/*--------------------------------------------------------------------------------------------------------------------------

                                            C ve Sistem Programcıları Derneği

                                UNIX/Linux Sistem Programlama Kursunda Yapılan Örnekler ve Özet Notlar
                                                      2. Bölüm

                                                Eğitmen: Kaan ASLAN

            Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.
            Kaynak belirtmek için aşağıdaki referansı kullanabilirsiniz:           

            Aslan, K. (2025), "UNIX/Linux Sistem Programlama Kursu", Sınıfta Yapılan Örnekler ve Özet Notlar, 
                C ve Sistem Programcıları Derneği, İstanbul.

                        (Notları sabit genişlikli font kullanan programlama editörleri ile açınız.)
                            (Editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz.)

                                          Son Güncelleme: 20/06/2025 - Cuma

---------------------------------------------------------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------------------------------------------------------
    Sinyal (signal) işlemleri UNIX/Linux sistemlerinde, sistem programlama etkinliklerinde yoğun bir biçimde kullanılmaktadır. 
    Bu nedenle bu sistemlerde programlama yapan programcıların sinyal işlemleri konusunda bilgi sahibi olması gerekmektedir. 
    Sinyal işlemleri kapsamlı bir konudur. Biz kursumuzun bu bölümünde bu işlemlerin temelleri ve ayrıntıları üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sinyal mekanizması kesme (interrupt) mekanizmasına benzetilebilir. Sinyaller UNIX/Linux sistemlerinde asenkron işlem 
    yapılmasına olanak sağlayan bir mekanizmadır. Sinyaller normal olarak proseslere gönderilmektedir. Ancak thread konusunun 
    işletim sistemlerine eklenmesiyle thread'lere de sinyal gönderilmesi mümkün hale getirilmiştir. (Ancak thread'lerin yalnızca 
    ilgili proses içerisinde erişilebilen bir kaynak olduğunu anımsayınız. Thread'lerin id değerleri ilgili proseste anlamlı 
    değerlerdir.) Bir sinyal prosese gönderildiğinde prosesin akışı kesilir, ismine sinyal fonksiyonu (signal handler) denilen 
    bir fonksiyon çalıştırılır. Sinyal fonksiyonu bitince akış kalınan yerden devam eder. Bu mekanizma kod çalışırken araya 
    asenkron biçimde başka işlemlerin girebilmesine olanak sağlamaktadır.

    Sinyalin oluşmasına yol açan çeşitli durumlar söz konusu olabilmektedir. Örneğin sinyal işletim sistemi tarafından prosese
    belli koşullar altında gönderiliyor olabilir. Programcının yaptığı çeşitli ihlallerde de işletim sistemi tarafından prosese
    sinyaller gönderilebilmektedir. Bazı sinyaller bazı aygıt sürücüleri tarafından prosese gönderilebilmektedir. Örneğin terminal 
    aygıt sürücüsü, prosesin ilişkin olduğu terminalde kullanıcı Ctrl+C gibi Ctrl+Backspace gibi tuşlara bastığında oturumun ön plan 
    proses grubuna bazı sinyalleri gönderebilmektedir. Sinyaller programlama yoluyla da bir prosesten diğerine gönderilebilmektedir. 
    Bazı POSIX fonksiyonları da kendi içlerinde bazı koşullarda ilgili proseslere sinyaller gönderebilmektedir.

    Bir sinyal bir prosese gönderildiğinde prosesin hangi thread'inin çalışmasına ara verilip sinyal fonksiyonunu çalıştıracağı 
    POSIX standartlarında işletim sisteminin isteğine bırakılmıştır. Yani örneğin bizim toplamda beş thread'imiz varsa prosese 
    bir sinyal gönderildiğinde bu beş thread'ten herhangi biri çalışmasına ara verip sinyal fonksiyonunu çalıştırabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Her sinyalin bir numarası vardır. Sinyallere ilişkin numaralar POSIX sistemlerinde işletim sistemini yazanların isteğine 
    bırakılmıştır. Ancak taşınabilirlik sağlamak için sinyal numaraları <signal.h> dosyası içerisinde SIGXXX biçiminde sembolik 
    sabitlerle define edilmiştir. Konuşurken ve program yazarken sinyallerin numaraları değil (çünkü taşınabilir değiller) bu 
    sembolik sabit isimleri kullanılmaktadır. UNIX/Linux sistemlerinde kullanılan tipik sinyaller şunlardır:

    SIGABRT
    SIGALRM
    SIGBUS
    SIGCANCEL
    SIGCHLD
    SIGCONT
    SIGEMT
    SIGFPE
    SIGFREEZE
    SIGHUP
    SIGILL
    SIGINFO
    SIGINT
    SIGIO
    SIGIOT
    SIGJVM1
    SIGJVM2
    SIGKILL
    SIGLOST
    SIGLWP
    SIGPIPE
    SIGPOLL
    SIGPROF
    SIGPWR
    SIGQUIT
    SIGSEGV
    SIGSTKFLT
    SIGSTOP
    SIGSYS
    SIGTERM
    SIGTHAW
    SIGTHR
    SIGTRAP
    SIGTSTP
    SIGTTIN
    SIGTTOU
    SIGURG
    SIGUSR1
    SIGUSR2
    SIGVTALRM
    SIGWAITING
    SIGWINCH
    SIGXCPU
    SIGXFSZ
    SIGXRES
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir sinyal oluştuğunda eğer programcı o sinyal için bir "sinyal fonksiyonu (signal handler)" set etmişse bu sinyal fonksiyonu 
    çağrılmaktadır. Eğer programcı sinyal için bir sinyal fonksiyonu set etmemişse bu durumda "default eylem (default action)" 
    uygulanmaktadır. Default eylem sinyalden sinyale değişebilmektedir. Bazı sinyallerde default eylem "sinyalin görmezlikten 
    gelinmesi (ignore)" iken, bazı sinyallerde "prosesin sonlandırılması (terminate)" biçimindedir. Bazı sinyallerde default 
    eylem "prosesin sonlandırılması ve bir core dosyasının oluşturulması" biçimindedir. Core dosyaları "teşhis amacıyla" oluşturulan 
    ve debugger altında incelenebilen özel dosyalardır. Tabii programcı bu default eylemleri sinyal temelinde öğrenmelidir. 
    Aşağıda sinyallerin default eylemlerinin ne olduğuna ilişkin bir liste verilmiştir:

    Sinyal                      Default Eylem
    -------                     ---------------
    SIGABRT                     terminate+core
    SIGALRM                     terminate
    SIGBUS                      terminate+core
    SIGCANCEL                   ignore
    SIGCHLD                     ignore
    SIGCONT                     continue/ignore
    SIGEMT                      terminate+core
    SIGFPE                      terminate+core
    SIGFREEZE                   ignore
    SIGHUP                      terminate
    SIGILL                      terminate+core
    SIGINFO                     ignore
    SIGINT                      terminate
    SIGIO                       terminate/ignore
    SIGIOT                      terminate+core
    SIGJVM1                     ignore
    SIGJVM2                     ignore
    SIGKILL                     terminate
    SIGLOST                     terminate
    SIGLWP                      terminate/ignore
    SIGPIPE                     terminate
    SIGPOLL                     terminate
    SIGPROF                     terminate
    SIGPWR                      terminate/ignore
    SIGQUIT                     terminate+core
    SIGSEGV                     terminate+core
    SIGSTKFLT                   terminate
    SIGSTOP                     stop process
    SIGSYS                      terminate+core
    SIGTERM                     terminate
    SIGTHAW                     ignore
    SIGTHR                      terminate
    SIGTRAP                     terminate+core
    SIGTSTP                     stop process
    SIGTTIN                     stop process
    SIGTTOU                     stop process
    SIGURG                      ignore
    SIGUSR1                     terminate
    SIGUSR2                     terminate
    SIGVTALRM                   terminate
    SIGWAITING                  ignore
    SIGWINCH                    ignore
    SIGXCPU                     terminate or terminate+core
    SIGXFSZ                     terminate or terminate+core
    SIGXRES                     ignore
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir sinyal oluşturulduğunda önce sinyal prosese teslim edilir ("deliver" işlemi). Proses kendine gelen sinyali mümkün olduğu
    kadar çabuk işlemek ister. Eğer ilgili sinyal için bir sinyal fonksiyonu set edilmişse proses çok gecikmeden bu sinyal 
    fonksiyonunu çağırmak isteyecektir. Sinyalin oluşmasıyla prosese teslim edilmesi arasındaki ara duruma "sinyalin askıda 
    (pending durumda olması)" denilmektedir. Eğer akış o anda bir sistem fonksiyonunun içerisindeyse ve o sistem fonksiyonu 
    uzun sürecek bir eylem başlatmışsa ya da açıkça bloke olmuşsa bu durumda işletim sistemi ilgili sistem fonksiyonunu başarısızlıkla
    sonuçlandırır ve bir an evvel sinyal fonksiyonunu çalıştırır. Tabii biz sistem fonksiyonlarını doğrudan değil POSIX fonksiyonları
    yoluyla kullanmaktayız. Böylece bu tür durumlarda çağırdığımız POSIX fonksiyonları sinyal dolayısıyla başarısız olabilmektedir. 
    Eğer bir POSIX fonksiyonu sinyal dolayısıyla başarısız olursa bu durumda errno değişkeni EINTR özel değeriyle set edilmektedir. 
    Örneğin biz bir borudan read fonksiyonuyla okuma yapmak isteyelim. Ancak boruda okunacak hiç byte olmasın. Bu durumda read 
    fonksiyonu blokeye yol açacaktır. İşte bu sırada prosese bir sinyal gelirse read fonksiyonu başarısızlıkla (yani -1 değeriyle)
    geri döner ve errno değişkeni EINTR değeriyle set edilir. Bu tür durumlarda biz fonksiyonun sinyal dolayısıyla başarısız 
    olduğunu anlayıp onu yeniden çağırmamız gerekir. Örneğin:

    while ((result = read(...)) == -1 && errno == EINTR)
        ;
    if (result == -1)
        exit_sys("read");

    Ancak programcı isterse bu tür POSIX fonksiyonlarının "otomatik biçimde yeniden çağrılmasını (automatic restart)" da 
    sağlayabilmektedir. Eğer programcı bunu sağlamışsa bu durumda fonksiyon hiç geri dönmez, ancak sinyal fonksiyonu çalıştırılır. 
    Bu otomatik çalıştırma işlemi kütüphane tarafından değil çekirdek tarafından sağlanmaktadır.

    Tabii bir sistem fonksiyonunun ya da onu çağıran POSIX fonksiyonunun sinyal nedeniyle başarısız olması için o fonksiyonun 
    "yavaş bir fonksiyon" olması gerekir. Programcı, çağırdığı sistem fonksiyonlarının ya da onu çağıran POSIX fonksiyonlarının 
    sinyal karşısındaki davranışını bilmek zorundadır. Tabii bir sinyal için sinyal fonksiyonu set edilmemişse ve default eylem 
    prosesin sonlanmasıysa zaten bu durumda ilgili sistem fonksiyonunun ya da onu çağıran POSIX fonksiyonunun başarısızlığının
    bir önemi de kalmamaktadır. Yavaş fonksiyon "sistem fonksiyonunun içerisinde göreli biçimde uzun zaman beklenebilmesi" 
    anlamına gelmektedir. Örneğin read fonksiyonu ile biz bir disk dosyasından (regular file) okuma yaparken sinyal oluştuğunda
    bu yavaş bir işlem değildir. Genellikle işletim sistemlerinin çekirdekleri okuma bitip, fonksiyon başarıyla sonlandıktan
    sonra set edilmiş olan sinyal fonksiyonunu çağırmaktadır. Ancak örneğin read fonksiyonu ile bir borudan okuma yapıyorsak 
    ve boruda hiç bilgi yoksa bu durumda read fonksiyonu yavaş bir sistem fonksiyonu durumundadır. Çünkü read fonksiyonu
    bu durumda blokeye yol açıp uzun süre bekleme oluşturabilmektedir. Yani sistem fonksiyonunun yavaş olması demekle genellikle
    blokeye yol açabilmesi kastedilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                73. Ders 13/08/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir sinyal oluştuğunda programcının kendi belirlediği fonksiyonun çağrılması (yani sinyal fonksiyonunun set edilmesi) iki
    POSIX fonksiyonu ile sağlanmaktadır: signal fonksiyonu ve sigaction fonksiyonu. Maalesef POSIX standartları oluşturulduğunda
    signal fonksiyonunun davranışı konusunda UNIX türevi sistemler arasında (özellikle AT&T ve Berkeley sistemleri arasında)
    farklılıklar söz konusuydu. POSIX standartları oluşturulurken bu farklılıklar bilindiği için signal fonksiyonu "öyle de 
    davranabilir böyle de davranabilir" biçiminde standartlara sokuldu. Bu durum da tabii sistemler arasında taşınabilirlik 
    sorunları oluşturmaktaydı. İşte signal fonksiyonunun bu taşınabilirlik sorunu sigaction fonksiyonuyla çözülmüştür. sigaction
    fonksiyonu POSIX standartlarına sokulduğunda fonksiyonun semantiği sistemler arasında farklılık oluşturmayacak biçimde 
    tanımlanmıştır. Biz kursumuzda önce signal fonksiyonunu sonra sigaction fonksiyonunu göreceğiz. Yukarıda da belirttiğimiz 
    gibi signal fonksiyonundaki semantik taşınabilir değildir. Bu nedenle programcıların sigaction fonksiyonunu kullanması 
    iyi bir tekniktir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    signal fonksiyonunun prototipi şöyledir:

    #include <signal.h>

    void (*signal(int sig, void (*func)(int)))(int);

    signal fonksiyonunun birinci parametresi set edilecek sinyale ilişkin sinyal numarasını belirtmektedir. İkinci parametre 
    ise sinyal oluştuğunda çağrılacak sinyal fonksiyonunun adresini almaktadır. Sinyal fonksiyonlarının geri dönüş değeri void
    parametreleri int türden olmak zorundadır. signal fonksiyonunun geri dönüş değeri de "parametresi int, geri dönüş değeri 
    void olan" bir fonksiyon adresidir. Fonksiyon başarı durumunda önceki sinyal fonksiyonunun adresi ile geri döner. Başarısızlık
    durumunda SIG_ERR özel değeri ile geri dönmektedir. SIG_ERR <signal.h> içerisinde başarısızlığı anlatan bir değer olarak 
    define edilmiştir. Örneğin:

    ...
    if (signal(SIGINT, sigint_handler) == SIG_ERR)
        exit_sys("signal");
    ...

    void sigint_handler(int sno)
    {
        ...
    }

    Sinyal fonksiyonunun parametresi ne anlam ifade etmektedir? İşletim sistemi oluşan sinyalin numarasını sinyal fonksiyonuna
    parametre olarak aktarmaktadır. Bu sayede programcı farklı sinyaller için aynı sinyal fonksiyonunu set edebilir. Fonksiyonun
    içerisinde bu parametre yardımıyla hangi sinyal nedeniyle fonksiyonun çağrılmış olduğunu belirlenebilir.

    signal fonksiyonunun ikinci parametresi için SIG_DFL ve SIG_IGN özel değeri girilebilir. SIG_DFL sinyali "default duruma"
    çekmek için kullanılmaktadır. Yani bu değer "sanki hiç sinyal fonksiyonu set edilmemiş gibi" bir etki oluşturmaktadır. 
    SIG_IGN ise "sinyali görmezden gelme yani ignore etme" için kullanılmaktadır. Bir sinyal SIG_IGN ile ignore edilirse bu 
    sinyal oluştuğunda sanki sinyal oluşmamış gibi bir davranış gösterilir. İleride de açıklayacağımız gibi her sinyal 
    ignore edilememektedir. Tabii signal fonksiyonunun geri dönüş değeri sinyale göre SIG_DFL ve SIG_IGN biçiminde de olabilmektedir. 
    Örneğin biz bir sinyali ilk kez set ediyorsak önceki sinyal fonksiyonu muhtemelen SIG_DFL ya da SIG_IGN biçiminde olacaktır.

    void (*old_handler)(int);

    if ((old_handler = signal(SIGINT, sigint_handler)) == SIG_ERR)
        exit_sys("signal");

    if (old_handler == SIG_DFL)
        printf("yes, old handler is SIG_DFL\n");

    Aşağıdaki örnekte SIGINT sinyali için bir sinyal fonksiyonu set edilmiştir. Daha önceden de belirttiğimiz gibi SIGINT sinyali
    terminal aygıt sürücüsü tarafından Ctrl+C tuşlarına basıldığında prosese gönderilmektedir. Bu sinyalin default davranışı 
    (default action) prosesin sonlandırılmasıdır. Tabii biz SIGINT için bir sinyal fonksiyonu set edersek proses sonlandırılmaz
    ve bizim set ettiğimiz fonksiyon çağrılır. Aşağıdaki programı çalıştırınca artık Ctrl+C tuşu ile programı sonlandıramayacağız. 
    Bunun için terminali kapatabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

void sigint_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    if (signal(SIGINT, sigint_handler) == SIG_ERR)
        exit_sys("signal");

    for (;;)
        ;

    return 0;
}

void sigint_handler(int sno)
{
    printf("signal occurred...\n");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    alarm isimli POSIX fonksiyonu belli bir süre dolduğunda onu çağıran prosese (yani kendi prosesine) SIGALRM isimli sinyali
    göndermektedir. Bu sinyalin default davranışı (default action) prosesin sonlandırılması biçimindedir. alarm fonksiyonunu 
    birden fazla çağırdığımızda bunlar biriktirilmez. Her yeni çağrı, eski çağrıyı devre dışı bırakarak yeniden alarmı set 
    etmektedir. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    unsigned alarm(unsigned seconds);

    Fonksiyon saniye sayısını parametre olarak almaktadır. Yani bu saniye dolduğunda fonksiyon SIGALRM sinyalini oluşturacaktır. 
    Fonksiyon eğer daha önce alarm fonksiyonu çağrılıp set işlemi yapıldıysa o set işlemi için kalan saniye sayısını vermektedir. 
    Eğer daha önce alarm fonksiyonu çağrılmamışsa ya da çağrıldığı halde zaten süre dolmuşsa fonksiyon 0 değeri ile geri dönmektedir. 
    Fonksiyon başarısız olamaz.

    alarm fonksiyonuna argüman olarak 0 değeri geçilirse bu durum önceki alarm işleminin devre dışı bırakılacağı anlamına gelmektedir. 
    Yani bu durum sanki alarm fonksiyonu daha önce hiç çağrılmamış gibi bir durum oluşturmaktadır.

    Aşağıdaki örnekte alarm fonksiyonu 5 saniyeye kurulmuştur. 5 saniye dolduktan sonra SIGALRM sinyali prosese gönderilecektir. 
    Program bu sinyal oluştuğunda bir sinyal fonksiyonu set ederek ekrana "ALARM" yazısının çıkartılmasını sağlamıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sigalrm_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    if (signal(SIGALRM, sigalrm_handler) == SIG_ERR)
        exit_sys("signal");

    alarm(5);

    for (int i = 0; i < 10; ++i) {
        printf("%d\n", i);
        sleep(1);
    }

    return 0;
}

void sigalrm_handler(int sno)
{
    printf("ALARM\n");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi signal fonksiyonun semantiği maalesef taşınabilir değildir. Bu fonksiyonunun davranışı 
    çeşitli sistemlerde aşağıda açıklayacağımız gibi farklılıklar gösterebilmektedir. signal fonksiyonundaki problemler
    ve semantik farklılıklar şunlardır:

    1) Eski AT&T UNIX sistemlerinde ve o kökten gelen sistemlerde signal fonksiyonu ile bir sinyal set edilip sinyal oluştuğu 
    zaman sinyal yeniden default duruma çekiliyordu. Böylece sanki sinyal set edilmemiş gibi bir etki oluşuyordu. Bu sistemlerde 
    eskiden bu etkiyi ortadan kaldırmak için programcılar sinyal fonksiyonunun (signal handler) hemen başında sinyal default'a 
    çekildiği için yeniden set işlemi yapıyorlardı. Örneğin:

    void signal_handler(int sno)
    {
        if (signal(SIGXXX, signal_handler) == SIG_ERR)
            exit_sys("signal");
        ...
    }

    Böylece sinyal default'a çekildiğinde yeniden sinyal set ediliyordu. Ancak üst üste aynı sinyalin oluştuğu durumlarda 
    prosesin sonlandırılmasına yönelik bir durum her zaman mümkün olabilmekteydi:

    void signal_handler(int sno)
    {
        ----> BU NOKTADA AYNI SİNYALDEN OLUŞSA SİNYAL DEFAULT'A ÇEKİLDİĞİ İÇİN PROSES SONLANDIRILACAKTIR!

        if (signal(SIGXXX, signal_handler) == SIG_ERR)
            exit_sys("signal");
        ...
    }

    AT&T ve türevlerinde yukarıdaki duruma ilişkin bir önlem alınamıyordu. Ancak daha sonra BSD UNIX sistemleri bu problemi
    "sinyalin default'a çekilmemesi" biçiminde değiştirerek çözmeye çalışmıştır. BSD ve türevlerinde sinyal default'a 
    çekilmemektedir. Linux sistemlerinde, signal sistem fonksiyonu AT&T semantiğini uygulamakta ve sinyali default'a çekmektedir. 
    Ancak signal fonksiyonu glibc kütüphanesinin belli versiyonundan sonra signal sistem fonksiyonu yerine sigaction sistem 
    fonksiyonu kullanılarak yazıldığı için sinyali default'a çekmemektedir. Yani Linux'ta signal POSIX fonksiyonu AT&T değil, 
    BSD semantiğini uygulamaktadır. POSIX standartları, AT&T ve BSD sistemlerindeki farklılıkların geçerli olabilmesi için 
    sinyal oluştuğunda oluşan sinyalin default'a çekilip çekilmeyeceğini işletim sistemlerini yazanların isteğine bırakmıştır.

    2) AT&T ve bu kökten gelen UNIX türevi sistemlerde bir sinyal oluştuğunda o sinyal, sinyal fonksiyonu çalıştığı sürece
    bloke edilmiyordu. Yani aynı sinyalden üst üste gelebiliyordu. Bu durum sinyal fonksiyonun iç içe birden fazla kez 
    çalıştırılmasına yol açabilmektedir. Bunun da "stack taşması (stack overflow)" gibi bazı sakıncaları söz konusu olabilmektedir. 
    BSD UNIX sistemleri bu problemi çözmüştür. BSD sistemlerinde bir sinyal oluştuğunda sinyal fonksiyonundan çıkılana kadar aynı
    sinyal bir daha oluşamamaktadır. Bu duruma ileride de göreceğimiz gibi "sinyalin bloke edilmesi" denilmektedir. Yani BSD 
    sistemleri sinyal fonksiyonu çalıştığı sürece aynı sinyali bloke etmekte ve böylece iç içe sinyalin oluşmasını engellemektedir. 
    Linux'un signal sistem fonksiyonu bu konuda da AT&T semantiğini uygulamaktadır. Ancak signal fonksiyonu glibc kütüphanesinin 
    belli bir versiyonundan sonra sigaction sistem fonksiyonunu çağırmaktadır ve BSD semantiğini uygulamaktadır. Yani Linux sistemlerinde
    signal fonksiyonu ile sinyal set edildiğinde sinyal fonksiyonu çalıştığı sürece proses ilgili sinyale bloke edilmektedir. POSIX 
    standartları sinyal fonksiyonu çalıştığı sürece aynı sinyalin bloke edilip edilmeyeceğini işletim sistemini yazanların 
    isteğine bırakmıştır.

    3) signal fonksiyonunun diğer bir problemi de yavaş sistem fonksiyonlarında "otomatik restart" yapılıp yapılmayacağının 
    sistemler arasında değişebilmesidir. AT&T ve bu kökten gelen UNIX türevi sistemlerde yavaş sistem fonksiyonları başarısız olmakta
    ve errno değeri EINTR olarak set edilmektedir. Halbuki BSD sistemlerinde signal fonksiyonu ile sinyal fonksiyonu set edildiğinde
    otomatik restart işlemi yapılmaktadır. Linux sistemlerinde signal sistem fonksiyonu AT&T semantiğini kullandığı için otomatik 
    restart yapmamaktadır. Ancak yukarıda da belirttiğimiz gibi signal fonksiyonu glibc kütüphanesinin belli bir versiyonundan 
    sonra sigaction sistem fonksiyonu çağrılarak yazılmıştır ve otomatik restart işlemi yapılmaktadır. POSIX standartlarında 
    signal fonksiyonu ile bir sinyal set edildiğinde otomatik restart işleminin yapılıp yapılmayacağı işletim sistemlerini 
    yazanların isteğine bırakılmıştır.

    Bu durumda Linux sistemlerindeki glibc kütüphanesinde bulunan signal fonksiyonu "sinyali default'a çekmemekte, sinyali sinyal
    fonksiyonu çalıştığı sürece bloke etmekte ve otomatik restart işlemini uygulamaktadır."
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                74. Ders 13/08/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    sigaction fonksiyonu signal fonksiyonunun oldukça iyileştirilmiş bir biçimidir. sigaction fonksiyonunda signal fonksiyonundaki
    semantik belirsizlikler kaldırılmıştır. Dolayısıyla programcıların sinyal fonksiyonlarını signal fonksiyonu yerine sigaction
    fonksiyonu ile set etmesi iyi bir tekniktir. Ancak sigaction fonksiyonunun kullanımı signal fonksiyonundan daha zordur. 
    sigaction fonksiyonunun prototipi şöyledir:

    #include <signal.h>

    int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);

    Fonksiyonun birinci parametresi yine set edilecek sinyalin numarasını belirtmektedir. Fonksiyonun ikinci parametresi 
    sigaction isimli bir yapı nesnesinin adresini almaktadır. Programcı sinyal set işlemi ile ilgili bazı bilgileri sigaction
    türünden yapı nesnesinin içerisine yerleştirir. Sonra bu nesnenin adresini fonksiyona verir. Fonksiyonun üçüncü parametresi
    NULL geçilebilir. Ancak NULL geçilmezse daha önceki sinyal set özellikleri bu parametreye adresi geçirilen sigaction türünden 
    nesneye yerleştirilecektir. Fonksiyonun ikinci parametresi de NULL adres geçilebilmektedir. Bu durumda programcı eski 
    sinyal set bilgilerini alır, ancak onu değiştirmez. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine 
    geri döner. errno değişkeni uygun biçimde set edilmektedir.

    sigaction fonksiyonun kullanımındaki en önemli nokta şüphesiz sigaction yapı nesnesinin içinin doldurulmasıdır. sigaction 
    yapısı <signal.h> başlık dosyasında şöyle bildirilmiştir:

    struct sigaction {
        void (*sa_handler)(int);
        void (*sa_sigaction)(int, siginfo_t *, void *);
        sigset_t sa_mask;
        int sa_flags;
    };

    Yapının sa_handler elemanı sinyal oluştuğunda çağrılacak fonksiyonun (signal handler) adresini almaktadır. Bu elemana
    geri dönüş değeri void, parametresi int olan bir fonksiyonun adresi geçirilmelidir. UNIX/Linux sistemlerine daha sonraları 
    "güvenilir sinyaller (reliable signals)" adı altında bazı semantik eklemeler yapılmıştır. Bu eklemelerden biri de sinyal 
    fonksiyonunun (signal handler) detaylandırılmasıdır. Yapının sa_sigaction elemanı da sinyal oluştuğunda çağrılacak fonksiyonu
    belirtmektedir. Ancak bu fonksiyonun parametrik yapısı daha değişiktir. Tabii programcı yapının iki elemanına da fonksiyon 
    girmez. Bunlardan birine fonksiyon girer. sigaction fonksiyonun sinyal oluştuğunda yapının hangi elemanındaki sinyal fonksiyonunu
    çağıracağı yapının sa_flags elemanında belirtilmektedir. Default durum yapının sa_handler elemanında belirtilen klasik tarzda 
    sinyal fonksiyonunun çağrılmasıdır. Yapının sa_handler ya da sa_sigaction elemanlarına yine signal fonksiyonunda olduğu gibi 
    SIG_DFL ve SIG_IGB özel değerleri girilebilmektedir.

    sigaction yapısının sa_mask elemanı sinyal bloke (mask) kümesini belirtmektedir. Default durumda bir sinyal oluştuğu 
    zaman sinyal fonksiyonu çağrıldığında zaten artık aynı numaralı sinyal, sinyal fonksiyonu çalıştığı sürece bloke olmaktadır. 
    Bir sinyalin bloke olması, o sinyal oluştuğunda işletim sisteminin sinyali prosese teslim etmemesi ve askıda (pending durumda) 
    bekletmesi anlamına gelmektedir. Ancak sinyaller biriktirilmez. Yani örneğin bir sinyal oluşup sinyal fonksiyonu çağrıldığında 
    o sinyalden beş kez daha oluşsa bloke açıldığında sinyal fonksiyonu yalnızca bir kez çalıştırılmaktadır. Ancak programcı 
    isterse "sinyal fonksiyonu çalıştığı sürece" oluşan sinyalin yanı sıra başka sinyallerin de bloke edilmesini sağlayabilmektedir. 
    Bunun için yapının sa_mask elemanı kullanılmaktadır. sa_mask elemanının sigset_t türünden olduğuna dikkat ediniz. Bu sigset_t 
    türü bir bit dizisi gibi düşünülmelidir. Yani bu türün çeşitli bitleri çeşitli sinyallerin bloke edilip edilmeyeceğini 
    belirtmektedir. İşte bu türün çeşitli bitlerini set etmek ve reset etmek için bazı fonksiyonlar bulundurulmuştur. Bu fonksiyonlar 
    makro biçiminde de yazılabilmektedir. Bu fonksiyonların (ya da makroların) listesi şöyledir:

    #include <signal.h>

    int sigemptyset(sigset_t *set);
    int sigfillset(sigset_t *set);
    int sigaddset(sigset_t *set, int signum);
    int sigdelset(sigset_t *set, int signum);
    int sigismember(const sigset_t *set, int signum);

    sigemptyset fonksiyonu bit dizisi içerisindeki tüm bitleri reset etmektedir. sigfillset fonksiyonu ise tüm bitleri set 
    etmektedir. sigaddset fonksiyonu bit dizisi içerisindeki ilgili sinyale ilişkin biti set etmektedir. sigdelset fonksiyonu 
    ise bit dizisi içerisindeki ilgili sinyale ilişkin biti reset etmektedir. sigismember fonksiyonu belli bir sinyale ilişkin 
    bitin bit dizisi içerisindeki değerini yani (yani set ya da reset olduğunu) bize vermektedir. Fonksiyonlar başarı durumunda 0, 
    başarısızlık durumunda -1 değerine geri dönmektedir. Ancak sigismember başarı durumunda 0 ya da 1 değerine, başarısızlık 
    durumunda -1 değerine geri döner. Tabii bu fonksiyonların başarısının kontrol edilmesine gerek yoktur. Örneğin biz sigset_t 
    bit dizisinde yalnızca SIGINT ve SIGTERM sinyali için ilgili bitleri set etmek isteyelim. Bu işlemi aşağıdaki gibi yapabiliriz:

    sigset_t sset;

    sigemptyset(&sset);
    sigaddset(&sset, SIGINT);
    sigaddset(&sset, SIGTERM);

    Biz burada herhangi bir bloke işlemi yapmadık. Yalnızca bir belirleme yaptık.

    İşte sigaction yapısının sa_mask elemanında sinyallere ilişkin set edilen bitler sinyal fonksiyonu çalıştığı sürece bloke 
    edilecektir. Örneğin:

    struct sigaction sa;

    sa.sa_handler = signal_handler;

    sigemptyset(&sa.sa_mask);
    sigaddset(&sa.sa_mask, SIGINT);
    sigaddset(&sa.sa_mask, SIGTERM);
    ...

    if (sigaction(SIGALRM, &sa, NULL) == -1)
        exit_sys("sigaction");

    Burada SIGALRM sinyali için set edilmiş olan sinyal fonksiyonu çalıştığı sürece SIGINT ve SIGTERM sinyalleri bloke edilecektir. 
    Zaten default durumda ilgili sinyalin kendisinin de sinyal fonksiyonu çalıştığı sürece bloke edildiğini belirtmiştik. Burada 
    bloke sürekli değil yalnızca sinyal fonksiyonu çalıştığı sürece söz konusu olmaktadır. Sinyal fonksiyonun çalışması bittiğinde
    sinyal işleme sokulacaktır.

    Programcı, yapının sa_mask elemanına değer atamalıdır. Bildiğiniz gibi yerel nesnelerin içerisinde rastgele değerler vardır. 
    Yapı nesnesi global olsa bile içi sıfırlanan nesnelerin bu bağlamda içi boş bir bit dizisi belirtmesi garanti değildir. 
    Örneğin biz yapının bu elemanına şöyle değer atayabiliriz:

    sigemptyset(&sa.sa_mask);

    Bu durumda sinyal fonksiyonu çalışırken ilgili sinyal dışındaki hiçbir sinyal bloke edilmeyecektir.

    sigaction yapısının sa_flags elemanı bazı sembolik sabitlerin bit OR işlemine sokulmasıyla oluşturulmaktadır. Bu bayrakların 
    her birinin bir anlamı vardır:

    SA_RESETHAND: Bu bayrak set edilirse sinyal fonksiyonu çalıştırıldığında sinyal otomatik olarak default'a çekilir. 
    Default durumda bu bayrağın set edilmediğine dikkat ediniz. Bu bayrak AT&T semantiğinin uygulanabilmesi için bulundurulmuştur.

    SA_RESTART: Bu bayrak set edilirse yavaş POSIX fonksiyonlarında (yani onların çağırdığı sistem fonksiyonlarında) sinyal 
    oluştuğunda sinyal fonksiyonu çağrılır ancak fonksiyon başarısızlıkla sonuçlanmaz. Çünkü sistem fonksiyonunun restart 
    edilmesi çekirdek tarafından otomatik yapılmaktadır. Bu biçimde set edilmiş bir sinyal fonksiyonu söz konusu olduğunda 
    ilgili sistem fonksiyonları sinyal dolayısıyla başarısız olmayacaktır. Anımsanacağı gibi AT&T'nin signal fonksiyonu 
    otomatik restart işlemi yapmamaktadır. Ancak BSD'lerin ve Linux'un signal fonksiyonu zaten otomatik restart işlemi yapmaktadır.

    SA_SIGINFO: Bu bayrak belirtilirse sinyal fonksiyonu için sigaction yapısının sa_handler elemanı değil, sa_sigaction elemanı 
    dikkate alınmaktadır. Tabi bu durumda sinyal fonksiyonun da (signal handler) parametrik yapısı değişmektedir. Bu konu 
    "gerçek zamanlı sinyalleri (realtime signals)" ele alacağımız paragraflarda açıklanacaktır.

    SA_NODEFER: Anımsanacağı gibi default durumda her zaman bir sinyal oluştuğunda sinyal fonksiyonu çalıştığı sürece o sinyal
    bloke edilmektedir. Yani iç içe aynı sinyalden oluşamamaktadır. Ancak bu bayrak kullanılırsa sinyal fonksiyonu çalıştığı sürece
    o sinyal bloke edilmeyecek ve sinyal fonksiyonu iç içe çağrılabilecektir. Anımsanacağı gibi signal fonksiyonundaki AT&T semantiği
    zaten böyleydi. Ancak BSD ve Linux sistemlerindeki semantik, aynı sinyalin sinyal fonksiyonu çalıştığı sürece bloke edilmesi 
    biçimindeydi.

    SA_NOCLDWAIT: Bu bayrak SIGCHLD sinyali için anlamlıdır. Otomatik olarak zombie proses oluşmasını engellemek için kullanılmaktadır. 
    Bu bayrak set edilip proses sonlandığında artık kaynaklarını wait fonksiyonlarını beklemeden serbest bırakır. Tabii programcı da
    böyle prosesler için artık wait işlemi yapmaz. Bu konu ayrı bir paragrafta açıklanacaktır.

    SA_NOCLDSTOP: Bu bayrak belirtildiğinde alt proses durdurulduğu zaman ya da yeniden çalışmaya devam ettirildiği zaman üst 
    prosese SIGCHLD sinyalini göndermemektedir. Bu konu da ileride ele alınacaktır.

    SA_ONSTACK: İç içe sinyaller oluştuğunda mevcut stack için taşma problemleri çok seyrek de olsa teorik olarak söz konusu 
    olabilmektedir. Bunun için alternatif stack kullanımı da mümkündür. İşte bu bayrak ilgili sinyal fonksiyonu çalışırken 
    alternatif stack kullanılacağını belirtmektedir. Alternatif stack'in ayrıca setaltstack fonksiyonu ile set edilmesi gerekmektedir.

    Aşağıda sigaction fonksiyonunun kullanımına bir örnek verilmiştir. Bu örnekte yapının sa_mask elemanı sigemptyset fonksiyonu 
    ile tamamen reset edilmiştir. Yani ilgili sinyal oluştuğunda, sinyal fonksiyonu çalıştığı sürece başka bir sinyal bloke edilmeyecektir. 
    Yapının sa_flags elemanına da 0 atanmıştır. Yani bu eleman için herhangi bir bayrak belirtilmemiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sigalrm_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;

    sa.sa_handler = sigalrm_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    if (sigaction(SIGALRM, &sa, NULL) == -1)
        exit_sys("sigaction");

    alarm(5);

    for (int i = 0; i < 10; ++i) {
        printf("%d\n", i);
        sleep(1);
    }

    return 0;
}

void sigalrm_handler(int sno)
{
    printf("ALARM\n");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi glibc kütüphanesindeki signal POSIX fonksiyonu belli bir versiyondan sonra signal sistem fonksiyonunu 
    çağırarak değil, sigaction fonksiyonunu çağırarak yazılmıştı. signal fonksiyonu "sinyali default'a çekmiyordu", "sinyal 
    fonksiyonu çalıştığı sürece aynı sinyali bloke ediyordu" ve "otomatik restart işlemi yapıyordu". O halde glibc kütüphanesindeki
    signal POSIX fonksiyonu sigaction fonksiyonu kullanılarak aşağıdaki gibi yazılabilir:

    void (*mysignal(int sig, void (*handler)(int)))(int)
    {
        struct sigaction sa, sa_old;

        sa.sa_handler = sigalrm_handler;
        sigemptyset(&sa.sa_mask);
        sa.sa_flags = SA_RESTART;

        if (sigaction(SIGALRM, &sa, &sa_old) == -1)
            return SIG_ERR;

        return sa_old.sa_handler;
    }

    Aşağıda yazdığımız fonksiyonun kullanımına örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sigalrm_handler(int sno);
void exit_sys(const char *msg);

void (*mysignal(int sig, void (*handler)(int)))(int)
{
    struct sigaction sa, sa_old;

    sa.sa_handler = sigalrm_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGALRM, &sa, &sa_old) == -1)
        return SIG_ERR;

    return sa_old.sa_handler;
}

int main(void)
{
    if (mysignal(SIGALRM, sigalrm_handler) == SIG_ERR)
        exit_sys("mysignal");

    alarm(5);

    for (int i = 0; i < 10; ++i) {
        printf("%d\n", i);
        sleep(1);
    }

    return 0;
}

void sigalrm_handler(int sno)
{
    printf("ALARM\n");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Sinyallerin proseslere gönderildiğini ve prosesin herhangi bir thread'i tarafından işletildiğini anımsayınız. İşte biz de 
    istersek bir prosese sinyal gönderebiliriz. Bunun için kill isimli POSIX fonksiyonu kullanılmaktadır. Maalesef bu fonksiyon
    yanlış isimlendirilmiştir. Kill sözcüğü İngilizce "öldürmek" ya da bu bağlamda "sonlandırmak" anlamına gelmektedir. Oysa kill 
    fonksiyonunun böyle bir amacı yoktur. Proseste ilgili sinyal için sinyal fonksiyonu set edilmemişse pek çok sinyalde zaten 
    default davranış (default action) prosesin sonlandırılması biçimindedir.

    kill fonksiyonunun prototipi şöyledir:

    #include <signal.h>

    int kill(pid_t pid, int sig);

    Fonksiyonun birinci parametresi sinyalin gönderileceği prosesin id değerini, ikinci parametresi gönderilecek sinyalin 
    numarasını almaktadır. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. 
    Fonksiyonun birinci parametresi aslında daha geniş bir kullanım alanına sahiptir. Fonksiyonun birinci parametresinin
    ayrıntılı açıklaması şöyledir:

    - Eğer bu parametre sıfırdan büyük bir değer olarak girilmişse (en çok kullanılan durum), sinyal yalnızca belirtilen id'ye
    sahip prosese gönderilmektedir.

    - Eğer bu parametre 0 girilirse sinyal, sinyali gönderen prosesin proses grup id'si ile aynı proses grup id'ye sahip olan 
    sinyal gönderme hakkının olabildiği tüm proseslere gönderilmektedir. Yani biz kendi proses grubumuzun tüm proseslerine bu 
    biçimde sinyal gönderebiliriz.

    - Eğer bu parametre -1 geçilirse sinyal, "sinyal gönderme hakkı" olan sistemdeki tüm proseslere gönderilmektedir.

    - Eğer bu parametre negatif bir değer olarak girilirse bu değerin mutlak değeri (yani pozitif hali) bir proses grup id
    kabul edilerek sinyal o proses grubunun "sinyal gönderme hakkına sahip olunan" tüm proseslerine gönderilmektedir.

    Burada sözünü ettiğimiz proses grubu kavramı izleyen bölümlerde ele alınacaktır.

    Genellikle kill ile sinyaller, bir prosesin sonlandırılması için gönderilmektedir. Ancak başka amaçlarla da sinyallerin 
    gönderilmesi söz konusu olabilmektedir.

    kill fonksiyonuyla bir prosese sinyal gönderebilmek için sinyali gönderen prosesin "gerçek ya da etkin kullanıcı id'sinin
    sinyalin gönderildiği prosesin gerçek ya da saklanmış kullanıcı id'si (saved-set-user id)" ile aynı olması gerekmektedir. 
    Saklanmış kullanıcı id'si (saved-set-user id) izleyen bölümlerde ele alınacaktır. Tabii eğer proses uygun önceliğe 
    (appropriate privileges) sahipse (yani Linux'ta root ya da uygun yeteneğe sahipse) proses herhangi bir prosese sinyal 
    gönderebilmektedir. Buradan çıkan özet şudur: Biz ancak kendi proseslerimize sinyal gönderebiliriz. Herhangi bir prosese 
    sinyal gönderebilmemiz için etkin kullanıcı id'mizin 0 olması (yani root proses olmamız) gerekir.

    Aşağıdaki örnekte "ssender.c" programı komut satırı argümanıyla aldığı sinyali, yine komut satırı argümanıyla aldığı id'ye 
    sahip prosese kill POSIX fonksiyonuyla göndermektedir. Sinyal numaralarının UNIX türevi sistemlerde aynı olmayabileceğine
    dikkat ediniz. Örneğin 12 numaralı sinyal farklı sistemlerde farklı olabilmektedir. Bu nedenle daha önce de belirttiğimiz 
    gibi sinyallerin numaraları yerine <signal.h> dosyası içerisindeki sembolik sabitler kullanılmalıdır. Tabii komut satırı 
    argümanları birer yazıdır. Sinyal isimlerini taşınabilir bir biçimde sinyal numaralarına dönüştüren standart bir POSIX
    fonksiyonu yoktur. (Ancak glibc kütüphanesinde bu amaçla kullanılabilecek standart olmayan bir fonksiyon bulunmaktadır.)
    Bu nedenle biz örnek programda, bir yapı dizisi oluşturup sinyal isimlerini manuel bir biçimde sinyal numaralarına 
    dönüştürdük. Örnek için iki terminal açınız. Terminalin birinde "sample" programını diğerinde "ssender" programını 
    çalıştırınız. "ssender" programından diğer programa sinyal gönderiniz. Tabii bunu yapabilmeniz için öncelikle "sample" 
    programının proses id'sini bilmeniz gerekir. Bunun için terminalde "ps -u" komutunu kullanabilirsiniz. Programın örnek 
    bir kullanımı şöyle olabilir:

    $ ./ssender TERM 12404

    Örneğimizde sinyal isimlerinde "SIG" önekinin kullanılmadığına dikkat ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* ssender.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

void exit_sys(const char *msg);

typedef struct tagSIGNAL_INFO {
    const char *name;
    int sig;
} SIGNAL_INFO;

SIGNAL_INFO g_signal_info[] = {
    {"INT", SIGINT},
    {"TERM", SIGTERM},
    {"KILL", SIGKILL},
    {"USR1", SIGUSR1},
    {NULL, 0},
    /* ... */
};

int main(int argc, char *argv[])
{
    pid_t pid;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }
    pid = (pid_t)atol(argv[2]);

    for (int i = 0; g_signal_info[i].name != NULL; ++i)
        if (!strcmp(argv[1], g_signal_info[i].name))
            if (kill(pid, g_signal_info[i].sig) == -1)
                exit_sys("kill");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sigusr1_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa, sa_old;

    sa.sa_handler = sigusr1_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGUSR1, &sa, &sa_old) == -1)
        exit_sys("sigaction");

    for (int i = 0; i < 60; ++i) {
        printf("%d\n", i);
        sleep(1);
    }

    return 0;
}

void sigusr1_handler(int sno)
{
    printf("SIGUSR1 handler running...\n");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Sinyal numaralarını alarak hata mesajları için sinyali betimleyen bir yazı veren strsignal isimli bir POSIX fonksiyonu 
    bulunmaktadır:

    #include <string.h>

    char *strsignal(int signum);

    Ayrıca glibc kütüphanesinde standart olmayan iki fonksiyon da vardır:

    #include <string.h>

    const char *sigdescr_np(int sig);
    const char *sigabbrev_np(int sig);

    sigdescr_np fonksiyonu strsignal fonksiyonuna benzerdir. sigabbrev_np fonksiyonu ise sinyal numarasından hareketle sinyal 
    ismini başında "SIG" öneki olmadan vermektedir. Bu fonksiyonları kullanmadan önce _GNU_SOURCE sembolik sabiti <string.h> 
    dosyasının yukarısında define edilmelidir. Ayrıca glibc kütüphanesinde eskiden bütün sinyal isimleri sys_siglist isimli 
    bir dizide toplanmıştı. (Bu dizinin uzunluğu NSIG sembolik sabiti kadardır.) Ancak bu dizi daha sonra deprecated yapılıp 
    kaldırılmıştır.

    Aşağıda bu fonksiyonlarının kullanımına yönelik bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

void exit_sys(const char *msg);

int main(void)
{
    printf("%s\n", strsignal(SIGTERM));
    printf("%s\n", sigabbrev_np(SIGTERM));
    printf("%s\n", sigdescr_np(SIGTERM));

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosese komut satırından sinyal göndermek için kill isimli bir kabuk komutu da bulunmaktadır. Bu kill kabuk komutu 
    zaten kill fonksiyonu kullanılarak yukarıda bizim yaptığımıza benzer biçimde kullanılmaktadır. kill komutu ile prosese 
    sinyal gönderirken sinyal ismi -TERM, -INT, _USR1 gibi başında "SIG" öneki olmadan belirtilmelidir. Örneğin:

    $ kill -TERM 12767        (SIGTERM sinyali gönderiliyor)
    $ kill -USR1 12767        (SIGUSR1 sinyali gönderiliyor)

    kill komutunda sinyalin ismi değil numarası da belirtilebilmektedir. Ancak sinyal numaralarının UNIX sistemleri genelinde 
    taşınabilir olmadığına dikkat ediniz. Örneğin:

    $ kill -15 12801        (Linux sistemlerinde SIGTERM sinyali gönderiliyor)
    $ kill -10 12801        (Linux sistemlerinde SIGUSR1 sinyali gönderiliyor)

    kill komutu hiç sinyal ismi ya da numarası belirtilmeden kullanılırsa default olarak SIGTERM sinyalini göndermektedir. 
    Örneğin:

    $ kill 12801

    Bu durumda prosese SIGTERM sinyali gönderilmektedir. Ancak örneğin:

    $ kill -KILL 12801

    Bu durumda prosese SIGKILL sinyali gönderilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                75. Ders 26/08/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosesi sonlandırmak için (kill etmek için) iki sinyal bulundurulmuştur: SIGTERM sinyali ve SIGKILL sinyali. Bu iki 
    sinyal birbirine benzerdir. Bu iki sinyalin de amacı prosesi sonlandırmaktır. Ancak bu iki sinyal arasında şöyle bir farklılık 
    vardır: SIGTERM sinyali proses tarafından bloke edilebilir, ignore edilebilir ya da bu sinyal için sinyal fonksiyonu set 
    edilebilir. Ancak SIGKILL sinyali ignore edilemez, bloke edilemez ve bu sinyal için sinyal fonksiyonu da set edilemez. 
    (Eğer signal ya da sigaction fonksiyonu ile SIGKILL sinyali için bir set işlemi yapılmaya çalışılırsa bu fonksiyonlar 
    başarısız olur ve errno değeri EINVAL ile set edilir.) Bu durumda bir prosesi garantili sonlandırmak için SIGTERM sinyali 
    değil, SIGKILL sinyali gönderilmelidir. Örneğin:

    $ kill -KILL 12801

    SIGTERM sinyalinin Linux sistemlerindeki numarası 15, SIGKILL sinyalinin ise 9'dur. Örneğin:

    $ kill -9 12801
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir proses id'ye ilişkin prosesin hala bulunuyor olduğunu, yani sonlanmamış olduğunu test etmenin çeşitli yöntemleri söz
    konusu olabilmektedir. Çok kullanılan yöntemlerden biri, kill fonksiyonu ile prosese 0 numaralı sinyali göndermektir. 
    0 numaralı sinyal aslında yoktur. 0 numara, sinyaller için bu amaçla kullanılmaktadır. Yani aslında 0 numaralı sinyal, 
    prosese hiç gönderilmemekte yalnızca bu tür test işlemleri için kullanılmaktadır. Biz kill fonksiyonu ile prosese 0 numaralı 
    sinyali gönderdiğimizde kill fonksiyonu başarılı olursa o prosesin sistemde bulunduğunu anlarız. Tabii proses sistemde 
    bulunduğu halde uygun önceliğe sahip olmadığından dolayı da başarısız olabilir. Bu durumda errno değişkeni EPERM değeri 
    ile set edilmektedir. Eğer prosesin var olmadığından dolayı kill fonksiyonu başarısız olmuşsa, bu durumda errno değişkeni 
    ESRCH değeri ile set edilmektedir. Bu durumda prosesin hala yaşadığının testi şöyle yapılabilir:

    if (kill(pid, 0) == -1) {
        if (errno == ESRCH) {
            /* proses sonlanmış */
        }
        exit_sys("kill);
    }

    /* proses sonlanmamış */
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sistemleri dünyasında bir fonksiyonun "senkron işlem" yapması demekle "fonksiyon geri döndüğünde o işin bitmiş 
    olmasının garanti edilmesi" anlaşılmaktadır. Örneğin read, write gibi fonksiyonlar senkron işlem yapmaktadır. read fonksiyonu
    geri döndüğünde okuma da bitmiş durumdadır. Bir fonksiyonun "asenkron işlem" yapması "fonksiyon geri döndüğünde o işlemin 
    bitmek zorunda olmadığı" anlamına gelmektedir. Örneğin kill fonksiyonu geri döndüğünde sinyalin ilgili proses tarafından 
    işlenmiş olduğunun bir garantisi yoktur. Bu durumda kill fonksiyonu "asenkron" bir işlem yapmaktadır. Örneğin "asenkron IO"
    işleminde biz bir fonksiyonla IO işlemini başlatırız ancak fonksiyon geri döndüğünde bu IO işlemi bitmiş olmak zorunda 
    değildir. Hala devam ediyor olabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    raise fonksiyonu bir prosesin kendisine sinyal göndermesi için kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <signal.h>

    int raise(int sig);

    Bu fonksiyonun eşdeğeri aşağıdaki gibi kill fonksiyonu kullanılarak da elde edilebilir. Fakat kill fonksiyonu asenkron 
    işlem sağlarken, raise fonksiyonu senkron bir işlem sağlamaktadır.

    kill(getpid(), sig);

    Fonksiyon gönderilecek sinyalin numarasını parametre olarak almaktadır. Başarı durumunda 0 değerine, başarısızlık durumunda 
    sıfır dışı herhangi bir değere (yani -1 olmak zorunda değil) geri dönmektedir. Tabii fonksiyon her zaman kendine sinyal 
    gönderebilir. Bu durumda başarısızlığın kontrol edilmesi gerekmez. (Tabii fonksiyona biz yanlış bir sinyal numarası geçersek 
    fonksiyon başarısız olabilmektedir.)

    POSIX standartlarına göre çok thread'li bir ortamda raise fonksiyonu hangi thread tarafından kullanılmışsa senkronluğu 
    sağlamak için sinyal fonksiyonu o thread tarafından çalıştırılmaktadır. Yani fonksiyon senkron işlem yapmasının dışında 
    aşağıdaki ile eşdeğerdir:

    pthread_kill(pthread_self(), sig);

    pthread_kill fonksiyonu izleyen paragraflarda ele alınacaktır. raise fonksiyonu aynı zamanda standart bir C fonksiyonudur. 
    Ancak C standartlarında sinyal konusu ayrıntılarıyla ele alınmış bir konu değildir. Yani C standartlarında bir sinyal 
    olgusundan bahsedilmiş ancak hiçbir ayrıntıya girilmemiştir.

    Anımsanacağı gibi Linux sistemlerinde aslında her thread'in bir "task struct" yapısı vardı ve proses id aslında task struct 
    yapısından elde ediliyordu. Yani aslında Linux sistemlerinde her thread'in bir pid değeri vardır. Bu değeri biz daha önce 
    gettid fonksiyonu ile elde etmiştik. O halde biz aslında kill fonksiyonunda thread'e ilişkin pid değerini kullanırsak zaten 
    sinyal adeta o thread'e gönderilmiş gibi bir etki oluşacaktır. Böylece biz Linux sistemlerinde başka bir prosesten, başka 
    bir prosesin thread'ine bu yolla sinyal gönderebilmekteyiz.

    Aşağıdaki örnekte proses kendine raise fonksiyonu ile SIGUSR1 sinyalini göndermektedir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sigusr1_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa, sa_old;

    sa.sa_handler = sigusr1_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGUSR1, &sa, &sa_old) == -1)
        exit_sys("sigaction");

    for (int i = 0; i < 10; ++i) {
        printf("%d\n", i);
        if (i == 5)
            raise(SIGUSR1);
        sleep(1);
    }

    return 0;
}

void sigusr1_handler(int sno)
{
    printf("SIGUSR1 handler running...\n");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Proses kendini bazı sinyallere bloke edebilir. Eğer proses kendini bir sinyale bloke ederse o sinyal oluştuğunda işletim 
    sistemi, sinyali prosese teslim etmez (deliver etmez). Onu "askıda (pending durumda)" bekletir. Eğer proses o sinyalin 
    blokesini kaldırırsa işletim sistemi sinyali prosese teslim eder. Ancak sinyaller biriktirilmemektedir. Yani bir proses
    kendini bir sinyale bloke etmiş ise o sırada o sinyal birden fazla kez prosese gönderilirse, proses sinyal blokesini 
    kaldırdığında yalnızca tek bir sinyal prosese teslim edilmektedir. Yani işletim sistemi askıda bekletilen sinyaller için bir 
    sayaç tutmamaktadır. Daha önceden de belirttiğimiz gibi default durumda zaten bir sinyal oluştuğunda, sinyal fonksiyonu 
    çalıştığı sürece aynı numaralı sinyal otomatik bloke edilmekte sinyal fonksiyonu sonlandığında blokesi açılmaktaydı.

    Thread'ler öncesinde UNIX türevi işletim sistemleri her proses için bir "signal mask" kümesi tutuluyordu. Prosesin 
    "signal mask" kümesi prosesin o anda hangi sinyallere bloke edilmiş olduğunu belirtmekteydi. Thread'ler konusu UNIX sistemlerine 
    sokulduğunda ayrıca her thread için de bir "signal mask" kümesi söz konusu olmuştur. Maalesef sigprocmask fonksiyonunun 
    çok thread'li uygulamalardaki davranışı tanımlanmamıştır. POSIX standartları fonksiyonun çok thread'li uygulamalardaki davranışını 
    "unspecified" olarak belirtmektedir. Linux sistemlerinde sigprocmask yalnızca fonksiyonun çağrıldığı thread'in signal mask kümesini 
    değiştirmektedir.

    Prosesin "signal mask" kümesini değiştirmek için yani onu belli sinyallere bloke etmek ya da blokesini açmak için sigprocmask
    isimli POSIX fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <signal.h>

    int sigprocmask(int how, const sigset_t *set, sigset_t *oset);

    Fonksiyonun birinci parametresi "signal mask kümesi" üzerinde hangi işlemin yapılacağını belirtmektedir. Bu parametre şunlardan 
    biri olabilir:

    SIG_BLOCK
    SIG_UNBLOCK
    SIG_SETMASK

    Fonksiyonun ikinci parametresi daha önce görmüş olduğumuz sigset_t türündendir. Anımsanacağı gibi bu tür aslında bitsel olarak 
    sinyalleri ifade etmek için kullanılmaktadır. İşte eğer fonksiyonun birinci parametresi SIG_BLOCK biçiminde girilirse ikinci 
    parametrede belirtilen sinyal kümesi prosesin "signal mask" kümesine dahil edilir. Yani artık bu sinyaller de bloke edilmiş 
    olur. Eğer birinci parametre SIG_UNBLOCK biçiminde girilirse bu durumda ikinci parametrede belirtilen sinyal kümesindeki 
    sinyaller prosesin signal mask kümesinden çıkartılmaktadır. Eğer birinci parametre SIG_SETMASK biçiminde girilirse bu durumda
    ikinci parametredeki sinyal kümesi prosesin "signal mask" kümesi haline getirilmektedir. Üçüncü parametre prosesin daha önceki 
    signal mask kümesinin yerleştirileceği nesneyi belirtmektedir. Aslında ikinci ve üçüncü parametreler NULL adres olarak da 
    geçirilebilir. Bu durumda bu parametreler fonksiyon tarafından kullanılmamaktadır. Fonksiyon başarı durumunda 0 değerine, 
    başarısızlık durumunda -1 değerine geri dönmektedir.

    Örneğin biz prosesimizi SIGTERM sinyaline bloke etmek isteyelim:

    sigset_t sset, osset;
    ...

    sigemptyset(&sset);
    sigaddset(&sset, SIGTERM);

    if (sigprocmask(SIG_BLOCK, &sset, &osset) == -1)
        exit_sys("sigprocmask");

    Burada sigprocmask fonksiyonunun birinci parametresi SIG_BLOCK biçiminde geçilmiştir. Bu durumda ikinci parametrede belirtilen
    sinyal kümesindeki sinyaller prosesin sinyal bloke kümesine (yani signal mask kümesine) dahil edilecektir. Böylece proses
    bu sinyale bloke edilmiş olacaktır. Pekiyi bu blokeyi nasıl kaldırabiliriz? Bunun için iki yöntem kullanabiliriz. Örneğin:

    if (sigprocmask(SIG_UNBLOCK, &sset, NULL) == -1)
        exit_sys("sigprocmask");

    Bunun diğer bir yolu eski sinyal mask kümesini yeniden set etmektir:

    if (sigprocmask(SIG_SETMASK, &osset, NULL) == -1)
        exit_sys("sigprocmask");

    Burada biz eski signal mask kümesini yeniden set ettik. Böylece daha önce yapmış olduğumuz SIG_BLOCK işlemi de devre dışı 
    kalmış oldu.

    sigprocmask fonksiyonunda prosesin signal mask kümesinde SIGKILL ya da SIGSTOP sinyalleri bulunsa bile bu durumda başarısız 
    olmaz. Yalnızca bu sinyaller için bloke işlemi yapılmaz.

    Aşağıdaki örnekte proses 30 saniye kadar SIGTERM sinyaline bloke edilmiş sonra da blokesi açılmıştır. Bu süre içerisinde
    başka bir terminalden kill komutuyla prosese SIGTERM sinyali göndermeyi deneyiniz. Bu süre zarfında sinyalin "askıda (pending)" 
    kaldığını prosese teslim edilmediğini göreceksiniz. Ancak 30 saniye geçtikten sonra örneğimizde prosesin blokesi açılmıştır. 
    Bu durumda işletim sistemi SIGTERM sinyalini prosese gönderecek ve proses bu sinyal için sinyal fonksiyonu set etmediğinden 
    dolayı sonlandırılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    sigset_t sset;

    sigemptyset(&sset);
    sigaddset(&sset, SIGTERM);

    if (sigprocmask(SIG_BLOCK, &sset, NULL) == -1)
        exit_sys("sigprocmask");

    printf("sleep for 30 seconds by blocikng SIGTERM...\n");
    for (int i = 0; i < 30; ++i) {
        printf("%d\n", i);
        sleep(1);
    }

    if (sigprocmask(SIG_UNBLOCK, &sset, NULL) == -1)
        exit_sys("sigprocmask");

    printf("program continues running...\n");

    for (int i = 0; i < 30; ++i) {
        printf("%d\n", i);
        sleep(1);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pek gereksinim duyulmasa da programcı o anda "askıda (pending)" olan sinyallerin kümesini de elde etmek isteyebilir. Bunun 
    için sigpending isimli POSIX fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <signal.h>

    int sigpending(sigset_t *set);

    Fonksiyon askıdaki sinyalleri argüman olarak girilen sigset_t nesnesi içerisine yerleştirmektedir. Programcı belli bir sinyalin
    bu kümede olup olmadığını sigismember fonksiyonu ile öğrenebilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    pause isimli POSIX fonksiyonu bir sinyal oluşana kadar ilgili thread'i blokede bekletmektedir. Biz de aslında bu fonksiyonu 
    daha önce kullanmıştık. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int pause(void);

    Fonksiyon her zaman -1 değerine geri döner. errno değişkeni de her zaman EINTR olarak set edilmektedir. Fonksiyonun başarısının 
    kontrol edilmesine gerek yoktur. Sinyal oluştuğunda eğer sinyal fonksiyonu set edilmemişse pause fonksiyonu zaten geri 
    dönmemektedir. Ancak sinyal fonksiyonu set edilmişse önce sinyal fonksiyonu çalıştırılmakta, sinyal fonksiyonunun çalışması 
    bittikten sonra pause fonksiyonu geri dönmektedir. Örneğin:

    for (;;)
        pause();

    Burada aslında programcının arzu ettiği sinyal oluştukça iş yapan, diğer durumlarda uykuda bekleyen bir akış söz konusudur. 
    Tabii böylesi bir programı sonlandırmanın bir yolu sinyal fonksiyonu set edilmemiş bir sinyali prosese göndermek olabilir.

    Aşağıdaki örnekte proses SIGUSR1 sinyalini işlemiş ve sonsuz döngüde pause ile beklemiştir. Burada başka bir terminalden 
    prosese aşağıdaki gibi SIGUSR1 sinyallerini gönderebilirsiniz:

    $ kill -USR1 26969
    $ kill -USR1 26969
    $ kill -USR1 26969
    $ kill -USR1 26969
    $ kill -USR1 26969
    $ kill -USR1 26969
    $ kill -USR1 26969
    $ kill -USR1 26969
    $ kill -USR1 26969
    $ kill 26969

    Tabii buradaki proses id programın her çalıştırılmasında farklı olabilecektir. Bunun için ps -u komutundan faydalanabilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sigusr1_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;

    sa.sa_handler = sigusr1_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGUSR1, &sa, NULL) == -1)
        exit_sys("sigaction");

    for(;;)
        pause();

    return 0;
}

void sigusr1_handler(int sno)
{
    printf("SIGUSR1 handler running...\n");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Sinyaller ilk UNIX sistemlerinden beri var olan bir kavramdır. Ancak thread'ler 90'ların ortalarında işletim sistemlerinde
    yaygınlaşmaya başlamıştır. Dolayısıyla sinyaller eskiden yalnızca proseslerle ilgili bir kavramdı. Yani sinyaller proseslere
    gönderiliyordu. Zaten eskiden proseslerin tek bir akışı (yani thread'i) vardı. Ancak 90'lı yılların ortalarına doğru thread'ler 
    işletim sistemlerine eklenince sinyaller konusu üzerinde thread'lere yönelik bazı revizyonlar yapılmıştır.

    Daha önceden de belirttiğimiz gibi sinyaller kill fonksiyonu ile ya da diğer kaynaklar yolu ile proseslere gönderilmektedir. 
    Prosesin hangi thread'inin, sinyal fonksiyonunu çalıştıracağı POSIX standartlarında işletim sisteminin isteğine bırakılmıştır.

    Prosesin bir thread'i kendi prosesinin başka bir thread'ine sinyal gönderebilir. (Tabii bir proses başka bir prosesin 
    spesifik bir thread'ine sinyal gönderememektedir.) Bir thread'e sinyal göndermek demek aslında sinyal fonksiyonunun o 
    thread tarafından çalıştırılmasını sağlamak demektir. Bunun için pthread_kill fonksiyonu kullanılmaktadır.

    #include <signal.h>

    int pthread_kill(pthread_t thread, int sig);

    Fonksiyonun birinci parametresi thread'in id değerini, ikinci parametresi ise gönderilecek sinyalin numarasını almaktadır. 
    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda ise errno değerine geri dönmektedir. Tabii ilgili sinyal 
    için sinyal fonksiyonu set edilmemişse yalnızca ilgili thread değil, tüm proses sonlandırılmaktadır.

    Aşağıdaki örnekte prosesin ana thread'i, diğer thread'e pthread_kill fonksiyonu ile SIGUSR1 sinyalini göndermektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <pthread.h>

void sigusr1_handler(int sig);
void *thread_proc(void *param);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    struct sigaction sa;
    int result;

    sa.sa_handler = sigusr1_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGUSR1, &sa, NULL) == -1)
        exit_sys("sigaction");

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        printf("Main thread running: %d\n", i);
        if (i == 5)
            if ((result = pthread_kill(tid, SIGUSR1)) != 0)
                exit_sys_errno("pthread_kill", result);

        sleep(1);
    }

    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;
}

void sigusr1_handler(int sig)
{
    printf("SIGUSR1 handler\n");
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("Other thread running: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Belli bir thread de sinyallere bloke edilebilir. UNIX türevi sistemlerde her thread'in de ayrıca bir signal mask kümesi 
    vardır. Belli bir thread'i belli sinyallere bloke etmek için tamamen sigprocmask fonksiyonunun benzeri olan pthread_sigmask 
    fonksiyonu kullanılmaktadır:

    #include <signal.h>

    int pthread_sigmask(int how, const sigset_t *set, sigset_t *oset);

    Fonksiyonun parametrik yapısı tamamen sigprocmask fonksiyonundaki gibidir. Fonksiyon hangi thread tarafından çağrılmışsa
    o thread'in signal mask kümesi bu işlemden etkilenir. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda errno
    değerine geri dönmektedir.

    Belli bir thread'in belli sinyallere bloke edilmesinin bazı gerekçeleri söz konusu olabilmektedir. Örneğin thread kesilmemesi
    gereken işlemler yapıyor olabilir. Bu durumda thread sinyallere bloke edilebilir. Tabii bir thread bir sinyale bloke edildiğinde 
    artık o sinyal oluştuğunda, sinyal fonksiyonu prosesin diğer thread'lerinden biri tarafından çalıştırılacaktır. Bazen 
    programcılar ilgili sinyalin prosesin belli bir thread'i tarafından işlenmesini sağlamak için diğer thread'leri ilgili 
    sinyale bloke edip yalnızca tek bir thread'de bu bloke işlemini yapmazlar. Sinyal oluştuğunda işletim sistemi de mecburen 
    sinyal fonksiyonunu o thread ile çağırır. Tabii prosesin tüm thread'leri ilgili sinyale bloke edilirse bu durum sanki prosesin 
    o sinyale bloke edilmesi gibi bir etki oluşturacaktır.

    UNIX/Linux sistemlerinde bir thread yaratıldığında thread'in signal mask kümesi onu yaratan thread'ten (üst thread'ten) 
    aktarılmaktadır. Yani örneğin bu sistemlerde biz prosesin ana thread'inde bir sinyali bloke edersek bu durumda bu sinyal
    ana thread tarafından yaratılan tüm thread'lerde bloke edilmiş olacaktır. Benzer biçimde fork işlemi sırasında da yaratılan 
    alt prosesin thread'inin signal mask kümesi onu yaratan üst prosesten aktarılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                76. Ders 27/08/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Seyrek olarak programcı kritik birtakım işlemler yaparken sinyalleri pthread_sigmask fonksiyonuyla bloke edip sonra açarak 
    pause ile bekleyebilmektedir. Örneğin:

    siprocmask(<sinyalleri bloke et>);
    <birtakım işlemler>
    siprocmask(<sinyalleri aç>);
    ---> Problem var!
    pause();
    <bu kısma sinyal geldiğinde geçilmek istenmektedir>

    Programcı sinyalleri açıp pause beklemesini yapmak istediği sırada sinyal prosese gönderilirse henüz akış pause fonksiyona 
    girmeden sinyal teslim edilebilir. Daha sonra akış pause fonksiyonuna girdiğinde buradan çıkılamayacaktır. Çünkü sinyali 
    gönderen kişi pause ile bekleyenin yoluna devam edebilmesi için sinyali göndermiştir. Bu problem atomik bir biçimde sinyalleri 
    açarak pause yapan bir fonksiyonla çözülebilir. İşte sigsuspend fonksiyonu bunu yapmaktadır. sigsuspend fonksiyonunun prototipi 
    şöyledir:

    #include <signal.h>

    int sigsuspend(const sigset_t *sigmask);

    Fonksiyon yeni uygulanacak signal mask kümesini parametre olarak alır. Bu kümeyi fonksiyonu çağıran thread'in (prosesin değil) 
    signal mask kümesi yapar ve atomik bir biçimde pause işleminde bekler. Böylece yukarıda bahsetmiş olduğumuz blokeyi açarak pause
    fonksiyonunda bekleme atomik hale getirilmiş olmaktadır. Tabii sinyal gelip fonksiyondan çıkıldığında, thread'in eski sinyal kümesi 
    yeniden set edilmektedir. POSIX standartları sigsuspend fonksiyonunun yalnızca ilgili thread'in signal mask kümesini etkilediğini 
    belirtmektedir. Eskiden thread'ler yokken bu fonksiyon prosesin signal mask kümesini etkiliyordu. Tabii thread'lerin olmadığı 
    devir ile tek thread'li uygulamalar aynı anlama gelmektedir. Yani başka bir deyişle fonksiyonu biz thread'siz bir programda
    çağırdığımızda fonksiyon eski zamanlardaki gibi prosese özgü işlem yapıyor gibi olacaktır. Ancak mevcut standartlarda sigsuspend
    fonksiyonu yalnızca fonksiyonun çağrıldığı thread'in signal mask kümesi üzerinde etkili olmaktadır. sigsuspend fonksiyonu
    eğer proses ilgili sinyal için bir sinyal fonksiyonu set etmemişse proses sonlanacağı için hiç geri dönmeyebilir. Eğer proses
    bir sinyal fonksiyonu set etmişse bu durumda fonksiyon -1 ile geri döner ve errno değişkeni EINTR değeri ile set edilir. Fonksiyonun
    geri dönüş değerinin kontrol edilmesine gerek yoktur.

    O halde sigsuspend fonksiyonunun eşdeğeri aşağıdaki gibidir:

    pthread_sigmask(SIG_SETMASK, &sset, &oldsset);
    pause();
    pthread_sigmask(SIG_SETMASK, &oldsset, NULL);

    Tabii sigsuspend fonksiyonu bütün bunları kendi içerisinde atomik bir biçimde yapmaktadır.

    sigsuspend fonksiyonunun kullanımının neden gerektiği programcılar tarafından zor anlaşılmaktadır. Çünkü bu fonksiyona oldukça 
    seyrek ihtiyaç duyulur. Konu ile ilgili soru ve cevaplar genellikle şunlardır:

    SORU: sigsuspend fonksiyonuna gereksinim duyulan bir senaryo nasıldır?

    YANIT: Tipik bir senaryo şöyledir: Programcı başka bir prosesten bir sinyal beklemektedir. Ancak o sinyal geldiğinde koduna 
    devam etmek istemektedir. Ancak bu sinyali beklemeden önce sinyalleri bloke ederek bazı işlemler yapmak isteyebilir. Dolayısıyla 
    bu süre zarfında o sinyal oluşursa pending durumda kalacaktır. Programcı sonra sinyalleri açarak pause işleminde diğer prosesin
    sinyalini beklemek ister. Ancak daha önce sinyal oluşmuş da olabilir. Bu durumda sinyali açarak pause işlemi uygularken sinyali 
    açtığı noktada akış henüz pause fonksiyonuna gelmeden sinyal prosese teslim edilirse akış pause fonksiyonuna geldiğinde sonsuz
    bir bekleme oluşmaktadır. İşte sinyallerin açılarak pause beklenmesinin atomik bir biçimde yapılması gerekmektedir.

    SORU: sigsuspend öncesinde sinyallerin bloke edilmesinin nedeni nedir? Çünkü sigsuspend sinyalleri açarak pause uygulamak 
    için kullanılmaktadır.

    YANIT: Bunun çeşitli nedenleri olabilir. Ancak başka bir prosesten sinyal beklerken birtakım başka şeylerin yapılması 
    gerekebilmektedir. Bu durumda diğer proses sinyal gönderirse sinyalin boşa gitmemesi için programcı en azından ilgili sinyali 
    bloke ederek sinyal gelmişse bile onun pending durumda kalmasını sağlayabilir.

    SORU: Zaten bir prosesin, bir işi yapmasını beklemek için senkronizasyon nesneleri kullanılmıyor mu? Neden ayrıca bir sinyal 
    yoluyla böyle bir bekleme yapılmak istensin? Yani örneğin prosesler arasında kullanılan bir durum değişkeni nesnesi ile de aynı 
    şeyler yapılamaz mı?

    YANIT: Evet yapılabilir. Ancak bu tür durumlarda sinyal kullanımı oldukça pratiktir. Yani sinyaller bir anlamda prosesler arası 
    haberleşme yöntemlerinden biri gibi düşünülebilir.

    Aşağıda sigsuspend fonksiyonunun kullanımına bir örnek verilmiştir. Örnekte proses SIGSUR1 sinyalini bloke ederek birtakım 
    işlemler yapmaktadır. (Örneğimizde bu işlemler 30 kere, saniyede bir ekrana bir şeyler yazdırılmasıdır.) Bu sırada prosese 
    sinyal gelse bile sinyal prosese iletilmeyecek ve askıda (pending) kalacaktır. Sonra program bu sinyalleri açarak pause 
    işleminde beklemek istemiştir. Bunun nedeni başka bir prosesin bir işi yapmasını beklemek olabilir. Yani başka bir proses 
    bir işi bitirince bizim programımız yoluna devam edecektir. Burada diğer proses ilgili sinyali (SIGUSR1) 30 saniyelik işlemler 
    sırasında göndermiş olabileceği gibi daha sonra da gönderecek olabilir. Program sinyalleri açarak pause işleminde beklemek 
    istediğinde sinyalleri açar açmaz askıda olan sinyal prosese iletilebilir ve henüz akış pause fonksiyonuna gelmeden sinyal 
    boşa gidebilir. Bu durumda akış pause fonksiyonuna geldiğinde zaten sinyal oluştuğu için ve bir daha da bu sinyal gönderilmeyeceği 
    için sonsuz bir bekleme durumu oluşabilir. Buradaki sigsuspend çağrısının amacı sinyallerin blokesinin çözülmesi ile pause 
    arasında açık bir pencerenin kapatılmasını sağlamaktır. Aşağıdaki örneği çalıştırdıktan sonra başka bir terminalden prosese 
    kill komutu ile SIGUSR1 sinyalini gönderip durumu inceleyiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sigusr1_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;
    sigset_t sset, oldsset;

    sa.sa_handler = sigusr1_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGUSR1, &sa, NULL) == -1)
        exit_sys("sigaction");

    sigfillset(&sset);
    if (sigprocmask(SIG_BLOCK, &sset, &oldsset) == -1)
        exit_sys("sigprocmask");

    for (int i = 0; i < 30; ++i) {
        printf("%d\n", i);
        sleep(1);
    }
    sigsuspend(&oldsset);

    printf("Ok\n");

    return 0;
}

void sigusr1_handler(int sno)
{
    printf("SIGUSR1 handler running...\n");        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz bir fonksiyonun içerisindeyken bir sinyal oluşsa ve sinyal fonksiyonumuz çalıştırılsa ve sinyal fonksiyonumuz da 
    aynı fonksiyonu çağırsa ne olur? Bu tür durumlarda iç içe çağırma söz konusu olacaktır. Bu durum thread güvenlilik durumuna 
    benzemektedir. POSIX standartları bu biçimde sinyal dolayısıyla iç içe çağrılabilecek fonksiyonları "asenkron sinyal güvenli 
    fonksiyonlar (async-signal-safe functions)" ismiyle belirtmektedir. POSIX standartlarında tüm asenkron sinyal güvenli 
    fonksiyonların listesi "System Interfaces/General Information/Signal Concepts" başlığında listelenmektedir. Bu listede 
    belirtilen asenkron sinyal güvenli fonksiyonlar gönül rahatlığı ile sinyal fonksiyonlarında ve dışarıda aynı anda kullanılabilirler. 
    Pekiyi daha önce görmüş olduğumuz thread güvenli sonu _r ile biten fonksiyonlar da sinyal güvenli midir? Genel olarak asenkron 
    sinyal güvenli fonksiyonlar, thread güvenli fonksiyonlardan biraz daha katı bir güvenliliğe sahiptir. Çünkü asenkron sinyal 
    güvenli fonksiyonlar aynı thread akışı tarafından iç içe çağrılabilecek fonksiyonlardır. Bu nedenle genel olarak asenkron 
    sinyal güvenli fonksiyonlar thread güvenli olma eğilimindeyken; asenkron thread güvenli fonksiyonlar, asenkron sinyal güvenli 
    olmayabilmektedir.

    Aslında bir fonksiyon thread güvenli olduğu halde sinyal güvenli olmayabilir, sinyal güvenli olduğu halde thread güvenli 
    olmayabilir. Örneğin bir fonksiyon TSD (Thread Specific Data) kullanılarak thread güvenli hale getirilmiş olabilir. Ancak
    sinyaller iç içe aynı thread tarafından işletilebileceği için bu fonksiyon sinyal güvenli olmayabilir. Yukarıda da belirttiğimiz 
    gibi her zaman olmasa da çoğu zaman sinyal güvenli fonksiyonlar aynı zamanda thread güvenli olma eğilimindedir.

    Fonksiyonun asenkron sinyal güvenli (async-signal-safe) olması genel olarak "reentrant" olması anlamına gelmektedir. Reentrant
    terimi sinyal yoluyla ya da başka yolla (örneğin kesme yoluyla) bir fonksiyonunun iç içe çalışabilirliği anlamına gelmektedir. 
    Dolayısıyla reentrant fonksiyonlar aynı zamanda asenkron sinyal güvenli fonksiyonlardır. Ancak POSIX standartlarında "reentrant" 
    terimi kullanılmamıştır. Reentrant ve thread safe kavramları arasındaki benzerlikler ve farklılıklar için Wikipedia'daki 
    aşağıdaki sayfayı gözden geçirebilirsiniz:

    https://en.wikipedia.org/wiki/Reentrancy_(computing)

    Biz örneklerimizde sinyal fonksiyonu içerisinde printf fonksiyonunu kullanmıştık. POSIX standartlarına göre C'nin tüm dosya 
    fonksiyonları thread güvenli olduğu halde sinyal güvenli değildir. Biz örneklerimizde kullanmış olsak da printf gibi <stdio.h>
    fonksiyonlarını sinyal fonksiyonlarından kullanmayınız. printf fonksiyonunun thread güvenli (thread safe) olduğu halde 
    asenkron sinyal güvenli olmadığına dikkat ediniz. Yani printf fonksiyonunu yazanlar onun farklı thread'lerden çağrılmasına karşı
    önlemler almışlardır ancak onun aynı thread tarafından çağrılmasına karşı herhangi bir önlem almamışlardır. Başka bir deyişle
    örneğin printf fonksiyonu thread güvenli olduğu halde "reentrant" değildir. Tabii bu yalnızca printf fonksiyonu için değil,
    C'nin tampon kullanan tüm <stdio.h> fonksiyonları için geçerlidir. Pekiyi biz sinyal fonksiyonları içerisinde ekrana bir
    şeyler yazdırmak istesek bunu nasıl sağlayabiliriz? Burada ilk akla gelecek yöntem yazdırılacak şeyleri sprintf ile bir tampona 
    yazdırıp, onu write fonksiyonu ile 1 numaralı betimleyiciyi kullanarak ekrana yazdırmaktır. Biz sonraki örneklerde printf
    fonksiyonunun aslında sinyal güvenli olmadığını yalnızca örneklerimizde pratiklik sağladığı için kullandığımızı belirtmek amacıyla
    onun yanına bir UNSAFE notu da ekleyeceğiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sinyal fonksiyonlarını yazarken dikkat edilmesi gereken diğer bir nokta da "errno" sorunudur. Sinyal fonksiyonu içerisinde
    errno değişkeninin değerini değiştirebilecek bir fonksiyon çağrısı varsa bu durum sorunlara yol açabilmektedir. (Anımsanacağı
    gibi bir POSIX fonksiyonu başarılı olduğu halde errno değişkenini yine de set edebilmektedir.) Buradaki sorunun kaynağını
    şöyle bir örnekle açıklayabiliriz:

    if (some_posix_func() == -1) {        // Bizim exit_sys fonksiyonumuz zaten bunu yapıyor
    ---> Bu sırada sinyal gelirse ne olur?
        perror("some_posix_func");
        exit(EXIT_FAILURE);
    }

    Burada ok ile belirtilen noktada bir sinyal gelirse, sinyal fonksiyonu errno değişkenini değiştirebileceği için perror ile 
    rapor edilen mesaj da yanlış bir mesaj olabilecektir. Pekiyi bu sorunu nasıl giderebiliriz? İşte tipik olarak yapılması gereken 
    şey sinyal fonksiyonunun başında errno değişkenini geçici olarak saklayıp sinyal fonksiyonunun sonunda yeniden set etmektir. 
    Örneğin:

    void signal_handler(int sig)
    {
        int errno_temp = errno;

        // birtakım işlemler

        errno = errno_temp;
    }

    Aşağıdaki örnekte yukarıda açıkladığımız problem simüle edilmiştir. Programda önce SIGUSR1 sinyali sigaction fonksiyonu 
    ile set edilmiştir. Sonra olmayan bir dosya açılmak istenmiştir. Olmayan bir dosya open ile açılmak istendiğinde errno 
    değişkeninin ENOENT değeri ile ("No such file or directory") set edilmesi gerekir. Ancak o arada bir sinyal oluşup da
    sinyal fonksiyonu çalıştırıldığında sinyal fonksiyonu da errno değişkenini değiştirirse sorun ortaya çıkacaktır. Biz örneğimizde
    raise fonksiyonu ile bu durumu yapay bir biçimde sağlamaya çalıştık:

    if ((fd = open("file_not_found", O_RDONLY)) == -1) {
        raise(SIGUSR1);        // only for example
        exit_sys("open");
    }

    Sinyal fonksiyonun aşağıdaki gibi olduğunu varsayalım:

    void sigusr1_handler(int sno)
    {
        printf("SIGUSR1 handler running...\n");        // UNSAFE

        kill(1, SIGKILL);        // kill will fail
    }

    Burada kill başarısız olacak ve errno değişkenini EPERM ("Operation not permitted") değeri ile set edecektir. Bu durumda 
    exit_sys fonksiyonu yanlış mesajı rapor edecektir. Bu durumu düzeltmek için sinyal fonksiyonu şöyle düzeltilmelidir:

    void sigusr1_handler(int sno)
    {
        int errno_temp = errno;

        printf("SIGUSR1 handler running...\n");        // UNSAFE

        kill(1, SIGKILL);        // kill will fail

        errno = errno_temp;
    }

    Sinyal fonksiyonunun düzeltilmiş biçimine ilişkin örnek program aşağıda verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>

void sigusr1_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;
    int fd;

    sa.sa_handler = sigusr1_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGUSR1, &sa, NULL) == -1)
        exit_sys("sigaction");

    if ((fd = open("file_not_found", O_RDONLY)) == -1) {
        raise(SIGUSR1);        /* only for example */
        exit_sys("open");
    }

    return 0;
}

void sigusr1_handler(int sno)
{
    int errno_temp = errno;

    printf("SIGUSR1 handler running...\n");        /* UNSAFE */

    kill(1, SIGKILL);        /* kill will fail */

    errno = errno_temp;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir sinyal fonksiyonu yazılırken global bir değişkenin kullanılması gerekebilmektedir. Bu durumda tıpkı çok thread'li 
    uygulamalarda olduğu gibi bu global değişkenin kararsız durumda kalması engellenmelidir. Tabii bu tür durumlarda nesneyi
    mutex gibi mekanizmalarla korumak uygun değildir. Çünkü bu mekanizmalar farklı thread'ler tarafından erişimde koruma 
    amaçlı oluşturulmuştur. Eğer bir sinyal fonksiyonu global bir değişkeni kullanacaksa onu atomik bir biçimde kullanmalıdır.
    Örneğin:

    int g_count;
    ...

    void signal_handler(int sig)
    {
        ...
        ++g_count;        ---> Bu artırma tek bir makine komutu ile yapılmak zorunda değil
        ...
    }

    Bu örnekte akış ++g_count işleminde kesilip, yeniden aynı fonksiyon çalıştırılırsa g_count değeri uygun biçimde artırılamayabilecektir.
    İşte bu tür durumlarda mutex gibi nesneler bize bir koruma sağlamamaktadır. Burada yapılması gereken bu artırımın atomik bir 
    biçimde yani tek bir makine komutuyla yapılmasıdır. İşte C99 ile birlikte C'ye sig_atomic_t türü de eklenmiştir. Bu türden 
    global bir nesne tanımlandığında, bu nesne üzerinde atama işlemleri atomik bir biçimde yapılmaktadır. Ancak ++, -- gibi 
    operatör işlemlerinin atomik yapılmasının bir garantisi yoktur.

    Thread'ler konusunda gördüğümüz gcc ve clang derleyicilerinin built-in fonksiyonlarını bu amaçla kullanabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosese SIGSTOP isimli gönderilirse proses durdurulur ve SIGCONT sinyali gönderilene kadar suspend biçimde kalır. 
    SIGSTOP sinyali tıpkı SIGKILL sinyalinde olduğu gibi bloke edilememekte ve ignore edilememektedir. Ayrıca SIGSTOP sinyali
    için sinyal fonksiyonu da set edilememektedir. SIGCONT sinyali için ise sinyal fonksiyonu set edilebilir ve bu sinyal bloke 
    edilebilir. SIGCONT sinyali bloke edilmiş olsa bile ya da SIGCONT sinyali için sinyal fonksiyonu set edilmiş olsa bile 
    durdurulmuş proses yine çalışmaya devam ettirilmektedir.

    Aslında prosesi durduran tek sinyal SIGSTOP sinyali değildir. Terminal ile ilgili SIGTTIN ve SIGTTOU sinyalleri de prosesin 
    durdurulmasına yol açabilmektedir. Biz bunlara "stop sinyalleri (stop signals)" diyeceğiz.

    Stop sinyalleriyle durdurulmuş bir prosese başka bir sinyal gönderilse bile proses bunu işlemez. Bu durumda sinyal askıda 
    (pending durumda) kalır. Askıdaki sinyaller prosese SIGCONT sinyali gönderilip proses yeniden çalıştırıldıktan sonra (resume 
    edildikten sonra) prosese teslim edilmektedir. Ancak SIGCONT sinyali sonrasında askında stop sinyalleri prosese teslim
    edilmez, doğrudan atılır. Benzer biçimde prosese bir stop sinyali teslim edildiğinde eğer o anda askıda olan SIGCONT sinyali 
    varsa bu sinyal doğrudan atılmaktadır. Durdurulmuş bir proses her zaman SIGKILL sinyali ile sonlandırılabilmektedir. SIGKILL 
    sinyali ile sonlandırma için prosesin SIGCONT sinyali ile çalışmaya devam ettirilmesine gerek yoktur.

    Aşağıdaki programı bir terminalden çalıştırıp diğer bir terminalden ona kill komutuyla SIGSTOP ve SIGCONT sinyallerini 
    göndererek durumu gözlemleyiniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(void)
{
    for (int i = 0; i < 60; ++i) {
        printf("%d\n", i);
        sleep(1);
    }

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Stop edilmiş prosesler ps komutunda Status bilgisi T ile gösterilmektedir. Örneğin:

    $ ps -u
    USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    kaan       24891  0.0  0.1  14176  5628 pts/1    Ss+  01:01   0:00 /usr/bin/bash --init-file /us
    kaan       25747  0.0  0.1  14292  5680 pts/2    Ss+  01:05   0:00 bash
    kaan       31684  0.0  0.1  14292  5776 pts/0    Ss   10:45   0:00 bash
    kaan       32827  0.0  0.0   2772   944 pts/2    T    12:57   0:00 ./mample
    kaan       32831  0.0  0.0  15428  1568 pts/0    R+   12:58   0:00 ps -u
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Klavyeden Ctrl+Z tuşuna basıldığında terminal aygıt sürücüsü oturumun (session) ön plan (foreground) proses grubuna SIGSTOP
    sinyali göndermektedir. Yani biz klavyeden Ctrl+Z tuşlarına basarak da o anda çalışmakta olan programa SIGSTOP sinyalini 
    göndertebilmekteyiz. Bu biçimde kabuk üzerinden durdurulan prosesler "fg (foreground)" kabuk komutuyla kaldığı yerden çalışmaya 
    devam ettirilebilmektedir. Tabii "fg" kabuk komutu aslında ilgili prosese (ya da proseslere) SIGCONT sinyalini göndermektedir. 
    Biz kabuk üzerinden Ctrl+Z tuşuna basarak bir prosesi durdurduğumuzda ona bir numara verilmektedir. fg komutunda o numara 
    kullanılmalıdır. Örneğin:

    $ ./mample
    0
    1
    2
    3
    4
    ^Z
    [3]+  Durdu                   ./mample
    $ fg 3
    $ ./mample
    5
    6
    7
    8
    9
    10
    11
    12
    ...

    Eğer "fg" komutu argümansız kullanılırsa en son stop ettirilen proses çalıştırılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz komut satırında klavyeden Ctrl+C ya da Ctrl+Z tuşlarına bastığımızda SIGINT sinyali ve SIGSTOP sinyali tek bir prosese 
    değil ön plan proses grubundaki proseslerin hepsine gönderilmektedir. Proses grupları ve oturum (session) kavramı sonraki 
    paragraflarda ele alınacaktır. Ancak burada temel bir açıklamayı da yapmak istiyoruz. Biz programımızda fork işlemi 
    yaptığımızda bizim üst prosesimiz ve alt prosesimiz aynı proses grubu içerisinde bulunur. Bu durumda Ctrl+C tuşlarına 
    bastığımızda SIGINT sinyali bu üst prosese de alt prosese de gönderilecek ve iki proses de sonlandırılacaktır (Tabii bu 
    prosesler SIGINT sinyalini set etmemişlerse). Aynı durum Ctrl+Z tuşlarına basıldığında da söz konusu olmaktadır. Ctrl+Z
    tuşlarına basıldığında SIGSTOP sinyali hem üst prosese hem de alt prosese gönderilecektir. Benzer biçimde "fg" komutunu 
    uyguladığımızda SIGCONT sinyali de hem üst prosese hem de alt prosese gönderilmektedir.

    Aşağıdaki programı çalıştırınız ve sonra Ctrl+C tuşlarına basınız. Hem üst prosesin hem de alt prosesin sonlandığını 
    göreceksiniz. Sonra programı yeniden çalıştırıp bu kez de Ctrl+Z tuşlarına basınız. Hem üst prosesin hem de alt prosesin 
    durdurulduğunu göreceksiniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {
        for (int i = 0; i < 60; ++i) {
            printf("Parent: %d\n", i);
            sleep(1);
        }
        if (waitpid(pid, NULL, 0) == -1)
            exit_sys("waitpid");
    }
    else {
        for (int i = 0; i < 60; ++i) {
            printf("Child: %d\n", i);
            sleep(1);
        }
        _exit(0);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    wait fonksiyonu ile alt proses beklenirken, wait fonksiyonu bu beklemeden ancak alt proses sonlandığında çıkabilmektedir. 
    Alt prosesin sonlanması da iki biçimde olabilmektedir: Normal olarak exit ya da _exit fonksiyonlarının çağrılmasıyla ve 
    bir sinyal dolayısıyla. Anımsanacağı gibi biz wait fonksiyonunun status parametresini WIFEXITED ve WIFSIGNALED makrolarına 
    sokarak bu durumu anlayabiliyorduk. Zaten anımsanacağı gibi prosesin exit kodunun oluşabilmesi için onun normal biçimde
    sonlanmış olması gerekiyordu. Fakat ayrıca bir de waitpid fonksiyonu vardı. İşte bu fonksiyonun üçüncü parametresine 
    WUNTRACED ve/veya WCONTINUED bayrakları geçilirse bu durumda waitpid fonksiyonu alt proses durdurulduğunda ve yeniden 
    çalıştırıldığında sonlanacaktır. Bu durumda status parametresindeki değer WIFSTOPPED ve WIFCONTINUED makrolarına sokularak 
    bu durum anlaşılabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosesi terminal yoluyla sonlandırmanın Ctrl+C tuşlarının dışında diğer bir yolu da Ctrl+\ tuşlarını (ya da bazı sistemlerde
    bunun yerine Ctrl+Backspace tuşları da kullanılabilmektedir) kullanmaktır. Bu durumda terminal aygıt sürücüsü oturumun ön plan 
    proses grubuna SIGQUIT isimli bir sinyal göndermektedir. SIGQUIT sinyali prosese gönderildiğinde eğer proses bu sinyali ele 
    almamışsa, proses sonlandırılır ve bir core dosyası oluşturulur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                77. Ders 02/09/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    abort aynı zamanda bir standart C fonksiyonudur. abort fonksiyonu "abnormal" bir sonlandırma için kullanılmaktadır. Pekiyi 
    programcı exit yerine neden programını abort fonksiyonuyla sonlandırmak istesin? İşte bazen içinde bulunulan duruma bağlı
    olarak normal sonlandırma bile yapılamayabilir. Yani exit fonksiyonunun başarılı bir biçimde işlem yapması bile içinde 
    bulunulan duruma göre mümkün olmayabilir. abort fonksiyonu UNIX/Linux sistemlerinde aslında kendi prosesi üzerinde SIGABRT 
    sinyalinin oluşmasına yol açmaktadır. SIGABRT sinyalinin default eylemi de prosesin sonlandırılması ve core dosyasının 
    oluşturulmasıdır. Yani abort fonksiyonu bir core dosyasının oluşumuna yol açtığı için abnormal sonlanmanın debugger altında 
    incelenmesine de olanak sağlamaktadır. SIGABRT sinyali için sinyal fonksiyonu set edilmiş olsa bile sinyal fonksiyonunun 
    çalışması bittikten sonra yine de proses sonlandırılmaktadır. Ayrıca SIGABRT sinyali bloke edilmişse ve ignore edilmişse 
    bile proses yine de sonlandırılmaktadır. SIGABRT sinyali ile prosesin sonlandırılmasının engellenmesinin tek yolu sinyal 
    fonksiyonu içerisinde "long jump" işlemi uygulamaktır. "long jump" konusu izleyen paragraflarda ele alınacaktır. abort 
    fonksiyonunun prototipi şöyledir:

    #include <stdlib.h>

    void abort(void);

    Aşağıdaki örnekte SIGABRT sinyali için bir sinyal fonksiyonu set edilmiştir. Ancak proses yine de sonlanacak ve core dosyası 
    oluşturulacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sigabrt_handler(int sig);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;

    sa.sa_handler = sigabrt_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGABRT, &sa, NULL) == -1)
        exit_sys("sigaction");

    for (int i = 0; i < 60; ++i) {
        printf("%d\n", i);
        sleep(1);
        if (i == 5)
            abort();
    }

    return 0;
}

void sigabrt_handler(int sig)
{
    printf("SIGABRT handler\n");        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde birkaç sinyal, işlemci tarafından oluşturulan içsel kesmelerle işletim sistemi tarafından prosese
    gönderilmektedir. Bunların en çok karşılaşılanı SIGSEGV isimli sinyaldir. Bu sinyal tahsis edilmemiş bir bellek bölgesine 
    erişildiğinde işletim sistemi tarafından prosese gönderilmektedir. Bu sinyalin default eylemi prosesin sonlandırılmasıdır. 
    Bu sinyal bloke edilemez ve ignore edilemez. Programcı nadiren bu sinyalde prosesinin sonlandırılmasını istemeyebilir. 
    Bunun tek yolu "long jump" uygulamaktır.

    Linux sistemlerinde SIGSEGV sinyali için bir sinyal fonksiyonu set edildiyse sinyal oluştuğunda bu sinyal fonksiyonu çalıştırılır. 
    Ancak sinyal fonksiyonunda proses, exit ya da _exit fonksiyonuyla sonlandırılmamışsa aynı sinyal yeniden oluşturulmaktadır. 
    Bazı UNIX türevi sistemlerde sinyal fonksiyonu sonlandığında proses işletim sistemi tarafından sonlandırılmaktadır. (Bu sinyalin 
    oluşmasına yol açan makine komutlarına Intel işlemcilerinde "fault" denilmektedir. Bu tür fault işlemlerinde sinyal fonksiyonu
    geri döndüğünde fault'a yol açan makine komutuyla akış devam ettirilir. Böylece yeniden fault oluşmaktadır.)

    Aşağıdaki örnekte tahsis edilmemiş bir bellek alanına erişilmesinden dolayı SIGSEGV sinyali oluşturulmuştur. Bu sinyal için 
    sinyal fonksiyonu set edilmiş ancak sinyal fonksiyonu içerisinde exit fonksiyonuyla proses sonlandırılmıştır. (Proses exit 
    fonksiyonu ile sonlandırılmasaydı aynı sinyal oluşturulmaya devam edecekti.)
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sigsegv_handler(int sig);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;
    char *str = (char *)0x12345678;

    sa.sa_handler = sigsegv_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGSEGV, &sa, NULL) == -1)
        exit_sys("sigaction");

    *str = 'x';

    printf("unreachable code!...\n");

    return 0;
}

void sigsegv_handler(int sig)
{
    printf("SIGSEGV handler\n");        /* UNSAFE */

    _exit(EXIT_FAILURE);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    SIGSEGV sinyali ile aynı biçimde ele alınan diğer sinyaller SIGBUS, SIGEMT, SIGFPE, SIGILL, SIGTRAP sinyalleridir. SIGFPE 
    sinyali "floating point birimi (FPU)" tarafından oluşturulmaktadır. SIGILL sinyali user mode'da çalışan prosesin özel makine 
    komutlarını kullanmasından dolayı oluşmaktadır (illegal instruction). Bu sinyallerin davranışı SIGSEGV sinyalinde olduğu 
    gibidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Diğer önemli bir sinyal de SIGCHLD isimli sinyaldir. Aslında biz bu sinyalden proses yaratımı kısmında bahsetmiştik. 
    UNIX/Linux sistemlerinde bir alt proses sonlanırken üst prosese SIGCHLD sinyalini göndermektedir. Eskiden bu sinyalin 
    ismi SIGCLD biçimindeydi. Linux sistemlerinde her iki sinyal eşdeğerdir ve aynı numaraya sahiptir. Ancak POSIX standartlarında
    SIGCLD sinyali yoktur.

    Anımsanacağı gibi wait fonksiyonları alt prosesi bekleyerek onu zombie olmaktan kurtarıyordu. İşte zombie proses oluşumunun
    engellenmesinin bir yolu da SIGCHLD sinyalini kullanmaktır. Bu yöntemde üst proses alt prosesleri yaratmadan önce SIGCHLD 
    sinyalini set eder. Böylece alt prosesler sonlandığında programcının set etmiş olduğu sinyal fonksiyonu çalışır. İşte bu 
    sinyal fonksiyonu içerisinde programcı wait fonksiyonlarını uygular. SIGCHLD sinyalinin default eylemi sinyalin "ignore" 
    edilmesidir. Yani biz bu sinyal için herhangi bir şey yapmamışsak alt proses bittiğinde yine bu sinyal oluşur. Ancak 
    işletim sistemi tarafından sinyal "ignore" edilir.

    Zombie proses oluşumunun, wait fonksiyonlarıyla beklemeden engellenmesi için yukarıda da belirttiğimiz gibi wait fonksiyonlarının
    SIGCHLD sinyalinde uygulanması gerekmektedir. Ancak bu uygulama sırasında dikkat edilmesi gereken bir nokta vardır. SIGCHLD
    sinyali geldiğinde sinyal fonksiyonu çalıştırılırken birden fazla alt proses de o sırada sonlanmış olabilir. Sinyaller 
    biriktirilmediği için SIGCHLD için set edilen sinyal fonksiyonundan çıkıldığında askıda (pending) olan SIGCHLD sinyali 
    prosese yalnızca bir kez gönderilecektir. Halbuki birden fazla alt proses o sırada sonlanmış olabilmektedir. İşte bu nedenle 
    SIGCHLD sinyal fonksiyonunda wait işlemi bir kez değil, bir döngü içerisinde uygulanmalıdır. Tabii wait işleminin blokeye 
    yol açmaması için waitpid fonksiyonu son parametresinde WNOHANG değeriyle çağrılmalıdır. Örneğin:

    while (waitpid(-1, NULL, WNOHANG) > 0)
        ;

    Anımsanacağı gibi waitpid fonksiyonu eğer beklenecek herhangi bir alt proses yoksa -1 değerine, WNOHANG değeri geçildiğinde ancak 
    henüz bir alt proses sonlanmamışsa 0 değerine geri dönmektedir. Yukarıdaki döngüde sonlanan bütün alt prosesler beklenmiş 
    olacaktır. Tabii bu sırada errno değişkeni değer değiştirebileceği için fonksiyonun başında alınıp çıkışta yeniden set edilmesi 
    uygun olur. Örneğin:

    void sigchld_handler(int sig)
    {
        int errno_temp = errno;

        while (waitpid(-1, NULL, WNOHANG) > 0)
            ;

        errno = errno_temp;
    }

    waitpid fonksiyonu aslında başka nedenlerle de başarısız olabilir. Gerçi bu durumlar programcı her şeyi doğru yapmışsa 
    söz konusu olmamaktadır. Ancak bazı programcılar waitpid başarısız olmuşsa ve başarısızlık nedeni beklenecek alt prosesin 
    olmayışından dolayı değilse bir hata rapor edebilmektedir. Bu durumda sinyal fonksiyonu şöyle de oluşturulabilmektedir:

    void sigchld_handler(int sig)
    {
        int errno_temp = errno;
        int result;

        while ((result = waitpid(-1, NULL, WNOHANG)) > 0)
            ;

        if (result == -1 && errno != ECHILD)
            exit_sys("waitpid");

        errno = errno_temp;
    }

    Aşağıdaki örnekte üst proses 10 tane alt proses yaratmıştır. Bu alt proseslerin zombie oluşturmasını, SIGCHLD sinyal 
    fonksiyonunda yukarıda belirtildiği gibi engellemiştir. Bu programı çalıştırıp başka bir terminalden "ps -u" komutu 
    ile zombie prosesin oluşmadığını gözlemleyiniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <sys/wait.h>

void sigchld_handler(int sig);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;
    pid_t pid;

    sa.sa_handler = sigchld_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGCHLD, &sa, NULL) == -1)
        exit_sys("sigaction");

    for (int i = 0; i < 10; ++i) {

        if ((pid = fork()) == -1)
            exit_sys("fork");

        if (pid == 0) {
            printf("child process\n");
            usleep(rand() % 500000);
            _exit(EXIT_SUCCESS);
        }
    }

    printf("Press ENTER to continue...\n");
    getchar();

    return 0;
}

void sigchld_handler(int sig)
{
    int errno_temp = errno;
    int result;

    while ((result = waitpid(-1, NULL, WNOHANG)) > 0)
        ;

    if (result == -1 && errno != ECHILD)
        exit_sys("waitpid");

    errno = errno_temp;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Zombie proses oluşumunun otomatik engellenmesinin bir yolu da SIGCHLD sinyalini "ignore" etmektir. Her ne kadar bu sinyalin
    default eylemi zaten "ignore" ise de bu sinyali açıkça "ignore" etmek başka bir anlama gelmektedir. SIGCHLD sinyali, signal 
    fonksiyonu ile ya da sigaction fonksiyonu ile ignore edilirse bu durumda işletim sistemi alt proses bittiğinde onun kaynaklarını
    hemen boşaltır. Böylece zombie oluşumu engellenmiş olur. Tabii biz SIGCHLD sinyalini açıkça ignore edersek artık wait fonksiyonlarını
    uygulayamayız. Ancak bu sinyalin ignore işlemi bazı alt proseslerin yaratılmasından sonra yapılırsa bu durumda bu alt proseslerin
    otomatik kaynak boşaltımının yapılıp yapılmayacağı işletim sisteminden işletim sistemine farklılık gösterebilmektedir. Linux 
    sistemlerinde daha önce yaratılmış olan alt prosesler için otomatik boşaltım yapılmamaktadır. Ayrıca POSIX standartlarında 
    sigaction fonksiyonunda SA_NOCLDWAIT bayrağı bulundurulmuştur. Bu bayrak yalnızca SIGCHLD sinyali için kullanılabilir. 
    Programcı isterse bu bayrak yoluyla da aynı şeyi yapabilir. Ancak bu bayrak kullanıldığında hala SIGCHLD sinyali için set 
    edilmiş olan sinyal fonksiyonunun çalıştırılıp çalıştırılmayacağı işletim sisteminden işletim sistemine farklılık 
    gösterebilmektedir. Linux sistemlerinde bu durumda sinyal fonksiyonu çalıştırılmaktadır.

    Aşağıdaki örnekte yine üst proses 10 tane alt proses yaratmıştır. Ancak üst proses bu işlemlerden önce SIGCHLD sinyalini
    sigaction fonksiyonu ile "ignore" etmiştir. Bu örneği çalıştırıp diğer bir terminalden alt zombie proses oluşmadığını 
    gözlemleyiniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <sys/wait.h>

void sigchld_handler(int sig);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;
    pid_t pid;

    sa.sa_handler = SIG_IGN;
    sigemptyset(&sa.sa_mask);        /* zaten bu elemana bakılmayacak, bu satır olmasa da olur */
    sa.sa_flags = SA_RESTART;        /* zaten bu elemana bakılmayacak, bu satır olmasa da olur */

    if (sigaction(SIGCHLD, &sa, NULL) == -1)
        exit_sys("sigaction");

    for (int i = 0; i < 10; ++i) {

        if ((pid = fork()) == -1)
            exit_sys("fork");

        if (pid == 0) {
            printf("child process\n");
            usleep(rand() % 500000);
            _exit(EXIT_SUCCESS);
        }
    }

    printf("Press ENTER to continue...\n");
    getchar();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    SIGUSR1 ve SIGUSR2 sinyalleri tamamen programcılar kendi uygulamalarında kullansınlar diye bulundurulmuştur. Örneğin bu 
    sinyalleri biz prosesler arası haberleşme amacıyla kullanabiliriz. Bu sinyallerin default eylemi prosesin sonlandırılmasıdır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX'e 90 yılların ortalarında "realtime extensions" başlığı altında "gerçek zamanlı (realtime)" sinyal kavramı da eklenmiştir.
    Gerçek zamanlı sinyallere ayrı isimler verilmemiştir. Gerçek zamanlı sinyallerin numaraları [SIGRTMIN, SIGRTMAX] değerleri 
    arasındadır. Gerçek zamanlı sinyallerin normal sinyallerden (ilk 32 sinyal numarası normal sinyaller için ayrılmıştır) 
    farkları şunlardır:

    1) Gerçek zamanlı sinyaller kuyruklanmaktadır. Yani birden fazla gerçek zamanlı aynı sinyal oluştuğunda kaç tane oluşmuş 
    olduğu tutulur ve o sayıda sinyal prosese teslim edilir. Halbuki normal sinyallerde bir sayaç (biriktirme) mekanizması yoktur. 
    Örneğin biz bir sinyali bloke etmiş olalım. Bu arada o sinyal 10 kere oluşmuş olsun. Sinyalin blokesini açtığımızda bu askıdaki 
    sinyalden yalnızca bir tane prosese teslim edilecektir. Halbuki gerçek zamanlı sinyallerde bu 10 kez oluşmuş sinyal için 
    prosese 10 sinyal teslim edilecektir.

    2) Gerçek zamanlı sinyallerde bir bilgi de sinyale iliştirilebilmektedir. Bu bilgi ya int bir değer ya da bir gösterici olur.
    Gösterici kullanıldığında bu göstericinin gösterdiği yerin hedef proseste anlamlı olması gerekmektedir. Yani bu adresin tipik olarak
    paylaşılan bir bellek alanındaki (shared memory) bir adres olması gerekir. (Tabii paylaşılan bellek alanları farklı proseslerde 
    farklı adreslere map (ya da attach) edilmiş olabilir. Bu durumda bu tür adreslerin göreli bir biçimde oluşturulması uygun olur.)

    3) Gerçek zamanlı sinyallerde bir öncelik ilişkisi (priority) vardır. Birden fazla farklı numaralı gerçek zamanlı sinyal bloke 
    edildiği durumda bloke açılınca bunların oluşma sırası küçük numaradan büyük numaraya göredir. Yani gerçek zamanlı sinyallerde
    küçük numara yüksek öncelik belirtmektedir. Gerçi Linux kernel kodları incelendiğinde Linux'un da bu tür durumlarda önce düşük 
    numaralı sinyali prosese teslim ettiği görülmektedir. Ancak ne olursa olsun bu UNIX türevi sistemlerde standart bir özellik 
    değildir.

    Gerçek zamanlı sinyaller kill fonksiyonu ile değil, sigqueue isimli fonksiyonla gönderilmektedir. Eğer bu sinyaller kill ile 
    gönderilirse kuyruklama yapılıp yapılmayacağı işletim sisteminden işletim sistemine değişebilmektedir. Linux gerçek zamanlı 
    sinyaller için bu kuyruklamayı yapmaktadır. Ancak gerçek zamanlı sinyaller kill POSIX fonksiyonu ile değil, sigqueue POSIX 
    fonksiyonuyla gönderilmelidir.

    Gerçek zamanlı sinyaller set edilirken sigaction fonksiyonu kullanılmak zorundadır. Gerçek zamanlı sinyaller signal fonksiyonu 
    ile set edilememektedir. Bu fonksiyonda sinyal fonksiyonunun adresi artık sigaction yapısının sa_handler elemanına değil, 
    sa_sigaction elemanına yerleştirilmelidir. Tabii fonksiyonun bunu anlaması için flags parametresine de ayrıca SA_SIGINFO 
    eklenmelidir. (Yani başka bir deyişle fonksiyon sa_flags parametresinde SA_SIGINFO değerini gördüğünde artık sinyal 
    fonksiyonu için yapının sa_sigaction elemanına bakar.) Örneğin:

    struct sigaction sa;
    ...
    sa.sa_sigaction = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART|SA_SIGINFO;

    sigaction yapısının sa_sigaction elemanına girilecek fonksiyonun parametrik yapısı aşağıdaki gibi olmak zorundadır:

    void signal_handler(int signo, siginfo_t *info, void *context);

    Aşağıdaki örnekte proc1 programı n tane gerçek zamanlı sinyal gönderir. proc2 ise bunları almaktadır. Programları çalıştırarak
    kuyruklamanın yapıldığına dikkat ediniz. sigqueue fonksiyonunda iliştirilen sinyal bilgisi siginfo_t yapısının si_value
    elemanından alınmaktadır.

    sigqueue fonksiyonuyla set edilen sinyal fonksiyonundaki siginfo_t yapısının diğer elemanlarını ilgili dokümanlardan inceleyiniz.
    (Örneğin burada sinyali gönderen proses id'si, gerçek kullanıcı id'si, sinyalin neden gönderildiği gibi bilgiler vardır.)
---------------------------------------------------------------------------------------------------------------------------*/

/* proc1.c */

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

void exit_sys(const char *msg);

/* ./prog1 <realtime signal no> <process id> <count> */

int main(int argc, char *argv[])
{
    int signo;
    pid_t pid;
    int count;
    int i;
    union sigval val;

    if (argc != 4) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    signo = (int)strtol(argv[1], NULL, 10);
    pid = (pid_t)strtol(argv[2], NULL, 10);
    count = (int)strtol(argv[3], NULL, 10);

    for (i = 0; i < count; ++i) {
        val.sival_int = i;
        if (sigqueue(pid, SIGRTMIN + signo, val) == -1)
            exit_sys("sigqueue");
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigusr1_handler(int sno)
{
    printf("sigusr1 occurred...\n");        /* UNSAFE */
}

/* proc2.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigrt_handler(int signo, siginfo_t *info, void *context);

/* ./prog2 <realtime signal no> */

int main(int argc, char *argv[])
{
    struct sigaction act;
    int signo;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    signo = (int)strtol(argv[1], NULL, 10);

    act.sa_sigaction = sigrt_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_SIGINFO;

    if (sigaction(SIGRTMIN + signo, &act, NULL) == -1)
        exit_sys("sigaction");

    for(;;)
        pause();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigrt_handler(int signo, siginfo_t *info, void *context)
{
    printf("SIGRTMIN + 0 occurred with %d code\n", info->si_value.sival_int);        /* UNSAFE */
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                78. Ders 03/09/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi gerçek zamanlı sinyallere farklı isimler karşı getirilmemiştir. Gerçek zamanlı sinyallerin
    minimum numaraları SIGRTMIN ve maksimum numaraları SIGRTMAX sembolik sabitleriyle <signal.h> içerisinde define edilmiştir. 
    Kursun yapıldığı Linux sistemlerinde SIGRTMIN değeri 34, SIGRTMAX değeri 64'tür. Aslında Linux'ta gerçek zamanlı sinyallerin 
    numaraları 32'den başlamaktadır. Ancak pthread kütüphanesi bunların ilk iki tanesini kullandığı için SIGRTMIN değeri 34'tür. 
    POSIX standartlarında bir sistemin minimum destekleyeceği gerçek zamanlı sinyal sayısı _POSIX_RTSIG_MAX sembolik sabitiyle 
    belirtilmiştir. Bu sembolik sabit 8'dir. Yani UNIX türevi bir sistem en azından 8 gerçek zamanlı sinyali desteklemelidir. 
    Tabii aslında bu minimum değerdir. Pek çok UNIX türevi sistem bundan daha fazla sayıda gerçek zamanlı sinyali desteklemektedir. 
    Bir sistemde, o sistem tarafından desteklenen gerçek zamanlı sinyallerin sayısı ayrıca <limits.h> içerisinde RTSIG_MAX sembolik 
    sabitiyle belirtilmiştir. Yani RTSIG_MAX aslında _POSIX_RTSIG_MAX sembolik sabitinin ilgili sistemdeki gerçek değerini belirtmektedir. 
    Ancak bu RTSIG_MAX sembolik sabiti aslında define edilmek zorunda değildir. Bu durumda bu değer sysconf fonksiyonuyla 
    argüman olarak _SC_RTSIG_MAX değeri geçirilmek suretiyle elde edilmektedir. (Sistem limitleri biraz karmaşık bir konudur.
    Zaten bu konu ayrı bir başlık altında ileride ele alınacaktır.) Linux sistemlerinde <limits.h> dosyası içerisinde RTSIG_MAX değeri 
    32 olarak define edilmiştir.

    Yukarıda da belirttiğimiz gibi gerçek zamanlı sinyaller kuyruklanmaktadır. Yani bir sinyal birden fazla kez oluştuğunda 
    bunlar işletim sistemi tarafından bir kuyruk sisteminde saklanmaktadır. İşte bu kuyruğun uzunluğu da sistemden sisteme 
    değişebilmektedir. POSIX standartları bir sistemin desteklemesi gereken en az kuyruk uzunluğunu _POSIX_SIGQUEUE_MAX
    sembolik sabitiyle <limits.h> dosyası içerisinde belirtmiştir. Bu sembolik sabitin değeri 32'dir. Ancak buradaki kuyruk 
    uzunluğu toplam kuyruk uzunluğudur. Yani her sinyal için ayrı bir kuyruk düşünülmemelidir. Belli bir sistemdeki gerçek değer 
    SIGQUEUE_MAX sembolik sabitiyle <limits.h> içerisinde belirtilmektedir. Ancak bu sembolik sabit de define edilmek zorunda 
    değildir. Linux sistemlerinde SIGQUEUE_MAX sembolik sabiti define edilmemiştir. Linux'ta bu değer eskiden 1024'tü. 
    Sonra NPROC sayısına hizalanmıştır. Programcı bunu Linux sistemlerinde en az 1024 olarak düşünebilir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#include <signal.h>

void exit_sys(const char *msg);

int get_queuemax(void)
{
    int queue_max;

#ifdef SIGQUEUE_MAX
    queue_max = SIGQUEUE_MAX;
#else
    queue_max = sysconf(_SC_SIGQUEUE_MAX);
#endif

    return queue_max;
}

int main(void)
{

    printf("%d\n", SIGRTMIN);            /* 34 */
    printf("%d\n", SIGRTMAX);            /* 64 */
    printf("%d\n", RTSIG_MAX);            /* 32 */
    // printf("%d\n", SIGQUEUE_MAX);    /* Undeclared */
    printf("%d\n", get_queuemax());        /* 30231 */

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Gerçek zamanlı sinyalleri gönderebilmek için sigqueue isimli bir POSIX fonksiyonu kullanılmaktadır. Fonksiyonun prototipi
    şöyledir:

    #include <signal.h>

    int sigqueue(pid_t pid, int signo, union sigval value);

    Fonksiyonun birinci parametresi sinyalin gönderileceği prosesin id değerini almaktadır. İkinci parametre gönderilecek sinyalin
    numarasını belirtmektedir. Üçüncü parametre ise sinyale iliştirilecek ekstra bilgiyi belirtmektedir. sigval isimli birlik (union) 
    şöyle bildirilmiştir:

    union sigval {
        int   sival_int;
        void *sival_ptr;
    };

    Görüldüğü gibi sinyale int bir bilgi de bir adres bilgisi de iliştirilebilmektedir. Tabii sinyale adres bilgisi iliştirilecekse
    bu adresin hedef proseste anlamlı olması gerekmektedir. Fonksiyon başarı durumunda 0, başarısızlık durumunda -1 değerine geri 
    dönmektedir. Bir fonksiyona sigqueue fonksiyonuyla sinyal gönderebilmek için tıpkı kill fonksiyonunda olduğu gibi sinyal gönderen 
    prosesin gerçek ya da etkin kullanıcı id'sinin, hedef prosesin gerçek ya da saklı kullanıcı id'si aynı olması ya da prosesin uygun 
    önceliğe sahip olması gerekmektedir.

    sigqueue fonksiyonu ile gerçek zamanlı sinyallerin dışında normal sinyaller de gönderilebilmektedir. Ancak normal sinyaller
    sigqueue fonksiyonu ile gönderilse bile kuyruklanmayacaktır. Benzer biçimde kill fonksiyonu ile gerçek zamanlı sinyaller de 
    gönderilebilmektedir. Ancak kill fonksiyonunun bu kuyruklamaya yol açıp açmayacağı sistemden sisteme değişebilmektedir.

    sigqueue fonksiyonunda, kill fonksiyonunda olduğu gibi "proses grubuna" sinyal gönderebilme gibi bir özellik yoktur.

    sigqueue fonksiyonu ile gönderilen sinyalin sigaction fonksiyonunda SA_SIGINFO bayrağı ile üç parametreli fonksiyon tarafından 
    alınması da zorunlu değildir. Yani sigqueue fonksiyonu ile gönderilen sinyal, normal sinyal fonksiyonu ile de elde edilebilir. 
    Ancak bu durumda sinyale iliştirilen bilgi elde edilemeyecektir. Özetle:

    1) sigqueue ile gerçek zamanlı sinyal göndermek zorunda değiliz. Ancak gerçek zamanlı olmayan sinyaller kuyruklanmaz.
    2) sigqueue ile gönderilen sinyalin üç parametreli sinyal fonksiyonuyla ele alınması da zorunlu değildir. Ancak bu 
    durumda sinyale iliştirilen bilgi elde edilemektedir. 
    3) Ters bir biçimde kill fonksiyonuyla gönderilen sinyal üç parametreli sinyal fonksiyonu ile de ele alınabilir. Tabii 
    bu durumda bir değer elde edilmeyecektir.
    4) kill fonksiyonuyla gerçek zamanlı sinyal gönderilebilir. Ancak bunun semantiği açıkça belirtilmemiştir. Yani gönderilen 
    sinyal kuyruklanmayabilir. kill fonksiyonuyla gerçek zamanlı sinyal göndermeye çalışmayınız.

    kill kabuk komutu default durumda kill fonksiyonu kullanılarak yazılmıştır. Ancak kill kabuk komutunda -q <değer> seçeneği
    kullanılırsa bu durumda kill kabuk komutu sigqueue fonksiyonunu kullanacaktır.

    Aşağıda bir prosese sigqueue fonksiyonu ile sinyal gönderen bir örnek program verilmiştir. Program üç komut satırı argümanı
    almaktadır. Kullanımı şöyledir:

    $ ./sq <process id> <sig> <value> 

    Linux'ta ilk gerçek zamanlı sinyalin 34 numara olduğunu anımsayınız. Normal olarak gerçek zamanlı sinyaller sigqueue 
    fonksiyonu ile gönderilirken numara SIGRTMIN + n biçiminde belirtilmektedir. Örneğin:

    if (sigqueue(atoi(argv[1]), SIGRTMIN + 1, sv) == -1)
        exit_sys("sigqueue");

    Normal sinyallerin Linux'taki numaraları için signal(7) man sayfasına başvurabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* sq.c */

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

/* ./sq <process id> <sig> <value> */

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    union sigval sv;

    if (argc != 4) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    sv.sival_int = atoi(argv[3]);
    if (sigqueue(atoi(argv[1]), atoi(argv[2]), sv) == -1)
        exit_sys("sigqueue");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    sigqueue fonksiyonu ile gönderilen sinyalin üç parametreli sinyal fonksiyonu ile alınması uygundur. Anımsanacağı gibi üç
    parametreli sinyal fonksiyonunun parametrik yapısı şöyleydi:

    void signal_handler(int signo, siginfo_t *info, void *context);

    Burada fonksiyonun birinci parametresi yine sinyalin numarasını belirtir. İkinci parametresi ise oluşan sinyal hakkındaki
    ayrıntılı bilgilerin bulunduğu siginfo_t türünden bir yapı nesnesinin adresini belirtir. Bu yapının pek çok elemanı vardır:

    siginfo_t {
        int      si_signo;     /* Signal number */
        int      si_errno;     /* An errno value */
        int      si_code;      /* Signal code */
        int      si_trapno;    /* Trap number that caused hardware-generated signal (unused on most architectures) */
        pid_t    si_pid;       /* Sending process ID */
        uid_t    si_uid;       /* Real user ID of sending process */
        int      si_status;    /* Exit value or signal */
        clock_t  si_utime;     /* User time consumed */
        clock_t  si_stime;     /* System time consumed */
        union sigval si_value; /* Signal value */
        int      si_int;       /* POSIX.1b signal */
        void    *si_ptr;       /* POSIX.1b signal */
        int      si_overrun;   /* Timer overrun count; POSIX.1b timers */
        int      si_timerid;   /* Timer ID; POSIX.1b timers */
        void    *si_addr;      /* Memory location which caused fault */
        long     si_band;      /* Band event (was int in glibc 2.3.2 and earlier) */
        int      si_fd;        /* File descriptor */
        short    si_addr_lsb;  /* Least significant bit of address (since Linux 2.6.32) */
        void    *si_lower;     /* Lower bound when address violation occurred (since Linux 3.19) */
        void    *si_upper;     /* Upper bound when address violation occurred (since Linux 3.19) */
        int      si_pkey;      /* Protection key on PTE that caused fault (since Linux 4.6) */
        void    *si_call_addr; /* Address of system call instruction (since Linux 3.5) */
        int      si_syscall;   /* Number of attempted system call (since Linux 3.5) */
        unsigned int si_arch;  /* Architecture of attempted system call (since Linux 3.5) */
    }

    Bu yapının önemli elemanları ve anlamları şunlardır:

    int si_signo:    Oluşan sinyalin numarası.
    int si_errno:    O andaki errno değeri (saklayıp geri yüklemek için gerekebilmektedir).
    pid_t si_pid:    Sinyali gönderen prosesin proses id'sini belirtmektedir.
    uid_t si_uid:    Sinyali gönderen prosesin gerçek kullanıcı id'sini belirtir.
    int si_int:        sigqueue fonksiyonundaki sinyale iliştirilen int değer.
    void *si_ptr:    sigqueue fonksiyonundaki sinyale iliştirilen adres bilgisi.

    sinyal fonksiyonunun üçüncü parametresi (context parametresi) sinyal oluşmadan önceki durum bilgisinin bulunduğu yerin 
    adresini belirtmektedir. Bu parametre Linux sistemlerinde ucontext_t türünden bir yapı nesnesinin adresini tutmaktadır.
    Bu parametreye çok nadir biçimde gereksinim duyulmaktadır.

    Aşağıdaki örnekte "sample" programı üç parametreli sinyal fonksiyonunu kullanmaktadır. Program hangi sinyal için sinyal 
    fonksiyonunu set edeceğini belirten bir komut satırı argümanı almaktadır. Program sonsuz bir döngüde pause çağrılarıyla 
    beklemektedir. Dolayısıyla programı Ctrl+C tuşları ile sonlandırabilirsiniz. Programın kullanımı şöyledir:

    $ ./sample 34

    Bu örnekte 34 Linux'taki ilk gerçek zamanlı sinyal numarasıdır. Bu programa yukarıdaki programı kullanarak sigqueue fonksiyonu 
    ile sinyal gönderebilirsiniz. Örneğin:

    $ ./sq 34183 34 123

    sample programı ona iliştirilen int bilgiyi de sinyal geldiğinde ekrana yazdırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <signal.h>
#include <unistd.h>

void signal_handler(int signo, siginfo_t *info, void *context);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    struct sigaction sa;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("Process id: %jd\n", (intmax_t)getpid());

    sa.sa_sigaction = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART|SA_SIGINFO;

    if (sigaction(atoi(argv[1]), &sa, NULL) == -1)
        exit_sys("sigaction");

    printf("waiting for signals...\n");

    for (;;)
        pause();

    return 0;
}

void signal_handler(int signo, siginfo_t *info, void *context)
{
    printf("#%d signal handler: %d\n", signo, info->si_int);        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekle gerçek zamanlı sinyallerin kuyruklandığını ancak gerçek zamanlı olmayan sinyallerin kuyruklanmadığını 
    gözlemleyebilirsiniz. Buradaki "sample" programını önce 10 numaralı sinyal ile (SIGUSR1) sonra da 34 numaralı sinyal ile 
    (SIGRTMIN + 0) çalıştırınız. Diğer bir terminalden "sample" programı 30 saniye beklerken birkaç sinyal gönderiniz. "sample" 
    programı 30 saniye sonra blokeyi açtığında gerçek zamanlı olmayan sinyaller için bunlardan bir tanesinin teslim edildiğini, 
    gerçek zamanlı sinyaller için hepsinin teslim edildiğini göreceksiniz. Örneğin 10 numaralı sinyal ile (SIGUSR1) şöyle bir 
    durum oluşmuştur:

    Birinci terminal

    $ ./sample 10
    Process id: 46480
    sleep 30 seconds...
    #10 signal handler: 12
    ^C

    İkinci Terminal

    $ ./sq 46480 10 12
    $ ./sq 46480 10 13
    $ ./sq 46480 10 14
    $ ./sq 46480 10 15
    $ ./sq 46480 10 16
    $ ./sq 46480 10 17

    Örneğin 34 numaralı sinyal ile (SIGRTMIN + 0) şöyle bir durum oluşmuştur:

    Birinci Terminal

    $ ./sample 34
    Process id: 46528
    sleep 30 seconds...
    #34 signal handler: 17
    #34 signal handler: 18
    #34 signal handler: 100
    #34 signal handler: 120
    #34 signal handler: 60
    #34 signal handler: 10

    İkinci Terminal

    $ ./sq 46528 34 17
    $ ./sq 46528 34 18
    $ ./sq 46528 34 100
    $ ./sq 46528 34 120
    $ ./sq 46528 34 60
    $ ./sq 46528 34 10
---------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <signal.h>
#include <unistd.h>

void signal_handler(int signo, siginfo_t *info, void *context);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    struct sigaction sa;
    sigset_t ss;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("Process id: %jd\n", (intmax_t)getpid());

    sa.sa_sigaction = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART|SA_SIGINFO;

    if (sigaction(atoi(argv[1]), &sa, NULL) == -1)
        exit_sys("sigaction");

    sigfillset(&ss);
    sigdelset(&ss, SIGINT);
    if (sigprocmask(SIG_BLOCK, &ss, NULL) == -1)
        exit_sys("sigprocmask");

    printf("sleep 30 seconds...\n");
    sleep(30);

    if (sigprocmask(SIG_UNBLOCK, &ss, NULL) == -1)
        exit_sys("sigprocmask");

    for (;;)
        pause();

    return 0;
}

void signal_handler(int signo, siginfo_t *info, void *context)
{
    printf("#%d signal handler: %d\n", signo, info->si_int);        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* sq.c */

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    union sigval sv;

    if (argc != 4) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    sv.sival_int = atoi(argv[3]);
    if (sigqueue(atoi(argv[1]), atoi(argv[2]), sv) == -1)
        exit_sys("sigqueue");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                79. Ders 09/09/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Senkron biçimde sinyal oluşmasını bekleyen iki ilginç fonksiyon vardır: sigwait ve sigwaitinfo. sigwaitinfo fonksiyonu 
    POSIX'e "Realtime Extensions" eklemeleri sırasında dahil edilmiştir. sigwait fonksiyonu uzun süredir zaten bulunmaktadır. 
    Fonksiyonların prototipleri şöyledir:

    #include <signal.h>

    int sigwait(const sigset_t *set, int *sig);
    int sigwaitinfo(const sigset_t *set, siginfo_t *info);

    Bu fonksiyonlar birinci parametresiyle belirtilmiş olan sinyal kümesindeki herhangi bir sinyal oluşana kadar thread'i blokede 
    bekletmektedir. Yani bu fonksiyonlarda biz hangi sinyaller için bekleme yapacağımızı fonksiyonun birinci parametresiyle 
    fonksiyona veririz. Fonksiyon da bu sinyallerden biri oluşana kadar çağrıyı yapan thread'i bloke bekletir. Fonksiyonlar 
    bizim belirttiğimiz kümedeki hangi sinyal dolayısıyla sonlanmışsa o sinyalin bilgilerini bizim ikinci parametreyle verdiğimiz 
    nesneye yerleştirmektedir. sigwait ile sigwaitinfo arasındaki tek fark sigwait fonksiyonunun yalnızca oluşan sinyalin numarasını 
    bize vermesi ancak sigwaitinfo fonksiyonunun oluşan sinyalin pek çok bilgisini siginfo_t yapısı eşliğinde bize vermesidir. 
    sigwait fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda errno değerinin kendisine geri dönmektedir. Zaten 
    POSIX standartları başarısızlık durumunda yalnızca EINVAL errno değerini tanımlamıştır. Ancak sigwaitinfo fonksiyonu başarı 
    durumunda 0, başarısızlık durumunda -1 değerine geri dönmekte ve errno değişkenini uygun biçimde set etmektedir. (sigwait 
    fonksiyonunun errno değişkenini set etmediğine ancak sigwaitinfo fonksiyonunun set ettiğine dikkat ediniz.)

    Biz bu fonksiyonların sinyal kümelerine normal sinyalleri de gerçek zamanlı sinyalleri de ekleyebiliriz. Gerçek zamanlı sinyaller 
    kuyruklandığı için kuyruktaki yalnızca ilk sinyalin bilgisi elde edilecektir. Ancak POSIX standartları pending duruma geçen 
    birden fazla sinyal olduğunda gerçek zamanlı sinyallerden düşük numarada (yüksek öncelikte) olanın bilgilerinin elde edileceğini
    belirtmiş olsa da pending durumda olan hem normal sinyal hem de gerçek zamanlı sinyal olduğunda bunların hangisinin bilgilerinin
    elde edileceği konusunda bir belirlemede bulunmamıştır (unspecified).

    Normal olarak fonksiyonların birinci parametrelerinde belirtilen sinyallerin daha önceden bloke edilmiş olması gerekmektedir. 
    POSIX standartları eğer bu sinyaller bloke edilmediyse fonksiyon çağrısının tanımsız davranış oluşturacağını belirtmektedir.

    Görüldüğü gibi biz sinyalleri bloke edip sigwait ya da sigwaitinfo fonksiyonlarıyla bekleyerek işlediğimizde aslında o 
    sinyalleri asenkron değil, senkron bir biçimde işlemiş olmaktayız.

    Aşağıdaki örnekte önce SIGINT ve SIGUSR1 sinyalleri bloke edilmiş sonra da sigwait fonksiyonu ile bu sinyaller oluşana kadar
    bekleme yapılmıştır. Bu sinyallerden biri gerçekleştiğinde gerçekleşen sinyalin numarası da stdout dosyasına yazdırılmıştır.
    Daha sonra bloke edilen sinyallerin blokelerinin de açıldığına dikkat ediniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

void exit_sys(const char *msg);

int main(void)
{
    sigset_t sset;
    int signo;
    int result;

    sigaddset(&sset, SIGUSR1);
    sigaddset(&sset, SIGINT);

    if (sigprocmask(SIG_BLOCK, &sset, NULL) == -1)
        exit_sys("sigprocmask");

    printf("waiting for signal...\n");

    if ((result = sigwait(&sset, &signo)) != 0) {
        fprintf(stderr, "sigwait: %s\n", strerror(result));
        exit(EXIT_FAILURE);
    }

    printf("%d signal occurred and processing...\n", signo);

    if (sigprocmask(SIG_UNBLOCK, &sset, NULL) == -1)
        exit_sys("sigprocmask");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi C'de goto işlemi aynı fonksiyon içerisinde yapılabilen bir işlemdir. Yani biz C'de bir fonksiyondan başka 
    bir fonksiyonun bir yerine goto yapamayız. Zaten goto etiketleri de C'de "fonksiyon faaliyet alanına (function scope)"
    sahiptir. İşte bir fonksiyondan başka bir fonksiyona goto yapmaya C dünyasında "long jump" denilmektedir. Her ne kadar
    bu "long jump" konusu aslında C Programlama Dili'ne ilişkin bir konu ise de genellikle bu eğitimlerde çok ayrıntı olduğu için
    bu fonksiyon üzerinde durulmamaktadır. Ancak long jump işlemleri sinyaller söz konusu olduğunda UNIX/Linux Sistem Programlama
    faaliyetlerinde kullanılabilmektedir. Biz de burada önce "long jump" işlemini ele alacağız. Sonra da onun sinyaller 
    konusundaki kullanımları üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyondan başka bir fonksiyona goto yapılamamasının temel nedenleri şunlardır:

    1) goto işleminin yapıldığı fonksiyondaki yerel değişkenler stack'tan nasıl boşaltılacaktır? (Bu problem kısmen çözülebilir)
    2) goto yapılan fonksiyondaki yerel değişkenler goto yapıldığı noktada yaratılmış olmayacağı için bu durumda ne olacaktır?
    3) goto yapılan fonksiyon return işlemi yaptığında nereye geri dönecektir? Bu fonksiyon çağrılmadığına göre nereye geri 
    döneceği belli değildir.

    Ancak program akışının daha önce geçilmiş olan başka bir fonksiyondaki bir noktaya aktarılmasında teknik bir sorun yoktur.
    Çünkü daha önce geçilen noktadaki CPU yazmaçlarının konumu saklanırsa ve "long jump" sırasında bu yazmaçların konumu o
    değerlerle yüklenirse adeta akış sanki zamanda geri gitmiş ve geçmişteki o noktaya geri dönülmüş gibi olmaktadır. İşte 
    biz C'de long jump işlemi ile ancak daha önce geçmiş olduğumuz bir noktaya geri dönebiliriz.

    C'de long jump işlemi oldukça basit olarak iki standart C fonksiyonuyla yapılmaktadır: setjmp ve longjmp. Fonksiyonların 
    prototipleri şöyledir:

    #include <setjmp.h>

    int setjmp(jmp_buf env);
    void longjmp(jmp_buf env, int val);

    setjmp fonksiyonu, fonksiyonun çağrıldığı noktadaki CPU yazmaçlarının konumunu alarak jmp_buf ile belirtilen alana yerleştirmektedir. 
    setjmp fonksiyonuna geçirilen jmp_buf nesnesinin global bir biçimde oluşturulmuş olması gerekir. Çünkü bu nesne geriye 
    dönüşte başka bir fonksiyonda longjmp yaparken de kullanılacaktır. longjmp işleminde geri dönüş aslında setjmp fonksiyonunun 
    içerisine yapılmaktadır. Böylece setjmp fonksiyonunun geri dönmesi akışın ilk kez geçişi sırasında olabileceği gibi longjmp 
    ile geri dönüş sırasında da olabilmektedir. Tabii programcının sonsuz döngüye girmemek için setjmp fonksiyonundan akışın 
    ilk kez geçmesinden dolayı mı yoksa longjmp işleminden dolayı mı çıkıldığını anlaması gerekir. İşte setjmp fonksiyonundan ilk 
    kez çıkılırken setjmp fonksiyonu 0 ile geri dönmekte ancak setjmp fonksiyonundan longjmp nedeniyle çıkıldığında setjmp 
    fonksiyonu, longjmp fonksiyonunun ikinci parametresi için girilen argümanla geri dönmektedir. Böylece programcı setjmp 
    fonksiyonundan hangi nedenle çıkıldığını anlayıp geri dönüşte sonsuz döngü oluşmasını engelleyebilir. Örneğin:

    jmp_buf g_jbuf;
    ...

    void foo(void)
    {
        ...

        if (setjmp(g_jbuf) == 1) {
            ...
        }
        else
            bar();
        ...
    }

    void some_func(void)
    {
        ...
        longjmp(g_jbuf, 1);
        ...
    }

    Burada foo fonksiyonunun içerisinde geri dönüş için geri dönüş noktası setjmp fonksiyonunda kaydedilmiştir. Bu kayıttan 
    sonra programcı bar fonksiyonunu çağırarak yoluna devam etmiştir. Ancak akış bar tarafından çağrılan fonksiyon zincirinden 
    biri olan some_func tarafından yeniden longjmp fonksiyonu ile geçmişe yani foo içerisindeki setjmp içerisine aktarılmıştır. 
    Bu durumda artık setjmp'den 1 değeri ile çıkılacak ve tekrar bar fonksiyonu çağrılmayacaktır.

    Aşağıda longjump kullanımına bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <setjmp.h>

void foo(void);
void bar(void);
void tar(void);

jmp_buf g_jbuf;

int main(void)
{
    printf("main begins...\n");

    foo();

    printf("main ends...\n");

    return 0;
}

void foo(void)
{
    printf("foo begins...\n");

    if (setjmp(g_jbuf) != 1)
        bar();

    printf("foo ends...\n");
}

void bar(void)
{
    printf("bar begins...\n");

    tar();

    printf("bar ends...\n");
}

void tar(void)
{
    printf("tar begins...\n");

    longjmp(g_jbuf, 1);

    printf("tar ends...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz setjmp yaptığımızda prosesteki bazı sinyaller bloke edilmişse ve daha sonra bu sinyallerin blokesi açılmışsa 
    biz longjmp ile eski noktaya dönerken sinyallerin bloke durumu ne olacaktır? İşte POSIX standartları setjmp işleminde 
    kayıt yapılırken prosesin sinyal bloke kümesinin de kaydedilip longjmp sırasında geri yükleneceği konusunda bir garanti 
    vermemiştir (unspecified). Bu nedenle eğer geri dönüşte aynı sinyal bloke kümesinin de yüklenmesi isteniyorsa setjmp ve 
    longjmp yerine sigsetjmp ve siglongjmp fonksiyonları kullanılmalıdır. Bu fonksiyonların prototipleri şöyledir:

    #include <setjmp.h>

    int sigsetjmp(sigjmp_buf env, int savemask);
    void siglongjmp(sigjmp_buf env, int val);

    Görüldüğü gibi fonksiyonların genel kullanımı setjmp ve longjmp fonksiyonu ile benzerdir. Ancak sigsetjmp fonksiyonu iki
    parametre almaktadır. Bu ikinci parametre (savemask parametresi) 0 ise prosesin sinyal bloke kümesi kaydedilip geri yükleme 
    yapılmaz, sıfır dışı ise kaydedilip geri yükleme yapılır. (Yani ikinci parametre 0 geçilirse fonksiyon setjmp gibi 
    davranmaktadır.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi "long jump" işlemine neden gereksinim duyulmaktadır? İşte bazı durumlarda programcı bulunan durumdan kaçıp geçmişteki 
    daha güvenli bir noktaya dönmek isteyebilir. Örneğin sinyal fonksiyonlarının içerisinde long jump işlemine sıkça rastlanmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                80. Ders 10/09/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Örneğin biz SIGSEGV sinyali oluştuğunda programı sonlandırmayıp başka birtakım işlemlerle programın çalışmasına devam etmesini
    isteyebiliriz. Bu durumda SIGSEGV sinyali için sinyal fonksiyonu set ederiz, ancak bu sinyal fonksiyonunda daha önceki bir 
    noktaya "long jump" yapabiliriz. Aşağıda bu duruma bir örnek verilmiştir. Bu örnekte sigsetjmp ve siglongjmp kullanmanın 
    özellikle bir nedeni yoktur. Yani örneğimizde setjmp ve longjmp fonksiyonlarını da kullanabilirdik.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <setjmp.h>

void sigsegv_handler(int sig);
void exit_sys(const char *msg);

jmp_buf g_jbuf;

int main(void)
{
    struct sigaction sa;
    char *str = (char *)0x12345678;

    sa.sa_handler = sigsegv_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGSEGV, &sa, NULL) == -1)
        exit_sys("sigaction");

    if (sigsetjmp(g_jbuf, 1) == 1) {
        printf("SIGSEGV occures, but we continue...\n");        /* UNSAFE */
        /* ... */
    }
    else {
        *str = 'x';
        /* ... */
    }

    return 0;
}

void sigsegv_handler(int sig)
{
    /* ... */

    siglongjmp(g_jbuf, 1);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz sinyal fonksiyonları içerisinde yalnızca asenkron sinyal güvenli fonksiyonları kullanabiliyorduk. Sinyal fonksiyonu 
    içerisinde longjmp yaparsak "long jump" yaptığımız yerde sinyal güvenli fonksiyonlar kullanmak zorunda mıyız? İşte sinyal 
    fonksiyonu çalıştırılıp oradan "long jump" yapıldığında atlanılan yerde de sinyal güvenli fonksiyonların kullanılması 
    gerekir. Çünkü bu bakımdan "reentancy" durumunda bir değişiklik yoktur.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sinyal fonksiyonları içerisinde tüm programın sonlandırılması isteniyorsa bu işlem exit standart C fonksiyonu ile yapılmamalıdır.
    Çünkü exit fonksiyonu stdio dosyalarını kapatıp onların tamponlarını tazelemektedir. Dolayısıyla exit fonksiyonu asenkron sinyal 
    güvenli bir fonksiyon değildir. Bu tür durumlarda doğrudan _exit POSIX fonksiyonu ile proses sonlandırılabilir. Anımsanacağı 
    gibi _exit fonksiyonu aslında doğrudan işletim sisteminin prosesi sonlandıran sistem fonksiyonunu çağırmaktadır. Ayrıca 
    C99 ile C'ye eklenen _Exit fonksiyonu da POSIX standartlarına göre asenkron sinyal güvenlidir. _Exit standart C fonksiyonunun 
    stdio tamponlarını flush edip etmeyeceği derleyicileri yazanların isteğine bırakılmıştır. POSIX standartlarına göre 
    bu fonksiyon tamamen _exit fonksiyonu ile eşdeğer işleve sahiptir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi bazı sinyallerdeki default eylem, prosesin sonlandırılmasıyla birlikte bir "core" dosyasının oluşturulmasıdır. 
    Buradaki "core" terimi eski bir terimdir ve ana belleği belirtmektedir. Core dosyasının üretilmesinin amacı onun debugger 
    altında incelenmesine olanak sağlanmasıdır. Böylece çöken bir programda, programın neden ve nerede çöktüğüne ilişkin bir 
    analiz yapılabilmektedir. Core dosyasının incelenmesi çeşitli debugger'larla yapılabilmektedir. Tabii UNIX/Linux dünyasında 
    en yaygın kullanılan debugger "gdb" isimli GNU projesi kapsamında oluşturulmuş olan debugger'dır. Biz izleyen paragraflarda 
    Linux sistemlerinde "core dosyalarına" yönelik bazı açıklamalarda bulunacağız. gdb debugger'ının temel kullanımı başka 
    bölümlerde ele alınacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde sinyal yoluyla core dosyası oluşturulması için sistem limitlerinin uygun olması gerekmektedir. 
    "ulimit -a" komutu ile sistem limitlerine bakılabilir. Eğer burada "core file size" 0 ise bunun artırılması gerekir. 
    "ulimit -c" ile yalnızca "core file size" bilgisi de görüntülenebilmektedir. Bu sınırın "unlimited" hale getirilmesi 
    şöyle yapılabilir:

    $ ulimit -c unlimited

    Core dosyasının üretildiği yer Linux sistemlerinde kullanılan bazı sistem paketlerine göre değişebilmektedir. Eskiden core 
    dosyaları prosesin çalışma dizininde yaratılıyordu. Daha sonra "systemd" paketi ile birlikte core dosyalarının yaratılması 
    biraz daha ayrıntılı hale getirilmiştir. Öncelikle core dosyalarının nasıl isimlendirildiğinin belirlenmesi gerekir. 
    Bunun için proc dosya sisteminde "/proc/sys/kernel/core_pattern" dosyasına bakılmalıdır. Bu dosya core dosyasının hangi 
    isimlendirme biçimiyle nerede yaratılacağını belirtmektedir. Örneğin bu dosyanın içeriği şöyle olabilir:

    |/lib/systemd/systemd-coredump %P %u %g %s %t 9223372036854775808 %h

    Burada core dosyasının üretilmesinde "systemd-coredump" isimli programın kullanılacağı belirtilmektedir. Bu programın dokümantasyonu 
    SYSTEMD-COREDUMP(8) man sayfasında yapılmıştır. Buradaki core_pattern dosyasının içeriğinde bulunan % format karakterleri core
    dosyasının hangi isimlerle kombine edilerek üretileceğini belirtmektedir. core dosyasının yeri aslında systemd-coredump programının 
    konfigürasyonunda belirlenmektedir. Default olarak /var/lib/systemd/coredump dizini kullanılmaktadır. Core dosyaları genellikle 
    lz4 formatında sıkıştırılmış bir biçimde tutulmaktadır. Bazı sistemlerde "core dump" utility'si olarak apport denilen program 
    da kullanılmaktadır. Bazı sistemlerde core_pattern dosyasının içeriği aşağıdaki gibi de olabilir:

    |/usr/share/apport/apport -p%p -s%s -c%c -d%d -P%P -u%u -g%g -- %E

    Burada core dosyasının yaratılma organizasyonu "apport" denilen programa devredilmiştir. Bu program da "core" dosyasını
    "/var/lib/systemd/coredump" dizininde ya da "/var/lib/apport/coredump" dizininde oluşturmaktadır.

    Core dosyalarını kolay yüklemek için ayrıca "coredumpctl" isimli bir programdan da faydalanılabilir. Ancak bu program default
    olarak kurulu durumda değildir. Bunun kurulabilmesi için aşağıdaki komut uygulanabilir:

    $ sudo apt install systemd-coredump

    coredumpctl programı core dosyaları üzerinde işlem yapmayı kolaylaştıran bir programdır. Örneğin üretilmiş olan core dosyalarının 
    listeleri şöyle alınabilir:

    $ coredumpctl list

    Bu komutla tüm üretilmiş olan core dosyaları listelenecektir. En son üretilen dosya listenin sonunda olacaktır. Ancak ters 
    sırada görüntüleme için -r seçeneği kullanılabilmektedir.

    Artık coredumptctl programı yüklendiğine göre ondan faydalanabiliriz. En son core dosyasını gdb ile yüklemek için şöyle 
    yapılır:

    $ coredumpctl gdb

    Bu komut ile her zaman son core dosyası yüklenmektedir. Spesifik bir core dosyasının yüklenmesi de sağlanabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir grup prosesin oluşturduğu gruba "proses grubu" denilmektedir. Proses grubu kavramı bir grup prosese sinyal gönderebilmek 
    için uydurulmuştur. Gerçekten de kill sistem fonksiyonunun birinci parametresi olan pid sıfırdan küçük bir sayı olarak girilirse 
    abs(pid) numaralı proses grubuna sinyal gönderilmektedir. Bir sinyal bir proses grubuna gönderilirse o proses grubunun bütün 
    üyeleri olan proseslere gönderilmiş olur. Anımsanacağı gibi kill fonksiyonun birinci parametresi 0 girildiğinde, sinyal kill 
    fonksiyonunu uygulayan prosesin içinde bulunduğu proses grubuna gönderilmektedir. Yani proses kendi proses grubuna sinyali 
    göndermektedir.

    Her proses grubunun bir id'si vardır. Bir proses grubunun id'si o proses grubundaki bir prosesin proses id'si ile aynıdır. İşte
    proses id'si proses grup id'sine eşit olan prosese, o proses grubunun "proses grup lideri (process group leader)" denilmektedir. 
    Proses grup lideri genellikle proses grubunu yaratan prosestir. fork işlemi sırasında alt prosesin proses grubu onu yaratan 
    üst prosesten alınmaktadır. Yani üst proses hangi proses grubundaysa fork işlemi sonucunda yaratılan proses de aynı proses
    grubunda olur.

    Bir prosesin ilişkin olduğu proses grubunun id'sini alabilmek için getpgrp ya da getpgid POSIX fonksiyonları kullanılır.

    #include <unistd.h>

    pid_t getpgrp(void);
    pid_t getpgid(pid_t pid);

    getpgrp fonksiyonu prosesin kendi grup id'sini elde etmekte kullanılmaktadır. getpgid fonksiyonu ise herhangi bir prosesin 
    proses grup id'sini elde etmekte kullanılmaktadır. getpgid fonksiyonunun parametresi 0 geçilirse fonksiyonu çağıran prosesin 
    proses grup id'si alınmış olur. Yani aşağıdaki çağrı eşdeğerdir:

    pgid = getpgrp();
    pgid = getpgid(0);

    Proses grup lideri olan proses sonlanmış olsa bile proses grubunun id'si aynı biçimde kalmaya devam eder. Yani işletim 
    sistemi bu durumda prosesin id'sini o proses grubu bu id ile temsil edildiği için başka proses'te kullanmaz. Proses grubu 
    gruptaki son prosesin sonlanması ya da grup değiştirmesiyle ömrünü tamamlamaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kabuktan bir program çalıştırdığımızda kabuk fork işlemini yaptıktan sonra alt proses için yeni bir proses grubu oluşturur
    ve alt prosesi o proses grubunun grup lideri yapar. Artık bu program kendi içerisinde fork yaptığında oluşturulacak olan 
    alt proseslerin hepsi aynı proses grubunun içerisinde olacaktır. Örneğin aşağıdaki gibi "sample" isimli bir programı bir 
    terminalden çalıştırmış olalım:

    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>

    void exit_sys(const char *msg);

    int main(void)
    {
        pid_t pid;

        if ((pid = fork()) == -1)
            exit_sys("fork");

        pause();

        return 0;
    }

    void exit_sys(const char *msg)
    {
        perror(msg);

        exit(EXIT_FAILURE);
    }

    Diğer bir terminalden giriş yaparak o terminaldeki (örneğimizde "pts/0") programların proses id'leri, üst proses id'leri ve
    proses grup id'leri hakknda bilgi edinelim:

    $ ps -t pts/0 -o pid,ppid,pgid,cmd
    PID     PPID     PGID CMD
    26158   25044   26158 bash
    29577   26158   29577 ./sample
    29578   29577   29577 ./sample

    Burada ilk çalıştırdığımız sample programının yaratılan proses grubunun grup lideri olduğu görülmektedir. sample programında 
    fork yapılarak oluşturulmuş olan prosesin de proses grup id'sinin aynı olduğuna dikkat ediniz. Proses grup id'leri fork işlemi
    sırasında üst prosesten alt prosese aktarılmaktadır.

    Kabuk üzerinden boru sembolü ile birden fazla programı çalıştırdığımızda kabuk birden fazla proses oluşturmaktadır. 
    Örneğin:

    $ ls -l | grep "sample"

    Burada kabuk "ls" ve "grep" programını çalıştırmak için fork işlemleri yapacaktır. Ancak kabuk burada "ls" ve "grep" proseslerinin
    proses id'lerini aynı yapmaktadır. Örneğin pts/1 terminalinden aşağıdaki gibi bir komut çalıştırmış olalım:

    $ cat | grep "test"

    Burada kabuk programı bir proses grubu oluşturup "cat" ve "grep" komutlarını aynı proses grubuna atayacaktır. Diğer terminalden
    durumu inceleyelim:

    $ ps -t pts/0 -o pid,ppid,pgid,cmd
    PID     PPID    PGID CMD
    34667   34658   34667 bash
    49484   34667   49484 cat
    49485   34667   49484 grep --color=auto test

    Burada "cat" programının yaratılan proses grubunun proses lideri olduğu görülmektedir. "grep" programı da aynı proses 
    grubuna atanmıştır. Yani burada kabuk programı bir proses grubu yaratıp "cat" ve "grep" programlarını aynı proses grubuna
    atamıştır. Tabii burada eğer "cat" ve "grep" programları da kendi içlerinde fork yapsalardı onların alt prosesleri de 
    aynı proses grubuna dahil olacaklardı. Thread'lerin ayrı proses id'leri yoktur. Yalnızca proseslerin proses id'leri vardır. 
    Dolayısıyla bir prosesin herhangi bir thread'inde biz getpgrp fonksiyonunu uygularsak aynı değeri elde ederiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yeni bir proses grubu yaratmak için ya da bir prosesin proses grubunu değiştirmek için setpgid POSIX fonksiyonu kullanılmaktadır.

    #include <unistd.h>

    int setpgid(pid_t pid, pid_t pgid);

    Fonksiyonun birinci parametresi proses grup id'si değiştirilecek prosesi, ikinci parametresi de hedef proses grup id'sini 
    belirtmektedir. Eğer bu iki parametre aynı ise yeni bir proses grubu yaratılır ve bu yeni grubun lideri de buradaki proses 
    olur. Bir proses (uygun önceliğe sahip olsa bile) ancak kendisinin ya da kendi alt proseslerinin proses grup id'lerini 
    değiştirebilir. Fakat üst proses, alt proses exec uyguladıktan sonra artık onun proses grup id'sini değiştirememektedir. 
    Ayrıca setpgid fonksiyonu ile proses ancak kendisinin ya da alt proseslerinin proses grup id'lerini aynı "oturum (session)" 
    içerisindeki bir proses grup id'si olarak değiştirebilmektedir. Oturum (session) kavramı izleyen paragraflarda ele alınmaktadır.

    setpgid fonksiyonunun birinci parametresi 0 girildiğinde fonksiyonu çağıran proses anlaşılmaktadır. İkinci parametresi 0 
    girildiğinde birinci parametresinde belirtilen proses anlaşılmaktadır. Yani aşağıdaki çağrılar eşdeğerdir:

    setpgid(getpid(), getpid());
    setpgid(getpid(), 0);
    setpgid(0, getpid());
    setpgid(0, 0);

    Örneğin kabuktan bir program çalıştırdığımızda kabuk önce fork işlemini yapar sonra alt proseste setpgid fonksiyonu ile 
    yeni bir proses grubu yaratır. Çalıştırılan programı da yeni yaratılan proses grubunun proses grup lideri yapar.

    Aşağıdaki örnekte üst proses fork yaparak alt prosesi oluşturmuştur. Alt proseste de setpgid fonksiyonu ile yeni bir proses 
    grubu yaratılmıştır. Programın örnek çıktısı şöyledir:

    $ ./sample
    Parent process id: 49658
    Parent process id of the parent: 34667
    Parent process group id: 49658
    Child process id: 49659
    Parent process id of the child: 49658
    Child process group id: 49659

    Buradan şunlar anlaşılmaktadır:

    - Kabuk, sample programını çalıştırırken yeni bir proses grubu oluşturup sample programını bu proses grubunun grup lideri 
    yapmıştır.

    - Alt proseste yeni bir proses grubu yaratılmış, alt proses de bu proses grubunun grup lideri olmuştur.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pgid;
    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {        /* parent process */
        printf("Parent process id: %jd\n", (intmax_t)getpid());
        printf("Parent process id of the parent: %jd\n", (intmax_t)getppid());
        pgid = getpgrp();
        printf("Parent process group id: %jd\n", (intmax_t)pgid);

        if (waitpid(pid, NULL, 0) == -1)
            exit_sys("waitpid");
    }
    else {        /* child process */
        sleep(1);
        if (setpgid(getpid(), getpid()) == -1)        /* setpgid(0, 0) */
            exit_sys("setpgid");

        printf("Child process id: %jd\n", (intmax_t)getpid());
        printf("Parent process id of the child: %jd\n", (intmax_t)getppid());
        pgid = getpgrp();
        printf("Child process group id: %jd\n", (intmax_t)pgid);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtildiği gibi kill POSIX fonksiyonuyla (ya da kill komutuyla) bir proses grubuna sinyal gönderildiğinde
    aslında proses grubundaki tüm proseslere sinyal gönderilmektedir. Bunu aşağıdaki programla test edebilirsiniz.

    Aşağıdaki programda üst proses SIGSUR1 sinyalini set ederek fork işlemi yapmıştır. Böylece aynı sinyal alt proseste de 
    set edilmiş durumdadır. Bu programı çalıştırınca üst proses alt prosesi wait fonksiyonunda bekleyecek, alt proses de
    pause ile sinyal oluşana kadar blokede bekleyecektir. Diğer bir terminalden bu proses grubuna kill komutu ile SUGUSR1
    sinyalini göndermeyi deneyiniz. Bunu yaparken kill komutunda proses grup id'sini negatif yapmayı unutmayınız. Aşağıda 
    testin nasıl yapıldığına ilişkin örnek verilmiştir:

    - Terminallerden birinde "sample" programı çalıştırılır:

    $ ./sample
    Parent process id: 49792
    Parent process id of the parent: 34667
    Parent process group id: 49792
    Child process id: 49793
    Parent process id of the child: 49792
    Child process group id: 49792
    SIGUSR1 occurred in process 49793
    SIGUSR1 occurred in process 49792
    waitpid: Interrupted system call

    - Diğer bir terminalden proses grubuna SIGUSR1 sinyali gönderilir:

    $ kill -USR1 -49792
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/wait.h>

void sigusr1_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    pid_t pgid;
    pid_t pid;
    struct sigaction sa;

    sa.sa_handler = sigusr1_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGUSR1, &sa, NULL) == -1)
        exit_sys("siagaction");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {        /* parent process */
        printf("Parent process id: %jd\n", (intmax_t)getpid());
        printf("Parent process id of the parent: %jd\n", (intmax_t)getppid());
        pgid = getpgrp();
        printf("Parent process group id: %jd\n", (intmax_t)pgid);

        if (waitpid(pid, NULL, 0) == -1)
            exit_sys("waitpid");
    }
    else {        /* child process */
        sleep(1);
        printf("Child process id: %jd\n", (intmax_t)getpid());
        printf("Parent process id of the child: %jd\n", (intmax_t)getppid());
        pgid = getpgrp();
        printf("Child process group id: %jd\n", (intmax_t)pgid);

        pause();
    }

    return 0;
}

void sigusr1_handler(int sno)
{
    printf("SIGUSR1 occurred in process %ld\n", (intmax_t)getpid());        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                81. Ders 16/09/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Oturum (session) kabuktaki arka plan çalışmayı düzene sokmak için uydurulmuş bir kavramdır. Bir oturum proses gruplarından 
    oluşur. Oturumu oluşturan proses gruplarından yalnızca biri "ön plan (foreground)", diğerlerinin hepsi "arka plan (background)"
    proses gruplardır. İşte aslında terminal sürücüsü (tty) klavye sinyallerini oturumun ön plan proses grubuna yollamaktadır.

    Kabuk üzerinden bir komut yazıp komutun sonuna & karakteri getirilirse bu & karakteri "bu komutu arka planda çalıştır" 
    anlamına gelmektedir. Böylece kabuk çalıştırılan komutu wait fonksiyonlarıyla beklemez. Yeniden prompt'a düşer. Ancak o komut 
    çalışmaya devam etmektedir. İşte kabuk & ile çalıştırılan her komut için yeni bir proses grubu yaratır ve o proses grubunu 
    oturumun arka plan proses grubu durumuna getirir. Sonunda & olmadan çalıştırılan komutlar ise ön plan proses grubunu oluşturur. 
    Tabii oturumu yaratan aslında genellikle kabuk programlarıdır. Kabuk, oturumu ve proses grubunu yaratır. Kendisi de oturumda bir 
    proses grubunda bulunuyor olur. Oturumların birer id'si vardır. Bir oturumun id'si onu yaratan prosesin içinde bulunduğu proses 
    grubunun id'si olur. Oturumu yaratan bu prosese de "oturum lideri (session leader)" denilmektedir. (Oturum liderinin proses 
    id'sinin, proses grup id'sinin ve oturum id'sinin aynı olması gerektiğine dikkat ediniz.)

    O halde durum özetle şöyledir: Kabuk bir oturum ve bir proses grubu yaratır. Kendisini bu proses grubunun lideri yapar. 
    kendisi proses grubunun ve oturumun lideri durumundadır. (Bu işlemlerin nasıl yapıldığına ilişkin ayrıntılar izleyen paragraflarda 
    açıklanmaktadır.) Sonra kabuk sonu & ile biten komutlar için proses grupları yaratıp bu proses gruplarını oturumun arka plan 
    proses grupları yapar. Sonunda & olmayan komutları da oturumun ön plan proses grubu yapmaktadır. Böylece belli bir anda oturumun 
    içerisinde bir ön plan proses grubu ve çeşitli arka plan proses grupları bulunacaktır. Tabii kabuğun kendisi de "sonunda & 
    olmayan" bir komut uygulandığında oturumun arka plan proses grubu içerisinde bulunuyor olacaktır. Terminal sürücüsü de SIGINT 
    ve SIGQUIT gibi sinyalleri oturumun ön plan proses grubuna göndermektedir. Örneğin biz mample programını sonunda & olacak biçimde 
    sample programını da normal bir biçimde aşağıdaki gibi çalıştırmış olalım:

    $ ./mample &
    [1] 52630
    $./sample

    Her iki program da pause fonksiyonunda bekleyecek biçimde yazılmıştır. Şimdi diğer bir terminalden bu proseslerin id'lerini, 
    proses grup id'lerini, oturum id'lerini yazdıralım:

    $ ps -o pid,pgid,sid,cmd -t pts/0
    PID     PGID    SID CMD
    31684   31684   31684 bash
    52630   52630   31684 ./mample
    52632   52632   31684 ./sample

    Burada görülen şudur: Kabuğun kendisi, mample ve sample prosesleri için ayrı birer proses grubu yaratmıştır. Ancak bu proses grupları 
    aynı oturum içerisindedir. Oturumun lideri ise kabuktur. Komut çıktısından göremesek de kabuk ve mample oturumun arka plan proses gruplarını, 
    sample ise ön plan proses grubunu oluşturmaktadır. mample ve sample proseslerinin grup id'lerinin farklı olduğuna dikkat ediniz.

    Yukarıda da belirttiğimiz gibi oturumların da proses gruplarında olduğu gibi id'leri vardır. Oturumların id'leri (session id) oturum 
    içerisindeki bir proses grubunun liderinin id'si ile aynıdır. Bu prosese aynı zamanda "oturum lideri (session leader)" denilmektedir.

    Kabuktaki bütün arka plan proses komutları "jobs" komutu ile görülebilmektedir. Örneğin:

    $ cat > x &
    [1] 14797
    $ cat > y &
    [2] 14798
    $ cat > z &
    [3] 14799
    $ cat > z | grep "test" &
    [4] 14827
    $ jobs
    [1]   Running                 cat > x &
    [2]   Running                 cat > y &
    [3]-  Running                 cat > z &
    [4]+  Running                 cat > z | grep --color=auto "test" &

    Belli bir arka plan proses grubunu ön plana çekmek için "fg %n (n burada arka plandaki işin numarasını belirtmektedir) 
    komutu uygulanır. % karakteri hiç kullanılmayabilir. Örneğin:

    $ fg %3
    cat > z

    Belli bir arka plan işe (job) yani proses grubuna "kill %n" komutuyla sinyal de gönderebiliriz. Örneğin:

    $ kill %2

    Oturum terminal sürücüsüyle ilişkili bir kavram olarak sisteme sokulmuştur. Oturumların bir "ilişkin olduğu terminal ya da 
    terminal sürücüsü (controlling terminal)" vardır. Bu terminal gerçek terminal ise "/dev/ttynnn" (buradaki nnn bir sayıyı temsil 
    ediyor) terminallerinden biridir. Sahte (pseudo) bir terminal ise "dev/pts/nnn" terminallerinden biridir. Pencere yöneticilerinin
     içerisinde açılan terminaller sahte (pseudo) terminallerdir. Ancak işlev olarak sahte terminallerin gerçek terminallerden bir 
     farkları yoktur. Klavyeden Ctrl+C ve Ctrl+\ (ya da Ctrl + Backspace) tuşlarına basıldığında SIGINT ve SIGQUIT sinyalleri bu 
     terminal sürücüsü tarafından oturumun ön plan proses grubuna gönderilmektedir. Örneğin:

    $ cat | grep "test"

    Bu komut terminalden uygulandıktan sonra biz Ctrl+c tuşlarına bastığımızda SIGINT sinyali ön plan proses grubuna gönderileceğinden 
    dolayı burada hem cat prosesi hem de grep prosesi sonlandırılacaktır.

    Burada aktardığımız bilgiler üzerinde şu anahtar noktalara yeniden dikkatinizi çekmek istiyoruz:

    1) Kabuk programları bir proses grubu ve oturum yaratmakta ve kendilerini proses grubunun ve oturumun oturum lideri yapmaktadır.
    Kabuğun çalıştığı terminal de oturumun "ilişkin olduğu terminal (controlling terminal)" durumundadır.

    2) Kabuk "sonu & ile bitmeyen" her komut için bir proses grubu oluşturur ve o proses grubunu oturumun ön plan proses grubu yapar. 
    Terminal sinyalleri bu proses grubuna gönderilmektedir.

    3) Kabuk "sonu & ile biten" her komut için ayrı bir proses grubu oluşturur ve o proses grubunu oturumun arka plan proses grubu 
    haline getirir.

    4) Terminal tuşlarıyla oluşturulan SIGINT ve SIGQUIT gibi sinyaller oturumun ön plan proses grubuna gönderilmektedir.

    Yukarıda açıklandığı gibi çalışan kabuk programlarına "görev kontrol kabukları (job control shells)" denilmektedir.
    Eski "Bourne Shell" kabuklarında görev kontrol özelliği yoktu. Bugün kullanılan kabuk programlarında genel olarak görev 
    kontrol özelliği bulunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosesin ilişkin olduğu oturum id'si (session id) getsid POSIX fonksiyonuyla alınmaktadır:

    #include <unistd.h>

    pid_t getsid(pid_t pid);

    Fonksiyon parametre olarak prosesin id'sini almaktadır. Eğer bu id değeri 0 olarak girilirse fonksiyonu çağıran prosesin oturum 
    id'si elde edilir.

    Aşağıdaki programda bir prosesin ve onun alt prosesinin id bilgileri stdout dosyasına yazdırılmıştır. Üst ve alt proseslerin 
    aynı session id'ye sahip olduğuna onun da bash'in session id'si (dolayısıyla proses id'si) olduğuna dikkat ediniz. Programın
    çalıştırılması ile elde edilen bir çıktı şöyledir:

    Parent process id: 52812
    Parent process id of the parent: 31684
    Parent process group id: 52812
    Parent process session id: 31684
    Child process id: 52813
    Parent process id of the child: 52812
    Child process group id: 52812
    Child process session id: 31684
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pgid, sid;
    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {        /* parent process */

        pgid = getpgrp();
        sid = getsid(0);

        printf("Parent process id: %jd\n", (intmax_t)getpid());
        printf("Parent process id of the parent: %jd\n", (intmax_t)getppid());
        printf("Parent process group id: %jd\n", (intmax_t)pgid);
        printf("Parent process session id: %jd\n", (intmax_t)sid);

        if (waitpid(pid, NULL, 0) == -1)
            exit_sys("waitpid");
    }
    else {        /* child process */

        sleep(1);

        pgid = getpgrp();
        sid = getsid(0);

        printf("Child process id: %jd\n", (intmax_t)getpid());
        printf("Parent process id of the child: %jd\n", (intmax_t)getppid());
        printf("Child process group id: %jd\n", (intmax_t)pgid);
        printf("Child process session id: %jd\n", (intmax_t)sid);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz sıfırdan bir "job control shell" yazmak istersek bu oturum işlemlerini nasıl yaparız? Öncelikle bizim bir oturum 
    yaratıp oturumumuzu bir terminal aygıt sürücü ile ilişkilendirmemiz gerekir. Yani oturumumuzun bir terminale ("controlling 
    terminal) sahip olması gerekir.

    Yeni bir oturum (session) yaratmak için setsid fonksiyonu kullanılmaktadır:

    #include <unistd.h>

    pid_t setsid(void);

    Fonksiyon şunları yapar:

    - Yeni bir oturum (session) oluşturur.
    - Bu oturum içerisinde yeni bir proses grubu oluşturur.
    - Oluşturulan oturumun ve proses grubunun lideri fonksiyonu çağıran prosestir.

    Görüldüğü gibi bir proses setsid fonksiyonunu çağırdığında bir oturumla birlikte yeni bir proses grubu da oluşturulmaktadır. 
    Bu proses grubu oturumun lideri olmaktadır. setsid fonksiyonu tipik olarak kabuk programları tarafından işin başında 
    çağrılmaktadır. Böylece kabuk yeni bir oturumun hem lideri olur hem de o oturum içerisinde yaratılmış olan bir proses 
    grubunun lideri olur. O halde bir komut uygulanmamış durumdaki kabuk ortamında bir oturum ve bir de proses grubu vardır. 
    Kabuk bu ikisinin de lideri durumundadır. Sonra kabukta sonu & ile bitmeyen bir komut çalıştırıldığında kabuk bu 
    komuta ilişkin proses için yeni proses grubu yaratacak ve bu grubu oturumun ön plan proses grubu yapacaktır.

    setsid fonksiyonunu çağıran proses eğer zaten bir proses grubunun grup lideri ise fonksiyon başarısız olmaktadır. Örneğin 
    biz kabuktan çalıştırdığımız bir programda setsid çağrısı yaparsak başarısız oluruz. O halde bir oturum yaratabilmemiz için
    bizim zaten bir proses grubunun proses grup lideri olmamamız gerekir. Bunu sağlayabilmek için tipik olarak proses önce fork 
    yapar sonra alt proseste setsid fonksiyonunu çağırır. Böylece üst proses proses grup lideri olsa bile alt proses hiçbir 
    zaman proses grup lideri olamayacaktır.

    Örneğin biz kabuktan çalıştırdığımız programda setsid fonksiyonunu çağırırsak fonksiyon başarısız olacaktır. Çünkü 
    kabuk bizim programımız için bir proses grubu yaratıp bizi o proses grubunun grup lideri yapmaktadır. Aşağıdaki 
    programı çalıştırarak hatayı inceleyiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    if (setsid() == -1)        /* function possibly will fail! */
        exit_sys("setsid");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi eğer yeni bir oturum yaratılmak isteniyorsa programın nasıl çalıştırılacağı bilinmediğine 
    göre önce fork uygulayıp alt proseste setsid uygulamak gerekir. Çünkü alt proses hiçbir zaman zaten proses grup lideri 
    olamayacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0)
        _exit(EXIT_SUCCESS);

    if (setsid() == -1)
        exit_sys("setsid");

    printf("Ok, i am session leader of the new session!\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz sıfırdan bir kabuk programı oluşturmak istediğimizde fork yapıp alt proseste setsid fonksiyonunu çağırıp oturum
    yaratabildik. Pekiyi oturumumuzu nasıl bir terminal aygıt sürücüsü ile ilişkilendireceğiz? İşte oturum lideri open 
    fonksiyonuyla O_NOCTTY bayrağı kullanılmadan bir terminal aygıt sürücüsünü açtığında ve elde ettiği dosya betimleyicisi
    ile ioctl(fd, TIOCSCTTY) çağrısı yaptığında artık o terminal oturumun ilişkin olduğu terminal (controlling terminal) 
    durumuna gelir. Örneğin:

    if ((fd = open("/dev/tty1", O_RDWR)) == -1)
        _exit(EXIT_FAILURE);

    if (ioctl(fd, TIOCSCTTY) == -1)
        _exit(EXIT_FAILURE)

    ioctl fonksiyonu aygıt sürücülerdeki fonksiyonların çağrılması için kullanılan genel amaçlı bir fonksiyondur. Bu fonksiyonun 
    kullanımını "aygıt sürücüler" konusunda göreceğiz. (Bazı sistemlerde bu ioctl işlemini yapmaya gerek kalmamaktadır. Ancak Linux 
    sistemlerinde bu işlemin yapılması gerekmektedir.)

    Eğer ioctl işlemi yapılırken terminal o anda başka bir oturumun terminaliyse (controlling terminal) ve çağrıyı yapan proses 
    uygun önceliğe de sahip değilse, çağrı EPERM errno değeri ile başarısız olmaktadır. Ancak ioctl çağrısı yapılırken eğer terminal 
    başka bir oturumun terminaliyse ancak çağrıyı yapan proses uygun önceliğe sahipse bu durumda terminal o oturumdan koparılıp 
    çağrının yapıldığı oturumun terminali (controlling terminal) haline getirilmektedir. Bu durumda ioctl işlemini yapan prosese 
    de "terminali kontrol eden proses (controlling process)" biçiminde isimlendirilmektedir. Normal olarak kabuk programı (bash) 
    terminali kontrol eden proses (controlling process) durumundadır. Dosyaların betimleyicileri üst prosesten alt prosese aktarıldığına 
    göre bu terminal betimleyicisi her proseste gözükecektir. Yukarıda belirttiğimiz gibi buna "ilgili prosesin ilişkin terminal 
    (process controlling terminal)" denilmektedir. Anımsanacağı gibi aslında 0 numaralı betimleyici terminal aygıt sürücüsünün 
    O_RDONLY modunda açılmasıyla, 1 numaralı betimleyici aynı aygıt sürücünün O_WRONLY moduyla açılmasıyla ve stderr dosyası da 
    1 numaralı betimleyicinin dup yapılmasıyla oluşturulmaktadır. Yani aslında 0, 1 ve 2 betimleyiciler aynı terminale ilişkindir.

    Bir oturumun ilişkin olduğu terminalin oturumdan kopartılması işlemi de ioctl(fd, TIOCNOTTY) çağrısıyla yapılabilmektedir.

    Şimdiye kadar oturum ve terminale ilişkin pek çok terim gördük. Bu terimlerin neler olduğunu ve ne anlamlara geldiğini aşağıda
    topluca listelemek istiyoruz:

    - Oturum (Session): Proses gruplarından oluşan görev kontrol kabuklarının faydalandığı bir kavramdır. Yeni bir oturum oluşturmak 
    için setsid fonksiyonu kullanılmaktadır.

    - Oturumun İlişkin Olduğu Terminal (Controlling Terminal): Oturumdaki proseslerin kullandığı terminali (terminal aygıt
     sürücüsünü) belirtmektedir.

    - Prosesin İlişkin Olduğu Terminal (Process Controlling Terminal): Belli bir prosesin kullandığı terminali (terminal aygıt 
    sürücüsünü) belirtmektedir.

    - Oturum Lideri (Session Leader): Oturumu yaratan prosesi belirtir. Bu prosesin proses id'si, proses grup id'si ve oturum id'si
    aynıdır.

    - Oturum Id'si (Session Id): Oturumu temsil eden proses id değeridir. Oturum id'si normal olarak oturum içerisindeki bir 
    proses grubunun, dolayısıyla da prosesin id'si ile aynıdır.

    - Ön Plan Proses Grubu (Foreground Process Group): Oturum içerisindeki özel klavye tuşları için sinyallerin gönderildiği proses 
    grubu. Bu proses grubu doğrudan terminalle etkileşebilmektedir. Sonuna & getirilmeden uygulanan komutlardaki prosesleri kabuk 
    aynı proses grubuna yerleştirmekte ve o proses grubunu da kabuğun ön plan proses grubu yapmaktadır. Belli bir anda oturumda 
    yalnızca bir tane ön plan proses grubu bulunmaktadır.

    - Arka Plan Proses Grubu (Background Process Group): Sonuna & getirilerek uygulanan komutlardaki prosesleri kabuk aynı proses 
    grubuna yerleştirmekte ve o proses grubunu da kabuğun arka plan proses grubu haline getirmektedir. Belli bir anda oturumda 
    birden fazla arka plan proses grubu bulunabilmektedir.

    Aşağıdaki örnekte bir oturum yaratılmış ve "/dev/tty1" terminali oturumun ilişkin olduğu terminal (controlling terminal) 
    yapılmıştır. Sonra prosesin açmış olduğu bütün dosyalar kapatılmış ve ilk üç betimleyicinin söz konusu terminale ilişkin 
    stdini, stdout ve stderr betimleyicisi olması sağlanmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;
    int fd;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0)
        _exit(EXIT_SUCCESS);

    if (setsid() == -1)
        exit_sys("setsid");

    for (int i = 0; i < 1024; ++i)
        close(i);

    if ((fd = open("/dev/tty1", O_RDONLY)) == -1)
        _exit(EXIT_FAILURE);

    if (open("/dev/tty1", O_WRONLY) == -1)
        _exit(EXIT_FAILURE);

    if (dup(1) == -1)
        _exit(EXIT_FAILURE);

    if (ioctl(fd, TIOCSCTTY) == -1)
        _exit(EXIT_FAILURE);

    for (int i = 0; i < 30; ++i) {
    printf("%d\n", i);
    sleep(1);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Oturumdaki ön plan proses grubunun hangisi olduğu tcgetpgrp POSIX fonksiyonuyla elde edilebilir. Oturumun ön plan proses
    grubu da tcsetpgrp POSIX fonksiyonuyla değiştirilebilir.

    #include <unistd.h>

    pid_t tcgetpgrp(int fd);
    int tcsetpgrp(int fd, pid_t pgid_id);

    Fonksiyonlar terminal aygıt sürücüsüne ilişkin dosya betimleyicileri ile çalışmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Oturumun arka plan bir prosesi, prosesin ilişkin olduğu terminalden (controlling terminal) okuma yapmak isterse terminal 
    sürücüsü o arka plan prosesin içinde bulunduğu proses grubuna SIGTTIN sinyalini göndermektedir. Bu sinyalin default eylemi 
    (default action) prosesin durdurulmasıdır. Bu biçimde durdurulmuş olan prosesler SIGCONT sinyali ile yeniden çalıştırılmak 
    istenebilir. Ancak yeniden okuma yapılırsa yine proses durdurulacaktır. Bu tür prosesler kabuk üzerinden fg %n komutuyla ön 
    plana çekilebilir. Bu durumda kabuk önce prosesin proses grubunu ön plan proses grubu yapar sonra da onu SIGCONT sinyali 
    ile yeniden proses grubunu çalışır duruma getirir.

    Aşağıdaki programı komut satırında sonuna & getirerek çalıştırınız. Program 10 saniye sonra stdin dosyasından okuma yapmaya
    çalışacak ve bu nedenden dolayı SIGTTIN sinyali gönderilerek durdurulacaktır. Prosesin durdurulmuş olduğunu "ps -l" komutu 
    ile ya da "ps -o stat,cmd" komutuyla gözlemleyiniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <unistd.h>

int main(void)
{
    int ch;

    sleep(10);
    ch = getchar();
    putchar(ch);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Arka plan proses grubundaki bir proses SIGTTIN sinyalini işleyebilir. Bu durumda proses durdurulmaz. Ancak tabii eğer 
    bu sırada sinyal yeniden başlatılabilir (SA_RESTART) biçimde set edilmemişse read fonksiyonu EINTR errno değeriyle 
    başarısız olacaktır. Eğer SIGTTIN sinyali yeniden başlatılabilir biçimde (yani SA_RESTART bayrağı kullanılarak) set edilmişse 
    bu durumda read fonksiyonu çekirdek tarafından yeniden başlatılacak ve yeniden aynı sinyal oluşacaktır. Dolayısıyla program 
    sonsuz döngüye girecektir.

    Aşağıda programın sonuna & getirerek çalıştırıp log dosyasını inceleyiniz. Programda stdin dosyasından okuma yapılmak 
    istendiğinde SIGTTIN sinyali oluşacak ve read fonksiyonu EINTR errno değeri ile başarısız olacaktır. Bu örnekte sigaction 
    fonksiyonunda sinyalin SA_RESTART özelliği kullanılmadan set edildiğine dikkat ediniz. Eğer biz sinyal fonksiyonunu 
    "otomatik olarak yeniden başlatılabilir biçimde" set etmiş olsaydık read fonksiyonu tekrar tekrar başarısız olacak ve 
    sürekli bir biçimde sinyal fonksiyonu çağrılacaktı. Arka plan proseslerin stdout dosyasına yazmaya çalıştığındaki özel 
    durum izleyen paragrafta ele alınmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <signal.h>

void sigttin_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;
    char ch;

    sa.sa_handler = sigttin_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    if (sigaction(SIGTTIN, &sa, NULL) == -1)
        exit_sys("sigaction");

    if (read(STDIN_FILENO, &ch, 1) && errno == EINTR)
        printf("read terminated by signal!...\n");

    return 0;
}

void sigttin_handler(int sno)
{
    printf("SIGTTIN occurred!...\n");        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Arka plan proses grubundaki bir prosesin ilişkin olduğu terminale (process controlling terminal) bir şeyler yazmaya çalışması 
    da uygun değildir. Bu durumda da terminal sürücüsü prosesin ilişkin olduğu arka plan proses grubuna SIGTTOU sinyalini 
    göndermektedir. Bu sinyalin default eylemi yine prosesin durdurulmasıdır. Ancak bu sinyalin aygıt sürücüsü tarafından arka 
    plan proses grubuna gönderilmesi için Linux'ta terminalin TOSTOP modunda olması gerekir. Eğer terminal bu modda değilse 
    SIGTTOU sinyali gönderilmemektedir. Bu durumda write fonksiyonu işlemini başarıyla sonlandırabilecektir. Terminal sürücüsünün 
    default davranışını şöyle öğrenebilirsiniz:

    $ stty -a
    speed 38400 baud; rows 27; columns 90; line = 0;
    intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>;
    swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V;
    discard = ^O; min = 1; time = 0;
    -parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
    -ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc
    -ixany -imaxbel iutf8
    opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
    isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke
    -flusho -extproc

    Burada -tostop SIGTTOU sinyalinin gönderilmeyeceğini belirtmektedir. Arka plan proseslerin terminal sürücüsüne bir şeyler 
    yazdığında SIGTTOU sinyalini göndermesini istiyorsanız şu komutu uygulamalısınız:

    $ stty tostop

    Artık aynı komutu uyguladığımızda ilgili seçenek "-tostop" yerine "tostop" biçiminde görüntülenecektir.

    Terminal aygıt sürücüsünün sinyal göndermemesini sağlamak için ise aşağıdaki komutu uygulayabilirsiniz:

    $ stty -tostop

    Yukarıdaki komutları da kullanarak aşağıdaki programı sonuna & getirerek arka plan proses grubu olarak çalıştırmayı 
    deneyiniz ve durumu gözlemleyiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    if (write(STDOUT_FILENO, "test\n", 5) == -1)
        exit_sys("write");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Eskiden UNIX/Linux sistemlerine RS232 gibi seri haberleşme arayüzleriyle terminaller bağlanırdı. Programcılar ve kullanıcılar 
    da bu terminalleri kullanarak başka bir odadan ya da uzaktan modem ile bağlanarak işlemlerini yapardı. Bu eski terminaller 
    bilgisayar gibi değildi. Yalnızca ekran ve klavyeden oluşuyordu. Bunlara o zamanlar "aptal terminaller (dummy terminals)"
    deniliyordu. Teknoloji gelişince bu aptal terminaller ortadan kalktı. Artık uzaktan bağlanma için aptal terminaller yerine
    aynı zamanda kendisi bilgisayar olan akıllı terminaller kullanılmaya başlandı. Sonra uzaktan kablolu bağlantı büyük ölçüde
    teknoloji dışı kaldı. Bağlantılar genellikle (ssh gibi protokollerle) uzaktan yapılır hale geldi.

    Bugün kullandığımız bilgisayarlarda eski terminallerin simüle edilmesini sağlayan iki temel mekanizma bulunmaktadır. 
    Bunlardan birisi "Ctrl+F+N" tuşlarına basılarak açılan terminallerdir. Bu terminallere genellikle "sanal terminaller 
    (virtual terminals)" denilmektedir. Diğeri ise GUI ortamında pencere yöneticilerinden açılan terminal pencereleridir. 
    Bunlara ise "sahte terminaller (pseudo terminals)" denilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Terminal bağlantısı koptuğunda ya da sahte terminal penceresi kapatıldığında terminal aygıt sürücüsü o terminalin ilişkin 
    olduğu oturumun liderine (aslında oturum liderinin proses grubuna) SIGHUP sinyali göndermektedir. Tipik komut satırlı 
    çalışmada oturum lideri kabuk programıdır. Dolayısıyla terminal penceresi kapatıldığında SIGHUP sinyali kabuk programına 
    (örneğin bash programına) gönderilmektedir. SIGHUP sinyalinin default eylemi prosesin sonlandırılmasıdır. Eğer terminalin 
    ilişkin olduğu (controlling terminal) oturumun lideri bu sinyali "ignore" ederse bu durumda terminalden yapılacak okumalarda 
    read fonksiyonu 0 ile (yani sanki EOF durumu oluşmuş gibi) geri dönmekte write fonksiyonu da EIO errno değeri ile başarısız 
    olmaktadır.

    Terminal bağlantısı koptuğunda ya da sahte terminal penceresi kapatıldığında terminal aygıt sürücüsünün kabuk 
    programına SIGHUP sinyali gönderdiğini belirtmiştik. İşte kabuk programları da bu SIGHUP sinyalini işleyerek oturumdaki 
    tüm proses gruplarına SIGHUP sinyali göndermektedir. Sonuç olarak terminal bağlantısı koptuğunda ya da terminal penceresi 
    kapatıldığında oturumdaki tüm proseslere SIGHUP sinyali gönderilmiş olur ve default durumda oturumun tüm prosesleri bu 
    biçimde sonlandırılır.

    Ancak burada ince bir nokta da vardır. Oturumun arka plan bir proses grubundaki proses terminalden okuma yapmak istediğinde 
    ona SIGTTIN sinyalinin gönderildiğini bu sinyalin de default durumda prosesi durdurduğunu (stop ettirdiğini) belirtmiştik. 
    İşte terminal bağlantısı koptuğunda ya da terminal penceresi kapatıldığında kabuk programı tüm proses gruplarına SIGHUP sinyalini
    gönderdiğinde arka plandaki durdurulmuş olan prosesler bu durumda sonlanmayacaktır. (Durdurulmuş bir prosesin SIGKILL dışında 
    bir sinyali işlemediğini, o sinyal gönderilse bile "pending" durumda kaldığını anımsayınız.) İşte bunun için kabuk programları 
    (ancak tüm kabuk programları değil) durdurulmuş proseslerin bulunduğu proses gruplarına yalnızca SIGHUP sinyalini değil, aynı 
    zamanda SIGCONT sinyalini de göndermektedir. Böylece bu durdurulmuş prosesler çalışmaya başlar başlamaz sonlandırılmaktadır.

    Pekiyi terminale ilişkin proses (controlling process) sonlanırsa ne olacaktır? İşte bu durumda çekirdek oturuma ilişkin tüm 
    prosesleri terminalden koparmaktadır ve oturumun ön plan proses grubuna SIGHUP sinyali göndermektedir. Tabii tipik olarak 
    terminali kontrol eden proses kabuk programı olduğu için kabuk programları bu tür durumlarda özel işlemler uygulamaktadır. 
    Örneğin bash programından "exit" komutu ile çıkmak isterseniz "bash" programı eğer arka planda durdurulmuş prosesler varsa 
    bir uyarı mesajı çıkartmaktadır. Örneğin:

    $ cat &
    [1] 26338
    $ exit
    exit
    Durmuş işler var.

    [1]+  Durdu                   cat
    $

    Ancak bu tür durumlarda üst üste iki kez exit yapıldığında artık "bash" oturumun tüm ön plan ve arka plan proses gruplarına 
    SIGHUP sinyali göndererek onları sonlandırmaktadır. Tabii durdurulmuş proseslere ilişkin proses grupları için aynı zamanda
    SIGCONT sinyalini de göndermektedir.

    Terminal kapatıldığında ya da kabuk programından çıkıldığında o terminalde çalışan programların çalışmasına devam etmesi 
    isteniyorsa bunun için "nohup" ve "disown" isimli programlardan faydalanılmaktadır. nohup programı çalıştırdığı programın
    SIGHUP sinyalini "ignore" eder, disown ise prosesi oturumdan koparır. Örneğin:

    $ nohup ./sample &

    Burada terminal kapatılsa bile bu prosesler çalışmaya devam edecektir. nohup programı stdout dosyasını "nohup.out" isimli
    bir dosyaya yönlendirmektedir. Bu iki komut hakkında ayrıntılı açıklamalar için dokümanlara başvurabilirsiniz.

    Pekiyi terminal bağlantısı koptuğunda ya da terminal penceresi kapatıldığında oluşan SIGHUP sinyali "ignore" edilirse ne olur?
    İşte bir proses ister ön planda isterse arka planda çalışıyor olsun eğer SIGHUP sinyalini "ignore" ederse terminal okumasında
    read fonksiyonu sanki EOF durumu oluşmuş gibi 0 değeri ile geri dönmektedir. Yine ister ön planda isterse arka planda 
    çalışıyor olursa olsun SIGHUP sinyali "ignore" edildiğinde terminale yazma yapılırsa write fonksiyonu EIO errno değeri ile
    başarısız olmaktadır. Bu durum terminalin ilişkin olduğu proses için de (yani kabul prosesi için de) böyledir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Terminal ve oturum konusu ile ilgili diğer bir konu da "öksüz proses grupları (orphan process groups)" konusudur. Anımsanacağı 
    gibi öksüz proses "kendisi devam ettiği halde üst prosesi sonlanmış olan proseslere" deniyordu.

    "Bir proses grubundaki her prosesin üst prosesi o proses grubundaysa ya da aynı oturumda değilse" böyle proses gruplarına
    öksüz proses grupları denilmektedir. Bu tanım kişilere biraz karışık gibi gelmektedir. De Morgan kuralına göre bunun değili 
    alınırsa belki daha sade bir tanım elde edilecektir: "Eğer bir proses grubundaki en az bir prosesin üst prosesi aynı 
    oturumda ancak farklı bir proses grubunda bulunuyorsa" o proses grubu öksüz değildir. Örneğin kabuktan bir program çalıştırmış 
    olalım. Program da birkaç kez fork yapıp alt proses oluşturmuş olsun. Şimdi bu proses grubu öksüz değildir. Çünkü bu gruptaki 
    tüm proseslerin üst prosesleri aynı gruptadır ya da aynı oturumdadır. Kabuktan çalıştırılan prosesin üst prosesinin kabuk 
    olduğuna ve onun da aynı oturumda olduğuna dikkat ediniz. Şimdi kabuktan bir program çalıştıralım. Bu program fork işlemi yapıp 
    kendisini sonlandırsın. Bu durumda alt prosesin üst prosesi "init" prosesi olacaktır. Böylece proses grubundaki söz konusu 
    alt prosesin üst prosesi aynı grupta değildir.

    Yukarıdaki örneği yinelemek istiyoruz. Biz kabuktan "./sample" programını çalıştıralım. Kabuk bu komut için bir ön plan proses 
    grubu oluşturacaktır. sample prosesi de bu ön plan proses grubunun lideri olacaktır. Şimdi biz bu sample prosesi içerisinde 
    fork yapıp üst prosesi sonlandırırsak proses grubu yaşamaya devam eder ancak öksüz durumda olur. Çünkü alt prosesin artık 
    üst prosesi init olacağı için init prosesi de aynı oturumda olmadığından yukarıdaki tanım sağlanmış olacaktır.

    Aşağıdaki örnekte "sample" programında bir kez fork yapılıp üst proses sonlandırılmıştır. ps komutuyla oluşan duruma dikkat 
    ediniz:

    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>

    void exit_sys(const char *msg);

    int main(void)
    {
        pid_t pid;

        if ((pid = fork()) == -1)
            exit_sys("fork");

        if (pid != 0)
            _exit(EXIT_SUCCESS);

        alarm(30);        // 30 saniye sonra proses sonlanacak
        pause();

        return 0;
    }

    void exit_sys(const char *msg)
    {
        perror(msg);

        exit(EXIT_FAILURE);
    }

    Burada ps komutuyla elde edilen çıktılara bakınız:

    $ ps -o pid,ppid,pgid,sid,cmd
      PID    PPID    PGID     SID CMD
    26667   26642   26667   26667 bash
    27410    1136   27409   26667 ./sample
    27411   26667   27411   26667 ps -o pid,ppid,pgid,sid,cmd

    $ ps -p 1136,1 -o pid,ppid,pgid,sid,cmd
     PID    PPID    PGID     SID CMD
       1       0       1       1 /sbin/init splash
    1136       1    1136    1136 /lib/systemd/systemd --user

    Buradan elde edilen değerlere bakıldığında üst prosesi sonlanmış prosesin üst prosesinin 1136 pid değerine sahip olan 
    systemd isimli proses olduğu, systemd prosesinin de üst prosesinin init olduğu anlaşılmaktadır. Biz bir prosesin üst prosesi
    sonlandığında onun üst prosesinin init olacağını söylemiştik. Ancak günümüzdeki systemd init paketlerinde bu durum yukarıdaki 
    gibi biraz farklıdır. Bu konu "servislerin (daemons) anlatıldığı" bölümde ele alınacaktır. Öksüz proses grubu tanımına dikkat 
    edilirse aslında kabuk programının içinde bulunduğu proses grubunun da öksüz olduğu görülmektedir:

    $ ps -o pid,ppid,pgid,sid,cmd
      PID    PPID    PGID     SID CMD
    26667   26642   26667   26667 bash
    27434   26667   27434   26667 ps -o pid,ppid,pgid,sid,cmd

    $ ps -p 26642 -o pid,ppid,pgid,sid,cmd
      PID    PPID    PGID     SID CMD
    26642    1136   26642   26642 /usr/libexec/gnome-terminal-server

    Burada bash kabuk programının üst prosesinin aynı oturuma dahil olmadığını görüyorsunuz. O halde bash prosesi de aslında 
    oturumdaki öksüz bir proses grubundadır.

    Öksüz proses gruplarında şöyle bir ayrıntı da vardır: Kabuk programları terminal bağlantısı koptuğunda ya da sahte terminal 
    penceresi kapatıldığında oturumun öksüz proses gruplarına SIGHUP sinyali göndermemektedir. Ancak bir proses grubu öksüz 
    hale geldiğinde eğer o proses grubu içerisinde durdurulmuş olan (stop edilmiş olan) bir proses varsa terminal aygıt 
    sürücüsü öksüz hale gelmiş olan bu proses grubuna SIGHUP ve SIGCONT sinyalleri göndermektedir. Öksüz proses gruplarındaki 
    proseslerin kabuk programı sonlansa bile yaşamaya devam edeceğine dikkat ediniz.

    Pekiyi öksüz proses grubundaki bir proses terminalden okuma yapmaya çalışırsa ya da terminale yazma yapmaya çalışırsa 
    ne olur? İşte bu durumda read fonksiyonu EIO errno değeri ile başarısız olmaktadır. write fonksiyonu ise terminal aygıt
    sürücünün TOSTOP ayarı aktif değilse normal olarak terminale yazmakta eğer aktif ise o da EIO errno değeri ile başarısız 
    olmaktadır. Örneğin biz üst prosesi sonlanmış bir alt proseste terminalden okuma yapmaya çalışırsak read fonksiyonu başarısız
    olacaktır. Ancak terminale yazma yapmaya çalışırsak terminalin TOSTOP ayarında göre ya yazdıklarımız ekrana çıkacak ya da 
    write fonksiyonu EIO errno değeri ile başarısız olacaktır. (Michael Kerrisk'in "The Linux Programming Environment" kitabının 
    730'uncu sayfasında sanki öksüz proses grubundaki proseslerin terminale yazma yapması durumunda write fonksiyonunun EIO errno 
    değeriyle başarısız olacağı gibi bir cümle edilmiştir. Halbuki bu durum terminalin TOSTOP ayarı ile ilgilidir.)

    Öksüz proses grubundaki proseslere (arka planda çalıştırılsın ya da çalıştırılmasın) terminalden okuma yaptığında 
    SIGTTIN sinyalinin gönderilmediğine, terminalin TOSTOP ayarı ne olursa olsun terminale yazma yapıldığında da SIGTTOU 
    sinyalinin gönderilmediğine dikkat ediniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                82. Ders 17/09/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir thread'in akışını belli bir süre bekletmek için işletim sistemlerinde sleep fonksiyonları bulundurulmaktadır. Bu fonksiyonlar
    thread'i bloke ederek çalışma kuyruğundan çıkartır ve özel sleep kuyruklarına yerleştirir. İstenen zaman dolduğunda yeniden 
    thread çalışma kuyruğuna yerleştirilir. Böylece istenilen miktarda bekleme CPU zamanı harcanmadan sağlanmış olur.

    UNIX türevi sistemlerde ilk zamanlardan beri sleep isimli bir bekleme fonksiyonu bulunmaktadır. Bu fonksiyon saniye 
    cinsinden bir duyarlılığa sahiptir. Günümüzde saniye düşük bir çözünürlük durumuna gelmiştir. sleep fonksiyonunun prototipi 
    şöyledir:

    #include <unistd.h>

    unsigned sleep(unsigned seconds);

    Fonksiyon parametre olarak beklenecek saniye sayısını almaktadır. Fonksiyonun geri dönüş değeri sinyal dolayısıyla erken 
    sonlanmada kalan saniye değerini belirtmektedir. Fonksiyonun 0 ile geri dönmesi normal bir sonlanma anlamına gelmektedir. 
    Ancak fonksiyonun geri döndürdüğü değerin de saniye duyarlılığında olması kalan zaman hakkında detaylı bilgi verememektedir. 
    sleep fonksiyonu sinyal geldiğinde hiçbir zaman otomatik yeniden çalıştırılmaz. Yani örneğin biz bir sinyali SA_RESTART
    bayrağı ile set etmiş olalım ve o anda sleep fonksiyonunda bekliyor olalım. İlgili sinyal geldiğinde sleep yeniden başlatılmaz. 
    Programcılar genel olarak sleep fonksiyonunun geri dönüş değeri ile ilgilenmezler. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz daha önceki kodlarımızda kullanım kolaylığından dolayı kullanmış olsak da aslında usleep fonksiyonu bir POSIX fonksiyonu
    değildir. Ancak Linux ve bazı UNIX türevi sistemlerde glibc kütüphanesinin içerisinde bulunmaktadır. usleep fonksiyonu 
    mikrosaniye çözünürlüğüne sahiptir. Prototipi şöyledir:

    #include <unistd.h>

    int usleep(useconds_t usec);

    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Fonksiyon sinyalden dolayı 
    başarısız olursa yeniden başlatılmaz ve errno değişkeni EINTR değeriyle set edilir. Fonksiyona uygunsuz argüman girildiğinde
    errno değişkeni EINVAL değeriyle set edilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Nanosaniye çözünürlüğe sahip ismine nanosleep denilen bir POSIX fonksiyonu da bulunmaktadır. Bu fonksiyon sonradan POSIX 
    standartlarına eklenmiştir. Fonksiyonun prototipi şöyledir:

    #include <time.h>

    int nanosleep(const struct timespec *rqtp, struct timespec *rmtp);

    Buradaki timespec yapısını daha önce de kullanmıştık. Bu yapı <time.h> dosyası içerisinde aşağıdaki gibi bildirilmiştir:

    struct timespec {
        time_t tv_sec;
        long tv_nsec;
    };

    nanosleep fonksiyonu da bir sinyal oluştuğunda sinyal fonksiyonu set edilmişse başarısız olur ve errno değeri EINTR ile 
    set edilir. Bu durumda bekleme için kalan süre fonksiyonun ikinci parametresiyle belirtilen timespec yapısının içerisine 
    yerleştirilmektedir. Fonksiyonun ikinci parametresi NULL adres girilebilir. Bu durumda bu yerleştirme yapılmaz. Birinci 
    parametreyle ikinci parametreye aynı nesnenin adreslerinin girilmesinde de bir sakınca yoktur.

    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    Aşağıdaki örnekte 3.5 saniyelik bir sleep uygulanmıştır. 1 saniyenin bir milyar nanosaniyeden oluştuğuna dikkat ediniz.
    Bu durumda yarım saniye 500000000 nanosaniyedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void exit_sys(const char *msg);

int main(void)
{
    struct timespec ts;

    printf("sleeping 3.5 seconds...\n");

    ts.tv_sec = 3;
    ts.tv_nsec = 500000000;

    if (nanosleep(&ts, NULL) == -1)
        exit_sys("nanosleep");

    printf("ok...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte SIGINT sinyali set edilmiş ve nanosleep fonksiyonu ile 10.5 saniye bekleme yapılmıştır. Bu programı
    iki durumda test ediniz. Birincisi klavyeden hiçbir tuşa basmadan zamanın dolmasını bekleyiniz. Bu durumda kalan zaman 0 
    olacaktır. İkinci durumda programı çalıştırdıktan sonra Ctrl+C tuşlarına basarak SIGINT sinyali oluşturunuz. Bu durumda 
    kalan zamanın sıfırdan büyük olduğunu göreceksiniz. Örnek iki denemenin sonuçları şöyledir:

    $ ./mample
    sleeping 10.5 second...
    Left second: 0
    Left nanosecond: 0

    $ ./mample
    sleeping 10.5 second...
    ^Csignt handler...
    Left second: 9
    Left nanosecond: 464386077
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <time.h>
#include <errno.h>
#include <signal.h>

void sigint_handler(int sig);
void exit_sys(const char *msg);

int main(void)
{
    struct timespec ts, tsleft;
    struct sigaction sa;

    sa.sa_handler = sigint_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    if (sigaction(SIGINT, &sa, NULL) == -1)
        exit_sys("sigaction");

    printf("sleeping 10.5 second...\n");

    ts.tv_sec = 10;
    ts.tv_nsec = 500000000;

    if (nanosleep(&ts, &tsleft) == -1 && errno != EINTR)
        exit_sys("nanosleep");

    printf("Left second: %ju\n", (intmax_t)tsleft.tv_sec);
    printf("Left nanosecond: %ld\n", (intmax_t)tsleft.tv_nsec);

    return 0;
}

void sigint_handler(int sig)
{
    printf("sigint handler...\n");        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    nanosleep fonksiyonu gerçek zamana (CLOCK_REALTIME) göre bekleme yapmaktadır. Beklemenin değişik zamanlamalara göre (bunlara 
    saat (clock) da denilmektedir) yapılabilmesi için clock_nanosleep fonksiyonu POSIX standartlarına eklenmiştir. Fonksiyonun
    prototipi şöyledir:

    #include <time.h>

    int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *rqtp, struct timespec *rmtp);

    Fonksiyonun birinci parametresi beklemede kullanılacak saatin cinsini belirtmektedir. POSIX standartlarında şu saat cinsleri 
    bulunmaktadır:

    CLOCK_REALTIME: Bu saat kullanılırsa bekleme sistem zamanının değiştirilmesinden etkilenebilmektedir. Örneğin 30 saniye 
    beklemek isterken sistem zamanı ileri alınırsa daha az bekleme söz konusu olabilmektedir.

    CLOCK_MONOTONIC: Sistem zamanının değiştirilmesinden ve diğer faktörlerden etkilenmeyen göreli bir saattir. Monotonic saat
    kararlı beklemeler için tercih edilmesi gereken saattir.

    CLOCK_PROCESS_CPUTIME_ID: Bu saat proses zamanının ölçülmesinde kullanılan saattir. Genel olarak bu saat timer tick'lerle
    ilerletilmektedir.

    CLOCK_THREAD_CPUTIME_ID: Bu saat de thread zamanının ölçülmesinde kullanılan saattir. Genel olarak bu saat de timer tick'lerle
    ilerletilmektedir.

    Linux sistemlerine özgü CLOCK_TAI ve CLOCK_BOOTTIME gibi başka saatler de bulunmaktadır.

    Fonksiyonun ikinci parametresine (flags) ya 0 ya da TIMER_ABSTIME değeri geçilebilir. Eğer bu parametreye TIMER_ABSTIME 
    değeri geçilirse bu durumda bekleme göreli zaman ile değil, mutlak zaman ile yapılmaktadır. Yani başka bir deyişle bu durumda
    bekleme miktarını belirten timespec yapısında beklemenin sonlandırılacağı mutlak zaman bilgisi bulunmalıdır. (Aslında biz 
    mutlak zamanlı beklemeleri thread konusunda bazı senkronizasyon nesnelerinin zaman aşımlı biçimlerini anlatırken görmüştük.)
    Mutlak zaman beklemesi için önce o andaki zaman bilgisinin clock_gettime fonksiyonuyla alınıp üzerine ekleme yapılması 
    gerekmektedir. Örneğin:

    if (clock_gettime(CLOCK_REALTIME, &ts) == -1)
        exit_sys("clock_gettime");

    ts.tv_sec += 10;

    Fonksiyonun üçüncü parametresi bekleme zamanını, dördüncü parametresi ise işlemin sinyal dolayısıyla sonlanması durumunda kalan
    zamanı belirtmektedir. Bu son parametre yine NULL adres geçilebilir. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda 
    errno değerine geri dönmektedir.

    Aşağıda daha önce nanosleep fonksiyonu için yapılan örneğin clock_nanosleep kullanan biçimi verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <time.h>
#include <errno.h>
#include <signal.h>

void sigint_handler(int sig);
void exit_sys(const char *msg);

int main(void)
{
    struct timespec ts, tsleft;
    struct sigaction sa;

    sa.sa_handler = sigint_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    if (sigaction(SIGINT, &sa, NULL) == -1)
        exit_sys("sigaction");

    printf("sleeping 10.5 second...\n");

    ts.tv_sec = 10;
    ts.tv_nsec = 500000000;

    if (clock_nanosleep(CLOCK_MONOTONIC, 0, &ts, &tsleft) == -1 && errno != EINTR)
        exit_sys("clock_nanosleep");

    printf("Left second: %ju\n", (intmax_t)tsleft.tv_sec);
    printf("Left nanosecond: %ld\n", (intmax_t)tsleft.tv_nsec);

    return 0;
}

void sigint_handler(int sig)
{
    printf("sigint handler...\n");        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Şu andaki almak için ve zaman ölçmek için zaten C'de prototipleri <time.h> içerisinde olan standart C fonksiyonları bulundurulmuştur.
    Ancak bu standart C fonksiyonları genel olarak düşük bir çözünürlüğe sahiptir. Bu fonksiyonlar C Programlama Dili kurslarında 
    ele alındığı için biz yalnızca bir özet yapacağız.

    time isimli standart C fonksiyonu epoch'tan geçen (epoch göreli orijini belirten bir terimdir) zamanı time_t türünden vermektedir. 
    Prototipi şöyledir:

    time_t time(time_t *timer);

    Buradaki time_t türü C standartlarına göre nümerik herhangi bir tür olabilmektedir. (Örneğin double ya da float da olabilmektedir.)
    Ancak POSIX standartlarında bu türün bir tamsayı türü olması gerektiği belirtilmiştir. Ayrıca C standartlarında "epoch" belirtilmemiştir. 
    POSIX standartlarında epoch 01/01/1970 : 00:00:00 olarak belirlenmiştir. (Genel olarak C derleyicilerinin hemen hepsi zaten epoch 
    olarak bu tarihi almaktadır.)

    localtime fonksiyonu time_t değerini alarak bunu bileşenlerine ayrıştırır ve struct tm yapısı biçiminde bize verir. Fonksiyonun 
    prototipi şöyledir:

    struct tm *localtime(const time_t *timer);

    gmtime fonksiyonu localtime fonksiyonunun tarih ve zamanı UTC olarak (eski adıyla GMT) veren biçimidir. Fonksiyonun prototipi
    şöyledir:

    struct tm *gmtime(const time_t *timer);

    Türkiye'nin yerel saati UTC'ye göre "day light saving" durumuna bağlı olarak +2 ya da +3 durumundadır.

    ctime ve asctime fonksiyonları doğrudan tarih ve zamanı bize bir yazı olarak vermektedir. Bu iki fonksiyon arasındaki tek fark ctime 
    fonksiyonu time_t parametresi alırken asctime fonksiyonunun struct tm parametresi almasıdır. Bu fonksiyonların prototipleri şöyledir:

    char *ctime(const time_t *timer);
    char *asctime(const struct tm *timeptr);

    mktime fonksiyonu epoch'tan (POSIX'te 01/01/1970'ten) belli bir tarih zamana kadar geçen zamanın elde edilmesinde kullanılmaktadır:

    time_t mktime(struct tm *timeptr);

    Programcı bir struct tm nesnesi tanımlar. Onun içini doldurur ve fonksiyona verir, fonksiyon da epoch'tan geçen zamanı time_t 
    türünden vermektedir.

    C standartlarında epoch ve time_t türü açıkça belirtilmediği için iki time_t değerinin çıkartılması için difftime fonksiyonu 
    bulundurulmuştur:

    double difftime(time_t time1, time_t time0);

    POSIX sistemlerinde zaten time_t saniye belirttiği için bu fonksiyonun kullanılmasına gerek kalmamaktadır.

    strftime fonksiyonu adeta snprintf fonksiyonunun tarih zaman üzerinde formatlama yapan bir biçimi gibidir. Fonksiyonun 
    prototipi şöyledir:

    size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *timeptr);

    Format karakterlerinin neler olduğu ilgili dokümanlardan görülebilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    C'de programın iki noktası arasındaki zamanı ölçmek için iki yöntem kullanılabilmektedir. Birincisi time fonksiyonu 
    ile zamanı elde edip bunları çıkartmak olabilir. Örneğin:

    time_t start, stop;
    ...

    start = time(NULL);
    ...
    ...
    ...
    stop = time(NULL);

    POSIX standartlarında bu yöntem ancak saniye duyarlılıkta ölçüm yapılmasına izin vermektedir. C standartlarında time 
    fonksiyonunun ne verdiği de belirsizdir. Dolayısıyla C standartlarında taşınabilir bir biçimde bu fonksiyonla zaman ölçmek
    aslında mümkün değildir.

    İkinci yöntem clock fonksiyonunu kullanmaktır. clock fonksiyonunun prototipi şöyledir:

    #include <time.h>

    clock_t clock(void);

    Fonksiyon bize clock_t türünden bir timer tick sayısı verir. Ancak bir saniyenin kaç tick'ten oluştuğu CLOCKS_PER_SEC sembolik 
    sabitiyle define edilmiştir. O halde programcı programın iki noktası arasında clock fonksiyonunu çağırıp bunları çıkartıp
    sonucu CLOCKS_PER_SEC değerine bölerse geçen zamanı elde edebilir. Örneğin:

    clock_t start, stop;
    double result;

    start = clock();
    ...
    ...
    ...
    stop = clock();

    result = (double)(stop - start) / CLOCKS_PER_SEC;

    Güncel Linux sistemlerinde CLOCKS_PER_SEC sembolik sabiti 1000000 olarak define edilmiştir. Dolayısıyla bu yöntemle Linux 
    sistemlerinde mikrosaniye duyarlılıkta zaman ölçülebilir. Windows sistemlerinde ise CLOCKS_PER_SEC sembolik sabiti 1000 
    değerindedir. Yani bu yöntemle milisaniye duyarlılıkta ölçüm yapılabilmektedir.

    clock_t türünün C standartlarında ve POSIX standartlarında nümerik bir tür olarak (yani tamsayı ya da gerçek sayı türü) typedef 
    edilmesi gerektiği belirtilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                83. Ders 23/09/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX standartlarında zaman ölçmek için en uygun fonksiyon clock_gettime fonksiyonudur. Biz zaten bu fonksiyonu daha önce
    senkronizasyon nesnelerinde zaman aşımlı bekleme yapmak için kullanmıştık. Fonksiyonun prototipi şöyledir:

    #include <time.h>

    int clock_gettime(clockid_t clock_id, struct timespec *tp);

    Fonksiyonun birinci parametresi zaman ölçümünde kullanılacak saatin türünü almaktadır. Bu tür şunlardan biri olabilir:

    CLOCK_REALTIME
    CLOCK_MONOTONIC
    CLOCK_PROCESS_CPUTIME_ID
    CLOCK_THREAD_CPUTIME_ID

    Biz daha önce CLOCK_REALTIME ile CLOCK_MONOTONIC arasındaki farkı belirtmiştik. CLOCK_REALTIME sistem zamanının değişmesinden
    etkilenebilecek bir saati belirtirken CLOCK_MONOTONIC sistem zamanının değişmesinden etkilenmeyecek stabil bir saati temsil 
    ediyordu. CLOCK_PROCESS_CPUTIME_ID belli bir prosesin tüm thread'lerinin harcadığı CPU zamanını ölçmek için, CLOCK_THREAD_CPUTIME_ID 
    ise belli bir thread'in harcadığı CPU zamanını ölçmek için kullanılmaktadır. Fonksiyonun ikinci parametresi timespec yapı 
    nesnesinin adresini almaktadır. Zaman bilgisi bu nesnenin içerisine yerleştirilmektedir. Fonksiyon başarı durumunda 0, başarısızlık 
    durumunda -1 değerine geri dönmektedir. timespec yapısını yeniden anımsatmak istiyoruz:

    struct timespec {
        time_t   tv_sec;        /* seconds */
        long     tv_nsec;        /* nanoseconds */
    };

    Aşağıda clock_gettime ile programın iki noktası arasındaki zaman ölçümüne bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void exit_sys(const char *msg);

int main(void)
{
    struct timespec ts1, ts2;
    long long elapsed_time;

    if (clock_gettime(CLOCK_MONOTONIC, &ts1) == -1)
        exit_sys("clock_gettime");

    for (int i = 0; i < 2000000000; ++i)
        ;

    if (clock_gettime(CLOCK_MONOTONIC, &ts2) == -1)
        exit_sys("clock_gettime");

    elapsed_time = (ts2.tv_sec * 1000000000LL + ts2.tv_nsec) - (ts1.tv_sec * 1000000000LL + ts1.tv_nsec);
    /* elsapsed_time = (ts2.tv_sec - ts1.tv_sec) * 1000000000.0 + ts2.tv_nsec - ts1.tv_nsec; */

    printf("Elapsed Nanosecond: %lld\n", elapsed_time);
    printf("Elapsed Second: %f\n", elapsed_time / 1000000000.);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    clock_gettime fonksiyonu ile elde edilen zaman her ne kadar nanosaniye mertebesindeki timespec yapısının içerisine 
    yerleştiriliyorsa da ölçüm duyarlılığı umulan kadar yüksek olmayabilir. Çünkü ölçümün duyarlılığı işlemciye ve işletim
    sisteminin çekirdeğine bağlı olabilmektedir. İşte ölçümün duyarlılığı ayrıca clock_getres fonksiyonu ile elde edilebilmektedir.

    #include <time.h>

    int clock_getres(clockid_t clock_id, struct timespec *res);

    Fonksiyonun birinci parametresi duyarlılığı ölçülecek olan saat türünü belirtmektedir. İkinci parametre ise duyarlılığın 
    yerleştirileceği timespec yapısının adresini belirtmektedir.

    Aşağıda fonksiyonun kullanımına bir örnek verilmiştir. Kursun yürütüldüğü sanal makinede bu fonksiyon 1 nanosaniye duyarlılık 
    belirtmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void exit_sys(const char *msg);

int main(void)
{
    struct timespec ts;
    long long result;

    if (clock_getres(CLOCK_MONOTONIC, &ts) == -1)
        exit_sys("clock_getres");

    result = (ts.tv_sec * 1000000000LL + ts.tv_nsec);

    printf("%lld\n", result);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    clock_gettime fonksiyonunda clockid_t olarak CLOCK_PROCESS_CPUTIME_ID geçilirse prosesin yalnızca CPU'da harcadığı zamanların
    toplamı verilir. Bu muhtemelen gerçek zamandan daha kısa olacaktır. Eğer proses çok thread'ten oluşuyorsa bu hesaba tüm 
    thread'lerin CPU zamanları dahil edilmektedir. Fakat clockid_t olarak CLOCK_THREAD_CPUTIME_ID verilirse bu da spesifik 
    bir thread'in (fonksiyonu çağıran) CPU zamanını ölçmekte kullanılır.

    Aşağıdaki örnekte aslında programın iki noktası arasında geçen zaman 5 saniyeden daha yüksek olduğu halde ölçüm 
    CLOCK_PROCESS_CPUTIME_ID ile yapıldığından ve yalnızca prosesin CPU'da harcadığı zamanın ölçülmesinden dolayı işlemden 
    çok küçük bir değer elde edilecektir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    struct timespec ts1, ts2;
    long long elapsed_time;

    if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts1) == -1)
        exit_sys("clock_gettime");

    for (int i = 0; i < 5; ++i) {
        for (int k = 0; k < 10000000; ++k)
            ;
        sleep(1);
    }

    if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts2) == -1)
        exit_sys("clock_gettime");

    elapsed_time = (ts2.tv_sec * 1000000000LL + ts2.tv_nsec) - (ts1.tv_sec * 1000000000LL + ts1.tv_nsec);
    /* elsapsed_time = (ts2.tv_sec - ts1.tv_sec) * 1000000000.0 + ts2.tv_nsec - ts1.tv_nsec; */

    printf("Elapsed Nanosecond: %lld\n", elapsed_time);
    printf("Elapsed Second: %f\n", elapsed_time / 1000000000.);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    clock_gettime fonksiyonunda eğer clock id olarak CLOCK_THREAD_CPUTIME_ID verilirse yalnızca fonksiyonu çağıran thread'in
    CPU'da harcadığı zaman elde edilmektedir. Tabii tek thread'li uygulamalarda CLOCK_PROCESS_CPUTIME_ID ile CLOCK_THREAD_CPUTIME_ID
    arasında bir fark oluşmayacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Ayrıca POSIX standartlarında clock_settime isimli bir fonksiyon da vardır. Bu fonksiyon söz konusu saati set etmek için
    kullanılmaktadır. Ancak set işlemi yalnızca uygun önceliğe sahip prosesler tarafından yapılabilmektedir. Her saat türü de
    set edilemeyebilmektedir. Fonksiyonun prototipi şöyledir:

    #include <time.h>

    int clock_settime(clockid_t clock_id, const struct timespec *tp);

    Biz burada bu fonksiyonun kullanımına örnek vermeyeceğiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosesin user mode'da ve kernel mode'da harcadığı zamanlar işletim sistemi tarafından proses kontrol bloğunda saklanmaktadır. 
    Proses kontrol bloğundan bu bilgiler times isimli POSIX fonksiyonu ile (doğrudan ilgili sistem fonksiyonunu çağırmaktadır)
    elde edilebilmektedir. Fonksiyonun prototipi şöyledir:

    #include <sys/times.h>

    clock_t times(struct tms *buffer);

    Fonksiyon çağrıldığı ana kadarki prosesin zaman bilgisini alarak tms isimli bir yapı nesnesinin içerisine yerleştirmektedir. 
    Fonksiyonun geri dönüş değeri belli bir orijinden geçen gerçek zamanı belirten bir değerdir. (Yani bu değer tek başına bir 
    anlam taşımaz.) Fonksiyon başarısızlık durumunda -1 değerine geri dönmektedir.

    tms yapısı şöyledir:

    struct tms {
        clock_t tms_utime;    /* user time */
        clock_t tms_stime;    /* system time */
        clock_t tms_cutime;    /* user time of children */
        clock_t tms_cstime;    /* system time of children */
    };

    Yapının tms_utime elemanı prosesin user mode'da harcadığı zamanı, tms_stime elemanı kernel mode'da harcadığı zamanı vermektedir. 
    tms_cutime elemanı wait fonksiyonlarıyla beklenen tüm alt proseslerin (ve onların alt proseslerinin de) user mode'daki zamanlarını
    tms_cstime da wait fonksiyonu ile beklenen tüm alt proseslerin (ve onların alt proseslerinin de) kernel mode'daki zamanlarını 
    vermektedir. Fonksiyonun verdiği zamanlar proses kontrol bloktan alınmaktadır. Proses kontrol bloğa da zamanlar "timer tick" 
    olarak yazılmaktadır. Timer tick değerleri günümüzün masaüstü sistemlerinde 1 milisaniye, yavaş sistemlerde 10 milisaniye 
    periyottadır. Bu fonksiyon prosesin bloke olup uykuda beklediği zamanları bize herhangi bir biçimde vermemektedir. Yalnızca
    prosesin ve alt proseslerin user mode'da ve kernel mode'da harcadığı zamanları bize vermektedir.

    Standard time kabuk komutu bu fonksiyon ve muhtemelen clock_gettime fonksiyonu kullanılarak gerçekleştirilmiştir.

    Aşağıdaki örnekte komut satırından alınan program çalıştırılmış ve onun user ve kernel mode'daki zamanı yazdırılmıştır. 
    Ancak programın çalışması için gereken gerçek zaman yazdırılmamıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/wait.h>
#include <time.h>
#include <sys/times.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    struct tms tms;
    pid_t pid;

    if (argc < 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0 && execvp(argv[1], &argv[1]) == -1)
        _exit(EXIT_FAILURE);

    if (wait(NULL) == -1)
        exit_sys("wait");

    if (times(&tms) == -1)
        exit_sys("times");

    printf("User time: %f\n", (double)tms.tms_cutime / CLOCKS_PER_SEC);
    printf("Kernel time: %f\n", (double)tms.tms_cstime / CLOCKS_PER_SEC);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bazen belli periyotta sürekli işlemlerin yapılması gerekebilmektedir. Örneğin ekrana canlı bir saat çıkartmak istediğimizi 
    düşünelim. Saatimizin duyarlılığı da saniye cinsinden olsun. Biz saniyede bir periyodik olarak bir fonksiyonumuzun çağrılmasını
    sağlarsak bu işlemi kolaylıkla yapabiliriz. Bu tür periyodik timer mekanizmalarına "interval timer" da denilmektedir. 
    POSIX standartlarında "interval timer" oluşturmak için iki fonksiyon bulundurulmuştur.

    Şüphesiz interval timer oluşturmanın basit bir yolu bir thread yaratmak ve o thread içerisinde bir döngü oluşturup 
    clock_nanosleep gibi bir fonksiyonla bekleme yapmak olabilir. Ancak bunun için bir thread'e gereksinim duyulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Interval timer setitimer isimli POSIX fonksiyonu ile basit bir biçimde oluşturulabilmektedir. Ancak POSIX standartlarına 
    izleyen paragraflarda ele alacağımız daha yetenekli bir "interval timer" mekanizması eklendiği için bu fonksiyon "obsolete"
    yani "deprecated" yapılmıştır. Fonksiyonun prototipi şöyledir:

    #include <sys/time.h>

    int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);

    setitimer fonksiyonunda periyodik işleme başlamak için gereken zaman ile periyot zamanı fonksiyona ayrı ayrı verilmektedir. 
    setitimer fonksiyonu ile oluşturulan "interval timer" mekanizmasının türleri vardır. Her tür, zaman dolduğunda farklı bir 
    sinyalin oluşmasına yol açmaktadır. Fonksiyonun birinci parametresi interval timer'ın türünü belirtmektedir. Bu tür 
    şunlardan biri olabilir:

    ITIMER_REAL: Bu gerçek zamana dayalı ölçüm yapar. Zaman dolduğunda SIGALRM sinyali gönderilmektedir.

    ITIMER_VIRTUAL: Buradaki ölçüm prosesin çalışmasına göre yapılmaktadır. Yani proses çalışmadığı sürece saat artmamaktadır. 
    Bu türde zaman dolduğunda SIGVTALRM sinyali gönderilmektedir.

    ITIMER_PROF: Burada ölçüm yine prosesin çalışmasına göre yapılmaktadır. Ancak bekleme zamanları da buna dahil edilmektedir. 
    Zaman dolduğunda SIGPROF sinyali gönderilmektedir.

    Fonksiyonun ikinci parametresi itimerval isimli bir yapı türündendir. Bu yapı şöyle bildirilmiştir:

    struct itimerval {
        struct timeval it_interval;        /* next value */
        struct timeval it_value;        /* current value */
    };

    Yapının elemanlarının struct timeval türünden olduğuna dikkat ediniz. Bu yapı da şöyle bildirilmiştir:

    struct timeval {
        time_t      tv_sec;            /* seconds */
        suseconds_t tv_usec;        /* microseconds */
    };

    itimerval yapısının it_value elemanı ilk periyoda kadar geçen zamanı, it_interval elemanı da periyodik zamanı belirtmektedir. 
    Fonksiyonun üçüncü parametresi bir önceki itimer çağrısında set edilen değerin elde edilmesi için kullanılmaktadır. Bu
    parametre NULL geçilebilir. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    setitemer ile oluşturulan interval timer'ın disable hale getirilmesi için fonksiyonun ikinci parametresindeki yapının 
    it_value elemanı sıfırlanarak çağrılması gerekmektedir.

    Aşağıdaki örnekte interval timer ilk periyoda kadar 5 saniye bekleyecek biçimde oluşturulmuştur. Timer periyodu da 
    1 saniye olarak ayarlanmıştır. 10 kere sinyal oluşturulduktan sonra interval timer disable edilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <sys/time.h>

int g_count;

void sigalrm_handler(int signo);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;
    struct itimerval itval;

    sa.sa_handler = sigalrm_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGALRM, &sa, NULL) == -1)
        exit_sys("sigaction");

    itval.it_value.tv_sec = 5;
    itval.it_value.tv_usec = 0;

    itval.it_interval.tv_sec = 1;
    itval.it_interval.tv_usec = 0;

    if (setitimer(ITIMER_REAL, &itval, NULL) == -1)
        exit_sys("setitimer");

    for (;;) {
        pause();
        ++g_count;
        if (g_count == 10) {
            itval.it_value.tv_sec = 0;
            itval.it_value.tv_usec = 0;

            if (setitimer(ITIMER_REAL, &itval, NULL) == -1)
                exit_sys("setitimer");
            break;
        }
    }

    printf("timer disabled, sleeps for extra 5 seconds before finish...\n");
    sleep(5);

    return 0;
}

void sigalrm_handler(int signo)
{
    printf("interval timer...\n");        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                84. Ders 24/09/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Periyodik timer oluşturabilmek için kullanılan setitimer fonksiyonunun bazı yetersizlikleri şunlardır:

    - Haberdar etme mekanizması yalnızca sinyalle yapılmaktadır.
    - Kullanılan sinyal gerçek zamanlı olmayan sinyallerdir. Bunların da biriktirilmesi söz konusu değildir.
    - Sinyal oluştuğunda sinyal gerçek zamanlı olmadığı için sinyale iliştirilecek bir bilgi de yoktur.
    - Thread yoluyla haberdar edilme mekanizması yoktur.
    - Zaman duyarlılığı mikrosaniye mertebesindedir.

    İşte bu eksikliklerden dolayı POSIX'e yeni bir interval timer mekanizması eklenmiştir. Bu interval timer mekanizmasının 
    kullanılması setitimer mekanizmasına göre daha zordur. Bu yeni mekanizmada ilk yapılacak şey bir interval timer nesnesinin
    timer_create fonksiyonu ile yaratılmasıdır. timer_create fonksiyonunun prototipi şöyledir:

    #include <time.h>

    int timer_create(clockid_t clockid, struct sigevent *evp, timer_t *timerid);

    Fonksiyonun birinci parametresi zamanlamada kullanılacak saatin türünü belirtmektedir. Bu tür daha önce gördüğümüz CLOCK_MONOTONIC,
    CLOCK_REALTIME, CLOCK_PROCESS_CPUTIME_ID, CLOCK_THREAD_CPUTIME_ID olabileceği gibi clock_getcpuclockid ve pthread_getcpuclockid
    fonksiyonlarından elde edilen clock id'ler kullanılabilmektedir. Fonksiyonun ikinci parametresi sigevent isimli bir yapı 
    nesnesinin adresini almaktadır. sigevent yapısı şöyle bildirilmiştir:

    #include <signal.h>

    union sigval {                /* Data passed with notification */
        int     sival_int;        /* Integer value */
        void   *sival_ptr;        /* Pointer value */
    };

    struct sigevent {
        int    sigev_notify;                            /* Notification method */
        int    sigev_signo;                                /* Notification signal */
        union  sigval sigev_value;                        /* Data passed with notification */
        void  (*sigev_notify_function)(union sigval);    /* Function used for thread notification (SIGEV_THREAD) */
        void   *sigev_notify_attributes;                /* Attributes for notification thread (SIGEV_THREAD) */
        pid_t  sigev_notify_thread_id;                    /* ID of thread to signal (SIGEV_THREAD_ID); Linux-specific */
    };

    Yapının sigev_notify elemanı periyot dolduğunda haberdar edilmenin nasıl yapılacağını belirtmektedir. Bu elemana şu değerlerden
    biri yerleştirilebilir:

    SIGEV_NONE: Haberdar edilme yapılmaz.

    SIGEV_SIGNAL: Haberdar edilme sinyal yoluyla yapılır.

    SIGEV_THREAD: Haberdar edilme bu mekanizma tarafından yaratılan bir thread tarafından yapılır.

    SIGEV_THREAD_ID: Haberdar edilme prosesin spesifik bir thread'i ile sinyal yoluyla yapılmaktadır. (Bu yöntem POSIX 
    standartlarında yoktur, dolayısıyla Linux'a özgüdür.)

    Yapının sigev_signo elemanı eğer haberdar edilme sinyal yoluyla yapılacaksa oluşturulacak sinyalin numarasını almaktadır.
    Bu sinyal numarası normal bir sinyal olabileceği gibi gerçek zamanlı bir sinyal de olabilmektedir. Yapının sigev_value 
    elemanı gerçek zamanlı sinyallerde sinyale iliştirilecek bilgiyi belirtmektedir. Bu aynı zamanda thread yoluyla haberdar 
    edilmede de kullanılmaktadır. Yapının sigev_notify_function elemanı eğer haberdar edilme thread yoluyla yapılacaksa haberdar
    edecek thread'in çağıracağı fonksiyonu belirtmektedir. Yapının sigev_notify_attributes elemanı ise yaratılacak thread'in 
    özellik bilgilerini belirtmektedir. Bu elemana NULL adres geçilebilir. Yapının sigev_notify_thread_id elemanı Linux'a özgüdür. 
    Eğer birinci parametreye Linux'a özgü olan SIGEV_THREAD_ID değeri geçilirse bu elemana da thread'in pid değeri girilmelidir. 
    Aslında fonksiyonun ikinci parametresi NULL adres de geçilebilmektedir. Bu durumda haberdar edilme SIGALRM sinyali yoluyla
    yapılmaktadır. (Aslında POSIX standartları bu durumda sinyalin SIGALRM olduğunu açıkça belirtmemiştir, "default signal" ifadesini
    kullanmıştır. Bu "default signal" Linux sistemlerinde SIGABRT sinyalidir.)

    timer_create fonksiyonunun son parametresi yaratılan interval timer'ın id'sinin yerleştirileceği timer_t türünden nesnenin
    adresini almaktadır. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Örneğin:

    struct sigaction sa;
    struct sigevent se;
    timer_t itimer;

    sa.sa_sigaction = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART|SA_SIGINFO;

    if (sigaction(SIGRTMIN, &sa, NULL) == -1)
        exit_sys("sigaction");

    se.sigev_notify = SIGEV_SIGNAL;
    se.sigev_signo = SIGRTMIN;
    se.sigev_value.sival_int = 100;

    if (timer_create(CLOCK_MONOTONIC, &se, &itimer) == -1)
        exit_sys("timer_create");

    Interval timer nesnesi yaratıldıktan sonra artık periyot timer_settime fonksiyonu ile belirlenmelidir. Fonksiyonun prototipi
    şöyledir:

    #include <time.h>

    int timer_settime(timer_t timerid, int flags, const struct itimerspec *new_value, struct itimerspec *old_value);

    Fonksiyonun birinci parametresi timer_create fonksiyonundan elde edilen "timer id" değeridir. İkinci parametre 0 ya da 
    TIMER_ABSTIME biçiminde geçilebilir. Bu parametre 0 geçilirse "göreli zaman", TIMER_ABSTIME geçilirse mutlak zaman 
    dikkate alınır. Programcılar hemen her zaman göreli zaman kullanırlar. Fonksiyonun üçüncü parametresi ilk haberdar 
    edilmenin ve periyodik haberdar edilmenin zamanlamasının ayarlandığı itimerspec isimli yapı nesnesinin adresini almaktadır. 
    Bu yapı programcı tarafından doldurulup fonksiyona verilmelidir. Yapı şöyle bildirilmiştir:

    #include <time.h>

    struct itimerspec {
        struct timespec it_interval;    /* Interval for periodic timer */
        struct timespec it_value;        /* Initial expiration */
    };

    Yapının it_value elemanı ilk haberdar edilmeye kadar geçecek zamanı, it_interval elemanı haberdar edilme periyodunu 
    belirtmektedir. Anımsanacağı gibi timespec yapısı da şöyle bildirilmiştir:

    struct timespec {
        time_t tv_sec;        /* Seconds */
        long tv_nsec;        /* Nanoseconds [0, 999'999'999] */
    };

    Fonksiyonun son parametresi eski değerlerin yerleştirileceği yapı nesnesinin adresini almaktadır. Bu parametre NULL 
    geçilebilir. Ya da ikinci parametre NULL geçilip eski değerler de alınabilir.

    timer_settime fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Örneğin:

    if (timer_create(CLOCK_MONOTONIC, &se, &itimer) == -1)
        exit_sys("timer_create");

    ts.it_value.tv_sec = 5;
    ts.it_value.tv_nsec = 0;

    ts.it_interval.tv_sec = 1;
    ts.it_interval.tv_nsec = 0;

    if (timer_settime(itimer, 0, &ts, NULL) == -1)
        exit_sys("timer_settime");

    Interval timer ile işimiz bitince onu timer_delete fonksiyonu ile yok etmemiz gerekir. Fonksiyonun prototipi şöyledir:

    #include <time.h>

    int timer_delete(timer_t timerid);

    Fonksiyon parametre olarak timer_create fonksiyonundan elde edilen timer id değerini almaktadır. Başarı durumunda 0 değerine, 
    başarısızlık durumunda -1 değerine geri döner. Başarısının kontrol edilmesine normal olarak gerek yoktur. Örneğin:

    timer_delete(itimer);

    Aşağıda POSIX modern interval timer mekanizmasını sinyal yoluyla haberdar etmeye bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>
#include <unistd.h>
#include <signal.h>
#include <time.h>

void signal_handler(int signo, siginfo_t *info, void *context);
void exit_sys(const char *msg);

jmp_buf g_jb;
int g_count;

int main(void)
{
    struct sigaction sa;
    struct sigevent se;
    timer_t itimer;
    struct itimerspec ts;

    sa.sa_sigaction = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART|SA_SIGINFO;

    if (sigaction(SIGRTMIN, &sa, NULL) == -1)
        exit_sys("sigaction");

    se.sigev_notify = SIGEV_SIGNAL;
    se.sigev_signo = SIGRTMIN;
    se.sigev_value.sival_int = 100;

    if (timer_create(CLOCK_MONOTONIC, &se, &itimer) == -1)
        exit_sys("timer_create");

    ts.it_value.tv_sec = 5;
    ts.it_value.tv_nsec = 0;

    ts.it_interval.tv_sec = 1;
    ts.it_interval.tv_nsec = 0;

    if (timer_settime(itimer, 0, &ts, NULL) == -1)
        exit_sys("timer_settime");

    for (;;) {
        if (setjmp(g_jb) == 1)
            break;
        pause();
        ++g_count;
    }

    timer_delete(itimer);

    return 0;
}

void signal_handler(int signo, siginfo_t *info, void *context)
{
    if (g_count == 10)
        longjmp(g_jb, 1);

    printf("interval timer code %d\n", info->si_int);        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de thread yoluyla haberdar edilmeye bir örnek verelim. Bu yöntemde thread bu mekanizma tarafından yaratılıp bizim
    fonksiyonumuz çağrılmaktadır. Burada yaratılacak olan thread'in toplamda bir tane mi olacağı yoksa her periyot için ayrı 
    bir thread'in yeniden mi yaratılacağı POSIX standartlarında işletim sistemini yazanların isteğine bırakılmıştır. Linux 
    tek bir thread yaratıp tüm periyotlarda aynı thread'i kullanmaktadır. Bu durumda çağrılacak callback fonksiyonun sigevent 
    yapısının sigev_notify_function elemanına girilmesi gerekmektedir. Fonksiyonun parametrik yapısı şöyle olmalıdır:

    void notification_proc(union sigval);

    Örneğin:

    struct sigevent se;
    timer_t itimer;
    struct itimerspec ts;

    se.sigev_notify = SIGEV_THREAD;
    se.sigev_notify_function = notification_proc;
    se.sigev_notify_attributes = NULL;
    se.sigev_value.sival_int = 100;

    if (timer_create(CLOCK_MONOTONIC, &se, &itimer) == -1)
        exit_sys("timer_create");

    ts.it_value.tv_sec = 5;
    ts.it_value.tv_nsec = 0;

    ts.it_interval.tv_sec = 1;
    ts.it_interval.tv_nsec = 0;

    if (timer_settime(itimer, 0, &ts, NULL) == -1)
        exit_sys("timer_settime");

    Aşağıda thread yaratılarak haberdar edilmeye bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>
#include <unistd.h>
#include <signal.h>
#include <time.h>

void notification_proc(union sigval sval);
void exit_sys(const char *msg);

int main(void)
{
    struct sigevent se;
    timer_t itimer;
    struct itimerspec ts;

    se.sigev_notify = SIGEV_THREAD;
    se.sigev_notify_function = notification_proc;
    se.sigev_notify_attributes = NULL;
    se.sigev_value.sival_int = 100;

    if (timer_create(CLOCK_MONOTONIC, &se, &itimer) == -1)
        exit_sys("timer_create");

    ts.it_value.tv_sec = 5;
    ts.it_value.tv_nsec = 0;

    ts.it_interval.tv_sec = 1;
    ts.it_interval.tv_nsec = 0;

    if (timer_settime(itimer, 0, &ts, NULL) == -1)
        exit_sys("timer_settime");

    printf("Press ENTER to exit...\n");
    getchar();

    timer_delete(itimer);

    return 0;
}

void notification_proc(union sigval sval)
{
    printf("interval timer code %d\n", sval.sival_int);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz sinyal yoluyla haberdar edilirken gerçek zamanlı bir sinyal kullanmamışsak bir biriktirme yapılmadığı için ilgili 
    sinyal bloke edildiğinde ondan kaç periyot geçtiğini anlayamayız. İşte bunu anlayabilmek için POSIX interval mekanizmasında 
    timer_getoverrun fonksiyonu bulundurulmuştur. Fonksiyonun prototipi şöyledir:

    #include <time.h>

    int timer_getoverrun(timer_t timerid);

    Fonksiyon bize sinyal bloke edildiğinde kaç kez periyot geçtiğini vermektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX türevi sistemlerde çok sayıda sistemden sisteme değişebilecek parametrik değer vardır. Örneğin bir yol ifadesinin 
    maksimum uzunluğu, bir prosesin açık durumda tutabileceği maksimum dosya sayısı (yani dosya betimleyici tablosunun büyüklüğü), 
    bir kullanıcının yaratabileceği alt proseslerin sayısı, exec fonksiyonuna geçirilecek komut satırı argümanlarının sayısı, 
    ek grupların (supplementary groups) sayısı (bu konu ileride ele alınmaktadır) gibi pek çok parametrik değer sistemden sisteme 
    değişebilmektedir. Halbuki taşınabilir programlar oluşturabilmek için bu parametrik değerlerin o anda programın çalıştığı 
    sistemde biliniyor olması gerekebilmektedir.

    Genel olarak sistemdeki parametrik değerler <limits.h> dosyası içerisinde sembolik sabitler biçiminde define edilmiştir. 
    (C standartlarında da bir <limits.h> dosyası vardır, ama POSIX limits.h dosyası çok daha geniş kapsamlıdır.) <limits.h> 
    dosyası içerisindeki sembolik sabitler POSIX standartlarında şu gruplara ayrılmıştır:

    - Runtime Invariant Values (Possibly Indeterminate)
    - Pathname Variable Values
    - Runtime Increasable Values
    - Maximum Values
    - Minimum Values
    - Numerical Limits (C standartlarında da var)
    - Other Invariant Values

    POSIX standartları bazı parametrik değerlerin POSIX uyumlu sistemler için olabilecek en küçük değerlerini "Minimum Values"
    kategorisi içerisinde define etmiştir. Buradaki sembolik sabitlerin hepsi _POSIX_ öneki başlatılmıştır ve genellikle sonunda 
    MAX soneki bulunmaktadır. Yani bu sembolik sabitlerin isimleri tipik olarak _POSIX_XXX_MAX biçimindedir. Her ne kadar sembolik 
    sabit isminde MAX soneki kullanılmışsa da aslında bu değerler her POSIX uyumlu sistemin destekleyeceği minimum değerlerdir. 
    Bu minimum değerlerin hepsi açıkça POSIX standartlarında belirtilmiştir. Örneğin bir prosesin açık durumda tutabileceği dosya 
    sayısı (yani dosya betimleyici tablosunun uzunluğu) _POSIX_OPEN_MAX sembolik sabitiyle belirtilmiştir ve bunun değeri 20'dir. 
    Yine örneğin bir kullanıcının yaratabileceği maksimum alt proses sayısı _POSIX_CHILD_MAX sembolik sabitiyle belirtilmiştir ve
    bunun değeri de 25'tir. Buradaki isimsel karışıklığa dikkat ediniz. _POSIX_CHILD_MAX sembolik sabiti bir kullanıcının yaratabileceği
    maksimum alt proses sayısına ilişkindir. Ancak bu sembolik sabitin değeri POSIX uyumlu sistemdeki olabilecek minimum değerdir. 
    Örneğin _POSIX_ARG_MAX sembolik sabiti exec fonksiyonlarında girilebilecek maksimum argüman ve çevre değişkenlerinin byte uzunluğu 
    ile ilgilidir. Ancak bu sembolik sabit POSIX uyumlu bir sistemdeki minimal değeri belirtmektedir ve 4096 olarak belirlenmiştir. 
    Başka bir deyişle bir POSIX uyumlu bir işletim sistemi yazacaksak bir kullanıcının yaratabileceği maksimum alt proses sayısının 
    en az 25 olmasını, exec fonksiyonuna girilebilecek maksimum argüman sayısının ve çevre değişkeni sayısının en az 4096 olmasını 
    sağlamalıyız.

    POSIX tarafından belirlenen ve _POSIX_XXX_MAX biçiminde <limits.h> içerisinde define edilmiş olan minimum değerler aslında
    çok küçük değerlerdir. Örneğin _POSIX_NAME_MAX bir dosyanın karakter uzunluğunu belirtir. Bunun minimum değeri 14'tür. Halbuki 
    yaygın hiçbir sistem 14 karakterden çok daha fazla dosya isimlerini desteklemektedir. Benzer biçimde bir kullanıcının maksimum 
    yaratacağı alt proses sayısının 25 olması da çok düşük bir değerdir. İşte bu sembolik sabitler tüm POSIX sistemlerindeki 
    olabilecek en küçük değerleri belirtmektedir, ancak modern sistemler dikkate alındığında bir kullanımı yoktur. O halde 
    programcının POSIX standartlarının desteklediği en küçük değere değil, o sistemdeki mevcut değere ihtiyacı vardır.

    <limits.h> dosyası içerisinde "Runtime Invariant Values (Possibly Indeterminate)" kategorisi bazı _POSIX_XXX_MAX değerlerinin 
    ilgili sistemdeki gerçek değerlerini belirtmektedir. Bu gerçek değerler <limits.h> içerisinde başında _POSIX_ öneki olmadan 
    bildirilmiştir. Örneğin _POSIX_CHILD_MAX minimum değerinin ilgili sistemdeki gerçek değeri CHILD_MAX sembolik sabitiyle,
    _POSIX_OPEN_MAX minimum değerinin ilgili sistemdeki gerçek değeri OPEN_MAX sembolik sabitiyle bildirilmiştir. Böylece 
    <limits.h> içerisinde hem POSIX sistemlerindeki minimum değerler hem de ilgili sistemdeki gerçek değerler define edilmiş 
    durumdadır. Ancak burada da önemli bir pürüz vardır. Bazı parametrik değerler sistemin çalışması sırasında değiştirilebilmektedir 
    ya da bazı parametrik değerler o andaki sistem kaynaklarının miktarıyla ilgilidir. Bu durumda bu parametrelerin ilgili 
    sistemdeki değerleri baştan tespit edilememektedir. Ayrıca bazı parametrelerin ilgili sistemde bir sınırı da olmayabilir. 
    İşte POSIX standartları "Runtime Invariant Values (Possibly Indeterminate)" başlığı altında "eğer bir parametrik değer 
    sistem çalışırken değiştirilebiliyorsa ya da onun bir sınırı yoksa" ona ilişkin sembolik sabitin <limits.h> içerisinde define 
    edilmemesi gerektiğini belirtmektedir. Yani aslında OPEN_MAX gibi, ARG_MAX gibi, CHILD_MAX gibi sembolik sabitler <limits.h> 
    içerisinde define edilmemiş de olabilirler. Yani bu parametrelere ilişkin sembolik sabitler ancak define edilmişse 
    kullanılabilmektedir. Pekiyi bir sembolik sabitin define edilip edilmeyeceği belirsizse biz bundan faydalanabilir miyiz? 
    İşte POSIX standartlarının örtük bir biçimde önerdiği yöntem şudur: Eğer bir parametrik değer <limits.h> içerisinde define 
    edilmişse programcı onu doğrudan derleme zamanında kullanabilir. Ancak define edilmemişse o anki gerçek değer programın 
    çalışma zamanı sırasında sysconf, pathconf ve fpathconf fonksiyonlarıyla elde edilmelidir. (Tabii hiç sembolik sabite 
    bakılmadan doğrudan bu fonksiyonlar da çağrılabilir. Yalnızca fonksiyon çağırma maliyeti bir dezavantaj oluşturmaktadır.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                85. Ders 30/09/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    <limits.h> içerisindeki diğer bir grup da "Pathname Variable Values" isimli gruptur. Bu başlık altında belirtilen 
    sembolik sabitlerin değerleri o anda kullanılan dosya sistemine bağlı olarak değişebilmektedir. UNIX/Linux sistemlerinde 
    farklı dosya sistemleri farklı noktalara mount edilebilmektedir. Bu farklı dosya sistemlerinin isim uzunlukları gibi 
    özellikleri de birbirinden farklı olabilmektedir. İşte bu tür büyüklükler <limits.h> içerisinde "Pathname Variable Values"
    başlığı altında toplanmıştır. Bu gruptaki en önemli sembolik sabitler NAME_MAX ve PATH_MAX sembolik sabitleridir. NAME_MAX 
    bir dizin girişinin isminin olabilecek maksimum karakter sayısını belirtmektedir. PATH_MAX ise toplamda mutlak bir yol 
    ifadesinin olabileceği en fazla karakter sayısını belirtir. Bir dosya isminin ya da bir yol isminin bir yerde saklanacağı 
    durumlarda saklanacak yerin büyüklüğünün belirlenmesi için bu değerlere gereksinim duyulmaktadır. Yukarıda da belirttiğimiz 
    gibi bu değerler dosya sisteminden sistemine değişebilecek değerlerdir. İşte POSIX standartları eğer bu değerler tüm dizin 
    ağacı içerisinde sabit ise bu sembolik sabitlerin define edilmesi, ancak sabit değilse define edilmemesi gerektiğini 
    belirtmektedir. Yani örneğin PATH_MAX sembolik sabiti bir UNIX türevi sistemde define edilmişken başka bir sistemde edilmemiş 
    olabilir. İşte "Pathname Variable Values" grubundaki sembolik sabitler eğer <limits.h> içerisinde define edilmemişse bu 
    durumda onların değerleri pathconf ya da fpathconf POSIX fonksiyonuyla alınmalıdır.

    <limits.h> içerisindeki "Runtime Increasable Values" grubundaki sembolik sabitler sistemden sisteme değişebilir ve işletiminin
    çalışma zamanı sırasında artırılabilir. Bu sembolik sabitlerin ilgili sistemdeki minimum değerleri bu başlık altında define 
    edilmek zorundadır. Anımsanacağı gibi bazı sembolik sabitlerin tüm POSIX sistemleri genelindeki minimum değerleri _POSIX_XXX
    biçiminde "Minimum Values" grubunda belirtilmiştir. Özetle "Runtime Increasable Values" grubundaki değerler o sistemdeki
    minimum değerler olarak kullanılabilir. Ancak bunların gerçek değerleri programın çalışma zamanı sırasında sysconf fonksiyonu
    ile elde edilmelidir.

    <limits.h> içerisindeki "Numeric Limits" grubundaki sembolik sabitler aslında C'nin <limits.h> dosyası içerisinde de bulunmaktadır. 
    Bu sembolik sabitler temel türlerin o sistemdeki maksimum ve minimum değerlerini belirtmektedir. Örneğin INT_MIN int türünün 
    o sistemdeki minimum değerini, INT_MAX ise maksimum değerini belirtir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    sysconf fonksiyonu yukarıda da belirttiğimiz gibi "Runtime Invariant Values" ve "untime Increasable Values" grubundaki 
    büyüklüklerin programın çalışma zamanı sırasında elde edilmesinde kullanılmaktadır. Tabii "Runtime Invariant Values" 
    grubundaki sembolik sabitler eğer define edilmişse bu fonksiyonu çağırmaya gerek yoktur. Doğrudan o sembolik sabitlerin 
    değeri programcı tarafından kullanılabilir. sysconf fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    long sysconf(int name);

    Fonksiyon parametre olarak hangi büyüklüğün değerinin elde edilmek istendiğini almaktadır. Bu değerler _SC_XXX biçiminde 
    define edilmiştir. Bu sembolik sabitlerin oluşturulmasındaki kurala dikkat ediniz: POSIX'teki minimum değerler _POSIX_XXX
    biçiminde, o sistemdeki değerler XXX biçiminde, sysconf fonksiyonun parametreleri ise _SC_XXX biçiminde isimlendirilmiştir. 
    Örneğin dosya betimleyici tablosunun POSIX'teki minimum uzunluğu _POSIX_OPEN_MAX sembolik sabitiyle, ilgili sistemdeki uzunluğu
    OPEN_MAX sembolik sabitiyle, sysconf fonksiyonundaki parametre ismi ise _SC_OPEN_MAX ismiyle define edilmiştir.

    sysconf fonksiyonu başarı durumunda ilgili büyüklüğe, başarısızlık durumunda -1 değerine geri dönmektedir. sysconf ile 
    elde edilmek istenen büyüklük belirli olmayabilir ve sınırsız (infinite) da olabilir. Bu durumda fonksiyon başarısız 
    olur. Ancak errno, değer değiştirmez. (Yani bu durumu belirlemek için errno değişkenine sysconf fonksiyonunu çağırmadan önce 0 
    değeri yerleştirilir. Sonra fonksiyon başarısız olduğunda errno değişkenine bakılır. Eğer hala 0 değeri duruyorsa ilgili 
    büyüklüğün belirsiz ya da sınırsız olduğu sonucu çıkartılır.)

    Örneğin dosya betimleyici tablosunun uzunluğunu (yani açılacak maksimum dosya sayısını) sysconf fonksiyonu ile şöyle elde 
    edebiliriz:

    errno = 0;
    if ((result = sysconf(_SC_OPEN_MAX)) == -1)
        if (errno == 0)
            fprintf(stderr, "infinite value...\n");
        else
            exit_sys("sysconf");
    else
        printf("%ld\n", result);
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#include <errno.h>

void exit_sys(const char *msg);

int main(void)
{
    long result;

    errno = 0;
    if ((result = sysconf(_SC_OPEN_MAX)) == -1)
        if (errno == 0)
            fprintf(stderr, "infinite value...\n");
        else
            exit_sys("sysconf");
    else
        printf("%ld\n", result);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi <limits.h> içerisindeki "Pathname Variable Values" grubunda bulunan sembolik sabitler eğer
    ilgili sistemde define edilmemişse bunların değerleri pathconf ya da fpathconf fonksiyonlarıyla elde edilmelidir. Bu 
    fonksiyonların prototipleri şöyledir:

    #include <unistd.h>

    long fpathconf(int fildes, int name);
    long pathconf(const char *path, int name);

    Fonksiyonların ikinci parametreleri değeri elde edilecek büyüklüğü belirtmektedir. Büyüklüğün POSIX sistemlerindeki minimum 
    değeri _POSIX_XXX, ilgili sistemdeki değeri XXX olmak üzere buradaki büyüklük isimleri _PC_XXX biçiminde isimlendirilmiştir. 
    Örneğin bir dosyanın maksimum karakter uzunluğunun POSIX'teki minimum değeri _POSIX_NAME_MAX biçimindedir. İlgili sistemdeki
    değeri NAME_MAX biçiminde pathconf ve fpathconf fonksiyonlarındaki isimleri ise _PC_NAME_MAX biçimindedir. path fonksiyonu
    yol ifadesiyle çalışırken, fpathconf fonksiyonu açık dosya betimleyicisi ile çalışmaktadır. Bazı büyüklükler için bu yol 
    ifadesinin ya da betimleyicinin dizine ilişkin olması gerekir.

    Fonksiyon başarı durumunda ilgili büyüklük değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Eğer ilgili 
    büyüklüğün o sistemde belli bir sınırı yoksa fonksiyonlar başarısız olmakta ancak errno değerini değiştirmemektedir.

    Biz yukarıda genel olarak açıklamış olsak da belli büyüklüklerin değerlerini elde ederken ayrıntılar için POSIX dokümanlarına 
    başvurmanızı tavsiye ederiz. Örneğin _PC_NAME_MAX ve _PC_PATH_MAX değerlerini elde etmek için yol ifadesinin ya da betimleyicinin 
    bir dizine ilişkin olması gerekmektedir. Aksi takdirde fonksiyonun çalışması sistemden sisteme değişebilmektedir. Ayrıca örneğin 
    _PC_PATH_MAX ile verilen uzunluk o dizine göreli uzunluktur. Yani bu uzunluğa o dizine kadarki karakter uzunluğu da eklenmelidir. 
    Ayrıca örneğin NAME_MAX sembolik sabitiyle ya da _PC_NAME_MAX ismiyle elde edilen uzunluğa null karakter dahil değildir. 
    Halbuki PATH_MAX ya da _PC_PATH_MAX ile elde edilen uzunluğa null karakter dahildir. Örneğin PATH_MAX değerini pathconf 
    fonksiyonu ile şöyle elde edebiliriz:

    long result;

    errno = 0;
    if ((result = pathconf("/", _PC_PATH_MAX)) == -1)
        if (errno == 0)
            fprintf(stderr, "infinite value...\n");
        else
            exit_sys("pathmax");
    else
        printf("%ld\n", result);

    Biz burada kök dizinden itibaren (yani kök dizine göreli biçimde) yol ifadesinin uzunluğunu elde ettik. Dolayısıyla mutlak 
    yol ifadesi için gereken karakter sayısı burada elde edilenden 1 fazla olmalıdır. Çünkü bu fonksiyonların verdikleri değer
    bizim onlara geçtiğimiz dizine görelidir. Tabii Linux sistemlerinde NAME_MAX ve PATH_MAX sembolik sabitleri zaten define 
    edilmiştir. Dolayısıyla aslında Linux sistemlerinde bu fonksiyonların bu amaçla çağrılmasına gerek yoktur. Yani yazacağınız
    kod yalnızca Linux sistemlerinde kullanılacaksa zaten siz NAME_MAX ve PATH_MAX sembolik sabitlerini doğrudan kullanabilirsiniz. 
    Ancak taşınabilir programlar için bu fonksiyonlara gereksinim duyulabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#include <errno.h>

void exit_sys(const char *msg);

int main(void)
{
    long result;

    errno = 0;
    if ((result = pathconf("/", _PC_PATH_MAX)) == -1)
        if (errno == 0)
            fprintf(stderr, "infinite value...\n");
        else
            exit_sys("pathmax");
    else
        printf("%ld\n", result);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bazı büyüklüklere ilişkin değerler ilgili sistemde define edilmeyebileceğine göre taşınabilir programlar için nasıl 
    bir yol izlenmelidir? Tabii yöntemlerden biri her zaman sysconf ya da pathcnf, fpathconf fonksiyonlarını çağırmak olabilir. 
    Ancak ilgili sembolik sabitler o sistemde define edilmişse bu çağrı gereksiz zaman kaybına yol açacaktır. Taşınabilirliği 
    sağlamak için Stevens "Advanced Programming in the UNIX Environment" kitabında aşağıdaki gibi bir yöntem önermektedir:

    #define PATH_MAX_GUESS        4096

    #ifdef MAX_PATH
        static long g_max_path = MAX_PATH;
    #else
        static long g_max_path = 0;
    #endif

    long path_max(void)
    {
        if (!g_max_path) {
            errno = 0;
            if ((g_max_path = pathconf("/", _PC_PATH_MAX)) == -1)
                if (errno == 0)
                    g_max_path = PATH_MAX_GUESS;
                else
                    exit_sys("pathmax");
            else
                ++g_max_path;
        }

        return g_max_path;
    }

    Burada path_max fonksiyonu toplamda sıfır kere ya da en fazla bir kere pathconf fonksiyonunu çağırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#include <errno.h>

void exit_sys(const char *msg);

#define PATH_MAX_GUESS        4096

#ifdef MAX_PATH
    static long g_max_path = MAX_PATH;
#else
    static long g_max_path = 0;
#endif

long path_max(void)
{
    if (!g_max_path) {
        errno = 0;
        if ((g_max_path = pathconf("/", _PC_PATH_MAX)) == -1)
            if (errno == 0)
                g_max_path = PATH_MAX_GUESS;
            else
                exit_sys("pathmax");
        else
            ++g_max_path;
    }

    return g_max_path;
}

int main(void)
{
    char *path;

    if ((path = (char *)malloc(path_max())) == NULL) {
        fprintf(stderr, "cannot allocate memory!...\n");
        exit(EXIT_FAILURE);
    }

    free(path);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sistemini bir kaynak yöneticisi olarak da düşünebiliriz. Prosesler işletim sisteminin sunduğu çeşitli kaynakları 
    kullanmaktadır. Tabii işletim sistemleri proseslerin kaynak kullanımlarını sınırlandırmaktadır. Aksi takdirde bir proses
    çok fazla kaynak kullanıp diğer proseslerin o kaynağa erişimini güçleştirebilir. Prosesin kaynak limitleri (yani kaynakları 
    hangi sınırlar içerisinde kullanabileceği) proses kontrol bloğu içerisinde saklanmaktadır. (Linux'ta bu bilgi task_struct 
    yapısının signal elemanının gösterdiği struct signal yapısının içerisindeki struct rlimit dizisinde bulunmaktadır.)

    UNIX türevi işletim sistemleri her kaynak için bir "soft limit (buna current limit de denilmektedir)" bir de "hard limit"
    değeri tutmaktadır. Kontroller soft limit dikkate alınarak yapılır. Herhangi bir proses soft limiti yükseltebilir. Ancak 
    en fazla hard limit kadar yükseltebilir. Yani hard limit, soft limit için tavan değeri belirtmektedir. Sıradan prosesler 
    hard limiti yükseltemezler, ancak düşürebilirler. Eğer hard limit sıradan prosesler tarafından düşürülürse bir daha eski 
    değerine bile yükseltilemez. Uygun önceliğe sahip prosesler hard limiti yükseltebilirler. Dolayısıyla soft limiti de
    yükseltebilirler. Bir özelliğin hard limiti, soft limitin aşağısına çekilememektedir.

    O halde bizim şu bilgileri edinmemiz gerekir: Prosesin kaynakları nelerdir ve bu kaynak limitleri nasıl elde edilip 
    değiştirilmektedir?

    Prosesin kaynak limitlerini elde etmek için getrlimit POSIX fonksiyonu, set etmek için setrlimit POSIX fonksiyonu 
    kullanılmaktadır. getrlimit fonksiyonunun prototipi şöyledir:

    #include <sys/resource.h>

    int getrlimit(int resource, struct rlimit *rlp);

    Fonksiyonun birinci parametresi kaynağın türünü, ikinci parametresi kaynak bilgilerinin yerleştirileceği rlimit yapı 
    nesnesinin adresini almaktadır. rlimit yapısı şöyle bildirilmiştir:

    struct rlimit {
        rlim_t rlim_cur;        /* Soft limit */
        rlim_t rlim_max;        /* Hard limit (ceiling for rlim_cur) */
    };

    Buradaki rlimit tür ismi işaretsiz bir tamsayı biçiminde typedef edilmek zorundadır. Fonksiyon başarı durumunda 0 değerine,
    başarısızlık durumunda -1 değerine geri dönmektedir.

    getrlimit fonksiyonunda dikkat edilmesi gereken birkaç nokta vardır: Fonksiyonun birinci parametresindeki kaynak belirten 
    değer <sys/resource.h> dosyası içerisinde RLIMIT_XXX sembolik sabitleriyle define edilmiştir. Fonksiyon ile elde edilmek 
    istenen limitler sınırsız olabilir. Bu durumda rlimit yapısının rlim_cur ve rlim_max elemanlarına RLIM_INFINITY özel 
    değeri yerleştirilir. Elde edilmek istenen limit o sistemde belirsiz olabilir ya da o limitin o sistemde elde edilme yolu 
    olmayabilir (unspecified). Bu durumda yapının rlim_cur elemanına RLIM_SAVED_CUR özel değeri, yapının rlim_max elemanına ise
    RLIM_SAVED_MAX değeri yerleştirilir. getrlimit fonksiyonu aşağıdaki gibi kullanılmalıdır:

    struct rlimit rl;

    if (getrlimit(RLIMIT_STACK, &rl) == -1)
        exit_sys("getrlimit");

    if (rl.rlim_cur == RLIM_INFINITY)
        printf("soft limit infinite...\n");
    else if (rl.rlim_cur == RLIM_SAVED_CUR)
        printf("soft limit unrepresentable...\n");
    else
        printf("Soft limit: %ju\n", (uintmax_t)rl.rlim_cur);

    if (rl.rlim_max == RLIM_INFINITY)
        printf("hard limit infinite...\n");
    else if (rl.rlim_max == RLIM_SAVED_MAX)
        printf("hard limit unrepresentable...\n");
    else
        printf("hard limit: %ju\n", (uintmax_t)rl.rlim_max);
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/resource.h>

void exit_sys(const char *msg);

int main(void)
{
    struct rlimit rl;

    if (getrlimit(RLIMIT_STACK, &rl) == -1)
        exit_sys("getrlimit");

    if (rl.rlim_cur == RLIM_INFINITY)
        printf("soft limit infinite...\n");
    else if (rl.rlim_cur == RLIM_SAVED_CUR)
        printf("soft limit unrepresentable...\n");
    else
        printf("Soft limit: %ju\n", (uintmax_t)rl.rlim_cur);

    if (rl.rlim_max == RLIM_INFINITY)
        printf("hard limit infinite...\n");
    else if (rl.rlim_max == RLIM_SAVED_MAX)
        printf("hard limit unrepresentable...\n");
    else
        printf("hard limit: %ju\n", (uintmax_t)rl.rlim_max);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    setrlimit fonksiyonu prosesin kaynaklarındaki hard ve/veya soft limitleri değiştirmek için kullanılmaktadır. Yukarıda da 
    belirttiğimiz gibi soft limit en fazla hard limit kadar yükseltilebilir. Hard limit ise ancak uygun önceliğe sahip prosesler
    tarafından yükseltilebilmektedir. Fonksiyonun prototipi şöyledir:

    #include <sys/resource.h>

    int setrlimit(int resource, const struct rlimit *rlp);

    Fonksiyonun yine birinci parametresi kaynağı, ikinci parametresi yükseltilecek limitleri belirtmektedir. Örneğin:

    struct rlimit rl;

    if (getrlimit(RLIMIT_NOFILE, &rl) == -1)
        exit_sys("getrlimit");

    rl.rlim_cur = 4096;

    if (setrlimit(RLIMIT_NOFILE, &rl) == -1)
        exit_sys("getrlimit");

    Burada önce dosya betimleyici tablosunun soft ve hard limitleri getrlimit fonksiyonuyla elde edilmiştir. Daha sonra da
    setrlimit fonksiyonu ile yalnızca soft limit değiştirilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/resource.h>

void exit_sys(const char *msg);

int main(void)
{
    struct rlimit rl;

    if (getrlimit(RLIMIT_NOFILE, &rl) == -1)
        exit_sys("getrlimit");

    rl.rlim_cur = 4096;

    if (setrlimit(RLIMIT_NOFILE, &rl) == -1)
        exit_sys("setrlimit");

    if (getrlimit(RLIMIT_NOFILE, &rl) == -1)
        exit_sys("getrlimit");

    if (rl.rlim_cur == RLIM_INFINITY)
        printf("soft limit infinite...\n");
    else if (rl.rlim_cur == RLIM_SAVED_CUR)
        printf("soft limit unrepresentable...\n");
    else
        printf("Soft limit: %ju\n", (uintmax_t)rl.rlim_cur);

    if (rl.rlim_max == RLIM_INFINITY)
        printf("hard limit infinite...\n");
    else if (rl.rlim_max == RLIM_SAVED_MAX)
        printf("hard limit unrepresentable...\n");
    else
        printf("hard limit: %ju\n", (uintmax_t)rl.rlim_max);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                86. Ders 01/10/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Prosesin kaynak limitleri üst prosesten alt prosese fork işlemi sırasında aktarılmaktadır. Yani örneğin kabuk programının 
    kaynak limiti değiştirilirse bu limit kabuktan çalıştırılan bütün programlara yansıtılacaktır. Ancak bu konuda genellikle 
    yanlış anlaşılan bir nokta vardır. İşletim sistemi kaynak aşımına ilişkin kontrolleri o prosesin proses kontrol bloğundaki 
    değerlere göre yapmaktadır. Örneğin bir kullanıcının yaratacağı maksimum proses sayısı RLIMIT_NPROC isimli kaynak ile 
    belirlenmiştir. Biz bu değeri değiştirdiğimizde artık bizim prosesimiz ve bizim yarattığımız prosesler bu limitten etkilenir. 
    Ancak bizim başka proseslerimizin proses kontrol bloğunda bu değişiklik yapılmamış olduğu için onlar bu değişiklikten 
    etkilenmeyecektir. Oysa kişiler bu limitin kullanıcı tabanlı bir limit olduğunu gördüğünde sanki bir proses bu limiti 
    değiştirdiğinde sistem genelinde bir değişiklik yapılıyormuş gibi düşünmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kabuk programının proses limitleri ulimit isimli içsel (internal) kabuk komutuyla görüntülenip değiştirilebilmektedir. 
    (ulimit komutunun tıpkı cd komutu gibi dışsal bir komut olamayacağına dikkat ediniz.) ulimit komutu -a seçeneği ile 
    kullanılırsa tüm soft limitler görüntülenir. Örneğin:

    $ ulimit -a
    real-time non-blocking time  (microseconds, -R) unlimited
    core file size              (blocks, -c) 0
    data seg size               (kbytes, -d) unlimited
    scheduling priority                 (-e) 0
    file size                   (blocks, -f) unlimited
    pending signals                     (-i) 15070
    max locked memory           (kbytes, -l) 497904
    max memory size             (kbytes, -m) unlimited
    open files                          (-n) 1000
    pipe size                (512 bytes, -p) 8
    POSIX message queues         (bytes, -q) 819200
    real-time priority                  (-r) 0
    stack size                  (kbytes, -s) 8192
    cpu time                   (seconds, -t) unlimited
    max user processes                  (-u) 15070
    virtual memory              (kbytes, -v) unlimited
    file locks                          (-x) unlimited

    Hard limitleri görüntülemek için -H, soft limitleri görüntülemek için (default) -S seçenekleri kullanılmaktadır. Örneğin:

    $ ulimit -H -a
    real-time non-blocking time  (microseconds, -R) unlimited
    core file size              (blocks, -c) unlimited
    data seg size               (kbytes, -d) unlimited
    scheduling priority                 (-e) 0
    file size                   (blocks, -f) unlimited
    pending signals                     (-i) 15070
    max locked memory           (kbytes, -l) 497904
    max memory size             (kbytes, -m) unlimited
    open files                          (-n) 1048576
    pipe size                (512 bytes, -p) 8
    POSIX message queues         (bytes, -q) 819200
    real-time priority                  (-r) 0
    stack size                  (kbytes, -s) unlimited
    cpu time                   (seconds, -t) unlimited
    max user processes                  (-u) 15070
    virtual memory              (kbytes, -v) unlimited
    file locks                          (-x) unlimited

    Limitlerde değişiklik yapmak için limite özgü seçenekler kullanılmalıdır. Örneğin -n seçeneği dosya betimleyici tablosunun 
    uzunluğu ile ilgilidir. Değişiklik şöyle yapılabilir:

    $ ulimit -n 2048
    $ ulimit -n
    2048

    Burada default olarak hem hard hem de soft limit değiştirilmiştir. Yalnızca soft limitin değiştirilmesi için -S, yalnızca 
    hard limitin değiştirilmesi için -H seçeneğinin de komuta eklenmesi gerekir. Örneğin:

    $ ulimit -H -n 5000
    $ ulimit -H
    unlimited
    $ ulimit -a -H
    real-time non-blocking time  (microseconds, -R) unlimited
    core file size              (blocks, -c) 0
    data seg size               (kbytes, -d) unlimited
    scheduling priority                 (-e) 0
    file size                   (blocks, -f) unlimited
    pending signals                     (-i) 15070
    max locked memory           (kbytes, -l) 497904
    max memory size             (kbytes, -m) unlimited
    open files                          (-n) 5000
    pipe size                (512 bytes, -p) 8
    POSIX message queues         (bytes, -q) 819200
    real-time priority                  (-r) 0
    stack size                  (kbytes, -s) unlimited
    cpu time                   (seconds, -t) unlimited
    max user processes                  (-u) 15070
    virtual memory              (kbytes, -v) unlimited
    file locks                          (-x) unlimited

    Burada biz yalnızca hard limiti değiştirdik. Yukarıda da belirttiğimiz gibi hard limit, soft limitin aşağısına indirilememektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de bazı proses limitlerinden bahsedelim. Bunlar hakkında daha ayrıntılı bilgileri ilgili dokümanlardan edinebilirsiniz.

    - RLIMIT_AS: Prosesin maksimum kullanabileceği sanal bellek miktarını belirtir. Bu limitin Linux'taki default hard ve soft default 
    RLIM_INFINITY biçimindedir.

    - RLIMIT_CORE: Bu limit üzerinde daha önce de "core dosyalarının oluşturulması" konusunda bazı şeyler söylemiştik. Bu limit
    core dosyalarının maksimum uzunluğunu belirtmektedir. Linux'ta default olarak soft ve hard değerleri 0 durumundadır. Yani
    core dosyalarının oluşturulabilmesi için bu limitin yükseltilmesi (örneğin RLIM_INFINITY yapılması) gerekmektedir.

    - RLIMIT_CPU: Bu limit prosesin harcayacağı CPU zamanını sınırlandırmak için bulundurulmuştur. Eğer proses burada belirtilen 
    CPU zamanını saniye olarak aşarsa bu durumda çekirdek prosese SIGXCPU sinyalini göndermektedir. Bu sinyalin default eylemi
    prosesin sonlandırılması biçimindedir. Linux'ta bu sinyal için sinyal fonksiyonu yazıldığında proses hemen sonlandırılmaz ve
    her saniyede bu sinyal yeniden gönderilir. Soft limit değerine ulaşıldığında prosese SIGKILL sinyali gönderilerek proses 
    sonlandırılmaktadır.

    - RLIMIT_DATA: Bu limit prosesin "data segment" kısmının limitini belirlemektedir. malloc gibi tahsisat fonksiyonları 
    bu data segment kısmını büyüttüğü için bu limitten etkilenmektedir. Bu limitin Linux'taki default hard ve soft değeri 
    RLIM_INFINITY biçimindedir.

    - RLIMIT_FSIZE: Prosesin toplamda yaratabileceği maksimum dosya uzunluğudur. Örneğin bu limit 5 MB'a ayarlanmışsa proses
    toplamda (tüm yarattığı dosyaların uzunluğu) ancak 5 MB uzunluğunda dosya yaratabilecektir. Bu limitin Linux'taki default
    hard ve soft değerleri RLIM_INFINITY biçimindedir. Eğer bu limit aşılırsa işletim sistemi prosese SIGXFSZ sinyalini 
    göndermektedir. Bu sinyalin default eylemi prosesin sonlandırılmasıdır.

    - RLIMIT_NICE: Bu değer SCHED_OTHER prosesler için nice değerine sınır koymak amacıyla düşünülmüştür. Anımsanacağı gibi 
    normalize edilmiş olan nice değerleri [0, 39] arasındaydı. Buradaki değer 20 - RLIMIT_NICE biçiminde normalize edilmektedir. 
    Bu değerin sıfır olması, prosesin nice değerini yükseltemeyeceği anlamına gelmektedir. Bu limitin Linux'taki default hard ve 
    soft değerleri 0 biçimindedir.

    - RLIMIT_NOFILE: Prosesin dosya betimleyici tablosunun uzunluğunu belirtmektedir. Bu limitin Linux'taki default soft değeri 1024, 
    hard değeri ise 1048576 biçimindedir. Biz bu limitin soft değerini değiştirdiğimizde kendi prosesimizin dosya betimleyici 
    tablosunu otomatik olarak büyütmüş olmaktayız. Ayrıca fork yaptığımız proseslerin de artık dosya betimleyici tabloları büyümüş
    olacaktır. Linux'ta tüm proseslerin dosya betimleyici tablolarının uzunlukları toplamı için de bir kısıt vardır. Bu kısıt 
    Linux'ta proc dosya sistemindeki /proc/sys/fs/file-max dosyasında belirtilmiştir. Güncel çekirdeklerde buradaki değer 
    9223372036854775807 biçiminde aşırı derecede büyüktür. Prosesin hard limiti olan 1048576 değeri de aslında proc dosya sistemi 
    ile değiştirilebilmektedir. Bunun için proc dosya sistemindeki /proc/sys/fs/nr_open dosyası kullanılmaktadır. Bu dosyadaki değeri 
    aşağıdaki gibi bir komutla değiştirebilirsiniz:

    $ sudo sh -c "echo 20 > /proc/sys/fs/mqueue/msg_max"

    Anımsanacağı gibi bu bilgi aynı zamanda sysconf fonksiyonundan da elde edilebilmektedir.

    - RLIMIT_NPROC: Belli bir kullanıcının yaratabileceği maksimum proses sayısıdır. Anımsanacağı gibi Linux sistemlerinde 
    thread'ler için de task_struct yapısı ayrılmaktadır. Bu nedenle buradaki limitler Linux sistemlerinde thread'leri de 
    kapsamaktadır. Yani biz thread yarattıkça da bu limite doğru ilerlemiş oluruz. Mevcut sistemlerde bu limitin hard ve 
    soft değerleri default olarak 15070 biçimindedir.

    Anımsanacağı gibi bu bilgi aynı zamanda sysconf fonksiyonundan da elde edilebilmektedir.

    - RLIMIT_RTPRIO: Bu limit uygun önceliğe sahip olmayan SCHED_FIFO ve SCHED_RR proseslerin önceliklerini sınırlandırmak için 
    kullanılmaktadır. (Anımsanacağı gibi bu çizelgeleme politikalarına sahip proseslerin Linux'taki öncelikleri [0, 99] arasında 
    olabiliyordu). Bu limitin Linux'taki default hard ve soft değerleri 0 biçimindedir.

    - RLIMIT_SIGPENDING: Gerçek zamanlı sinyallerdeki kuyruk uzunluğunu belirtmektedir. Bu limitin Linux'taki default hard ve soft 
    değerleri mevcut çekirdeklerde 15070 biçimindedir.

    - RLIMIT_STACK: Bir thread'in stack uzunluğunu sınırlandırmak için kullanılmaktadır. Linux'ta default durumda thread'lerin 
    stack uzunlukları 8 MB'dir. Bu limitin Linux'taki default soft değeri 8 MB, hard değeri ise RLIM_INFINITY biçimindedir. 
    (Yani biz thread yaratırken stack uzunluğunu bu soft limiti yukarı çekmeden artıramayız, ancak düşürebiliriz.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux'ta limitlerin hard ve soft değerlerini kalıcı bir biçimde değiştirebilmek için /etc/security/limits.conf dosyası 
    bulundurulmuştur. Örneğin bu dosya sayesinde biz sistem açıldığında prosesimizin dosya betimleyici tablosunun default 
    uzunluğunun (soft limitini) istediğimiz bir değerde olmasını sağlayabiliriz. Bu dosyanın formatı için man sayfalarına 
    başvurabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosesin kaynak kullanımlarını elde etmek için getrusage isimli bir POSIX fonksiyonu bulundurulmuştur. Fonksiyonun 
    prototipi şöyledir:

    #include <sys/resource.h>

    int getrusage(int who, struct rusage *r_usage);

    Fonksiyonun birinci parametresi kaynak bilgilerinin elde edileceği prosesleri belirtmektedir. İkinci parametresi kaynak 
    bilgilerinin yerleştirileceği yapı nesnesinin adresini almaktadır. Bu yapıda Linux'a özgü bazı elemanlar da vardır. 
    Ayrıntıları için ilgili dokümanlara başvurabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sonraki konuya yardımcı olması için UNIX türevi sistemlerin dosya sistemlerinde kullandığı i-node yapısı üzerinde durmak 
    istiyoruz.

    Biz daha önce dosya betimleyici tablosundaki slotların "dosya nesnesi" denilen yapı nesnelerini gösterdiğini belirtmiştik. 
    Dosya nesneleri Linux kaynak kodlarında "struct file" yapısıyla temsil edilmektedir. Daha önceki modelimiz şöyleydi:

    Proses Kontrol Blok
    ...
    ---------------------------->   Dosya Betimleyici Tablosu
    ...                             0
                                    1
                                    2
                                    3 --------------------------------> Dosya Nesnesi
                                    4
                                    ...

    İşte diskteki dosya için o dosya kullanılmaya başlandığı zaman işletim sistemi aynı zamanda i-node isimli bir nesne 
    oluşturmaktadır. i-node nesnesi farklı prosesler aynı dosya dosyayı açsalar bile o dosya için toplamda bir tanedir. 
    i-node nesnesi içerisinde tipik olarak bizim stat fonksiyonlarıyla elde ettiğimiz bilgiler bulunmaktadır. (Örneğin fstat
    fonksiyonu hiç disk işlemi yapmadan bilgileri doğrudan bu i-node nesnesinin içerisinden almaktadır.) Burada anahtar nokta
    toplamda bir dosya için işletim sisteminin sistem genelinde tek bir i-node nesnesi oluşturmasıdır. Çünkü i-node nesneleri
    işletim sisteminin diskte tek olan dosya bilgilerini yerleştirdiği nesnelerdir. O dosya diskte tek olduğuna göre o dosya 
    bilgilerinin çekirdek tarafından bellekteki temsili de tek olmalıdır. Tabii modern işletim sistemleri dosyalara ilişkin 
    bu i-node elemanlarını bir cache sistemi içerisinde tutmaktadır. Yani bir dosya artık hiçbir proses tarafından kullanılmıyor 
    olsa da o dosyanın bilgileri i-node cache içerisinde bulunuyor olabilir. Linux i-node nesneleri için LRU (Least Recently Used)
    stratejisine sahip bir cache sistemi kullanmaktadır. Bu durumda yukarıdaki şeklin daha gerçekçi biçimi aşağıdaki gibi olabilir:

        Proses Kontrol Blok
    ...
    ---------------------------->   Dosya Betimleyici Tablosu
    ...                             0
                                    1
                                    2
                                    3 --------------------------------> Dosya Nesnesi ------> i-node nesnesi
                                    4
                                    ...

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kursumuzun bu bölümünde birden fazla prosesin aynı dosyaya erişim yaptığı durumlardaki problemleri ve bu problemlerin 
    nasıl çözülmesi gerektiği üzerinde duracağız. Bu konuya genel olarak işletim sistemlerinde "dosya kilitleme (file locking)"
    de denilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İki prosesin aynı anda, aynı dosyanın, aynı bölümü üzerinde işlem yaptığını düşünelim. Bu durumda ne olur? Örneğin bir 
    proses dosyanın belli bir kısmına write fonksiyonu ile yazma yaparken diğer bir proses aynı kısımdan, aynı anda read 
    fonksiyonu ile okuma yapmak istese bir problem oluşur mu? İşte UNIX türevi sistemlerde read ve write işlemleri sistem 
    genelinde atomik işlemlerdir. Yani işletim sistemi read ve write işlemlerini sıraya sokarak onların biri tamamen bitince 
    diğeri işleme sokulacak biçimde yapmaktadır. Bu nedenle bir proses, dosyanın belli bir bölümüne yazma yaparken diğer bir 
    proses de aynı dosyanın, aynı bölümünden okuma yapıyorsa; okuyan proses ya yazan prosesin yazmış olduğu değeri okur ya da 
    dosyadaki yazma işleminden önceki değeri okur. Karışık bir değer okumaz. Yani read ve write işlemleri iç içe geçmemektedir. 
    POSIX standartları bunu garanti etmektedir. Benzer biçimde iki proses de aynı dosyanın aynı bölümüne yazma yapmak istese,
    dosyada ya birinin ya da diğerinin yazdığı gözükecektir. Karışık bir bilgi (yani biraz birinin, biraz ötekinin yazdığı değer)
    gözükmeyecektir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Veritabanı yönetim sistemleri ya da veritabanı kütüphaneleri bir dosyaya birbirleriyle ilgili birden fazla read ve 
    write işlemi yapabilmektedir. Örneğin şöyle bir senaryo düşünelim. Siz bir dosyanın belli bir yerine bir bilgi yazmak 
    isteyin, ancak o bilginin hash değeri de dosyanın başka bir yerine yazılacak olsun. Burada birbiriyle uyumlu iki farklı write 
    işlemi söz konusudur. Siz birinci write işlemini yaptıktan sonra henüz ikinci write işlemini yapmadan başka bir proses 
    bu iki write işlemini hızlı davranıp yaparsa, siz ikinci write işlemini yaptığınızda artık yazdığınız hash değeri ile 
    asıl bilgi uyumsuz hale gelecektir. İşte veritabanı uygulamalarında bu biçimdeki işlemler çok yoğun yapılmaktadır. 
    Veritabanı programı bir dosyaya önce kaydı yazıp sonra dosyanın başka bir yerine onun indeks bilgisini yazabilmektedir. 
    Bu bilginin tutarlı olması gerekmektedir. Özetle tek bir read ve write sistem genelinde atomiktir, ancak birden fazla read ve 
    write için böyle bir durum söz konusu değildir. Bu tür problemlerin çözümü için akla gelen ilk yöntem senkronizasyon nesnelerini
    kullanmaktır. Örneğin proses iki write işlemi öncesinde mutex nesnesini kilitler ve iki write işlemi bittiğinde kilidi açar. 
    Diğer prosesler de aynı mutex nesnesini aynı biçimde kullanır. Tabii burada mutex nesnesinin prosesler arasında kullanılabiliyor 
    olması gerekmektedir. Ancak bu çözüm hem yorucu hem de yavaş bir çözümdür. İşte bu tür problemler için "dosya kilitleme"
    denilen mekanizmalar kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dosya kilitleme bütünsel olarak ve offset temelinde (yani dosyanın bir bölümünü kapsayacak biçimde) yapılabilmektedir. Bütünsel 
    dosya kilitleme kullanışlı değildir ve seyrek uygulanmaktadır. Offset temelinde dosya kilitleme de kendi içerisinde ikiye 
    ayrılmaktadır: İsteğe bağlı kilitleme (advisory lock) ve zorunlu kilitleme (mandatory lock). Biz bu bölümde önce bütünsel 
    kilitlemeyi daha sonra offset temelinde kilitlemeyi ele alacağız. Bütünsel kilitleme adeta mutex benzeri bir senkronizasyon 
    nesnesi ile dosyaya tüm ulaşımı engelleyecek bir mekanizma oluşturmaktadır. Offset temelinde kilitlemede dosyanın yalnızca 
    istenilen bölümleri kilitlenmekte, diğer bölümleri üzerinde işlemler yapılabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bütünsel dosya kilitleme için Linux sistemlerinde flock isimli fonksiyon kullanılmaktadır. flock fonksiyonu ilk kez BSD 
    sistemlerinde gerçekleştirilmiştir. POSIX standartlarında bulunmamaktadır. Fonksiyonun prototipi şöyledir:

    #include <sys/file.h>

    int flock(int fd, int operation);

    Fonksiyonun birinci parametresi bütünsel olarak kilitlenecek dosyaya ilişkin betimleyiciyi belirtmektedir. İkinci parametre 
    kilitlemenin nasıl yapılacağını belirtir. İkinci parametre şunlardan biri olabilir:

    LOCK_SH: Okuma için kilidi alma
    LOCK_EX: Yazma için kilidi alma
    LOCK_UN: Kilidi bırakma

    Bu değerlerden biri ayrıca LOCK_NB (non-blocking) değeri ile de bit OR işlemine sokulabilmektedir. Buradaki mekanizma 
    "reader-writer lock" mekanizmasına benzemektedir. Yani dosyaya birden fazla proses read işlemi yapabilir. Ancak bir proses 
    write yapıyorsa diğerlerinin işlem bitene kadar beklemesi sağlanmalıdır. Buradaki LOCK_SH (shared lock) okuma eylemi için 
    erişme anlamına gelmektedir. LOCK_EX ise yazma işlemi için erişmek anlamına gelir. LOCK_UN kilitlemeyi kaldırmaktadır. Bu 
    durumda dosyaya yazma amaçlı erişilecekse önce LOCK_EX ve işlem bitince de LOCK_UN uygulanmalıdır. Dosyaya okuma amaçlı 
    erişilecekse önce LOCK_SH ve işlem bitince de LOCK_UN uygulanmalıdır. Fonksiyon başarı durumunda 0 değerine, başarısızlık 
    durumunda -1 değerine geri dönmektedir.

    Proseslerden bir dosyanın değişik yerlerine tutarlı bir biçimde yazma yapacak olsun. Kodunu şöyle organize etmelidir (kontroller
    yapılmamıştır):

    flock(fd, LOCK_EX);

    /* yazma işlemleri */

    flock(fd, LOCK_UN);

    Bu durumda diğer bir proses flock fonksiyonunu LOCK_SH ya da LOCK_EX ile çağırdığında blokede bekler. Ta ki bu proses 
    flock fonksiyonunu LOCK_UN ile çağırana kadar. Dosyadan okuma yapacak proses de kodunu şöyle organize etmelidir:

    flock(fd, LOCK_SH);

    /* okuma işlemleri */

    flock(fd, LOCK_UN);

    Bu durumda başka bir proses de aynı dosyaya flock fonksiyonunu LOCK_SH ile çağırarak erişmek istese bloke oluşmaz. Ancak 
    bir proses dosyaya flock fonksiyonunu LOCK_EX ile çağırarak erişmeye çalışırsa blokede bekler. Ta ki bu proses LOCK_UN 
    yapana kadar. Mekanizma tamamen daha önce görmüş olduğumuz reader-writer lock senkronizasyon nesnesindeki gibidir.

    Bu biçimdeki kilitler alt prosese fork işlemi sırasında da geçirilmektedir ve exec işlemi sırasında bu kilitler korunmaktadır. 
    Kilit bilgisi dosya nesnesinin içerisinde saklanmaktadır. Dolayısıyla birden fazla kez open fonksiyonu çağrılarak elde edilmiş 
    olan dosya betimleyicilerinden biri ile kilit alındığında diğer betimleyici bu kilidi almamış gibi olmaktadır. Ancak aynı dosya 
    nesnesini gösteren betimleyici ile birden fazla kez flock fonksiyonu çağrılırsa bu durumda ikinci flock birincinin etkisini 
    kaldırır ve yeni etki oluşur.

    Bütünsel lock işlemi uygulanırken LOCK_NB bayrağı da kullanılırsa bu durumda uyuşmayan lock işlemleri blokeye yol açmaz. 
    Fonksiyon başarısız olur ve errno değeri EWOULDBLOCK biçiminde set edilir.

    Eğer kilit hiç açılmazsa kilidin ilişkin olduğu dosya nesnesine ilişkin son betimleyici kapatıldığında kilit otomatik olarak 
    açılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                87. Ders 07/10/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Offset temelinde dosya kilitleme işlemleri yukarıda da belirttiğimiz gibi kendi aralarında "isteğe bağlı (advisory)" ve 
    "zorunlu (mandatory)" olmak üzere ikiye ayrılmaktadır. Offset temelinde lock işlemleri fcntl fonksiyonu ile gerçekleştirilmektedir. 
    fcntl fonksiyonu bir dosya betimleyicisi ile bazı özel işlemler yapmakta kullanılan genel bir fonksiyondu. Biz bu fonksiyonu
    daha önce tanıtmıştık. Fonksiyonun prototipi şöyleydi:

    #include <fcntl.h>

    int fcntl(int fd, int cmd, ...);

    Fonksiyon iki argümanla ya da üç argümanla çağrılmaktadır. İkinci parametreye komut parametresi denilmektedir. Üçüncü 
    parametrenin anlamı ikinci parametredeki komuta göre değişmektedir.

    Offset temelinde kilitleme için kilitlenecek dosyayı temsil eden bir dosya betimleyicisi olmalıdır (birinci parametre). 
    fcntl fonksiyonunun ikinci parametresine F_SETLK, F_SETLKW ya da F_GETLK değerlerinden biri girilir. Üçüncü parametresine 
    ise her zaman flock isimli bir yapı nesnesinin adresi girilmelidir. F_SETLK ve F_SETLKW komutlarında bu flock yapı
    nesnesinin içi programcı tarafından doldurulmalıdır. Ancak F_GETLK komutunda bu yapı nesnesinin içi fonksiyon tarafından 
    doldurulmaktadır. flock yapısı şöyle bildirilmiştir:

    struct flock {
        short l_type;
        short l_whence;
        off_t l_start;
        off_t l_len;
        pid_t l_pid;
    };

    Bu yapı nesnesinin elemanları pid dışında programcı tarafından doldurulur. l_type elemanı kilitlemenin cinsini belirtir. 
    Bu elemana F_RDLCK, F_WRLCK, F_UNLCK değerlerinden biri girilmelidir. Yapının l_whence elemanı offset için orijini belirtmektedir. 
    Bu elemana da SEEK_SET (0), SEEK_CUR (1) ya da SEEK_END (2) değerleri girilmelidir. l_start elemanı kilitlenecek bölgenin 
    başlangıç offset'ini l_len ise uzunluğunu belirtmektedir. l_pid, F_GETLK komutu tarafından doldurulmaktadır. Yapının l_type elemanının
    kilidin türünü belirttiğini söylemiştik. Bu tür tıpkı thread senkronizasyonu konusunda görmüş olduğumuz "okuma-yazma kilitleri 
    (reader-writer lock)" gibi işlem görmektedir. Yani biz belli bir bölgeye F_WRLCK ile kilit yerleştirirsek bu durum "bizim o bölgeye
    başkalarının okuma ya da yazma yapmasını istemediğimiz" anlamına gelmektedir. Biz belli bir bölgeye F_RDLCK ile kilit yerleştirirsek
    bu durum da "bizim o bölgeye başkalarının yazma yapmasını istemediğimiz ancak okuma yapmalarına izin verdiğimiz" anlamına gelmektedir. 
    F_UNLCK ise bizim o bölgedeki kilidi kaldırmak istediğimiz anlamına gelmektedir. Bu kilit türlerini şöyle özetleyebiliriz:

    F_WRLCK: Başkaları yazma da okuma da yapmamalı
    F_RDLCK: Başkaları okuma yapabilir ancak yazma yapmamalı
    F_UNLCK: Bu bölgedeki kilit kaldırılmak isteniyor

    l_len değeri 0 ise bu l_start değerinden itibaren dosyanın sonuna ve ötesine kadar kilitleme anlamına gelmektedir. (Bu durumda
    örneğin lseek ile dosya göstericisi EOF ötesine konumlandırılsa bile kilit geçerli olmaktadır.) Yani yapının l_len elemanı 0
    olarak girilirse dosya ne kadar büyütülürse büyütülsün tüm büyütülen alanlar da kilitli olacaktır.

    Pekiyi fcntl fonksiyonunun ikinci parametresindeki F_SETLK, F_SETLKW ve F_GETLK komutları ne anlama gelmektedir? F_SETLK blokesiz, 
    F_SETLKW blokeli kilitleme yapmaktadır. Blokesiz kilitlemede "çelişen (incompatible)" kilitleme isteklerinde thread bloke olmaz,
    ancak fcntl fonksiyonu başarısız olur. Blokeli kilitlemede ise çelişen (incompatible) kilitleme isteklerinde thread bloke olur. 
    Ta ki bu çelişki ortadan kaldırılana kadar. Örneğin biz bir dosyanın 100 ile 110 offset'leri arasını F_WRLCK türü ile F_SETLK 
    komutunu kullanarak kilitlemek isteyelim. Eğer bu bölge başka bir proses tarafından F_RDLCK ya da F_WRLCK türü ile kilitlenmişse
    kilitleme başarısız olur ve fcntl fonksiyonu -1 değeri ile geri döner. Ancak biz aynı bölgeyi F_SETLKW ile blokeli kilitlemek 
    istersek bu durumda çelişkili bir kilitleme isteği söz konusu olduğu için thread bloke olur. Ta ki bu çelişki giderilene kadar. 
    (Yani kilidi yerleştiren proses onu kaldırana kadar.) Özetle F_SETLK ile çelişkili kilit yerleştirilmek istenirse fcntl başarısız 
    olmakta, ancak F_SETLKW ile çelişkili kilit yerleştirilmek istenirse fcntl blokeye yol açmaktadır. Genellikle uygulamalarda F_SETLKW 
    kullanılmaktadır.

    Yukarıda da belirttiğimiz gibi F_SETLK ile bir bölgeyi kilitlemek isteyen proses eğer bu alan başka bir proses tarafından çelişki 
    yaratacak biçimde kilitlenmişse fcntl fonksiyonu başarısız olur ve -1 değerine geri döner. Bu durumda errno değişkeni EACCES 
    ya da EAGAIN değerlerinden biri ile set edilmektedir.

    Aynı proses kendisinin yerleştirmiş olduğu bir kilidin türünü değiştirebilir. Bu durumda bir çelişkiye bakılmamaktadır. Yani 
    örneğin biz bir dosyanın belli bölgesine bir F_WRLCK yerleştirmiş olabiliriz. Sonra bunu F_RDLCK ile yer değiştirebiliriz. 
    Bu işlem atomik düzeyde yapılmaktadır.

    F_GETLK komutu için de programcının flock nesnesini oluşturmuş olması gerekir. Bu durumda fcntl bu alanın isteğe bağlı biçimde
    kilitlenip kilitlenmeyeceğini bize söyler. Yani bu durumda fcntl kilitleme yapmaz ama sanki yapacakmış gibi duruma bakar. 
    Eğer çelişki yoksa fcntl yalnızca yapının l_type elemanını F_UNLCK haline getirir. Eğer çelişki varsa bu çelişkiye yol açan 
    kilit bilgilerini yapı nesnesinin içerisine doldurur. Fakat o alan birden farklı biçimlerde kilitlenmişse bu durumda
    fcntl bu kilitlerin herhangi birinin bilgisini bize verecektir. Örneğin kilit durumunu öğrenmek istediğimiz bölgede ayrık
    iki farklı kilit bulunuyor olabilir. Bu tür durumlarda fcntl fonksiyonu bu kilit bilgilerinin herhangi birini bize vermektedir.

    fcntl ile offset temelinde konulmuş olan kilitler fork işlemi sırasında alt prosese aktarılmazlar. Yani üst prosesin 
    kilitlemiş olduğu alanlar alt proses tarafından da kilitlenmiş gibi olmazlar. (Halbuki flock fonksiyonu ile bütünsel 
    kilitlemelerin fork işlemi sırasında alt prosese aktarıldığını anımsayınız.) exec işlemleri sırasında offset temelindeki 
    kilitlemeler varlığını devam ettirmektedir.

    Dosyanın kilit bilgileri dosyanın diskteki varlığı üzerine kaydedilmemektedir. İşletim sisteminin çekirdek içerisinde 
    oluşturduğu i-node elemanının içerisinde kaydedilmektedir. Dolayısıyla aynı dosyayı açmış olan prosesler aynı i-node 
    nesnesini gördükleri için aynı kilit bilgilerine sahip olurlar. Genellikle UNIX türevi işletim sistemleri kilit 
    bilgilerini i-node nesnesi içerisinde bir bağlı listede proses id'lere göre sıralı bir biçimde tutmaktadır.

    Prosesin yerleştirmiş olduğu bir kilit o proses tarafından kilit türü F_UNLCK yapılarak kaldırılabilmektedir. Ancak en kötü 
    olasılıkla ilgili dosya kapatıldığında o prosesin o dosya üzerinde yerleştirmiş olduğu kilitler de kaldırılmaktadır. Burada 
    önemli bir nokta bir dosya betimleyicisi dup yapıldığında onlardan herhangi biri close ile kapatılırsa kilidin kaldırılacağıdır. 
    Yani kilidin kaldırılması için bir betimleyicinin close edilmesi yeterli olmaktadır. Benzer biçimde aynı proses, aynı dosyayı 
    ikinci kez açtığı durumda, onlardan herhangi biri close işlemi yaptığında kilit kaldırılmaktadır. Proses biterken zaten 
    betimleyiciler üzerinde close işlemleri yapılacağı için o prosesin açmış olduğu dosyalar üzerinde yerleştirdiği kilitler de 
    ortadan kaldırılacaktır.

    Prosesin dosyaya F_WRLCK kilidi yerleştirebilmesi için dosyanın yazma modunda, F_RDLCK kilidi koyabilmesi için ise dosyanın 
    okuma modunda açılmış olması gerekir.

    Offset temelinde kilitlemede "deadlock" oluşumuna dikkat edilmelidir. Yani biz bir prosesin kilidi açmasını beklerken o 
    proses de bizim başka bir kilidi açmamızı bekliyorsa burada bir "deadlock" durumu söz konusudur. İşte deadlock durumu 
    fcntl fonksiyonu tarafından otomatik olarak tespit edilmektedir. Eğer bir proses F_SETLKW ile (F_SETLK ile değil) kilit 
    koymak isterken bir "deadlock" durumu söz konusu ise fcntl başarısız olmakta ve errno değeri EDEADLK değeri ile set edilmektedir.

    Kilitlenmek istenen bölgede birden fazla ayrık kilit bulunuyor olabilir. Bu durumda kilitlemenin yapılabilmesi için bu 
    ayrık kilitlerin hiçbirinde bir çelişkinin olmaması gerekir. Aksi takdirde F_SETLK komutunda fcntl başarısız olur, F_SETLKW 
    komutunda ise fcntl blokeye yol açar. Yani kilitleme işlemi "yap hep ya hiç" biçiminde yapılmaktadır.

    Bir bölgenin belli bir kilit türüyle kilitlenmiş olduğunu varsayalım. Aynı proses bu bölgenin bir alt bölgesini başka 
    bir kilit türüyle kilitleyebilir ya da o alt bölgenin kilidini kaldırabilir. Bu durumda işletim sistemi otomatik olarak 
    kilitleri birbirinden ayıracaktır. Örneğin:

    WWWWWWWWWWWWWWWWWWWWW

    Bu bölgenin F_WRLCK ile kilitlenmiş olduğunu düşünelim. Biz bu bölgenin ortasında bir bölgenin kilidini F_RDLCK olarak 
    değiştirelim:

    WWWWWWWWWRRRRRWWWWWWW

    Burada artık üç kilit bölgesi oluşmaktadır. Kilidin kaldırılması eğer kilidi koyan proses tarafından yapılıyorsa her zaman 
    başarılı olmaktadır. Yani biz yukarıdaki üç bölgenin kilidini tek bir F_UNLCK ile kaldırabiliriz. Kilitlenmemiş bölgeye 
    F_UNLCK uygulansa bile fcntl fonksiyonu başarısız olmamaktadır.

    Pekiyi fcntl fonksiyonunun başarısı nasıl kontrol edilmelidir. Eğer kilitleme F_SETLK fonksiyonu ile yapılıyorsa EACCES
    ve EAGAIN değerleri test edilmelidir. Mesajlar bu durumlar için özel olarak verilmesi daha iyi bir tekniktir. Eğer kilitleme 
    F_SETLKW ile yapılıyorsa EDEADLK değeri de test edilmelidir. Örneğin:

    if (fcntl(fd, F_SETLK, &fl) == -1) {
        if (errno == EACCES || errno == EAGAIN) {
            fprintf(stderr, "lock failed!...\n");
            ...
        }
        else
            exit_sys("fcntl");
    }

    Ya da örneğin:

    if (fcntl(fd, F_SETLKW, &fl) == -1) {
        if (errno == EDEADLK) {
            fprintf(stderr, "deadlock danger!...\n");
            ...
        }
        else
            exit_sys("fcntl");
    }

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda kilitleme işlemlerini test etmek için "flock-test.c" isimli örnek bir program verilmektedir. Bu programı çalıştırırken
    komut satırı argümanı olarak kilitlemeye konu olacak dosyanın yol ifadesi verilmelidir. Örneğin:

    $ ./flock-test test.txt

    Program aşağıdaki gibi bir prompt'a düşmektedir:

    CSD (55306)>

    Parantezler içerisinde prosesin proses id'si bulunmaktadır. Buraya kullanıcı komutlar girerek fcntl ile kilit yerleştirebilir. 
    Girilecek komutların biçimi şöyle olmalıdır:

    <fcntl command code> <lock type> <starting offset> <length>

    Örneğin:

    CSD (55306)>F_SETLK F_RDLCK 0 64

    Bu komutla fcntl fonksiyonu ile "test.txt" dosyasının 0 offset'inden 64 byte uzunluktaki bölgeye F_RDLCK yerleştirilmek 
    istenmiştir. Yerleştirme işlemi blokeye yol açmayan F_SETLK komut kodu ile yapılacaktır. Aynı programı başka bir terminalden 
    girerek çalıştırmalısınız. Örneğin:

    CSD (55377)>F_SETLK F_WRLCK 0 64
    Locked failed!..

    F_GETLK komutunda aslında kilit türünün belirtilmesi gereksizdir. Ancak buradaki programı kısaltmak için kullanılmayacak olsa 
    da bir kilit türünü yine belirtmek zorundayız. Örneğin:

    CSD (55471)>F_GETLK F_RDLCK 0 64
    Write Lock
    Whence: 0
    Start: 0
    Length: 64
    Process Id: 55469

    Komutun ikinci argümanı aslında program tarafından kullanılmamaktadır. Ancak girilmek zorundadır.

    Programdan çıkmak için komut satırına "quit" yazılabilir.

    Bu programı kllanarak F_SETLKW komutuyla blokeli işlemleri de deneyiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* fclock-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define MAX_CMDLINE        4096
#define MAX_ARGS        64

void parse_cmd(void);
int get_cmd(struct flock *fl);
void disp_flock(const struct flock *fl);
void exit_sys(const char *msg);

char g_cmd[MAX_CMDLINE];
int g_count;
char *g_args[MAX_ARGS];

int main(int argc, char *argv[])
{
    int fd;
    pid_t pid;
    char *str;
    struct flock fl;
    int fcntl_cmd;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    pid = getpid();

    if ((fd = open(argv[1], O_RDWR)) == -1)
        exit_sys("open");

    for (;;) {
        printf("CSD (%ld)>", (long)pid), fflush(stdout);
        fgets(g_cmd, MAX_CMDLINE, stdin);
        if ((str = strchr(g_cmd, '\n')) != NULL)
            *str = '\0';
        parse_cmd();
        if (g_count == 0)
            continue;
        if (g_count == 1 && !strcmp(g_args[0], "quit"))
            break;
        if (g_count != 4) {
            printf("invalid command!\n");
            continue;
        }

        if ((fcntl_cmd = get_cmd(&fl)) == -1) {
            printf("invalid command!\n");
            continue;
        }

        if (fcntl(fd, fcntl_cmd, &fl) == -1)
            if (errno == EACCES || errno == EAGAIN)
                printf("Locked failed!...\n");
            else
                perror("fcntl");
        if (fcntl_cmd == F_GETLK)
            disp_flock(&fl);
    }

    close(fd);

    return 0;
}

void parse_cmd(void)
{
    char *str;

    g_count = 0;
    for (str = strtok(g_cmd, " \t"); str != NULL; str = strtok(NULL, " \t"))
        g_args[g_count++] = str;
}

int get_cmd(struct flock *fl)
{
    int cmd, type;

    if (!strcmp(g_args[0], "F_SETLK"))
        cmd = F_SETLK;
    else if (!strcmp(g_args[0], "F_SETLKW"))
        cmd = F_SETLKW;
    else if (!strcmp(g_args[0], "F_GETLK"))
        cmd = F_GETLK;
    else
        return -1;

    if (!strcmp(g_args[1], "F_RDLCK"))
        type = F_RDLCK;
    else if (!strcmp(g_args[1], "F_WRLCK"))
        type = F_WRLCK;
    else if (!strcmp(g_args[1], "F_UNLCK"))
        type = F_UNLCK;
    else
        return -1;

    fl->l_type = type;
    fl->l_whence = SEEK_SET;
    fl->l_start = (off_t)strtol(g_args[2], NULL, 10);
    fl->l_len = (off_t)strtol(g_args[3], NULL, 10);

    return cmd;
}

void disp_flock(const struct flock *fl)
{
    switch (fl->l_type) {
        case F_RDLCK:
            printf("Read Lock\n");
            break;
        case F_WRLCK:
            printf("Write Lock\n");
            break;
        case F_UNLCK:
            printf("Unlocked (can be locked)\n");
    }

    printf("Whence: %d\n", fl->l_whence);
    printf("Start: %ld\n", (long)fl->l_start);
    printf("Length: %ld\n", (long)fl->l_len);
    if (fl->l_type != F_UNLCK)
        printf("Process Id: %ld\n", (long)fl->l_pid);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi dosya kilitleme mekanizmasından nasıl faydalanılacaktır? Örneğin biz aynı dosyanın iki bölgesi üzerinde birbirleriyle 
    ilgili iki güncelleme yapmak isteyelim. Tipik olarak bunun için önce iki bölgeyi kilitleriz. Sonra güncellemeleri yaparız. 
    Sonra da kilitleri açarız. Örneğin (kontroller yapılmamıştır):

    fcntl(fd, F_SETLKW, &region1);        /* F_WRLCK */
    fcntl(fd, F_SETLKW, &region2);        /* F_WRLCK */

    write(fd, region1, size1);
    write(fd, region2, size2);

    fcntl(fd, F_SETLKW, &region1);        /* F_UNLCK */
    fcntl(fd, F_SETLKW, &region2);        /* F_UNLCK */

    Şimdi belli bir kaydın bir elemanını değiştirmek isteyelim:

    fcntl(fd, F_SETLKW, &region);        /* F_WRLCK */

    read(fd, buf, elem_size);
    <update işlemi>
    write(fd, buf, elem_size);

    fcntl(fd, F_SETLKW, &region);        /* F_UNLCK */
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir programın tek bir kopyasının çalışması istenebilmektedir. Örneğin program bir kaynak kullanıyor olabilir. Programın 
    kullandığı kaynak sistem genelinde tek olabilir. Ya da programın birden fazla kopyasının çalıştırılması tasarım bakımından 
    anomalilere yol açıyor da olabilir. Bunu sağlamak için kayıt kilitleme mekanizması kullanılabilmektedir. Program çalışmaya 
    başladığında bir dosyayı bütünsel olarak kilitlemeye çalışır. Eğer kilitleme başarısız olursa programın başka bir kopyasının 
    çalışıyor olduğu sonucuna varılır. Aslında bu işlem isimli senkronizasyon nesneleriyle de yapılabilmektedir. Örneğin Windows
    sistemlerinde bunun için dosya kilitleme mekanizması yerine "isimli mutex nesneleri" tercih edilmektedir. Ancak UNIX/Linux
    sistemlerindeki geleneksel yaklaşım dosya kilitleme mekanizmasının kullanılmasıdır.

    Aşağıda programın tek bir kopyasının çalışmasını sağlayan basit bir örnek verilmiştir. Bu örnekte proses dosyayı bütünsel 
    olarak "exclusive" bir biçimde kilitlemeye çalışmıştır. Dosya kapatıldığında zaten kilit de ortadan kalkmaktadır. Burada 
    flock fonksiyonunda LOCK_NB bayrağını da kullandık. Çünkü bu tür durumlarda bloke oluşmasının engellenmesi gerekmektedir. 
    Bu yöntemde içi boş bir dosyanın yaratılmış olduğuna dikkat ediniz. Bu tür dosyaların "/temp" dizini içerisinde yaratılması 
    da sık karşılaşılan bir uygulamadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/file.h>

#define LOCK_FILE_PATH        "lock.dat"

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open(LOCK_FILE_PATH, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR)) == -1)
        exit_sys("open");

    if (flock(fd, LOCK_EX|LOCK_NB) == -1)
        if (errno == EWOULDBLOCK) {
            fprintf(stderr, "only one instance of this program can run...\n");
            exit(EXIT_FAILURE);
        }
        else
            exit_sys("flock");

    sleep(10);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda "isteğe bağlı (advisory)" kilitleme işlemi yaptık. Burada "isteğe bağlı (advisory)" demekle aslında read/write 
    fonksiyonlarının bu kilitlere hiç bakmaması anlatılmak istenmiştir. Örneğin biz dosyanın bir bölgesine F_WRLCK ile bir 
    kilit yerleştirelim. Başka bir proses o bölgeye write ile yazma yapabilir. Tabii dosya erişen ilgili programların hepsi
    birbirleriyle koordineli yazıldığı için onlar da read/write yapmadan önce aynı kilit mekanizmasını kullanarak senkronizasyon 
    sağlamaktadır. Özetle "isteğe bağlı kilitleme (advisory locking)" demekle read/write fonksiyonlarının bakmadığı, fcntl 
    fonksiyonunun baktığı kilit anlaşılmaktadır. Pekiyi "zorunlu (mandatory)" kilit sistemi nedir? Zorunlu kilitlemede read/write 
    fonksiyonları kilitlere bakarak çalışmaktadır. Yani örneğin biz bir bölgeye F_WRLCK ile zorunlu kilit yerleştirmişsek o 
    bölgeden read işlemi ya da o bölgeye write işlemi yapıldığında bu fonksiyonlar otomatik blokeye yol açmakta ya da başarısız 
    olmaktadır. Uygulamada "isteğe bağlı (advisory) kilitleme" çok daha yoğun kullanılmaktadır. Çünkü zorunlu kilitlemede read/write 
    fonksiyonlarının her defasında kilitlere bakması (kilitler konulmamış bile olsa) zaman kaybına yol açmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi zorunlu (mandatory) kilitleme nasıl uygulanmaktadır? İsteğe bağlı kilitleme ile zorunlu kilitlemenin uygulanış biçimi 
    arasında hiçbir farklılık yoktur. Kilitleme isteğe bağlı mı yoksa zorunlu mu olduğu "mount parametrelerine" ve "dosyanın erişim 
    haklarına" bakılarak belirlenmektedir.

    Zorunlu kilitleme kavramı POSIX standartlarında bulunmamaktadır. POSIX standartları fcntl fonksiyonunun açıklamasında bunun 
    gerekçelerini belirtmiştir. Zaten bazı işletim sistemleri zorunlu kilitlemeyi hiç desteklememektedir. Linux 2.4 çekirdeği 
    ile birlikte zorunlu dosya kilitlemesini destekler hale gelmiştir. Yukarıda da belirttiğimiz gibi zorunlu kilitleme için aslında 
    fcntl fonksiyonunda ek bir şey yapılmaz. Linux'ta zorunlu kilitleme için şu koşulların sağlanmış olması gerekmektedir:

    1) Dosyanın içinde bulunduğu dosya sisteminin -o mand ile mount edilmiş olması gerekir. Mevcut mount edilmiş olan bir dosya 
    sisteminin mount parametreleri aşağıdaki gibi değiştirilebilir:

    $ sudo mount -o mand,remount <device> <mount point>

    Hangi dosya sisteminin "mand" parametresi ile mount edileceğini tespit etmeniz gerekir. Bunun için df komutunu argümansız 
    biçimde kullanabilirsiniz. Örneğin:

    $ df
    Dosyasistemi    1K-blok     Dolu      Boş Kull% Bağlanılan yer
    udev            1471368        0  1471368    0% /dev
    tmpfs            303552     1364   302188    1% /run
    /dev/sda5      81526200 41496476 35845404   54% /
    tmpfs           1517748        4  1517744    1% /dev/shm
    tmpfs              5120        4     5116    1% /run/lock
    tmpfs           1517748        0  1517748    0% /sys/fs/cgroup
    /dev/sda1        523248        4   523244    1% /boot/efi
    tmpfs            303548      104   303444    1% /run/user/1000

    mount parametrelerini görebilmek için mount komutunu parametresiz olarak kullanabilirsiniz. Ancak burada karşınıza uzun 
    bir liste çıkabilir. grep utility'si ile ilgili satırı görüntüleyebilirsiniz. Örneğin:

    $ mount | grep /dev/sda5
    /dev/sda5 on / type ext4 (rw,relatime,mand,errors=remount-ro)

    Aslında mount komutu bu bilgileri /proc/mounts dosyasından elde etmektedir. Örneğin:

    $ sudo mount -o mand,remount /dev/sda5 /

    Sistem açıldığında ilgili dosya sisteminin "mand" parametresi ile mount edilebilmesi için bazı start-up dosyaları 
    kullanabilirsiniz. Örneğin /etc/fstab dosyası bu amaçla kullanılabilmektedir.

    2) İlgili dosyanın set-group-id bayrağı set edilip gruba x hakkı varsa reset edilmelidir. Bu işlem şöyle yapılmalıdır:

    $ chmod g+s,g-x <dosya>

    Örneğin:

    $ chmod g+s,g-x test.txt

    Bir dosyanın bir proses tarafından zorunlu kilitlenmiş olması dosyanın silinmesini engellememektedir. Dosyanın truncate 
    ve ftruncate fonksiyonu ile genişletilmesi ya da budanması işleminde zorunlu kilitleme mekanizması devreye girmektedir. 
    Yani bu fonksiyonlar sanki dosyaya yazma yapıyormuş gibi etki göstermektedir. Benzer biçimde örneğin dosyaya zorunlu 
    kilit konulmuşsa dosya O_TRUNC modunda açılamamaktadır. Ancak yukarıda belirttiğimiz gibi dosya remove ya da unlink 
    fonksiyonlarıyla üzerinde zorunlu kilit olsa bile silinebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                88. Ders 08/10/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda zorunlu kilitlemeyi test etmek için bir örnek hazırlanmıştır. Bu örnekte iki program vardır. "flock-test.c" 
    programı yukarıdaki programın aynısıdır. "rw-test.c" programı ise belli bir dosyanın belli bir offset'inden belli miktarda
    okuma ya da yazma yapan bir programdır. "flock-test.c" programını yukarıda açıklamıştık. "rw-test.c" programının komut 
    satırı argümanları şöyledir:

    $ ./rw-test <dosya ismi> <r|w> <offset> <uzunluk>

    Burada "r" okuma, "w" ise yazma yapma anlamına gelmektedir. Örneğin:

    $ ./rw-test test.txt w 60 10

    Bu çalıştırmayla program write fonksiyonu ile "test.txt" dosyasına 60'ıncı offset'inden itibaren 10 byte yazacaktır. Örneğin:

    $ ./rw-test test.txt r 0 64

    Burada da program "test.txt" dosyasının 0'ıncı offset'inden 64 byte okuyacaktır.

    Aşağıdaki örneği test yaparken şu biçimde kullanabilirsiniz: Önce "flock-test" programı ile dosyanın belli bir bölgesine kilit 
    yerleştiriniz. Sonra "rw-test" programı ile ilgili offset'i kapsayan bölgeden okuma/yazma yapmaya çalışınız. read ve write 
    fonksiyonlarındaki blokeyi gözlemleyiniz. Sonra kilidi kaldırınca fonksiyonların blokeden çıkacağını göreceksiniz. Tabii 
    örnekte test işleminde kullanacağınız dosyanın (örneğin "test.txt") yukarıda belirttiğimiz gibi zorunlu kilitlemeye 
    hazırlanmış olması gerekir.

    Zorunlu kilitleme uygulanmış bir dosya open fonksiyonu ile O_NONBLOCK bayrağı kullanılarak açılmışsa (normal dosyaların 
    bu bayrak kullanılarak açılması genellikle işlevsizdir, ancak burada bir istisna vardır) bu durumda read/write fonksiyonları
    çelişkili kilitle karşılaştığında bloke olmazlar ve başarısızlıkla (-1 değeriyle) geri dönerler. Bu durumda errno değeri 
    EAGAIN (Resource temporarily unavailable) değeri ile set edilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* flock-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define MAX_CMDLINE        4096
#define MAX_ARGS        64

void parse_cmd(void);
int get_cmd(struct flock *fl);
void disp_flock(const struct flock *fl);
void exit_sys(const char *msg);

char g_cmd[MAX_CMDLINE];
int g_count;
char *g_args[MAX_ARGS];

int main(int argc, char *argv[])
{
    int fd;
    pid_t pid;
    char *str;
    struct flock fl;
    int fcntl_cmd;
F_SETLKW"wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    pid = getpid();

    if ((fd = open(argv[1], O_RDWR)) == -1)
        exit_sys("open");

    for (;;) {
        printf("CSD (%ld)>", (long)pid), fflush(stdout);
        fgets(g_cmd, MAX_CMDLINE, stdin);
        if ((str = strchr(g_cmd, '\n')) != NULL)
            *str = '\0';
        parse_cmd();
        if (g_count == 0)
            continue;
        if (g_count == 1 && !strcmp(g_args[0], "quit"))
            break;
        if (g_count != 4) {
            printf("invalid command!\n");
            continue;
        }

        if ((fcntl_cmd = get_cmd(&fl)) == -1) {
            printf("invalid command!\n");
            continue;
        }

        if (fcntl(fd, fcntl_cmd, &fl) == -1)
            if (errno == EACCES || errno == EAGAIN)
                printf("Locked failed!...\n");
            else
                perror("fcntl");
        if (fcntl_cmd == F_GETLK)
            disp_flock(&fl);
    }

    close(fd);

    return 0;
}

void parse_cmd(void)
{
    char *str;

    g_count = 0;
    for (str = strtok(g_cmd, " \t"); str != NULL; str = strtok(NULL, " \t"))
        g_args[g_count++] = str;
}

int get_cmd(struct flock *fl)
{
    int cmd, type;

    if (!strcmp(g_args[0], "F_SETLK"))
        cmd = F_SETLK;
    else if (!strcmp(g_args[0], "F_SETLKW"))
        cmd = F_SETLKW;
    else if (!strcmp(g_args[0], "F_GETLK"))
        cmd = F_GETLK;
    else
        return -1;

    if (!strcmp(g_args[1], "F_RDLCK"))
        type = F_RDLCK;
    else if (!strcmp(g_args[1], "F_WRLCK"))
        type = F_WRLCK;
    else if (!strcmp(g_args[1], "F_UNLCK"))
        type = F_UNLCK;
    else
        return -1;

    fl->l_type = type;
    fl->l_whence = SEEK_SET;
    fl->l_start = (off_t)strtol(g_args[2], NULL, 10);
    fl->l_len = (off_t)strtol(g_args[3], NULL, 10);

    return cmd;
}

void disp_flock(const struct flock *fl)
{
    switch (fl->l_type) {
        case F_RDLCK:
            printf("Read Lock\n");
            break;
        case F_WRLCK:
            printf("Write Lock\n");
            break;
        case F_UNLCK:
            printf("Unlocked (can be locked)\n");
    }

    printf("Whence: %d\n", fl->l_whence);
    printf("Start: %ld\n", (long)fl->l_start);
    printf("Length: %ld\n", (long)fl->l_len);
    if (fl->l_type != F_UNLCK)
        printf("Process Id: %ld\n", (long)fl->l_pid);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* rw-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

/* ./rwtest <dosya ismi> <r/w> <offset> <uzunluk> */

int main(int argc, char *argv[])
{
    int fd;
    int operation;
    off_t offset;
    off_t len;
    char *buf;
    ssize_t result;

    if (argc != 5) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (strcmp(argv[2], "r") && strcmp(argv[2], "w")) {
        fprintf(stderr, "invalid operation!\n");
        exit(EXIT_FAILURE);
    }

    offset = (off_t)strtol(argv[3], NULL, 10);
    len = (off_t)strtol(argv[4], NULL, 10);

    if ((buf = (char *)calloc(len, 1)) == NULL) {
        fprintf(stderr, "cannot allocate memory!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], argv[2][0] == 'r' ? O_RDONLY : O_WRONLY)) == -1)
        exit_sys("open");

    lseek(fd, offset, SEEK_SET);
    if (argv[2][0] == 'r') {
        if ((result = read(fd, buf, len)) == -1)
            exit_sys("read");
        printf("%ld bytes read\n", (long)result);
    }
    else {
        if ((result = write(fd, buf, len)) == -1)
            exit_sys("write");
        printf("%ld bytes written\n", (long)result);
    }

    free(buf);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Dosyalardaki kilitleri izlemek için proc dosya sistemindeki /proc/locks dosyasından faydalanılabilmektedir. Örneğin:

    $ cat /proc/locks
    1: POSIX  ADVISORY  WRITE 34561 08:05:4194918 0 EOF
    2: POSIX  MANDATORY WRITE 57926 08:05:1207498 0 63
    3: POSIX  ADVISORY  READ 34560 00:36:103 0 EOF
    4: POSIX  ADVISORY  READ 34560 08:05:3031150 0 EOF
    5: POSIX  ADVISORY  READ 34560 08:05:3050341 0 EOF
    6: FLOCK  ADVISORY  WRITE 705 00:19:673 0 EOF

    Buradaki ilk sütun kilidin hangi fonksiyonlarla konulduğunu belirtmektedir. Bu sütunda POSIX belirteci kilidin fcntl ya da 
    lockf fonksiyonu ile konulduğunu belirtir. flock fonksiyonu Linux'a özgü olduğu için burada LINUX belirteci ile görüntülenecektir. 
    İkinci sütun kilidin isteğe bağlı mı zorunlu mu olduğunu belirtmektedir. Üçüncü sütun ise kilidin türünü belirtmektedir. 
    Dördüncü sütun kilidi koyan prosesin proses id'sini belirtmektedir. Sonraki sütun ':' karakterleriyle ayrılmış üç alandan 
    oluşmaktadır. İlk iki alan dosyanın içinde bulunduğu aygıtın majör ve minör numaralarını belirtmektedir. Üçüncü alanda 
    kilit uygulanan dosyanın i-node numarası belirtilmektedir. Sonraki iki sütunda da kilidin başlangıç offset'i ve uzunluğu
    belirtilmektedir.

    UNIX/Linux sistemlerinde dosyanın yol ifadesinden hareketle stat, fstat, lstat fonksiyonlarıyla biz dosyanın i-node
    numarasını elde edebiliriz. Ancak bunun tersini yapan bir mekanizma yoktur. Bu işlem ancak find utility'si ile arama 
    yöntemiyle yapılabilir. Örneğin:

    $ find / -inum 1207498 2> /dev/null

    Burada find utility'sine biz i-node numarası 1207498 olan dizin girişlerini kökten itibaren özyinelemeli biçimde aratmaktayız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dosya kilitleme için POSIX standartlarında lockf isimli bir fonksiyon da bulundurulmuştur. Bu fonksiyon aslında yukarıda 
    görmüş olduğumuz fcntl fonksiyonuna sarma yapan bir fonksiyondur. lockf fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    int lockf(int fd, int function, off_t size);

    Fonksiyonun birinci parametresi dosya betimleyicisini, ikinci parametresi uygulanacak lock işleminin türünü, üçüncü 
    parametresi ise kilitlenecek alanının uzunluğunu belirtmektedir. Fonksiyonda başlangıç offset'inin olmadığına dikkat ediniz.
    Fonksiyon her zaman dosya göstericisinin gösterdiği yerden itibaren kilitleme yapmaktadır. İkinci parametrede belirtilen 
    kilit türü şunlardan biri olabilir:

    Kilit Türü        fcntl Karşılığı            Anlamı

    F_ULOCK            F_SETLK, F_UNLCK        Kilidi kaldırır
    F_LOCK            F_SETLK, F_WRLCK        Blokesiz yazma kilidi yerleştirir
    F_TLOCK            F_SETLKW, F_WRLCK        Blokeli yazma kilidi yerleştirir
    F_TEST            F_GETLK                    Kilidin yerleştirilmiş olup olmadığına bakar

    Görüldüğü gibi fonksiyon her zaman "yazma (yani "exclusive")" bir kilit yerleştirmektedir. Dolayısıyla bu fonksiyon fcntl 
    fonksiyonuna göre daha yeteneksizdir. Programcılar tarafından pek tercih edilmemektedir.

    Fonksiyonun üçüncü parametresi 0 geçilirse bu durum "bulunulan offset'ten dosya sonuna kadar ve daha sonraki eklemeleri 
    kapsayacak biçimde" kilit yerleştirilmesi anlamına gelir. Eğer F_ULOCK işleminde bu parametre 0 girilirse bulunulan offset'ten 
    itibaren sonraki bütün kilitler kaldırılmaktadır. Fonksiyonun uzunluk belirten size parametresi negatif de girilebilir. 
    Bu durumda dosya göstericisinin gösterdiği yerden geriye doğru alan kilitlenir. Fonksiyon başarı durumunda 0 değerine, 
    başarısızlık durumunda -1 değerine geri dönmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar proc dosya sistemindeki bazı dosyaları hedefe yönelik biçimde gördük. Şimdi proc dosya sistemini 
    genel olarak ele almak istiyoruz. proc dosya sistemi disk tabanlı bir dosya sistemi değildir. Bu dosya sistemi bellek 
    tabanlıdır. Genellikle bu dosya sistemindeki bilgiler çekirdek modülleri ve aygıt sürücüler tarafından talep edildiğinde
    verilmektedir. proc dosya sistemi standart bir dosya sistemi değildir. Dolayısıyla bu dosya sistemi POSIX standartlarında 
    belirtilmemiştir. Linux gibi bazı UNIX türevi sistemler bu dosya sistemini desteklerken bazıları desteklememektedir. 
    (Örneğin macOS sistemleri proc dosya sistemini desteklememektedir.) proc dosya sistemi boot işlemi sırasında "/proc" dizinine 
    mount edilmektedir.

    proc dosya sistemindeki dosyaların ve dizinlerin listesi alındığında sanki onların uzunlukları "0" imiş gibi rapor edilmektedir. 
    Bunun nedeni bu dizindeki dosyaların içeriklerinin talep edildiğinde oluşturulmasıdır. Örneğin:

    $ ls -l /proc

    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 1
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 10
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 100
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 1001
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 1003
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 101
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 102
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 103
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 105
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 107
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 108
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 11
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 110
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 111
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 112
    ...

    proc dosya sistemi içerisinde dizinler ve dosyalar bulunmaktadır. Bu dizinlerin ve dosyaların nasıl oluşturulduğu aygıt 
    sürücülerin ele alındığı bölümde açıklanmaktadır.

    proc dosya sistemi çekirdeğin ve aygıt sürücülerin birtakım bilgileri dış dünyaya iletmesini basit bir biçimde sağlamaktadır. 
    Bu dosya sistemi sayesinde biz sistemde ne olup bittiğini buradaki dosyaların içeriklerini okuyarak anlayabiliriz. Gerçekten 
    de pek çok UNIX/Linux komutu aslında çekirdeğe ilişkin birtakım bilgileri bu dosya sisteminden elde etmektedir. Örneğin 
    "ps" komutu ile sistemdeki proseslerin bilgilerini elde edebiliyorduk. Aslında "ps" komutu bu bilgileri proc dosya sistemindeki
    dosyalardan elde etmektedir. Biz bazı konularda bazı bilgileri elde etmek için bu proc dosya sistemindeki birtakım dosyaları 
    kullanmıştık. proc dosya sistemindeki dosyaların bazıları yazmaya da izin vermektedir. Eğer sistem yöneticisi bu dosyalarda
    değişiklik yaparsa çekirdek ve aygıt sürücüler bu değişiklikleri dikkate alıp çalışmasını bu değişikliklere göre ayarlayabilmektedir.
    proc dosya sistemi içerisindeki dosyalar genel olarak "text dosyalar" biçimindedir. Yani bunların içeriklerini biz "cat" 
    komutuyla elde edebiliriz.

    proc dosya sisteminde iç içe pek çok dizin ve dosya bulunmaktadır. Biz burada bu dosya sisteminin genel içeriği hakkında 
    bazı bilgiler vereceğiz.

    proc dosya sisteminin kökünde (yani "/proc" dizininde) her proses için ayrı bir dizin yaratılmaktadır. Yaratılan dizinin 
    ismi prosesin id değeri biçimindedir. Yani örneğin biz bir programı çalıştırdığımızda yaratılan prosesin proses id'sine 
    ilişkin bir dizin "/proc" dizinin kökünde yaratılmaktadır:

    $ ./app
    press ENTER to exit...

    Şimdi yaratılan prosesin proses id'sine başka bir terminalden bakalım:

    $ ps -a
    PID TTY          TIME CMD
    16852 pts/0    00:00:00 app
    16854 pts/3    00:00:00 ps

    İşte çekirdek "/proc" dizininde "16852" ismiyle bir dizin yaratıp o ilgili prosesin tüm bilgilerini bu dizinin içerisine 
    yerleştirmektedir:

    $ ls -ld /proc/16852
    dr-xr-xr-x 9 kaan study 0 Ağu 27 13:40 /proc/16852

    Bu dizin içeriğini görüntülediğimizde aşağıdaki gibi bir dizin yapısıyla karşılaşmaktayız:

    $ ls /proc/16852
    arch_status  cmdline             environ  limits     mounts      oom_score      root       smaps_rollup  task
    attr         comm                exe      loginuid   mountstats  oom_score_adj  sched      stack         timens_offsets
    autogroup    coredump_filter     fd       map_files  net         pagemap        schedstat  stat          timers
    auxv         cpu_resctrl_groups  fdinfo   maps       ns          patch_state    sessionid  statm         timerslack_ns
    cgroup       cpuset              gid_map  mem        numa_maps   personality    setgroups  status        uid_map
    clear_refs   cwd

    Buradaki girişlerin bazıları "dizin" bazıları da dosyadır. Buradaki bazı dizin ve dosyalar hakkında kısa açıklamalar yapalım:

    - fd dizini prosesin açmış olduğu dosyalara ilişkin bilgileri bulundurmaktadır. Örneğin:

    $ ls -l
    toplam 0
    lrwx------ 1 kaan study 64 Ağu 27 14:00 0 -> /dev/pts/0
    lrwx------ 1 kaan study 64 Ağu 27 14:00 1 -> /dev/pts/0
    lrwx------ 1 kaan study 64 Ağu 27 14:00 2 -> /dev/pts/0

    Burada dosyaların sembolik bağlantı dosyaları olduğuna dikkat ediniz.

    - fdinfo isimli dizin içerisinde açılmış dosyaların bazı önemli bilgileri bulundurulmaktadır.

    - environ isimli dosya prosesin çevre değişken listesini bize vermektedir.

    - cmdline isimli dosyada program çalıştırılırken kullanılan komut satırı argümanları bulunmaktadır.

    proc dosya sisteminin kök dizininde sisteme ilişkin bilgi veren pek çok dosya dosya bulunmaktadır. Burada bunların
    birkaçı üzerinde duralım:

    - version isimli dosya yüklü olan çekirdek ve dağıtım hakkında temel bilgileri vermektedir.

    - devices dosyası yüklü olan aygıt sürücüler hakkında bilgiler vermektedir.

    - modules isimli dosya yüklü olan çekirdek modülleri hakkında bilgiler vermektedir.

    proc dosya sistemi oldukça fazla dizine ve dosyaya sahiptir. Bazı dosyalar özel birtakım konularla ilgilidir. Dolayısıyla 
    bu dosyaların ve dizinlerin "konuya göre gerektikçe öğrenilmesi" yoluna gidilebilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar read/write fonksiyonlarıyla klasik IO işlemleri yaptık. UNIX/Linux sistemlerinde bloke durumlarında 
    kullanılabilecek alternatif IO modelleri de vardır. Bunlara "ileri IO (advanced IO)" de denilmektedir. Bu bölümde özellikle 
    client-server programların gerçekleştirilmesinde kullanılabilecek ileri IO modelleri üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi ileri IO işlemlerine neden gereksinim duyulmaktadır? Client-server bir sistem için bir server programı yazacak olalım. 
    Server program N tane client'tan gelen istekleri okusun ve onlara yanıt göndersin. Haberleşme ortamı isimli borularla ya da 
    sonraki bölümde göreceğimiz soketlerle yapılabilmektedir. Ancak isimli borulardan ve soketlerden okuma yapılırken eğer boruda
    ya da sokette hiçbir bilgi yoksa read fonksiyonu bloke olmaktadır. Bu nedenle böyle bir program aşağıdaki gibi bir döngüyle 
    yazılamamaktadır:

    for (;;) {
        for (int i = 0; i < N; ++i) {
            read(...);
            write(...);
        }
        ...
    }

    Burada bir client'ın borusunda ya da soketinde hiç bilgi yoksa read fonksiyonu blokeye yol açacak ve diğer client'lardan 
    gelen bilgiler işleme sokulamayacaktır. Tabii bu durum yalnızca borular ve soketler için değil, bloke yok açan diğer kaynaklar 
    için de söz konusudur. Bu tür durumlarda ilk akla gelen şey blokesiz modda işlem yapmak olabilir. Örneğin:

    for (;;) {
        for (int i = 0; i < N; ++i) {
            result = read(...);
            if (result == -1 && errno == EAGAIN)
                continue;
            write(...);
        }
        ...
    }

    Burada problem çözülmüş gibi gözükmekle birlikte aslında başka bir sorun oluşmaktadır. Eğer hiçbir client'tan bilgi gelmemişse 
    burada "meşgul bir döngü (busy loop)" oluşmaktadır. Bu tür durumlarda akla gelen en basit çözüm "thread ya da proses" modelini 
    kullanmaktadır. Tabii proses yaratımı, thread yaratımına göre çok daha maliyetli olduğu için thread modeli tercih edilmektedir. 
    Bu modelde her client için ayrı bir thread (ya da proses) oluşturulur. O client'ın istekleri o thread (ya da proses) tarafından 
    sağlanır. Böylece bir client'a bilgi gelmediği zaman yalnızca o thread (ya da proses) bloke olacaktır. Diğerlerinin çalışması 
    devam edecektir. Bu model basitliği nedeniyle az sayıda client'ın bulunduğu durumlarda uygun bir yöntemdir. Ancak ölçeklenebilir 
    (scalable) değildir. Yani client sayısı arttığında çok fazla sistem kaynağı kullanılacağından dolayı olumsuzluk ortaya çıkacaktır.
    İşte ileri IO modelleri temel olarak yukarıdaki tarzda problemleri çözmek için geliştirilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX sistemlerinde ileri IO işlemleri dört bölüme ayrılarak incelenebilir:

    1) Multiplexed IO: Bu modelde bir grup betimleyici izlemeye alınır. Bu betimleyicilerde ilgilenilen olay (read/write/error) 
    gerçekleşmemişse blokede beklenir. Ta ki bu betimleyicilerden en az birinde ilgilenilen olay gerçekleşene kadar. Multiplexed 
    IO için select ve poll POSIX fonksiyonları kullanılmaktadır. Ancak Linux epoll isimli daha yetenekli bir fonksiyona da sahiptir.

    2) Sinyal Tabanlı (Signal Driven) IO: Burada belli betimleyiciler izlemeye alınır. Ancak blokede beklenmez. Bu betimleyicilerde 
    olay gerçekleştiğinde SIGIO isimli sinyal oluşur. Programcı da bu sinyal oluştuğunda blokeye maruz kalmadan read/write 
    işlemini yapılabilir.

    3) Asenkron IO: Burada read/write işlemleri başlatılır. Ancak bir bloke oluşmaz. Arka planda çekirdek tarafından okuma 
    ve yazma bir yandan devam ettirilir. Ancak aktarım bittiğinde programcı bundan haberdar edilir. Bunun signal driven IO'dan 
    farkı şudur: Signal tabanlı IO'da aktarım yapılmamaktadır. Yalnızca okuma yazma yapılırsa bloke olunmayacağı prosese söylenmektedir. 
    Halbuki asenkron IO'da okuma ve yazma işlemi bloke çözüldüğünde arka planda gerçekleştirilmekte ve yalnızca işlemin bittiği 
    haber verilmektedir.

    4) Scatter-Gather IO: Burada okuma birden fazla adrese, yazma ise birden fazla adresten kaynağa yapılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Multiplexed IO işlemlerinde select ve poll isimli POSIX fonksiyonları ve Linux sistemlerinde de Linux sistemlerine özgü 
    epoll fonksiyonu kullanılmaktadır. select fonksiyonu çok eskiden beri var olan klasik fonksiyonlardan biridir. select ilk 
    kez BSD sistemlerinde gerçekleştirilmiştir. POSIX standartları oluşturulduğunda doğrudan standartlarda bulundurulmuştur. Aslında
    select fonksiyonunun tasarımında bazı kusurlar vardır. Ancak fonksiyon hala en çok kullanılan ileri IO fonksiyonlarındandır.
    select fonksiyonunun prototipi şöyledir:

    #include <sys/select.h>

    int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);

    Fonksiyonun parametrelerindeki fd_set türü bir bit dizisi belirtmektedir. Bu bit dizisinin belli bitini 1 yapmak için
    FD_SET, belli bitini 0 yapmak için FD_CLR, tüm bitlerini sıfır yapmak için FD_ZERO, belli bitini test etmek için ise 
    FD_ISSET makroları kullanılmaktadır. Biz fonksiyonun ikinci (readfds), üçüncü (writefds) ve dördüncü (errorfds) parametrelerine 
    bir grup betimleyiciyi o betimleyicilerin numaralarına karşı gelen bitleri 1 yaparak veririz. Örneğin biz 18, 23 ve 47 numaralı
    betimleyicilerle ilgilenmek isteyelim. Bunun için fd_set veri yapısının 18, 23 ve 47 numaralı bitlerini 1 yaparız. Fonksiyonun 
    ikinci parametresi (readfds) "okuma amaçlı izlenecek betimleyicilerin kümesini", üçüncü parametresi (writefds) "yazma 
    amaçlı izlenecek betimleyicilerin kümesini" ve dördüncü parametresi (errorfds) ise "hata (exception) oluşumu için izlenecek 
    betimleyicilerin kümesini" belirtmektedir. Bu parametrelerin biri ya da birden fazlası NULL geçilebilir. Bu durum ilgili 
    izlemenin yapılmayacağını belirtmektedir. Fonksiyonun birinci parametresi bu kümelerdeki en yüksek betimleyicinin bir fazla 
    değerini almaktadır. Bu parametre aslında işlemleri hızlandırmak için düşünülmüştür. En yüksek betimleyici değeri 
    FD_SETSIZE (1024) ile define edilmiş durumdadır. (Yani bu parametreye istersek doğrudan bu değeri de geçebiliriz.) Örneğin 
    biz 18, 23 ve 47 numaralı betimleyicileri izlemek istiyorsak bu birinci parametreye 48 değerini (47 + 1) girebiliriz. Ancak 
    buraya en yüksek betimleyici değeri olan FD_SETSIZE girilse de bir sorun oluşmayacaktır. Yukarıda da belirttiğimiz gibi 
    bu birinci parametre yalnızca işlemleri hızlandırmak için bir ipucu niteliğindedir.

    Fonksiyonun son parametresi "zaman aşımı" belirtmektedir. Zaman aşımı için NULL adres girilebilir. Bu durum zaman aşımının
    uygulanmayacağı anlamına gelir. timeval yapısını biz daha önce kullanmıştık. Anımsatmak istiyoruz:

    struct timeval {
        time_t        tv_sec;
        suseconds_t tv_usec;
    };

    Bu yapı mikrosaniye çözünürlüğünde bir zaman aralığı belirtmek için oluşturulmuştur. Yapının her iki elemanı 0'da girilebilir. 
    Bu durumda select fonksiyonu hemen testini yapar ve geri döner.

    select fonksiyonu ile bir grup betimleyiciyi okuma amaçlı izlemek isteyelim. İlk yapacağımız şey izlenecek betimleyicileri 
    bir fd_set nesnesi içerisinde belirtmek ve bu nesnesin adresini fonksiyonun ikinci parametresine vermektir. Birinci parametreye 
    de buradaki en yüksek betimleyici değerinin 1 fazlası geçirilecektir. Örneğin:

    fd_set rset;
    ...

    FD_ZERO(&rset);
    FD_SET(fd1, &rset);        // fd1 = 18 varsayalım
    FD_SET(fd2, &rset);        // fd2 = 23 varsayalım
    FD_SET(fd3, &rset);        // fd3 = 48 varsayalım

    maxfds = getmax(fd1, fd2, fd3);

    select(maxfds + 1, &rset, NULL, NULL, NULL);

    select fonksiyonu bizim ona verdiğimiz betimleyicileri okuma amaçlı izler. Bu betimleyicilere hiçbir bilgi gelmemişse select 
    akışı blokede bekletmektedir. Ancak bu betimleyicilerin en az birine bir bilgi geldiyse bu durumda select blokeyi çözmektedir. 
    Görüldüğü gibi select fonksiyonu "okunacak hiçbir bilgi betimleyicilerde oluşmamışsa akışı blokede bekletmekte ancak en az bir 
    betimleyicide okunacak bilgi oluşmuşsa okuma işleminin yapılması için blokeyi çözmektedir. select fonksiyonun okumayı yapmadığına 
    yalnızca okuma yapılabilecek bir durumun oluştuğunu tespit ettiğine dikkat ediniz. Tabii programıcının select'in blokesi 
    çözüldüğünde hangi betimleyicilere bilgi gelmiş olduğunu anlaması gerekir. Çünkü gelen bilgileri read ile o betimleyicilerden 
    okuyacaktır. Tabii select fonksiyonu aslında bir kez değil, genellikle bir döngü içerisinde kullanılmaktadır.

    Pekiyi select blokeyi çözdüğünde programcı ne yapmalıdır? Örneğin biz yine 18, 23 ve 48 numaralı betimleyicileri okuma amaçlı
    izlemek isteyelim. select fonksiyonu 23 numaralı betimleyiciye bilgi geldiğinden dolayı blokeyi çözmüş olsun. Bizim bunu 
    anlayıp 23 numaralı betimleyiciden read fonksiyonu ile (ya da soketler söz konusu ise recv ya da recvfrom fonksiyonları ile) 
    okuma yapmamız gerekir. İşte select bizim ona verdiğimiz fd_set nesnelerini çıkışta yeniden uygun biçimde set etmektedir. 
    Hangi betimleyicilerde ilgili olay gerçekleşmişse o betimleyicilere ilişkin bitleri set edip diğerlerini reset etmektedir. 
    Yani select bizim ona verdiğimiz fd_set nesnelerinin içeriğini bozup ilgili olayın gerçekleştiği betimleyicileri o nesnelerde 
    belirtmektedir. O halde bizim select fonksiyonu geri döndüğünde bu fd_set nesnelerinin bitlerine bakıp hangi betimleyiciye 
    ilişkin bitlerin set edildiğini anlamamız ve onlardan okuma yapmamız gerekir. select ile beklerken birden fazla betimleyicide 
    olayın gerçekleşmiş olabileceğine dikkat ediniz. Bu nedenle kontrolü else-if ile değil, ayrık if deyimleriyle yapmalısınız. 
    Aşağıdaki kod parçasında üç betimleyici select ile izlenmiş, select fonksiyonunun blokesi çözüldüğünde bu betimleyicilere ilişkin 
    bitler tek tek FD_ISSET makrosu ile kontrol edilmiştir. Hangi betimleyicide okuma olayı gerçekleşmişse read fonksiyonu ile o 
    betimleyiciden okuma yapılmıştır. Bu noktada artık read fonksiyonunun blokeye yol açmayacağına dikkat ediniz.

    fd_set rset;
    ...

    FD_ZERO(&rset);
    FD_SET(fd1, &rset);        // fd1 = 18 varsayalım
    FD_SET(fd2, &rset);        // fd2 = 23 varsayalım
    FD_SET(fd3, &rset);        // fd3 = 48 varsayalım

    maxfds = getmax(fd1, fd2, fd3);

    if (select(maxfds + 1, &rset, NULL, NULL, NULL) == -1)
        exit_sys("select");

    if (FD_ISSET(fd1, &rset)) {
        result = read(fd1, ...);
        ...
    }
    if (FD_ISSET(fd2, &rset)) {
        result = read(fd2, ...);
        ...
    }
    if (FD_ISSET(fd3, &rset)) {
        result = read(fd3, ...);
        ...
    }

    Programcı select yoluyla çok sayıda betimleyiciyi izliyorsa select çıkışında onlar için ayrı if deyimleriyle kontrol yapmak 
    yorucu olabilmektedir. Bu durumda iki yol izlenebilir. Birincisi tüm betimleyicileri bir döngü içerisinde kontrol etmektir:

    ...
    if (select(maxfds + 1, &rset, NULL, NULL, NULL) == -1)
        exit_sys("select");

    for (int fd = 0; fd <= maxfds; ++fd)
        if (FD_ISSET(fd, &rset)) {
            result = read(fd, ...);
            ...
        }

    Burada 0'dan maxfds değerine kadar rset nesnesindeki tüm bitlere bakılmış ve set edilen bitlere ilişkin betimleyicilerden 
    okuma yapılmıştır. İkinci yöntem, izlenecek betimleyicileri aynı zamanda bir diziye yerleştirmektir. Örneğin:

    fd_set rset;
    int fds[3];
    ...

    fds[0] = fd1;
    fds[1] = fd2;
    fds[2] = fd3;
    ...
    FD_ZERO(&rset);

    for (int i = 0; i < 3; ++i)
        FD_SET(fds[i], &rset);

    maxfds = getmax(fds, 3);

    if (select(maxfds + 1, &rset, NULL, NULL, NULL) == -1)
        exit_sys("select");

    for (int i = 0; i < 3; ++i)
        if (FD_ISSET(fds[i], &rset)) {
            result = read(fds[i], ...);
            ...
        }

    Burada izlenecek betimleyicilerin numaraları fds dizisine yerleştirilmiştir. select geri döndüğünde yalnızca fds dizisindeki 
    betimleyicilere ilişkin bitler FD_ISSET makrosuyla kontrol edilmiştir.

    Yukarıda da belirttiğimiz gibi select fonksiyonu genel olarak bir döngü içerisinde kullanılmaktadır. Fonksiyonu döngü 
    içerisinde kullanırken bizim ona verdiğimiz fd_set kümesinin bozulacağına, dolayısıyla döngünün başında onun yeniden yüklenmesi 
    gerektiğine dikkat ediniz. Örneğin:

    fd_set rset, orset;
    ...

    FD_ZERO(&rset);
    FD_SET(fd1, &rset);        // fd1 = 18 varsayalım
    FD_SET(fd2, &rset);        // fd2 = 23 varsayalım
    FD_SET(fd3, &rset);        // fd3 = 48 varsayalım

    maxfds = getmax(fd1, fd2, fd3);

    for (;;) {
        orset = rset;
        if (select(maxfds + 1, &orset, NULL, NULL, NULL) == -1)
            exit_sys("select");

        if (FD_ISSET(fd1, &orset)) {
            read(fd1, ...);
        }
        if (FD_ISSET(fd2, &orset)) {
            read(fd2, ...);
        }
        if (FD_ISSET(fd3, &orset)) {
            read(fd3, ...);
        }
    }

    Burada her döngünün başında izlemenin yapılacağı rset nesnesi orset (output rset) nesnesine atanmıştır. Böylece her defasında 
    orset izlenmesi gereken betimleyicileri belirtmektedir. İki fd_set nesnesi birbirine atanabilmektedir. (fd_set türü tipik 
    olarak bir yapı biçiminde oluşturulmuştur. İki yapı nesnesi birbirine atandığında karşılıklı elemanların atanacağına dikkat 
    ediniz.)

    Pekiyi boru, soket gibi betimleyicilerden select eşliğinde okuma yapılırken karşı taraf bu betimleyicileri kapatırsa ne olacaktır?
    İşte bu durumda select fonksiyonu sanki o betimleyicide "okuma" olayı varmış gibi davranmaktadır. Örneğin boruyu karşı taraf 
    kapattığında select fonksiyonu okuma olayı gerçekleşmiş gibi geri döner, biz de read fonksiyonu ile 0 byte okuruz ve artık
    karşı tarafın boruyu kapatmış olduğunu anlarız.

    select ile çok sayıda betimleyiciyi izlerken bu betimleyicileri karşı taraf kapattığında biz de read fonksiyonu ile bunu 
    anladığımızda artık betimleyiciyi okuma kümesinden çıkartmamız gerekir.

    select fonksiyonu başarısızlık durumunda -1 değerine geri döner. Eğer hiçbir betimleyicide olay gerçekleşmemiş, ancak zaman 
    aşımı dolmuşsa fonksiyon 0 değerine geri dönmektedir. Eğer en az bir betimleyicide ilgili olay gerçekleşmişse select fonksiyonu 
    bu durumda toplam gerçekleşen olay sayısına geri dönmektedir. (Aynı betimleyici örneğin hem okuma hem de yazma için izleniyorsa 
    ve bu betimleyicide hem okuma hem de yazma olayı gerçekleşmişse bu değer 2 artırılmaktadır.) Fonksiyonun geri dönüş değeri 
    genellikle programcılar tarafından kullanılmamaktadır.

    select fonksiyonunun normal disk dosyaları için kullanılması anlamsızdır. Eğer select normal disk dosyaları için kullanılırsa 
    select her zaman olay gerçekleşmiş gibi geri dönecektir. select fonksiyonu uzun süre beklemeye yol açabilecek terminal 
    gibi, boru gibi, soket gibi aygıtlar için kullanılmalıdır. Normal olarak select ile beklenecek betimleyicilere ilişkin 
    kaynaklar "blokeli" modda açılmalıdırlar. select blokeyi kendisi uygulamaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                89. Ders 14/10/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda select fonksiyonunun kullanımına basit bir örnek verilmiştir. Bu örnekte select ile stdin dosyası (0 numaralı
    betimleyici) okuma amaçlı izlenmektedir. Klavyeden giriş yapılıp ENTER tuşuna basıldığında select blokeyi çözmekte ve 
    read ile artık bloke olmadan okuma yapılabilmektedir. select fonksiyonunun tek bir betimleyici için kullanılmasının 
    bir anlamı yoktur. Bu örnek yalnızca select fonksiyonunun kullanımını ana hatlarıyla açıklamak için verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/select.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    fd_set rset, orset;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;

    FD_ZERO(&rset);
    FD_SET(0, &rset);

    for (;;) {
        orset = rset;
        if (select(0 + 1, &orset, NULL, NULL, NULL) == -1)
            exit_sys("select");

        if (FD_ISSET(0, &orset)) {
            if ((result = read(0, buf, BUFFER_SIZE)) == -1)
                exit_sys("read");
            if (result == 0)
                break;

            buf[result] = '\0';
            printf("%s", buf);
        }
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir grup betimleyici select fonksiyonu ile izlenirken karşı taraf ilgili betimleyiciyi kapatırsa ne olacaktır? Örneğin 
    biz select fonksiyonu ile isimli boruları ya da soketleri izleyebiliriz. Böylece borunun ya da soketin karşı tarafındakilerin
    yazdıklarını etkin bir biçimde elde edebiliriz. Pekiyi ya karşı taraf boruyu ya da soketi kapatırsa ne olacaktır. İşte
    yukarıda da belirttiğimiz gibi karşı taraf boru ya da soketi kapattığında select sanki "okuma" olayı oluşmuş gibi davranır. 
    Biz de bunu read fonksiyonu ile anlarız (read bu durumda 0 ile geri dönecektir). Böylece kendi betimleyicimizi kapatıp 
    ilgili betimleyiciyi de izleme listesinden çıkartırız.

    Aşağıdaki örnekte program komut satırı argümanlarıyla aldığı isimli boruları okuma amacıyla select fonksiyonuyla izlemektedir. 
    İsimli boruların O_RDONLY modda açılması sırasında karşı taraf boruyu O_WRONLY modunda (ya da O_RDWR modunda) açana kadar
    open fonksiyonunun blokeye yol açtığını anımsayınız. Bu programı kullanırken önce mkfifo komutuyla isimli boruları yaratmalısınız. 
    Örneğin:

    $ mkfifo x y Z

    Burada x, y ve z isimli boruları yaratılacaktır. Daha sonra programı bu isimli boruların yol ifadeleriyle çalıştırmalısınız. 
    Örneğin:

    $ ./sample x y z

    Artık bu isimli borular açıldığında program bir döngü içerisinde select fonksiyonunda bekleyecektir. Bu borulardan herhangi 
    birine yazma yapıldığında select blokesi çözülecek ve artık program o borudan okuma yapacaktır. Bütün borular kapatıldığında
    program sonlandırılmaktadır.

    Aşağıdaki programı test etmek için en pratik yöntem başka terminaller açarak cat programını borulara yönlendirerek çalıştırmaktır. 
    Örneğin:

    $ cat > x

    Artık klavyeden bir şeyler yazıp ENTER tuşuna bastığımızda cat onu boruya yazacaktır. cat programından Ctrl+D tuşu ile 
    çıkabilirsiniz. Tabii aslında cat programı Ctrl+C ile sinyal yoluyla sonlandırılsa da bir sorun oluşmayacaktır. Bir 
    proses nasıl sonlanırsa sonlansın işletim sistemi o prosesin açmış olduğu dosyaları kapatmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/select.h>

#define BUFFER_SIZE        4096
#define MAX_SIZE        4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    fd_set rset, orset;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;
    int fds[MAX_SIZE];
    int maxfd;
    int count;

    if (argc == 1) {
        fprintf(stderr, "too few arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("opens named pipes... it may block...\n");

    FD_ZERO(&rset);

    maxfd = -1;
    for (int i = 1; i < argc; ++i) {
        if ((fds[i] = open(argv[i], O_RDONLY)) == -1)
            exit_sys("open");
        printf("%s opened...\n", argv[i]);
        if (fds[i] > maxfd)
            maxfd = fds[i];

        FD_SET(fds[i], &rset);
        ++count;
    }

    for (;;) {
        orset = rset;
        printf("waiting at select...\n");
        if (select(maxfd + 1, &orset, NULL, NULL, NULL) == -1)
            exit_sys("select");

        for (int i = 0; i <= maxfd; ++i)
            if (FD_ISSET(fds[i], &orset)) {
                if ((result = read(fds[i], buf, BUFFER_SIZE)) == -1)
                    exit_sys("read");
                if (result == 0) {
                    printf("peer closed descriptor...\n");
                    close(fds[i]);
                    FD_CLR(fds[i], &rset);
                    --count;

                    if (count == 0)
                        goto EXIT;
                }

                buf[result] = '\0';
                printf("%s", buf);
            }
    }
EXIT:

    printf("there is no descriptor open, finishes...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    select fonksiyonu en çok okuma amaçlı izlemede kullanılmaktadır. Pekiyi yazma amaçlı izleme nedir? İşte bazı aygıtlar 
    yazma sırasında da blokeye yol açabilmektedir. Örneğin biz borulara write fonksiyonu ile yazma yaptığımızda eğer boru
    tamamen doluysa boruda yer açılana kadar blokede bekleriz. Ancak bu bizim diğer borulara yazma yapmamızı engelleyebilir. 
    O zaman biz select fonksiyonunu yazma izlemesi için de kullanabiliriz. Örneğin select fonksiyonuna biz üç boru betimleyicisini
    yazma izlemesi için vermiş olalım. select boruda yer açılınca blokeyi çözecek ve yazma yapılabilecek betimleyicileri yine
    okumadaki gibi set edecektir. Biz de okumadakine benzer bir biçimde hangi boruda boşluk oluştuysa ona yazma yaparız. 
    (Borularda tüm bilgi boruya yazılana kadar bloke oluşmaktadır. select az bir byte yazabilme durumunda blokeyi çözmektedir. 
    Tabii okuyan taraf da aynı miktar bilgiyi okuyorsa burada yine sorun çıkmayacaktır.) Benzer biçimde soketlere yazma yapılırken 
    yazılan bilgiler önce network tamponuna yazılmaktadır. Eğer bu tampon doluysa yine bloke oluşmaktadır. Görüldüğü gibi 
    okumadaki benzer bloke problemi yazmada da ortaya çıkabilmektedir.

    Borularda önce yazan tarafın boruyu kapatması gerekmektedir. Ancak okuyan taraf boruyu kapatırsa yazan taraf boruya 
    yazma yaptığında SIGPIPE sinyalinin oluştuğunu anımsayınız. select fonksiyonunda okuyan taraf boruyu kapatırsa yazma
    takibinde sanki bir yazma olayı varmış gibi durum oluşmaktadır. Tabii bu durumda select geri dönünce yazma yapılırsa yine 
    SIGPIPE sinyali oluşturulacaktır. Aynı durum aslında soketlerde de söz konusudur.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    select fonksiyonunun dördüncü parametresi olan "errorfds" ne anlama gelmektedir?

    int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);

    Bu parametre programcılar tarafından genellikle yanlış anlaşılmaktadır. İsminden dolayı sanki betimleyicide bir hata 
    izlemesinin yapılacağı sanılmaktadır. Oysa bu parametre çok kısıtlı bir kullanıma sahiptir. Borularda bu parametrenin 
    bir etkisi yoktur. Soketlerde ise "out of band data" oluştuğunda bir etkisi olmaktadır. Yani bu parametre bulunuyor 
    olsa da önemli bir kullanıma sahip değildir. Dolayısıyla genellikle NULL geçilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    select fonksiyonunun son parametresi zaman aşımı belirtmektedir. Zaman aşımı "en kötü olasılıkla blokenin ne kadar süreceğini"
    belirtir. select eğer zaman aşımından dolayı sonlanırsa 0 değerine geri dönmektedir. Bu zaman aşımı parametresi NULL geçilirse
    bu durum herhangi bir zaman aşımının uygulanmayacağı anlamına gelir. Linux sistemlerinde bu zaman aşımı parametresi girilirse
    çıkışta bu elemana "kalan zaman" set edilmektedir. Ancak POSIX standartları bu davranışı garanti etmemektedir.

    select fonksiyonundaki zaman aşımı parametresi mikrosaniye duyarlılığındadır. Ancak pek çok işletim sistemi bu duyarlılıkta 
    işlem yapamamaktadır. timeval yapısını yeniden anımsatmak istiyoruz:

    struct timeval {
        time_t      tv_sec;            /* seconds */
        suseconds_t tv_usec;        /* microseconds */
    };

    Eskiden UNIX türevi sistemlerde yüksek çözünürlüklü bekleme yapan nanosleep ve clock_nanosleep fonksiyonları yoktu. 
    Programcılar da bu amaçla select fonksiyonunu kullanabiliyordu. Eğer select fonksiyonunun izleme parametrelerinin hepsine
    NULL geçilirse ancak zaman aşımı parametresine belli bir süre girilirse fonksiyon sanki mikrosaniye duyarlılığına sahip 
    sleep gibi çalışmaktadır. Tabii buradaki duyarlılık sistemlerde sağlanamayabiliyordu. Örneğin:

    struct timeval tv;
    ...

    tv.tv_sec = 3;
    tv.tv_usec = 500000;

    printf("waiting at sleep for 3.5 second...\n");

    if (select(0, NULL, NULL, NULL, &tv) == -1)
        exit_sys("select");
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/select.h>

void exit_sys(const char *msg);

int main(void)
{
    struct timeval tv;

    tv.tv_sec = 3;
    tv.tv_usec = 500000;

    printf("waiting at sleep for 3.5 second...\n");

    if (select(0, NULL, NULL, NULL, &tv) == -1)
        exit_sys("select");

    printf("Ok\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    select fonksiyonunda kullanılan fd_set bit dizisi en fazla FD_SETSIZE kadar biti içermektedir. Linux sistemlerinde FD_SETSIZE
    1024 olarak define edilmiştir. Dolayısıyla Linux sistemlerinde select fonksiyonu ile ancak ilk 1024 betimleyici izlenebilir. 
    Biz setrlimit fonksiyonu ile dosya betimleyici tablomuzu büyütsek bile select fonksiyonu yalnızca ilk 1024 betimleyici ile
    çalışmaya devam edecektir. Bunun için çeşitli çözümler uyduruldaysa da bunların hiçbiri genel ve taşınabilir değildir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    select fonksiyonunun pselect isminde sigset_t parametreli bir biçimi de vardır:

    #include <sys/select.h>

    int pselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timespec *timeout,
            const sigset_t *sigmask);

    Fonksiyon sigmask parametresiyle aldığı sinyal kümesini thread'in sinyal bloke kümesi yapar. Böylece fonksiyon çalıştığı 
    sürece bazı sinyaller bloke edilebilmekte ya da onların blokesi açılabilmektedir. Fonksiyon sonlandığında eski sinyal bloke
    kümesini yeniden thread'in sinyal bloke kümesi olarak set edilmektedir. Yani buraya girilecek sinyal bloke kümesi fonksiyon 
    çalıştığı sürece etkili olmaktadır. Bu parametre NULL adres geçilirse fonksiyonun pselect fonksiyonundan bir farkı kalmaz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    poll fonksiyonu select fonksiyonun alternatifi olan bir fonksiyondur. select ile poll aynı amaçlarla kullanılmaktadır. 
    Fakat bu iki fonksiyonun parametrik yapıları ve kullanılma biçimleri farklıdır. Daha önceden de belirttiğimiz gibi select
    fonksiyonu BSD sistemlerinde tasarlanmışken poll fonksiyonu klasik AT&T UNIX sistemlerinde tasarlanmıştır. Tabii bu iki 
    fonksiyon da ilk zamandan beri POSIX standartlarında bulunmaktadır.

    poll fonksiyonu bazı bakımlardan select fonksiyonundan daha iyi gibi gözükmektedir. Ancak poll fonksiyonunun kullanımı 
    biraz daha zordur.

    poll fonksiyonunun prototipi şöyledir:

    #include <poll.h>

    int poll(struct pollfd fds[], nfds_t nfds, int timeout);

    poll fonksiyonu izlenilecek betimleyicileri bit dizisi olarak değil, bir yapı dizisi olarak almaktadır. Fonksiyonun birinci 
    parametresi pollfd türünden bir yapı dizisinin adresini, ikinci parametresi ise onun uzunluğunu almaktadır. Son parametre 
    milisaniye cinsinden zaman aşımını belirtir. Bu parametre -1 girilirse zaman aşımı uygulanmaz, 0 girilirse fonksiyon 
    betimleyicilerin durumuna bakıp hemen geri döner. pollfd yapısı şöyle bildirilmiştir:

    struct pollfd {
        int fd;                /* file descriptor */
        short events;        /* requested events */
        short revents;        /* returned events */
    };

    Yapının fd elemanı izlenecek betimleyiciyi, events elemanı izleme biçimini belirtmektedir. Eğer bu betimleyici değeri negatif 
    herhangi bir değer olarak girilirse o betimleyici için izleme yapılmamaktadır. Dolayısıyla pollfd dizisinden bir elemanı 
    mantıksal olarak çıkartmak için bu betimleyici negatif bir değere çekilebilir. Programcı poll fonksiyonunu çağırmadan önce bu 
    iki elemana değer yerleştirmelidir. Ancak yapının revents elemanı fonksiyon geri döndüğünde oluşan olay hakkında bilgi vermektedir. 
    Bu eleman programcı tarafından events elemanında set edilmez, fonksiyon tarafından revents elemanında set edilir. (Bu sayede yapının 
    elemanlarının bozulmadığına dikkat ediniz.) 

    En önemli izleme olayları şunlardır:

    POLLIN: Okuma amaçlı izlemeyi belirtir. Boruda ya da sokette okunacak bilgi oluştuğunda fonksiyon tarafından bu bayrak 
    set edilmektedir. Soketlerde accept yapan tarafta bir bağlantı isteği oluştuğunda da POLLIN bayrağı set edilmektedir. 
    Aynı zamanda soketlerde karşı taraf soketi kapattığında da POLLIN bayrağı set edilmektedir.

    POLLOUT: Yazma amaçlı izlemeyi belirtir. Boruya ya da sokete yazma durumu oluştuğunda (yani boruda ya da network tamponunda yazma 
    için yer açıldığında) fonksiyon tarafından bu bayrak set edilmektedir. Aynı zamanda soketlerde karşı taraf soketi kapattığında da 
    POLLOUT bayrağı set edilmektedir.

    POLLERR: Hata amaçlı izlemeyi belirtir. Bu bayrak yapının events elemanında set edilmez, fonksiyon tarafından yapının revents 
    elemanında set edilmektedir. Bu bayrak borularda okuma yapan tarafın boruyu kapatmasıyla yazma yapan tarafta set edilmektedir. 
    (Normal olarak okuyan tarafın boruyu kapattığı durumda boruya yazma yapıldığında SIGPIPE sinyalinin oluştuğunu anımsayınız.) 
    Eğer okuyan taraf boruyu kapattığında boruya yazma için yer varsa yazma yapan tarafta aynı zamanda POLLOUT bayrağı da set edilmektedir. 
    POLLERR bayrağı soketlerde kullanılmamaktadır.

    POLLHUP: Boruya yazan tarafın boru betimleyicisini kapattığında okuma yapan tarafta bu bayrak set edilmektedir. Bu bayrak yapının 
    events elemanında set edilmez, fonksiyon tarafından yapının revents elemanında set edilmektedir. (HUP, "hang up" anlamına gelmektedir.) 
    Eğer boruya yazma yapan taraf boruyu kapattığında hala boruda okunacak bilgi varsa okuma yapan tarafta aynı zamanda POLLIN bayrağı 
    da set edilmektedir. POLLHUP bayrağı soketlerde kullanılmamaktadır.

    POLLRDHUP: Soketlerde karşı taraf soketi kapattığında ya da shutdown fonksiyonu SHUT_WR argümanıyla çağrıldığında oluşur.

    POLLNVAL: Bu bayrak yapının events elemanında set edilmez. Fonksiyon tarafından eğer izlenen bir betimleyici kapalıysa 
    yapının revents elemanında fonksiyon tarafından set edilmektedir.

    Bu bayraklar bit OR işlemine sokulabilmektedir. Örneğin hem okuma hem de yazma izlemesi için POLLIN|POLLOUT kullanılabilir.

    Bayrakların anlamları için "The Linux Programming Interface" kitabından şu tabloları da vermek istiyoruz:

    Boruda bilgi yok ve yazan tarafın betimleyicisi kapalı ===> Okuyan tarafta POLLHUP
    Boruda bilgi var ve yazan tarafın betimleyicisi kapalı ===> Okuyan tarafta POLLIN|POLLHUP
    Boruda bilgi var ve yazan tarafın betimleyicisi açık ===> Okuyan tarafta POLLIN

    Boruda yazma için yer yok ve okuyan tarafın betimleyicisi kapalı ===> Yazan tarafta POLLERR
    Boruda yazma için yer var ve okuyan tarafın betimleyicisi kapalı ===> Yazan tarafta POLLOUT|POLLERR
    Boruda yazma için yer var ve okuyan tarafın betimleyicisi açık ===> Yazan tarafta POLLOUT

    Sokette bilgi var ===> Okuyan tarafta POLLIN
    Network tamponunda yazacak yer var ===> Yazan tarafta POLLOUT
    accept yapan tarafta bağlantı isteği oluştuğunda ===> accept yapan tarafta POLLIN
    Karşı taraf soketi kapattığında ===> karşı tarafta POLLIN|POLLOUT|POLLRDHUP

    Geri döndürülen olayların birden fazlası birlikte gerçekleşmiş olabilir. Bu nedenle programcının kontrolü else-if ile 
    değil, ayrık if deyimleriyle yapması gerekir. Okuyan taraf boruları ve soketleri kapatırsa bu durum poll fonksiyonunda POLLERR 
    olayı biçiminde ele alınmaktadır. Programcının POLLHUP ve POLLERR bayraklarını yapının events elemanında set etmesi gerekmemektedir. 
    Bu bayraklar gerektiğinde fonksiyon tarafından yapının revents elemanında set edilmektedir. Borular kapatıldığında seyrek de 
    olsa hem POLLIN hem de POLLHUP olayları birlikte gerçekleşebilmektedir. Karşı taraf bir boruyu kapatıldığında POLLHUP 
    oluştuktan sonra yeniden karşı tarafı kapalı olan boru poll işlemi uygulanırsa yine POLLHUP olayı gerçekleşmektedir. Yani 
    karşı tarafın borusu kapalıysa artık her defasında POLLHUP olayı gerçekleşir.

    poll fonksiyonuna geçersiz bir betimleyici ya da açık olmayan bir betimleyici girilmişse poll fonksiyonu o betimleyici için 
    POLLNVAL olayı oluşturmaktadır. Bu nedenle kapatılmış betimleyicilerin ya negatif bir değere çekilmesi ya da diziden çıkartılması 
    gerekir.

    Server uygulamalarında programcı yine tipik olarak poll fonksiyonunu bir döngü içerisinde çağırır. Döngüden çıkışta dizinin 
    tüm elemanlarının revents elemanını uygun olay için kontrol eder. Eğer bir betimleyici üzerinde hiçbir olay gerçekleşmemişse revents 
    elemanı 0 değerinde olacaktır. Örneğin okuma amaçlı nfds kadar betimleyiciyi poll fonksiyonu ile izlemek isteyelim. İzlenecek 
    betimleyici bilgilerinin pfds isimli dizi de olduğuna varsayalım. poll sonrasındaki kontrol şöyle yapılabilir (kontroller uygulanmamıştır):

    poll(pfds, nfds, -1);

    for (int i = 0; i < nfds; ++i) {
        if (pfds[i].revents & POLLIN) {
            read(pfds[i].fd, ...);
            ...
        }
        if (pfds[i].revents & POLLOUT) {
            read(pfds[i].fd, ...);
            ...
        }
        ...
    }

    Görüldüğü gibi dizinin hangi elemanlarında olay gerçekleştiği bilinmemektedir. (select fonksiyonunda da bizim tek tek
    betimleyicilere FD_ISSET makrosuyla baktığımızı anımsayınız.)

    poll fonksiyonu başarı durumunda bizim dizideki olay gerçekleşen eleman sayısına (olay sayısına değil) geri dönmektedir. 
    Fonksiyon zaman aşımından dolayı sonlanmışsa 0 değerine geri dönmektedir. Zaman aşımı 0 verildiyse ve hiçbir olay 
    gerçekleşmemişse fonksiyon yine 0 değerine geri dönmektedir. Fonksiyon başarısızlık durumunda -1 değerine geri döner ve 
    errno değişkeni uygun biçimde set edilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                90. Ders 15/10/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda poll fonksiyonunun stdin üzerinde basit bir kullanımına örnek verilmiştir. poll fonksiyonu terminal ile kullanılırken
    Ctrl+d tuşlarına basıldığında POLLHUP olayı değil, POLLIN olayı gerçekleşmektedir. Dolayısıyla aşağıdaki kodda döngüden read
    fonksiyonu ile 0 byte okunduğunda çıkılmaktadır. Ctrl+d tuşlarına basıldığında EOF etkisi oluşturulmakta ve read fonksiyonu 
    0 byte okumaktadır. Ancak izleyen paragraflarda görüleceği gibi borular kapatıldığında poll fonksiyonu POLLHUP olayı 
    oluşturmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <poll.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    char buf[BUFFER_SIZE + 1];
    ssize_t result;
    struct pollfd pfds[1];

    pfds[0].fd = 0;
    pfds[0].events = POLLIN;

    for (;;) {
        if (poll(pfds, 1, -1) == -1)
            exit_sys("poll");

        if (pfds[0].revents & POLLIN) {
            if ((result = read(pfds[0].fd, buf, BUFFER_SIZE)) == -1)
                exit_sys("read");
            if (result == 0)
                break;
            buf[result] = '\0';
            printf("%s", buf);
        }
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de gerçek bir server uygulamasına benzer biçimde bir grup isimli borudan poll fonksiyonu ile okuma yapmaya çalışalım.
    Aşağıdaki örnek daha önce select fonksiyonuyla yaptığımız örneğin poll versiyonudur. Yani bu örnekteki program yine bir 
    grup isimli boru, komut satırı argümanı yapılarak çalıştırılmalıdır. Örneğin:

    $ ./sample x y z

    Örneğimizde önce borular açılıp pfds dizisi oluşturulmuştur:

    struct pollfd pfds[MAX_SIZE];
    ...

    for (int i = 1; i < argc; ++i) {
        if (count >= MAX_SIZE) {
            fprintf(stderr, "too many arguments, last arguments ignored!...\n");
            break;
        }
        if ((pfds[i - 1].fd = open(argv[i], O_RDONLY)) == -1)
            exit_sys("open");
        pfds[i - 1].events = POLLIN;
        printf("%s opened...\n", argv[i]);
        ++count;
    }

    İzlemenin POLLIN ile okuma izlemesi olduğuna dikkat ediniz. Yukarıda da belirttiğimiz gibi izlemede POLLHUP belirtilmemektedir. 
    Yine örneğimizde bir döngü içerisinde poll fonksiyonu çağrılmıştır:

    for (;;) {
        printf("waiting at poll...\n");

        if (poll(pfds, count, -1) == -1)
            exit_sys("poll");
        ...
    }

    Buradaki count, pfds dizisindeki eleman sayısını belirtmektedir. poll fonksiyonu blokeyi çözdüğünde bizim dizinin tüm 
    elemanlarını kontrol edip POLLIN ve POLLHUP olaylarının gerçekleşip gerçekleşmediğine bakmamız gerekmektedir:

    for (int i = 0; i < count; ++i) {
        if (pfds[i].revents & POLLIN) {
            ...
        }
        else if (pfds[i].revents & POLLHUP) {
            ...
        }
        ...
    }

    Burada POLLIN ve POLLHUP olaylarının else-if biçiminde ele alındığına dikkat ediniz. Normalde örneğin okuma ve yazma izlemesi 
    yapılırken bu olayların ayrık if deyimleriyle yapılması gerekir. Ancak POLLIN ve POLLHUP olaylarının else-if biçiminde ele 
    alınması daha uygundur. Bunun nedenini şöyle açıklayabiliriz: Karşı taraf boruya (ya da sokete) bilgi yazıp hemen boruyu 
    kapattığında POLLIN ve POLLHUP olayları birlikte oluşabilmektedir. Bu durumda POLLIN ve POLLHUP ayrık if deyimleriyle ele 
    alınırsa ve POLLIN olayında borudakilerin hepsi okunmazsa arkadan POLLUP işlemi ele alınırken boru kapatılacağı için eksik 
    yapılmış olacaktır. Halbuki else-if durumunda biz borudakilerin tamamını okumasak bile sonraki poll işleminde yeniden POLLIN 
    ve POLLHUP oluşacak ve boruyu bitirdikten sonra artık yalnızca POLLHUP olayı oluşacaktır.

    Örneğimizde bir boru kapatıldığında onun dizi elemanındaki betimleyicisi negatif bir değere çekilmiş ve böylece mantıksal 
    olarak diziden atılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <poll.h>

#define BUFFER_SIZE        4096
#define MAX_SIZE        128

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    char buf[BUFFER_SIZE + 1];
    struct pollfd pfds[MAX_SIZE];
    ssize_t result;
    int tcount, count;

    if (argc == 1) {
        fprintf(stderr, "too few arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("opens named pipes... it may block...\n");

    count = 0;
    for (int i = 1; i < argc; ++i) {
        if (count >= MAX_SIZE) {
            fprintf(stderr, "too many arguments, last arguments ignored!...\n");
            break;
        }
        if ((pfds[i - 1].fd = open(argv[i], O_RDONLY)) == -1)
            exit_sys("open");
        pfds[i - 1].events = POLLIN;
        printf("%s opened...\n", argv[i]);
        ++count;
    }
    tcount = count;

    for (;;) {
        printf("waiting at poll...\n");

        if (poll(pfds, count, -1) == -1)
            exit_sys("poll");

        for (int i = 0; i < count; ++i) {
            if (pfds[i].revents & POLLIN) {
                printf("POLLIN occurred...\n");
                if ((result = read(pfds[i].fd, buf, BUFFER_SIZE)) == -1)
                    exit_sys("read");
                buf[result] = '\0';
                printf("%s\n", buf);

            }
            else if (pfds[i].revents & POLLHUP) {
                printf("POLLHUP occurred...\n");
                close(pfds[i].fd);
                pfds[i].fd = -1;
                --tcount;
            }
        }
        if (tcount == 0)
            break;
    }

    printf("there is no descriptor open, finishes...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi aslında kapanan betimleyicileri mantıksal olarak diziden atmak için onun betimleyicisi 
    negatif bir değere çekilebilmektedir. Ancak istersek gerçekten kapanan betimleyicileri diziden atabiliriz. Tabii bu atma
    işlemi aslında dizinin sonundaki elemanın, atılacak elemanla yer değiştirilmesi yoluyla yapılabilmektedir. Aşağıda buna 
    bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <poll.h>

#define BUFFER_SIZE        4096
#define MAX_SIZE        128

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    char buf[BUFFER_SIZE + 1];
    struct pollfd pfds[MAX_SIZE];
    ssize_t result;
    int tcount, count;

    if (argc == 1) {
        fprintf(stderr, "too few arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("opens named pipes... it may block...\n");

    count = 0;
    for (int i = 1; i < argc; ++i) {
        if (count >= MAX_SIZE) {
            fprintf(stderr, "too many arguments, last arguments ignored!...\n");
            break;
        }
        if ((pfds[i - 1].fd = open(argv[i], O_RDONLY)) == -1)
            exit_sys("open");
        pfds[i - 1].events = POLLIN;
        printf("%s opened...\n", argv[i]);
        ++count;
    }
    tcount = count;

    for (;;) {
        printf("waiting at poll...\n");

        if (poll(pfds, count, -1) == -1)
            exit_sys("poll");

        for (int i = 0; i < count; ++i) {
            if (pfds[i].revents & POLLIN) {
                printf("POLLIN occurred...\n");
                if ((result = read(pfds[i].fd, buf, BUFFER_SIZE)) == -1)
                    exit_sys("read");
                buf[result] = '\0';
                printf("%s\n", buf);

            }
            else if (pfds[i].revents & POLLHUP) {
                printf("POLLHUP occurred...\n");
                close(pfds[i].fd);
                pfds[i] = pfds[tcount - 1];
                --tcount;
            }
        }
        count = tcount;
        if (count == 0)
            break;
    }

    printf("there is no descriptor open, finishes...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Tıpkı select fonksiyonunda olduğu gibi poll fonksiyonun da ppoll isimli sigset_t parametreli bir biçimi de vardır:

    #define _GNU_SOURCE        /* See feature_test_macros(7) */
    #include <poll.h>

    int ppoll(struct pollfd *fds, nfds_t nfds, const struct timespec *tmo_p, const sigset_t *sigmask);

    ppoll fonksiyonu POSIX standartlarında bulunmamaktadır. Linux sistemlerine özgüdür. Fonksiyon poll fonksiyonundan farklı
    olarak sinyal bloke kümesini parametre olarak alarak thread'in sinyal bloke kümesini set eder. Çıkışta da onu eski haline
    getirir. Yani buradaki sinyal bloke kümesi fonksiyon çalıştığı sürece etkili olmaktadır. Bu parametre NULL geçilirse 
    fonksiyon poll fonksiyonu gibi çalışmaktadır. Ancak ppoll fonksiyonunun zaman aşımı parametresinin timespec türünden olduğuna 
    dikkat ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi select ve poll fonksiyonlarını birbiriyle kıyaslarsak neler söyleyebiliriz?

    - poll fonksiyonunun kullanımı biraz daha kolay gibidir.

    - select fonksiyonu FD_SETSIZE (1024) kadar betimleyiciyi desteklemektedir. Oysa poll fonksiyonundaki dizi istenildiği 
    kadar büyük olabilir.

    - select fonksiyonunda fonksiyona verdiğimiz kümeler fonksiyon tarafından güncellendiği için fonksiyonun her çağrılmasında
    eski kümeyi saklayarak yeniden kullanmamız gerekir. Halbuki poll fonksiyonunda yapının giriş ve çıkış elemanları birbirinden
    ayrılmıştır.

    - select fonksiyonundaki zaman aşımı duyarlılığı mikrosaniye, poll fonksiyonundaki zaman aşımı duyarlılığı milisaniye 
    mertebesindendir.

    - Her iki fonksiyonda da betimleyici sayısı fazlalaştıkça performans düşme eğilimindedir.

    - poll fonksiyonunu kullanabilmek için pollfd türünden bir yapı dizisinin oluşturulması gerekmektedir. Halbuki select 
    fonksiyonunda fd_set veri yapısı bitsel düzeyde olduğu için az yer kaplamaktadır.

    poll fonksiyonunun select fonksiyonuna göre en önemli avantajı betimleyici sayısının istenildiği kadar çok olabilmesidir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                91. Ders 22/10/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    select ve poll fonksiyonlarının en önemli sorunu betimleyici sayısı arttığında performansın ciddi biçimde düşmesidir. Yani
    bu fonksiyonlar iyi bir ölçeklenebilirliğe (scalability) sahip değildir. İşte bu nedenden dolayı multiplexed IO işlemleri için 
    Linux sistemlerinde bu sistemlere özgü epoll fonksiyonları da bulundurulmuştur. epoll fonksiyonları, select ve poll fonksiyonlarına 
    göre özellikle betimleyici sayısı arttığında çok daha iyi performans göstermektedir. Bu nedenle Linux sistemlerinde ölçeklenebilir 
    server uygulamaları için tercih edilecek yöntem epoll yöntemi olmalıdır. Ancak epoll fonksiyonlarının taşınabilir olmadığına, 
    yalnızca Linux sistemlerine özgü olduğuna dikkat ediniz.

    epoll arayüzünün kullanımı temelde üç fonksiyon ile yapılmaktadır. epoll_create (ya da epoll_create1), epoll_ctl ve epoll_wait. 
    epoll arayüzünün kullanımı tipik olarak aşağıdaki adımlardan geçilerek yapılmaktadır:

    1) Programcı önce epoll_create isimli fonksiyonla bir betimleyici elde eder. Bu betimleyicinin IO olaylarının izleneceği 
    betimleyici ile bir ilgisi yoktur. Bu betimleyici diğer fonksiyonlara bir handle gibi geçirilmektedir. Fonksiyonun prototipi 
    şöyledir:

    #include <sys/epoll.h>

    int epoll_create(int size);

    Fonksiyonun parametresi kaç betimleyicinin izlenileceğine yönelik bir ipucu değeri alır. Programcı burada verdiği değerden
    daha fazla betimleyiciyi izleyebilir. Dolayısıyla bu parametre yalnızca bir ipucu niteliğindedir. Zaten daha sonra bu parametre 
    tasarımcıları rahatsız etmiş ve epoll_create1 isimli fonksiyonla kaldırılmıştır:

    #include <sys/epoll.h>

    int epoll_create1(int flags);

    Buradaki flags şimdilik yalnızca FD_CLOEXEC değerini ya da 0 değerini alabilmektedir. Fonksiyonların geri dönüş değeri
    başarı durumunda handle görevinde olan bir betimleyicidir.

    epoll_create ve epoll_create1 fonksiyonları başarı durumunda epoll betimleyicisine, başarısızlık durumunda -1 değerine geri 
    dönmektedir.

    2) Artık programcı izleyeceği betimleyicileri epoll sistemine epoll_ctl fonksiyonuyla ekler. Örneğin programcı 3 boru 
    betimleyicisini izleyecekse bu 3 betimleyici için de ayrı ayrı epoll_ctl çağrısı yapmalıdır. Fonksiyonun prototipi şöyledir:

    #include <sys/epoll.h>

    int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);

    Fonksiyonun birinci parametresi epoll_create ya da epoll_create1 fonksiyonundan elde edilen betimleyici değeridir. İkinci parametre
    EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL değerlerinden birini alır. EPOLL_CTL_ADD sisteme betimleyici eklemek için, EPOLL_CTL_DEL 
    sistemden betimleyici çıkartmak için, EPOLL_CTL_MOD da mevcut eklenmiş betimleyicide izleme değişikliği yapmak için kullanılmaktadır. 
    Üçüncü parametre izlenecek betimleyiciyi belirtir. Son parametre izlenecek olayı belirtmektedir. struct epoll_event yapısı 
    şöyle bildirilmiştir:

    struct epoll_event {
        uint32_t events;
        epoll_data_t data;
    };

    Yapının events elemanı tıpkı poll fonksiyonunda olduğu gibi izlenecek olayları belirten bayrak değerlerini almaktadır. Bu 
    bayrak değerleri epoll_ctl fonksiyonunda izlenecek olayları belirtir. İzleyen paragraflarda göreceğimiz epoll_wait fonksiyonunda 
    da gerçekleşen olayları belirtmektedir. İzleme amacıyla kullanılan tipik bayraklar şunlardır:

    EPOLLIN: Okuma amaçlı izlemeyi belirtir. Boruda ya da sokette okunacak bilgi oluştuğunda epoll_wait tarafından bu bayrak set 
    edilir. Soketlerde accept yapan tarafta bir bağlantı isteği oluştuğunda da EPOLLIN bayrağı epoll_wait tarafından set 
    edilmektedir. EPOLLIN bayrağı aynı zamanda karşı taraf soketi kapattığında da oluşmaktadır.

    EPOLLOUT: Yazma amaçlı izlemeyi belirtir. Boruya ya da sokete yazma durumu oluştuğunda (yani boruda ya da network tamponunda 
    yazma için yer açıldığında) fonksiyon tarafından bu bayrak set edilmektedir. EPOLLOUT bayrağı aynı zamanda karşı taraf soketi 
    kapattığında da oluşmaktadır.

    EPOLLERR: Hata amaçlı izlemeyi belirtir. Bu bayrak epoll_ctl fonksiyonunda set edilmez, epoll_wait fonksiyonu tarafından set 
    edilmektedir. Bu bayrak borularda okuma yapan tarafın boruyu kapatmasıyla yazma yapan tarafta set edilmektedir. (Normal olarak 
    okuyan tarafın boruyu kapattığı durumda boruya yazma yapıldığında SIGPIPE sinyalinin oluştuğunu anımsayınız.) Eğer okuyan taraf 
    boruyu kapattığında boruya yazma için yer varsa yazma yapan tarafta aynı zamanda EPOLLOUT bayrağı da set edilmektedir. 
    EPOLLERR bayrağı soketlerde kullanılmamaktadır.

    EPOLLHUP: Boruya yazan tarafın boru betimleyicisini kapattığında okuma yapan tarafta bu bayrak set edilmektedir. Bu bayrak 
    epoll_ctl fonksiyonunda set edilmez, epoll_wait tarafından yapının set edilmektedir. (HUP, "hang up" anlamına gelmektedir.) 
    Eğer boruya yazma yapan taraf boruyu kapattığında hala boruda okunacak bilgi varsa okuma yapan tarafta aynı zamanda EPOLLIN 
    bayrağı da set edilmektedir. EPOLLHUP bayrağı soketlerde kullanılmamaktadır.

    EPOLLRDHUP: Bu olay soketlerde karşı taraf soketi kapattığında ya da shutdown fonksiyonu SHUT_WR argümanıyla çağrıldığında 
    oluşur.
    Bayrak hem epoll_ctl fonksiyonunda set edilebilir hem de epoll_wait tarafından set edilebilir.

    Daha önce poll bayrakları için verdiğimiz tabloyu epoll bayrakları için de benzer biçimde vermek istiyoruz:

    Boruda bilgi yok ve yazan tarafın betimleyicisi kapalı ===> Okuyan tarafta EPOLLHUP
    Boruda bilgi var ve yazan tarafın betimleyicisi kapalı ===> Okuyan tarafta EPOLLIN|EPOLLHUP
    Boruda bilgi var ve yazan tarafın betimleyicisi açık ===> Okuyan tarafta EPOLLIN

    Boruda yazma için yer yok ve okuyan tarafın betimleyicisi kapalı ===> Yazan tarafta EPOLLERR
    Boruda yazma için yer var ve okuyan tarafın betimleyicisi kapalı ===> Yazan tarafta EPOLLOUT|EPOLLERR
    Boruda yazma için yer var ve okuyan tarafın betimleyicisi açık ===> Yazan tarafta EPOLLOUT

    Sokette bilgi var ===> Okuyan tarafta EPOLLIN
    Network tamponunda yazacak yer var ===> Yazan tarafta EPOLLOUT
    accept yapan tarafta bağlantı isteği oluştuğunda ===> accept yapan tarafta EPOLLIN
    Karşı taraf soketi kapattığında ===> karşı tarafta EPOLLIN|EPOLLOUT|EPOLLRDHUP

    epoll_event yapısının data elemanı aslında çekirdek tarafından saklanıp epoll_wait fonksiyonu yoluyla bize geri verilmektedir.
    Bu eleman bir birlik biçiminde bildirilmiştir (yani programcı tarafından bu birliğin yalnızca tek elemanı set edilmelidir):

    typedef union epoll_data {
        void *ptr;
        int fd;
        uint32_t u32;
        uint64_t u64;
    } epoll_data_t;

    Programcının tipik olarak olayın gerçekleştiği dosya betimleyicisinin hangisi olduğunu bilmesi gerekmektedir. Dolayısıyla 
    genellikle birliğin fd elemanı set edilmektedir. Tabii programcı daha fazla bilgi set etmek istiyorsa bir yapı oluşturabilir. 
    Betimleyiciyi ve diğer bilgileri bu yapının içerisine yerleştirebilir. Yapı nesnesinin adresini de birliğin ptr elemanına 
    atayabilir.

    epoll_ctl fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. errno değişkeni uygun 
    biçimde set edilmektedir.

    Kenar tetiklemeli (edge triggered) ve düzey tetiklemeli (level triggered) kavramları lojik elektronikte kullanılmaktadır. 
    Kenar tetikleme belli bir olay ilk gerçekleştiğinde birtakım değişikliklerin yapıldığını, düzey tetikleme ise belli bir olay 
    devam ettiği sürece değişikliklerin sürekli yapıldığını anlatmaktadır. Her ne bu terimler elektronikten geçtiyse de yazılımda da 
    anlatımları kolaylaştırmak için kullanılmaktadır. Örneğin select ve poll fonksiyonları "düzey tetiklemeli (level triggered)" 
    olarak çalışmaktadır. Yani bir boruya bilgi geldiği zaman bu fonksiyonlar çağrıldığında durumu bize bildirirler. O bilgi borudan 
    okunmadığı sürece bu fonksiyonları tekrar çağırdığımızda bu fonksiyonlar yine durumu bize bildirmektedir. epoll fonksiyonu 
    ise default durumda yine düzey tetiklemeli çalışırken özel olarak epoll_event yapısının events elemanına EPOLLET eklenirse o 
    betimleyici için "kenar tetiklemeli (edge triggered)" mod kullanılır.

    Yukarıda da belirtildiği gibi düzey tetiklemeli mod demek (select, poll'daki durum ve epoll'daki default durum) bir okuma 
    ya da yazma olayı açılıp bloke çözüldüğünde programcı eğer okuma ya da yazma yapmayıp yeniden bu fonksiyonları çağırırsa 
    bekleme yapılmayacak demektir. Yani örneğin biz select ya poll ile stdin dosyasını izliyorsak ve klavyeden bir giriş yapıldıysa 
    bu fonksiyonlar blokeyi çözer. Fakat biz read ile okuma yapmazsak ve yeniden select ve poll fonksiyonlarını çağırırsak artık 
    bloke oluşmaz. Halbuki kenar tetiklemeli modda biz okuma yapmasak bile yeni okuma eylemi oluşana kadar yine blokede kalırız. 
    Biz buradaki örneklerimizde epoll fonksiyonunu düzey tetiklemeli olarak kullanacağız. Soketler konusunda epoll fonksiyonunun 
    kenar tetiklemeli kullanımı üzerinde duracağız.

    Tabii programcının izleyeceği her betimleyici için epoll_ctl fonksiyonunu çağırması gerekir. Örneğin biz 3 farklı betimleyiciyi 
    izleyeceksek bizim üç kere epoll_ctl fonksiyonunu çağırmamız gerekir.

    3) Asıl bekleme ve izleme işlemi epoll_wait fonksiyonu tarafından yapılmaktadır. Bu fonksiyon select ve poll fonksiyonu gibi 
    eğer izlenen betimleyicilerde hiçbir olay gerçekleşmemişse bloke oluşturur ve eğer en az bir betimleyicide izlenen olaylardan 
    biri gerçekleşmişse blokeyi çözer. epoll_wait fonksiyonunun prototipi şöyledir: 

    #include <sys/epoll.h>

    int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);

    Fonksiyonun birinci parametresi epoll_create ya da epoll_create1 fonksiyonundan elde edilmiş olan betimleyici değeridir. 
    İkinci parametre oluşan olayların depolanacağı yapı dizisinin adresidir. Biz bu yapının events elemanından oluşan olayın 
    ne olduğunu anlarız. Yapının data elemanı epoll_ctl sırasında verdiğimiz değeri belirtir. Bizim en azından epoll_ctl fonksiyonunda 
    ilgili betimleyiciyi bu data elemanında girmiş olmamız gerekir. Fonksiyonun üçüncü parametresi, ikinci parametresiyle belirtilen 
    dizinin uzunluğudur. Normal olarak bu dizinin eklenmiş olan betimleyici sayısı kadar olması gerekir. Ancak buradaki değer 
    toplam izlenecek betimleyici sayısından az olabilir. Bu parametre tek hamlede en fazla kaç betimleyici hakkında bilgi 
    verileceğini belirtmektedir. Örneğin biz fonksiyonun ikinci parametresine 5 elemanlı bir yapı dizisinin adresini, üçüncü 
    parametresine de 5 değerini girebiliriz. Bu durumda epoll_wait fonksiyonunu çağırdığımızda fonksiyon bize en fazla 5 olay
    hakkında bilgi verecektir. Son parametre yine milisaniye cinsinden zaman aşımını belirtir. -1 değeri zaman aşımının 
    kullanılmayacağını, 0 değeri hemen betimleyicilere bakılıp çıkılacağını belirtmektedir. Fonksiyon başarı durumunda diziye 
    doldurduğu eleman sayısı ile, başarısızlık durumda -1 değeri ile geri dönmektedir. Örneğin fonksiyon 2 değerine geri dönmüş 
    olsun. Bu durum fonksiyon tarafından verdiğimiz dizinin "ilk 2" elemanının doldurulduğu anlamına gelmektedir. Fonksiyon 0 
    değeri ile geri dönerse sonlanmanın zaman aşımından dolayı oluştuğu anlaşılmaktadır. Tabii epoll_wait fonksiyonunun yine 
    bir döngü içerisinde çağrılması gerekmektedir.

    4) İzleme işlemlerinin kapatılması için tek yapılacak şey epoll_create ya da epoll_create1 fonksiyonundan elde edilen 
    betimleyicinin close fonksiyonuyla kapatılmasıdır.

    Belli bir betimleyiciyi izleme listesinden çıkartmak için normal olarak epoll_ctl fonksiyonu EPOLL_CTL_DEL parametresiyle 
    çağrılmalıdır. Ancak epoll sisteminde çoğu kez buna gerek yoktur. Bir dosyaya ilişkin son betimleyici de kapatılmışsa 
    o betimleyici otomatik olarak izleme listesinden çıkartılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda stdin dosyasından (0 numaralı betimleyiciden) epoll fonksiyonu ile okuma işlemine bir örnek verilmiştir. Örnekte
    sanki birden fazla betimleyici söz konusuymuş gibi işlem yapılmıştır. Bunun amacı kodun genel durum için bir şablon 
    oluşturmasını sağlamaktır. Tıpkı poll fonksiyonunda olduğu gibi terminalden Ctrl+d tuşlarına basıldığında EPOLLIN olayı 
    gerçekleştiğine dikkat ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/epoll.h>

#define MAX_EVENTS        1
#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(void)
{
    int epfd;
    struct epoll_event ee;
    struct epoll_event ree[MAX_EVENTS];
    int nevents;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;

    if ((epfd = epoll_create(1)) == -1)
        exit_sys("epoll_create");

    ee.events = EPOLLIN;
    ee.data.fd = 0;        /* yalnızca 0 numaralı betimleyici kullanıyoruz, aslında bu örnekte gerek yok */

    if (epoll_ctl(epfd, EPOLL_CTL_ADD, 0, &ee) == -1)
        exit_sys("epoll_ctl");

    for (;;) {
        if ((nevents = epoll_wait(epfd, ree, MAX_EVENTS, -1)) == -1)
            exit_sys("epoll_wait");

        for (int i = 0; i < nevents; ++i) {
            if (ree[i].events & EPOLLIN) {
                if ((result = read(ree[i].data.fd, buf, BUFFER_SIZE)) == -1)
                    exit_sys("read");
                if (result == 0)
                    goto EXIT;
                buf[result] = '\0';
                printf("%s", buf);
            }
        }
    }
EXIT:
    close(epfd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de daha vermiş olduğumuz borulardan okuma örneğini aşağıda epoll fonksiyonu ile gerçekleştirelim. Örneğimizde yine program 
    isimli boruları komut satırı argümanı olarak almaktadır. Örneğin:

    $ ./sample x y z

    Bu borular üzerinde okuma olayları izlenmektedir. Borular kapatıldığında EPOLLHUP olayı gerçekleşmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/epoll.h>

#define BUFFER_SIZE        4096
#define MAX_SIZE        128
#define MAX_EVENTS        5

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    char buf[BUFFER_SIZE + 1];
    int epfd, fd;
    struct epoll_event ee;
    struct epoll_event ree[MAX_EVENTS];
    int nevents;
    ssize_t result;
    int count;

    if (argc == 1) {
        fprintf(stderr, "too few arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((epfd = epoll_create(1)) == -1)
        exit_sys("epoll_create");

    printf("opens named pipes... it may block...\n");

    count = 0;
    for (int i = 1; i < argc; ++i) {
        if (count >= MAX_SIZE) {
            fprintf(stderr, "too many arguments, last arguments ignored!...\n");
            break;
        }
        if ((fd = open(argv[i], O_RDONLY)) == -1)
            exit_sys("open");

        ee.events = EPOLLIN;
        ee.data.fd = fd;
        if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ee) == -1)
            exit_sys("epoll_ctl");

        printf("%s opened...\n", argv[i]);
        ++count;
    }
    for (;;) {
        printf("waiting at epoll_wait...\n");

        if ((nevents = epoll_wait(epfd, ree, MAX_EVENTS, -1)) == -1)
            exit_sys("epoll_wait");

        for (int i = 0; i < nevents; ++i) {
            if (ree[i].events & EPOLLIN) {
                printf("EPOLLIN occurred...\n");
                if ((result = read(ree[i].data.fd, buf, BUFFER_SIZE)) == -1)
                    exit_sys("read");
                buf[result] = '\0';
                printf("%s\n", buf);

            }
            else if (ree[i].events & EPOLLHUP) {
                printf("EPOLLHUP occurred...\n");
                close(ree[i].data.fd);
                --count;
            }
        }
        if (count == 0)
            break;
    }

    printf("there is no descriptor open, finishes...\n");

    close(epfd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi Linux sistemlerinde epoll fonksiyonunun performansı select ve poll fonksiyonlarından 
    çok daha iyidir. Bu nedenle Linux sistemlerinde ilk tercih edilecek multiplexed IO sistemi epoll olmalıdır. Tabii epoll
    sistemi POSIX uyumlu değildir. Yani epoll kullandığımız kodlar taşınabilir olmamaktadır.

    epoll performansı için Michael Kerrisk'in "The Linux Programming Environment" kitabında karşılaştırmalı olarak saniye 
    cinsinden şu değerler verilmektedir:

    Number of descriptors   poll() CPU time         select() CPU time           epoll CPU time

    10                      0.61                    0.73                        0.41
    100                     2.9                     3.0                         0.42
    1000                    35                      35                          0.53
    10000                   990                     930                         0.66

    Burada görüldüğü gibi Linux sistemlerinde select ile poll fonksiyonlarının performansı birbirine çok yakındır. Ancak
    epoll sisteminin performansı açık ara çok daha iyidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    epoll fonksiyonu ile sistem genelinde izlenecek maksimum betimleyici sayısı default durumda sistem belleği ile ilgili bir 
    biçimde ayarlanmaktadır. Bu bilgi /proc/sys/fs/epoll/max_user_watches dosyasında bulunmaktadır. Bu değer değiştirilebilmektedir. 
    Kursun yapıldığı sanal makinede bu değer 858824 biçimindedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    epoll ile kenar tetiklemeli işlemler üzerinde burada örnek vermeyeceğiz. Bunun için ilgili dokümanlara başvurabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sinyal tabanlı (signal driven) IO işlemlerinde belli bir betimleyicide olay oluştuğunda prosese bir sinyal gönderilmektedir. 
    Böylece sinyal oluştuğunda ilgili kaynaktan okuma/yazma işlemleri yapılabilmektedir. Bunun için SIGIO isimli bir sinyal 
    bulundurulmuştur. Ancak izleyen paragraflarda da görüleceği üzere olay gerçekleştiğinde oluşturulacak olan bu sinyal 
    değiştirilebilmektedir. Ancak bu model güncel POSIX standartlarında bulunmamaktadır. Bazı UNIX türevi sistemler ve Linux 
    sistemleri bu modeli desteklemektedir.

    Sinyal tabanlı IO modeli tipik olarak şu aşamalardan geçilerek gerçekleştirilmektedir.

    1) Betimleyici open fonksiyonuyla açılır. Eğer soketler söz konusu ise betimleyici socket fonksiyonuyla ya da accept 
    fonksiyonuyla elde edilmektedir.

    2) Oluşturulacak sinyal için (default durumda SIGIO sinyali) sinyal fonksiyonu set edilir.

    3) İlgili betimleyicide olay oluştuğunda hangi prosese sinyal gönderileceği fcntl fonksiyonu ile set edilir. Tabii genel olarak 
    programcı sinyalin kendi prosesine gönderilmesini ister. Bunun için fcntl fonksiyonunun ikinci parametresi olan fcntl komutu için
    F_SETOWN girilmelidir. fcntl fonksiyonunun üçüncü parametresine ise sinyalin gönderileceği prosesin id değeri girilir. Bu 
    parametreye getpid() fonksiyonunun geri dönüş değeri girilirse ilgili olay gerçekleştiğinde kendi prosesimize sinyal gönderilir. 
    Üçüncü parametre negatif bir proses id girilirse, bu değerin mutlak değeri proses grup belirtmektedir.

    4) Betimleyici blokesiz moda sokulur ve aynı zamanda O_ASYNC bayrağı da set edilir. Bu işlem fcntl fonksiyonunda F_SETFL komut 
    koduyla yapılabilmektedir.

    fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_NONBLOCK | O_ASYNC);

    O_ASYNC bayrağı POSIX standartlarında bulunmamaktadır.

    Bu yöntemde ilgilenilen olay (yani okuma olayının mı yazma olayının mı izleneceği) gizlice open fonksiyonundaki açış modunda 
    belirtilmektedir. Yani örneğin bizim open fonksiyonuyla dosyayı O_RDONLY modunda açmamız yalnızca okuma olayıyla ilgilendiğimizi, 
    O_WRONLY modunda açmamız yalnızca yazma olayı ile ilgilendiğimizi, O_RDWR modunda açmamız da hem okuma hem de yazma ile ilgilendiğimizi
    belirtir.

    5) Artık normal akış devam eder. İlgilenilen olay gerçekleştiğinde sinyal oluşturulmaktadır.

    Sinyal tabanlı IO işlemleri "kenar tetiklemeli (edge triggered)" bir biçimde oluşturulmaktadır. Yani yalnızca yeni bilgi 
    geldiğinde sinyal oluşturulur. Bu nedenle programcının sinyal oluştuğunda bir döngü içerisinde başarısız olana kadar 
    okuma/yazma yapması uygun olmaktadır. Örneğin boruya ya da sokete 100 byte gelmiş olsun. Bu durumda sinyal oluşturulur. 
    Eğer biz sinyal oluştuğunda eksik bilgi okursak (örneğin 50 byte okuduğumuzu varsayalım) kenar tetikleme yüzünden artık
    boruya ya da sokete yeni bir bilgi gelene kadar sinyal oluşmayacaktır. Bu nedenle bizim o zamana kadar gelmiş olan tüm 
    bilgileri bir döngü içerisinde okumamız uygun olur. Örneğin:

    for (;;) {
        result = read(STDIN_FILENO, buf, BUFFER_SIZE);

        if (result == -1) {
            if (errno == EAGAIN)
                break;
            exit_sys("read");
        }

        if (result == 0)
            exit(EXIT_SUCCESS);

        buf[result] = '\0';
        printf("%s", buf);        // UNSAFE
    }

    Burada bir döngü içerisinde errno değeri EAGAIN olmayana kadar okuma yapılmıştır.

    Pekiyi sinyal geldiğinde okuma işlemi nasıl yapılmalıdır? İlk akla gelen yöntem okumanın sinyal fonksiyonun içerisinde 
    yapılmasıdır. Ancak bu durum genellikle iyi bir teknik değildir. Bunun tipik nedenleri şunlardır:

    - Sinyal oluştuğunda sinyal fonksiyonunda uzun süre işlem yapmak iyi bir teknik değildir. Çünkü sinyal fonksiyonu çalıştığı 
    sürece aynı sinyal blokede kalmaktadır. SIGIO sinyali gerçek zamanlı bir sinyal olmadığı için kuyruklanmamaktadır. Ancak 
    mekanizmanın kenar tetiklemeli olduğunu anımsayınız. Bu nedenle sinyalin blokesi açıldığında o ana kadar gelmiş olan tüm 
    bilgiler döngü içerisinde okunacaktır.

    - Sinyal fonksiyonu içerisinde ancak biz sinyal güvenli (signal safe) fonksiyonları çağırabiliriz. Ancak okuma ve sonrasında 
    pek çok sinyal güvenli olmayan fonksiyonların çağrılması gerekebilmektedir.

    Pekiyi okuma/yazma işlemlerini sinyal geldiği zaman sinyal fonksiyonu içerisinde yapmayacaksak nerede ve nasıl yapmalıyız? 
    İşte tipik olarak sinyal fonksiyonu içerisinde bir flag set edilip işlemler dışarıda yapılabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                92. Ders 28/10/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte stdin dosyasından sinyal tabanlı okuma yapılmıştır. Bu örnekte sinyal fonksiyonunda yalnızca bir flag 
    set edilmiştir. Okumalar sinyal fonksiyonunun dışında bu flag değişkenine bakılarak gerçekleştirilmiştir. flag değişkeni 
    sig_atomic_t türünden tanımlanmıştır. Anımsanacağı gibi bu türden nesnelere atama işlemleri tek makine komutuyla atomik 
    yapılmaktadır. Her ne kadar sig_atomic_t türü "volatile" özelliğine de kapsıyor gibiyse de biz yine de flag değişkeninde 
    volatile niteleyicisini kullandık.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>

#define BUFFER_SIZE        1024

void sigio_handler(int signo);
void exit_sys(const char *msg);

volatile sig_atomic_t g_sigio_flag;

int main(void)
{
    struct sigaction sa;
    int flags;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;

    sa.sa_handler = sigio_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGIO, &sa, NULL) == -1)
        exit_sys("sigaction");

    if (fcntl(STDIN_FILENO, F_SETOWN, getpid()) == -1)
        exit_sys("fcntl");

    flags = fcntl(STDIN_FILENO, F_GETFL);

    if (fcntl(STDIN_FILENO, F_SETFL, flags|O_NONBLOCK|O_ASYNC) == -1)
        exit_sys("fcntl");

    for (;;) {
        pause();

        if (g_sigio_flag) {
            for (;;) {
                result = read(STDIN_FILENO, buf, BUFFER_SIZE);

                if (result == -1) {
                    if (errno == EAGAIN)
                        break;
                    exit_sys("read");
                }

                if (result == 0)
                    exit(EXIT_SUCCESS);

                buf[result] = '\0';
                printf("%s", buf);
            }
            g_sigio_flag = 0;
        }
    }

    return 0;
}

void sigio_handler(int signo)
{
    g_sigio_flag = 1;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi sinyal tabanlı IO işlemlerinde birden fazla betimleyici ile nasıl işlem yapılacaktır? Örneğin biz 3 boru betimleyicisinden 
    okuma yapmak isteyelim. SIGIO sinyali oluştuğunda hangi boruya bilgi geldiğini nasıl anlayacağız? Yukarıdaki örnekte yalnızca 
    stdin dosyasından okuma yaptık. Bu örnekte böyle bir bilgiye ihtiyacımız yoktu. İşte bu yöntemin aslında etkin bir biçimde 
    kullanılabilmesi için IO olayı olduğunda SIGIO sinyali yerine gerçek zamanlı bir sinyalin oluşturulması gerekmektedir. 
    Gerçek zamanlı sinyaller hem kuyruklanmakta hem de bu sinyallere ek bir bilgi yerleştirilebilmektedir.

    Sinyal tabanlı IO işlemindeki default sinyalin SIGIO sinyali olduğunu belirtmiştik. Ancak SIGIO sinyalinin gerçek zamanlı 
    olmaması bir handikap oluşturmaktadır. İşte default sinyal aslında fcntl fonksiyonu ile F_SETSIG komutu kullanılarak 
    değiştirilebilmektedir. Örneğin:

    fcntl(fd, F_SETSIG, SIGRTMIN);

    Benzer biçimde oluşturulacak sinyalin numarası da fcntl fonksiyonunda F_GETSIG komutuyla elde edilebilmektedir. Biz F_SETSIG
    komutu ile gerçek zamanlı bir sinyal set ettiğimizde artık sinyal fonksiyonumuzun siginfo_t parametreli olması gerekmektedir. 
    Gerçek zamanlı sinyallerin nasıl set edildiğini anımsatmak istiyoruz:

    void signal_handler(int signo, siginfo_t *info, void *context);
    ...
    struct sigaction sa;
    ...

    sa.sa_sigaction = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART|SA_SIGINFO;

    Gerçek zamanlı sinyallerin bu konudaki faydasını izleyen paragraflarda açıklayacağız. Ancak şimdi aşağıda sinyal tabanlı 
    IO işlemleri için gerçek zamanlı sinyalin set edilmesine yönelik örnek vermek istiyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>

#define BUFFER_SIZE        1024

void signal_handler(int signo, siginfo_t *info, void *context);
void exit_sys(const char *msg);

volatile sig_atomic_t g_sigio_flag;

int main(void)
{
    struct sigaction sa;
    int flags;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;

    sa.sa_sigaction = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART|SA_SIGINFO;

    if (sigaction(SIGRTMIN, &sa, NULL) == -1)
        exit_sys("sigaction");

    if (fcntl(STDIN_FILENO, F_SETOWN, getpid()) == -1)
        exit_sys("fcntl");

    flags = fcntl(STDIN_FILENO, F_GETFL);

    if (fcntl(STDIN_FILENO, F_SETFL, flags|O_NONBLOCK|O_ASYNC) == -1)
        exit_sys("fcntl");

    if (fcntl(STDIN_FILENO, F_SETSIG, SIGRTMIN) == -1)
        exit_sys("fcntl");

    for (;;) {
        pause();

        if (g_sigio_flag) {
            for (;;) {
                result = read(STDIN_FILENO, buf, BUFFER_SIZE);

                if (result == -1) {
                    if (errno == EAGAIN)
                        break;
                    exit_sys("read");
                }

                if (result == 0)
                    exit(EXIT_SUCCESS);

                buf[result] = '\0';
                printf("%s", buf);
            }
            g_sigio_flag = 0;
        }
    }

    return 0;
}

void signal_handler(int signo, siginfo_t *info, void *context)
{
    g_sigio_flag = 1;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi gerçek zamanlı sinyallerde sinyal fonksiyonuna çekirdek tarafından içi doldurulan siginfo_t türünden bir 
    yapı nesnesinin adresi geçiriliyordu. siginfo_y yapısını anımsayınız:

    siginfo_t {
        int      si_signo;     /* Signal number */
        int      si_errno;     /* An errno value */
        int      si_code;      /* Signal code */
        int      si_trapno;    /* Trap number that caused hardware-generated signal (unused on most architectures) */
        pid_t    si_pid;       /* Sending process ID */
        uid_t    si_uid;       /* Real user ID of sending process */
        int      si_status;    /* Exit value or signal */
        clock_t  si_utime;     /* User time consumed */
        clock_t  si_stime;     /* System time consumed */
        union sigval si_value; /* Signal value */
        int      si_int;       /* POSIX.1b signal */
        void    *si_ptr;       /* POSIX.1b signal */
        int      si_overrun;   /* Timer overrun count; POSIX.1b timers */
        int      si_timerid;   /* Timer ID; POSIX.1b timers */
        void    *si_addr;      /* Memory location which caused fault */
        long     si_band;      /* Band event (was int in glibc 2.3.2 and earlier) */
        int      si_fd;        /* File descriptor */
        short    si_addr_lsb;  /* Least significant bit of address (since Linux 2.6.32) */
        void    *si_lower;     /* Lower bound when address violation occurred (since Linux 3.19) */
        void    *si_upper;     /* Upper bound when address violation occurred (since Linux 3.19) */
        int      si_pkey;      /* Protection key on PTE that caused fault (since Linux 4.6) */
        void    *si_call_addr; /* Address of system call instruction (since Linux 3.5) */
        int      si_syscall;   /* Number of attempted system call (since Linux 3.5) */
        unsigned int si_arch;  /* Architecture of attempted system call (since Linux 3.5) */
    }

    Anımsanacağı gibi yapının si_signo elemanı oluşan sinyalin numarasını, si_pid elemanı sinyali oluşturan prosesin id 
    değerini vermekteydi. Sinyal tabanlı IO işlemlerinde yapının si_fd elemanı sinyale yol açan betimleyicinin numarasını 
    vermektedir. si_code elemanı ise sinyalin neden oluştuğuna yönelik bilgi vermektedir. Yapının bu si_code elemanında şu 
    bitler set edilmiş olabilir:

    POLL_IN: Okuma ya da kapatma olayı
    POLL_OUT: Yazma olayı
    POLL_ERR: IO hatası

    Diğer bayraklar için dokümanlara başvurabilirsiniz.

    Aşağıda daha önce yaptığımız boru örneğinin sinyal tabanlı IO modeli ile gerçekleştirimini veriyoruz. Bu örnekte sinyaller
    senkron biçimde sigwaitinfo fonksiyonu ile işlenmiştir. Dolayısıyla bir sinyal fonksiyonu yazılmamıştır. sigwaitinfo 
    uygulamadan önce beklenecek sinyalleri bloke etmeyi unutmayınız. Örneğimizde sigwaitinfo fonksiyonundan çıkıldığında 
    oluşan olay siginfo_t yapısının si_code elemanından elde edilmiş ve yapının si_fd elemanından okuma yapılmıştır. Karşı 
    taraf boruyu ya da soketi kapattığında yine POLL_IN olayının gerçekleşeceğini anımsatmak istiyoruz. 
---------------------------------------------------------------------------------------------------------------------------*/

#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <unistd.h>

#define BUFFER_SIZE        4096
#define MAX_SIZE        128

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    char buf[BUFFER_SIZE + 1];
    int fd;
    ssize_t result;
    sigset_t sset;
    siginfo_t sinfo;
    int count;

    if (argc == 1) {
        fprintf(stderr, "too few arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("opens named pipes... it may block...\n");

    count = 0;
    for (int i = 1; i < argc; ++i) {
        if (count >= MAX_SIZE) {
            fprintf(stderr, "too many arguments, last arguments ignored!...\n");
            break;
        }
        if ((fd = open(argv[i], O_RDONLY)) == -1)
            exit_sys("open");

        if (fcntl(fd, F_SETOWN, getpid()) == -1)
            exit_sys("fcntl");

        if (fcntl(fd, F_SETFL, fcntl(fd, F_GETFL)|O_NONBLOCK|O_ASYNC) == -1)
            exit_sys("fcntl");

        if (fcntl(fd, F_SETSIG, SIGRTMIN) == -1)
            exit_sys("fcntl");

        printf("%s opened...\n", argv[i]);
        ++count;
    }

    sigaddset(&sset, SIGRTMIN);

    if (sigprocmask(SIG_BLOCK, &sset, NULL) == -1)
        exit_sys("sigprocmask");

    for (;;) {
        if ((sigwaitinfo(&sset, &sinfo)) == -1)
            exit_sys("sigwaitinfo");

        if (sinfo.si_code & POLL_IN) {
            for (;;) {
                result = read(sinfo.si_fd, buf, BUFFER_SIZE);

                if (result == -1) {
                    if (errno == EAGAIN)
                        break;
                    exit_sys("read");
                }

                if (result == 0) {
                    --count;
                    close(sinfo.si_fd);
                    break;
                }

                buf[result] = '\0';
                printf("%s", buf);
            }
            if (count == 0)
                break;
        }
    }

    if (sigprocmask(SIG_UNBLOCK, &sset, NULL) == -1)
        exit_sys("sigprocmask");

    printf("there is no descriptor open, finishes...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi multiplexed select ve poll modeli ile sinyal tabanlı IO modelini kıyaslarsak neler söyleyebiliriz? Linux sistemlerinde 
    sinyal tabanlı IO modeli, select ve poll modeline göre daha yüksek performans sunmaktadır. Özellikle önceki örnekte yaptığımız 
    senkron sinyal işlemesi yüksek miktarda betimleyici söz konusu olduğunda select ve poll modelinden daha iyi sonuçlar 
    vermektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İleri IO modellerinden biri de "Asenkron IO" modelidir. Bu modelde okuma/yazma gibi işlemler başlatılır ancak akış devam 
    eder. İşlemler bittiğinde durum programcıya bir sinyal ya da fonksiyon çağrısı ile bildirilir. Asenkron IO işlemleri POSIX 
    standartları tarafından desteklenmektedir. Asenkron IO modelinde kullanılan fonksiyonlar aio_xxx biçiminde isimlendirilmiştir. 
    Asenkron IO işlemleri için kullanılan fonksiyonlar ve yapılar <aio.h> dosyası içerisinde bildirilmiştir.

    Asenkron IO işlemleri tipik olarak şu aşamalardan geçilerek yürütülmektedir:

    1) Önce <aio.h> içerisinde bildirilmiş olan struct aiocb (asynchronous IO control block) isimli bir yapı türünden nesne tanımlanıp 
    içinin doldurulması gerekir. Yapı şöyle bildirilmiştir.

    #include <aio.h>

    struct aiocb {
        int             aio_fildes;
        off_t           aio_offset;
        volatile void  *aio_buf;
        size_t          aio_nbytes;
        int             aio_reqprio;
        struct sigevent aio_sigevent;
        int             aio_lio_opcode;
    };

    Yapının aio_fildes elemanına okuma/yazma yapılmak istenen dosyaya ilişkin dosya betimleyicisi yerleştirilir. Asenkron okuma/yazma
    işlemleri dosya göstericisinin gösterdiği yerden itibaren yapılmamaktadır. Okuma/yazmanın dosyanın neresinden yapılacağı yapının 
    aio_offset elemanında belirtilir. (Seekable olmayan aygıtlar için bu elemana 0 girilebilir. Eğer yazma durumu söz konusuysa 
    ve dosya O_APPEND modda açıldıysa bu durumda aio_offset elemanının değeri dikkate alınmaz. Her yazılan dosyaya eklenir.) 
    Yapının aio_buf elemanı transferin yapılacağı bellek adresini belirtir. Bu adresteki dizinin işlem sonlanana kadar yaşıyor 
    durumda olması gerekmektedir. Yapının aio_nbytes elemanı okunacak ya da yazılacak byte miktarını belirtmektedir. Tabii burada 
    belirtilen byte miktarı aslında aio_buf dizisinin uzunluğunu belirtmektedir. Yoksa kesin olarak okunacak byte sayısını belirtmez. 
    Yani örneğin asenkron biçimde bir borudan 100 byte okumak isteyelim. Bize "işlem bitti" bildirimi 100 byte okuduktan sonra 
    gelmek zorunda değildir. En az 1 byte'lık okuma olayı gerçekleşmişse de "işlem bitti bildirimi" yapılır. Tabii hiçbir zaman burada 
    belirtilen byte miktarından fazla okuma yazma yapılmayacaktır. Başka bir deyişle yapının bu aio_nbytes elemanı en fazla yapılacak 
    okuma/yazma miktarını belirtmektedir. Yapının aio_reprio elemanı ise okuma/yazma için bir öncelik derecesi belirtmektedir. Yani 
    bu değer yapılacak transferin önceliğine ilişkin bir ipucu belirtir. Ancak işletim sisteminin bu ipucunu kullanıp kullanmayacağı 
    isteğe bağlı bırakılmıştır. Bu elemana 0 geçilebilir. Yapının aio_sigevent elemanı işlem bittiğinde yapılacak bildirim hakkında 
    bilgileri barındırmaktadır. Bu sigevent yapısını daha önce timer konusunda görmüştük. Burada yeniden anımsatmak istiyoruz:

    #include <signal.h>

    struct sigevent {
        int          sigev_notify;
        int          sigev_signo;
        union sigval sigev_value;
        void       (*sigev_notify_function) (union sigval);
        void        *sigev_notify_attributes;
    };

    Bu yapının sigev_notify elemanı bildirimin türünü belirtir. Anımsanacağı gibi bu tür SIGEV_NONE, SIGEV_SIGNAL, SIGEV_THREAD
    biçiminde olabilmektedir. SIGEV_NONE IO olayı bittiğinde bir bildirimin yapılmayacağını, SIGEV_SIGNAL bir sinyal ile 
    bildirimin yapılacağını, SIGEV_THREAD ise bildirimin kernel tarafından yaratılan bir thread yoluyla yapılacağını belirtmektedir. 
    Yapının sigev_signo elemanı ise eğer sinyal yoluyla bildirimde bulunulacaksa sinyalin numarasını belirtmektedir. Yapının 
    sigev_value elemanı sinyal fonksiyonuna ya da thread fonksiyonuna gönderilecek kullanıcı tanımlı bilgiyi temsil etmektedir. 
    Buradaki birliğin aşağıdaki gibi bildirildiğini anımsayınız:

    #include <signal.h>

    union sigval {            /* Data passed with notification */
        int     sival_int;    /* Integer value */
        void   *sival_ptr;    /* Pointer value */
    };

    Yapının sigev_notify_function elemanı eğer bildirim thread yoluyla yapılacaksa işletim sistemi tarafından yaratılan thread'in 
    çağıracağı callback fonksiyonunu belirtmektedir. Yapının sigev_notify_attributes elemanı ise yaratılacak thread'in özelliklerini 
    belirtir. Bu parametre NULL geçilebilir.

    Örneğin:

    struct aiocb cb;
    char buf[BUFFER_SIZE + 1];
    ...

    cb.aio_fildes = STDIN_FILENO;
    cb.aio_offset = 0;
    cb.aio_buf = buf;
    cb.aio_nbytes = BUFFER_SIZE;
    cb.aio_reqprio = 0;
    cb.aio_sigevent.sigev_notify = SIGEV_THREAD;
    cb.aio_sigevent.sigev_value.sival_ptr = &cb;
    cb.aio_sigevent.sigev_notify_function = io_proc;
    cb.aio_sigevent.sigev_notify_attributes = NULL;

    2) Şimdi okuma ya da yazma olayını aio_read ya da aio_write fonksiyonuyla başlatmak gerekir. Artık akış bu fonksiyonlarda bloke 
    olmayacak fakat işlem bitince bize bildirimde bulunulacaktır.

    #include <aio.h>

    int aio_read(struct aiocb *aiocbp);
    int aio_write(struct aiocb *aiocbp);

    Fonksiyonlar başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. İşlemlerin devam ettiğine yani 
    henüz sonlanmadığına dikkat ediniz. Bu fonksiyonlara verdiğimiz aiocb yapılarının işlem tamamlanana kadar yaşıyor olması gerekir. 
    Yani fonksiyon bizim verdiğimiz aiocb yapısını çalışırken kullanıyor olabilir.

    aio_read ve aio_write fonksiyonları yalnızca bir defalık okuma yazma için mekanizmayı kurmaktadır. Mekanizmanın nasıl devam 
    ettirileceği izleyen maddede ele alınacaktır.

    Örneğin:

    if (aio_read(&cb) == -1)
        exit_sys("aio_read");

    3) Anımsanacağı gibi biz aiocb yapısının aio_nbytes elemanına maksimum okuma/yazma miktarını vermiştik. Halbuki bundan daha
    az okuma/yazma yapılması mümkündür. Pekiyi bize bildirimde bulunulduğunda ne kadar miktarda bilginin okunmuş ya da yazılmış 
    olduğunu nasıl anlayacağız? İşte bunun için aio_return isimli fonksiyon kullanılmaktadır:

    #include <aio.h>

    ssize_t aio_return(struct aiocb *aiocbp);

    Fonksiyon başarı durumunda transfer edilen byte sayısına, başarısızlık durumunda -1 değerine geri dönmektedir. Eğer bildirim 
    gelmeden bu fonksiyon çağrılırsa geri dönüş değeri anlamlı olmayabilir. aio_read ve aio_write fonksiyonları sinyal güvenli 
    değildir, ancak aio_return ve aio_error fonksiyonları sinyal güvenlidir.

    Yukarıda aio_read ve aio_write işlemlerinin bir defalık okuma/yazma sağladığını belirtmiştik. İşlemin devamının sağlanması 
    için her okuma/yazma olayı gerçekleştiğinde yeniden aio_read ve aio_write fonksiyonlarının çağrılması gerekmektedir. Yani
    IO işlemi gerçekleştiğinde, biz yeniden IO işlemi için bu fonksiyonların çağrılmasını sağlamalıyız.

    Aşağıda asenkron IO modelinin uygulanmasına ilişkin bir örnek verilmiştir. Örnekte stdin dosyasından sürekli okuma yapılmak 
    istenmiştir. Burada bildirim SIGEV_THREAD ile kernel tarafından yaratılan thread yoluyla yapılmaktadır. Okuma olayı bittiğinde 
    kernel tarafından yaratılmış olan thread, bizim belirlediğimiz fonksiyonu çağırmaktadır. Ancak bu işlemler için kaç thread'in 
    yaratılacağı gibi özellikler sistemden sisteme değişebilmektedir. Örneğin Linux genellikle tek bir thread yaratıp tüm olayları 
    bu thread'e yaptırmaktadır. Biz de bu fonksiyon içerisinde aio_return fonksiyonu ile kaç byte okunduğunu belirleyip işlemin devam 
    etmesi için aio_read fonksiyonunu yeniden çağırmaktayız. Burada thread fonksiyonuna bizim aiocb yapısını nasıl geçirdiğimize 
    dikkat ediniz:

    cb.aio_sigevent.sigev_value.sival_ptr = &cb;

    aio_sigevent yapısının sigev_value elemanı thread fonksiyonuna parametre olarak aktarılmaktadır. sigev_value elemanının 
    bir birlik olduğunu anımsayınız. Biz de bu birliğin sival_ptr elemanına, aiocb yapı nesnesinin adresini yerleştirdik. 
    Klavyeden Ctrl+d tuşlarına basıldığında bu da bir IO olayı olarak ele alınmaktadır. Ancak bu durumda aio_return fonksiyonu
    0 değeri ile geri dönmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <aio.h>

#define BUFFER_SIZE        4096

void io_proc(union sigval sval);
void exit_sys(const char *msg);

int main(void)
{
    struct aiocb cb;
    char buf[BUFFER_SIZE + 1];

    cb.aio_fildes = STDIN_FILENO;
    cb.aio_offset = 0;
    cb.aio_buf = buf;
    cb.aio_nbytes = BUFFER_SIZE;
    cb.aio_reqprio = 0;
    cb.aio_sigevent.sigev_notify = SIGEV_THREAD;
    cb.aio_sigevent.sigev_value.sival_ptr = &cb;
    cb.aio_sigevent.sigev_notify_function = io_proc;
    cb.aio_sigevent.sigev_notify_attributes = NULL;

    if (aio_read(&cb) == -1)
        exit_sys("aio_read");

    printf("waiting at pause, press Ctrl+C to exit...\n");

    pause();

    return 0;
}

void io_proc(union sigval sval)
{
    ssize_t result;
    struct aiocb *cb = (struct aiocb *)sval.sival_ptr;
    char *buf = (char *)cb->aio_buf;

    if ((result = aio_return(cb)) == -1)
        exit_sys("aio_return");

    if (result == 0) {
        printf("Ctrl+d pressed...\n");
        return;
    }

    buf[result] = '\0';
    printf("%s", buf);

    if (aio_read(cb) == -1)
        exit_sys("aio_read");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                93. Ders 29/10/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte daha önce yapmış olduğumuz birden fazla borudan okuma örneğini asenkron IO modeli ile gerçekleştiriyoruz.
    Burada yine komut satırı argümanları ile alınan bir grup isimli boru açılmıştır. Her boru açıldığında bir aiocb yapısı 
    dinamik bir biçimde tahsis edilerek içi doldurulmuştur. Tabii her asenkron IO işleminde farklı bir tamponun kullanılması 
    gerekmektedir. Burada yine bildirim thread yoluyla yapılmaktadır. IO olayı bittiğinde belirlediğimiz fonksiyon kernel 
    tarafından çağrılacaktır. Biz de bu fonksiyon içerisinde kaç byte okumanın yapıldığını belirleyip okunanları ekrana (stdout 
    dosyasına) yazdırmaktayız. Tahsis edilen alanların betimleyici kapatıldıktan sonra free edildiğine dikkat ediniz. Ana akış
    bu sırada pause fonksiyonunda bekletilmektedir. Son boru betimleyicisi de kapatıldığında raise fonksiyonu ile kendi prosesimize
    SIGINT sinyalini göndererek işlemleri sonlandırmaktayız. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <stdatomic.h>
#include <aio.h>

#define BUFFER_SIZE        4096
#define MAX_SIZE        128

void io_proc(union sigval sval);
void exit_sys(const char *msg);

volatile atomic_int g_count;

int main(int argc, char *argv[])
{
    char buf[BUFFER_SIZE + 1];
    int fd;
    struct aiocb *cb;

    if (argc == 1) {
        fprintf(stderr, "too few arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("opens named pipes... it may block...\n");

    g_count = 0;
    for (int i = 1; i < argc; ++i) {
        if (g_count >= MAX_SIZE) {
            fprintf(stderr, "too many arguments, last arguments ignored!...\n");
            break;
        }
        if ((fd = open(argv[i], O_RDONLY)) == -1)
            exit_sys("open");

        printf("%s opened...\n", argv[i]);

        if ((cb = (struct aiocb *)malloc(sizeof(struct aiocb))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }

        cb->aio_fildes = fd;
        cb->aio_offset = 0;
        if ((cb->aio_buf = malloc(BUFFER_SIZE + 1)) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }
        cb->aio_nbytes = BUFFER_SIZE;
        cb->aio_reqprio = 0;
        cb->aio_sigevent.sigev_notify = SIGEV_THREAD;
        cb->aio_sigevent.sigev_value.sival_ptr = cb;
        cb->aio_sigevent.sigev_notify_function = io_proc;
        cb->aio_sigevent.sigev_notify_attributes = NULL;

        if (aio_read(cb) == -1)
            exit_sys("aio_read");

        ++g_count;
    }

    printf("waiting at pause, press Ctrl+C to exit...\n");

    pause();

    free(cb->aio_buf);

    free(cb);

    return 0;
}

void io_proc(union sigval sval)
{
    ssize_t result;
    struct aiocb *cb = (struct aiocb *)sval.sival_ptr;
    char *buf = (char *)cb->aio_buf;

    if ((result = aio_return(cb)) == -1)
        exit_sys("aio_return");

    if (result == 0) {
        printf("pipe closed...\n");
        close(cb->aio_fildes);
        free(buf);
        free(cb);
        --g_count;

        if (g_count == 0)
            if (raise(SIGINT) != 0)
                exit_sys("raise");
        return;
    }

    buf[result] = '\0';
    printf("%s", buf);

    if (aio_read(cb) == -1)
        exit_sys("aio_read");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örneği biraz farklı bir biçimde de düzenleyebiliriz. Örneğin aiocb yapısı ile tampon, bizim oluşturduğumuz 
    bir yapının içerisinde saklanabilir. Böylece tahsisat işlemleri ve kullanım işlemleri biraz daha kolaylaştırılabilir. 
    Örneğin:

    typedef struct {
        struct aiocb cb;
        char buf[BUFFER_SIZE + 1];
    } IOCB_BUF;

    Bu sayede biz aiocb yapısı ve tampon için iki ayrı tahsisat yapmak yerine tek bir tahsisat yapabiliriz. Aynı zamanda
    bu yapının içerisine başka bilgiler de yerleştirilebilmektedir. Gerçekten de özellikle TCP soket uygulamalarında okunan
    bilgilerin bir araya getirilmesi için tampona eşlik eden başka bilgilerinde bu yapıda tutulması gerekebilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <stdatomic.h>
#include <aio.h>

#define BUFFER_SIZE        4096
#define MAX_SIZE        128

typedef struct {
    struct aiocb cb;
    char buf[BUFFER_SIZE + 1];
} IOCB_INFO;

void io_proc(union sigval sval);
void exit_sys(const char *msg);

volatile atomic_int g_count;

int main(int argc, char *argv[])
{
    int fd;
    IOCB_INFO *ioinfo;

    if (argc == 1) {
        fprintf(stderr, "too few arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("opens named pipes... it may block...\n");

    g_count = 0;
    for (int i = 1; i < argc; ++i) {
        if (g_count >= MAX_SIZE) {
            fprintf(stderr, "too many arguments, last arguments ignored!...\n");
            break;
        }
        if ((fd = open(argv[i], O_RDONLY)) == -1)
            exit_sys("open");

        printf("%s opened...\n", argv[i]);

        if ((ioinfo = (IOCB_INFO *)malloc(sizeof(IOCB_INFO))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }

        ioinfo->cb.aio_fildes = fd;
        ioinfo->cb.aio_offset = 0;
        ioinfo->cb.aio_buf = ioinfo->buf;
        ioinfo->cb.aio_nbytes = BUFFER_SIZE;
        ioinfo->cb.aio_reqprio = 0;
        ioinfo->cb.aio_sigevent.sigev_notify = SIGEV_THREAD;
        ioinfo->cb.aio_sigevent.sigev_value.sival_ptr = ioinfo;
        ioinfo->cb.aio_sigevent.sigev_notify_function = io_proc;
        ioinfo->cb.aio_sigevent.sigev_notify_attributes = NULL;

        if (aio_read(&ioinfo->cb) == -1)
            exit_sys("aio_read");

        ++g_count;
    }

    printf("waiting at pause, press Ctrl+C to exit...\n");

    pause();

    free(ioinfo);

    return 0;
}

void io_proc(union sigval sval)
{
    ssize_t result;
    IOCB_INFO *ioinfo = (IOCB_INFO *)sval.sival_ptr;

    if ((result = aio_return(&ioinfo->cb)) == -1)
        exit_sys("aio_return");

    if (result == 0) {
        printf("pipe closed...\n");
        close(ioinfo->cb.aio_fildes);
        free(ioinfo);
        --g_count;

        if (g_count == 0)
            if (raise(SIGINT) != 0)
                exit_sys("raise");
        return;
    }

    ioinfo->buf[result] = '\0';
    printf("%s", ioinfo->buf);

    if (aio_read(&ioinfo->cb) == -1)
        exit_sys("aio_read");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    aio_cancel fonksiyonu ise başlatılmış olan bir asenkron IO işlemini iptal etmek için kullanılmaktadır.

    #include <aio.h>

    int aio_cancel(int fd, struct aiocb *aiocbp);

    Fonksiyonun birinci parametresi iptal edilecek betimleyiciyi belirtir. Eğer iocb NULL geçilirse bu betimleyiciye ilişkin 
    bütün asenkron işlemler iptal edilmektedir.

    Fonksiyon AIO_CANCELED değerine geri dönerse iptal başarılıdır. AIO_NOTCANCELED değerine geri dönerse işlem aktif biçimde 
    devam etmekte olduğu için iptal başarısızdır. AIO_ALLDONE değeri ise işlemin zaten bittiğini belirtir. Fonksiyon başarısızlık 
    durumunda -1 değerine geri dönmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    aio_error isimli fonksiyon herhangi bir durumda başlatılan işlemin akıbeti konusunda bilgi almak için kullanılabilir.

    #include <aio.h>

    int aio_error(const struct aiocb *aiocbp);

    Fonksiyonun geri dönüş değeri bu asenkron işlemin o anda ne durumda olduğu hakkında bize bilgi vermektedir. Eğer fonksiyon 
    EINPROGRESS biçiminde özel bir değere geri dönerse işlemin hala devam ettiği anlamı çıkar. Geri dönüş değeri ECANCELED 
    ise bu durumda işlem aio_cancel fonksiyonuyla iptal edilmiştir (Bu geri dönüş değeri POSIX standartlarında bulunmamaktadır. Linux 
    sistemlerinde bulunmaktadır.) Fonksiyon errno değerini set etmez. Geri dönüş değeri diğer pozitif değerlerden birisi ise 
    hata ile ilgili errno değerini belirtir. Başlatılan IO işlemi başarılı bir biçimde sonlanmışsa fonksiyon 0 değerine geri 
    dönmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdiye kadar görmüş olduğumuz IO modellerinin kullanımları ve performansları hakkında şunları söyleyebiliriz:

    - select, poll modeli ve asenkron IO modeli POSIX standartlarında bulunan taşınabilir modellerdir.
    - epoll modeli ve sinyal tabanlı IO modeli Linux sistemlerine özgüdür. Yani taşınabilir değildir.
    - Linux sistemlerinde performansı en yüksek model epoll modelidir. Performans sıralaması iyiden kötüye doğru şöyledir:

    1) epoll modeli
    2) sinyal tabanlı IO modeli ve asenkron IO modeli
    3) select ve poll modeli
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Üzerinde duracağımız son IO modeli İngilizce "scatter/gather" IO modeli denilen modeldir. ("scatter" saçmak, "gather"
    toplamak anlamına gelmektedir. Buna Türkçe "saçma/toplama IO modeli" diyebiliriz.)

    Pek çok uygulamada değişik adreslerdeki bilgilerin peşi sıra dosyaya yazılması ya da dosyadan okunanların değişik adreslere
    yazılması söz konusu olabilmektedir. Örneğin bir kaydı temsil eden aşağıdaki üç bilginin birbiri ardına dosyaya yazılmak 
    istendiğini düşünelim:

    int record_len;
    char record[RECORD_SIZE];
    int record_no;

    Bu bilgilerin dosyaya yazılması için normal olarak üç ayrı write işlemi yapmak gerekir:

    if (write(fd, &record_len, sizeof(int)) != sizeof(int)) {
        ...
    }

    if (write(fd, record, RECORD_SIZE) != RECORD_SIZE) {
        ...
    }

    if (write(fd, &record_no, sizeof(int)) != sizeof(int)) {
        ...
    }

    Burada farklı adreslerde bulunan üç farklı bilgi dosyaya peşi sıra yazılmak istenmiştir. Ancak bu write işlemi göreli bir 
    zaman kaybı oluşturabilmektedir. Tabii zaman kaybı uygulamaların ancak çok azında bir önem oluşturur. Buradaki zaman kaybının 
    en önemli nedeni her write çağrısının kernel mode'a geçiş yapmasıdır. Eğer bu zaman kaybını aşağı çekmek istiyorsak ilk 
    akla gelen yöntem önce bu bilgileri başka bir tampona kopyalayıp tek bir write işlemi yapmaktır:

    char buf[BUFSIZE];

    memcpy(buf, &recordlen, sizeof(int));
    memcpy(buf + sizeof(int), record, RECORD_SIZE);
    memcpy(buf + sizeof(int) + RECORD_SIZE, &record_no, sizeof(int));

    if (write(fd, buf, 2 * sizeof(int) + RECORD_SIZE) != 2 * sizeof(int) + RECORD_SIZE) {
        ...
    }

    Bu işlem üç ayrı write işlemine göre oldukça hızlıdır. işte readv ve writev isimli fonksiyonlar farklı adreslerdeki bilgileri 
    yukarıdakine benzer biçimde dosyaya yazıp dosyadan okumaktadır. Bu işlemlere İngilizce "scatter/gather IO" denilmektedir. readv ve 
    writev fonksiyonlarının prototipleri şöyledir:

    #include <sys/uio.h>

    ssize_t readv(int fildes, const struct iovec *iov, int iovcnt);
    ssize_t writev(int fildes, const struct iovec *iov, int iovcnt);

    Fonksiyonların birinci parametreleri okuma ya da yazma işleminin yapılacağı dosya betimleyicisini, ikinci parametreleri 
    kullanılacak tampon uzunluklarının ve adreslerinin belirtildiği yapı dizisinin adresini, üçüncü parametresi de bu yapı dizisinin 
    uzunluğunu belirtir. Programcı struct iovec türünden bir yapı dizisi oluşturup onun içini doldurmalıdır. Fonksiyonlar 
    başarısızlık durumunda -1 değerine, diğer durumlarda okunan yazılan toplam byte miktarına geri dönmektedir. Okuma ve 
    yazma işlemleri tek parça halinde atomik biçimde yapılmaktadır. Yani bu okuma yazma işlemlerinin arasına başka bir dosya
    işlemi girememektedir. iovec yapısı şöyle bildirilmiştir:

    struct iovec {
        void *iov_base;
        size_t iov_len;
    };

    Yapının iov_base elemanı yazılacak ya da okunacak bilginin bellek adresini, iov_len elemanı ise bunun uzunluğunu belirtmektedir.

    Aşağıdaki örnekte aslında üç farklı write işlemi ile yapılacak yazma işlemleri tek hamlede atomik olarak writev fonksiyonuyla
    yapılmıştır. Burada farklı adreslerdeki bilgilerin dosyaya dosya göstericisinin gösterdiği yerden itibaren peşi sıra 
    yazıldığına dikkat ediniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/uio.h>

#define BUFFER_SIZE        10

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char *buf1[BUFFER_SIZE];
    char *buf2[BUFFER_SIZE];
    char *buf3[BUFFER_SIZE];
    struct iovec vec[3];

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");

    memset(buf1, 'a', BUFFER_SIZE);
    memset(buf2, 'b', BUFFER_SIZE);
    memset(buf3, 'c', BUFFER_SIZE);

    vec[0].iov_base = buf1;
    vec[0].iov_len = BUFFER_SIZE;

    vec[1].iov_base = buf2;
    vec[1].iov_len = BUFFER_SIZE;

    vec[2].iov_base = buf3;
    vec[2].iov_len = BUFFER_SIZE;

    if (writev(fd, vec, 3) == -1)
        exit_sys("writev");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda readv fonksiyonun kullanımına bir örnek verilmiştir. Burada yukarıdaki örnekte oluşturulan dosya ters bir biçimde
    readv fonksiyonu ile farklı adreslere okunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/uio.h>

#define BUFFER_SIZE        10

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char *buf1[BUFFER_SIZE];
    char *buf2[BUFFER_SIZE];
    char *buf3[BUFFER_SIZE];
    struct iovec vec[3];

    if ((fd = open("test.txt", O_RDONLY)) == -1)
        exit_sys("open");

    vec[0].iov_base = buf1;
    vec[0].iov_len = BUFFER_SIZE;

    vec[1].iov_base = buf2;
    vec[1].iov_len = BUFFER_SIZE;

    vec[2].iov_base = buf3;
    vec[2].iov_len = BUFFER_SIZE;

    if (readv(fd, vec, 3) == -1)
        exit_sys("writev");

    write(1, buf1, BUFFER_SIZE);
    write(1, buf2, BUFFER_SIZE);
    write(1, buf3, BUFFER_SIZE);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Arka planda sessiz sedasız çalışan bir kullanıcı arayüzü olmayan, kullanıcılarla terminal yoluyla etkileşmeyen programlara 
    Windows dünyasında "servis (service)", UNIX/Linux dünyasında ise "daemon (di:mın biçiminde okunuyor)" denilmektedir. Servisler 
    ya da daemon'lar tipik olarak boot süreci sırasında çalışmaya başlatılırlar ve yine tipik olarak makine reboot edilene kadar 
    çalışmaya devam ederler. Tabii böyle bir zorunluluk yoktur. Yani servis ya da daemon programlar istenildiği zaman başlatılıp 
    istenildiği zaman sonlandırılabilmektedir. "Servis" ya da "daemon" kernel mod bir kavram değildir. Yani servisler ve daemon'lar 
    genellikle "user mode'da" çalışmak üzere yazılırlar. UNIX/Linux dünyasında geleneksel olarak daemon'lar "xxxxxd" biçiminde 
    sonuna 'd' harfi getirilerek isimlendirilmektedir. Çekirdeğe ilişkin bazı thread'ler de servis benzeri işlemler yaptıkları için 
    bunlar da çoğu kez sonu 'd' ile bitecek ancak başı da 'k' ile başlayacak biçimde isimlendirilmiştir. Bu kernel daemon'ların 
    bizim şu andaki konumuz olan daemon'larla hiçbir ilgisi yoktur. Yalnızca işlev bakımından bir benzerlik söz konusudur. UNIX/Linux 
    dünyasında daemon denildiğinde akla öncelikle "server programlar" gelmektedir. Örneğin ftp server programı (ftpd) ve http server 
    programı (httpd) daemon programlar biçiminde yazılmışlardır. Daemon'lar genellikle arka planda önemli işlemler yaptıkları için 
    uygun önceliklerle (yani sudo ile root hakkıyla) çalıştırılırlar.

    Daemon programlar pek çok modern UNIX/Linux sisteminde "init paketleri" içerisindeki özel utility'ler tarafından başlatılıp, 
    sürdürülüp, sonlandırılmaktadır. Yani ilgili dağıtımın bu daemon'ları idare etmek için özel komutları bulunabilmektedir. Linux 
    sistemlerinde init prosesi ve diğer proseslerin kodları ve boot süreci ile ilgili utility'ler "init paketleri" denilen paketler 
    biçiminde farklı proje grupları tarafından oluşturulmuştur. Başka bir deyişle "servis yönetim (service management)" işlemleri 
    organize bir biçimde bu "init paketleri" tarafından yapılmaktadır. Yaygın olarak kullanılan üç "init paketi" bulunmaktadır:

    1) SysVinit: Klasik System5'teki işlevleri yapan init paketidir. Linux uzun bir süre bu paketi kullanmıştır.
    2) Upstart: 2006 yılında oluşturulmuştur ve 2010'ların ortalarına kadar (bazı dağıtımlarda hala) kullanılmaya yaygın 
    biçimde kullanılmıştır.
    3) systemd: 2010 yılında oluşturulmuştur ve son yıllarda pek çok Linux dağıtımında kullanılmaya başlanmıştır. Bugün en 
    yaygın kullanılan init paketi durumundadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                94. Ders 04/11/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir daemon programı yazabilmek için öncelikle onun terminal bağlantısının kesilmesi gerekmektedir. Bir programı komut 
    satırından sonuna & getirerek "arka plan proses grubu" biçiminde çalıştırarak daemon oluşturamayız. Çünkü bu durumda terminal 
    kapatıldığında bizim prosesimiz de SIGHUP sinyali yüzünden kapatılacaktır.

    Bir daemon programın yazılması tipik olarak şu aşamalardan geçilerek yapılmaktadır:

    1) Daemon programlar bir dosya açmak istediklerinde tam olarak belirlenen haklarla bunu yapmalıdırlar. Bu nedenle bu proseslerin
    umask değerlerinin 0 yapılması uygun olur. Örneğin:

    umask(0);

    2) Bir prosesin daemon etkisi yaratması için terminalle bir bağlantısının kalmaması gerekir. Bu da basit bir biçimde maalesef
    0, 1, 2 numaralı terminal betimleyicilerinin kapatılmasıyla sağlanamaz. Bunu sağlamanın en temel yolu setsid fonksiyonunu 
    çağırmaktır. Anımsanacağı gibi setsid fonksiyonu yeni bir oturum (session) ve yeni bir proses grubu oluşturup ilgili prosesi 
    bu proses grubunun ve oturumun lideri yapmaktadır. Ayrıca setsid fonksiyonu prosesin terminal ilişkisini (controlling terminal) 
    de ortadan kaldırmaktadır. Ancak setsid uygulayabilmek için prosesin herhangi bir proses grup lideri olmaması gerekir. Aksi 
    takdirde setsid fonksiyonu başarısız olmaktadır. Yine anımsanacağı gibi kabuk programlar çalıştırdıkları programlar için bir 
    proses grubu yaratıp o programı da proses grup lideri yapıyordu. İşte proses grup lideri olmaktan kurtulmak için bir kez fork 
    yapıp üst prosesi sonlandırabiliriz. Aynı zamanda bu işlem kabuk programının hemen komut satırına yeniden düşmesine yol açacaktır. 
    O halde 2'nci aşamada fork işlemi yapılıp üst proses sonlandırılmalıdır. Örneğin:

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0)
        _exit(EXIT_SUCCESS);

    3) Artık alt proses setsid fonksiyonunu uygulayarak yeni bir oturum yaratır ve terminal ilişkisini keser. Terminal ilişkisinin 
    kesilmesi ile artık terminal kapatılsa bile programımız çalışmaya devam edecektir. Tabii setsid ile terminal bağlantısının kesilmiş 
    olması programın terminale bir şey yazamayacağı anlamına gelmez. Hala 0, 1, 2 numaralı betimleyiciler açıktır. Terminal açık 
    olduğu sürece oraya yazma yapılabilir. Örneğin:

    if (setsid() == -1)
        _exit(EXIT_FAILURE);

    4) Daemon programların çalışma dizinlerinin (current working directory) sağlam bir dizin olması tavsiye edilir. Aksi takdirde 
    o dizin silinirse arka plan programların çalışmaları bozulabilir. Bu nedenle daemon programlar çoğu kök dizini (silinemeyeceği 
    için) çalışma dizini yapmaktadır. Tabii bu zorunlu değildir. Bunun yerine varlığı garanti edilmiş olan herhangi bir dizin de 
    çalışma dizini yapılabilir. Örneğin:

    if (chdir("/") == -1)
        _exit(EXIT_FAILURE);

    5) Daemon programın o ana kadar açılmış olan tüm betimleyicileri kapatması uygun olur. Örneğin 0, 1, 2 numaralı betimleyiciler
    ilgili terminale ilişkindir ve artık o terminal kapatılmış ya da kapatılacak olabilir. Program kendini daemon yaptığı sırada 
    açmış olduğu diğer dosyaları da kapatmalıdır. Bunu sağlamanın basit bir yolu prosesin toplam dosya betimleyici tablosunun 
    uzunluğunu elde edip her bir betimleyici için close işlemi uygulamaktır. Çünkü maalesef biz açık betimleyicileri pratik bir 
    biçimde tespit edememekteyiz. Zaten kapalı bir betimleyiciye close uygulanırsa close başarısız olur, ancak program çökmez. 
    Anımsanacağı gibi prosesin toplam betimleyici sayısı sysconf çağrısında _SC_OPEN_MAX argümanıyla ya da getrlimit fonksiyonunda 
    RLIMIT_NOFILE argümanıyla elde edilebilir. İki fonksiyon da aynı değeri vermektedir. Örneğin:

    long maxfd;

    if ((maxfd = sysconf(_SC_OPEN_MAX)) == -1)
        _exit(EXIT_FAILURE);

    for (long i = 0; i < maxfd; ++i)
        close(i);

    6) Zorunlu olmamakla birlikte ilk üç betimleyiciyi "/dev/null" aygıtına yönlendirmek iyi bir fikirdir. Çünkü daemon içerisinde
    çağıracağımız bazı fonksiyonlar bu betimleyicileri kullanıyor olabilirler. Anımsanacağı gibi "/dev/null" aygıtına yazılanlar 
    zaten kaybolmaktadır. Bu aygıttan okuma yapılmak istendiğinde ise EOF etkisi oluşmaktadır. Örneğin:

    int fd;

    if ((fd = open("/dev/null", O_RDONLY)) == -1)        // fd is guaranteed to be 0
        _exit(EXIT_FAILURE);

    if (dup(fd) == -1 || dup(fd) == -1)                    // now descriptor 1 and 2 redirected /dev/null
        _exit(EXIT_FAILURE);

    Burada bazı programcılar (örneğin Stevent & Rago ile Kerrisk'in kitaplarında bu biçimde) elde edilen betimleyicilerin 
    0, 1 ve 2 olduğunu doğrulamaya çalışmaktadır. Tüm betimleyiciler kapatıldığına göre ve open ile dup fonksiyonları 
    en düşük betimleyicileri verdiğine göre böyle bir kontrolün yapılmasına aslında gerek yoktur. Bu kontrolün tek anlamı
    çok thread'li uygulamalarda o sırada başka bir thread'in bu noktada dosya açıyor olmasıdır. Böyle bir olasılığı 
    değerlendirmek isterseniz kodu şöyle değiştirebilirsiniz:

    int fd0, fd1, fd2;

    if ((fd0 = open("/dev/null", O_RDONLY)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd1 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd2 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if (fd0 != 0 || fd1 != 1 || fd2 != 2)
        _exit(EXIT_FAILURE);

    Pekiyi daemon'lar ne yaparlar? İşte daemon'lar arka planda genellikle sürekli bir biçimde birtakım işler yapmaktadır. 
    Bu anlamda en tipik daemon örnekleri "server" programlardır. Örneğin http server aslında httpd isimli bir daemon'dan 
    ibarettir. Bunun gibi UNIX/Linux sistemlerinde genellikle boot zamanında devreye giren onlarca daemon program vardır. 
    Örneğin belli zamanlarda belli işlerin yapılması için kullanılan "cron" utility'si aslında bir daemon olarak çalışmaktadır.

    Yukarıda da belirttiğimiz gibi daemon'lar genellikle yetki gerektiren işlemler yaptıkları için uygun önceliğe sahip olacak 
    biçimde (yani root olarak) çalıştırılmaktadırlar.

    Aşağıdaki örnekte tipik bir daemon program iskeleti oluşturulmuştur. Programın sonuna bir pause çağrısı yerleştirdik. 
    Daemon'ı sonlandırmak için proses id'sini bulup kill işlemi uygulayabilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/* mydaemond.c */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

#define DEF_FDT_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;
    long maxfd;
    int fd0, fd1, fd2;

    umask(0);

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0)
        _exit(EXIT_SUCCESS);

    if (setsid() == -1)
        _exit(EXIT_FAILURE);

    if (chdir("/") == -1)
        _exit(EXIT_FAILURE);

    errno = 0;
    if ((maxfd = sysconf(_SC_OPEN_MAX)) == -1)
        if (errno == 0)
            maxfd = DEF_FDT_SIZE;
        else
            _exit(EXIT_FAILURE);

    for (long i = 0; i < maxfd; ++i)
        close(i);

    if ((fd0 = open("/dev/null", O_RDONLY)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd1 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd2 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if (fd0 != 0 || fd1 != 1 || fd2 != 2)
        _exit(EXIT_FAILURE);

    pause();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında yukarıdaki işlemleri bir fonksiyona da yaptırabiliriz. Böylece o fonksiyonu çağırdığımızda proses bir daemon 
    haline getirilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* mydaemond.c */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void exit_sys(const char *msg);

#define DEF_FDT_SIZE        4096

void make_daemon(void)
{
    pid_t pid;
    long maxfd;
    int fd0, fd1, fd2;

    umask(0);

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0)
        _exit(EXIT_SUCCESS);

    if (setsid() == -1)
        _exit(EXIT_FAILURE);

    if (chdir("/") == -1)
        _exit(EXIT_FAILURE);

    errno = 0;
    if ((maxfd = sysconf(_SC_OPEN_MAX)) == -1)
        if (errno == 0)
            maxfd = DEF_FDT_SIZE;
        else
            _exit(EXIT_FAILURE);

    for (long i = 0; i < maxfd; ++i)
        close(i);

    if ((fd0 = open("/dev/null", O_RDONLY)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd1 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd2 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if (fd0 != 0 || fd1 != 1 || fd2 != 2)
        _exit(EXIT_FAILURE);
}

int main(void)
{
    make_daemon();

    pause();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                95. Ders 05/11/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir daemon ne zaman ve nasıl sonlandırılmalıdır? Daemon'lar arka planda sessiz sedasız çalıştığından onların 
    sonlandırılması sinyaller yoluyla yapılabilir. Tipik olarak daemon'lar SIGTERM sinyali ile sonlandırılmaktadır. Anımsanacağı
    gibi SIGTERM sinyali ele alınabilir bir sinyaldir (SIGKILL sinyalinin ele alınamayacağını anımsayınız). İşte bir daemon 
    birtakım son işlemler yapacaksa bunu SIGTERM sinyali oluştuğunda bu sinyali set ederek yapabilmektedir. Pekiyi daemon 
    hiç sonlandırılmazsa ne olur? İşletim sistemi kapanırken bütün proseslere zaten önce SIGTERM sinyali göndermektedir. 
    Dolayısıyla daemon'lar en kötü olasılıkla birtakım son işlemleri sistem kapatılırken SIGTERM sinyali yoluyla yapabilirler. 
    Ancak sistemler genellikle SIGTERM sinyalinden sonra proseslere belli bir süre bekleyip SIGKILL sinyali de göndermektedir. 
    Örneğin Linux kapanırken SIGTERM sinyalindan yaklaşık 5 saniye sonra her ihtimale karşı proseslere SIGKILL sinyali de
    göndermektedir. Bu durumda daemon programların son işlemlerini bu zaman aralığı içerisinde yavaş olmayacak biçimde 
    yapması beklenir.

    Aşağıdaki daemon programının SIGTERM sinyalini işlemesi örneği verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* mydaemond.c */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <signal.h>

void sigterm_handler(int signo);
void exit_sys(const char *msg);

#define DEF_FDT_SIZE        4096

void make_daemon(void)
{
    pid_t pid;
    long maxfd;
    int fd0, fd1, fd2;

    umask(0);

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0)
        _exit(EXIT_SUCCESS);

    if (setsid() == -1)
        _exit(EXIT_FAILURE);

    if (chdir("/") == -1)
        _exit(EXIT_FAILURE);

    errno = 0;
    if ((maxfd = sysconf(_SC_OPEN_MAX)) == -1)
        if (errno == 0)
            maxfd = DEF_FDT_SIZE;
        else
            _exit(EXIT_FAILURE);

    for (long i = 0; i < maxfd; ++i)
        close(i);

    if ((fd0 = open("/dev/null", O_RDONLY)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd1 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd2 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if (fd0 != 0 || fd1 != 1 || fd2 != 2)
        _exit(EXIT_FAILURE);
}

int main(void)
{
    struct sigaction sa;

    sa.sa_handler = sigterm_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGTERM, &sa, NULL) == -1)
        exit_sys("sigaction");

    make_daemon();

    pause();

    return 0;
}

void sigterm_handler(int signo)
{
    /* cleanup processing */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Daemon programlar genellikle başlatılırken bazı yönergeleri kullanıcıların oluşturduğu konfigürasyon dosyalarından okumaktadır.
    Bu konfigürasyon dosyaları geleneksel olarak "/etc" dizininin altında uzantısı ".conf" olacak biçimde oluşturulmaktadır. 
    Örneğin bizim daemon programımız "/etc/mydaemond.conf" dosyasını okuyup yönergeleri oradan alacak olabilir. Bu dosya henüz 
    daemon'laştırma yapılmadan da okunabilir ya da daemon'laştırma yapıldıktan sonra da okunabilir. Daemon'laştırma yapıldıktan 
    sonra konfigürasyon dosyasını açarken ve sonraki işlemlerde başarısızlıklara ilişkin mesajların artık terminale yazılamayacağına 
    dikkat ediniz. Bunun için log mekanizmaları kullanılmaktadır. Örneğin:

    int main(void)
    {
        struct sigaction sa;

        make_daemon();
        read_config();

        sa.sa_handler = sigterm_handler;
        sigemptyset(&sa.sa_mask);
        sa.sa_flags = SA_RESTART;

        if (sigaction(SIGTERM, &sa, NULL) == -1) {
            // log mekanizması yoluyla hata mesajı oluşturulabilir
            _exit(EXIT_FAILURE);
        }

        // ...

        return 0;
    }

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Daemon'ların çoğu tek bir proses olarak çalışmak zorundadır. Yani daemon'ın başka kopyasının da çalıştırılabilmesi 
    problemlere yol açabilmektedir. Daemon yazarken onun tek kopyasının çalıştığına emin olmak isteyebilirsiniz. Bunun nasıl 
    yapıldığını "dosya kilitleme işlemlerinde" açıklamıştık. Geleneksel olarak daemon'lar bu amaçla "/run" dizini içerisinde 
    ".pid" uzantılı dosyalar oluşturmaktadır. Bu "/run" dizinine sıradan prosesler tarafından yazma hakkı verilmemektedir. Yani 
    bu dizinde dosya yaratmak istiyorsanız daemon programınızı uygun önceliğe sahip olacak biçimde (yani root olarak)" 
    çalıştırmalısınız.

    Aşağıda daemon'ın tek bir kopyasının çalıştırılmasının sağlanmasına yönelik bir örnek verilmiştir. Programı sudo ile 
    çalıştırmayı unutmayınız.
---------------------------------------------------------------------------------------------------------------------------*/

/* mydaemond.c */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <signal.h>
#include <sys/file.h>

void read_config(void);
void check_instance(void);
void sigterm_handler(int signo);
void exit_sys(const char *msg);

#define DEF_FDT_SIZE        4096
#define LOCK_FILE_PATH        "/run/mydaemond.pid"
#define CONFIG_FILE            "/etc/mydaemond.conf"

void make_daemon(void)
{
    pid_t pid;
    long maxfd;
    int fd0, fd1, fd2;

    umask(0);

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0)
        _exit(EXIT_SUCCESS);

    if (setsid() == -1)
        _exit(EXIT_FAILURE);

    if (chdir("/") == -1)
        _exit(EXIT_FAILURE);

    errno = 0;
    if ((maxfd = sysconf(_SC_OPEN_MAX)) == -1)
        if (errno == 0)
            maxfd = DEF_FDT_SIZE;
        else
            _exit(EXIT_FAILURE);

    for (long i = 0; i < maxfd; ++i)
        close(i);

    if ((fd0 = open("/dev/null", O_RDONLY)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd1 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd2 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if (fd0 != 0 || fd1 != 1 || fd2 != 2)
        _exit(EXIT_FAILURE);
}

int main(void)
{
    struct sigaction sa;

    make_daemon();
    check_instance();
    read_config();

    sa.sa_handler = sigterm_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGTERM, &sa, NULL) == -1) {
        /* log mekanizması yoluyla hata mesajı oluşturulabilir */
        _exit(EXIT_FAILURE);
    }

    pause();

    return 0;
}

void read_config(void)
{
    /* ... */
}

void check_instance(void)
{
    int fd;

    if ((fd = open(LOCK_FILE_PATH, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR)) == -1) {
        /* log mekanizması ile mesaj oluşturulabilir */
        _exit(EXIT_FAILURE);
    }

    if (flock(fd, LOCK_EX|LOCK_NB) == -1) {
        if (errno == EWOULDBLOCK) {
                /* log mekanizması ile mesaj oluşturulabilir */
        }
        else {
                /* log mekanizması ile mesaj oluşturulabilir */
        }
        _exit(EXIT_FAILURE);
    }
}

void sigterm_handler(int signo)
{
    /* cleanup processing */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Daemon programların "reinitialize" edilebilmesi sık karşılaşılan bir uygulamadır. Daemon program konfigürasyon dosyasını 
    okuyup çalıştıktan sonra onu durdurmadan adeta reset etmek isteyebiliriz. Örneğin daemon çalışırken konfigürasyon dosyasında
    bir değişiklik yapabiliriz. O değişiklikten sonra yeniden daemon programının o konfigürasyon dosyasını çalıştırmasını sağlamak 
    isteyebiliriz. Genel olarak bu işlem için SIGHUP sinyalinden faydalanılmaktadır. SIGHUP sinyali terminal aygıt sürücüsü ve 
    kabuk programları tarafından kullanılan bir sinyaldir. Ancak daemon programının terminal bağlantısı kesildiğinden SIGHUP 
    sinyali daemon programlar için "boşa çıkmış ve kullanılabilir" bir sinyal durumundadır.

    Aşağıda SIGHUP sinyalinin işlenmesine yönelik bir örnek verilmiştir. Burada konfigürasyon dosyası sinyal fonksiyonu 
    içerisinde okunmuştur. Bu durumda bu işlemlerin asenkron sinyal güvenli bir biçimde yapılması gerekir. Tabii buna 
    alternatifler de söz konusu olabilir. Örneğin sinyal fonksiyonunda bir bayrak set edilip başka bir yerde bu bayrağa
    bakılabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* mydaemond.c */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <signal.h>
#include <sys/file.h>

void read_config(void);
void check_instance(void);
void sigterm_handler(int signo);
void sighup_handler(int signo);
void exit_sys(const char *msg);

#define DEF_FDT_SIZE        4096
#define LOCK_FILE_PATH        "/run/mydaemond.pid"
#define CONFIG_FILE            "/etc/mydaemond.conf"

void make_daemon(void)
{
    pid_t pid;
    long maxfd;
    int fd0, fd1, fd2;

    umask(0);

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0)
        _exit(EXIT_SUCCESS);

    if (setsid() == -1)
        _exit(EXIT_FAILURE);

    if (chdir("/") == -1)
        _exit(EXIT_FAILURE);

    errno = 0;
    if ((maxfd = sysconf(_SC_OPEN_MAX)) == -1)
        if (errno == 0)
            maxfd = DEF_FDT_SIZE;
        else
            _exit(EXIT_FAILURE);

    for (long i = 0; i < maxfd; ++i)
        close(i);

    if ((fd0 = open("/dev/null", O_RDONLY)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd1 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd2 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if (fd0 != 0 || fd1 != 1 || fd2 != 2)
        _exit(EXIT_FAILURE);
}

int main(void)
{
    struct sigaction sa;
    int fd;

    make_daemon();
    check_instance();
    read_config();

    sa.sa_handler = sigterm_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGTERM, &sa, NULL) == -1) {
        /* log mekanizması yoluyla hata mesajı oluşturulabilir */
        _exit(EXIT_FAILURE);
    }

    sa.sa_handler = sighup_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGHUP, &sa, NULL) == -1) {
        /* log mekanizması yoluyla hata mesajı oluşturulabilir */
        _exit(EXIT_FAILURE);
    }

    /* ... */

    pause();

    return 0;
}

void read_config(void)
{
    /* ... */
}

void check_instance(void)
{
    int fd;

    if ((fd = open(LOCK_FILE_PATH, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR)) == -1) {
        /* log mekanizması ile mesaj oluşturulabilir */
        _exit(EXIT_FAILURE);
    }

    if (flock(fd, LOCK_EX|LOCK_NB) == -1) {
        if (errno == EWOULDBLOCK) {
                /* log mekanizması ile mesaj oluşturulabilir */
        }
        else {
                /* log mekanizması ile mesaj oluşturulabilir */
        }
        _exit(EXIT_FAILURE);
    }
}

void sigterm_handler(int signo)
{
    /* cleanup processing */
}

void sighup_handler(int signo)
{
    read_config();        /* read_config asenkron sinyal güvenli bir fonksiyon olmalı */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Daemon gibi programlarda, kernel modüllerinde bir terminal bağlantısı olmadığı için hata mesajlarının ve diğer mesajların 
    ekrana yazdırılması mümkün olmayabilir ya da uygun olmayabilir. İşte bu tür durumlarda birtakım mesajların bir log'lama
    mekanizması yoluyla oluşturulması gerekebilmektedir.

    UNIX/Linux sistemlerinde kernel tarafından desteklenen kapsamlı bir log mekanizması bulunmaktadır. Bu log mekanizması 
    değişik kaynaklardan gelen mesajların biriktirilip saklanmasını sağlamaktadır. Bu merkezi log mekanizması aslında ilk BSD 
    sistemlerinde uygulanmıştır. Ancak daha sonra genelleştirilmiştir ve POSIX standartlarına yansıtılmıştır. Bu log mekanizması 
    genel olarak "syslog" ismiyle belirtilmektedir. Öncelikle Linux sistemleri için bu merkezi syslog mekanizmasının çalışma 
    biçimi hakkında bilgi vereceğiz. Bu çalışma açıklanırken genellikle şekillerden faydalanılmaktadır. Ancak burada text editörde 
    çalıştığımızdan dolayı bu şekli çizemiyoruz. Bunun için "Linux Programming Environment" kitabının 775'inci sayfasına başvurabilirsiniz. 
    Biz burada sözel anlatım uygulayacağız. Linux sistemlerindeki merkezi syslog mekanizması ile diğer sistemlerdeki syslog 
    mekanizması bazı ayrıntılar dışında birbirine benzemektedir.

    Merkezi syslog mekanizmasının üst seviye önemli bir bileşeni "syslogd" isimli bir daemon programdır. Bu program user mode'da
    çalışmaktadır. syslogd daemon programı iki kaynaktan mesajları alarak hedefte oluşturmaktadır. Loglamanın hedefi değiştirilebilmektedir. 
    syslogd daemon programının mesajları okuduğu iki kaynak şöyledir:

    1) Yerel kullanımlar için /dev/log isimli UNIX domain datagram soket dosyası
    2) Uzaktan kullanımlar için UDP 514 portu

    "/dev/log" isimli UDP UNIX domain soketine temelde iki aktör yazmaktadır. Bunlardan biri normal kullanıcılardır. Örneğin 
    biz bir daemon yazarken mesajları syslog isimli POSIX fonksiyonu ile oluştururuz. Bu POSIX fonksiyonu da aslında bu 
    sokete yazma yapmaktadır:

    user (syslog POSIX fonksiyonu) ---> /dev/log (UDP UNIX domain soket) <--- syslogd daemon okuyor

    /dev/log dosyasına yazan ikinci aktör ise aygıt sürücüler ve kernel modüllerdir. Bu kodlar kernel fonksiyonları ile "klogd" 
    isimli kernel mode'daki daemon programa mesajları aktarmaktadır. Bu kernel mod daemon programı da /dev/log dosyasına yazma 
    yapmaktadır:

    Aygıt sürücüler ve kernel modüller (printk) <--- klogd daemon'ı okuyor ---> /dev/log <--- syslogd daemon okuyor

    Loglama amacıyla user mod programlarda biz genellikle izleyen paragraflarda açıklayacağımız POSIX fonksiyonlarını kullanırız. 
    Ancak kernel mod programlarda (kernel modüllerinde ve aygıt sürücülerinde) genellikle printk gibi bir kernel fonksiyonu 
    kullanılmaktadır. Yukarıdaki şekillerden de gördüğünüz gibi her iki mekanizmada aynı loglama sistemine bilgileri aktarmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                96. Ders 11/11/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    User mode'da loglama işlemleri için üç POSIX fonksiyonu kullanılmaktadır:

    openlog
    syslog
    closelog

    openlog fonksiyonu loglama mekanizmasını başlatır, syslog fonksiyonu loglama işlemlerini yapar ve closelog fonksiyonu da 
    sistemi kapatır. openlog fonksiyonu aslında mekanizma için zorunlu bir fonksiyon değildir. openlog fonksiyonunun prototipi 
    şöyledir:

    #include <syslog.h>

    void openlog(const char *ident, int logopt, int facility);

    Fonksiyonun birinci parametresi log mesajlarında görüntülenecek program ismini belirtmektedir. Genellikle programcılar bu 
    parametre için program ismini argüman olarak verirler. Linux sistemlerinde bu parametreye NULL geçilebilmektedir. Bu durumda 
    sanki bu parametre için program ismi yazılmış gibi işlem yapılır. Ancak POSIX standartlarında NULL geçme durumu belirtilmemiştir. 
    İkinci parametre aşağıdaki sembolik sabitlerin bit or işlemine sokulmasıyla oluşturulabilir:

    LOG_PID
    LOG_CONS
    LOG_NDELAY
    LOG_ODELAY
    LOG_NOWAIT

    Burada LOG_PID log mesajında prosesin proses id'sinin de bulundurulacağını belirtir. LOG_CONS log mesajlarının aynı zamanda 
    default console'a ("/dev/console") da yazılacağını belirtmektedir. LOG_NDELAY bayrağı loglama sisteminin hemen açılması gerektiğini
    belirtir. Normal olarak bu sistem ilk loglama yapıldığında açılmaktadır. LOG_ODELAY zaten default durumdur. Loglama sistemi 
    ilk log işlemi yapıldığında açılır. LOG_NOWAIT alt prosesler söz konusu olduğunda loglama için alt proseslerin yaratılmasının 
    beklenmeyeceği anlamına gelmektedir. Bu parametre istenirse 0 olarak da geçilebilir. Ancak tipik uygulamalarda LOG_PID 
    biçiminde geçilmektedir.

    Fonksiyonun üçüncü parametresi log mesajını yollayan prosesin kim olduğu hakkında temel bir bilgi vermek için düşünülmüştür. 
    LOG_USER bir user proses tarafından bu loglamanın yapıldığını belirtmektedir. LOG_KERN mesajın kernel tarafından gönderildiğini 
    belirtir. LOG_DAEMON (POSIX'te yok) mesajın bir sistem daemon programı tarafından gönderildiğini belirtmektedir. LOG_LOCAL0'dan 
    LOG_LOCAL7'ye kadarki sembolik sabitler özel log kaynaklarını belirtmektedir. Bu parametre de 0 olarak geçilebilir. Bu durumda 
    LOG_USER değeri girilmiş gibi işlem yapılmaktadır. Ancak tipik olarak LOG_USER biçiminde geçilmektedir.

    openlog fonksiyonunun başarısı kontrol edilememektedir. Çünkü fonksiyonun geri dönüş değeri void biçimdedir.

    Örneğin:

    openlog("sample", LOG_PID, LOG_USER);

    Log mesajlarının aktarımı için asıl fonksiyon syslog isimli fonksiyondur. Fonksiyonun prototipi şöyledir:

    #include <syslog.h>

    void syslog(int priority, const char *format, ...);

    Fonksiyonun birinci parametresi mesajın öncelik derecesini (yani önemini) belirtir. Diğer parametreler tamamen printf fonksiyonundaki 
    gibidir. Öncelik değerleri şunlardır:

    LOG_EMERG
    LOG_ALERT
    LOG_CRIT
    LOG_ERR
    LOG_WARNING
    LOG_NOTICE
    LOG_INFO
    LOG_DEBUG

    En çok kullanılanlar error mesajları için LOG_ERR, uyarı mesajları için LOG_WARNING ve genel bilgilendirme mesajları 
    için LOG_INFO değerleridir. Buradaki değerler log mesajlarında görüntülenmektedir. Örneğin:

    syslog(LOG_ERR, "invalid operation");

    Yukarıda openlog fonksiyonunun çağrılmasının zorunlu olmadığını belirtmiştik. Bu durumda openlog fonksiyonundaki belirlemeler
    için default değerler alınmaktadır. Ancak istenirse openlog fonksiyonunun üçüncü parametresi syslog fonksiyonunun birinci 
    parametresiyle kombine edilebilir. Biz örneklerimizde openlog fonksiyonunu çağıracağız. syslog fonksiyonunun da geri dönüş 
    değerinin void olduğuna dikkat ediniz.

    Nihayet loglama mekanizması eğer açılmışsa onu kapatmak için closelog fonksiyonu kullanılmaktadır. Bu fonksiyon eğer loglama 
    mekanizması henüz açılmadıysa bir şey yapmamaktadır. Fonksiyonun prototipi şöyledir:

    #include <syslog.h>

    void closelog(void);

    Pekiyi log mesajları nereye aktarılmaktadır? İşte aslında işletim sistemlerinde hedef çeşitli biçimlerde değiştirilebilmektedir. 
    Ancak Linux'un ileri sürümlerinde default hedef "/var/log/syslog" dosyasıdır. Bu dosya sistemi disk tabanlı bir sistem değildir. 
    Dolayısıyla buradaki bilgiler reboot işleminde kalıcı değildir. Bu dosya uzayabileceği için bir kuyruk sistemi gibi oluşturulmaktadır. 
    Yani belli süre sonra önce yazılmış olan mesajlar kaybolabilmektedir. Dosyanın sonunu görebilmek için "tail" komutunu 
    kullanabilirsiniz. tail komutu default olarak dosyanın sonundaki 10 satırı göstermektedir. Ancak -n seçeneği ile daha fazla 
    satır görüntülenebilmektedir.

    Aşağıda loglama için basit bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <syslog.h>

int main(void)
{
    openlog("sample", LOG_PID, LOG_USER);

    syslog(LOG_INFO, "This is a test...");

    closelog();

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi syslog log mesajlarını nereye yazmaktadır? Yukarıda da belirttiğimiz gibi aslında syslog fonksiyonu log mesajlarını 
    "/dev/log" ismindeki UNIX domain datagram sokete yazmaktadır. Bu soketten okuma yapan "syslogd" isimli bir daemon vardır.
    Ancak yeni Linux sistemlerinde bu daemon'ın biraz daha gelişmiş biçimi olan "rsyslogd" daemon'ı da kullanılmaktadır. 
    Kursun yapıldığı zamanlarda Linux sistemlerinde yaygın olarak "rsyslogd" isimli daemon kullanılmaktadır. İşte aslında 
    log mesajlarının hangi dosyalara yazılacağına "syslogd" ya da "rsyslogd" daemon'ları karar vermektedir. Bu daemon'lar 
    çalışmaya başladıklarında default durumda "/etc/syslog.conf" ya da "/etc/rsyslog.conf" dosyalarına bakmaktadır. İşte aslında 
    bu daemon'ların hangi dosyalara yazacağı bu konfigürasyon dosyalarında sistem yöneticisi tarafından belirlenmektedir. 
    Ancak bu dosyada da belirleme yapılmamışsa default olarak pek çok mesaj grubu (error, warning, info) "/var/log/syslog" 
    dosyasına yazılmaktadır. O halde programcı syslog mesajları için default durumda bu dosyaya başvurmalıdır.

    Log dosyalarını incelemek için pek çok utility bulunmaktadır. Örneğin lnav, glogg, ksystemlog gibi. systemd init paketi 
    içerisindeki servis programları olan systemctl ve journalctl komutları ile de görüntüleme yapılabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de log mekanizmasının bir daemon programda kullanımına bir örnek verelim. Merkezi log mekanizması daha çok terminal 
    ilişkisi olmayan daemon'lar ve aygıt sürücüler gibi programlar tarafından kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/* mydaemond.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <signal.h>
#include <sys/file.h>
#include <syslog.h>

void read_config(void);
void check_instance(void);
void sigterm_handler(int signo);
void sighup_handler(int signo);
void exit_daemon(const char *msg);

#define DEF_FDT_SIZE        4096
#define LOCK_FILE_PATH        "/run/mydaemond.pid"
#define CONFIG_FILE            "/etc/mydaemond.conf"

void make_daemon(void)
{
    pid_t pid;
    long maxfd;
    int fd0, fd1, fd2;

    umask(0);

    if ((pid = fork()) == -1)
        exit_daemon("fork");

    if (pid != 0)
        _exit(EXIT_SUCCESS);

    if (setsid() == -1)
        exit_daemon("setsid");

    if (chdir("/") == -1)
        exit_daemon("chdir");

    errno = 0;
    if ((maxfd = sysconf(_SC_OPEN_MAX)) == -1)
        if (errno == 0)
            maxfd = DEF_FDT_SIZE;
        else
            exit_daemon("sysconf");

    for (long i = 0; i < maxfd; ++i)
        close(i);

    if ((fd0 = open("/dev/null", O_RDONLY)) == -1)
        exit_daemon("open");

    if ((fd1 = dup(fd0)) == -1)
        exit_daemon("dup");

    if ((fd2 = dup(fd0)) == -1)
        exit_daemon("dup");

    if (fd0 != 0 || fd1 != 1 || fd2 != 2) {
        syslog(LOG_ERR, "invalid file descriptors");
        _exit(EXIT_FAILURE);
    }
}

int main(void)
{
    struct sigaction sa;
    int fd;

    openlog("mydaemond", LOG_PID, LOG_USER);

    make_daemon();
    check_instance();
    read_config();

    sa.sa_handler = sigterm_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGTERM, &sa, NULL) == -1)
        exit_daemon("sigaction");

    sa.sa_handler = sighup_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGHUP, &sa, NULL) == -1)
        exit_daemon("sigaction");

    syslog(LOG_INFO, "ok, daemon is running");

    for (;;)
        pause();

    closelog();

    return 0;
}

void read_config(void)
{
    syslog(LOG_INFO, "mydaemon is reading configuration file...");
}

void check_instance(void)
{
    int fd;

    if ((fd = open(LOCK_FILE_PATH, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR)) == -1)
        exit_daemon("open");

    if (flock(fd, LOCK_EX|LOCK_NB) == -1) {
        if (errno == EWOULDBLOCK) {
            syslog(LOG_ERR, "Only one instance of this daemon can be run...");
            _exit(EXIT_FAILURE);
        }
        exit_daemon("flock");
    }
}

void sigterm_handler(int signo)
{
    syslog(LOG_INFO, "mydaemond is terminating...");

    closelog();

    _exit(EXIT_SUCCESS);
}

void sighup_handler(int signo)
{
    syslog(LOG_INFO, "mydaemond got SIGHUP and read config file...");

    read_config();        /* read_config asenkron sinyal güvenli bir fonksiyon olmalı */
}

void exit_daemon(const char *msg)
{
    syslog(LOG_ERR, "%s: %s", msg, strerror(errno));

    closelog();

    _exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux dünyasında boot işleminden sonra sistemin işler hale getirilebilmesi için ve servis yönetimlerinin yapılması 
    için kullanılan programların bulunduğu paketlere "init paketleri" denilmektedir. Örneğin init prosesinin kodları da bu 
    paketin içerisindedir.

    Yukarıda da belirtildiği gibi pek çok daemon aslında sistem boot edilirken çalıştırılmakta ve sistem kapatılana kadar 
    çalışır durumda kalmaktadır. Fakat bazı daemon'lar ise gerektiğinde çalıştırılıp, gerekmediğinde durdurulabilmektedir. 
    İşte UNIX/Linux sistemlerinde bu çalıştırma, durdurma gibi faaliyetler için "init paketleri" içerisinde daha yüksek seviyeli 
    araçlar bulundurulmaktadır. Tarihsel süreç içerisinde Linux sistemlerinde boot sonrası işlemlerden ve servis işlemlerinden 
    sorumlu üç önemli init paketi geliştirilmiştir:

    SysVinit (klasik)
    upstart
    systemd

    Kursun yapıldığı zaman diliminde ağırlıklı biçimde init paketi olarak "systemd" paketi kullanılmaktadır. Upstart paketinin 
    de sürdürümü artık yapılmamaktadır. Tabii eskiden kurulmuş Linux sistemleri ve bazı dağıtımlar hala bu paketi kullanıyor 
    olabilir. Biz kursumuzda "systemd" paketi hakkında temel bilgiler vereceğiz.

    Sisteminizde hangi init paketinin kurulu olduğunu çeşitli biçimlerde anlayabilirsiniz. Örneğin:

    $ sudo ls -l /proc/1/exe

    Buradan aşağıdakine benzer bir çıktı elde edilmiştir:

    lrwxrwxrwx 1 root root 0 Kas 11 11:45 /proc/1/exe -> /usr/lib/systemd/systemd

    Hangi init paketinin kullanıldığının anlaşılması için diğer bir yöntem de şöyle olabilir:

    $ cat /proc/1/status
    Name:    systemd
    Umask:    0000
    State:    S (sleeping)
    Tgid:    1
    Ngid:    0
    Pid:    1
    PPid:    0
    ...

    Sisteminizde hangi init paketinin kullanıldığını anlamanın diğer bir yolu da doğrudan ps komutunu "-p 1" seçeneği ile 
    kullanmaktır:

    $ ps -p 1 (ya da "ps -p 1 -o comm")
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    systemd paketi boot sonrasında devreye girecek programlardan ve daemon'lardan ve bazı faydalı komutlardan oluşmaktadır. 
    Bu komutlar genel olarak xxxctl biçiminde isimlendirilmiştir. Paketin en önemli komutu şüphesiz "systemctl" isimli komuttur.
    Servis yönetimleri temel olarak bu komut yoluyla yapılmaktadır. Yani "systemctl" komutu adeta systemd paketinin ön yüzü
    (front-end) gibidir.

    systemd paketi çalışmaya başladığında çeşitli konfigürasyon dosyalarına başvurmaktadır. Bu konfigürasyon dosyaları 
    "/etc/systemd" dizini içerisinde bulunmaktadır. Örneğin:

    $ ls -l /etc/systemd
    toplam 56
    -rw-r--r--  1 root root  615 Nis  1  2020 coredump.conf
    -rw-r--r--  1 root root 1042 Nis 22  2020 journald.conf
    -rw-r--r--  1 root root 1042 Nis 22  2020 logind.conf
    drwxr-xr-x  2 root root 4096 Nis 22  2020 network
    -rw-r--r--  1 root root  584 Nis  1  2020 networkd.conf
    -rw-r--r--  1 root root  529 Nis  1  2020 pstore.conf
    -rw-r--r--  1 root root  642 Mar 18  2021 resolved.conf
    -rw-r--r--  1 root root  790 Nis  1  2020 sleep.conf
    drwxr-xr-x 20 root root 4096 Ara 26  2021 system
    -rw-r--r--  1 root root 1759 Nis 22  2020 system.conf
    drwxr-xr-x  2 root root 4096 Tem  3  2021 system.conf.d
    -rw-r--r--  1 root root  604 Nis 22  2020 timesyncd.conf
    drwxr-xr-x  4 root root 4096 Tem  3  2021 user
    -rw-r--r--  1 root root 1185 Nis 22  2020 user.conf

    Buradaki .conf dosyalarının içi genel olarak "değişken=değer" biçiminde satırlardan oluşmaktadır. Kolaylık olsun diye
    özellikler # ile yorum satırı haline getirilip dosyada bulundurulmuştur. Sistem yönticisi ilgili satırdaki #'i kaldırarak
    o özelliği değiştirebilir.

    systemd paketi içerisinde pek çok çalıştırılabilir program da bulunmaktadır. Bu programların bazıları "daemon" biçiminde 
    yazılmıştır. systemd paketinin çalıştırılabilir (executable) program dosyaları "/lib/systemd" dizinindedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda systemd paketinin aynı zamanda bir "servis yöneticiliği" yaptığını da belirtmiştik. İşte bizim bir servisimizin 
    (daemon'umuzun) systemd yönetiminin kontrolüne girebilmesi için ismine "unit dosyası (unit file)" denilen bir dosyanın 
    hazırlanması gerekmektedir. Çeşitli amaçlar için çeşitli unit dosyaları kullanılmaktadır. Bu unit dosyalarının türlerine 
    göre uzantıları farklı olabilmektedir. Önemli unit dosya türleri şunlardır:

    - Service unit dosyası (.service)
    - Socket unit dosyası (.socket)
    - Slice unit dosyası (.slice)
    - Mount ve Automount unit dosyası (.mount, .automount)
    - Target unit dosyası (.target)
    - Timer unit dosyası (.timer)
    - Path unit dosyası (.path)
    - Swap unit dosyası (.swap)

    Programcının kendi daemon'ları için "service unit dosyası" oluşturması gerekmektedir. Unit dosyaları genel olarak 
    "/lib/systemd/system" dizini içerisindedir. Aslında "systemd" paketinin unit dosyaları için hangi dizinlere bakacağı 
    konfigürasyon dosyalarında ayarlanabilmektedir. Default bakılan dizinler sırasıyla şunlardır:

    /lib/systemd/system
    /etc/systemd/system
    /run/systemd/system
    /usr/lib/systemd/system
    /usr/local/lib/systemd/system

    Sistem yöneticileri genellikle kendi unit dosyalarını "/etc/systemd/system" dizini içerisine yerleştirmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sistem boot edildiğinde belli çalışma modellerinde belli servislerin aktive edilmesi ya da edilmemesi gerekebilmektedir. 
    Örneğin sistem grafik modda açılmayacaksa XWindow sistemine ilişkin daemon'ların aktif hale getirilmesi anlamsızdır. Benzer 
    biçimde sistemde bir network kartı yoksa veya wireless özelliği yoksa bunlara yönelik daemon'ların (inetd gibi) aktif hale
    getirilmesi gereksizdir.

    Eskiden klasik SystemVinit paketlerinde "çalışma düzeyi (run level)" denilen boot seçenekleri bulunuyordu. Sistem yöneticisi 
    de hangi servisin hangi çalışma düzeyinde aktive edeceğini belirtiyordu. Böylece sistem bir çalışma düzeyinde boot edildiğinde 
    yalnızca o çalışma düzeyinde aktif edilmesi gereken servisler (daemon'lar) aktive ediliyordu. Ancak bu çalışma düzeyi sistemi 
    kısıtlı bir seçenek oluşturmaktaydı. systemd paketinde bu "çalışma düzeyi" kullanımı kaldırılmıştır. Bunun yerine "target unit 
    dosyası" yöntemi kullanılmaya başlanmıştır. Bu sistemlerde "çalışma düzeyi" yerine ismine "target unit" denilen ve bir boot 
    seçeneğini belirten bir unit dosyası bulundurulur. Servisler de hangi target unit için aktive edileceklerini kendileri belirtirler.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Unit dosyalarının içerikleri konusunda çeşitli ayrıntılar vardır. Ancak biz burada bu ayrıntıların üzerinde durmayacağız. 
    Tipik bir "service unit dosyası" minimalist biçimde şöyle oluşturulmaktadır:

    # mydaemon.service

    [Unit]
    Description=Mydaemon Unit
    [Service]
    Type=forking
    ExecStart=/usr/bin/mydaemond
    [Install]
    WantedBy=multi-user.target

    Burada "Description" bizim unit dosyamızı temsil eden bir yazıdır. Type daemon'ın nasıl çalıştırılacağını belirtir. 
    Burada "forking" normal fork mekanizmasıyla çalıştırma anlamına gelmektedir. ExecStart daemon dosyasının nerede olduğunu 
    belirtmektedir. Daemon dosyaları tipik olarak "/usr/bin" dizinine ya da "/usr/local/bin" dizinlerine yerleştirilmelidir. 
    WantedBy hangi target ile sistem boot edildiğinde bu daemon'ın yükleneceğini belirtir. Buradaki "multi-user.target" isimli
    target unit klasik ve tipik boot işlemini belirtmektedir.

    Biz burada minimalist bir service unit dosyası oluşturduk. Servis unit dosyalarının içeriğine yönelik pek çok ayrıntı 
    vardır. Bunun resmi dokümanları için "man systemd.service" sayfasına başvurabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                97. Ders 12/11/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki adımları sırasıyla bir daha özetlemek istiyoruz. Daemon'ımızı systemd kontrolüne verebilmek için sırasıyla
    şu işlemlerin yapılması gerekmektedir.

    1) Bir service unit dosyası oluşturulmalıdır. Bu dosyanın uzantısı ".service" biçiminde olmalıdır. Bu dosyada daemon 
    programının yol ifadesi ExecStart ismiyle bulunmaktadır.
    2) Bu service unit dosyası "/etc/systemd/system" dizinine kopyalanmalıdır.
    3) Daemon programı "/usr/bin" ya da "usr/local/bin" dizinine kopyalanmalıdır. (Tabii bu dizin servis unit dosyasındaki
    ExecStart ile aynı olmalıdır.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki işlemler yapıldıktan sonra artık servis yönetimi "systemctl" komutuyla yapılabilir. Bu komutun çeşitli parametreleri
    vardır. Burada biz bazı parametreleri üzerinde açıklamalar yapacağız.

    - Daemon'ımızın boot zamanında devreye sokulması için "systemctl enable" komutunun kullanılması gerekmektedir. Komutun 
    genel biçimi şöyledir:

    sudo systemctl enable <daemon_ismi>

    Buradaki <daemon_ismi> service unit dosyasının ismidir. Uzantı belirtilmeyebilir. Örneğin:

    $ sudo systemctl enable mydaemon

    Eğer daemon'ın o anda yüklenmesi isteniyorsa ayrıca komuta --now seçeneği de eklenmelidir. Örneğin:

    $ sudo systemctl enable mydaemon --now

    - Daemon'ımızın boot sırasında devreye sokulmasının kaldırılması için "systemctl disable" komutu kullanılmaktadır. 
    Komutun genel biçimi şöyledir:

    $ sudo systemctl disable <daemon_ismi>

    Örneğin:

    $ sudo systemctl disable mydaemon

    - Daemon'ı çalıştırmak için "systemctl start" komutu kullanılmaktadır. Komutun genel biçimi şöyledir:

    $ sudo systemctl start <daemon_ismi>

    - Daemon'ı durdurmak için "systemctl stop" komutu kullanılmalıdır. Komutun genel biçimi şöyledir:

    $ sudo systemctl stop <daemon_ismi>

    Daemon durdurulurken ona default SIGTERM sinyali gönderilmektedir. systemd SIGTERM sinyalini gönderdikten sonra bir süre
    bekler, daemon hala sonlanmamışsa bu kez ona SIGKILL sinyalini gönderir.

    - Daemon'ımızın durumunu anlamak için "systemctl status" komutu kullanılır. Komutun genel biçimi şöyledir:

    systemctl status [daemon_ismi]

    Örneğin:

    $ systemctl status mydaemon

    - Bazen daemon'ımızı "restart" etmek isteyebiliriz. restart önce durdurup sonra çalıştırmak anlamına gelmektedir. Komutun
    genel biçimi şöyledir:

    sudo systemctl restart <daemon_ismi>

    Örneğin:

    $ sudo systemctl restart mydaemon

    - Daemon'ımızın boot zamanında devreye girip girmeyeceğini "systemctl status" komutunun yanı sıra "systemctl is-enabled"
    komutuyla da anlayabiliriz. Örneğin:

    $ systemctl is-enabled mydaemon

    - systemd tüm unit dosyalarını inceleyerek bir çalıştırma ağacı oluşturmaktadır. Biz bir unit dosyasını değiştirdiğimizde
    bu ağacın yeniden oluşturulması gerekmektedir. Bunun için "systemctl daemon-reload" komutu kullanılmaktadır. Komutun genel 
    biçimi şöyledir:

    $ sudo systemctl daemon-reload

    Komutun parametresiz olduğuna dikkat ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz prosesler arası haberleşmeyi iki grubu ayırmıştık:

    1) Aynı makinenin prosesleri arasında haberleşme
    2) Farklı makinelerin prosesleri arasında haberleşme

    Kursumuzda aynı makinenin prosesleri arasındaki haberleşmeleri (boru haberleşmeleri, mesaj kuyrukları) görmüştük. Şimdi farklı 
    makinelerin prosesleri arasındaki haberleşmeler üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Farklı makinelerin prosesleri arasında haberleşme (yani bir ağ içerisinde haberleşme), aynı makinenin prosesleri arasındaki 
    haberleşmeye göre daha karmaşık unsurlar içermektedir. Çünkü burada ilgili işletim sisteminin dışında pek çok belirlemelerin 
    önceden yapılmış olması gerekir. İşte ağ haberleşmesinde önceden belirlenmiş kurallar topluluğuna "protokol" denilmektedir. 
    Ağ haberleşmesi için tarihsel süreç içerisinde pek çok protokol ailesi gerçekleştirilmiştir. Bunların bazıları büyük şirketlerin 
    kontrolü altındadır ve hala kullanılmaktadır. Ancak açık bir protokol ailesi olan "IP protokol ailesi" günümüzde farklı 
    makinelerin prosesleri arasındaki haberleşmede hemen her zaman tercih edilen protokol ailesidir.

    Protokol ailesi (protocol family) denildiğinde birbirleriyle ilişkili bir grup protokol anlaşılmaktadır. Bir protokol ailesinin 
    pek çok protokolü başka protokollerin üzerine konumlandırılmış olabilmektedir. Böylece protokol aileleri katmanlı (layered) 
    bir yapıya sahip olmuştur. Üst seviye bir protokol alt seviye protokolün "zaten var olduğu fikriyle" o alt seviye protokol 
    kullanılarak oluşturulmaktadır. Bu katmanlı yapıyı prosedürel programlama tekniğinde "zaten var olan bir fonksiyonu kullanarak 
    daha yüksek seviyeli bir fonksiyon yazmaya" benzetebiliriz.

    Ağ haberleşmesi için katmanlı bir protokol yapısının kavramsal olarak nasıl oluşturulması gerektiğine yönelik ISO tarafından 
    80'li yılların başlarında "OSI Model (Open System Interconnection Model)" isimli bir referans dokümanı oluşturulmuştur. OSI 
    model bir gerçekleştirim değildir. Kavramsal bir referans dokümanıdır. Ancak bu referans dokümanı pek çok çalışma için bir 
    zemin oluşturmuştur. OSI referans modeline göre bir protokol ailesinde tipik olarak 7 katman bulunmalıdır. Bu katmanlar 
    aşağıdaki gibi birbirlerini üzerine oturtulmuştur:

    Uygulama Katmanı (Application Layer)
    Sunum Katmanı (Presentation Layer)
    Oturum Katmanı (Session Layer)
    Aktarım Katmanı (Transport Layer)
    Network Katmanı (Network Layer)
    Veri Bağlantı Katmanı (Data Link Layer)
    Fiziksel Katman (Physical Layer)

    - En aşağı seviyeli elektriksel tanımlamaların yapıldığı katmana "fiziksel katman (physical layer)" denilmektedir. (Örneğin 
    kabloların, konnektörlerin özellikleri, akım, gerilim belirlemeleri vs. gibi.) Yani bu katman iletişim için gereken fiziksel 
    ortamı betimlemektedir.

    - Veri bağlantı katmanı (data link layer) artık bilgisayarlar arasında fiziksel bir adreslemenin yapıldığı ve bilgilerin paketlere 
    ayrılarak gönderilip alındığı bir ortam tanımlarlar. Yani bu katmanda bilgilerin gönderildiği ortam değil, gönderilme biçimi 
    ve fiziksel adresleme tanımlanmaktadır. Ağ üzerinde her birimin donanımsal olarak tanınabilen fiziksel bir adresinin olması 
    gerekir. Örneğin bugün kullandığımız Ethernet kartları "Ethernet Protocolü (IEEE 802.11)" denilen bir protokole uygun tasarlanmıştır. 
    Bu ethernet protokolü OSI'nin fiziksel ve veri bağlantı katmanına karşılık gelmektedir. Ethernet protokolünde yerel ağa bağlı 
    olan her birimin ismine "MAC adresi" denilen 6 byte'lık fiziksel bir adresi vardır. Ethernet protokolünde MAC adresini bildiğimiz 
    ağa bağlı bir birime bilgi gönderebiliriz. Bilgiler "paket anahtarlaması packet switching)" denilen teknikle gönderilip alınmaktadır. 
    Bu teknikte byte'lar bir paket adı altında bir araya getirilir sonra ilgili fiziksel katmanla seri bir biçimde gönderilir. 
    Bugün kullandığımız yerel ağlarda aslında bilgi bir birimden diğerine değil hub'lar yoluyla ağa bağlı olan tüm birimlere
    gönderilmektedir. Ancak bunlardan yalnızca biri gelen bilgiyi sahiplenmektedir. Bugün kablosuz haberleşmede kullanılan 
    "IEEE 802.11" protokolü de tıpkı Ethernet protokolü gibi hem bir fiziksel katman hem de veri bağlantı katmanı tanımlamaktadır.

    Fiziksel katman ve veri katmanı oluşturulduğunda artık biz yerel ağda bir birimden diğerine paket adı altında bir grup byte'ı 
    gönderip alabilir duruma gelmekteyiz.

    - Ağ Katmanı (network layer) artık "internetworking" yapmak için gerekli kuralları tanımlamaktadır. "Internetworking" terimi 
    "network'lerden oluşan network'ler" anlamına gelir. Aynı fiziksel ortamda bulunan ağlara "Yerel Ağlar (Local Area Networks)" 
    denilmektedir. Bu yerel ağlar "router" denilen aygıtlarla birbirlerine bağlanmaktadır. Böylece "internetworking" ortamı 
    oluşturulmaktadır. Tabii böyle bir ortamda artık ağa bağlı birimler için fiziksel adresler kullanılamaz. Bu ortamlarda ağa 
    bağlı birimlere mantıksal bir adreslerin atanması gerekmektedir. İşte "network katmanı" internetworking ortamı içerisinde bir 
    birimden diğerine bir paket bilginin gönderilmesi için gereken tanımlamaları içermektedir. Ağ katmanı bu nedenle en önemli 
    katmandır. Ağ katmanında artık fiziksel adresleme değil, mantıksal adresleme sistemi kullanılmaktadır. Ayrıca bilgilerin 
    paketlere ayrılarak router'lardan dolaşıp hedefe varması için rotalama mekanizması da bu katmanda tanımlanmaktadır. Yani 
    elimizde yalnızca ağ katmanı ve onun aşağısındaki katmanlar varsa biz artık "internetworking" ortamında belli bir kaynaktan 
    belli bir hedefe paketler yollayıp alabiliriz.

    - Aktarım katmanı (transport layer) network katmanının üzerindedir. Aktarım katmanında artık kaynak ile hedef arasında 
    mantıksal bir bağlantı oluşturulabilmekte ve veri aktarımı daha güvenli olarak yapılabilmektedir. Aynı zamanda aktarım 
    katmanı "multiplex" bir kaynak-hedef yapısı da oluşturmaktadır. Bu sayede bilgiler hedefteki spesifik bir programa 
    gönderilebilmektedir. Bu işleme "port numaralandırması" da denilmektedir. Bu durumda aktarım katmanında tipik şu işlemlere 
    yönelik belirlemeler bulunmaktadır:

        - Bağlantının nasıl yapılacağına ilişkin belirlemeler
        - Ağ katmanından gelen paketlerin stream tabanlı organizasyonuna ilişkin belirlemeler
        - Veri aktarımını güvenli hale getirmek için akış kontrolüne ilişkin belirlemeler
        - Gönderilen bilgilerin hedefte ayrıştırılmasını sağlayan protokol port numaralandırmasına ilişkin belirlemeler

    - Oturum katmanı (session) katmanı pek çok protokol ailesinde yoktur. Görevi oturum açma kapama gibi yüksek seviyeli bazı 
    belirlemeleri yapmaktır. Örneğin bu katmanda bir grup kullanıcıyı bir araya getiren oturumların nasıl açılacağına ve nasıl 
    kapatılacağına ilişkin belirlemeler bulunmaktadır. IP protokol ailesinde OSI'de belirtilen biçimde bir oturum katmanı yoktur.

    - Sunum katmanı (presentation layer) verilerin sıkıştırılması, şifrelenmesi gibi tanımlamalar içermektedir. Yine bu katman 
    IP protokol ailesinde OSI'de belirtildiği biçimde bulunmamaktadır.

    - Nihayet protokol ailesini kullanarak yazılmış olan tüm kullanan bütün programlar aslında uygulama katmanını oluşturmaktadır. 
    Yani ağ ortamında haberleşen her program zaten kendi içerisinde açık ya da gizli bir protokol oluşturmuş durumdadır. Örneğin 
    IP protokol ailesindeki somut işleri yapmakta kullanılan Telnet, SSH, HTTP, POP3, FTP gibi protokoller uygulama katmanı 
    protokolleridir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bugün farklı makinelerin prosesleri arasında en çok kullanılan protokol ailesi IP (Internet Protocol) denilen protokol 
    ailesidir. IP protokol ailesi temel ve yardımcı pek çok protokolden oluşmaktadır. Aileye ismini veren ailenin ağ katmanı 
    (network layer) protokolü olan IP protokolüdür. Pekiyi pekiyi IP ailesi neden bu kadar popüler olmuştur? Bunun en büyük 
    nedeni 1983 yılında hepimizin katıldığı Internet'in (I'nin büyük yazıldığına dikkat ediniz) bu aileyi kullanmaya başlamasıdır. 
    Böylece IP ailesini kullanarak yazdığımız programlar hem aynı bilgisayarda hem yerel ağımızdaki bilgisayarlarda hem de 
    Internet'te çalışabilmektedir. Aynı zamanda IP ailesinin açık bir (yani bir şirketin malı değil) protokol olması da cazibeyi 
    çok artırmıştır.

    IP ailesi 70'li yıllarda Vint Cerf ve Bob Kahn tarafından geliştirilmiştir. IP ismi Internet Protocol'den gelmektedir. 
    Burada internet "internetworking" anlamında kullanılmıştır. Cerf ve Kahn 1974 yılında önce TCP protokolü üzerinde sonra da 
    IP protokolü üzerinde çalışmışlar ve bu protokollerin ilk versiyonlarını oluşturmuşlardır.

    Bugün hepimizin bağlandığı büyük ağa "Internet" denilmektedir. Bu ağ ilk kez 1969 yılında Amerika'da Amerikan Savunma Bakanlığı'nın 
    bir soğuk savaş projesi biçiminde başlatıldı. O zamana kadar yalnızca kısıtlı ölçüde yerel ağlar vardı. 1969 yılında ilk kez 
    bir "WAN (Wide Area Network)" oluşturuldu. Bu proje Amerikan Savunma Bakanlığı'nın DARPA isimli araştırma kurumu tarafından 
    başlatılmıştır ve projeye "ARPA.NET" ismi verilmiştir. Daha sonra bu ağa Amerika'daki çeşitli devlet kurumları ve üniversiteler 
    katıldı. Sonra ağ Avrupa'ya sıçradı. 1983 yılında bu ağ NCP protokolünden IP protokol ailesine geçiş yaptı. Bundan sonra 
    artık APRA.NET ismi yerine "Internet" ismi kullanılmaya başlandı. (Internet sözcüğü I harfi küçük harfle yazılırsa "internetworking" 
    anlamında büyük harfle yazılırsa bugün katıldığımız dev ağ anlamında kullanılmaktadır.) Biz de IP ailesini kullanarak kendi 
    "internetworking" ortamımızı oluşturabiliriz. Örneğin bir şirket hiç Internet'e bağlanmadan kendi internet'ini oluşturabilir. Buna 
    eskiden "intranet" denirdi. IP protokol ailesi herkesin kendi internet'ini oluşturabilmesi için bütün gerekli protokolleri 
    barındırmaktadır. Tabii sinerji bakımından herkes zaten var olan ve "Internet" denilen bu dev ağa bağlanmayı tercih etmektedir.

    IP protokol ailesi 4 katmanlı bir ailedir. Bu ailede "fiziksel ve veri bağlantı katmanı" bir arada düşünülebilir. Bugün bunlar 
    Ethernet ve Wireless protokolleri biçiminde kullanılmaktadır. IP ailesinin ağ katmanı aileye ismini veren IP protokolünden 
    oluşmaktadır. Aktarım katmanı ise TCP ve UDP protokollerinden oluşur. Nihayet TCP üzerine oturtulmuş olan HTTP, TELNET, SSH, 
    POP3, IMAP gibi pek çok protokol ailenin uygulama katmanını oluşturmaktadır. Tabii IP protokol ailesinde bu hiyerarşik yapıyla 
    ilgili olmayan irili ufaklı pek çok protokol de bulunmaktadır.

    +---------------------+-------------------------------+
    |  Application Layer  |   HTTP, SSH, POP3, IMAP, ...  |
    +---------------------+---------------+---------------+
    |    Transport Layer  |      TCP      |      UDP      |
    +---------------------+---------------+---------------+
    |     Network Layer   |               IP              |
    +---------------------+-------------------------------+
    |  Physical/Data Link |           Ethernet            |
    |       Layer         |           Wireless            |
    +---------------------+-------------------------------+

    IP protokolü tek başına kullanılırsa ancak ağa bağlı bir birimden diğerine bir paket gönderip alma işini yapar. Bu nedenle 
    bu protokolün tek başına kullanılması çok seyrektir. Uygulamada genellikle "aktarım (transport) katmanına" ilişkin TCP ve 
    UDP protokolleri kullanılmaktadır. IP ailesinin uygulama katmanındaki HTTP, SSH, POP3, IMAP, FTP gibi önemli protokollerinin 
    hepsi TCP protokolü üzerine oturtulmuştur. Ailede genellikle TCP protokolü kullanıldığı için buna kısaca "TCP/IP" de denilmektedir.

    IP protokolü ailenin en önemli ve taban protokolüdür. IP protokolünde ağa bağlı olan ve kendisine IP adresiyle erişilebilen 
    her birime "host" denilmektedir. IP protokolü bir host'tan diğerine bir paket (buna IP paketi denilmektedir) bilginin 
    gönderimine ilişkin tanımlamaları içermektedir. IP protokolünde her host'un ismine "IP adresi" denilen mantıksal bir adresi 
    vardır. Paketler belli bir IP adresinden diğerine gönderilmektedir. IP protokolünün iki önemli versiyonu vardır: IPv4 ve 
    IPv6. Bugün her iki versiyon da aynı anda kullanılmaktadır. IPv4'te IP adresleri 4 byte uzunluktadır. (Protokolün tasarlandığı 
    70'li yıllarda 4 byte adres alanı çok geniş sanılmaktaydı). IPv6'da ise IP adresleri 16 byte uzunluğundadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP bağlantılı (connection-oriented), UDP bağlantısız (connectionless) bir protokoldür. Buradaki bağlantı IP paketleriyle 
    yapılan mantıksal bir bağlantıdır. Bağlantı sırasında gönderici ve alıcı birbirlerini tanır ve haberleşme boyunca haberleşmenin 
    güvenliği için birbirleriyle konuşabilirler. Bağlantılı protokol "client-server" tarzı bir haberleşmeyi akla getirmektedir. 
    Bu nedenle TCP/IP denildiğinde akla "client-server" haberleşme gelmektedir. TCP modelinde client önce server'a bağlanır. 
    Sonra iletişim güvenli bir biçimde karşılıklı konuşmalarla sürdürürlür. Tabii TCP bunu yaparken IP paketlerini yani IP 
    protokolünü kullanmaktadır. UDP protokolü bağlantısızdır. Yani UDP protokolünde bizim bir host'a UDP paketi gönderebilmemiz 
    için bir bağlantı kurmamıza gerek kalmaz. Örneğin biz televizyon yayını UDP modeline benzemektedir. Verici görüntüyü yollar 
    ancak alıcının alıp almadığıyla ilgilenmez. Vericinin görüntüyü yollaması için alıcıyla bağlantı kurması gerekmemektedir.

    TCP "stream tabanlı", UDP ise "datagram (paket) tabanlı" bir protokoldür. Stream tabanlı protokol demek tamamen boru haberleşmesinde 
    olduğu gibi gönderen tarafın bilgilerinin bir kuyruk sistemi eşliğinde oluşturulması ve alıcının istediği kadar byte'ı parça 
    parça okuyabilmesi demektir. Datagram tabanlı haberleşme demek tamamen mesaj kuyruklarında olduğu gibi bilginin paket paket 
    iletilmesi demektir. Yani datagram haberleşmede alıcı taraf gönderen tarafın tüm paketini tek hamlede almak zorundadır. 
    Stream tabanlı haberleşmenin oluşturulabilmesi için IP paketlerine bir numara verilmesi ve bunların hedefte birleştirilmesi 
    gerekmektedir. Örneğin biz bir host'tan diğerine 10K'lık bir bilgi gönderelim. TCP'de bu bilgi IP paketlerine ayrılıp numaralandırılır. 
    Bunlar hedefte birleştirilir ve sanki 10000 byte'lık ardışıl bir bilgiymiş gibi gösterilir. Halbuki UDP'de paketler birbirinden 
    bağımsızdır. Dolayısıyla bunların hedefte birleştirilmesi zorunlu değildir. IP protokolünde bir host birtakım paketleri diğer 
    host'a gönderdiğinde alıcı taraf bunları aynı sırada almayabilir. Bu özelliğinden dolayı TCP, ailenin en çok kullanılan transport 
    katmanı durumundadır.

    TCP güvenilir (reliable), UDP güvenilir olmayan (unreliable) bir protokoldür. TCP'de mantıksal bir bağlantı oluşturulduğu için 
    yolda kaybolan paketlerin telafi edilmesi mümkündür. Alıcı taraf gönderenin bilgilerini eksiksiz ve bozulmadan aldığını bilir.
    Aynı zamanda TCP'de "bir akış kontrolü (flow control)" de uygulanmaktadır. Akış kontrolü sayesinde alıcı taraf tampon taşması 
    durumuna karşı gönderici tarafı durdurabilmektedir. Halbuki UDP'de böyle bir mekanizma yoktur. Gönderen taraf alıcının bilgiyi 
    alıp almadığını bilmez.

    Tüm bunlar eşliğinde IP ailesinin en çok kullanılan transport katmanının neden TCP olduğunu anlayabilirsiniz. Uygulama katmanındaki
    protokoller hep TCP kullanmaktadır.

    Yukarıda da belirttiğimiz gibi IP protokol ailesinde ağa bağlı olan birimlere "host" denilmektedir. Host bir bilgisayar olmak 
    zorunda değildir. İşte bu protokolde her host'un mantıksal bir adresi vardır. Bu adrese IP adresi denilmektedir. IP adresi 
    IPv4'te 4 byte uzunlukta, IPv6'da 16 byte uzunluktadır. Ancak bir host'ta farklı programlar farklı host'larla haberleşiyor 
    olabilir. İşte aynı host'a gönderilen IP paketlerinin o host'ta ayrıştırılması için "protokol port numarası" diye isimlendirilen 
    içsel bir numara uydurulmuştur. Port numarası bir şirketin içerisinde çalışanların dahili numarası gibi düşünülebilir. Port 
    numaraları IPv4'te ve IPv6'da 2 byte'la ifade edilmektedir. İlk 1024 port numarası IP ailesinin uygulama katmanındaki protokoller 
    için ayrılmıştır. Bunlara "well known ports" denilmektedir. Bu nedenle programcıların port numaralarını 1024'ten büyük olacak 
    biçimde almaları gerekir. Bir host TCP ya da UDP kullanarak bir bilgi gönderecekse bilginin gönderileceği host'un IP numarasını 
    ve bilginin orada kime gönderileceğini anlatan port numarasını belirtmek zorundadır. IP numarası ve port numarası çiftine 
    "IP End Point" de denilmektedir. Bilgiyi almak isteyen program kendisinin hangi portla ilgilendiğini de belirtmek durumundadır. 
    Örneğin biz bir host'ta çalışacak bir TCP/IP ya da UDP/IP program yazmak istiyorsak o host'un belli bir port numarasına gelen 
    bilgilerle ilgileniriz. Port numarası  kavramının IP protokolünde olmadığına TCP ve UDP protokollerinde bulunduğuna dikkat 
    ediniz.

    TCP ve UDP protokollerinin IP protokolü üzerine oturtulduğunu belirtmiştik. Bu ne anlama gelmektedir? Biz TCP kullanarak 
    belli bir IP numarası ve port numarası (end point) belirterek bir grup byte'ı göndermiş olalım. Aslında bu byte topluluğu
    bir TCP paketi oluşturularak bir paket biçiminde yola çıkarılmaktadır. Ancak ana network protokolü IP'dir. O halde bu 
    paketin aslında bir IP paketi olarak gönderilmesi gerekir. Bir IP paketi iki kısımdan oluşmaktadır: IP Header ve IP data

    +-------------------------+
    |        IP Header        |
    +-------------------------+
    |         IP Data         |
    +-------------------------+

    IP Header'da söz konusu IP paketinin hedefe ulaştırılabilmesi için gerekli bilgiler bulunur. Gönderilecek asıl bilgi bu 
    paketin "IP Data" kısmındadır. İşte bir TCP paketi aslında bir IP paketi olarak IP paketinin "IP Data" kısmına gömülerek
    gönderilmektedir. Bu durumda TCP paketinin genel görünümü şöyledir:

    +-------------------------+
    |        IP Header        |
    +-------------------------+   <---+
    |        TCP Header       |       |
    +-------------------------+     IP Data
    |         TCP Data        |       |
    +-------------------------+   <---+

    Yani TCP paketinin header ve data kısmı aslında IP paketinin data kısmı gibi oluşturulmaktadır. Böylece yolculuk eden 
    paket aslında bir TCP paketi değil IP paketidir. TCP bilgileri bu IP paketinin data kısmında bulunmaktadır. IPv4 başlık 
    uzunluğu 20 byte'dır. IPv4 paket başlık alanları aşağıdaki verilmiştir.

    <------- Byte 1 -------><------- Byte 2 -------><------- Byte 3 -------><------- Byte 4 ------->
    +-----------+-----------+----------------------+-----------------------------------------------+             ^
    |  Version  |    IHL    |    Type of Service   |                  Total Length                 |  (4 bytes)  |
    | (4 bits)  | (4 bits)  |       (8 bits)       |                   (16 bits)                   |             |
    +-----------+-----------+----------------------+-----------+-----------------------------------+             |
    |                 Identification               |   Flags   |           Fragment Offset         |  (4 bytes)  |
    |                   (16 bits)                  |  (3 bits) |              (13 bits)            |             |
    +-----------------------+----------------------+-----------+-----------------------------------+             |
    |   Time to Live (TTL)  |       Protocol       |                 Header Checksum               |  (4 bytes)  |  20 bytes
    |         (8 bits)      |       (8 bits)       |                    (16 bits)                  |             |
    +-----------------------+----------------------+-----------------------------------------------+             |
    |                                  Source IP Address (32 bits)                                 |  (4 bytes)  |
    +----------------------------------------------------------------------------------------------+             |
    |                               Destination IP Address (32 bits)                               |  (4 bytes)  |
    +----------------------------------------------------------------------------------------------+             v
    |                            Segment (L4 protocol (TCP/UDP) + Data)                            |
    +----------------------------------------------------------------------------------------------+

    TCP header'ı 20 byte'tan oluşmaktadır ve yapısı aşağıdaki gibidir.

    <------- Byte 1 -------><------- Byte 2 -------><------- Byte 3 -------><------- Byte 4 ------->
    +----------------------------------------------+-----------------------------------------------+             ^
    |                  Source Port                 |                Destination Port               |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             |
    |                                        Sequence Number                                       |  (4 bytes)  |
    |                                          (32 bits)                                           |             |
    +----------------------------------------------------------------------------------------------+             |
    |                                    Acknowledgement Number                                    |  (4 bytes)  |
    |                                          (32 bits)                                           |             |  20 bytes
    +-----------+----------------+-----------------+-----------------------------------------------+             |
    |Header Len.|    Reserved    |   Control Bits  |                  Window Size                  |  (4 bytes)  |
    |  (4 bits) |    (6 bits)    |     (6 bits)    |                   (16 bits)                   |             |
    +-----------+----------------+-----------------+-----------------------------------------------+             |
    |                   Checksum                   |                     Urgent                    |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             v
    |                                           Options                                            |
    |                                        (0 or 32 bits)                                        |
    +----------------------------------------------------------------------------------------------+
    |                                    Application Layer Data                                    |
    |                                         (Size Varies)                                        |
    +----------------------------------------------------------------------------------------------+

    UDP header'ı 8 byte'tan oluşmaktadır ve yapısı aşağıdaki gibidir.

    <------- Byte 1 -------><------- Byte 2 -------><------- Byte 3 -------><------- Byte 4 ------->
    +----------------------------------------------+-----------------------------------------------+             ^
    |                  Source Port                 |                Destination Port               |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             |  8 bytes
    |                 Header Length                |                   Checksum                    |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             v
    |                                    Application Layer Data                                    |
    |                                         (Size Varies)                                        |
    +----------------------------------------------------------------------------------------------+

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                98. Ders 18/11/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    IP haberleşmesi (yani paketlerin, oluşturulması, gönderilmesi alınması vs.) işletim sistemlerinin çekirdekleri tarafından 
    yapılmaktadır. Tabii User mod programlar için sistem çağrılarını yapan API fonksiyonlarına ve kütüphanelerine gereksinim 
    vardır. İşte bunların en yaygın kullanılanı "soket kütüphanesi" denilen kütüphanedir. Bu kütüphane ilk kez 1983 yılında 
    BSD 4.2'de gerçekleştirilmiştir ve pek çok UNIX türevi sistem bu kütüphaneyi aynı biçimde benimsemiştir. Microsoft'un 
    Windows sistemleri de bu API kütüphanesini desteklemektedir. Bu kütüphaneye "Winsock" ya da kısaca "WSA (Windows Socket API)" 
    denilmektedir. Microsoft'un Winsock kütüphanesi hem klasik BSD soket API fonksiyonlarını hem de başı WSAXXX ile başlayan 
    Windows'a özgü API fonksiyonlarını barındırmaktadır. Yani UNIX/Linux sistemlerinde yazdığımız soket programlarını küçük 
    değişikliklerle Windows sistemlerine de port edebiliriz.

    Soket kütüphanesi yalnızca IP protokol ailesi için tasarlanmış bir kütüphane değildir. Bütün protokollerin ortak kütüphanesidir.
    Bu nedenle kütüphanedeki fonksiyonlar daha genel biçimde tasarlanmıştır.

    Biz soket fonksiyonlarını kullanırken aslında arka planda işlemler TCP/IP ve UDP/IP protokollerine uygun bir biçimde 
    gerçekleştirilmektedir. Örneğin biz send soket fonksiyonu ile bir bilgiyi göndermek istediğimizde aslında bu fonksiyon 
    arka planda bir TCP paketi dolayısıyla da bir IP paketi oluşturarak protokole uygun bir biçimde bu bilgiyi göndermektedir. 
    Soket kütüphanesinin yalnızca bir API arayüzü olduğuna dikkat ediniz.

    Berkeley soket kütüphanesi POSIX tarafından desteklenmektedir. Yani burada göreceğimiz soket fonksiyonları aynı zamanda 
    birer POSIX fonksiyonudur. Soket fonksiyonlarının prototiplerinin önemli bir bölümü <sys/socket.h> dosyası içerisinde 
    bulunmaktadır. Ancak bu başlık dosyasının dışında bazı fonksiyonlar için başka başlık dosyalarının da include edilmesi 
    gerekmektedir.

    Ağ protokollerinde "endian'lık" da önemli olmaktadır. IP ailesi "Big Endian" formata göre tasarlanmıştır. Buna protokolde
    "network byte ordering" denilmektedir. Dolayısıyla bizim soket API'lerine verdiğimiz birtakım değerlerin big endian formata 
    dönüştürülmesi gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz kursumuzda önce soket kütüphanesi ile TCP/IP client-server programların oluşturulması konusunu ele alacağız. 
    Sonra TCP/IP haberleşmesinin bazı protokol detaylarından bahsedeceğiz. Sonra da UDP/IP haberleşme üzerinde duracağız. 
    Berkeley soket kütüphanesinin bazı fonksiyonları hem TCP/IP hem de UDP/IP haberleşmede ortak olarak kullanılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir TCP/IP uygulamasında server ve client olmak üzere iki ayrı program yazılır: "TCP Server Program" ve "TCP Client Program".
    Biz önce TCP server programın daha sonra da TCP client programın yazımı üzerinde duracağız. Tabii TCP server programın 
    üzerinde dururken zaten bazı ortak soket fonksiyonlarını da göreceğiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir TCP server program tipik olarak aşağıdaki soket API'lerinin sırayla çağrılmasıyla gerçekleştirilmektedir:

    socket ---> bind ---> listen ---> accept ---> send/recv ya da read/write ---> shutdown ---> close

    Haberleşme için öncelikle bir soket nesnesinin yaratılması gerekmektedir. Bu işlem socket isimli fonksiyonla yapılmaktadır.
    socket fonksiyonu bir soket nesnesi (handle alanı) yaratır ve bize bir dosya betimleyicisi verir. Biz diğer fonksiyonlarda 
    soket biçiminde isimlendirilen bu betimleyiciyi kullanırız. socket fonksiyonunun prototipi şöyledir:

    #include <sys/socket.h>

    int socket(int domain, int type, int protocol);

    Fonksiyonun birinci parametresi kullanılacak protokol ailesini belirtir. Bu parametre AF_XXX (Address Family) biçimindeki 
    sembolik sabitlerden biri olarak girilir. IPv4 için bu parametreye AF_INET, IPv6 için AF_INET6 girilmelidir. UNIX domain 
    soketler için bu parametre AF_UNIX olarak girilmelidir.

    Fonksiyonun ikinci parametresi kullanılacak protokolün stream tabanlı mı yoksa datagram tabanlı mı olacağını belirtmektedir. 
    Stream soketler için SOCK_STREAM, datagram soketler için SOCK_DGRAM kullanılmalıdır. Ancak başka soket türleri de vardır. 
    TCP protokolü stream tabanlı olduğu için TCP uygulamalarında bu parametre SOCK_STREAM olarak girilmelidir. Ancak UDP datagram 
    tabanlı olduğu için UDP uygulamalarında bu parametre SOCK_DGRAM biçiminde girilmelidir.

    Fonksiyonun üçüncü parametresi transport katmanındaki protokolü belirtmektedir. Ancak zaten ikinci parametreden transport 
    protokolü anlaşılıyorsa üçüncü parametre 0 olarak geçilebilmektedir. Örneğin IP ailesinde üçüncü parametreye gerek duyulmamaktadır. 
    Çünkü ikinci parametredeki SOCK_STREAM zaten TCP'yi, SOCK_DGRAM ise zaten UDP'yi anlatmaktadır. Fakat yine de bu parametreye 
    istenirse IP ailesi için IPPROTO_TCP ya da IPPROTO_UDP girilebilir. (Bu sembolik sabitler <netinet/in.h> içerisindedir.) 

    socket fonksiyonu başarı durumunda soket betimleyicisine, başarısızsa -1 değerine geri döner ve errno uygun biçimde set 
    edilir. socket nesnesinin bir dosya gibi kullanıldığına dikkat ediniz. socket fonksiyonu bize open fonksiyonunda olduğu 
    gibi dosya betimleyici tablosunda indeks belirten en düşük numaralı dosya betimleyicisini vermektedir.

    Örneğin:

    int server_sock;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Server program soketi yarattıktan sonra onu bağlamalıdır (bind etmelidir). bind işlemi sırasında server'ın hangi portu 
    dinleyeceği ve hangi network arayüzünden (kartından) gelen bağlantı isteklerini kabul edeceği belirlenir. Ancak bind 
    fonksiyonu dinleme işlemini başlatmaz. Yalnızca soket nesnesine bu bilgileri yerleştirir. Fonksiyonun prototipi şöyledir:

    #include <sys/socket.h>

    int bind(int socket, const struct sockaddr *addr, socklen_t addrlen);

    Fonksiyonun birinci parametresi yaratılmış olan soket betimleyicisini alır. İkinci parametre her ne kadar sockaddr isimli 
    yapı türündense de aslında her protokol için ayrı bir yapı adresini almaktadır. Yani sockaddr yapısı genelliği (void gösterici
    gibi) temsil etmek için kullanılmıştır. IPv4 için kullanılacak yapı sockaddr_in, IPv6 için sockaddr_in6 ve örneğin Unix 
    domain soketler için ise sockaddr_un biçiminde olmalıdır. Üçüncü parametre, ikinci parametredeki yapının uzunluğu olarak 
    girilmelidir.

    sockaddr_in yapısı <netinet/in.h> dosyası içerisinde aşağıdaki gibi bildirilmiştir:

    #include <netinet/in.h>

    struct sockaddr_in {
        sa_family_t     sin_family;
        in_port_t       sin_port;
        struct in_addr  sin_addr;
    };

    Yapının sin_family elemanına protokol ailesini belirten AF_XXX değeri girilmelidir. Bu eleman tipik olarak short biçimde 
    bildirilmiştir. Yapının sin_port elemanı in_port_t türündendir ve bu tür uint16_t olarak typedef edilmiştir. Bu eleman server'ın 
    dinleyeceği port numarasını belirtir. Yapının sin_addr elemanı IP numarası belirten bir elemandır. Bu eleman in_addr isimli 
    bir yapı türündendir. in_addr yapısı <netint/in.h> dosyası içerisinde şöyle bildirilmiştir:

    #include <netinet/in.h>

    struct in_addr {
        in_addr_t s_addr;
    };

    in_addr_t 4 byte'lık işaretsiz tamsayı türünü (uint32_t) belirtmektedir. Böylece s_addr 4 byte'lık IP adresini temsil eder. 
    Eğer biz tüm network kartlarından gelen bağlantı isteklerini kabul etmek istiyorsak IP adresi olarak INADDR_ANY özel değerini 
    geçmeliyiz.

    Yukarıda da belirttiğimiz gibi IP ailesinde tüm sayısal değerler "big endian" formatıyla belirtilmek zorundadır. Bu ailede 
    "network byte ordering" denildiğinde "big endian" format anlaşılır. Oysa makinelerin belli bir bölümü (örneğin Intel ve 
    default ARM) "little endian" kullanmaktadır. İşte elimizdeki makinenin endian'lığı ne olursa olsun onu big endian formata 
    dönüştüren htons (host to network byte ordering short) ve htonl (host to network byte ordering long) isimli iki fonksiyon 
    vardır. Bu işlemlerin tersini yapan da ntohs (network byte ordering to host short) ve ntohl (network byte ordering to host 
    long) fonksiyonları da bulunmaktadır. Fonksiyonların prototipleri şöyledir:

    #include <arpa/inet.h>

    uint32_t htonl(uint32_t hostlong);
    uint16_t htons(uint16_t hostshort);
    uint32_t ntohl(uint32_t netlong);
    uint16_t ntohs(uint16_t netshort);

    Yukarıda da belirttiğimiz üzere IP adresi olarak INADDR_ANY özel değeri "tüm network kartlarından gelen bağlantı isteklerini 
    kabul et" anlamına gelmektedir. Bu durumda sockaddr_in yapısı tipik olarak şöyle doldurulabilir:

    struct sockaddr_in sinaddr;

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(SERVER_PORT);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind fonksiyonu başarı durumunda sıfır değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Örneğin:

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    server program bind işleminden sonra soketi aktif dinleme konumuna sokmak için listen fonksiyonunu çağırmalıdır. Fonksiyonun 
    prototipi şöyledir:

    #include <sys/socket.h>

    int listen(int socket, int backlog);

    Fonksiyonun birinci parametresi soket betimleyicisini, ikinci parametresi kuyruk uzunluğunu belirtir. listen işlemi blokeye 
    yol açmamaktadır. İşletim sistemi listen işleminden sonra ilgili porta gelen bağlantı isteklerini uygulama için oluşturduğu 
    bir bağlantı kuyruğuna yerleştirmektedir. Kuyruk uzunluğunu yüksek tutmak meşgul server'larda bağlantı isteklerinin kaçırılmamasını
    sağlayabilir. Linux'ta default durumda verilebilecek en yüksek değer 128'dir. Ancak /proc/sys/net/core/somaxconn dosyasındaki
    değer değiştirilerek bu default uzunluk artırılabilir. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine 
    geri dönmektedir. Örneğin:

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    Bu fonksiyon işletim sistemlerinin "firewall mekanizması" tarafından denetlenebilmektedir. Eğer çalıştığınız sistemde söz konusu 
    port firewall tarafından kapatılmışsa bunu açmanız gerekir. (Windows sistemlerinde listen fonksiyonu bir pop pencere çıkartarak
    uyarı mesajı görüntülemektedir.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bağlantıyı sağlayan asıl fonksiyon accept fonksiyonudur. accept fonksiyonu bağlantı kuyruğuna bakar. Eğer orada bir bağlantı 
    isteği varsa onu alır ve hemen geri döner. Eğer orada bir bağlantı isteği yoksa default durumda blokede bekler. Fonksiyonun 
    prototipi şöyledir:

    #include <sys/socket.h>

    int accept(int socket, struct sockaddr *address, socklen_t *address_len);

    Fonksiyonun birinci parametresi dinleme soketinin dosya betimleyicisini almaktadır. İkinci parametre bağlanılan client'a 
    ilişkin bilgilerin yerleştirileceği sockaddr_in yapısının adresini almaktadır. Bu parametre yine genel bir sockaddr yapısı 
    türünden gösterici ile temsil edilmiştir. Bizim bu parametre için IPv4'te sockaddr_in türünden, IPv6'da sockaddr_in6 
    türünden bir yapı nesnesinin adresini argüman olarak vermemiz gerekir. sockaddr_in yapısının üç elemanı olduğunu anımsayınız. 
    Biz bu parametre sayesinde bağlanan client programın IP adresini ve o host'taki port numarasını elde edebilmekteyiz. Client 
    program server programa bağlanırken bir IP adresi ve port numarası belirtir. Ancak kendisinin de bir IP adresi ve port 
    numarası vardır. Client'ın port numarası kendi makinesindeki (host'undaki) port numarasıdır. Client'ın IP adresine ve oradaki 
    port numarasına "remote end point" de denilmektedir. Örneğin 178.231.152.127 IP adresinden bir client programın 52310 portu 
    ile server'ın bulunduğu 176.234.135.196 adresi ve 55555 numaralı portuna bağlandığını varsayalım. Burada remote endpoint 
    "178.231.152.127:52310" biçiminde ifade edilmektedir. İşte biz accept fonksiyonunun ikinci parametresinden client hakkında 
    bu bilgileri almaktayız.

    Client (178.231.152.127:52310) ---> Server (176.234.135.196:55555)

    accept fonksiyonunun üçüncü parametresi yine ikinci parametredeki yapının (yani sockaddr_in yapısının) byte uzunluğunu 
    belirtmektedir. Ancak bu parametre bir adres olarak alınmaktadır. Yani programcı socklen_t türünden bir nesne tanımlamalı,
    bu nesneye bu sizeof değerini yerleştirmeli ve nesnenin adresini de fonksiyonun üçüncü parametresine geçirmelidir. Fonksiyon 
    bağlanılan client'a ilişkin soket bilgilerinin byte uzunluğunu yine bu adrese yerleştirmektedir. Tabii IP protokol ailesinde 
    her iki taraf da aynı yapıyı kullanıyorsa fonksiyon çıkışında bu sizeof değerinde bir değişiklik olmayacaktır. Ancak tasarım 
    genel yapıldığı için böyle bir yola gidilmiştir.

    accept fonksiyonu başarı durumunda bağlanılan client'a ilişkin yeni bir soket betimleyicisine geri dönmektedir. Artık bağlanılan
    client ile bu soket yoluyla konuşulacaktır. accept başarısızlık durumunda -1 değeri ile geri dönmektedir. Örneğin:

    struct sockaddr_in sin_client;
    socklen_t sin_len;
    int client_sock;
    ...

    sin_len = sizeof(sin_client);
    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
        exit_sys("accept");

    Server tarafta temelde iki soket bulunmaktadır. Birincisi bind, listen, accept işlemini yapmakta kullanılan sokettir. 
    Bu sokete TCP/IP terminolojisinde "pasif soket (passive socket)" ya da "dinleme soketi (listening socket)" denilmektedir. 
    İkinci soket ise client ile konuşmakta kullanılan accept fonksiyonunun geri döndürdüğü sokettir. Buna da "aktif soket
    (active socket)" denilmektedir. Tabii server program birden fazla client ile konuşacaksa accept fonksiyonunu bir kez değil,
    çok kez uygulamalıdır. Her accept o anda bağlanılan client ile konuşmakta kullanılabilecek yeni bir soket vermektedir. 
    bind, listen işlemleri bir kez yapılmaktadır. Halbuki accept işlemi her client bağlantısı için ayrıca uygulanmalıdır.

    accept fonksiyonu default durumda blokeli modda çalışmaktadır. Eğer accept çağrıldığında o anda bağlantı kuyruğunda hiç
    bir client isteği yoksa accept fonksiyonu blokeye yol açmaktadır.

    accept fonksiyonu ile elde edilen client bilgilerindeki IP adresini ve port numaraları "big endian" formatında yani 
    "network byte ordering" formatındadır. Bunları sayısal olarak görüntülemek için ntohl ve ntohs fonksiyonlarının kullanılması
    gerekir. Tabii izleyen paragrafta ele alacağımız gibi aslında IP adresleri genellikle "noktalı desimal format" denilen 
    bir format ile yazı biçiminde görüntülenmektedir.

    Aşağıda accept işlemine kadar olan bir örnek server programı verilmiştir. Tabii programda sonraki paragraflarda göreceğimiz 
    bazı eksiklikler vardır.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define SERVER_PORT        55555

void exit_sys(const char *msg);

int main(void)
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORT);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("waiting for connection...\n");
    sin_len = sizeof(sin_client);
    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
        exit_sys("accept");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                99. Ders 19/11/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    IP adresleri sockaddr_in yapısının içerisindeki in_addr yapısında belirtilmiştir. IPv4'te IP adreslerinin 4 byte uzunlukta 
    olduğunu söylemiştik. sockaddr_in yapısını ve in_addr yapısını yeniden veriyoruz:

    #include <netinet/in.h>

    struct sockaddr_in {
        sa_family_t     sin_family;
        in_port_t       sin_port;
        struct in_addr  sin_addr;
    };

    struct in_addr {
        in_addr_t s_addr;
    };

    Buradaki in_addr_t türü uint32_t biçiminde typedef edilmiştir. Yani 4 byte'lık bir tamsayı türüdür. Elimizde sockaddr_in
    türünden bir nesne olsun:

    struct sockaddr_in sin_client;

    Biz bu nesne yoluyla 4 byte'lık IP adresini "sin_client.sin_addr.s_addr" ifadesi ile elde ederiz.

    IPv4 adresleri genellikle kullanıcılar tarafından "noktalı desimal format (dotted decimal format)" denilen bir formatla 
    gösterilmektedir. Bu formatta IP adresinin her byte'ı arasına "." karakteri getirilir ve IP adresi bir yazı olarak gösterilir. 
    Örneğin:

    "127.0.0.1"
    "192.168.1.1"
    "176.234.135.196"

    İşte 4 byte'lık işaretsiz bir tamsayı biçimindeki IP adresini noktalı desimal formata dönüştürmek için inet_ntoa isimli
    bir POSIX fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <arpa/inet.h>

    char *inet_ntoa(struct in_addr in);

    Fonksiyon in_addr yapısını almaktadır (yapının tek bir elemanı olduğu için adresini almamaktadır). Fonksiyon başarı durumunda 
    noktalı desimal formattaki IP adres yazısına geri dönmektedir. Fonksiyon başarısız olamamaktadır. Fonksiyonun geri döndürdüğü 
    adres statik bir alanın adresidir. Dolayısıyla verilen adres thread güvenli değildir.

    inet_ntoa fonksiyonunun yaptığının tersini yapan inet_addr isimli bir POSIX fonksiyonu da vardır. Fonksiyonun prototipi 
    şöyledir:

    #include <arpa/inet.h>

    in_addr_t inet_addr(const char *cp);

    Fonksiyon noktalı desimal formattaki yazıyı alarak onu 4 byte'lık IP adresine dönüştürmektedir. Başarı durumunda bu IP 
    adresine, başarısızlık durumunda (in_addr_t)-1 değerine geri dönmektedir. (in_addr_t türü işaretsiz ise geri döndürülen 
    değer -1 değil, en büyük pozitif sayı olmaktadır. Ancak işaretsiz tamsayı türünü -1 ile karşılaştırırsak zaten -1 değeri 
    de o türe dönüştürüleceği için sorun ortaya çıkmayacaktır.) Başarısızlık durumunda herhangi bir errno değeri set edilmemektedir.

    inet_ntoa fonksiyonundaki ve bunun tersini yapan inet_addr fonksiyonundaki IP adresleri "big endian" formata göre yani 
    "network byte ordering" formatına göre verilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bağlantı işleminden sonra artık bilgi gönderip alma işlemi yapılabilir. Sonra da aktif soket düzgün bir biçimde kapatılmalıdır. 
    Ancak biz önce client programda da belli bir noktaya gelip bu ortak kısımları ondan sonra ele alacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP client program, server programa bağlanabilmek için tipik bazı adımları uygulamak zorundadır. Bu adımlar sırasında 
    çağrılacak fonksiyonlar şunlardır:

    socket ---> bind (isteğe bağlı) ---> gethostbyname (isteğe bağlı) ---> connect ---> send/recv ya da read/write 
    ---> shutdown ---> close

    Client taraf önce yine socket fonksiyonuyla bir soket yaratır. Örneğin:

    int client_sock;
    ...

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    Soketin bind edilmesi gerekmez. Zaten genellikle client taraf soketi bind etmez. Eğer client taraf belli bir porttan 
    bağlanmak istiyorsa bu durumda bind işlemini uygulayabilir. Eğer client bind işlemi yapmazsa zaten işletim sistemi 
    connect işlemi sırasında sokete boş bir port numarasını atamaktadır. İşletim sisteminin bind edilmemiş client programa 
    connect işlemi sırasında atadığı bu port numarasına İngilizce "ephemeral port" (ömrü kısa olan port) denilmektedir. Seyrek 
    olarak bazı server programlar client için belli bir remote port numarası talep edebilmektedir. Bu durumda client'ın bu 
    remote porta sahip olabilmesi için bind işlemini uygulaması gerekir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Client bağlantı için server'ın IP adresini ve port numarasını bilmek zorundadır. IP adreslerinin akılda tutulması zordur. 
    Bu nedenle IP adresleri ile eşleşen "host isimleri" oluşturulmuştur. Ancak IP protokol ailesi host isimleriyle değil, IP
    numaralarıyla çalışmaktadır. İşte host isimleriyle IP numaralarını eşleştiren ismine DNS (Domain Name Server) denilen 
    özel server'lar bulunmaktadır. Bu server'lar IP protokol ailesindeki DNS isimli bir protokol ile çalışmaktadır. Dolayısıyla
    client programın elinde IP adresi yerine host ismi varsa DNS işlemi yaparak o host ismine karşı gelen IP numarasını elde
    etmesi gerekir. DNS server'lar dağıtık biçimde bulunmaktadır. Bir kayıt bir DNS server'da yoksa başka bir DNS server'a 
    referans edilmektedir.

    DNS server'larda host isimleriyle IP numaraları bire bir karşılık gelmemektedir. Belli bir host ismine birden fazla IP
    numarası eşleştirilmiş olabileceği gibi belli bir IP numarasına da birden fazla host ismi eşleştirilmiş olabilmektedir.

    DNS işlemleri yapan iki geleneksel fonksiyon vardır: gethostbyname ve gethostbyaddr. Bu fonksiyonların kullanımları 
    kolaydır. Ancak bu fonksiyonlar artık "deprecated" yapılmış ve POSIX standartlarından da silinmiştir. Bunların yerine 
    getnameinfo ve getaddrinfo fonksiyonları oluşturulmuştur. Bu fonksiyonlar POSIX standartlarında bulunmaktadır. Biz önce 
    gethostbyname ve gethostbyaddr fonksiyonlarını göreceğiz. (Çünkü ana noktalar üzerinde durmak için vakit kaybetmemek 
    istemiyoruz.) Belli süre sonra da getnameinfo ve getaddrinfo fonksiyonlarını açıklayacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    gethostbyname fonksiyonunun prototipi şöyledir:

    #include <netdb.h>

    struct hostent *gethostbyname(const char *name);

    Fonksiyon bizden host ismini alır ve DNS işlemi yaparak bize statik düzeyde tahsis edilmiş olan bir hostent yapı nesnesinin 
    adresini verir. Fonksiyon errno değişkeni yerine h_errno isimli bir değişkeni set etmektedir. Bu değişkenin değerini yazıya 
    dönüştürmek için strerror fonksiyonu değil, prototipi <netdb.h> içerisinde olan hstrerror fonksiyonu kullanılmaktadır. hostent 
    yapısı aşağıdaki gibi bildirilmiştir:

    struct hostent {
        char  *h_name;            /* official name of host */
        char **h_aliases;         /* alias list */
        int    h_addrtype;        /* host address type */
        int    h_length;          /* length of address */
        char **h_addr_list;       /* list of addresses */
    };

    Yapının h_name elemanı host'un asıl ismini vermektedir. Her host'un alternatif isimleri de olabilmektedir. Yapının 
    h_aliases elemanı ise host'un diğer isimlerini belirtmektedir. Bu gösterici dizisinin her elemanı host'un bir ismini 
    belirtir. Dizinin sonunda NULL adres vardır. Örneğin:

    h_aliases ----> adres -----> isim
                    adres -----> isim
                    adres -----> isim
                    ...
                    NULL

    Yapının h_addrtype elemanı adresin ilişkin olduğu protokol ailesini belirtmektedir. h_length elemanı söz konusu adresin 
    byte uzunluğunu belirtir. Bu genel bir fonksiyon olduğundan ve adresler de değişik uzunluklarda ve türlerde olabileceğinden
    adresler char türden bir dizi içerisine byte byte kodlanmıştır. IPv4'te bu diziler 4 eleman uzunluğundadır. Buradaki adresler
    "big endian" formatta yani "network byte ordering" biçimindedir. Yine h_addr_list göstericinin gösterdiği dizinin son elemanı 
    NULL adres içermektedir. Örneğin:

    h_addr_list ----> adres -----> byte byte byte byte
                      adres -----> byte byte byte byte
                      adres -----> byte byte byte byte
                      ...
                      NULL

    Biz h_addr_list elemanında belirtilen adreslerden ilkini (0'ıncı indekstekini alabiliriz)

    Tipik olarak client program önce server host isminin noktalı desimal formatta olup olmadığına bakar. Eğer bu host ismi 
    noktalı desimal formatta ise onu inet_addr fonksiyonu ile IP numarasına dönüştürür. Eğer host ismi noktalı desimal formatta
    değilse, gethostbyname fonksiyonunu uygulayarak bu kez oradan IP adresini elde eder. Örneğin:

    #define SERVER_NAME        "some_host_name or dotted decimal ip name"

    int client_sock;
    struct sockaddr_in sin_server;
    struct hostent *hent;
    ...

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORT);
    if ((sin_server.sin_addr.s_addr = inet_addr(SERVER_NAME)) == -1) {
        if ((hent = gethostbyname(SERVER_NAME)) == NULL) {
            fprintf(stderr, "gethostbyname: %s\n", hstrerror(h_errno));
            exit(EXIT_FAILURE);
        }
        memcpy(&sin_server.sin_addr.s_addr, hent->h_addr_list[0], hent->h_length);
    }

    gethostbyname fonksiyonu isme karşı IP numaralarının elde edilmesi için kullanılmaktadır. Bunun ters olan gethostbyaddr 
    isimli yine "deprecated" yapılmış bir fonksiyon daha vardır:

    #include <netdb.h>

    struct hostent *gethostbyaddr(const void *addr, socklen_t len, int af);

    Fonksiyonun birinci parametresi "big endian" biçiminde byte dizilimine sahip adresi belirtmektedir. İkinci parametre bu 
    adresin uzunluğunu, üçüncü parametre ise protokol ailesini belirtir. Yine fonksiyon başarı durumunda hostent nesnesinin 
    adresine, başarısızlık durumunda NULL adrese geri dönmektedir. Bu fonksiyon da errno yerine h_errno değişkeninin set 
    etmektedir. Yine bu h_errno değerine yazıya dönüştürmek için hstrerror fonksiyonu kullanılmaktadır.

    O anda çalışılan makinenin IPv4 adresi "127.0.0.1" ile temsil edilmektedir. Bu adrese "loopback address" de denilmektedir. 
    Bazı işletim sistemlerinde (Windows, Linux ve macOS) "localhost" ismi de o anda çalışılan makinenin host ismi olarak 
    kullanılabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Artık client program connect fonksiyonuyla TCP bağlantısını sağlayabilir. connect fonksiyonunun prototipi şöyledir:

    #include <sys/socket.h>

    int connect(int socket, const struct sockaddr *address, socklen_t address_len);

    Fonksiyonun birinci parametresi soket betimleyicisini belirtir. İkinci parametre bağlanılacak server'a ilişkin sockaddr_in
    yapı nesnesinin adresini belirtmektedir. Fonksiyonun üçüncü parametresi, ikinci parametredeki yapının uzunluğunu almaktadır. 
    Fonksiyon başarı durumunda sıfır değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    Eğer connect fonksiyonu çağrıldığında server program çalışmıyorsa ya da server programın bağlantı kuyruğu doluysa connect
    belli bir zaman aşımı süresi kadar bekler ve sonra başarısız olur ve errno değeri ECONNREFUSED ("Connection refused") ile
    set edilir. Örneğin:

    if (connect(client_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("connect");

    Aşağıda örnekte bağlantı için gereken minimum client program verilmiştir. Burada henüz görmediğimiz işlemleri hiç uygulamadık.
---------------------------------------------------------------------------------------------------------------------------*/

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define SERVER_NAME        "127.0.0.1"
#define SERVER_PORT        55555

void exit_sys(const char *msg);

int main(void)
{
    int client_sock;
    struct sockaddr_in sin_server;
    struct hostent *hent;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    /*
    {
        struct sockaddr_in sin_client;

        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(50000);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }
    */

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORT);
    if ((sin_server.sin_addr.s_addr = inet_addr(SERVER_NAME)) == -1) {
        if ((hent = gethostbyname(SERVER_NAME)) == NULL) {
            fprintf(stderr, "gethostbyname: %s\n", hstrerror(h_errno));
            exit(EXIT_FAILURE);
        }
        memcpy(&sin_server.sin_addr.s_addr, hent->h_addr_list[0], hent->h_length);
    }

    if (connect(client_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("connect");

    printf("connected...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Tıpkı borularda olduğu gibi soketlerlerde de "blokeli" ve "blokesiz" çalışma söz konusudur. Soketlerde default çalışma 
    biçimi "blokeli" moddur. Blokeli modda gönderme ve alma işlemlerinde aşağıda açıklayacağımız gibi belli koşullarda bloke
    oluşmaktadır. Blokesiz modda ise hiçbir zaman bloke oluşmaz. Biz de default mod olan blokeli modu ele alacağız. 
    Genellikle kullanılan mod da zaten blokeli moddur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bağlantı sağlandıktan sonra artık recv ya da read ve write fonksiyonlarıyla gönderme alma işlemleri yapılabilir. 
    recv fonksiyonunun prototipi şöyledir:

    #include <sys/socket.h>

    ssize_t recv(int socket, void *buffer, size_t length, int flags);

    Fonksiyonun birinci parametresi aktif soketin betimleyicisini belirtmektedir. İkinci parametre alınacak bilginin 
    yerleştirileceği dizinin adresini almaktadır. Üçüncü parametre ise okunmak istenen byte sayısını belirtmektedir. 
    Fonksiyonun son parametresi aşağıdaki üç sembolik sabitin bit OR işlemine sokulmasıyla oluşturulabilir:

    MSG_PEEK
    MSG_OOB
    MSG_WAITALL

    Biz şimdilik bu değerlerin anlamlarını açıklamayacağız. Ancak MSG_PEEK değeri bilginin network tamponundan alındıktan sonra
    oradan atılmayacağını belirtmektedir. Bu parametre 0 da geçilebilir. Zaten recv fonksiyonunun read fonksiyonundan tek farkı
    bu son parametredir. Bu son parametrenin 0 geçilmesiyle read kullanılması arasında hiçbir farklılık yoktur.

    recv fonksiyonu blokeli modda (default durum blokeli moddur) tıpkı borularda olduğu gibi eğer hazırda en az 1 byte varsa
    okuyabildiği kadar bilgiyi okur ve okuyabildiği byte sayısına geri döner. Eğer o anda network tamponunda hiç byte yoksa
    recv fonksiyonu en az 1 byte okuyana kadar blokede bekler. (Yani başka bir deyişle recv tıpkı borularda olduğu gibi eğer 
    okunacak bir şey yoksa blokede bekler, ancak okunacak en az 1 byte varsa okuyabildiğini okur ve beklemeden geri döner.)

    recv fonksiyonu başarı durumunda okunabilen byte sayısına, başarısızlık durumunda -1 değerine geri dönmektedir. 
    Eğer karşı taraf soketi (peer socket) kapatmışsa bu durumda tıpkı borularda olduğu gibi recv fonksiyonu 0 ile 
    geri dönmektedir. Soketlerle boruların kullanımlarının birbirlerine çok benzediğine dikkat ediniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                100. Ders 25/11/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Soketten bilgi göndermek için send ya da write fonksiyonu kullanılmaktadır. send fonksiyonunun da parametrik yapısı şöyledir:

    #include <sys/socket.h>

    ssize_t send(int socket, const void *buffer, size_t length, int flags);

    Fonksiyonun birinci parametresi aktif soketin betimleyicisini belirtmektedir. İkinci parametre gönderilecek bilgilerin 
    bulunduğu dizinin adresini belirtir. Üçüncü parametre ise gönderilecek byte miktarını belirtmektedir. Son parametre aşağıdaki
    sembolik sabitlerin bit düzeyinde OR işlemine sokulmasıyla oluşturulabilir:

    MSG_EOR
    MSG_OOB
    MSG_NOSIGNAL

    Biz şimdilik bu bayraklar üzerinde durmayacağız.

    send fonksiyonu bilgileri karşı tarafa o anda göndermez. Onu önce network tamponuna yerleştirir. İşletim sistemi o tampondan 
    TCP (dolayısıyla IP) paketleri oluşturarak mesajı göndermektedir. Yani send fonksiyonu geri döndüğünde bilgiler network tamponuna 
    yazılmıştır, ancak henüz karşı tarafa gönderilmemiş olabilir. Pekiyi o anda network tamponu doluysa ne olacaktır? İşte UNIX/Linux 
    sistemlerinde send fonksiyonu, gönderilecek bilginin tamamı network tamponuna aktarılana kadar blokede beklemektedir. Ancak bu 
    konuda işletim sistemleri arasında farklılıklar olabilmektedir. Örneğin Windows sistemlerinde send fonksiyonu eğer network 
    tamponunda gönderilmek istenen kadar yer yoksa ancak en az bir byte'lık boş bir yer varsa tampona yazabildiği kadar byte'ı 
    yazıp hemen geri dönmektedir. Diğer UNIX/Linux sistemleri arasında da send fonksiyonunun davranışı bakımından bu yönde farklılıklar 
    olabilmektedir. Ancak POSIX standartları blokeli modda tüm bilginin network tamponuna yazılana kadar send fonksiyonunun bloke 
    olacağını belirtmektedir. Linux çekirdeği de buna uygun biçimde çalışmaktadır.

    send fonksiyonu network tamponuna yazılan byte sayısı ile geri dönmektedir. Blokeli modda bu değer, yazılmak istenen değerle
    aynı olur. send fonksiyonu başarısızlık durumunda -1 değeri ile geri döner ve errno uygun biçimde set edilir. Tıpkı borularda 
    olduğu gibi send fonksiyonunda da eğer karşı taraf soketi kapatmışsa send fonksiyonu default durumda SIGPIPE sinyalinin 
    oluşmasına yol açmaktadır. Eğer bu sinyalin oluşturulması istenmiyorsa bu durumda send fonksiyonunun son parametresi (flags)
    MSG_NOSIGNAL olarak geçilmelidir. Bu durumda karşı taraf soketi kapatmışsa send fonksiyonu başarısız olur ve errno değeri 
    EPIPE olarak set edilir. send fonksiyonunun soketlerdeki davranışının borulardaki davranışa çok benzediğine dikkat ediniz.

    send fonksiyonunun son parametresi 0 geçildiğinde bu fonksiyonun davranışı tamamen write fonksiyonunda olduğu gibidir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Haberleşmenin sonunda TCP soketi nasıl kapatılmalıdır? Mademki soketler UNIX/Linux sistemlerinde birer dosya betimleyicisi 
    gibidir o halde soketi kapatma işlemi "close" ile yapılabilir. Tabii tıpkı dosyalarda olduğu gibi soketlerde de close işlemi 
    yapılmazsa işletim sistemi proses normal ya da sinyal gibi nedenlerle sonlandığında otomatik olarak betimleyicileri kapatır
    yani close işlemini kendisi yapar.

    Soket betimleyicileri de "dup" işlemine sokulabilir. Bu durumda close işlemi uygulandığında soket nesnesi yok edilmez. 
    Çünkü o nesneyi gören başka bir betimleyici daha vardır. Benzer biçimde fork işlemi sırasında da betimleyicilerin çiftlendiğine 
    dikkat ediniz.

    Aktif soketlerin doğrudan close ile kapatılması iyi bir teknik değildir. Bu soketler önce "shutdown" ile haberleşmeden 
    kesilmeli sonra close ile kapatılmalıdır. Bu biçimde soketlerin kapatılmasına İngilizce "graceful close (zarif kapatma)" 
    denilmektedir. Pekiyi shutdown fonksiyonu ne yapmaktadır ve neden gerekmektedir? close işlemi ile bir soket kapatıldığında 
    işletim sistemi sokete ilişkin tüm veri yapılarını ve bağlantı bilgilerini siler. Örneğin biz karşı tarafa send ile bir 
    şey gönderdikten hemen sonraki satırda close yaparsak artık send ile gönderdiklerimizin karşı tarafa ulaşacağının hiçbir 
    garantisi yoktur. Çünkü anımsanacağı gibi send aslında "gönderme tamponuna" bilgiyi yazıp geri dönmektedir. Hemen arkasından 
    close işlemi uygulandığında artık bu sokete ilişkin gönderme ve alma tamponları da yok edileceğinden tamponda gönderilmeyi 
    bekleyen bilgiler hiç gönderilmeyebilecektir. close işlemini bilgisayarımızı "power düğmesine basarak kapatmaya" benzetebiliriz. 
    Bu durumda o anda çalışan tüm programlar ve işletim sistemi aniden yok edilmektedir. shutdown işlemini de "işletim sistemindeki 
    shutdown" mekanizmasına benzetebiliriz. İşletim sistemini shutdown ettiğimizde tüm prosesler uygun biçimde sonlandırılıp sistem 
    stabil olarak kapatılmaktadır. Tabii soketlerde doğrudan close işlemi çoğu kez önemli bir probleme yol açmayabilir. Ancak doğru 
    teknik aktif soketlere önce shutdown uygulayıp sonra close etmektedir.

    shutdown fonksiyonunun üç işlevi vardır:

    1) Haberleşmeyi TCP çerçevesinde el sıkışarak sonlandırmak (bu konu ileride ele alınacaktır).
    2) Gönderme tamponuna yazılan bilgilerin gönderildiğine emin olmak.
    3) Okuma ya da yazma işlemini sonlandırıp diğer işleme devam edebilmek (half close işlemi).

    shutdown fonksiyonunun prototipi şöyledir:

    #include <sys/socket.h>

    int shutdown(int socket, int how);

    Fonksiyonun birinci parametresi sonlandırılacak soketin betimleyicisini, ikinci parametresi biçimini belirtmektedir. İkinci 
    parametre şunlardan biri olarak girilebilir:

    SHUT_RD: Bu işlemden sonra artık soketten okuma yapılamaz. Fakat sokete yazma yapılabilir. Bu seçenek pek kullanılmamaktadır.

    SHUR_WR: Burada artık shutdown daha önce gönderme tamponuna yazılmış olan byte'ların gönderilmesine kadar bloke oluşturabilir. 
    Bu işlemden sonra artık sokete yazma yapılamaz ancak okuma işlemi devam ettirilebilir.

    SHUT_RDWR: En çok kullanılan seçenektir. Burada da artık shutdown daha önce gönderme tamponuna yazılmış olan byte'ların 
    gönderilmesine kadar bloke oluşturabilir. Artık bundan sonra soketten okuma ya da yazma yapılamamaktadır.

    shutdown başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    O halde aktif bir soketin kapatılması tipik olarak şöyle yapılmaktadır:

    shutdown(sock, SHUT_RDWR);
    close(sock);

    Karşı taraf soketi (peer socket) shutdown ile SHUT_WR ya da SHUT_RDWR ile sonlandırmışsa artık biz o soketten okuma 
    yaptığımızda recv ya da read fonksiyonları 0 ile geri döner. Benzer biçimde karşı taraf doğrudan soketi close ile kapatmışsa 
    yine recv ya da read fonksiyonları 0 ile geri döner.

    Karşı tarafın soketi kapatıp kapatmadığı tipik olarak recv fonksiyonunda anlaşılabilmektedir. Yukarıda da belirttiğimiz 
    gibi karşı taraf soketi kapattıktan sonra biz sokete write ya da send ile bir şeyler yazmak istersek default durumda 
    UNIX/Linux sistemlerinde SIGPIPE sinyali oluşmaktadır. Programcı send fonksiyonunun flags parametresine MSG_NOSIGNAL 
    değerini girerse bu durumda send başarısız olmakta ve errno değişkeni EPIPE değeri ile set edilmektedir. Karşı taraf 
    soketi kapatmamış ancak bağlantı kopmuş olabilir. Bu durumda send/write ve recv/read fonksiyonları başarısız olur ve 
    -1 değeriyle ile geri döner.

    O halde recv ya da read işlemi yapılırken fonksiyonların geri dönüş değerleri -1 ve 0 ile kontrol edilmelidir. Örneğin:

    if ((result = recv(...)) == -1)
        exit_sys("recv");
    if (result == 0) {
        // karşı taraf soketi kapatmış, gerekli işlemleri yap
    }

    Benzer biçimde send ya da write fonksiyonlarıyla yazma yapılırken fonksiyonların geri dönüş değerleri -1 ile kontrol 
    edilmelidir. Örneğin:

    if (send(...) == -1)
        exit_sys("send");
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte client program, server programa bağlanarak stdin dosyasından okuduğu yazıları send fonksiyonu ile server
    programa göndermektedir. Server program da bu yazıları alarak stdout dosyasına basmaktadır. Haberleşme normal olarak 
    client tarafın "quit" yazısını girmesiyle sonlandırılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define SERVER_PORT        55555
#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORT);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("waiting for connection...\n");
    sin_len = sizeof(sin_client);
    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
        exit_sys("accept");

    printf("connected client ===> %s:%d\n", inet_ntoa(sin_client.sin_addr), ntohs(sin_client.sin_port));

    for (;;) {
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received: \"%s\"\n", (intmax_t)result, buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    close(server_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define SERVER_NAME        "127.0.0.1"
#define SERVER_PORT        55555
#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    int client_sock;
    struct sockaddr_in sin_server;
    struct hostent *hent;
    char buf[BUFFER_SIZE];
    char *str;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    /*
    {
        struct sockaddr_in sin_client;

        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(50000);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }
    */

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORT);
    if ((sin_server.sin_addr.s_addr = inet_addr(SERVER_NAME)) == -1) {
        if ((hent = gethostbyname(SERVER_NAME)) == NULL) {
            fprintf(stderr, "gethostbyname: %s\n", hstrerror(h_errno));
            exit(EXIT_FAILURE);
        }
        memcpy(&sin_server.sin_addr.s_addr, hent->h_addr_list[0], hent->h_length);
    }

    if (connect(client_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("connect");

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bu noktada UNIX/Linux sistemlerinde yazılan soket programlarının Windows sistemlerine nasıl port edileceği hakkında bazı 
    açıklamalarda bulunmak istiyoruz.

    Windows sistemlerindeki soket kütüphanesine "Winsock" denilmektedir. Şu anda bu kütüphanenin 2'nci versiyonu kullanılmaktadır. 
    Winsock API fonksiyonları "UNIX/Linux uyumlu" fonksiyonlar ve Windows'a özgü fonksiyonlar olmak üzere iki biçimde kullanılabilmektedir. 
    Ancak Winsock'un UNIX/Linux uyumlu fonksiyonlarında da birtakım değişiklikler söz konusudur. Bir UNIX/Linux ortamında yazılmış
    soket uygulamasının Windows sistemlerine aktarılması için şu düzeltmelerin yapılması gerekir:

    1) POSIX'in soket sistemine ilişkin tüm başlık dosyaları kaldırılır. Onun yerine <winsock2.h> dosyası include edilir.

    2) xxx_t'li typedef türleri silinir ve onların yerine (dokümanlara da bakabilirsiniz) int, short, unsigned int, unsigned short
    türleri kullanılır. (Örneğin ssize_t türü ve socklen_t türleri yerine int türleri kullanılmalıdır.)

    3) Windows'ta soket sisteminin başlatılması için WSAStartup fonksiyonu işin başında çağrılır ve işin sonunda da bu işlem
    WSACleanup fonksiyonuyla geri alınır. Bu fonksiyonları şöyle kullanabilirsiniz:

    WSADATA wsadata;
    ...
    if ((result = WSAStartup(MAKEWORD(2, 2), &wsadata)) != 0)
        exit_sys("WSAStartup", EXIT_FAILURE, result);
    ...
    WSACleanup();

    4) Windows'ta dosya betimleyicisi kavramı yoktur. (Onun yerine "handle" kavramı vardır.) Dolayısıyla soket türü de int değil,
    SOCKET isimli bir typedef türüdür.

    5) shutdown fonksiyonunun ikinci parametresi SD_RECEIVE, SD_SEND ve SD_BOTH biçimindedir.

    6) close fonksiyonu yerine closesocket fonksiyonu ile soket kapatılır.

    7) Windows'ta soket fonksiyonları başarısızlık durumunda -1 değerine geri dönmezler. socket fonksiyonu başarısızlık durumunda
    INVALID_SOCKET değerine, diğerleri ise SOCKET_ERROR değerine geri dönmektedir.

    8) Visual Studio IDE'sinde default durumda "deprecated" durumlar "error"e yükseltilmiştir. Bunlar için bir makro 
    define edilebilmektedir. Ancak proje ayarlarından "sdl check" disable da edilebilir. Benzer biçimde proje ayarlarından 
    "Unicode" değeri "not set" yapılmalıdır.

    9) Projenin linker ayarlarından Input/Additional Dependencies edit alanına Winsock kütüphanesi olan "Ws2_32.lib" import 
    kütüphanesi eklenir.

    10) Windows'ta son soket API fonksiyonlarının başarısızlık nedenleri WSAGetLastError fonksiyonuyla elde edilmektedir. Yani 
    Windows sistemlerinde errno değişkeni set edilmemektedir. Belli bir hata kodunun yazıya dönüştürülmesi de biraz ayrıntılıdır. 
    Bunun için aşağıdaki fonksiyonu kullanabilirsiniz:

    void ExitSys(LPCSTR lpszMsg, DWORD dwLastError)
    {
        LPTSTR lpszErr;

        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
            fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
            LocalFree(lpszErr);
        }

        exit(EXIT_FAILURE);
    }

    Yukarıdaki programların Winsock'a dönüştürülmüş biçimleri aşağıda verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <winsock2.h>

#define SERVER_PORT        55555
#define BUFFER_SIZE        4096

void ExitSys(LPCSTR lpszMsg, DWORD dwLastError);

int main(void)
{
    WSADATA wsadata;
    SOCKET server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    int sin_len;
    char buf[BUFFER_SIZE + 1];
    int result;

    if ((result = WSAStartup(MAKEWORD(2, 2), &wsadata)) != 0)
        ExitSys("WSAStartup", result);

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
        ExitSys("socket", WSAGetLastError());

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORT);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == SOCKET_ERROR)
        ExitSys("bind", WSAGetLastError());

    if (listen(server_sock, 8) == SOCKET_ERROR)
        ExitSys("listen", WSAGetLastError());

    printf("waiting for connection...\n");
    sin_len = sizeof(sin_client);
    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == SOCKET_ERROR)
        ExitSys("accept", WSAGetLastError());

    printf("connected client ===> %s:%d\n", inet_ntoa(sin_client.sin_addr), ntohs(sin_client.sin_port));

    for (;;) {
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == SOCKET_ERROR)
            ExitSys("recv", WSAGetLastError());
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received: \"%s\"\n", (intmax_t)result, buf);
    }

    shutdown(client_sock, SD_BOTH);
    closesocket(client_sock);

    closesocket(server_sock);

    WSACleanup();

    return 0;
}

void ExitSys(LPCSTR lpszMsg, DWORD dwLastError)
{
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>

#define SERVER_NAME        "192.168.153.131"
#define SERVER_PORT        55555
#define BUFFER_SIZE        4096

void ExitSys(LPCSTR lpszMsg, DWORD dwLastError);

int main(void)
{
    WSADATA wsadata;
    SOCKET client_sock;
    struct sockaddr_in sin_server;
    struct hostent *hent;
    char buf[BUFFER_SIZE];
    char *str;
    int result;

    if ((result = WSAStartup(MAKEWORD(2, 2), &wsadata)) != 0)
        ExitSys("WSAStartup", result);

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
        ExitSys("socket", WSAGetLastError());

    /*
    {
        struct sockaddr_in sin_client;

        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(50000);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == SOCKET_ERROR)
            ExitSys("bind", WSAGetLastError());
    }
    */

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORT);
    if ((sin_server.sin_addr.s_addr = inet_addr(SERVER_NAME)) == SOCKET_ERROR) {
        if ((hent = gethostbyname(SERVER_NAME)) == NULL)
            ExitSys("gethostbyname", WSAGetLastError());
        memcpy(&sin_server.sin_addr.s_addr, hent->h_addr_list[0], hent->h_length);
    }

    if (connect(client_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == SOCKET_ERROR)
        ExitSys("connect", WSAGetLastError());

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, (int)strlen(buf), 0) == SOCKET_ERROR)
            ExitSys("send", WSAGetLastError());
        if (!strcmp(buf, "quit"))
            break;
    }

    shutdown(client_sock, SD_BOTH);
    closesocket(client_sock);

    WSACleanup();

    return 0;
}

void ExitSys(LPCSTR lpszMsg, DWORD dwLastError)
{
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                101. Ders 26/11/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kurstaki denemeleri genellikle sanal makine üzerinden yapmaktayız. Sanal makine programları zaman içerisinde oldukça 
    gelişmiştir. Bunlardan "docker" sistemleri de evrimleştirilmiştir. Sanal makine için bedava iki önemli alternatif
    "VMware Player" ve "VirtualBox" programlarıdır. Biz kursumuzda "VMware Player" kullanıyoruz. Ancak "VirtualBox" da 
    problemsiz bir biçimde aynı kalitede işlev görmektedir.

    VMware Player donanım sanallaştırmasını tam olarak yapmaktadır. Yani oluşturulan sanal makine tamamen sanki aynı yerel
    ağa bağlı olan bağımsız bir makine gibi davranmaktadır. Bu sanal makineye biz istediğimiz kadar network kartı 
    takabiliriz. TCP/IP denemelerinde client ve server programlar "host" ve "guest" sistemlerde konuşlandırılabilir. Bu durumda
    kullanılacak IP adreslerine dikkat etmek gerekir. VMWare'deki guest IP adresini öğrenebilmek için önce "Virtual Machine 
    Settings/Network Adapter/Advanced" düğmelerinden sanal ethernet kartının MAC adresini görmelisiniz. Sonra host sistemde 
    bu MAC adresine karşı gelen IP adresini bulmaya çalışabilirsiniz. Bunun için "arp -a" komutu kullanılabilir. Bu komutta
    aşağıdaki gibi bir çıktı göreceksiniz:

    Interface: 192.168.153.1 --- 0x10
    Internet Address      Physical Address      Type
    192.168.153.128       00-0c-29-76-3b-e8     dynamic
    192.168.153.131       00-0c-29-76-3b-fc     dynamic
    192.168.153.255       ff-ff-ff-ff-ff-ff     static
    224.0.0.22            01-00-5e-00-00-16     static
    224.0.0.251           01-00-5e-00-00-fb     static
    224.0.0.252           01-00-5e-00-00-fc     static
    239.255.255.250       01-00-5e-7f-ff-fa     static
    255.255.255.255       ff-ff-ff-ff-ff-ff     static

    Burada MAC adresine karşı gelen IP adresini elde edebilirsiniz.

    Benzer biçimde guest sistemden host sisteme erişebilmek için host sistemin guest sistemde kullanılacak IP adresini elde 
    etmeniz gerekir. Bu IP adresi host sistemin LAN üzerindeki yerel IP adresi değildir. Bu IP adresi "arp -a" komutuyla ya da 
    Windows'taki "ipconfig" komutuyla elde edilebilir. Yukarıdaki çıktıdaki ilk satır zaten bunu belirtmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Client ve server programları yazarken onların ilgili olduğu server ve port numaralarını komut satırı argümanlarıyla 
    almak iyi bir tekniktir. Örneğin biz client programı şöyle çalıştırabilmeliyiz:

    ./client -s <server_ismi> -p <server_port> -b <client_port>

    Tabii buradaki -s ve -p seçeneklerinin default değerleri de söz konusu olacaktır.

    Benzer biçimde server program da aşağıdaki gibi çalıştırılabilir olmalıdır:

    ./server -p <port_numarası>

    Buradaki port numarası server'ın dinlediği port numarasıdır. Bunun da bir default değeri olabilir.

    Aşağıda daha önce yazmış olduğumuz client ve server programların bu biçime getirilmiş hallerini veriyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;
    int option;
    int server_port;
    int p_flag, err_flag;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("listening port %d\n", server_port);

    printf("waiting for connection...\n");
    sin_len = sizeof(sin_client);
    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
        exit_sys("accept");

    printf("connected client ===> %s:%d\n", inet_ntoa(sin_client.sin_addr), ntohs(sin_client.sin_port));

    for (;;) {
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received: \"%s\"\n", (intmax_t)result, buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    close(server_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_server, sin_client;
    struct hostent *hent;
    char buf[BUFFER_SIZE];
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int server_port, bind_port;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    if ((sin_server.sin_addr.s_addr = inet_addr(server_name)) == -1) {
        if ((hent = gethostbyname(server_name)) == NULL) {
            fprintf(stderr, "gethostbyname: %s\n", hstrerror(h_errno));
            exit(EXIT_FAILURE);
        }
        memcpy(&sin_server.sin_addr.s_addr, hent->h_addr_list[0], hent->h_length);
    }

    if (connect(client_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("connect");

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    TCP protokolünün gerçekleştirimlerinde tipik olarak işletim sistemleri her soket için "gönderme tamponu (sending buffer)" 
    ve "alma tamponu (receiving buffer)" kullanmaktadır. TCP'de bir akış kontrolünün de uygulandığını anımsayınız. Bu akış 
    kontrolünün nasıl uygulandığına izleyen paragraflarda değineceğiz. Bizim send ya da write fonksiyonlarıyla karşı tarafa 
    göndermek istediğimiz bilgiler önce gönderme tamponuna yazılmakta sonra işletim sistemi tarafından TCP/IP paketi haline 
    getirilip gönderilmektedir. send ve write fonksiyonları bilgiyi gönderme tamponuna yazıp hemen geri dönmektedir. Bu 
    fonksiyonların geri dönmesi bilgilerin karşı tarafa iletildiği anlamına gelmemektedir. Benzer biçimde işletim sistemi 
    network kartına gelen bilgileri onun ilişkin olduğu soketin alma tamponuna kendisi yerleştirmektedir. recv ve read 
    fonksiyonları bu alma tamponuna bakmaktadır. Default blokeli modda bu alma tamponu boşsa bu fonksiyonların blokeye yol 
    açtığını belirtmiştik. Benzer biçimde send ve write fonksiyonları da default blokeli modda gönderme tamponuna bilgi tam 
    olarak yazılamıyorsa bilgi tam olarak tampona yazılana kadar blokeye yol açmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Soket programlamada bir tarafın tek bir send ya da write ile gönderdiklerini diğer tarafın tek bir recv ya da read ile 
    okuması garanti değildir. Örneğin biz tek bir send ile 10000 byte göndermiş olalım. Karşı taraf da recv fonksiyonu ile 
    bir döngüde sürekli okuma yapıyor olsun. Örneğin karşı taraf önce recv ile 4096 byte okuyabilir. Sonra diğer recv ile 
    kalan byte'ları okuyabilir. Bu durum soket programlarının organizasyonunu biraz karışık hale getirmektedir. Bu nedenle 
    örneğin biz 10000 byte gönderen bir tarafın gönderdiği 10000 byte'ı okuyabilmek için bir döngü kullanmamız gerekir. 
    Soketten belli miktarda byte okuyana kadar okumayı devam ettiren bir fonksiyon aşağıdaki gibi yazılabilir:

    ssize_t read_socket(int sock, char *buf, size_t len)
    {
        size_t left, index;

        left = len;
        index = 0;

        while (left > 0) {
            if ((result = recv(sock, buf + index, left, 0)) == -1)
                return -1;
            if (result == 0)
                break;
            index += result;
            left -= result;
        }

        return (ssize_t) index;
    }

    Bu fonksiyonun çalışması oldukça basittir. recv ile her defasında left kadar byte okunmak istenmiştir. Ancak left 
    kadar değil, result kadar byte okunmuş olabilir. Bu durumda left okunan miktar kadar azaltılmış index ise o miktar 
    kadar artırılmıştır. Yukarıdaki fonksiyondan üç nedenle çıkılabilir:

    1) Bağlantı kopmuştur ve recv başarısız olur.
    2) Karşı taraf soketi kapatmıştır. recv 0 ile geri döner.
    3) İstenen kadar miktar okunmuştur.

    Aslında recv fonksiyonunun talep edilen miktarda byte'ların hepsinin okunabilmesi için MSG_WAITALL biçiminde bir flags 
    parametresi de vardır. Ancak MSG_WAITALL flags parametresi alma tamponundan daha yüksek miktarda verilerin okunması 
    için uygun olmayabilmektedir. Bu konu ileride ele alınacaktır.

    Yeniden vurgulamak gerekirse bir soketten n byte okuma işlemi tek bir recv ile başarılmak zorunda değildir. Soket 
    programlamaya yeni başlayanlar sanki bir disk dosyasından ya da borudan bilgi okunuyor gibi tek bir okuma çağrısı ile 
    bunu yapma eğilimindedirler. Halbuki bu işlem yukarıdaki gibi bir döngüyle ya da recv fonksiyonuna MSG_WAITALL flags 
    parametresi girilerek yapılmak zorundadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Zamanla bazı klasik soket fonksiyonları yerine onların işlevini yapabilecek daha yetenekli fonksiyonlar oluşturulmuştur. 
    Eski fonksiyonlar IPv4 zamanlarında tasarlanmıştı. IPv6 ile birlikte bu IPv4 için tasarlanmış olan fonksiyonların IPv6'yı 
    da destekleyecek daha genel versiyonları oluşturuldu. Bu eski fonksiyonların bir bölümü de "deprecated" hale getirildi.
    Biz yukarıdaki örneklerde bu eski fonksiyonları kullandık. Ancak artık yeni uygulamalarda IPv6'yı da destekleyen eski bazı 
    fonksiyonların yeni biçimlerinin kullanılması daha uygundur. Biz de bu bölümde bu fonksiyonları ele alacağız bundan sonra 
    bu fonksiyonları kullanacağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    inet_ntoa fonksiyonu bilindiği gibi 4 byte'lık IPv4 adresini noktalı desimal formata dönüştürüyordu. İşte bu fonksiyonun 
    inet_ntop isimli IPv6'yı da kapsayan gelişmiş bir biçimi vardır:

    #include <arpa/inet.h>

    const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);

    Fonksiyonun birinci parametresi AF_INET (IPv4) ya da AF_INET6 (IPv6) olarak girilmelidir. İkinci parametre dönüştürülecek 
    nümerik IPv4 ya da IPv6 adresinin bulunduğu nesnenin adresini belirtmektedir. Fonksiyon dönüştürme sonucunda elde edilecek 
    yazısal noktalı desimal formatı üçüncü parametreyle belirtilen adresten itibaren yerleştirir. Son parametre üçüncü parametredeki 
    dizinin uzunluğunu belirtir. Bu parametre INET_ADDRSTRLEN ya da INET6_ADDRSTRLEN biçiminde girilebilir. Fonksiyon başarı 
    durumunda üçüncü parametreyle belirtilen adrese, başarısızlık durumunda NULL adrese geri döner. Örneğin bu fonksiyon server 
    programda şöyle kullanılabilir:

    char ntopbuf[INET_ADDRSTRLEN];
    ...
    printf("connected client ===> %s:%u\n", inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN), 
            (unsigned)ntohs(sin_client.sin_port));

    inet_ntoa işleminin tersinin inet_addr ile yapıldığını belirtmiştik. İşte inet_addr fonksiyonunun yerine hem IPv4 hem de 
    IPv6 ile çalışan inet_pton fonksiyonu kullanılabilmektedir:

    #include <arpa/inet.h>

    int inet_pton(int af, const char *src, void *dst);

    Fonksiyonun birinci parametresi yine AF_INET ya da AF_INET6 biçiminde geçilir. İkinci parametre noktalı desimal formatın 
    bulunduğu yazının adresini, üçüncü parametre ise nümerik adresin yerleştirileceği adresi almaktadır. Bu parametreye IPv4 için 
    4 byte'lık, IPv6 için 16 byte'lık yerleştirme yapılmaktadır. Fonksiyon başarı durumunda 1 değerine, başarısızlık durumunda 
    0 ya da -1 değerine geri döner. Eğer başarısızlık birinci parametreden kaynaklanıyorsa -1, ikinci parametreden kaynaklanıyorsa 
    0 değerine geri dönmektedir. Bu durumda örneğin client programda inet_addr yerine inet_pton fonksiyonunu şöyle çağırabilirdik:

    if (inet_pton(AF_INET, server_name, &sin_server.sin_addr.s_addr) == 0) {
        ...
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                102. Ders 02/12/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    IPv6 ile birlikte yeni gelen diğer bir fonksiyon da getaddrinfo isimli fonksiyondur. Bu fonksiyon aslında inet_addr ve 
    gethosybyname fonksiyonlarının IPv6'yı da içerecek biçimde genişletilmiş bir biçimidir. Yani getaddrinfo hem noktalı 
    desimal formatı nümerik adrese dönüştürür hem de eğer geçersiz bir noktalı desimal format söz konusuysa (bu durumda server 
    isimsel olarak girilmiş olabilir) DNS işlemi yaparak ilgili host'un IP adresini elde eder. Maalesef fonksiyon biraz karışık 
    tasarlanmıştır. Fonksiyonun prototipi şöyledir:

    #include <netdb.h>

    int getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res);

    Fonksiyonun birinci parametresi "noktalı desimal formatlı IP adresi" ya da "host ismini" belirtmektedir. İkinci parametre 
    NULL geçilebilir ya da buraya port numarası girilebilir. Ancak bu parametreye port numarası girilecekse yazısal biçimde 
    girilmelidir. Fonksiyon bu port numarasını htons yaparak "big endian" formata dönüştürüp bize verecektir. Bu parametreye
    aynı zamanda IP ailesinin uygulama katmanına ilişkin spesifik bir protokolün ismi de girilebilmektedir (Örneğin "http" gibi, 
    "ftp" gibi). Bu durumda bu protokollerin port numaraları bilindiği için sanki o port numaraları girilmiş gibi işlem yapılır.
    Eğer bu parametreye NULL girilirse bize port olarak 0 verilecektir. Port numarasını biz yerleştiriyorsak bu parametreye NULL 
    girebiliriz. Fonksiyonun üçüncü parametresi nasıl bir adres istediğimizi anlatan filtreleme seçeneklerini belirtir. Bu parametre 
    addrinfo isimli bir yapı türündendir. Bu yapının yalnızca ilk dört elemanı programcı tarafından girilebilmektedir. Ancak POSIX 
    standartları bu yapının elemanlarının sıfırlanmasını öngörmektedir (buradaki sıfırlanmak terimi normal türdeki elemanlar için 
    0 değerini, göstericiler için NULL adres değerini belirtmektedir). addrinfo yapısı şöyledir:

    struct addrinfo {
        int              ai_flags;
        int              ai_family;
        int              ai_socktype;
        int              ai_protocol;
        socklen_t        ai_addrlen;
        struct sockaddr *ai_addr;
        char            *ai_canonname;
        struct addrinfo *ai_next;
    };

    Yapının ai_flags elemanı pek çok bayrak değeri alabilmektedir. Bu değer 0 olarak da geçilebilir. Yapının ai_family elemanı 
    AF_INET girilirse host'a ilişkin IPv4 adresleri, AF_INET6 girilirse host'a ilişkin IPv6 adresleri, AF_UNSPEC girilirse hem 
    IPv4 hem de IPv6 adresleri elde edilir. Yapının ai_socktype elemanı 0 girilebilir ya da SOCK_STREAM veya SOCK_DGRAM girilebilir. 
    Fonksiyonun ayrıntılı açıklaması için dokümanlara başvurunuz. Bu parametre NULL adres de girilebilir. Bu durumda ilgili host'a 
    ilişkin tüm adresler elde edilir.

    getaddrinfo fonksiyonunun son parametresine bir bağlı listenin ilk elemanını gösteren adres yerleştirilmektedir. Buradaki 
    bağlı listenin bağ elemanı struct addrinfo yapısının ai_next elemanıdır. Bu bağlı listenin boşaltımı freeaddrinfo fonksiyonu
    tarafından yapılmaktadır.

    getaddrinfo fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda error koduna geri döner. Bu error kodları klasik 
    errno değerlerinden farklı olduğu için strerror fonksiyonuyla değil, gai_strerror fonksiyonuyla yazıya dönüştürülmelidir.

    Bağlı listenin düğümlerini free hale getirmek için freeaddrinfo fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <netdb.h>

    void freeaddrinfo(struct addrinfo *ai);

    Fonksiyon getaddrinfo fonksiyonunun verdiği bağlı listenin ilk düğümünün (head pointer) adresini parametre olarak alır ve tüm
    bağlı listeyi boşaltır. gai_strerror fonksiyonunun prototipi de şöyledir:

    #include <netdb.h>

    const char *gai_strerror(int ecode);

    getaddrinfo fonksiyonunun client programda tipik kullanımı aşağıda verilmiştir.

    getaddrinfo fonksiyonu sayesinde client program için önceki örneklerde yaptığımız işlemleri oldukça basitleştirmiş olmaktayız. 
    Biz daha önce client programda önce inet_addr fonksiyonu ya da inet_pton fonksiyonu ile server adresinin noktalı formatta olup
    olmadığını anlayıp duruma göre gethostbyname fonksiyonu ile DNS işlemi yapmıştık. Oysa getaddrinfo fonksiyonu bu iki işlemi 
    birlikte yapmaktadır. Bu fonksiyon bize connect için gereken sockaddr_in ya da sockadd_in6 yapı nesnelerini kendisi oluşturup
    sockaddr türünden bir adres gibi vermektedir. Client programın bu fonksiyonu kullanarak bağlantı sağlaması aşağıdaki gibi 
    bir kalıpla sağlanabilir:

    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    ...

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    Burada server_name noktalı desimal formattaki server IP numarasını ya da server ismini belirtmektedir. server_port ise yazısal
    biçimde port numarasını belirtmektedir. sockaddr yapı nesnesinin oluşturulması için gereken bilgiler ise hints parametresinde 
    girilmiştir. Fonksiyon DNS işlemi sonucunda elde edilen host bilgilerini bir bağlı liste biçiminde vermektedir. Bu örnek kodda
    bağlı listenin her elemanı connect fonksiyonuna sokulmuş ve bağlantı sağlanmaya çalışılmıştır. Örneğimizde biz hints parametresine
    AF_INET değerini girdik. Bu durumda DNS işlemi yapılırken fonksiyon yalnızca IPv4 adreslerini elde edecektir. IP bağlantısında 
    bir taraf IPv4, diğer taraf IPv6 da olabilmektedir. hints parametresine eğer biz AF_UNSPEC geçseydik fonksiyon bize hem IPv4 
    hem de IPv6 adreslerini verecektir. Örnek kodda elde edilen adreslerden hiçbiri ile bağlantı sağlanamamışsa program 
    sonlandırılmıştır.

    getaddrinfo fonksiyonunun tersini yapan getnameinfo isminde bir fonksiyon da sonraları soket kütüphanesine eklenmiştir. 
    getnameinfo aslında inet_ntop, getserverbyname (biz görmedik) fonksiyonlarının birleşimi gibidir. Biz aşağıdaki
    örnekte bu fonksiyonu kullanmayacağız.

    #include <netdb.h>

    int getnameinfo(const struct sockaddr *addr, socklen_t addrlen, char *host, 
            socklen_t hostlen, char *serv, socklen_t servlen, int flags);

    Fonksiyonun birinci parametresi sockaddr_in ya da sockaddr_in6 yapısını almaktadır. İkinci parametre birinci parametredeki 
    yapının uzunluğudur. Fonksiyonun sonraki dört parametresi sırasıyla noktalı hostun yazısal temsilin yerleştirileceği dizinin 
    adresi ve uzunluğu, port numarasına ilişkin yazının (servis ismi) yerleştirileceği dizinin adresi ve uzunluğudur. Son parametre 
    0 geçilebilir. Maksimum host ismi NI_MAXHOST ile maksimum servis ismi ise NI_MAXSERV ile belirtilmiştir.

    Yukarıda yazdığımız server ve client programlarının yeni fonksiyonlarla modern yazım biçimini de aşağıda veriyoruz. Bu 
    server ve client programları birer şablon olarak kullanabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;
    char buf[BUFFER_SIZE + 1];
    char ntopbuf[INET_ADDRSTRLEN];
    ssize_t result;
    int option;
    int server_port;
    int p_flag, err_flag;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("listening port %d\n", server_port);

    printf("waiting for connection...\n");
    sin_len = sizeof(sin_client);
    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
        exit_sys("accept");

    printf("connected client ===> %s:%u\n", inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sin_client.sin_port));

    for (;;) {
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received: \"%s\"\n", (intmax_t)result, buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    close(server_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[BUFFER_SIZE];
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Soket bağlantısında kullanılan diğer iki fonksiyon da getpeername ve getsockname fonksiyonlarıdır. getpeername fonksiyonu
    bağlı bir soketi parametre olarak alır ve karşı tarafın ip adresini ve port numarasını bize sockaddr_in ya da sockaddr_in6 
    biçiminde verir. Tabii aslında server bağlantıyı yaptığında karşı tarafın bilgisini zaten accept fonksiyonunda almaktadır. 
    Bu bilgi saklanarak kullanılabilir. Ancak bu bilgi saklanmamışsa istenildiği zaman getpeername fonksiyonuyla alınabilmektedir. 
    Fonksiyonun prototipi şöyledir:

    #include <sys/socket.h>

    int getpeername(int sock, struct sockaddr *addr, socklen_t *addrlen);

    Fonksiyonun birinci parametresi soket betimleyicisidir. İkinci parametre duruma göre karşı tarafın bilgilerinin yerleştirileceği 
    sockaddr_in ya da sockaddr_in6 yapı nesnesinin adresini alır. Son parametre ikinci parametredeki yapının uzunluğunu belirtmektedir. 
    Eğer buraya az bir uzunluk girilirse kırpma yapılır ve gerçek uzunluk verdiğimiz adresteki nesneye yerleştirilir. Fonksiyon başarı 
    durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    getpeername fonksiyonunun ters işlemini getsockname fonksiyonu yapmaktadır. Bu fonksiyon kendi bağlı soketimizin ip adresini ve 
    port numarasını elde etmek için kullanılır. Genellikle bu fonksiyona gereksinim duyulmamaktadır.

    #include <sys/socket.h>

    int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

    Fonksiyonun parametrik yapısı ve geri dönüş değeri getpeername fonksiyonundaki gibidir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar TCP bağlantısının sağlanması ve send/recv fonksiyonlarının kullanımlarını gördük. Artık dikkatimizi 
    bağlantı sonrasındaki haberleşmeye yönelteceğiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP/IP client-server programlamada en önemli konulardan biri "çok client'lı (multi-client)" server programların yazılmasıdır.
    Server program birden fazla client ile haberleşme yaparken bir client için recv ya da read fonksiyonunu kullandığında 
    eğer o client'a bilgi gelmemişse bloke oluşacağından dolayı diğer client'lardan bilgi okuyamayacaktır. Bu durumda daha önce
    görmüş olduğumuz ileri IO tekniklerinin uygulanması gerekmektedir. Biz daha önce bu ileri IO tekniklerini borular üzerinde
    incelemiştik. Aslında bu tekniklerin borularda kullanılmasıyla soketlerde kullanılması benzer biçimdedir. Daha önce ele 
    aldığımız ileri IO teknikleri şunlardı (scatter/getter IO tekniğini burada listelemiyoruz):

    1) Multiplexed IO
    2) Sinyal Tabanlı (Signal Driven) IO
    3) Asenkron IO

    İşte biz bu bölümde bu IO tekniklerini de kullanarak çok client'lı TCP server uygulamalarının nasıl yazılabileceği üzerinde
    duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çok client'lı server uygulamalarında accept fonksiyonu bir kez çağrılmaz. Bir döngü içerisinde çağrılır. Çünkü server 
    her client için accept uygulamak zorundadır. Örneğin:

    for (;;) {
        printf("waiting for connection...\n");
        sin_len = sizeof(sin_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
            exit_sys("accept");

        printf("connected client ===> %s:%u\n", inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN), 
                (unsigned)ntohs(sin_client.sin_port));
    }

    Tabii accept fonksiyonu default durumda blokeye yol açmaktadır. Pekiyi hem accept fonksiyonunda beklenip hem de 
    bağlanılmış client'lar ile konuşma nasıl yapılacaktır?
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                103. Ders 03/12/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Multi-client programlar için en basit ancak en verimsiz yöntem/model "fork modeli"dir. Eğer az sayıda client söz konusu ise 
    bu model basitliğinden dolayı tercih edilebilir. Bu modelde her accept işleminde bir fork yapılır. Alt proses bağlanılan
    client ile konuşur. Ancak her client için yeni bir prosesin yaratılması aslında verimsiz bir yöntemdir. Tabii az client
    söz konusu ise basitliğinden dolayı bu yöntem yine de kullanılabilir.

    Aşağıda fork modeliyle multi-client bir server örneği verilmiştir. Örnekte client programlar server ile bağlanıp ona yazı 
    göndermekte, server program da bu yazıyı ters çevirerek client programlara geri yollamaktadır. Örneği test etmek için 
    birden fazla terminal penceresi açmalısınız. Bu programda fork işlemi yapıldığında üst prosesin o andaki bellek alanının 
    alt prosese kopyalandığına dolayısıyla alt prosesin son accept yapılan client sokete sahip olduğuna dikkat ediniz. 
    Örneğimizde server program sonsuz döngüde çalışmaktadır. Server programı sonlandırmak için Ctrl+c tuşlarıyla ona SIGINT
    sinyalini gönderebilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096

void client_proc(int sock, struct sockaddr_in *sin);
char *revstr(char *str);
void exit_sys(const char *msg);

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;
    char ntopbuf[INET_ADDRSTRLEN];
    int option;
    int server_port;
    int p_flag, err_flag;
    pid_t pid;
    struct sigaction sa;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    sa.sa_handler = SIG_IGN;

    if (sigaction(SIGCHLD, &sa, NULL) == -1)
        exit_sys("sigaction");

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("listening port %d\n", server_port);

    for (;;) {
        printf("waiting for connection...\n");
        sin_len = sizeof(sin_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
            exit_sys("accept");

        printf("connected client ===> %s:%u\n", inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sin_client.sin_port));

        if ((pid = fork()) == -1)
            exit_sys("fork");

        if (pid == 0) {
            client_proc(client_sock, &sin_client);
            exit(EXIT_SUCCESS);
        }
    }

    close(server_sock);

    return 0;
}

void client_proc(int sock, struct sockaddr_in *sin)
{
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    char ntopbuf[INET_ADDRSTRLEN];
    unsigned port;
    ssize_t result;

    inet_ntop(AF_INET, &sin->sin_addr, ntopbuf, INET_ADDRSTRLEN);
    port = (unsigned)ntohs(sin->sin_port);

    for (;;) {
        if ((result = recv(sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received from %s:%u: \"%s\"\n", (intmax_t)result, ntopbuf, port, buf);
        revstr(buf);
        if (send(sock, buf, result, 0) == -1)
            exit_sys("send");
    }

    printf("client disconnected %s:%u\n", ntopbuf, port);

    shutdown(sock, SHUT_RDWR);
    close(sock);
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    ssize_t result;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;

        buf[result] = '\0';
        printf("%s\n", buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Thread modeli fork modeline benzemektedir. Ancak thread yaratmak proses yaratmaktan daha kolay olduğu için proses modeline
    göre daha az maliyetlidir. Bu modelde her accept işleminde bir proses değil, thread yaratılmaktadır. Tabii thread'ler aynı 
    adres alanını kullandığı için onlara gerekli parametreler uygun biçimde geçirilmelidir.

    Aşağıdaki örnekte fork işlemi ile proses yaratmak yerine pthread_create fonksiyonu ile thread yaratılmıştır. Yaratılan 
    thread'e client bilgileri CLIENT_INFO yapısı eşliğinde geçirilmiştir. CLIENT_INFO yapı nesnesi dinamik olarak tahsis edilmiş 
    ve thread fonksiyonu içerisinde free işlemi uygulanmıştır. UNIX/Linux sistemlerinde nasıl "zombie proses" oluyorsa "zombie
    thread" de oluşabilmektedir. Örneğimizde zombie thread oluşumunu engellemek için thread yaratılır yaratılmaz pthread_detach
    fonksiyonu ile thread detach moda sokulmuştur. 
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096

void *client_thread_proc(void *param);
char *revstr(char *str);
void exit_sys(const char *msg);

typedef struct tagCLIENT_INFO {
    int sock;
    struct sockaddr_in sin;
} CLIENT_INFO;

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;
    char ntopbuf[INET_ADDRSTRLEN];
    int option;
    int server_port;
    int p_flag, err_flag;
    pthread_t tid;
    CLIENT_INFO *ci;
    int result;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("listening port %d\n", server_port);

    for (;;) {
        printf("waiting for connection...\n");
        sin_len = sizeof(sin_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
            exit_sys("accept");

        printf("connected client ===> %s:%u\n", inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sin_client.sin_port));

        if ((ci = (CLIENT_INFO *)malloc(sizeof(CLIENT_INFO))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }

        ci->sock = client_sock;
        ci->sin = sin_client;

        if ((result = pthread_create(&tid, NULL, client_thread_proc, ci)) != 0) {
            fprintf(stderr, "pthread_create: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }

        if ((result = pthread_detach(tid)) != 0) {
            fprintf(stderr, "pthread_detach: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }
    }

    close(server_sock);

    return 0;
}

void *client_thread_proc(void *param)
{
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    char ntopbuf[INET_ADDRSTRLEN];
    unsigned port;
    ssize_t result;
    CLIENT_INFO *ci = (CLIENT_INFO *)param;

    inet_ntop(AF_INET, &ci->sin.sin_addr, ntopbuf, INET_ADDRSTRLEN);
    port = (unsigned)ntohs(ci->sin.sin_port);

    for (;;) {
        if ((result = recv(ci->sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received from %s:%u: \"%s\"\n", (intmax_t)result, ntopbuf, port, buf);
        revstr(buf);
        if (send(ci->sock, buf, result, 0) == -1)
            exit_sys("send");
    }

    printf("client disconnected %s:%u\n", ntopbuf, port);

    shutdown(ci->sock, SHUT_RDWR);
    close(ci->sock);

    free(ci);

    return NULL;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    ssize_t result;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;

        buf[result] = '\0';
        printf("%s\n", buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Multi-client server uygulamaları için diğer model de select modelidir. Biz daha önce bu modeli zaten görmüştük ve borular
    üzerinde bu modeli kullanmıştık. Soketler üzerinde de select modelinin kullanılması borulara çok benzerdir. Burada dikkat 
    edilmesi gereken noktalar şunlardır:

    1) Sokete bilgi geldiğinde, karşı taraf soketi kapattığında ve yeni bir bağlantı isteği oluştuğunda bu durum select tarafından 
    bir "okuma olayı" olarak ele alınmaktadır.

    2) İşin başında dinleme soketi (pasif soket) select fonksiyonunun okuma kümesine yerleştirilmelidir. select fonksiyonunun 
    blokesi çözüldüğünde eğer söz konusu okuma olayı dinleme soketi üzerinde gerçekleşmişse bu durumda yeni bir bağlantı isteği
    söz konusudur. Bizim de accept fonksiyonunu çağırıp buradan elde ettiğimiz yeni soketi de select fonksiyonunun okuma kümesine
    dahil etmemiz gerekir.

    3) Karşı taraf soketi kapattığında bu durum recv fonksiyonunda anlaşılmaktadır. Dolayısıyla programcının soketi kapatıp ilgili 
    betimleyiciyi select fonksiyonunun okuma kümesinden çıkarması da gerekir.

    Aşağıda select modeli ile bir TCP server örneği verilmiştir. Bu örnekte select fonksiyonunun blokesi çözüldüğünde
    önce betimleyicinin dinleme soketine ilişkin betimleyici olup olmadığına bakılmıştır. Eğer betimleyici dinleme soketine
    ilişkinse accept işlemi uygulanmıştır. Değilse recv işlemi uygulanmıştır. Karşı taraf soketi kapattığında recv fonksiyonu 
    0 ile geri dönecektir. Bu durumda ilgili soket okuma kümesinden çıkartılmıştır. Örneğimizdeki server kodunda iç içe 
    birkaç if deyimi kullanılmıştır. Kod aslında fonksiyonlar yoluyla daha anlaşılabilir biçimde de düzenlenebilirdi.

    Server program için diğer bir tasarım şöyle de olabilirdi: Bağlanan her client için yine bir CLIENT_INFO yapısı tahsis 
    edilebilirdi. Client bilgileri bu yapının içinde saklanabilirdi. Sonra da dosya betimleyicisinden hareketle CLIENT_INFO 
    nesnesine hızlı bir biçimde erişmek için "hash tablosu" oluşturulabilirdi. 
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096

char *revstr(char *str);
void exit_sys(const char *msg);

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sinaddr_len;
    char buf[BUFFER_SIZE + 1];        /* BUFFER_SIZE is enough */
    socklen_t sin_len;
    char ntopbuf[INET_ADDRSTRLEN];
    int option;
    int server_port;
    int p_flag, err_flag;
    fd_set rset, tset;
    int maxfds;
    ssize_t result;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    FD_ZERO(&rset);
    FD_SET(server_sock, &rset);
    maxfds = server_sock;

    printf("listening port %d\n", server_port);

    for (;;) {
        printf("waiting for connection...\n");

        tset = rset;
        if (select(maxfds + 1, &tset, NULL, NULL, NULL) == -1)
            exit_sys("select");

        for (int fd = 0; fd <= maxfds; ++fd)
            if (FD_ISSET(fd, &tset)) {
                if (fd == server_sock) {
                    sin_len = sizeof(sin_client);
                    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
                        exit_sys("accept");
                    FD_SET(client_sock, &rset);
                    if (client_sock > maxfds)
                        maxfds = client_sock;

                    inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                    printf("connected client ===> %s:%u\n", ntopbuf, (unsigned)ntohs(sin_client.sin_port));
                }
                else {
                    sinaddr_len = sizeof(sin_client);
                    if (getpeername(fd, (struct sockaddr *)&sin_client, &sinaddr_len) == -1)
                        exit_sys("getpeername");
                    inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);

                    if ((result = recv(fd, buf, BUFFER_SIZE, 0)) == -1)
                        exit_sys("recv");
                    if (result > 0) {
                        buf[result] = '\0';
                        if (!strcmp(buf, "quit"))
                            goto DISCONNECT;

                        printf("%jd byte(s) received from %s:%u: \"%s\"\n", (intmax_t)result, ntopbuf, (unsigned)ntohs(sin_client.sin_port), buf);

                        revstr(buf);
                        if (send(fd, buf, result, 0) == -1)
                            exit_sys("send");
                    }
                    else {        /* result == 0 */
                    DISCONNECT:
                        shutdown(fd, SHUT_RDWR);
                        close(fd);
                        FD_CLR(fd, &rset);

                        printf("client disconnected ===> %s:%u\n", ntopbuf, (unsigned)ntohs(sin_client.sin_port));
                    }
                }
            }
    }

    close(server_sock);

    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    ssize_t result;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;

        buf[result] = '\0';
        printf("%s\n", buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    poll modeli de select modeline benzer biçimde uygulanabilir. Bu modelde dikkat edilmesi gereken noktalar şunlardır:

    1) İşin başında yine dinleme soketi (pasif soket) pollfd dizisi içerisine yerleştirilmiş olmalıdır.

    2) pollfd yapısının izlenecek olayı belirten events elemanı POLLIN olarak girilebilir.

    3) poll geri döndüğünde pollfd dizisinin revents elemanlarına bakılmalı ve bu elemanlar üzerinde POLLIN olayının 
    gerçekleşip gerçekleşmediği kontrol edilmelidir.

    4) Yeni bağlantı isteği geldiğinde dinleme soketi üzerinde POLLIN olayı oluşmaktadır. Bu durumda programcının accept işlemini
    yapması gerekir. Yeni bağlantı kurulan client'ın pollfd bilgileri yine diziye eklenmelidir.

    5) Karşı taraf soketi kapattığında yine POLLIN olayı gerçekleşmektedir. Bu durumda recv fonksiyonu ile 0 byte okunursa 
    soketin kapatıldığı anlaşılmaktadır. Tabii bu durumda programcının bu pollfd dizisinden bu elemanı çıkarması gerekir.

    Aşağıda multi-client server için poll modeline bir örnek verilmiştir. Burada pfds isimli bir pollfd dizisini oluşturulmuştur. 
    Bu dizinin maksimum uzunluğu MAX_CLIENT kadardır. Her bağlantı sağlandığında yeni client için bu pollfd dizisine bir eleman 
    eklenmiştir. Bir client disconnect olduğunda bu diziden ilgili eleman silinmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <poll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096
#define MAX_CLIENT            1000

char *revstr(char *str);
void exit_sys(const char *msg);

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sinaddr_len;
    char buf[BUFFER_SIZE + 1];        /* BUFFER_SIZE is enough */
    socklen_t sin_len;
    char ntopbuf[INET_ADDRSTRLEN];
    int option;
    int server_port;
    int p_flag, err_flag;
    struct pollfd pfds[MAX_CLIENT];
    int npfds, count;
    ssize_t result;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    pfds[0].fd = server_sock;
    pfds[0].events = POLLIN;
    npfds = 1;

    printf("listening port %d\n", server_port);

    for (;;) {
        printf("waiting for connection...\n");

        if (poll(pfds, npfds, -1) == -1)
            exit_sys("poll");

        count = npfds;

        for (int i = 0; i < count; ++i) {
            if (pfds[i].revents & POLLIN) {
                if (pfds[i].fd == server_sock) {
                    if (npfds >= MAX_CLIENT) {
                        fprintf(stderr, "number of clints exceeds %d limit!...\n", MAX_CLIENT);
                        continue;
                    }
                    sin_len = sizeof(sin_client);
                    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
                        exit_sys("accept");
                    pfds[npfds].fd = client_sock;
                    pfds[npfds].events = POLLIN;
                    ++npfds;

                    inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                    printf("connected client ===> %s:%u\n", ntopbuf, (unsigned)ntohs(sin_client.sin_port));
                }
                else {
                    sinaddr_len = sizeof(sin_client);
                    if (getpeername(pfds[i].fd, (struct sockaddr *)&sin_client, &sinaddr_len) == -1)
                        exit_sys("getpeername");
                    inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);

                    if ((result = recv(pfds[i].fd, buf, BUFFER_SIZE, 0)) == -1)
                        exit_sys("recv");
                    if (result > 0) {
                        buf[result] = '\0';
                        if (!strcmp(buf, "quit"))
                            goto DISCONNECT;

                        printf("%jd byte(s) received from %s:%u: \"%s\"\n", (intmax_t)result, ntopbuf, (unsigned)ntohs(sin_client.sin_port), buf);

                        revstr(buf);
                        if (send(pfds[i].fd, buf, result, 0) == -1)
                            exit_sys("send");
                    }
                    else {
                    DISCONNECT:
                        shutdown(pfds[i].fd, SHUT_RDWR);
                        close(pfds[i].fd);
                        pfds[i] = pfds[npfds - 1];
                        --npfds;

                        printf("client disconnected ===> %s:%u\n", ntopbuf, (unsigned)ntohs(sin_client.sin_port));
                    }
                }
            }
        }
    }

    close(server_sock);

    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    ssize_t result;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;

        buf[result] = '\0';
        printf("%s\n", buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                104. Ders 09/12/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi Linux sistemlerinde en etkin asenkron IO yöntemi epoll isimli yöntemdir. epoll yönteminin
    yalnızca Linux sistemlerine özgü olduğunu anımsayınız. Yine anımsayacağınız gibi bu yöntemde önce epoll_create ya da 
    epoll_create1 fonksiyonlarıyla bir epoll betimleyicisinin yaratılması gerekiyordu. Daha sonra izlenecek betimleyiciler 
    epoll_ctl fonksiyonu ile izlemeye dahil ediliyordu. Ancak olay beklemesi epoll_wait fonksiyonu ile yapılıyordu.

    Biz daha önce borularla epoll örneği yapmıştık. Soketlerle de işlemler benzer biçimde yürütülmektedir. epoll server 
    modelinin anahtar noktalarını şöyle açıklayabiliriz:

    - Önce dinleme soketi epoll ile izlemeye alınmalıdır. Soketten okuma işlemleri için yine EPOLLIN olayı oluşmaktadır.

    - EPOLLIN olayı oluştuğunda olaya konu olan soket betimleyicisinin dinleme soketi olup olmadığına bakılmalıdır. Eğer olaya
    konu olan betimleyici dinleme soketiyse accept işlemi uygulanıp elde edilen betimleyicinin de izlenmesi sağlanmalıdır.

    - Karşı taraf soketi kapattığında hem EPOLLIN hem de EPOLLERR olayları oluşmaktadır. EPOLLIN olayı oluştuğunda recv 
    uygulanıp 0 byte okunduğunda karşı tarafın soketi kapatmış olacağı düşünülmeli ve client soket kapatılmalıdır.

    - Client soketin kapatılması ile otomatik olarak izleme sona erdirilmektedir. Bunun için ayrıca epoll_ctl kullanılmasına
    gerek yoktur.

    - epoll modelinde karşı tarafın soketi kapatmasından dolayı oluşan EPOLLIN ve EPOLLERR olaylarında getpeername fonksiyonu
    kullanılmamalıdır. (Halbuki select ve poll fonksiyonlarında bu durumda getpeername fonksiyonu kullanılabilmektedir.)

    Anımsanacağı gibi epoll modelinde default izleme biçimi "düzey tetiklemeli (level triggered)" biçimdedir. Düzey tetiklemeli
    izlemede bir olay oluştuğunda o olayda olayın gereği yapılmadıktan sonra o olay yeniden oluşuyor gibi izleme yapılmaktadır. 
    Örneğin düzey tetiklemeli izlemede sokete bilgi gelmiş olsun. Bu durumda epoll_wait yapıldığında EPOLLIN olayı gerçekleşecektir. 
    Ancak eğer biz sokete gelen tüm bilgileri okumazsak epoll_wait fonksiyonunu bir daha çağırdığımızda yine EPOLLIN olayı 
    gerçekleşecektir. Çünkü düzey tetiklemede sokette okunacak bilgi olduğu sürece epoll_wait hep bu olayı oluşturacaktır. Ancak 
    kenar tetiklemede durum böyle değildir. Kenar tetiklemeli modda sokete bilgi gelmiş olsun. Bu durumda epoll_wait yapıldığında
    EPOLLIN olayı gerçekleşecektir. Biz bu olayda soketteki tüm bilgileri okumazsak bile artık epoll_wait fonksiyonunu çağırdığımızda
    EPOLLIN olayı oluşmayacaktır. EPOLLIN olayı bu modda yalnızca sokete yeni bir bilgi geldiğinde oluşmaktadır.

    Aşağıda daha önce yaptığımız client/server örneğinin epoll modeli ile düzey tetiklemeli gerçekleştirimi verilmiştir. 
    Örneğimizde disconnect olan client'ın bilgilerini o sırada getpeername uygulayamadığımızdan dolayı yazdırmadık. (Tabii 
    aslında bu tür uygulamalarda sürekli getpeername uygulamak iyi bir teknik değildir. Bağlanılan client'ın bilgilerini
    bir kere saklayıp oradan elde etmek daha iyi bir yöntemdir. Ancak biz buradaki uygulamalarda kodu karmaşık göstermemek 
    için her defasında getpeername fonksiyonunu kullandık.)
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/epoll.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096
#define MAX_EVENTS            1024

char *revstr(char *str);
void exit_sys(const char *msg);

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sinaddr_len;
    char buf[BUFFER_SIZE + 1];            /* BUFFER_SIZE is enough */
    socklen_t sin_len;
    char ntopbuf[INET_ADDRSTRLEN];
    int option;
    int server_port;
    struct epoll_event ee;
    struct epoll_event ree[MAX_EVENTS];
    int p_flag, err_flag;
    int epfd;
    int nevents;
    ssize_t result;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    if ((epfd = epoll_create(1024)) == -1)
        exit_sys("epoll_create");

    ee.events = EPOLLIN;
    ee.data.fd = server_sock;

    if (epoll_ctl(epfd, EPOLL_CTL_ADD, server_sock, &ee) == -1)
        exit_sys("epoll_ctl");

    printf("listening port %d\n", server_port);

    for (;;) {
        printf("waiting for connection...\n");

        if ((nevents = epoll_wait(epfd, ree, MAX_EVENTS, -1)) == -1)
            exit_sys("epoll_wait");

        for (int i = 0; i < nevents; ++i) {
            if (ree[i].events & EPOLLIN) {
                if (ree[i].data.fd == server_sock) {
                    sin_len = sizeof(sin_client);
                    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
                        exit_sys("accept");

                    ee.events = EPOLLIN;
                    ee.data.fd = client_sock;
                    if (epoll_ctl(epfd, EPOLL_CTL_ADD, client_sock, &ee) == -1)
                        exit_sys("epoll_ctl");

                    inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                    printf("connected client ===> %s:%u\n", ntopbuf, (unsigned)ntohs(sin_client.sin_port));
                }
                else {
                    if ((result = recv(ree[i].data.fd, buf, BUFFER_SIZE, 0)) == -1)
                        exit_sys("recv");
                    buf[result] = '\0';

                    if (result > 0) {
                        sinaddr_len = sizeof(sin_client);
                        if (getpeername(ree[i].data.fd, (struct sockaddr *)&sin_client, &sinaddr_len) == -1)
                            exit_sys("getpeername");
                        inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                        printf("%jd byte(s) received from %s:%u: \"%s\"\n", (intmax_t)result, ntopbuf, (unsigned)ntohs(sin_client.sin_port), buf);
                        revstr(buf);
                        if (send(ree[i].data.fd, buf, result, 0) == -1)
                            exit_sys("send");
                    }
                    else {
                        shutdown(ree[i].data.fd, SHUT_RDWR);
                        close(ree[i].data.fd);

                        printf("client disconnected\n");
                    }
                }
            }
        }
    }

    close(server_sock);

    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    ssize_t result;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;

        buf[result]     = '\0';
        printf("%s\n", buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında bu tür client/server uygulamalarında epoll modelinin "kenar tetiklemeli (edge triggered)" modda kullanılmasının 
    daha iyi bir performans sağladığı belirtilmektedir. Kenar tetiklemeli modu kullanırken göz önüne alınması gereken önemli
    anahtar noktalar şunlardır:

    - Kenar tetiklemeli modda sokete bilgi geldiğinde gelen bilgilerin hepsinin okunmasına gayret edilmelidir. Çünkü eğer biz
    sokete bilgi geldiğinde onların hepsini okumazsak bir daha EPOLLIN olayı ancak yeni bir bilgi geldiğinde oluşacağından 
    gelmiş olan bilgilerin işleme sokulması gecikebilecektir. (Halbuki düzey tetiklemeli modda gelen bilgilerin hepsi okunmasa 
    bile bir sonraki epoll_wait çağrımında yine EPOLLIN olayı gerçekleşeceği için böyle bir durum söz konusu olmayacaktır.)

    - Betimleyiciyi kenar tetiklemeli modda izlemek için epoll_event yapısının events elemanına EPOLLET bayrağının eklenmesi 
    gerekmektedir.

    - Kenar tetiklemeli modda sokete gelen tüm bilgilerin okunması için betimleyicinin blokesiz modda olması gerekir. Aksi takdirde
    recv ya da read yaparken sokette bilgi kalmamışsa bloke oluşacaktır. Soket default olarak blokeli moddadır. Soketi daha 
    önce görmüş olduğumuz fcntl fonksiyonu ile aşağıdaki gibi blokesiz moda sokabiliriz:

    if (fcntl(sock, F_SETFL, fcntl(sock, F_GETFL) | O_NONBLOCK) == -1)
        exit_sys("fcntl");

    Blokesiz modda recv ya da read fonksiyonu ile başarısız olana kadar okuma da şöyle yapılabilir:

    for (;;) {
        if ((result = recv(...)) == -1)
            if (errno == EAGAIN)
                break;
            exit_sys("recv");
        }
        // ...
    }

    - Aslında epoll modelinde bazı soket betimleyicileri düzey tetiklemeli bazıları kenar tetiklemeli modda olabilir. Örneğin
    pasif soketi düzey tetiklemeli modda tutup diğerlerini kenar tetiklemeli modda tutabilirsiniz.

    Aşağıda daha önce yazmış olduğumuz client/server programın epoll modeli ile kenar tetiklemeli biçimi verilmiştir. Bu örnekte
    dinleme soketi düzey tetiklemeli modda bırakılmış ancak client soketler kenar tetiklemeli moda sokulmuştur. Soket üzerinde
    EPOLLIN olayı gerçekleştiğinde bir döngü içerisinde recv fonksiyonu EAGAIN nedeniyle başarısız olana kadar okuma yapılmıştır. 
    Tabii bu örnek aslında kenar tetiklemeli modele iyi bir örnek oluşturmamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/epoll.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096
#define MAX_EVENTS            1024

char *revstr(char *str);
void exit_sys(const char *msg);

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sinaddr_len;
    char buf[BUFFER_SIZE + 1];            /* BUFFER_SIZE is enough */
    socklen_t sin_len;
    char ntopbuf[INET_ADDRSTRLEN];
    int option;
    int server_port;
    struct epoll_event ee;
    struct epoll_event ree[MAX_EVENTS];
    int p_flag, err_flag;
    int epfd;
    int nevents;
    ssize_t result;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    if ((epfd = epoll_create(1024)) == -1)
        exit_sys("epoll_create");

    ee.events = EPOLLIN;
    ee.data.fd = server_sock;

    if (epoll_ctl(epfd, EPOLL_CTL_ADD, server_sock, &ee) == -1)
        exit_sys("epoll_ctl");

    printf("listening port %d\n", server_port);

    for (;;) {
        printf("waiting for connection...\n");

        if ((nevents = epoll_wait(epfd, ree, MAX_EVENTS, -1)) == -1)
            exit_sys("epoll_wait");

        for (int i = 0; i < nevents; ++i) {
            if (ree[i].events & EPOLLIN) {
                if (ree[i].data.fd == server_sock) {
                    sin_len = sizeof(sin_client);
                    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
                        exit_sys("accept");

                    if (fcntl(client_sock, F_SETFL, fcntl(client_sock, F_GETFL) | O_NONBLOCK) == -1)
                        exit_sys("fcntl");

                    ee.events = EPOLLIN|EPOLLET;
                    ee.data.fd = client_sock;
                    if (epoll_ctl(epfd, EPOLL_CTL_ADD, client_sock, &ee) == -1)
                        exit_sys("epoll_ctl");

                    inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                    printf("connected client ===> %s:%u\n", ntopbuf, (unsigned)ntohs(sin_client.sin_port));
                }
                else {
                    for (;;) {
                        if ((result = recv(ree[i].data.fd, buf, BUFFER_SIZE, 0)) == -1) {
                            if (errno == EAGAIN)
                                break;
                            exit_sys("recv");
                        }
                        buf[result] = '\0';

                        if (result > 0) {
                            sinaddr_len = sizeof(sin_client);
                            if (getpeername(ree[i].data.fd, (struct sockaddr *)&sin_client, &sinaddr_len) == -1)
                                exit_sys("getpeername");
                            inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                            printf("%jd byte(s) received from %s:%u: \"%s\"\n", (intmax_t)result, ntopbuf, (unsigned)ntohs(sin_client.sin_port), buf);
                            revstr(buf);
                            if (send(ree[i].data.fd, buf, result, 0) == -1)
                                exit_sys("send");
                        }
                        else {
                            shutdown(ree[i].data.fd, SHUT_RDWR);
                            close(ree[i].data.fd);

                            printf("client disconnected\n");
                            break;
                        }
                    }
                }
            }
        }
    }

    close(server_sock);

    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    ssize_t result;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;

        buf[result] = '\0';
        printf("%s\n", buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi asenkron IO için başı aio_ ile başlayan bir grup asenkron IO fonksiyonları da bulunuyordu. Bu fonksiyonlarla
    okuma yazma yapılırken işlemler başlatılıyor ancak akış bloke olmadan arka planda devam ettiriliyordu. Olayın bittiği de bize 
    bir sinyal ya da bir callback fonksiyonu yoluyla bildiriliyordu. Biz bu yöntemi daha önce incelemiş ve bununla ilgili bazı 
    örnekler yapmıştık. Şimdi de bu yöntemi soketlerde kullanacağız.

    Asenkron IO modelinin soketlerde kullanılmasına ilişkin anahtar noktalar şunlardır:

    - accept işleminin bu mekanizmaya dahil edilmesi gerekmemektedir. Yani akış accept işleminde bloke olabilir. Tabii istenirse 
    accept işlemi de bu mekanizmaya dahil edilebilir. Çünkü accept işlemi de bir okuma durumu oluşturmaktadır.

    - Bir okuma (ya da yazma) olayından sonra yeniden aynı mekanizmanın aio_read fonksiyonu çağrılarak kurulması gerekmektedir. 
    Yani aio_read bir kez değil, her defasında yeniden çağrılmalıdır.

    Aşağıda daha önce yapmış olduğumuz server programını bu kez asenkron IO fonksiyonlarıyla gerçekleştiriyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <aio.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096
#define MAX_EVENTS            1024

void io_proc(union sigval sval);
char *revstr(char *str);
void exit_sys(const char *msg);

typedef struct tagCLIENT_INFO {
    struct aiocb cb;
    char buf[BUFFER_SIZE + 1];        /* BUFFER_SIZE is enough */
    char ntopbuf[INET_ADDRSTRLEN];
    unsigned port;
} CLIENT_INFO;

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;
    int option;
    int server_port;
    CLIENT_INFO *ci;
    int p_flag, err_flag;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("listening port %d\n", server_port);

    for (;;) {
        printf("waiting for connection...\n");

        sin_len = sizeof(sin_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
            exit_sys("accept");

        if ((ci = (CLIENT_INFO *)calloc(1, sizeof(CLIENT_INFO))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }

        inet_ntop(AF_INET, &sin_client.sin_addr, ci->ntopbuf, INET_ADDRSTRLEN);
        ci->port = ntohs(sin_client.sin_port);

        printf("connected client ===> %s:%u\n", ci->ntopbuf, ci->port);

        ci->cb.aio_fildes = client_sock;
        ci->cb.aio_offset = 0;
        ci->cb.aio_buf = ci->buf;
        ci->cb.aio_nbytes = BUFFER_SIZE;
        ci->cb.aio_reqprio = 0;
        ci->cb.aio_sigevent.sigev_notify = SIGEV_THREAD;
        ci->cb.aio_sigevent.sigev_value.sival_ptr = ci;
        ci->cb.aio_sigevent.sigev_notify_function = io_proc;
        ci->cb.aio_sigevent.sigev_notify_attributes = NULL;

        if (aio_read(&ci->cb) == -1)
            exit_sys("aio_read");
    }

    close(server_sock);

    return 0;
}

void io_proc(union sigval sval)
{
    CLIENT_INFO *ci = (CLIENT_INFO *)sval.sival_ptr;
    ssize_t result;

    if ((result = aio_return(&ci->cb)) == -1)
        exit_sys("aio_return");

    ci->buf[result] = '\0';

    if (result > 0) {
        printf("%jd byte(s) received from %s:%u: \"%s\"\n", (intmax_t)result, ci->ntopbuf, (ci->port), ci->buf);
        revstr(ci->buf);
        if (send(ci->cb.aio_fildes, ci->buf, result, 0) == -1)
            exit_sys("send");

        if (aio_read(&ci->cb) == -1)
            exit_sys("aio_read");
    }
    else {
        shutdown(ci->cb.aio_fildes, SHUT_RDWR);
        close(ci->cb.aio_fildes);

        printf("client disconnected ===> %s:%u\n", ci->ntopbuf, (ci->port));
        free(ci);
    }
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    ssize_t result;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;

        buf[result] = '\0';
        printf("%s\n", buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                105. Ders 10/12/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bu noktada dikkatimizi UDP protokolü üzerine yönelteceğiz. UDP protokolünü ele aldıktan sonra yine TCP protokolü ile ilgili
    bazı ayrıntılar üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Giriş kısmında da belirttiğimiz gibi UDP (User Datagram Protocol) bağlantılı olmayan bir protokoldür. Dolayısıyla bir 
    taraf bir tarafa hiç bağlanmadan onun IP adresini ve port numarasını bilerek UDP paketlerini gönderebilir. Gönderen taraf 
    alan tarafın paketi alıp almadığını bilmez. Yani UDP protokolünde bir akış kontrolü yoktur. Dolayısıyla alan taraf bilgi 
    kaçırabilir. Protokol kaçırılan bilgilerin telafisini kendisi yapmamaktadır. Halbuki TCP protokolünde bir bağlantı oluşturulduğu 
    için bir akış kontrolü uygulanarak karşı tarafa ulaşmamış TCP paketlerinin yeniden gönderilmesi sağlanmaktadır.

    UDP tabii ki TCP'ye göre daha hızlıdır. Zaten TCP bir bakıma UDP'nin organize edilmiş bağlantılı biçimidir. Pekiyi UDP protokolü 
    ile ağ katmanı protokolü olan IP protokolü arasındaki fark nedir? Her iki protokolde aslında paketlerin iletimini yapmaktadır. 
    Aslında UDP protokolünün gerçekten de IP protokolünden çok farkı yoktur. Ancak UDP bir aktarım (transport) katmanı protokolü olduğu 
    için port numarası içermektedir. Halbuki IP protokolünde port numarası kavramı yoktur. Yani IP protokolünde biz bir host'a paket 
    gönderebiliriz. Onun belli bir portuna paket gönderemeyiz. Bunun dışında UDP ile IP protokollerinin kullanımları konusunda yine 
    bazı farklılıklar vardır. Aslında biz programcı olarak doğrudan IP paketleri de gönderebiliriz. Buna "raw socket" kullanımı 
    denilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP'de accept uygulayan tarafa "server", connect uygulayana tarafa "client" denilmektedir. Ancak UDP bağlantısız bir protokol
    olduğu için "client" ve "server" kavramları bu protokolde tam oturmamaktadır. Ancak yine de genellikle hizmet alan tarafa
    "client", hizmet veren tarafa "server" denilmektedir. UDP'de client daha çok gönderim yapan, server ise okuma yapan taraftır.

    UDP özellikle periyodik kısa bilgilerin gönderildiği ve alındığı durumlarda hız nedeniyle tercih edilmektedir. UDP haberleşmesinde 
    bilgiyi alan tarafın (server) bilgi kaçırabilmesi söz konusu olabileceğinden dolayı böyle kaçırmalarda sistemde önemli bir
    aksamanın olmaması gerekir. Eğer bilgi kaçırma durumlarında sistemde önemli aksamalar oluşabiliyorsa UDP yerine TCP tercih 
    edilmelidir. Örneğin bir televizyon yayınında görüntüye ilişkin bir frame karşı taraf tarafından alınmadığında önemli bir 
    aksama söz konusu değildir. Belki görüntüde bir kasis olabilir ancak bu durum önemli kabul edilmemektedir. Örneğin birtakım 
    makineler belli periyotlarda server'a "ben çalışıyorum" demek için periyodik UDP paketleri yollayabilir. Server da hangi 
    makinenin çalışmakta olduğunu (bozulmamış olduğunu) bu sayede anlayabilir. Örneğin bir araba simülatörü arabanın durumunu 
    UDP paketleriyle dış dünyaya verebilir. Bir UDP paketi 64K gibi bir sınıra sahiptir.

    TCP ve UDP protokollerinde bir uzunluk bilgisi yoktur. Uzunluk bilgisi IP protokolünde bulunmaktadır. IPv4 ve IPv6 
    protokollerinde bir IP paketi en fazla 64K uzunlukta olabilmektedir. Tabii TCP stream tabanlı olduğu için bu 64K uzunluğun 
    TCP için bir önemi yoktur. Ancak UDP paket tabanlı olduğu için bir UDP paketi IP paketinin uzunluğunu aşamaz. Dolayısıyla bir 
    UDP paketi en fazla 64K uzunlukta olabilmektedir. Büyük paketlerin UDP ile gönderilmesi için programcının paketlere kendisinin 
    manuel numaralar vermesi gerekebilir. Zaten TCP protokolü bu şekilde bir numaralandırmayı kendi içerisinde yapmaktadır. UDP 
    haberleşmesinin önemli bir farkı da "broadcasting" işlemidir. Broadcasting, yerel ağda belli bir host'un tüm host'lara UDP 
    paketleri gönderebilmesine denilmektedir. TCP'de böyle bir broadcasting mekanizması yoktur.

    UDP header'ı 8 byte'tan oluşmaktadır ve yapısı aşağıdaki gibidir.

    <------- Byte 1 -------><------- Byte 2 -------><------- Byte 3 -------><------- Byte 4 ------->
    +----------------------------------------------+-----------------------------------------------+             ^
    |                  Source Port                 |                Destination Port               |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             |  8 bytes
    |                 Header Length                |                   Checksum                    |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             v
    |                                    Application Layer Data                                    |
    |                                         (Size Varies)                                        |
    +----------------------------------------------------------------------------------------------+

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UDP server programı tipik olarak şu adımlardan geçilerek oluşturulur:

    1) Server SOCK_DGRAM parametresiyle bir socket yaratır.

    2) Soketi bind fonksiyonuyla bağlar.

    3) recvfrom fonksiyonuyla gelen paketleri alır ve sendto fonksiyonuyla UDP paketi gönderir.

    4) Haberleşme bitince server soketi close fonksiyonuyla ile kapatır.

    Haberleşme bittiğinde shutdown gibi bir işlemin gerekmediğine dikkat ediniz. shutdown işlemi TCP'de bağlantıyı koparmak için
    kullanılmaktadır. Halbuki UDP protokolünde zaten bağlantı yoktur. Yukarıdaki adımları fonksiyon temelinde aşağıdaki gibi 
    de özetleyebiliriz:

    socket (SOCK_DGRAM) ---> bind ---> recfrom/sendto ---> close
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UDP client program da şu adımlardan geçilerek oluşturulur:

    1) Client soketi SOCK_DGRAM parametresiyle yaratır.

    2) Client isteğe bağlı olarak soketi bind fonksiyonuyla bağlayabilir.

    3) Client, server'ın host isminden hareketle server'ın IP adresini gethostbyname ya da getaddrinfo fonksiyonuyla elde edebilir.

    4) Client sendto fonksiyonuyla UDP paketlerini gönderir ve recvfrom fonksiyonuyla UDP paketlerini alabilir.

    5) Haberleşme bitince client close fonksiyonuyla soketi kapatır.

    Bu adımları fonksiyon isimleriyle şöyle özetleyebiliriz:

    socket (SOCK_DGRAM) ---> bind (isteğe bağlı) ---> gethostbyname/getaddrinfo (isteğe bağlı) ---> sendto/recvfrom ---> close
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UDP paketlerini okumak için kullanılan recvfrom prototipi şöyledir:

    #include <sys/socket.h>

    ssize_t recvfrom(int socket, void *buffer, size_t length, int flags, struct sockaddr *address, socklen_t *address_len);

    Fonksiyonun birinci parametresi okuma işleminin yapılacağı soketi belirtir. İkinci parametre alınacak bilginin yerleştirileceği 
    adresi belirtmektedir. Üçüncü parametre ikinci parametredeki alanın uzunluğunu belirtir. Eğer buradaki değer UDP paketindeki 
    gönderilmiş olan byte sayısından daha az ise kırpılarak diziye yerleştirme yapılmaktadır. Fonksiyonun üçüncü parametresi (flags) 
    birkaç seçeneğe sahiptir. Bu parametre için 0 girilebilir. Fonksiyonun dördüncü parametresi UDP paketini gönderen tarafın IP 
    adresinin ve port numarasının yerleştirileceği sockaddr_in yapısının adresini alır. Son parametre ise bu yapının uzunluğunu tutan 
    int nesnenin adresini almaktadır. Fonksiyon başarı durumunda UDP paketindeki byte sayısına, başarısızlık durumunda -1 değerine 
    geri dönmektedir.

    recvfrom fonksiyonunun herhangi bir client'tan gelen paketi alabildiğine dikkat ediniz. Dolayısıyla her recvfrom ile alınan paket 
    farklı bir client'a ilişkin olabilmektedir.

    recvfrom fonksiyonu, eğer soket blokeli moddaysa (default durum) UDP paketi gelene kadar blokeye yol açar. Blokesiz modda fonksiyon
    bekleme yapmaz, -1 değeriyle geri döner ve errno EAGAIN değeriyle set edilir.

    sendto fonksiyonunun prototipi de şöyledir:

    #include <sys/socket.h>

    ssize_t sendto(int socket, const void *message, size_t length, int flags, const struct sockaddr *dest_addr, socklen_t dest_len);

    Fonksiyonun parametreleri recvfrom da olduğu gibidir. Yani birinci parametre gönderim yapılacak soketi belirtir. İkinci 
    ve üçüncü parametreler gönderilecek bilgilerin bulunduğu tamponu ve onun uzunluğunu belirtmektedir. Yine bu fonksiyonda 
    da bir flags parametresi vardır. Dördüncü parametre bilginin gönderileceği IP adresini ve port numarasını belirtir. Son 
    parametre ise dördüncü parametredeki yapının (sockaddr_in ya da sockaddr_in6) uzunluğunu alır.

    Fonksiyon blokeli modda paket network tamponuna yazılana kadar blokeye yol açmaktadır. sendto fonksiyonu da başarı durumunda 
    network tamponuna yazılan byte sayısına, başarısızlık durumunda -1'e geri dönmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda tipik bir UDP client-server örneği verilmiştir. Bu örnekte client yine bir prompt'a düşerek kullanıcıdan bir 
    yazı istemektedir. Bu yazıyı UDP paketi biçiminde server'a yollamaktadır. Server da bu yazıyı alıp görüntüledikten sonra 
    yazıyı ters çevirip client'a geri yollamaktadır. Programların komut satırı argümanları diğer örneklerde olduğu gibidir.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <getopt.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096

char *revstr(char *str);
void exit_sys(const char *msg);

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;
    int server_port;
    char buf[BUFFER_SIZE + 1];
    char ntopbuf[INET_ADDRSTRLEN];
    ssize_t result;
    int option;
    int p_flag, err_flag;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
            exit_sys("bind");

    printf("waiting UDP packet...\n");
    for (;;) {
        sin_len = sizeof(sin_client);
        if ((result = recvfrom(server_sock, buf, BUFFER_SIZE, 0, (struct sockaddr *)&sin_client, &sin_len)) == -1)
            exit_sys("recvfrom");
        buf[result] = '\0';

        inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
        printf("%jd byte(s) received from %s:%u: \"%s\"\n", (intmax_t)result, ntopbuf, (unsigned)ntohs(sin_client.sin_port), buf);

        revstr(buf);

        if (sendto(server_sock, buf, result, 0, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("sendto");
    }

    close(server_sock);

    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>

#define DEF_SERVER_NAME        "localhost"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client, sin_server;
    socklen_t sin_len;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res;
    int gai_result;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    char buf[BUFFER_SIZE + 1];        /* BUFFER_SIZE is enough */
    char ntopbuf[INET_ADDRSTRLEN];
    ssize_t result;
    char *str;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    freeaddrinfo(res);

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (!strcmp(buf, "quit"))
            break;

        if (sendto(client_sock, buf, strlen(buf), 0, res->ai_addr, sizeof(struct sockaddr_in)) == -1)
            exit_sys("send");

        sin_len = sizeof(sin_server);
        if ((result = recvfrom(client_sock, buf, BUFFER_SIZE, 0, (struct sockaddr *)&sin_server, &sin_len)) == -1)
            exit_sys("recvfrom");
        buf[result] = '\0';

        inet_ntop(AF_INET, &sin_server.sin_addr, ntopbuf, INET_ADDRSTRLEN);
        printf("%jd byte(s) received from server %s:%u: \"%s\"\n", (intmax_t)result, ntopbuf, (unsigned)ntohs(sin_server.sin_port), buf);
    }

    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                106. Ders 16/12/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP/IP ya da UDP/IP server uygulamalarında server'ın bir client'tan gelen isteği yerine getirmesi bir zaman kaybı 
    oluşturabilmektedir. Server bir client ile uğraşırken diğer client'ların istekleri mecburen bekletilir. İşte bu durumu 
    en aza indirmek için select, poll (ve epoll) modellerinde server bir client'ın isteğini bir thread ile yerine getirebilir. 
    Böylece server birden fazla client'a aynı anda hizmet verebilecektir. Örneğin select modelinde bu işlem şöyle yapılabilir:

    for (;;) {
        select(...);
        if (<belli bir sokete bilgi geldi>) {
            <thread oluştur ve işlemi thread'e devret>
        }
    }

    Benzer biçimde UDP server uygulamasında da işlem şöyle yapılabilir:

    for (;;) {
        recvfrom(...)
        <thread oluştur ve işlemi thread'e devret>
    }

    Tabii burada küçük bir işlem için yeni bir thread'in yaratılıp yok edilmesi etkin bir yöntem değildir. Çünkü bilindiği gibi
    thread'lerin yaratılıp yok edilmeleri de dikkate değer bir zaman kaybı oluşturmaktadır. Thread'ler konusunda da belirttiğimiz 
    gibi bu tür durumlarda "thread havuzları (thread pools)" kullanılabilir. Thread havuzlarında zaten belli bir miktar thread 
    yaratılmış ve bekler durumda (suspend durumda) tutulmaktadır. Böylece client'tan gelen isteğin bu thread'lerden biri tarafından 
    gerçekleştirilmesi sağlanır. POSIX sistemlerinde C'de kullanılabilecek standart bir thread havuzu mekanizmasının olmadığını
    anımsayınız. Bu nedenle böyle bir thread havuzunu programcının kendisi yazabilir ya da C için yazılmış olan bir thread havuzu
    kütüphanesini kullanabilir. Windows sistemlerinde işletim sistemi düzeyinde thread havuzlarına ilişkin standart API fonksiyonları 
    bulunmaktadır. C++'ta pek çok framework içerisinde (MFC gibi, Qt gibi) zaten thread havuzları sınıfsal biçimde bulunmaktadır.

    Pekiyi yoğun bir server düşünelim. Makinemizde de bir tane işlemci bulunuyor olsun. Böyle bir thread havuzunun kullanılması
    gerçek anlamda bir fayda sağlayabilir mi? Örneğin 5 tane client'ın isteğini thread yoluyla sağlamaya çalışalım. Her client'ın 
    isteği için 3 quanta süresi gerekiyor olsun. İşlemler seri yapıldığında toplam 15 quanta zamanında tüm client'ların mesajları 
    işlenmiş olacaktır. Thread'ler kullanıldığında işlemcinin çalışma kuyruğunda (run queue) 5 thread bulunacak ve bunlar 
    zaman paylaşımlı biçimde çalışacaktır. Dolayısıyla yine bu client'ların hepsinin işlerini bitirmesi için 15 quanta süresi 
    gerekecektir. Tabii sistemde başka proseslerin thread'leri de varsa çok thread'li çalışma toplamda bu server'ın diğer 
    proseslere göre daha fazla işlemci zamanı kullanmasına yol açacaktır.

    Ancak makinemizde birden fazla işlemci varsa bu durumda yukarıdaki thread sistemi belirgin bir avantaj sağlayacaktır. 
    Bu tür durumlarda işlemci sayısı kadar thread'in aynı anda çalışması sağlanabilir. Bu thread'ler farklı işlemcilerde
    eş zamanlı bir biçimde çalışabileceği için ciddi bir hızlanma sağlanacaktır. Tabii buradaki thread'lerin aynı anda 
    farklı işlemciler tarafından çalıştırılması gerekir. İşletim sistemleri genellikle bu ayarlamayı kendi içlerinde yapabilmektedir. 
    Örneğin Linux sistemlerinde kullanılan güncel çizelgeleme algoritmasında her işlemci için ayrı bir çalışma kuyruğu oluşturulmakta
    ve thread'ler bunlara dinamik bir biçimde dağıtılmaktadır. Ancak yine de bazı durumlarda thread'lerin belli işlemcilere
    programcı tarafından atanması (processor affinity) gerekebilmektedir.

    Örneğin makinemizde 8 işlemci ya da çekirdek olsun. Bu durumda biz 8 tane thread yaratıp bu 8 thread'in farklı işlemcilerde 
    eş zamanlı olarak kendi içlerinde seri bir biçimde çalışmasını sağlayabiliriz. Bunun sağlanması iki biçimde yapılabilir. 
    Birincisi her thread için yukarıdaki döngü yeniden oluşturulabilir. Örneğin:

    // 1'inci thread

    for (;;) {
        recvfrom(...)
        <mesajı işle>
    }

    // 2'nci thread

    for (;;) {
        recvfrom(...)
        <mesajı işle>
    }
    ...

    Soket fonksiyonları bu bağlamda thread güvenlidir. İkinci yöntemde server aldığı mesajları bir kuyruğa yazar. Thread'ler de 
    aynı kuyruktan mesajları alarak işleme sokar. Örneğin:

    for (;;) {
        recvfrom(...)
        <mesajı kuyruğa yerleştir>
    }
    ...

    // 1'inci thread

    for (;;) {
        <kuyruktan mesajı al işle>
    }

    // 2'nci thread

    for (;;) {
        <kuyruktan mesajı al işle>
    }
    ...

    Bu tür durumlarda işlemci ya da çekirdek sayısından daha fazla thread'in oluşturulması özel durumlar dışında önemli bir 
    fayda sağlamamaktadır.

    Linux'un epoll modelinde thread'li kullanımda Linux genel olarak her işlemci ya da çekirdek için gerektiğinde kendisi 
    thread oluşturmaktadır. Dolayısıyla epoll modeli yukarıdaki gibi bir organizasyon yapılmasa da daha iyi bir performans 
    göstermektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi client istekleri için çok işlemcili ya da çok çekirdekli bir bilgisayar yetmiyorsa ne olacak? Bu tür durumlarda 
    işleri birden fazla server makineye dağıtmak gerekir. Client'ın birden çok server olduğunu fark etmemesi dolayısıyla bu 
    sürecin tamamen server tarafta otomatik hale getirilmesi uygun olur. Aynı makinenin klonundan çıkartılıp sisteme eklendiğinde
    yükü paylaşabilmesi sağlanmalıdır. Böylece "ölçeklenebilir (scalable)" bir sistem söz konusu olacaktır. Pekiyi yük bu server
    makinelere nasıl dağıtılabilir? İşte bunun için kullanılan mekanizmaya "load balancing", bu mekanizmayı sağlayan birime de
    "load balancer" denilmektedir.

    Server Makine        Server Makine        Server Makine        Server Makine        ...

                                Load Balancer

    Bu tür dağıtık sistemlerde client aslında "load balancer" ile bağlantı sağlar. Load balancer, client'ı en az meşgul olan 
    server'a iletir. Bugün kullanılan cloud sistemler de kendi içlerinde load balancer benzeri mekanizmalar içermektedir. 
    Load Balancer'lar tamamen donanımsal olarak ya da tamamen yazılımsal olarak gerçekleştirilebilmektedir. Yazılımsal gerçekleştirim
    daha esnek olabilmektedir. Ancak donanımsal gerçekleştirimler bazı durumlarda daha etkin olabilmektedir.

    Donanımsal load balancer'larda client, server ile bağlantı kurmak istediğinde load balancer devreye girip sanki yalnızca 
    en az meşgul olan server sistemde varmış gibi bağlantıyı onun kabul etmesini sağlamaktadır. Yazılımsal load balancer'larda
    load balancer bir "proxy" gibi çalışmaktadır. Client load balancer ile bağlantı sağlar. Load balancer bunu en az meşgul server'a
    yönlendirir. Bu kez client bu server ile bağlantı kurar. Buradaki load balancer görevini yapan "proxy" programınının server
    yüklerini sürekli izlemesi gerekmektedir. Bunun için genellikle UDP protokolü kullanılmaktadır. Yani UDP ile server makineler
    sürekli bir biçimde kendi durumlarını proxy'ye iletirler. Proxy'de bu bilgilerden hareketle en az meşgul server'ı tespit 
    eder. Tabii server makineler eğer devre dışı kalırsa proxy'inin bunu fark etmesi ve artık ona yönlendirme yapmaması gerekir.
    Benzer biçimde yeni bir server makinesi sisteme eklendiğinde proxy hemen onu da sisteme otomatik olarak dahil etmelidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de TCP/IP ve UDP/IP protokollerinin ve bunun için kullanılan soket fonksiyonlarının ayrıntıları üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP için kullandığımız recv ve send fonksiyonlarının, read ve write fonksiyonlarından tek farkı flags parametresidir. 
    Biz yukarıdaki örneklerde bu parametreyi 0 geçtik. Dolayısıyla yukarıdaki örneklerde kullandığımız recv ve send fonksiyonlarının, 
    read ve write fonksiyonlarından hiçbir farkı yoktur. Pekiyi bu flag değerleri neler olabilir? İşte POSIX standartlarında 
    recv fonksiyonundaki flag değerleri şunlardan biri ya da birden fazlası olabilir:

    MSG_PEEK: Bu bayrak gelen bilginin tampondan okunacağını ancak tampondan atılmayacağını belirtmektedir. Yani biz MSG_PEEK 
    flag değeri ile okuma yaparsak hem bilgiyi elde ederiz hem de sanki hiç okuma yapmamışız gibi bilgi network tamponunda kalır. 
    Dolayısıyla bizim thread'imiz ya da başka bir thread recv yaparsa tampondakini okuyacaktır. Pekiyi bu bayrak hangi amaçla
    kullanılmaktadır. Bazen (çok seyrek olarak) mesajın ne olduğuna MSG_PEEK ile bakıp duruma göre onu kuyruktan almak isteyebiliriz. 
    Eğer mesaj bizim beğenmediğimiz bir mesajsa onu almak istemeyebiliriz. Onun başka bir thread tarafından işlenmesini sağlayabiliriz.

    MSG_OOB: Out-of-band data (urgent data) denilen okumalar için kullanılmaktadır. Out-of-band data konusu ayrı bir paragrafta 
    açıklanacaktır.

    MSG_WAITALL: Bu bayrak n byte okunmak istendiğinde bu n byte'ın hepsi okunana kadar bekleme sağlamaktadır. Fakat bu durumda bir 
    sinyal geldiğinde yine recv -1 ile geri döner ve errno EINTR ile set edilir. Yine soket kapatıldığında ya da soket üzerinde 
    bir hata oluştuğunda fonksiyon talep edilen kadar bilgiyi okuyamamış olabilir. Biz daha önce n byte okuma yapmak için aşağıdaki 
    gibi bir fonksiyon önermiştik:

    ssize_t read_socket(int sock, char *buf, size_t len)
    {
        size_t left, index;

        left = len;
        index = 0;

        while (left > 0) {
            if ((result = recv(sock, buf + index, left, 0)) == -1)
                return -1;
            if (result == 0)
                break;
            index += result;
            left -= result;
        }

        return (ssize_t) index;
    }

    İşte aslında recv fonksiyonundaki MSG_WAITALL bayrağı adeta bunu sağlamaktadır. Ancak yine de bu bayrağın bazı sistemlerde 
    bazı problemleri vardır. Örneğin Windows sistemlerinde ve Linux sistemlerinde bu bayrakla okunmak istenen miktar network alım 
    tamponunun büyüklüğünden fazlaysa istenen miktarda byte okunamayabilmektedir. Ancak bu bayrak yüksek olmayan miktarlarda okumalar 
    için yukarıdaki fonksiyonun yerine kullanılabilmektedir.

    send fonksiyonundaki POSIX bayrakları da şunlardır:

    MSG_EOR: Soket türü SOCK_SEQPACKET ise kaydı sonlandırmakta kullanılır.

    MSG_OOB: Out-of-band data gönderimi için kullanılmaktadır. Bu konu ayrı bir paragrafta ele alınacaktır.

    MSG_NOSIGNAL: Normal olarak send ya da write işlemi yapılırken karşı taraf soketi kapatmışsa bu fonksiyonların çağrıldığı 
    tarafta SIGPIPE sinyali oluşmaktadır. Ancak bu bayrak kullanılırsa böylesi durumlarda SIGPIPE sinyali oluşmaz, send 
    ya da write fonksiyonu -1 ile geri döner ve errno EPIPE değeri ile set edilir.

    Linux, POSIX'in bayraklarından daha fazlasını bulundurmaktadır. Örneğin recv ve send işleminde MSG_DONTWAIT bir çağrımlık 
    "non-blocking" etki yaratmaktadır. Yani recv sırasında network tamponunda hiç bilgi yoksa recv bloke olmaz, -1 ile geri 
    döner ve errno EAGAIN değeri ile set edilir. send işlemi sırasında da network tamponu dolu ise send bloke olmaz -1 ile geri 
    döner ve errno yine EAGAIN değeri ile set edilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Normal olarak connect/accept işlemi TCP'de kullanılmaktadır. Ancak UDP soketlerde de seyrek biçimde connect/accept 
    kullanılabilir. Eğer UDP bir soket connect ile UDP server'a bağlanırsa (server da bunu accept ile kabul etmelidir) bu durumda
    artık iki taraf recvfrom ve sendto fonksiyonlarının yerine recv ve send fonksiyonlarını kullanabilir. Tabii burada yine 
    datagram haberleşmesi yapılmaktadır. Yalnızca her defasında gönderme ve alma işlemlerinde karşı tarafın soketine ilişkin 
    bilgilerin belirtilmesine gerek kalmamaktadır. Bu biçimdeki connect/accept bağlantısında yine bir akış kontrolü uygulanmamaktadır.

    Aslında recv fonksiyonu yerine recvfrom fonksiyonu da kullanılabilir. Yani recvfrom fonksiyonunun son iki parametresi NULL
    geçilirse zaten bu işlem recv ile eşdeğer olmaktadır. Örneğin aşağıdaki iki çağrı eşdeğerdir:

    result = recv(sock, buf, len, flags);
    result = recvfrom(sock, buf, len, flags, NULL, NULL);

    Benzer biçimde send yerine sendto fonksiyonu da kullanılabilir. Bu durumda sendto fonksiyonunun son iki parametresi 
    ihmal edilir. Örneğin aşağıdaki iki çağrı eşdeğerdir:

    result = send(sock, buf, len, flags);
    result = sendto(sock, buf, len, flags, any_value, any_value);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar client ile server programlar arasında ciddi bir mesaj alışverişi yapmadık. Verdiğimiz örneklerde client
    program, server programa bir yazı iletiyordu. Server program da client'a bu yazıyı ters çevirip gönderiyordu. Bu çok basit 
    bir mesajlaşma işlemidir. Halbuki gerçek client-server uygulamalarında mesajlaşmalar çok daha çeşitli ve ayrıntılıdır. 
    Gerçek uygulamalarda client program, server programdan çok çeşitli şeyleri yapmasını isteyebilir. Server'da client'ın isteğine
    uygun bir biçimde yanıtları iletir. Örneğin dört işlem yapan bir server program olsun. Client iki operand'ı server'a gönderip 
    ondan dört işlemden birini yapmasını istesin. Bu durumda client'ın server'a gönderdiği mesajlar fazlalaşmaktadır. Örneğin:

    ADD op1 op2
    SUB op1 op2
    MUL op1 op2
    DIV op1 op2

    Bir chat programında client server'dan pek çok şey isteyebilir. Server da client'a çok çeşitli bilgiler iletebilir. Yani bu 
    tür uygulamalarda mesajın bir içeriği ve parametreleri vardır.

    Pekiyi mesajlar karşı tarafa hangi formatta iletilecektir? İşte bunun için binary ve text olmak üzere iki mesajlaşma 
    tekniği kullanılmaktadır.

    Binary mesajlaşmada kabaca her iki taraf birbirlerine bir yapı nesnesinin içeriğini binary biçimde gönderir. Karşı taraf 
    da bu yapı nesnesini alarak işlemini yapar. Ancak farklı mesajlarda farklı yapılar kullanılacağı için mesajın başında mesajın 
    türünü ve uzunluğunu belirten ortak bir başlık kısmı bulundurulur. Bunun için tipik olarak şöyle bir yol izlenir: Mesajı 
    gönderecek taraf önce mesajın uzunluğunu sonra da mesajın ne mesajı olduğunu belirten mesaj kodunu (numarasını) sonra da 
    mesajın içeriğini karşı tarafa yollar. Bu işlemi "pseudo code" olarak aşağıdaki gibi ifade edebiliriz:

    typedef struct tagMSG_HEADER {
        int len;
        int type;
    } MSG_HEADER;

    typedef struct tagMSG_XXX {
        // message info
    } MSG_XXX;

    typedef struct tagMSG_YYY {
        // message info
    } MSG_YYY;

    Örneğin MSG_XXX mesajı karşı tarafa gönderilecek olsun:

    MSG_HEADER header;
    MSG_XXX msg_xxx;

    header.len = sizeof(MSG_XXX);
    header.type = MSG_TYPE_XXX;
    send(sock, &header, sizeof(MSG_HEADER), 0);

    <msg_xxx'in içi dolduruluyor>

    send(sock, &msg_xxx, sizeof(MSG_XXX), 0);

    Mesajı alan taraf da önce mesajın uzunluğunu ve kodunu elde eder, sonra da türünü elde eder ve soketten o uzunlukta okuma 
    yapar. Örneğin:

    MSG_HEADER header;
    MSG_XXX msg_xxx;
    ...

    recv(sock, &header, sizeof(MSG_HEADER), MSG_WAITALL);

    switch (header.type) {
        case MSG_TYPE_XXX:
            recv(sock, &msg_xxx, sizeof(header.len), MSG_WAITALL);
            process_msg_xxx(&msg_xxx);
            break;
        ...
    }

    Burada aklınıza şöyle bir soru gelebilir: Okuyan taraf zaten mesajın kodunu (numarasını) elde edince o mesajın kaç byte 
    uzunlukta olduğunu bilmeyecek mi? Bu durumda mesajın uzunluğunun karşı tarafa iletilmesine ne gerek var? İşte mesajlar 
    sabit uzunlukta olmayabilir. Örneğin mesajın içerisinde bir metin bulunabilir. Bu durumda mesajın gerçek uzunluğu bu metnin
    uzunluğuna bağlı olarak değişebilir. Genel bir çözüm için mesajın uzunluğunun da karşı tarafa iletilmesi gerekmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                107. Ders 17/12/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki gibi binary tabanlı mesajlaşma daha hızlı ve etkin olma eğiliminde ise de pratikte daha çok text tabanlı mesajlaşmalar
    kullanılmaktadır. Çünkü text tabanlı mesajlaşmalar insanlar tarafından yazısal biçimde de oluşturulabilmektedir. IP protokol 
    ailesinin uygulama katmanındaki POP3, Telnet, FTP gibi protokolleri text tabanlı mesajlaşmayı kullanmaktadır.

    Text tabanlı mesajlaşmada client'tan server'a ve server'dan client'a gönderilen mesajlar bir yazı olarak gönderilir. 
    Karşı taraf bu yazıyı alır, parse eder ve gereğini yapar. Programlama dillerinde yazılarla işlem yapabilen pek çok 
    standart araç bulunduğu için bu biçimde mesajların işlenmesi genel olarak daha kolaydır. Ancak mesaj tabanlı haberleşme 
    genel olarak daha yavaştır. Çünkü birtakım bilgilerin yazısal olarak ifade edilmesi binary ifade edilmesinden genel 
    olarak daha fazla yer kaplama eğilimindedir.

    Text tabanlı mesajlaşmada önemli bir sorun mesajın nerede bittiğinin tespit edilmesidir. Bunun için mesajın sonu özel 
    bir karakterle sonlandırılabilir. Örneğin IP protokol ailesinin uygulama katmanındaki protokoller genel olarak mesajları 
    CR/LF ('\r' ve '\n') çiftiyle bitirmektedir. Örneğin:

    "ADD op1 op2\r\n"
    "SUB op1 op2\r\n"
    "MUL op1 op2\r\n"
    "DIV op1 op2\r\n"

    Tabii bu biçimdeki mesajlaşmalarda soketten CR/LF çifti görülene kadar okuma yapılması gerekir. Bu işlem soketten byte 
    byte okuma ile yapılmamalıdır. Çünkü her byte okuması için prosesin kernel mode'a geçmesi zaman kaybı oluşturmaktadır. 
    Belli bir karakter ya da karakter kümesi görülene kadar soketten okuma işleminin nasıl yapılması gerektiği izleyen 
    paragraflarda açıklanacaktır.

    Yazının sonunun tespit edilmesi için kullanılabilecek diğer bir yöntem de baştan yazının uzunluğunun iletilmesi olabilir. 
    Örneğin:

    "ADD op1 op2"

    Yukarıdaki mesaj için önce bu yazının uzunluğu karşı tarafa iletilebilir. Sonra yazı gönderilir. Okuyan taraf da yazının 
    hepsini belirtilen uzunlukta okuma yaparak elde edebilir.

    Yazının sonuna belli bir karakter yerleştirerek o karakteri görene kadar etkin okuma yapmak için şöyle bir teknik kullanılmaktadır:
    Karakterler soketten tek tek okunmaz. Blok blok okunarak bir tampona yerleştirilir. Sonra bu tampondan karakterler elde edilir. 
    Tabii blok okuması yapıldığında birden fazla satır tamponda bulunabilecektir. Bu durumda okuma sırasında tamponda nerede 
    kalındığının da tutulması gerekir. Bu işlemi yapan klasik bir algoritma "Effective TCP/IP Programming" kitabında verilmiştir. 
    Aşağıda bu biçimde CR/LF çifti görülene kadar soketten etkin bir biçimde yukarıda belirttiğimiz gibi okuma yapan bir fonksiyon 
    örneği veriyoruz:

    ssize_t sock_readline(int sock, char *str, size_t size)
    {
        char *bstr = str;
        static char *bp;
        static ssize_t count = 0;
        static char buf[2048];

        if (size <= 2) {
            errno = EINVAL;
            return -1;
        }

        while (--size > 0) {
            if (--count <= 0) {
                if ((count = recv(sock, buf, sizeof(buf), 0)) == -1)
                    return -1;
                if (count == 0)
                    return 0;
                bp = buf;
            }
            *str++ = *bp++;
            if (str[-1] == '\n')
                if (str - bstr > 1 && str[-2] == '\r') {
                    *str = '\0';
                    break;
                }
        }

        return (ssize_t) (str - bstr);
    }

    Fonksiyonun birinci parametresi okuma yapılacak soketi, ikinci ve üçüncü parametreleri okunacak satırın yerleştirileceği 
    dizinin adresini ve uzunluğunu almaktadır. Buradaki dizinin sonunda her zaman CR/LF ve null karakter bulunacaktır. Fonksiyon 
    başarı durumunda diziye yerleştirilen karakter sayısı ile (CR/LF dahil) geri dönmektedir. Karşı taraf soketi kapatmışsa 
    ve hiçbir okuma yapılamamışsa bu durumda fonksiyon 0 ile geri dönmektedir. Bu durumda programcının verdiği dizinin içeriği 
    kullanılmamalıdır. Mesajın sonunda CR/LF çifti olmadıktan sonra fonksiyon başarılı okuma yapmamaktadır. Fonksiyon başarısızlık 
    durumunda -1 değerine geri döner ve errno uygun biçimde set edilir. Burada yazmış olduğumuz sock_readline fonksiyonu bir 
    satır okunana kadar blokeye yol açmaktadır. Dolayısıyla çok client'lı server uygulamalarında select, poll ve epoll gibi modellerde
    bu fonksiyon bu haliyle kullanılamaz. Örneğin biz select fonksiyonunda bir grup soketi bekliyor olalım. Bir sokete bir satırın 
    yarısı gelmiş olabilir. Bu durumda biz read_line fonksiyonunu çağırırsak bloke oluşacaktır. Tabii gerçi satırın geri kalan kısmı 
    zaten kısa bir süre sonra gelecek olsa da bu durum yine bir kusur oluşturacaktır.

    UNIX/Linux, macOS ve Windows sistemlerinde yalnızca CR ('\r) karakteri imleci bulunulan satırın başına geçirmektedir. Dolayısıyla 
    bir yazının sonunda CR/LF çifti varsa yazının ekrana bastırılmasında bir sorun oluşmayacaktır. Çünkü önce CR karakteri 
    imleci bulunulan satırın başına geçirecek sonra LF karakteri aşağı satırın başına geçirecektir. Böylece yazının sonunda LF
    karakterinin bulunmasıyla CR/LF karakterlerinin bulunması arasında bir fark oluşmayacaktır.

    Aşağıdaki örnekte client program, server programa CR/LF ile sonlandırılmış bir yazı göndermektedir. Server program da bu yazıyı 
    yukarıdaki sock_readline fonksiyonunu kullanarak okuyup ekrana (stdout dosyasına) yazdırmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096

ssize_t sock_readline(int sock, char *str, size_t size);
void exit_sys(const char *msg);

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;
    char buf[BUFFER_SIZE + 1];
    char ntopbuf[INET_ADDRSTRLEN];
    ssize_t result;
    int option;
    int server_port;
    int p_flag, err_flag;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("listening port %d\n", server_port);

    printf("waiting for connection...\n");
    sin_len = sizeof(sin_client);
    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
        exit_sys("accept");

    printf("connected client ===> %s:%u\n", inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sin_client.sin_port));

    for (;;) {
        if ((result = sock_readline(client_sock, buf, BUFFER_SIZE)) == -1)
            exit_sys("sock_readline");
        if (result == 0)
            break;
        if (!strcmp(buf, "quit\r\n"))
            break;
        buf[strlen(buf) - 2] = '\0';
        printf("%jd byte(s) received: \"%s\"\n", (intmax_t)result, buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    close(server_sock);

    return 0;
}

ssize_t sock_readline(int sock, char *str, size_t size)
{
    char *bstr = str;
    static char *bp;
    static ssize_t count = 0;
    static char buf[2048];

    if (size <= 2) {
        errno = EINVAL;
        return -1;
    }

    while (--size > 0) {
        if (--count <= 0) {
            if ((count = recv(sock, buf, sizeof(buf), 0)) == -1)
                return -1;
            if (count == 0)
                return 0;
            bp = buf;
        }
        *str++ = *bp++;
        if (str[-1] == '\n')
            if (str - bstr > 1 && str[-2] == '\r') {
                *str = '\0';
                break;
            }
    }

    return (ssize_t) (str - bstr);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[BUFFER_SIZE];
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        strcat(str, "\r\n");

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit\r\n"))
            break;
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                108. Ders 05/01/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                109. Ders 07/01/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi matematiksel işlemler yapan bir client/server uygulama yazmak isteyelim. Bu multi-client bir uygulama olsun. Bunun için 
    thread modelini kullanalım. (Çünkü bu tür uygulamalarda diğer modeller kullanılırken dikkat etmemiz gereken başka 
    noktalar vardır. Diğer modellerde soketten okunan bilgilerin biriktirilmesi gerekmektedir. Bu biriktirmenin nasıl yapılabileceğini
    izleyen paragraflarda açıklayacağız.)

    Uygulama katmanı protokollerinde genel olarak client'ın server'a her gönderdiği mesaj için server client'a bir yanıt verir. 
    Bu yanıt olumlu ise istenen işlemin yanıtıdır. Olumsuz ise bir hata yanıtıdır. Bu tür protokollerde protokolü tasarlayan baştan 
    client'ın server'a, server'ın da client'a göndereceği mesajları belirlemelidir.

    Matematiksel işlemler yapan client/server programımızda client'ın server'a göndereceği mesajlar şunlar olabilir:

    "LOGIN <user_name> <password>\r\n"
    "ADD op1 op2\r\n"
    "SUB op1 op2\r\n"
    "MUL op1 op2\r\n"
    "DIV op1 op2\r\n"
    "SQRT op1\r\n"
    "POW op1\r\n"
    "LOGOUT\r\n"

    Server'ın client'a gönderdiği mesajlar da şunlar olabilir:

    "LOGIN_ACCEPTED\r\n"
    "LOGOUT_ACCEPTED\r\n"
    "RESULT result\r\n"
    "ERROR message\r\n"

    Bu tür uygulama katmanı protokollerinde fiziksel bağlantı ile mantıksal bağlantının karıştırılmaması gerekir. Bir client'ın
    server'a connect fonksiyonuyla bağlanması onun hizmet alacağı anlamına gelmemektedir. Onun hizmet alabilmesi için mantıksal 
    bir bağlantının da sağlanması gerekir. Bizim protokolümüzde bu mantıksal bağlantı "LOGIN" ve "LOGIN_ACCEPTED" mesajlarıyla
    yapılmaktadır. Client, TCP'den bağlandıktan sonra server'a kullanıcı adını ve parolayı yollar. Server doğrulamayı yaparsa 
    client'a "LOGIN_ACCEPTED\r\n" mesajını iletir. Eğer server doğrulamayı yapamazsa bu durumda örneğin "ERROR LOGIN_FAILED\r\n"
    gibi bir hata mesajıyla geri dönüp soketi kapatacaktır.

    Aşağıda çok client'lı matematiksel işlem yapan bir client-server uygulama kodu verilmiştir. Bu uygulamada "calc-server" 
    programı her client bağlantısında bir thread açıp o thread yoluyla ilgili client ile konuşmaktadır. Yani buradaki server
    IO modeli olarak thread modelini kullanmaktadır. Bir client, server'a "kullanıcı adı" ve "parola" ile bağlanmaktadır. Server
    program bir CSV dosyasına bakarak kullanıcı adı ve parola bilgisini doğrulamaktadır. Bir client bağlandığında server program 
    CLIENT_INFO isimli bir yapı türünden bir nesne yaratıp client'ın bilgilerini orada saklamaktadır. Aslında bu tür programlarda 
    tüm client'ların bilgileri bir dizi ya da bağlı liste içerisinde tutulmalıdır. Çünkü server tüm client'lara belli bir mesajı 
    göndermek isteyebilir. Server programı aşağıdaki gibi derleyebilirsiniz:

    gcc -Wall -o calc-server calc-server.c -lm

    Prototipleri <math.h> içerisinde olan standart C fonksiyonları libc kütüphanesinde değildir. libm isimli ayrı bir 
    kütüphanededir. Maalesef gcc otomatik olarak bu kütüphaneyi link aşamasına dahil etmemektedir. Bu nedenle matematiksel 
    fonksiyonları kullanırken linker için -lm seçeneğinin bulundurulması gerekmektedir.

    Client program (calc-client.c) server'a fiziksel olarak TCP'den bağlandıktan sonra ona kullanıcı adı ve parolayı mesaj 
    olarak gönderir. Sonra bir komut satırına düşer. Komutlar komut satırından verilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/* calc-server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <stdint.h>
#include <stdbool.h>
#include <errno.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define CREDENTIALS_PATH    "credentials.csv"

#define DEF_SERVER_PORT        55555
#define MAX_MSG_SIZE        4096
#define MAX_MSG_PARAMS        32

#define MAX_USER_NAME        64
#define MAX_PASSWORD        64
#define MAX_CREDENTIALS        1024

typedef struct tagCREDENTIAL {
    char user_name[MAX_USER_NAME];
    char password[MAX_PASSWORD];
} CREDENTIAL;

typedef struct tagCLIENT_INFO {
    int sock;
    struct sockaddr_in sin;
    char buf[MAX_MSG_SIZE + 1];                // MAX_MSG_SIZE is enough
    CREDENTIAL credential;
} CLIENT_INFO;

typedef struct tagMSG {
    char *params[MAX_MSG_PARAMS];
    int count;
} MSG;

typedef struct tagCLIENT_MSG_PROC {
    char *msg;
    bool (*proc)(CLIENT_INFO *, const MSG *);
} CLIENT_MSG_PROC;

int read_credentials(void);
void *client_thread_proc(void *param);
ssize_t sock_readline(int sock, char *str, size_t size);
void receive_msg(CLIENT_INFO *ci);
void send_msg(CLIENT_INFO *ci, const char *msg);
int is_empty_line(const char *line);
void exit_client_thread(CLIENT_INFO *ci);
void parse_msg(char *msg, MSG *msgs);

bool login_proc(CLIENT_INFO *ci);
bool add_proc(CLIENT_INFO *ci, const MSG *msg);
bool sub_proc(CLIENT_INFO *ci, const MSG *msg);
bool mul_proc(CLIENT_INFO *ci, const MSG *msg);
bool div_proc(CLIENT_INFO *ci, const MSG *msg);
bool sqrt_proc(CLIENT_INFO *ci, const MSG *msg);
bool pow_proc(CLIENT_INFO *ci, const MSG *msg);
bool logout_proc(CLIENT_INFO *ci, const MSG *msg);

char *revstr(char *str);
void exit_sys(const char *msg);

CLIENT_MSG_PROC g_client_msgs[] = {
    {"ADD", add_proc},
    {"SUB", sub_proc},
    {"MUL", mul_proc},
    {"DIV", div_proc},
    {"SQRT", sqrt_proc},
    {"POW", pow_proc},
    {"LOGOUT", logout_proc},
    {NULL, NULL}
};
CREDENTIAL g_credentials[MAX_CREDENTIALS];
int g_ncredentials;

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;
    int option;
    int server_port;
    int p_flag, err_flag;
    pthread_t tid;
    CLIENT_INFO *ci;
    int result;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (read_credentials() == -1) {
        fprintf(stderr, "cannot read credentials...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("listening port %d\n", server_port);

    for (;;) {
        sin_len = sizeof(sin_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
            exit_sys("accept");

        // printf("connected client ===> %s : %u\n", inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sin_client.sin_port));

        if ((ci = (CLIENT_INFO *)malloc(sizeof(CLIENT_INFO))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }

        ci->sock = client_sock;
        ci->sin = sin_client;

        if ((result = pthread_create(&tid, NULL, client_thread_proc, ci)) != 0) {
            fprintf(stderr, "pthread_create: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }

        if ((result = pthread_detach(tid)) != 0) {
            fprintf(stderr, "pthread_detach: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }
    }

    close(server_sock);

    return 0;
}

int read_credentials(void)
{
    char buf[MAX_USER_NAME + MAX_PASSWORD + 32];
    FILE *f;
    char *str;

    if ((f = fopen(CREDENTIALS_PATH, "r")) == NULL)
        return -1;

    g_ncredentials = 0;
    while (fgets(buf, MAX_USER_NAME + MAX_PASSWORD + 32, f) != NULL) {
        if (is_empty_line(buf) == 0)
            continue;
        if ((str = strtok(buf, ",")) == NULL)
            return -1;
        strcpy(g_credentials[g_ncredentials].user_name, str);
        if ((str = strtok(NULL, "\n")) == NULL)
            return -1;
        strcpy(g_credentials[g_ncredentials].password, str);

        if ((str = strtok(NULL, "\n")) != NULL)
            return -1;

        ++g_ncredentials;
    }

    fclose(f);

    return 0;
}

int is_empty_line(const char *line)
{
    while (*line != '\0') {
        if (!isspace(*line))
            return -1;
        ++line;
    }

    return 0;
}

void *client_thread_proc(void *param)
{
    char ntopbuf[INET_ADDRSTRLEN];
    unsigned port;
    CLIENT_INFO *ci = (CLIENT_INFO *)param;
    MSG msg;
    int i;

    inet_ntop(AF_INET, &ci->sin.sin_addr, ntopbuf, INET_ADDRSTRLEN);
    port = (unsigned)ntohs(ci->sin.sin_port);

    if (!login_proc(ci)) {
        send_msg(ci, "ERROR incorrect user name or password\r\n");
        exit_client_thread(ci);
    }

    send_msg(ci, "LOGIN_ACCEPTED\r\n");
    printf("client connected with user name \"%s\"\n", ci->credential.user_name);

    for (;;) {
        receive_msg(ci);
        *strchr(ci->buf, '\r') = '\0';
        printf("Message from \"%s\": \"%s\"\n", ci->credential.user_name, ci->buf);
        parse_msg(ci->buf, &msg);

        if (msg.count == 0) {
            send_msg(ci, "ERROR empty command\r\n");
            continue;
        }

        for (i = 0; g_client_msgs[i].msg != NULL; ++i)
            if (!strcmp(g_client_msgs[i].msg, msg.params[0])) {
                if (!g_client_msgs[i].proc(ci, &msg))
                    goto EXIT;
                break;
            }
        if (g_client_msgs[i].msg == NULL) {
            send_msg(ci, "ERROR invalid command\r\n");
        }

    }

    printf("client disconnected %s : %u\n", ntopbuf, port);

EXIT:
    shutdown(ci->sock, SHUT_RDWR);
    close(ci->sock);

    free(ci);

    return NULL;
}

ssize_t sock_readline(int sock, char *str, size_t size)
{
    char *bstr = str;
    static char *bp;
    static ssize_t count = 0;
    static char buf[2048];

    if (size <= 2) {
        errno = EINVAL;
        return -1;
    }

    while (--size > 0) {
        if (--count <= 0) {
            if ((count = recv(sock, buf, sizeof(buf), 0)) == -1)
                return -1;
            if (count == 0)
                return 0;
            bp = buf;
        }
        *str++ = *bp++;
        if (str[-1] == '\n')
            if (str - bstr > 1 && str[-2] == '\r') {
                *str = '\0';
                break;
            }
    }

    return (ssize_t) (str - bstr);
}

void receive_msg(CLIENT_INFO *ci)
{
    ssize_t result;

    if ((result = sock_readline(ci->sock, ci->buf, MAX_MSG_SIZE)) == -1) {
        fprintf(stderr, "sock_readline: %s\n", strerror(errno));
        exit_client_thread(ci);
    }

    if (result == 0) {
        fprintf(stderr, "sock_readline: client unexpectedly down...\n");
        exit_client_thread(ci);
    }
}

void send_msg(CLIENT_INFO *ci, const char *msg)
{
    if (send(ci->sock, msg, strlen(msg), 0) == -1)
        exit_client_thread(ci);
}

void exit_client_thread(CLIENT_INFO *ci)
{
    shutdown(ci->sock, SHUT_RDWR);
    close(ci->sock);
    free(ci);
    pthread_exit(NULL);
}

void parse_msg(char *buf, MSG *msg)
{
    char *str;

    msg->count = 0;
    for (str = strtok(buf, " \r\n\t"); str != NULL; str = strtok(NULL, " \r\n\t"))
        msg->params[msg->count++] = str;

    msg->params[msg->count] = NULL;
}

bool login_proc(CLIENT_INFO *ci)
{
    MSG msg;
    char *user_name, *password;

    receive_msg(ci);
    parse_msg(ci->buf, &msg);

    user_name = msg.params[1];
    password = msg.params[2];

    if (msg.count != 3)
        return false;

    if (strcmp(msg.params[0], "LOGIN") != 0)
        return false;

    for (int i = 0; i < g_ncredentials; ++i)
        if (strcmp(user_name, g_credentials[i].user_name) == 0 && strcmp(password, g_credentials[i].password) == 0) {
            ci->credential = g_credentials[i];
            return true;
        }

    return false;
}

bool add_proc(CLIENT_INFO *ci, const MSG *msg)
{
    double op1, op2, result;
    char buf[MAX_MSG_SIZE];

    if (msg->count != 3) {
        send_msg(ci, "ERROR invalid operand in command\r\n");
        return true;
    }
    op1 = atof(msg->params[1]);
    op2 = atof(msg->params[2]);

    result = op1 + op2;

    sprintf(buf, "RESULT %f\r\n", result);
    send_msg(ci, buf);

    return true;
}

bool sub_proc(CLIENT_INFO *ci, const MSG *msg)
{
    double op1, op2, result;
    char buf[MAX_MSG_SIZE];

    if (msg->count != 3) {
        send_msg(ci, "ERROR invalid operand in command\r\n");
        return true;
    }
    op1 = atof(msg->params[1]);
    op2 = atof(msg->params[2]);

    result = op1 - op2;

    sprintf(buf, "RESULT %f\r\n", result);
    send_msg(ci, buf);

    return true;
}

bool mul_proc(CLIENT_INFO *ci, const MSG *msg)
{
    double op1, op2, result;
    char buf[MAX_MSG_SIZE];

    if (msg->count != 3) {
        send_msg(ci, "ERROR invalid operand in command\r\n");
        return true;
    }
    op1 = atof(msg->params[1]);
    op2 = atof(msg->params[2]);

    result = op1 * op2;

    sprintf(buf, "RESULT %f\r\n", result);
    send_msg(ci, buf);

    return true;
}

bool div_proc(CLIENT_INFO *ci, const MSG *msg)
{
    double op1, op2, result;
    char buf[MAX_MSG_SIZE];

    if (msg->count != 3) {
        send_msg(ci, "ERROR invalid operand in command\r\n");
        return true;
    }
    op1 = atof(msg->params[1]);
    op2 = atof(msg->params[2]);

    result = op1 / op2;

    sprintf(buf, "RESULT %f\r\n", result);
    send_msg(ci, buf);

    return true;
}

bool sqrt_proc(CLIENT_INFO *ci, const MSG *msg)
{
    double op, result;
    char buf[MAX_MSG_SIZE];

    if (msg->count != 2) {
        send_msg(ci, "ERROR invalid operand in command\r\n");
        return true;
    }
    op = atof(msg->params[1]);
    result = sqrt(op);

    sprintf(buf, "RESULT %f\r\n", result);
    send_msg(ci, buf);

    return true;
}

bool pow_proc(CLIENT_INFO *ci, const MSG *msg)
{
    double op1, op2, result;
    char buf[MAX_MSG_SIZE];

    if (msg->count != 3) {
        send_msg(ci, "ERROR invalid operand in command\r\n");
        return true;
    }
    op1 = atof(msg->params[1]);
    op2 = atof(msg->params[2]);

    result = pow(op1, op2);

    sprintf(buf, "RESULT %f\r\n", result);
    send_msg(ci, buf);

    return true;
}

bool logout_proc(CLIENT_INFO *ci, const MSG *msg)
{
    send_msg(ci, "LOGOUT_ACCEPTED\r\n");

    printf("%s logging out...\n", ci->credential.user_name);

    return false;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* calc-client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define MAX_MSG_SIZE        4096
#define MAX_MSG_PARAMS        32

typedef struct tagMSG {
    char *params[MAX_MSG_PARAMS];
    int count;
} MSG;

typedef struct tagSERVER_MSG_PROC {
    char *msg;
    bool (*proc)(const MSG *);
} SERVER_MSG_PROC;

ssize_t sock_readline(int sock, char *str, size_t size);
void receive_msg(int sock, char *msg);
void send_msg(int sock, const char *msg);
void parse_msg(char *buf, MSG *msg);
int parse_error(char *buf, MSG *msg);
int login_attempt(int sock, const char *user_name, const char *password);

bool result_proc(const MSG *msg);
bool error_proc(const MSG *msg);
bool logout_accepted_proc(const MSG *msg);

void exit_sys(const char *msg);

SERVER_MSG_PROC g_server_msgs[] = {
    {"ERROR", error_proc},
    {"RESULT", result_proc},
    {"LOGOUT_ACCEPTED", logout_accepted_proc},
    {NULL, NULL}
};

/* ./calc-client <username> <password> [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[MAX_MSG_SIZE];
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    const char *user_name, *password;
    MSG msg;
    int i;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (argc - optind != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    user_name = argv[optind + 0];
    password = argv[optind + 1];

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    if (login_attempt(client_sock, user_name, password) == -1)
        goto EXIT;

    printf("connection successful...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, MAX_MSG_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (buf[strspn(buf, " \t")] == '\0')        /* check if buf contains white spaces */
            continue;
        strcat(str, "\r\n");

        send_msg(client_sock, buf);
        receive_msg(client_sock, buf);

        parse_msg(buf, &msg);

        for (i = 0; g_server_msgs[i].msg != NULL; ++i)
            if (!strcmp(g_server_msgs[i].msg, msg.params[0])) {
                if (!g_server_msgs[i].proc(&msg))
                    goto EXIT;
                break;
            }
    }
EXIT:
    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

ssize_t sock_readline(int sock, char *str, size_t size)
{
    char *bstr = str;
    static char *bp;
    static ssize_t count = 0;
    static char buf[2048];

    if (size <= 2) {
        errno = EINVAL;
        return -1;
    }

    while (--size > 0) {
        if (--count <= 0) {
            if ((count = recv(sock, buf, sizeof(buf), 0)) == -1)
                return -1;
            if (count == 0)
                return 0;
            bp = buf;
        }
        *str++ = *bp++;
        if (str[-1] == '\n')
            if (str - bstr > 1 && str[-2] == '\r') {
                *str = '\0';
                break;
            }
    }

    return (ssize_t) (str - bstr);
}

void receive_msg(int sock, char *msg)
{
    ssize_t result;

    if ((result = sock_readline(sock, msg, MAX_MSG_SIZE)) == -1)
        exit_sys("receive_msg");
    if (result == 0) {
        fprintf(stderr, "receive_msg: unexpectedly down...\n");
        exit(EXIT_FAILURE);
    }
}

void send_msg(int sock, const char *msg)
{
    if (send(sock, msg, strlen(msg), 0) == -1)
        exit_sys("send_msg");
}

void parse_msg(char *buf, MSG *msg)
{
    char *str;

    if (parse_error(buf, msg) == 0)
        return;

    msg->count = 0;
    for (str = strtok(buf, " \r\n\t"); str != NULL; str = strtok(NULL, " \r\n\t"))
        msg->params[msg->count++] = str;

    msg->params[msg->count] = NULL;
}

int parse_error(char *buf, MSG *msg)
{
    while (isspace(*buf))
        ++buf;
    if (!strncmp(buf, "ERROR", 5)) {
        buf += 5;
        while (isspace(*buf))
            ++buf;
        *strchr(buf, '\r') = '\0';
        msg->count = 2;
        msg->params[0] = "ERROR";
        msg->params[1] = buf;

        return 0;
    }
    return -1;
}

int login_attempt(int sock, const char *user_name, const char *password)
{
    char buf[MAX_MSG_SIZE];
    MSG msg;

    sprintf(buf, "LOGIN %s %s\r\n", user_name, password);
    send_msg(sock, buf);
    receive_msg(sock, buf);
    parse_msg(buf, &msg);
    if (!strcmp(msg.params[0], "ERROR")) {
        fprintf(stderr, "login error: %s\n", msg.params[1]);
        return -1;
    }

    if (strcmp(msg.params[0], "LOGIN_ACCEPTED") != 0) {
        fprintf(stderr, "unexpected server message!...\n");
        return -1;
    }
    return 0;
}

bool result_proc(const MSG *msg)
{
    printf("%s\n", msg->params[1]);

    return true;
}

bool error_proc(const MSG *msg)
{
    printf("Error: %s\n", msg->params[1]);

    return true;
}

bool logout_accepted_proc(const MSG *msg)
{
    return false;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                110. Ders 12/01/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de IRC stili bir chat programı yazacağımızı düşünelim. Programlardaki IO modeli üzerinde durmayacağız. Yalnızca 
    mesajlaşmalar üzerinde duracağız.

    Bu tür chat programlarında server kendisine bağlanan tüm client'ların bilgilerini tutmaktadır. Bir client bir yazıyı 
    tüm diğer client'ların görmesi için server'a iletir. Server'da bunu client'lara iletir. Böyle basit bir chat uygulamasında 
    client'tan server'a gönderilecek mesajlar şunlar olabilir:

    "LOGIN <kullanıcı_adı> <parola>\r\n"
    "SEND_MESSAGE <mesaj metni>\r\n
    "LOGOUT\r\n"

    Server'dan client'a gönderilecek mesajlar şunlar olabilir:

    "LOGIN_ACCEPTED\r\n"
    "ACTIVE_USERS\r\n"
    "NEW_USER_LOGGEDIN <kullanıcı adı>\r\n"
    "USER_LOGGEDOUT <kullanıcı_adı>\r\n"
    "LOGOUT_ACCEPTED\r\n"
    "DISTRIBUTE_MESSAGE <mesaj metni>\r\n"
    "LOGOUT_ACCEPTED\r\n"
    "ERROR <hata_mesajı>"

    Çalışma akışı şöyle olabilir:

    - Client önce LOGIN mesajı ile server'a mantıksal bakımdan bağlanır. Server da bağlantıyı kabul ederse client'a 
    LOGIN_ACCEPTED mesajını gönderir. Tabii oturuma yeni kullanıcı katıldığı için aynı zamanda server diğer tüm client'lara
    NEW_USER_LOGGEDIN yollar. Bağlanan client'a ise oturumdakilerin hepsinin listesini ACTIVE_USERS mesajı ile iletmektedir.

    - Client bir mesajın oturumdaki herkes tarafından görülmesini sağlamak amacıyla server'a SEND_MESSAGE mesajını gönderir. 
    Server da bu mesajı oturumdaki tüm client'lara DISTRIBUTE_MESSAGE mesajıyla iletir.

    - Bir kullanıcı logout olmak istediğinde server'a LOGOUT mesajını gönderir. Server'da bunu kabul ederse client'a 
    LOGOUT_ACCEPTED mesajını gönderir. Ancak client'ın logout olduğu bilgisinin oturumdaki diğer client'lara da iletilmesi 
    gerekmektedir. Bunun için server tüm client'lara USER_LOGGED mesajını göndermelidir.

    - Yine bir hata durumunda server client'lara ERROR mesajı gönderebilir.

    Aslında chat programları için IP protocol ailesinde IRC (Internet Relay Chat) protokolü bulunmaktadır. IRC server ve client 
    programlar Linux sistemlerinde zaten bulunmaktadır. Siz de bu protokolün dokümanlarını inceleyerek bu protokol için 
    client ve/veya server programları yazabilirsiniz. IRC protokolü "RFC 1459" olarak dokümante edilmiştir. Başka kurumların da
    chat protokollerinin bazıları artık dokümante edilmiştir. Microsoft'un MSN Chat protokolünün dokümanlarına aşağıdaki 
    adresten erişebilirsiniz:

    http://www.hypothetic.org/docs/msn/
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Komut satırı tabanlı bir telnet, ssh benzeri client-server bir program yazmak isteyelim. Amacımız bir client'ın
    server makinede komut satırından işlem yapmasını sağlamak olsun. Yani client server'a bağlanacak ona shell komutları 
    yollayacak, komutların çıktısını da görecek. Böyle bir programın server tarafının çatısı şöyle oluşturulabilir:

    - Client program bağlandığında server iki boru yaratır ve fork işlemi yapar.

    - fork işleminden sonra henüz exec işlemi yapmadan alt prosesin stdin betimleyicisini borunun birine, stdout betimleyicisini 
    de diğerine yönlendirir. Böylece üst proses boruya yazma yaptığında aslında alt proses bunu stdin betimleyicisinden okuyacaktır.
    Benzer biçimde alt proses diğer boruya yazma yaptığında üst proses de bunu diğer borudan okuyabilecektir.

    - Bu yönlendirmelerden sonra server exec yaparak shell programını çalıştırır.

    - Client, server'a shell komutunu gönderdiğinde server komutu shell programına işletir, çıktısını elde eder ve client'a 
    yollar.

    Aslında bu işlemi yapan iki standart protokol vardır: telnet ve ssh protokolleri. telnet protokolü güvenlik bakımından 
    zayıf olduğu için günümüzde daha çok ssh kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                111. Ders 14/01/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Telnet ya da ssh benzeri programı yazarken üst prosesin /bin/bash programını çalıştırıp ona komutlar yollaması ve ondan 
    komutlar alması gerekmektedir. İşin bu kısmını yapan örnek bir program aşağıda verilmiştir. Aşağıdaki programda üst proses
    iki boru yaratmıştır. Sonra alt prosesi yaratarak exec uygulamıştır. Ancak üst proses henüz exec yapmadan alt prosesin 
    stdin betimleyicisini ve stdout betimleyicisini boruya yönlendirmiştir. Böylece şöyle bir mekanizma oluşturulmuştur: Üst 
    proses borulardan birine yazdığında sanki alt prosesin stdin dosyasına yazmış gibi olmaktadır. Üst proses diğer borudan 
    okuma yaptığında alt prosesin stdout dosyasına yazılanları okumuş gibi olmaktadır.

    Aşağıdaki programda bazı kusurlar vardır. Örneğin:

    - Üst proses kabuğa komutu ilettikten sonra onun stdout ya da stdin dosyasına yazdıklarını okumaya çalışmaktadır. Ancak
    ne kadar bilginin okunacağı belli değildir.

    - Üst proses alt prosesin yazdıklarını okuyabilmek için biraz gecikme uygulamıştır. Ancak alt proses bu gecikmeden uzun süre 
    çalışıyorsa program hatalı çalışır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>

#define BUFFER_SIZE        65536

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;
    int fdsout[2];
    int fdsin[2];
    char buf[BUFFER_SIZE + 1];
    ssize_t result;
    int status;

    if (pipe(fdsin) == -1)
        exit_sys("pipe");

    if (pipe(fdsout) == -1)
        exit_sys("pipe");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0) { /* child */
        close(fdsin[0]);
        close(fdsout[1]);

        if (dup2(fdsin[1], 1) == -1)
            _exit(EXIT_FAILURE);
        if (dup2(fdsin[1], 2) == -1)
            _exit(EXIT_FAILURE);
        if (dup2(fdsout[0], 0) == -1)
            _exit(EXIT_FAILURE);

        close(fdsin[1]);
        close(fdsout[0]);

        if (execl("/bin/bash", "/bin/bash", (char *)NULL) == -1)
            _exit(EXIT_FAILURE);

        /* unreachable code */
    }

    /* parent process */

    close(fdsin[1]);
    close(fdsout[0]);

    /* parent writes fdsout[1] and read fdsin[0] */

    if (fcntl(fdsin[0], F_SETFL, fcntl(fdsin[0], F_GETFL)|O_NONBLOCK) == -1)
        exit_sys("fcntl");

    for (;;) {
        printf("Command: ");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if (write(fdsout[1], buf, strlen(buf)) == -1)
            exit_sys("write");
        if (!strcmp(buf, "exit\n"))
            break;
        usleep(300000);
        if ((result = read(fdsin[0], buf, BUFFER_SIZE)) == -1) {
            if (errno == EAGAIN)
                continue;
            exit_sys("read");
        }

        buf[result] = '\0';
        printf("%s", buf);
    }

    if (wait(&status) == -1)
        exit_sys("wait");

    if (WIFEXITED(status))
        printf("Shell exits normally with exit code: %d\n", WEXITSTATUS(status));
    else
        printf("shell exits abnormally!...\n");

    close(fdsin[0]);
    close(fdsout[1]);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                112. Ders 19/01/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    IP ailesinin uygulama katmanındaki Telnet, SSH, HTTP, POP3, SMTP gibi protokoller daha önceden de belirttiğimiz gibi hep 
    yazısal işlem yapmaktadır. Yani bu protokollerde mesajlar birer yazı biçiminde sonu \r\n ile bitecek biçimde gönderilip 
    alınmaktadır. Burada e-posta almak için kullanılan POP3 (Post Office Protocol Version 3) protokolü üzerinde kısaca duracağız. 
    E-posta almak için yaygın kullanılan diğer protokol IMAP protokolüdür. IMAP protokolü, POP3 protokolünden daha güvenli ve
    ayrıntılı tasarlanmıştır. E-posta okuyucuları iki protokolü de kullanmaktadır. POP3 ve IMAP protokollerinin client program
    olduğuna dikkat ediniz. Client program, POP3 ve IMAP server'lara bağlanarak onlardan e-postaları almaktadır. Yani e-postaları
    tutan sunucu tarafıdır ve client onlara bağlanıp e-postaları yerel makineye çekmektedir.

    Tipik olarak e-posta gönderip alma işlemleri şöyle gerçekleştirilmektedir.

    1) Bunun için bir e-posta sunucu programının bulunuyor olması gerekir. Eğer tüm sistemi siz kuruyorsanız bu sunucuyu (server) 
    da sizin kurmanız gerekmektedir. Zaten Windows sistemlerinde, UNIX/Linux sistemlerinde bu sunucular hazır biçimde bulunmaktadır.
    Tabii eğer domain hizmetini aldığınız bir kurum varsa onlar da zaten e-posta hizmeti vermek için hazır e-posta sunucuları 
    bulundurmaktadır. E-posta gönderebilmek için ya da e-posta alabilmek için bizim e-posta sunucusunun adresini biliyor olmamız 
    gerekir. Gönderme işleminde kullanılacak sunucu ile alma işleminde kullanılacak sunucu farklı olabilmektedir. Örneğin CSD'nin 
    e-posta sunucusuna "mail.csystem.org" adresiyle erişilebilmektedir. Bu sunucu hem gönderme hem de alma işlemini yapmaktadır. 
    E-posta gönderebilmek için client program ile server program, "SMTP (Simple Mail Transfer Protocol)" denilen bir protokolle
    haberleşmektedir. O halde gönderim için bizim e-posta sunucusuna bağlanarak SMTP protokolü ile göndereceğimiz e-postayı ona iletmemiz 
    gerekir.

    2) Biz göndereceğimiz e-postayı SMTP protokolü ile e-posta sunucumuza ilettikten sonra bu sunucu hedef e-posta sunucusuna bu 
    e-postayı yine SMTP protokolü ile iletmektedir. E-postayı alan sunucu bunu bir posta kutusu (mail box) içerisinde saklar.

    3) Karşı taraftaki client program POP3 ya da IMAP protokolü ile kendi e-posta sunucuna bağlanarak posta kutusundaki e-postayı 
    yerel makineye indirir.

    client ---SMTP---> e-posta sunucusu ---SMTP--> e-posta sunucusu ---POP3/IMAP---> client

    Görüldüğü gibi POP3 ve IMAP protokolleri e-posta sunucusunun posta kutusundaki zaten gelmiş ve saklanmış olan e-postaları yerel 
    makineye indirmek için kullanılmaktadır.

    POP3 protokolü RFC 1939 dokümanlarında açıklanmıştır. Protokol kabaca şöyle işlemektedir:

    1) Client program 110 numaralı (ya da 995 numaralı) porttan server'a TCP ile fiziksel olarak bağlanır.

    2) Protokolde mesajlaşma tamamen text tabanlı ve satırsal biçimde yapılmaktadır. Satırlar CR/LF karakterleriyle sonlandırılmaktadır. 
    Protokolde client'ın gönderdiği her komuta karşı server bir yanıt göndermektedir. (Fiziksel bağlantı sağlandığında da server 
    bir onay mesajı gönderir.) Eğer yanıt olumluysa mesaj "+OK" ile, eğer yanıt olumsuzsa mesaj "-ERR" ile başlatılmaktadır. Yani 
    server'ın client'a gönderdiği mesajın genel biçimi şöyledir:

    +OK [diğer bilgiler] CR/LF
    -ERR [diğer bilgiler] CR/LF

    3) Fiziksel bağlantıdan sonra client program mantıksal olarak server'a login olmalıdır. Login olmak için önce "user name" sonra da 
    "password" gönderilmektedir. User name ve password gönderme işlemi aşağıdaki iki komutla yapılmaktadır.

    "USER <user name> CR/LF"
    "PASS <password> CR/LF"

    Kullanıcı adı e-posta adresiyle aynıdır. Örneğin biz "test@csystem.org" için e-posta sunucusuna bağlanıyorsak buradaki kullanıcı 
    ismi "test@csystem.org" olacaktır. Parola e-postalarınızı okumak için kullandığınız paroladır. Sisteme başarılı bir biçimde login 
    olduğumuzu varsayıyoruz. Tipik olarak server bize şu mesajı iletecektir:

    +OK Logged in.

    Eğer password yanlış girilmişse yeniden önce user name ve sonra password gönderilmelidir.

    4) Client program LIST komutunu göndererek e-posta kutusundaki mesaj bilgilerini elde eder. LIST komutuna karşılık server önce aşağıdaki
    gibi bir satır gönderir:

    +OK 6 messages:

    Burada server e-posta kutusunda kaç e-posta olduğunu belirtmektedir. Sonra her e-postaya bir numara vererek onların byte uzunluklarını 
    satır satır iletir. Komut yalnızca '.' içeren bir satırla son bulmaktadır. Örneğin:

    +OK 6 messages:
    1 1565
    2 5912
    3 11890
    4 4920
    5 9714
    6 4932
    .

    5) Belli bir e-posta RETR komutuyla elde edilmektedir. Bu komuta elde edilecek e-postanın index numarası girilir. Örneğin:

    "RETR 2 CR/LF"

    RETR komutuna karşı server önce aşağıdaki gibi bir satır gönderir:

    +OK 5912 octets

    Burada programcı bu satırı parse ederek burada belirtilen miktarda byte kadar soketten okuma yapmalıdır. Anımsanacağı gibi porttan 
    tam olarak n byte okumak TCP'de tek bir recv ile yapılamamaktadır.

    6) Mesajı silmek için DELE komutu kullanılır. Komuta parametre olarak silinecek mesajın indeks numarası girilmektedir. Örneğin:

    "DELE 3 CR/LF"

    Bu komut uygulandığında server henüz e-postayı posta kutusundan silmez. Yalnızca onu "silinecek" biçiminde işaretler. Silme işlemi QUIT 
    komutuyla oturum sonlandırıldığında yapılmaktadır. Eğer client silme eyleminden pişmanlık duyarsa RSET komutuyla ilk duruma gelir.
    RSET komutu logout yapmaz. Yalnızca silinmiş olarak işaretlenenlerin işaretlerini kaldırır.

    7) STAT komutu o anda e-posta kutusundaki e-posta sayısını bize vermektedir. Bu komut gönderildiğinde aşağıdaki gibi bir yanıt
    alınacaktır:

    +OK 5 27043

    Burada server e-posta kutusunda toplam 5 e-postanın bulunduğunu ve bunların byte uzunluklarının da 27043 olduğunu söylemektedir.

    8) Protocol client programın QUIT komutunu göndermesiyle sonlandırılmaktadır. Örneğin:

    "QUIT CR/LF"

    9) POP3 protokolününde client belli bir süre server'a hiç mesaj göndermezse, server client'ın soketini kapatıp bağlantıyı
    koparmaktadır. Her ne kadar RFC 1939'da server'ın en azından 10 dakika beklemesi gerektiği söylenmişse de server'ların 
    çoğu çok daha az bir süre beklemektedir.

    POP3 protokolünde client programın gönderdiği yazısal komutlar için server programın gönderdiği yanıtlar parse edilerek 
    tam gerektiği kadar okuma yapılabilir. Ancak aşağıdaki programda biz basitlik sağlamak amacıyla server'dan gelen mesajları 
    başka bir thread ile ele aldık.
---------------------------------------------------------------------------------------------------------------------------*/

/* pop3.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <pthread.h>

#define DEF_SERVER_NAME        "mail.csystem.org"
#define DEF_SERVER_PORT        "110"
#define BUFFER_SIZE            4096

ssize_t sock_readline(int sock, char *str, size_t size);
void *thread_proc(void *param);
void send_msg(int sock, const char *msg);

void exit_sys_thread(const char *msg, int err);
void exit_sys(const char *msg);

/* ./pop3 [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    char buf[BUFFER_SIZE + 1];
    pthread_t tid;
    int result;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (argc - optind != 0) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    if ((result = pthread_create(&tid, NULL, thread_proc, (void *)client_sock)) != 0)
        exit_sys_thread("pthread_create", result);

    usleep(500000);
    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (buf[strspn(buf, " \t")] == '\0')        /* check if buf contains white spaces */
            continue;
        strcat(str, "\r\n");

        send_msg(client_sock, buf);
        sleep(1);
        if (!strcmp(buf, "QUIT\r\n"))
            break;
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    return 0;
}

void *thread_proc(void *param)
{
    int sock = (int)param;
    char buf[BUFFER_SIZE];
    int result;

    for (;;) {
        if ((result = sock_readline(sock, buf, BUFFER_SIZE)) == -1)
            exit_sys("receive_msg");
        if (result == 0) {
            printf("closing connection...\n");
            break;
        }
        printf("%s", buf);
    }

    exit(EXIT_SUCCESS);

    return NULL;
}

ssize_t sock_readline(int sock, char *str, size_t size)
{
    char *bstr = str;
    static char *bp;
    static ssize_t count = 0;
    static char buf[2048];

    if (size <= 2) {
        errno = EINVAL;
        return -1;
    }

    while (--size > 0) {
        if (--count <= 0) {
            if ((count = recv(sock, buf, sizeof(buf), 0)) == -1)
                return -1;
            if (count == 0)
                return 0;
            bp = buf;
        }
        *str++ = *bp++;
        if (str[-1] == '\n')
            if (str - bstr > 1 && str[-2] == '\r') {
                *str = '\0';
                break;
            }
    }

    return (ssize_t) (str - bstr);
}

void send_msg(int sock, const char *msg)
{
    if (send(sock, msg, strlen(msg), 0) == -1)
        exit_sys("send_msg");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                113. Ders 21/01/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında POP3 client programda her mesaja karşılık server'ın nasıl bir yazı gönderdiği bilindiğine göre buradan hareketle
    hiç thread oluşturmadan gönderilen komut için yanıt elde edilebilir. Aşağıda bu fikre bir örnek verilmiştir. Örneğimizde 
    LIST ve RETR komutları özel olarak ele alınmıştır. LIST komutunda server'ın listeyi ilettikten sonra son satırda "." gönderdiğini
    anımsayınız. Biz de aşağıda programda satırda "." görene kadar okuma yaptık. RETR komutunda +OK yazısından sonra mesajdaki
    byte sayısının da gönderildiğini anımsayınız. Biz de bundan faydalanarak soketten o kadar byte okuduk.
---------------------------------------------------------------------------------------------------------------------------*/

/* pop3.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "mail.csystem.org"
#define DEF_SERVER_PORT        "110"
#define BUFFER_SIZE            4096

ssize_t sock_readline(int sock, char *str, size_t size);
void send_msg(int sock, const char *msg);
void receive_msg(int sock, char *msg);
void getcmd(const char *buf, char *cmd);
void proc_list(int sock);
void proc_retr(int sock);

void exit_sys(const char *msg);

/* ./pop3 [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    char buf[BUFFER_SIZE + 1];
    char cmd[BUFFER_SIZE];

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (argc - optind != 0) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    receive_msg(client_sock, buf);
    printf("%s", buf);

    freeaddrinfo(res);

    usleep(500000);
    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (buf[strspn(buf, " \t")] == '\0')        /* check if buf contains white spaces */
            continue;
        strcat(str, "\r\n");

        send_msg(client_sock, buf);
        getcmd(buf, cmd);

        if (!strcmp(cmd, "LIST"))
            proc_list(client_sock);
        else if (!strcmp(cmd, "RETR"))
            proc_retr(client_sock);
        else {
            receive_msg(client_sock, buf);
            printf("%s", buf);
        }
        if (!strcmp(cmd, "QUIT"))
            break;
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

ssize_t sock_readline(int sock, char *str, size_t size)
{
    char *bstr = str;
    static char *bp;
    static ssize_t count = 0;
    static char buf[2048];

    if (size <= 2) {
        errno = EINVAL;
        return -1;
    }

    while (--size > 0) {
        if (--count <= 0) {
            if ((count = recv(sock, buf, sizeof(buf), 0)) == -1)
                return -1;
            if (count == 0)
                return 0;
            bp = buf;
        }
        *str++ = *bp++;
        if (str[-1] == '\n')
            if (str - bstr > 1 && str[-2] == '\r') {
                *str = '\0';
                break;
            }
    }

    return (ssize_t) (str - bstr);
}

void send_msg(int sock, const char *msg)
{
    if (send(sock, msg, strlen(msg), 0) == -1)
        exit_sys("send_msg");
}

void receive_msg(int sock, char *msg)
{
    ssize_t result;

    if ((result = sock_readline(sock, msg, BUFFER_SIZE)) == -1)
        exit_sys("receive_msg");
    if (result == 0) {
        fprintf(stderr, "receive_msg: unexpectedly down...\n");
        exit(EXIT_FAILURE);
    }
}

void getcmd(const char *buf, char *cmd)
{
    int i;

    for (i = 0; buf[i] != '\0' && !isspace(buf[i]); ++i)
        cmd[i] = buf[i];
    cmd[i] = '\0';
}

void proc_retr(int sock)
{
    ssize_t result;
    char bufrecv[BUFFER_SIZE + 1];
    ssize_t n;
    int i, ch;

    for (i = 0;; ++i) {
        if ((result = recv(sock, &ch, 1, 0)) == -1)
            exit_sys("sock_readline");
        if (result == 0)
            return;
        if ((bufrecv[i] = ch) == '\n')
            break;
    }
    bufrecv[i] = '\0';

    printf("%s\n", bufrecv);
    n = (ssize_t)strtol(bufrecv + 3, NULL, 10);

    while (n > 0) {
        if ((result = recv(sock, bufrecv, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        bufrecv[result] = '\0';
        printf("%s", bufrecv);
        fflush(stdout);
        n -= result;
    }
}

void proc_list(int sock)
{
    ssize_t result;
    char bufrecv[BUFFER_SIZE];

    do {
        if ((result = sock_readline(sock, bufrecv, BUFFER_SIZE)) == -1)
            exit_sys("sock_readline");
        if (result == 0)
            break;
        printf("%s", bufrecv);
    } while (*bufrecv != '.');
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz bir e-postaya bir resim ya da dosya iliştirirsek ne olacaktır? POP3 protokolü çok eski bir protokoldür. Internet'in
    uygulama katmanındaki ilk protokollerden biridir. Bu protokolde her şey yazı gibi gönderilip alınmaktadır. Dolayısıyla 
    kullanıcı e-postasına bir resim ya da dosya iliştirdiğinde onun içeriği yazıya dönüştürülerek sanki bir yazıymış gibi 
    gönderilmektedir. Pekiyi e-postanın bu gibi farklı içerikleri posta okuyan client tarafından nasıl ayrıştırılacaktır?
    İşte bir yazı içerisinde değişik içerikler MIME denilen sistemle başlıklandırılmaktadır. E-postaları içeriklerine 
    ayrıştırabilmek için ilgili içeriklerin nasıl yazıya dönüştürüldüğünü ve nasıl geri dönüşüm yapıldığını bilmeniz gerekmektedir. 
    Bunun için Base 64 denilen yöntem kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Soketler yaratıldıktan sonra onların bazı özellikleri setsockopt isimli fonksiyonla değiştirilebilir ve getsockopt isimli 
    fonksiyonla da elde edilebilir. setsockopt fonksiyonunun prototipi şöyledir:

    #include <sys/socket.h>

    int setsockopt(int socket, int level, int option_name, const void *option_value, socklen_t option_len);

    Fonksiyonun birinci parametresi özelliği değiştirilecek soketi belirtir. İkinci parametresi değişimin hangi düzeyde yapılacağını 
    belirten bir sembolik sabit biçiminde girilir. Soket düzeyi için tipik olarak SOL_SOCKET girilmelidir. Üçüncü parametre hangi 
    özelliğin değiştirileceğini belirtmektedir. Dördüncü parametre değiştirilecek özelliğin değerinin bulunduğu nesnenin adresini 
    almaktadır. Son parametre dördüncü parametredeki nesnenin uzunluğunu belirtmektedir. Fonksiyon başarı durumunda 0, başarısızlık 
    durumunda -1 değerine geri döner.

    Soket seçeneğini elde etmek için de getsockopt fonksiyonu kullanılmaktadır:

    #include <sys/socket.h>

    int getsockopt(int socket, int level, int option_name, void *restrict option_value, socklen_t *restrict option_len);

    Parametreler setsockopt'ta olduğu gibidir. Yalnızca dördüncü parametrenin yönü değişiktir ve beşinci parametre gösterici 
    almaktadır.

    Tipik soket seçenekleri (üçüncü parametre) şunlardan biri olabilir:

    SO_ACCEPTCONN
    SO_BROADCAST
    SO_DEBUG
    SO_DONTROUTE
    SO_ERROR
    SO_KEEPALIVE
    SO_LINGER
    SO_OOBINLINE
    SO_RCVBUF
    SO_RCVLOWAT
    SO_RCVTIMEO
    SO_REUSEADDR
    SO_SNDBUF
    SO_SNDLOWAT
    SO_SNDTIMEO
    SO_TYPE

    Burada bizim için şimdilik önemli olan birkaç seçenek vardır: SO_BROADCAST, SO_OOBLINE, SO_SNDBUF, SO_RECVBUF, SO_REUSEADDR.
    Soket seçeneğinin değiştirilmesi aşağıdaki örnekte olduğu gibi yapılabilir.

    Örneğin:

    int buflen;
    int optsize = sizeof(int)
    ...
    if (getsockopt(sock_client, SOL_SOCKET, SO_RCVBUF, &buflen, &optsize) == -1)
        exit_sys("getsockopt");

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                114. Ders 26/01/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    SO_REUSEADDR seçeneği belli bir port için bind işlemi yapmış bir server'ın client bağlantısı sağladıktan sonra sonlanması 
    sonucunda bu server'ın yeniden çalıştırılıp aynı portu bind edebilmesi için kullanılmaktadır. Bir portu bind eden server, 
    bir client ile bağlandıktan sonra çökerse, ya da herhangi bir biçimde sonlanırsa işletim sistemleri o portun yeniden belli 
    bir süre bind edilmesini engellemektedir. Bunun nedeni eski çalışan server ile yeni çalışacak olan server'ın göndereceği 
    ve alacağı paketlerin karışabilme olasılığıdır. Eski bağlantıda yollanmış olan paketlerin ağda maksimum bir geçerlilik süresi 
    vardır. İşletim sistemi de bunun iki katı kadar bir süre (2 dakika civarı, neden iki katı olduğu protokolün aşağı seviyeli 
    çalışması ile ilgilidir) bu portun yeniden bind edilmesini engellemektedir. İşte eğer SO_REUSEADDR soket seçeneği kullanılırsa 
    artık sonlanan ya da çöken bir server hemen yeniden çalıştırıldığında bind işlemi sırasında "Address already in use" biçiminde 
    bir hata ile karşılaşılmayacaktır. Bu soket seçeneğini aşağıdaki gibi setsockopt fonksiyonu ile set edebiliriz:

    int sockopt = 1;
    ...
    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &sockopt, sizeof(sockopt)) == -1)
      exit_sys("setsockopt");

    SO_REUSEADDR seçeneğini set etmek için int bir nesne alıp onun içerisine sıfır dışı bir değer yerleştirip, onun adresini 
    setsockopt fonksiyonunun dördüncü parametresine girmek gerekir. Bu nesneye 0 girip fonksiyonu çağırırsak bu özelliği kapatmış 
    oluruz.

    SO_REUSEADDR bayrağı daha önce bir program tarafından bind edilmiş soketin ikinci kez diğer bir program tarafından bind 
    edilmesi için kullanılmamaktadır. Eğer böyle bir ihtiyaç varsa (nadiren olabilir) Linux'ta (fakat POSIX'te değil) SO_REUSEPORT 
    soket seçeneği kullanılmalıdır. Bu soket seçeneği benzer biçimde Windows sistemlerinde SO_EXCLUSIVEADDRUSE biçimindedir. 
    Yani bu soket seçenekleri kullanıldığında aynı port birden fazla server tarafından bind edilip aynı anda kullanılabilir. 
    Bu bayraklarla birden fazla proses aynı portu bind ettiğinde bir client'tan bu porta connect işlemi yapıldığı zaman işletim
    sistemi belli bir load balancing yaparak bağlantının server'lardan biri tarafından kabul edilmesini sağlayacaktır.

    Aşağıdaki server programını client ile bağlandıktan sonra Ctrl+C ile sonlandırınız. Sonra yeniden çalıştırmaya çalışınız. 
    SO_REUSEADDR seçeneği kullanıldığından dolayı bir sorun ile karşılaşılmayacaktır. Daha sonra server programdan o kısmı
    silerek yeniden denemeyi yapınız. Örneğimizdeki client program server adresini ve port numarasını, server program ise 
    yalnızca port numarasını komut satırı argümanı olarak almaktadır. Programları farklı terminallerde aşağıdaki gibi 
    çalıştırabilirsiniz:

    $ ./server 55555
    $ ./client localhost 555555
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock, sock_client;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    char ntopbuf[INET_ADDRSTRLEN];
    in_port_t port;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    int sockopt = 1;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &sockopt, sizeof(sockopt)) == -1)
        exit_sys("setsockopt");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");

    sinaddr_len = sizeof(sinaddr_client);
    if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
        exit_sys("accept");

    printf("Connected: %s : %u\n", inet_ntop(AF_INET, &sinaddr_client, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sinaddr_client.sin_port));

    for (;;) {
        if ((result = recv(sock_client, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%ld bytes received from %s (%u): %s\n", (long)result, ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port), buf);
    }

    shutdown(sock_client, SHUT_RDWR);
    close(sock_client);
    close(sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct addrinfo *ai, *ri;
    struct addrinfo hints = {0};
    char buf[BUFFER_SIZE];
    char *str;
    int result;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    if ((result = getaddrinfo(argv[1], argv[2], &hints, &ai)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(result));
        exit(EXIT_FAILURE);
    }

    for (ri = ai; ri != NULL; ri = ri->ai_next)
        if (connect(sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(ai);

    printf("Connected...\n");

    for (;;) {
        printf("Yazı giriniz:");
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;

        if ((send(sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
    }

    shutdown(sock, SHUT_RDWR);
    close(sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    OOB Verisi (Out-Of-Band Data) bazı stream protokollerinde olan bir özelliktir. Örneğin TCP protokolü OOB verisini 1 byte 
    olarak desteklemektedir. OOB verisine TCP'de "Acil (Urgent)" veri de denilmektedir. Bunun amacı OOB verisinin normal stream 
    sırasında değil daha önce gönderilenlerin -eğer hedef host'ta henüz onlar okunmamışsa- önünde ele alınabilmesidir. Yani biz 
    TCP'de birtakım verileri gönderdikten sonra OOB verisini gönderirsek bu veri önce göndermiş olduklarımızdan daha önde işleme 
    sokulabilir. Böylece OOB verisi uygulamalarda önce gönderilen birtakım bilgilerin iptal edilmesi gibi gerekçelerle kullanılabilmektedir.

    OOB verisini gönderebilmek için send fonksiyonunun flags parametresine MSG_OOB bayrağını girmek gerekir. Tabii TCP yalnızca 
    1 byte uzunluğunda OOB verisinin gönderilmesine izin vermektedir. Bu durumda eğer send ile birden fazla byte MSG_OOB bayrağı 
    ile gönderilmek istenirse gönderilenlerin yalnızca son byte'ı OOB olarak gönderilir. Son byte'tan önceki tüm byte'lar normal 
    veri olarak gönderilmektedir.

    Normal olarak OOB verisi recv fonksiyonunda MSG_OOB bayrağı ile alınmaktadır. Ancak bu bayrak kullanılarak recv çağrıldığında 
    eğer bir OOB verisi sırada yoksa recv başarısız olmaktadır. recv fonksiyonunun MSG_OOB bayraklı çağrısında başarılı olabilmesi 
    için o anda bir OOB verisinin gelmiş olması gerekir. Pekiyi OOB verisinin geldiğini nasıl anlarız? İşte tipik yöntem SIGURG 
    sinyalinin kullanılmasıdır. Çünkü sokete bir OOB verisi geldiğinde işletim sistemi SIGURG sinyali oluşturabilmektedir. Bu sinyalin 
    default durumu IGNORE biçimindedir. (Yani ilgili proses eğer bu sinyali set etmemişse sanki sinyal oluşmamış gibi bir davranış 
    gözükür.) Ancak default olarak OOB verisi geldiğinde sinyal oluşmamaktadır. Bunu mümkün hale getirmek için soket üzerinde fcntl 
    fonksiyonu ile F_SETOWN komut kodunu kullanarak set işlemi yapmak gerekir. fcntl fonksiyonunun son parametresi bu durumda sinyalin 
    gönderileceği prosesin id değeri olarak girilmelidir. Eğer bu parametre negatif bir proses grup id'si olarak girilirse bu 
    durumda işletim sistemi bu proses grubunun bütün üyelerine bu sinyali gönderir. Tabii tipik olarak sinyalin soket betimleyicisine 
    sahip olan prosese gönderilmesi istenir. Bu işlem şöyle yapılabilir:

    if (fcntl(sock_client, F_SETOWN, getpid()) == -1)
        exit_sys("fcntl");

    Aşağıdaki server programda bir OOB verisi geldiğinde SIGURG sinyali oluşturulmaktadır. Bu sinyalin içerisinde recv 
    fonksiyonu MSG_OOB bayrağı ile çağrılmıştır. OOB verisinin okunması için MSG_OOB bayrağı gerekir. Ancak OOB verisinin olmadığı 
    bir durumda bu bayrak kullanılırsa recv başarısız olmaktadır. O halde SIGURG sinyali geldiğinde recv fonksiyonu MSG_OOB 
    bayrağı ile çağrılmalıdır. Bu durumda TCP'de her zaman yalnızca 1 byte okunabilmektedir. Ayrıca server programda SIGURG 
    sinyali set edilirken sigaction yapısının flags parametresinin SA_RESTART biçiminde geçildiğine dikkat ediniz. Bu recv 
    üzerinde beklerken oluşabilecek SIGURG sinyalinden sonra recv'in otomatik yeniden başlatılması için kullanılmıştır. 
    Yine buradaki server program port numarasını, client program ise server adresini ve port numarasını komut satırı argümanı
    olarak almaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/* oobserver.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define BUFFER_SIZE        1024

void sigurg_handler(int sno);
void exit_sys(const char *msg);

int sock_client;

int main(int argc, char *argv[])
{
    int sock;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    char ntopbuf[INET_ADDRSTRLEN];
    in_port_t port;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    struct sigaction sa;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    sa.sa_handler = sigurg_handler;
    sa.sa_flags = SA_RESTART;
    sigemptyset(&sa.sa_mask);

    if (sigaction(SIGURG, &sa, NULL) == -1)
        exit_sys("sigaction");

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");

    sinaddr_len = sizeof(sinaddr_client);
    if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
        exit_sys("accept");

    if (fcntl(sock_client, F_SETOWN, getpid()) == -1)
            exit_sys("fcntl");

    printf("Connected: %s : %u\n", inet_ntop(AF_INET, &sinaddr_client, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sinaddr_client.sin_port));

    for (;;) {
        if ((result = recv(sock_client, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%ld bytes received from %s (%u): %s\n", (long)result, ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port), buf);
    }

    shutdown(sock_client, SHUT_RDWR);
    close(sock_client);
    close(sock);

    return 0;
}

void sigurg_handler(int sno)
{
    char oob;

    if (recv(sock_client, &oob, 1, MSG_OOB) == -1)
        exit_sys("recv");

    printf("OOB Data received: %c\n", oob);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* oobclient.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct addrinfo *ai, *ri;
    struct addrinfo hints = {0};
    char buf[BUFFER_SIZE];
    char *str;
    int result;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    if ((result = getaddrinfo(argv[1], argv[2], &hints, &ai)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(result));
        exit(EXIT_FAILURE);
    }

    for (ri = ai; ri != NULL; ri = ri->ai_next)
        if (connect(sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(ai);

    printf("Connected...\n");

    for (;;) {
        printf("Yazı giriniz:");
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
         if (!strcmp(buf, "quit"))
            break;

        if ((send(sock, buf, strlen(buf), buf[0] == 'u' ? MSG_OOB : 0)) == -1)
            exit_sys("send");
    }

    shutdown(sock, SHUT_RDWR);
    close(sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Soket fonksiyonlarını kullanarak aynı makinenin prosesleri arasında haberleşme yapabiliriz. Ancak bunun için IP protokol 
    ailesinin kullanılması oldukça yavaş bir haberleşme sağlamaktadır. İşte aynı makinenin prosesleri arasında soket fonksiyonlarını 
    kullanarak hızlı bir biçimde haberleşmenin sağlanabilmesi için ismine "UNIX Domain Socket" denilen bir soket haberleşmesi 
    oluşturulmuştur. Her ne kadar bu soket haberleşmesinin isminde UNIX geçiyorsa da bu soketler Windows sistemleri ve macOS 
    sistemleri tarafından da desteklenmektedir.

    UNIX domain soket yaratabilmek için socket fonksiyonunun birinci parametresi (protocol family) AF_UNIX geçilmelidir. UNIX domain 
    soketlerin TCP/IP ya da UDP/IP soketlerle bir ilgisi yoktur. Bu soketler UNIX/Linux sistemlerinde oldukça etkin bir biçimde 
    gerçekleştirilmektedir. Dolayısıyla aynı makinenin prosesleri arasında haberleşmede borulara, mesaj kuyruklarına, paylaşılan 
    bellek alanlarına bir seçenek olarak kullanılabilmektedir. Hatta bazı UNIX türevi sistemlerde (ama Linux'ta böyle değil) aslında 
    çekirdek tarafından önce bu protokol gerçekleştirilip daha sonra boru mekanizması bu protokol kullanılarak gerçekleştirilmektedir. 
    Böylece örneğin aynı makinedeki iki prosesin haberleşmesi için UNIX domain soketler TCP/IP ve UDP/IP soketlerine göre çok daha 
    hızlı çalışmaktadır. Aynı makine üzerinde çok client'lı uygulamalar için UNIX domain soketler boru haberleşmesine ve mesaj 
    kuyruklarına göre organizasyonel avantaj bakımından tercih edilebilmektedir. Çünkü çok client'lı boru uygulamalarını ve mesaj 
    kuyruğu uygulamalarını yazmak daha zahmetlidir. Programcılar TCP/IP ve UDP/IP soket haberleşmesi yaparken kullandıkları 
    fonksiyonların aynısını UNIX domain soketlerde de kullanabilmektedir. Böylece örneğin elimizde bir TCP/IP ya da UDP/IP 
    client-server program varsa bu programı kolaylıkla UNIX domain soket kullanılacak biçimde değiştirebiliriz.

    UNIX domain soketlerin kullanımı en çok boru kullanımına benzemektedir. Ancak UNIX domain soketlerin borulara olan bir 
    üstünlüğü "full duplex" haberleşme sunmasıdır. Bilindiği gibi borular "half duplex" bir haberleşme sunmaktadır. Ancak 
    genel olarak boru haberleşmeleri UNIX domain soket haberleşmelere göre daha hızlı olma eğilimindedir.

    UNIX domain soketler kullanım olarak daha önce görmüş olduğumuz TCP/IP ve UDP/IP soketlerine çok benzemektedir. Yani işlemler
    sanki TCP/IP ya da UDP/IP client server program yazılıyormuş gibi yapılır. Başka bir deyişle UNIX domain soketlerinde client ve 
    server programların genel yazım adımları TCP/IP ve UDP/IP ile aynıdır.

    UNIX domain soketlerde client'ın server'a bağlanması için gereken adres bir dosya ismi yani yol ifadesi biçimindedir. Kullanılacak 
    yapı sockaddr_in değil, sockaddr_un yapısıdır. Bu yapı <sys/un.h> dosyası içerisinde bildirilmiştir ve en azından şu elemanlara 
    sahip olmak zorundadır:

    #include <sys/un.h>

    struct sockaddr_un {
        sa_family_t sun_family;
        char sun_path[108];
    };

    Yapının sun_family elemanı AF_UNIX biçiminde, sun_path elemanı da soketi temsil eden dosyanın yol ifadesi biçiminde girilmelidir. 
    Burada yol ifadesiyle belirtilen dosya bind işlemi tarafından yaratılmaktadır. Yaratılan bu dosyanın türü "ls -l komutunda" 
    "(s)ocket" biçiminde görüntülenmektedir. Eğer bu dosya zaten varsa bind fonksiyonu başarısız olur. Dolayısıyla bu dosyanın 
    varsa silinmesi gerekmektedir. O halde client ve server programlar işin başında bir isim altında anlaşmalıdır. Önemli bir 
    nokta da şudur: sockaddr_un yapısının kullanılmadan önce sıfırlanması gerekmektedir. bind tarafından yaratılan bu soket 
    dosyaları normal bir dosya değildir. Yani open fonksiyonuyla açılamamaktadır.

    UNIX domain soketlerde port numarası biçiminde bir kavramın olmadığına dikkat ediniz. Port numarası kavramı IP ailesinin
    aktarım katmanına ilişkin bir kavramdır. UNIX domain soketler AF_UNIX protokol ailesi ismiyle oluşturulan başka bir ailenin
    soketleridir.

    Pekiyi stream tabanlı UNIX domain soketlerde server accept uyguladığında client'a ilişkin sockaddr_un yapısından ne almaktadır?
    Aslında bu protokolde bir port kavramı olmadığına göre server bağlantıdan bir bilgi elde etmeyecektir. Fakat yine de 
    client program da bind uygulayıp ondan sonra sokete bağlanabilir. Bu durumda server, client bağlantısından sonra sockaddr_un
    yapısından client'ın bind ettiği soket dosyasının yol ifadesini elde eder.

    Aşağıdaki örnekte çok client'lı bir UNIX domain soket örneği verilmiştir. Örneğimizdeki server programda thread modeli
    kullanılmıştır. Yani server her client bağlantısında bir thread yaratmaktadır. Bu programların her ikisinde de komut 
    satırı argümanı olarak soket dosyasının yol ifadesi alınmaktadır. Bir soket dosyası zaten var ise bind işleminin başarısız
    olacağını anımsayınız. 
---------------------------------------------------------------------------------------------------------------------------*/

/* uds-server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

typedef struct tagCLIENT_INFO {
    int sock;
    struct sockaddr_un sun;
} CLIENT_INFO;

void *client_thread_proc(void *param);
char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_un sun_server, sun_client;
    socklen_t sun_len;
    CLIENT_INFO *ci;
    ssize_t result;
    pthread_t tid;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((server_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path, argv[1]);

    if (bind(server_sock, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    for (;;) {
        printf("waiting for connection...\n");
        sun_len = sizeof(sun_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sun_client, &sun_len)) == -1)
            exit_sys("accept");

        printf("Connected new client\n");

        if ((ci = (CLIENT_INFO *)malloc(sizeof(CLIENT_INFO))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }

        ci->sock = client_sock;
        ci->sun = sun_client;

        if ((result = pthread_create(&tid, NULL, client_thread_proc, ci)) != 0) {
            fprintf(stderr, "pthread_create: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }

        if ((result = pthread_detach(tid)) != 0) {
            fprintf(stderr, "pthread_detach: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }
    }

    close(server_sock);

    return 0;
}

void *client_thread_proc(void *param)
{
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    CLIENT_INFO *ci = (CLIENT_INFO *)param;
    ssize_t result;

    for (;;) {
        if ((result = recv(ci->sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received: %s\n", (intmax_t)result, buf);
        revstr(buf);
        if (send(ci->sock, buf, result, 0) == -1)
            exit_sys("send");
    }

    printf("client disconnected...\n");

    shutdown(ci->sock, SHUT_RDWR);
    close(ci->sock);

    free(ci);

    return NULL;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* uds-client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_un sun_server;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    char *str;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((client_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path, argv[1]);

    if (connect(client_sock, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
        exit_sys("connect");

    for (;;) {
        printf("Yazı giriniz:");
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if ((send(client_sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;

        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%ld bytes received: %s\n", (long)result, buf);
    }

    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                115. Ders 28/01/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte client program da bind işlemi uygulamaktadır. Böylece server client'ın soket ismini accept fonksiyonundan 
    elde edebilmektedir. Ancak uygulamada client'ın bu biçimde bind yapması genellikle tercih edilmemektedir. Eğer client'a bir 
    isim verilecekse sonraki paragrafta açıklanacağı gibi "soyut bir isim" verilmelidir. Buradaki örneğimizde yine server program 
    socket dosyasının yol ifadesi ile çalıştırılmalıdır. Client program da hem server soketin hem de client soketin yol ifadesi ile 
    çalıştırılmalıdır. Örneğin:

    $ ./uds-server serversock
    $ ./uds-client serversock clientsock
---------------------------------------------------------------------------------------------------------------------------*/

/* uds-server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

typedef struct tagCLIENT_INFO {
    int sock;
    struct sockaddr_un sun;
} CLIENT_INFO;

void *client_thread_proc(void *param);
char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_un sun_server, sun_client;
    socklen_t sun_len;
    CLIENT_INFO *ci;
    ssize_t result;
    pthread_t tid;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((server_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path, argv[1]);

    if (bind(server_sock, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    for (;;) {
        printf("waiting for connection...\n");
        sun_len = sizeof(sun_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sun_client, &sun_len)) == -1)
            exit_sys("accept");

        printf("Connected new client: %s\n", sun_client.sun_path);

        if ((ci = (CLIENT_INFO *)malloc(sizeof(CLIENT_INFO))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }

        ci->sock = client_sock;
        ci->sun = sun_client;

        if ((result = pthread_create(&tid, NULL, client_thread_proc, ci)) != 0) {
            fprintf(stderr, "pthread_create: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }

        if ((result = pthread_detach(tid)) != 0) {
            fprintf(stderr, "pthread_detach: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }
    }

    close(server_sock);

    return 0;
}

void *client_thread_proc(void *param)
{
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    CLIENT_INFO *ci = (CLIENT_INFO *)param;
    ssize_t result;

    for (;;) {
        if ((result = recv(ci->sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received from \"%s\": %s\n", (intmax_t)result, ci->sun.sun_path, buf);
        revstr(buf);
        if (send(ci->sock, buf, result, 0) == -1)
            exit_sys("send");
    }

    printf("\"%s\" client disconnected...\n", ci->sun.sun_path);

    shutdown(ci->sock, SHUT_RDWR);
    close(ci->sock);

    free(ci);

    return NULL;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* uds-client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_un sun_server, sun_client;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    char *str;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((client_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_client, 0, sizeof(sun_client));
    sun_client.sun_family = AF_UNIX;
    strcpy(sun_client.sun_path, argv[2]);

    if (bind(client_sock, (struct sockaddr *)&sun_client, sizeof(sun_client)) == -1)
        exit_sys("bind");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path, argv[1]);

    if (connect(client_sock, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
        exit_sys("connect");

    for (;;) {
        printf("Yazı giriniz:");
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if ((send(client_sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;

        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%ld bytes received: %s\n", (long)result, buf);
    }

    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında Linux sistemlerinde client'ın server'a kendini tanıtması için soyut (abstract) bir adres de oluşturulabilmektedir. 
    Client program sockaddr_un yapısındaki sun_path elemanının ilk byte'ını null karakter olarak geçip diğer byte'larına bir 
    bilgi girebilir. Client bu biçimde bind işlemi yaptığında artık soket dosyası yaratılmaz. Ancak bu isim accept ile karşı 
    tarafa iletilir. Dolayısıyla client'ın girmiş olduğu yol ifadesi aslında soyut bir yol ifadesi olarak client'ı tespit 
    etmek amacıyla kullanılabilir. Bu özelliğin POSIX standartlarında bulunmadığını, yalnızca Linux sistemlerine özgü olduğunu
    bir kez daha anımsatmak istiyoruz.

    Aşağıdaki örnekte client program bind işlemini yukarıda açıkladığımız gibi yapmaktadır. Dolayısıyla client program bir 
    soket yaratmamış olacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/* uds-server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

typedef struct tagCLIENT_INFO {
    int sock;
    struct sockaddr_un sun;
} CLIENT_INFO;

void *client_thread_proc(void *param);
char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_un sun_server, sun_client;
    socklen_t sun_len;
    CLIENT_INFO *ci;
    ssize_t result;
    pthread_t tid;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((server_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path, argv[1]);

    if (bind(server_sock, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    for (;;) {
        printf("waiting for connection...\n");
        sun_len = sizeof(sun_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sun_client, &sun_len)) == -1)
            exit_sys("accept");

        printf("Connected new client: %s\n", sun_client.sun_path + 1);

        if ((ci = (CLIENT_INFO *)malloc(sizeof(CLIENT_INFO))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }

        ci->sock = client_sock;
        ci->sun = sun_client;

        if ((result = pthread_create(&tid, NULL, client_thread_proc, ci)) != 0) {
            fprintf(stderr, "pthread_create: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }

        if ((result = pthread_detach(tid)) != 0) {
            fprintf(stderr, "pthread_detach: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }
    }

    close(server_sock);

    return 0;
}

void *client_thread_proc(void *param)
{
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    CLIENT_INFO *ci = (CLIENT_INFO *)param;
    ssize_t result;

    for (;;) {
        if ((result = recv(ci->sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received from \"%s\": %s\n", (intmax_t)result, ci->sun.sun_path + 1, buf);
        revstr(buf);
        if (send(ci->sock, buf, result, 0) == -1)
            exit_sys("send");
    }

    printf("\"%s\" client disconnected...\n", ci->sun.sun_path + 1);

    shutdown(ci->sock, SHUT_RDWR);
    close(ci->sock);

    free(ci);

    return NULL;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* uds-client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_un sun_server, sun_client;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    char *str;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((client_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_client, 0, sizeof(sun_client));
    sun_client.sun_family = AF_UNIX;
    strcpy(sun_client.sun_path + 1, argv[2]);

    if (bind(client_sock, (struct sockaddr *)&sun_client, sizeof(sun_client)) == -1)
        exit_sys("bind");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path, argv[1]);

    if (connect(client_sock, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
        exit_sys("connect");

    for (;;) {
        printf("Yazı giriniz:");
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if ((send(client_sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;

        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%ld bytes received: %s\n", (long)result, buf);
    }

    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında Linux sistemlerinde server program da bind işlemini yaparken soyut isim kullanabilir. Yani server program da aslında 
    sockaddr_un yapısındaki sun_path elemanının ilk karakterini null karakter yapıp diğer karakterlerine soketin ismini 
    yerleştirebilir. Bu durumda haberleşme sırasında gerçekte hiçbir soket dosyası yaratılmayacaktır. Tabii soket dosyalarının 
    önemli bir işlevi erişim haklarına sahip olmasıdır. Soyut isimler kullanıldığında böyle bir erişim hakkı kontrolü 
    yapılmamaktadır.

    Aşağıdaki örnekte server program da soyut bir isim kullanmaktadır. Buradaki haberleşmede hiç soket dosyasının yaratılmayacağına
    dikkat ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* uds-server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

typedef struct tagCLIENT_INFO {
    int sock;
    struct sockaddr_un sun;
} CLIENT_INFO;

void *client_thread_proc(void *param);
char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_un sun_server, sun_client;
    socklen_t sun_len;
    CLIENT_INFO *ci;
    ssize_t result;
    pthread_t tid;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((server_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path + 1, argv[1]);

    if (bind(server_sock, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    for (;;) {
        printf("waiting for connection...\n");
        sun_len = sizeof(sun_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sun_client, &sun_len)) == -1)
            exit_sys("accept");

        printf("Connected new client: %s\n", sun_client.sun_path + 1);

        if ((ci = (CLIENT_INFO *)malloc(sizeof(CLIENT_INFO))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }

        ci->sock = client_sock;
        ci->sun = sun_client;

        if ((result = pthread_create(&tid, NULL, client_thread_proc, ci)) != 0) {
            fprintf(stderr, "pthread_create: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }

        if ((result = pthread_detach(tid)) != 0) {
            fprintf(stderr, "pthread_detach: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }
    }

    close(server_sock);

    return 0;
}

void *client_thread_proc(void *param)
{
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    CLIENT_INFO *ci = (CLIENT_INFO *)param;
    ssize_t result;

    for (;;) {
        if ((result = recv(ci->sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received from \"%s\": %s\n", (intmax_t)result, ci->sun.sun_path + 1, buf);
        revstr(buf);
        if (send(ci->sock, buf, result, 0) == -1)
            exit_sys("send");
    }

    printf("\"%s\" client disconnected...\n", ci->sun.sun_path + 1);

    shutdown(ci->sock, SHUT_RDWR);
    close(ci->sock);

    free(ci);

    return NULL;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* uds-client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_un sun_server, sun_client;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    char *str;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((client_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_client, 0, sizeof(sun_client));
    sun_client.sun_family = AF_UNIX;
    strcpy(sun_client.sun_path + 1, argv[2]);

    if (bind(client_sock, (struct sockaddr *)&sun_client, sizeof(sun_client)) == -1)
        exit_sys("bind");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path + 1, argv[1]);

    if (connect(client_sock, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
        exit_sys("connect");

    for (;;) {
        printf("Yazı giriniz:");
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if ((send(client_sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;

        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%ld bytes received: %s\n", (long)result, buf);
    }

    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX domain soketler aynı makinenin prosesleri arasında haberleşme sağladığına göre bunlarda send işlemi ile gönderilen 
    bilginin tek bir recv işlemi ile alınması beklenir. Gerçekten de Linux sistemlerinde tasarım bu biçimde yapılmıştır. 
    Ancak POSIX standartları bu konuda bir garanti vermemektedir. Ancak Linux sistemlerinde tıpkı borularda olduğu gibi bu işlem 
    için ayrılan tampon büyüklüğünden fazla miktarda byte send (ya da write) ile gönderildiğinde parçalı okuma gerçekleşebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX domain soketlerde datagram haberleşme de yapılabilir. Bu haberleşme mesaj kuyruklarına bir seçenek oluşturmaktadır. 
    UNIX domain soketlerde datagram haberleşmede gönderilen datagram'ların aynı sırada alınması garanti edilmiştir. Yani 
    gönderim UDP/IP'de olduğu gibi güvensiz değil, güvenlidir. Anımsanacağı gibi UDP/IP'de gönderilen datagram'lar hedefe farklı
    sıralarda ulaşabiliyordu. Aynı zamanda bir datagram ağda kaybolursa bunun bir telafisi söz konusu değildi. UNIX domain 
    soketlerde her şey aynı makinede ve işletim sisteminin kontrolü altında gerçekleştirildiği için böylesi bir durum söz konusu
    olmayacaktır.

    Aşağıda UNIX domain soketler kullanılarak bir datagram haberleşme örneği verilmiştir. Burada server hiç bağlantı sağlamadan 
    herhangi bir client'tan paketi alır, oradaki yazıyı ters çevirip ona geri gönderir. Hem client hem de server ayrı ayrı iki 
    dosya ismi ile bind işlemi yapmaktadır. Server program komut satırı argümanı olarak kendi bind edeceği soket dosyasının 
    yol ifadesini, client program ise hem kendi bind edeceği soket dosyasının yol ifadesini hem de server soketin yol ifadesini 
    almaktadır. Bu örnekte server ve client önce remove fonksiyonu ile daha önce yaratılan soket dosyasını aynı zamanda silmektedir.

    Aşağıda UNIX domain datagram sokete ilişkin bir örnek verilmiştir. Örnekte client server'a bir datagram mesaj göndermekte ve 
    server da onu ters çevirip client'a geri yollamaktadır. Server program, server soketin yol ifadesini komut satırı argümanı 
    olarak almaktadır. Client program da hem server soketin yol ifadesini hem de client soketin yol ifadesini komut satırı 
    argümanı olarak almaktadır. Programları şöyle çalıştırabilirsiniz:

    $ ./uds-dg-server serversock
    $ ./uds-dg-client serversock clientsock
---------------------------------------------------------------------------------------------------------------------------*/

/* uds-dg-server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct sockaddr_un sun_server, sun_client;
    socklen_t sun_len;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((sock = socket(AF_UNIX, SOCK_DGRAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path, argv[1]);

    if (remove(argv[1]) == -1 && errno != ENOENT)
        exit_sys("remove");

    if (bind(sock, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
        exit_sys("bind");

    printf("Waiting for client data...\n");

    for (;;) {
        sun_len = sizeof(sun_client);
        if ((result = recvfrom(sock, buf, BUFFER_SIZE, 0, (struct sockaddr *)&sun_client, &sun_len)) == -1)
            exit_sys("recvfrom");

        buf[result] = '\0';
        printf("%ld bytes received from \"%s\": %s\n", (long)result, sun_client.sun_path, buf);

        revstr(buf);
        if (sendto(sock, buf, strlen(buf), 0, (struct sockaddr *)&sun_client, sizeof(sun_client)) == -1)
            exit_sys("sendto");
    }

    close(sock);

    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* uds-dg-client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct sockaddr_un sun_client, sun_server, sun_response;
    socklen_t sun_len;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((sock = socket(AF_UNIX, SOCK_DGRAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_client, 0, sizeof(sun_client));
    sun_client.sun_family = AF_UNIX;
    strcpy(sun_client.sun_path, argv[2]);

    if (remove(argv[2]) == -1 && errno != ENOENT)
        exit_sys("remove");

    if (bind(sock, (struct sockaddr *)&sun_client, sizeof(sun_client)) == -1)
        exit_sys("bind");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path, argv[1]);

    for (;;) {
        printf("Yazı giriniz:");
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;

        if (sendto(sock, buf, strlen(buf), 0, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
            exit_sys("sendto");

        sun_len = sizeof(sun_server);
        if ((result = recvfrom(sock, buf, BUFFER_SIZE, 0, (struct sockaddr *)&sun_response, &sun_len)) == -1)
            exit_sys("recvfrom");

        buf[result] = '\0';
        printf("%ld bytes received from \"%s\": %s\n", (long)result, sun_response.sun_path, buf);
    }

    close(sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                116. Ders 02/02/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX domain soketler "isimsiz boru haberleşmesine" benzer biçimde de kullanılabilmektedir. Anımsanacağı gibi isimsiz borularla
    yalnızca üst ve alt prosesler arasında haberleşme yapılabiliyordu. Yine anımsayacağınız gibi pipe fonksiyonu bize iki 
    betimleyici veriyordu. Biz de fork işlemi ile bu betimleyicileri alt prosese geçiriyorduk. İşte isimsiz borularla yapılan 
    şeylerin benzeri soketlerle de yapılabilmektedir. İsimsiz soketlere İngilizce "unbound sockets" de denilmektedir.
    İsimsiz (unbound) soket yaratımı socketpair isimli fonksiyonla yapılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <sys/socket.h>

    int socketpair(int domain, int type, int protocol, int sv[2]);

    Fonksiyonun birinci parametresi protokol ailesinin ismini alır. Her ne kadar fonksiyon genel olsa da pek çok işletim sistemi 
    bu fonksiyonu yalnızca UNIX domain soketler için gerçekleştirmektedir. (Gerçekten de üst ve alt prosesler arasında UNIX domain 
    soketler varken örneğin TCP/IP soketleriyle haberleşmenin zarardan başka bir faydası olmayacaktır.) Linux sistemleri isimsiz 
    soket olarak yalnızca UNIX domain soketlerini desteklemektedir. Dolayısıyla bu birinci parametre Linux sistemlerinde AF_UNIX 
    biçiminde geçilmelidir. Fonksiyonun ikinci parametresi kullanılacak soketin türünü belirtir. Bu parametre yine SOCK_STREAM 
    ya da SOCK_DGRAM biçiminde girilmelidir. Üçüncü parametre kullanılacak transport katmanını belirtmektedir. Bu parametre 0 olarak 
    geçilebilir. Son parametre bir çift soket betimleyicisinin yerleştirileceği iki elemanlı int türden dizinin başlangıç adresini 
    almaktadır. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Örneğin:

    int socks[2];

    if (socketpair(AF_UNIX, SOCK_STREAM, 0, socks) == -1)
        exit_sys("socketpair");

    socketpair fonksiyonu SOCK_STREAM soketler için zaten bağlantı sağlanmış iki soketi bize vermektedir. Yani bu fonksiyon 
    çağrıldıktan sonra listen, accept, connect gibi fonksiyonların çağrılması gereksizdir. Dolayısıyla tipik haberleşme şöyle 
    gerçekleştirilmektedir:

    1) socketpair fonksiyonu ile soket çifti yaratılır.

    2) Soket çifçi yaratıldıktan sonra fork ile alt proses yaratılır.

    3) İki taraf da kullanmayacakları soketleri kapatırlar. Hangi prosesin socketpair fonksiyonunun son parametresine yerleştirilen
    hangi soket betimleyicisini kullanacağının bir önemi yoktur.

    4) Haberleşme soket fonksiyonlarıyla gerçekleştirilir.

    Pekiyi isimsiz borularla socketpair fonksiyonuyla oluşturulan isimsiz UNIX domain soketler arasında ne fark vardır?
    Aslında bu iki kullanım benzer etkilere sahiptir. Ancak en önemli farklılık UNIX domain soketlerin çift yönlü (full duplex)
    bir haberleşme sağlamasıdır. Normalde isimsiz mesaj kuyrukları olmadığına dikkat ediniz. Halbuki isimsiz UNIX domain soketler 
    sanki isimsiz mesaj kuyrukları gibi de kullanılabilmektedir.

    Aşağıdaki programda tıpkı isimsiz boru haberleşmesinde olduğu gibi üst ve alt prosesler birbirleri arasında isimsiz UNIX 
    domain soketler yoluyla haberleşmektedir. Buradaki soketlerin çift yönlü haberleşmeye olanak verdiğini anımsayınız.
---------------------------------------------------------------------------------------------------------------------------*/

/* uds-socketpair.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/socket.h>

#define BUFFER_SIZE        1024

char *revstr(char *str);
void exit_sys(const char *msg);

int main(void)
{
    int socks[2];
    char buf[BUFFER_SIZE + 1];
    char *str;
    ssize_t result;
    pid_t pid;

    if (socketpair(AF_UNIX, SOCK_STREAM, 0, socks) == -1)
        exit_sys("socketpair");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {        /* parent */
        close(socks[1]);

        for (;;) {
            if ((result = recv(socks[0], buf, BUFFER_SIZE, 0)) == -1)
                exit_sys("recv");
            if (result == 0)
                break;
            buf[result] = '\0';
            if (!strcmp(buf, "quit"))
                break;
            revstr(buf);
            if (send(socks[0], buf, strlen(buf), 0) == -1)
                exit_sys("send");
        }

        if (waitpid(pid, NULL, 0) == -1)
            exit_sys("waitpid");

        close(socks[0]);

        exit(EXIT_SUCCESS);
    }
    else {            /* child */
        close(socks[0]);

        for (;;) {
            printf("Yazı giriniz:");
            if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
                continue;
            if ((str = strchr(buf, '\n')) != NULL)
                *str = '\0';
            if ((send(socks[1], buf, strlen(buf), 0)) == -1)
                exit_sys("send");
            if (!strcmp(buf, "quit"))
                break;
            if ((result = recv(socks[1], buf, BUFFER_SIZE, 0)) == -1)
                exit_sys("recv");
            if (result == 0)
                break;
            buf[result] = '\0';

            printf("%ld bytes received: %s\n", (long)result, buf);
        }

        close(socks[1]);
        exit(EXIT_SUCCESS);
    }

    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bu bölümde TCP ve UDP protokollerinin aşağı seviyeli çalışma mekanizması üzerinde durulacaktır. Ancak bu protokollerin aşağı
    seviyeli çalışma biçimleri biraz karmaşıktır. Biz burada çok derine inmeden bu çalışma biçimini açıklayacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP protokolü 1981 yılında RFC 793 dokümanı ile tanımlanmıştır (https://tools.ietf.org/html/rfc793). Sonradan protokole 
    bazı revizyonlar ve eklemeler de yapılmıştır. Protokolün son güncel versiyonu 2022'de RFC 9293 dokümanında tanımlanmıştır.

    Paket tabanlı protokollerin hepsinde gönderilip alınan veriler paket biçimindedir (yani bir grup byte biçimindedir). Bu paketlerin
    "başlık (header) ve veri (data)" kısımları vardır. Örneğin "Ethernet paketinin başlık ve veri kısmı", "IP paketinin başlık ve 
    veri kısmı", "TCP paketinin başlık ve veri kısmı" bulunmaktadır. Öte yandan TCP protokolü aslında IP protokolünün üzerine 
    oturtulmuştur. Yani aslında TCP paketleri IP paketleri gibi gönderilip alınmaktadır. Nihayet aslında bu paketler bilgisayarımıza 
    Ethernet ya da Wireless paketi olarak gelmektedir. Paketlerin başlık kısımlarında önemli "metadata" bilgileri bulunmaktadır. 
    O halde örneğin aslında bizim network kartımıza bilgiler Ethernet paketi gibi gelmektedir. Aslında IP paketi Ethernet paketinin 
    veri kısmında, TCP paketi de aslında IP paketinin veri kısmında konuşlandırılmaktadır. Yani aslında bize gelen Ethernet paketinin 
    veri kısmında IP paketi, IP paketinin veri kısmında da TCP paketi bulunmaktadır. TCP'de gönderdiğimiz veriler aslında IP paketinin 
    veri kısmını oluşturmaktadır.

    Örneğin bir host'tan diğerine bir TCP paketinin gönderildiğini düşünelim. TCP paketi "TCP Header" ve "TCP Data" kısmından oluşmaktadır:

    +-------------------------+
    |        TCP Header       |
    +-------------------------+
    |         TCP Data        |
    +-------------------------+

    Ancak TCP paketi aslında IP paketi gibi gönderilmektedir. IP paketi de "IP Header" ve "IP Data" kısımlarından oluşmaktadır. 
    İşte aslında TCP paketi IP paketinin Data kısmında bulundurulur. Yani yolculuk eden TCP paketinin görünümü şöyledir:

    +-------------------------+
    |        IP Header        |
    +-------------------------+   <---+
    |        TCP Header       |       |
    +-------------------------+     IP Data
    |         TCP Data        |       |
    +-------------------------+   <---+

    TCP paketi de bilgisayarımızın Ethernet kartına sanki Ethernet paketi gibi gelmektedir. Ethernet paketi de "Ethernet Header" ve 
    "Ethernet Data" kısımların oluşmaktadır. İşte bütün TCP paketi aslında IP paketi gibi IP paketi de Ethernet paketi gibi gönderilip 
    alınmaktadır:

    +-------------------------+
    |     Ethernet Header     |
    +-------------------------+   <----------------+
    |        IP Header        |                    |
    +-------------------------+   <---+            |
    |        TCP Header       |       |       Ethernet Data
    +-------------------------+     IP Data        |
    |         TCP Data        |       |            |
    +-------------------------+   <---+------------+

    Bu durumu aşağıdaki gibi de gösterebiliriz:

    +-------------------------+
    |     Ethernet Header     |
    +----+--------------------+----+
         |        IP Header        |
         +----+--------------------+----+
              |        TCP Header       |
              +----+--------------------+----+
                   |         TCP Data        |
                   +-------------------------+

    Örneğin biz TCP'de send fonksiyonuyla "ankara" yazısını gönderiyor olalım. Bu "ankara" yazısını oluşturan byte'lar aslında 
    TCP paketinin veri kısmındadır.

    +-------------------------+
    |     Ethernet Header     |
    +----+--------------------+----+
         |        IP Header        |
         +----+--------------------+----+
              |        TCP Header       |
              +----+--------------------+----+
                   |         "ankara"        |
                   +-------------------------+

    Ethernet protokolü (IEEE 802.3) OSI katmanına göre fiziksel ve veri bağlantı katmanının işlevlerini yerine getirmektedir.
    Wireless haberleşme için kullanılan Wi-Fi protokolü (IEEE 802.11) Ethernet protokolünün telsiz (wireless) biçimi gibi düşünülebilir.

    Tabii IP paketleri aslında yalnızca bilgisayarımıza gelirken Ethernet paketi ya da Wi-Fi paketi olarak gelir. Dışarıda rotalanırken 
    Ethernet paketi söz konusu değildir.

    IP protokolünün IPv4 ve IPv6 biçiminde iki versiyonunun olduğunu anımsayınız. Ancak TCP ve UDP protokollerinin böyle bir 
    versiyon numarası yoktur. TCP paketi IPv4 paketinin veri kısmında da IPv6 paketinin veri kısmında da konuşlandırılmış olabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yerel ağımızda aslında router tarafından gönderilip alınan paketlerin hepsi yerel ağdaki tüm bilgisayarlara ulaşmaktadır. 
    Ethernet ve Wireless kartları yalnızca kendilerini ilgilendiren paketleri alıp işletim sistemini haberdar edebilmektedir. 
    Ancak bu kartlar için yazılmış özel programlar sayesinde bilgisayarımıza ulaşan tüm paketler incelenebilmektedir. Bu tür
    yardımcı programlara "network sniffer" da denilmektedir.

    En yaygın kullanılan "network sniffer" program "wireshark" isimli open source programdır. Bu programın eskiden ismi 
    "Ethereal" biçimindeydi. Aslında wireshark programı "libpcap" isimli open source kütüphane kullanılarak yazılmıştır. Yani
    asıl işlevsellik bu kütüphanededir. Wireshark adeta libpcap kütüphanesinin bir önyüzü (front-end) gibidir. Bu kütüphanenin 
    Windows versiyonuna "npcap" denilmektedir. Linux Debian türevi sistemlerde kütüphane aşağıdaki gibi indirilebilir:

    $ sudo apt-get install libpcap-dev

    Benzer biçimde Linux'ta wireshark programını da GUI arayüzü yazılım yöneticisinden yüklenebileceği gibi komut satırından 
    Debian türevi sistemlerde aşağıdaki gibi yüklenebilir:

    $ sudo apt-get install wireshark

    Wireshark programının kullanımına ilişkin pek çok "tutorial" bulunmaktadır. Kursumuzun EBooks klasöründe de birkaç kitap
    bulunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    IPv4 protokolünün başlık (header) kısmı şöyledir (her satırda 4 byte bulunmaktadır). Toplam başlık uzunluğu 20 byte'dır.

    <------- Byte 1 -------><------- Byte 2 -------><------- Byte 3 -------><------- Byte 4 ------->
    +-----------+-----------+----------------------+-----------------------------------------------+             ^
    |  Version  |    IHL    |    Type of Service   |                  Total Length                 |  (4 bytes)  |
    | (4 bits)  | (4 bits)  |       (8 bits)       |                   (16 bits)                   |             |
    +-----------+-----------+----------------------+-----------+-----------------------------------+             |
    |                 Identification               |   Flags   |           Fragment Offset         |  (4 bytes)  |
    |                   (16 bits)                  |  (3 bits) |              (13 bits)            |             |
    +-----------------------+----------------------+-----------+-----------------------------------+             |
    |   Time to Live (TTL)  |       Protocol       |                 Header Checksum               |  (4 bytes)  |  20 bytes
    |         (8 bits)      |       (8 bits)       |                    (16 bits)                  |             |
    +-----------------------+----------------------+-----------------------------------------------+             |
    |                                  Source IP Address (32 bits)                                 |  (4 bytes)  |
    +----------------------------------------------------------------------------------------------+             |
    |                               Destination IP Address (32 bits)                               |  (4 bytes)  |
    +----------------------------------------------------------------------------------------------+             v
    |                            Segment (L4 protocol (TCP/UDP) + Data)                            |
    +----------------------------------------------------------------------------------------------+

    Version : IP versiyonunu içerir. IPv4 ya da IPv6 değerlerinden birini içermektedir. IPv4 için 4 değeri kullanılmaktadır. (0100)
    IHL : Internet Header Length bilgisini içermektedir. Genelde 20 byte değerini içerir. Fakat farklı değerler aldığı durumlar da 
    söz konusu olabilmektedir.
    Type of Service : DS / DSCP / ECN alanlarını içermektedir. Paket önceliği konusunda kullanılmaktadır.
    Total Length : Header ve data'nın toplam uzunluk bilgisini içermektedir.
    Identification, Flags, Frament Offset : Paketin ikinci 4 byte'lık kısmı fragmentation için kullanılmaktadır.
    Time to Live (TTL) : Paketin yaşam ömrünün bilgisini içermektedir. Yaşam ömrü her router geçildiğinde bir azalmaktadır. Eğer 
    TTL değeri 0 olursa paket router tarafından çöpe atılmaktadır. TTL genel olarak yolunu şaşırmış paketlerin network'lerde sonsuza 
    kadar dolaşmasını önlemek için kullanılmaktadır. Bazen de paket router'lar arasında bir loop (routing loop) içerisinde takılıp 
    kalmaktadır. TTL, bu gibi durumları engellemek için kullanılmaktadır. Dünya'da en uzak noktaya bile data gönderirken maksimum 
    15-20 router geçilmektedir.
    Protocol : L4 protokol bilgisini içermektedir. Örneğin, TCP için 6, UDP için 17, ICMP için 1 değerlerini içermektedir.
    Header Checksum : Router'lar IP paket header'ının yolda bozulup bozulmadığını bu değeri kontrol ederek sağlayabilmektedir.
    Source IP Address : Kaynak IP adresinin unicast IP adresi olması gerekmektedir.
    Destination IP Address : Hedef IP adresi unicast, broadcast ve multicast IP adresi olabilir.

    Buradan da gördüğünüz gibi IP başlığında kaynak ve hedef IP adresleri ve IP paketinin toplam uzunluğu bulunmaktadır. Port
    kavramının IP protokolünde olmadığını anımsayınız.

    IPv6 header kısmı aşağıda verilmiştir. Toplam başlık uzunluğu 40 byte'a sabitlenmiştir.

    <------- Byte 1 -------><------- Byte 2 -------><------- Byte 3 -------><------- Byte 4 ------->
    +-----------+-----------------+----------------------------------------------------------------+             ^
    |  Version  |  Traffic Class  |                           Flow Label                           |  (4 bytes)  |
    | (4 bits)  |    (4 bits)     |                                                                |             |
    +-----------+-----------------+----------------+-----------------------+-----------------------+             |
    |                 Payload Length               |      Next Header      |       Hop Limit       |  (4 bytes)  |
    |                   (16 bits)                  |                       |                       |             |
    +----------------------------------------------+-----------------------+-----------------------+             |
    |                                                                                              |             |
    |                                                                                              |             |
    |                                                                                              |             |
    |                                                                                              |             |
    |                                 Source IP Address (128 bits)                                 | (16 bytes)  |
    |                                                                                              |             |  40 bytes
    |                                                                                              |             |
    |                                                                                              |             |
    +----------------------------------------------------------------------------------------------+             |
    |                                                                                              |             |
    |                                                                                              |             |
    |                                                                                              |             |
    |                                                                                              |             |
    |                              Destination IP Address (128 bits)                               | (16 bytes)  |
    |                                                                                              |             |
    |                                                                                              |             |
    |                                                                                              |             |
    +----------------------------------------------------------------------------------------------+             v

    Version : IP versiyonunu içerir. IPv6 için 6 değeri kullanılmaktadır. (0110)
    Traffic Class : Paket önceliği konusunda kullanılmaktadır.
    Flow Label : Bir sunucuyla yapılan haberleşme için bir numara belirlenmektedir ve haberleşme boyunca bütün paketlerde 
    bu numara kullanılarak iletişim sağlanmaktadır. Farklı amaçlar için de kullanıldığı durumlar vardır.
    Payload Length : Datanın boyutunu içermektedir.
    Next Header : L4 protokol bilgisini içermektedir.
    Hop Limit : IPv4'teki TTL alanıyla aynıdır.

    TCP paketi yukarıda da belirttiğimiz gibi IP paketinin veri (data) kısmındadır. TCP paketi de "TCP Header" ve "TCP Data" 
    kısımlarından oluşmaktadır. TCP başlık kısmı şöyledir. (her satırda 4 byte bulunmaktadır):

    <------- Byte 1 -------><------- Byte 2 -------><------- Byte 3 -------><------- Byte 4 ------->
    +----------------------------------------------+-----------------------------------------------+             ^
    |                  Source Port                 |                Destination Port               |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             |
    |                                        Sequence Number                                       |  (4 bytes)  |
    |                                          (32 bits)                                           |             |
    +----------------------------------------------------------------------------------------------+             |
    |                                    Acknowledgement Number                                    |  (4 bytes)  |
    |                                          (32 bits)                                           |             |  20 bytes
    +-----------+----------------+-----------------+-----------------------------------------------+             |
    |Header Len.|    Reserved    |   Control Bits  |                  Window Size                  |  (4 bytes)  |
    |  (4 bits) |    (6 bits)    |     (6 bits)    |                   (16 bits)                   |             |
    +-----------+----------------+-----------------+-----------------------------------------------+             |
    |                   Checksum                   |                     Urgent                    |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             v
    |                                           Options                                            |
    |                                        (0 or 32 bits)                                        |
    +----------------------------------------------------------------------------------------------+
    |                                    Application Layer Data                                    |
    |                                         (Size Varies)                                        |
    +----------------------------------------------------------------------------------------------+

    Burada her satır 32 bit yani 4 byte yer kaplamaktadır. TCP başlığı 20 byte'tan 60 byte'a kadar değişen uzunlukta olabilir. 
    Başlıktaki Header Length TCP data'sının hangi offset'ten başladığını dolayısıyla TCP başlığının DWORD (4 byte olarak) uzunluğunu 
    belirtir. Yani başlığın byte uzunluğu için buradaki değer 4 ile çarpılmalıdır. Böylece Header Length kısmında en az 5 
    (toplam 20 byte) en fazla 15 (toplam 60 byte) değeri bulunabilir. Bu başlıkta kaynak ve hedef IP adreslerinin ve TCP data 
    kısmının uzunluğunun bulunmadığına dikkat ediniz. Çünkü bu bilgiler zaten IP başlığında doğrudan ya da dolaylı biçimde 
    bulunmaktadır. TCP paketi her zaman IP paketinin data kısmında konuşlandırılmaktadır.

    Başlıktaki Control Bits alanı 6 bitten oluşmaktadır. Her bit bir özelliği temsil eder. Buradaki belli bitler set edildiğinde 
    başlıktaki belli alanlar da anlamlı hale gelebilmektedir. Buradaki bitler yani flag'ler şunlardır: URG, ACK, PSH, RST, 
    SYN, FIN. Flags alanındaki birden fazla bit 1 olabilir. Yani birden fazla flag set edilmiş olabilir. Bir TCP paketi 
    (TCP segment) yalnızca başlık içerebilir. Yani hiç data içermeyebilir. Başka bir deyişle TCP paketinin data kısmı 0 byte 
    uzunluğunda olabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                117. Ders 04/02/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP protokolünde o anda iki tarafın da bulunduğu bir "durum (state)" vardır. Taraflar belli eylemler sonucunda durumdan
    duruma geçiş yaparlar. Bu nedenle TCP'nin çalışması bir "sonlu durum makinesi (finite state machine)" biçiminde ele alınıp 
    açıklanabilir. Henüz bağlantı yoksa iki taraf da CLOSED denilen durumdadır. TCP'de tarafların hangi olaylar sonucunda
    hangi durumda olduklarına ilişkin diyagrama "durum diyagramı (state diagram)" denilmektedir. (TCP durum diyagramı için 
    Google'da "TCP state diagram" araması ile görsellerden çizilmiş diyagramları görebilirsiniz.)

    TCP bağlantısının kurulması için client ile server data kısmı boş olan (yani yalnızca başlık kısmı bulunan) paketleri gönderip 
    almaktadır. Buna el sıkışma (hand shaking) denilmektedir. TCP'de bağlantı kurulması için yapılan el sıkışma 4'lü (four way) 
    ya da 3'lü (three way) olabilir. Burada 3'lü demekle bağlantı için toplam 3 paketin yolculuk etmesi, 4'lü demekle toplam 4 
    paketin yolculuk etmesi kastedilmektedir. Uygulamada daha çok 3'lü el sıkışma kullanılmaktadır.

    TCP'de bağlantının kurulabilmesi için "iki tarafın da birbirlerine SYN biti set edilmiş data kısmı olmayan TCP paketi 
    (20 byte) gönderip karşı taraftan ACK biti set edilmiş data'sı olmayan TCP paketi alması" gerekir. Yukarıda da belirttiğimiz
    gibi bunun iki yolu olabilir:

          Client                                 Server

    +-----------------+                    +-----------------+
    |      CLOSED     |                    |      LISTEN     |
    +-----------------+                    +-----------------+
                        ------- SYN ----->
    +-----------------+
    |     SYN-SENT    |
    +-----------------+
                        <------ ACK ------
                        <------ SYN ------
    +-----------------+                    +-----------------+
    |   ESTABLISHED   |                    |   SYN-RECEIVED  |
    +-----------------+                    +-----------------+
                        ------- ACK ----->
                                           +-----------------+
                                           |   ESTABLISHED   |
                                           +-----------------+

    Burada 4 paket kullanıldığı için buna 4'lü el sıkışma denilmektedir. Yukarıdaki bağlantı kurulurken iki tarafın TCP 
    durumunu (state) da belirttik. Server bağlantı sırasında ACK ile SYN bitini tek bir paket olarak da gönderilebilir. 
    (Yani paketin Flags kısmında hem SYN hem de ACK biti set edilmiş olabilir.) Buna 3'lü el sıkışma denilmektedir:

          Client                                 Server

    +-----------------+                    +-----------------+
    |      CLOSED     |                    |      LISTEN     |
    +-----------------+                    +-----------------+
                        ------- SYN ----->
    +-----------------+
    |     SYN-SENT    |
    +-----------------+
                        <--- SYN + ACK ---
                                           +-----------------+
                                           |   SYN-RECEIVED  |
                                           +-----------------+
                        ------- ACK ----->
    +-----------------+                    +-----------------+
    |   ESTABLISHED   |                    |   ESTABLISHED   |
    +-----------------+                    +-----------------+

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bağlantının kopartılması için iki tarafın da birbirlerine FIN biti set edilmiş paketler gönderip ACK biti set edilmiş 
    paketleri alması gerekir. Bağlantının kopartılması da tipik olarak 3'lü ya da 4'lü el sıkışma yoluyla yapılmaktadır. 
    FIN ve ACK paketleri ayrı ayrı gönderilirse 4'lü el sıkışma tek bir paket olarak gönderilirse 3'lü el sıkışma gerçekleşir. 
    Bağlantının kopartılması talebini herhangi bir taraf başlatabilir. 4'lü el sıkışma ile bağlantının kopartılması şöyle
    yapılmaktadır:

          Peer - 1                               Peer - 2

    +-----------------+                    +-----------------+
    |   ESTABLISHED   |                    |   ESTABLISHED   |
    +-----------------+                    +-----------------+
                        ------- FIN ----->
    +-----------------+                    +-----------------+
    |    FIN-WAIT-1   |                    |    CLOSE_WAIT   |
    +-----------------+                    +-----------------+
                        <------ ACK ------
    +-----------------+
    |    FIN-WAIT-2   |
    +-----------------+
                        <------ FIN ------
                                           +-----------------+
                                           |     LAST-ACK    |
                                           +-----------------+
                        ------- ACK ----->
    +-----------------+                    +-----------------+
    |    TIME-WAIT    |                    |      CLOSED     |
    +-----------------+                    +-----------------+
    +-----------------+
    |      CLOSED     |
    +-----------------+

    Burada iki taraf da birbirlerine FIN biti set edilmiş data kısmı olmayan TCP paketleri gönderip ACK biti set edilmiş data 
    kısmı olmayan TCP paketleri almıştır. 3'lü el sıkışma ile bağlantının kopartılmasında bir taraf tek bir pakette hem FIN biti 
    set edilmiş hem de ACK biti set edilmiş paket göndermektedir:

          Peer - 1                               Peer - 2

    +-----------------+                    +-----------------+
    |   ESTABLISHED   |                    |   ESTABLISHED   |
    +-----------------+                    +-----------------+
                        ------- FIN ----->
    +-----------------+                    +-----------------+
    |    FIN-WAIT-1   |                    |    CLOSE_WAIT   |
    +-----------------+                    +-----------------+
                        <--- FIN + ACK ---
    +-----------------+                    +-----------------+
    |    FIN-WAIT-2   |                    |     LAST-ACK    |
    +-----------------+                    +-----------------+
                        ------- ACK ----->
    +-----------------+                    +-----------------+
    |    TIME-WAIT    |                    |      CLOSED     |
    +-----------------+                    +-----------------+
    +-----------------+
    |      CLOSED     |
    +-----------------+

    Burada özetle bir taraf önce karşı tarafa FIN paketi yollamıştır. Karşı taraf buna ACK+FIN ile karşılık vermiştir. Diğer taraf 
    da son olarak karşı tarafa ACK yollamıştır. Ancak bağlantıyı kopartmak isteyen taraf bu ACK yollama işinden sonra MSL (Maximum Segment Life) 
    denilen bir zaman aralığının iki katı kadar beklemektedir (Tipik olarak 2 dakika). MSL bir paketin kaybolduğuna karar verilmesi 
    için gereken zamanı belirtmektedir. (Eğer alıcı taraf beklemeden hemen CLOSED duruma geçseydi bu durumda gönderici taraf yeniden 
    bağlantı kurduğunda henüz alıcı taraf paketi almamışsa sanki eski bağlantı devam ettiriliyormuş gibi bir durum olabilirdi.)

    Soket programlamada bağlantı shutdown ile SHUT_RD kullanılarak kopartıldığında yukarıdaki 3'lü el sıkışma gerçekleşmektedir.

    Bağlantının koparılması "yarım biçimde de (half close") yapılabilir. Bu durumda bir taraf diğer tarafa FIN paketi gönderir. 
    Karşı taraf da buna ACK paketi ile karşılık verir. Bundan sonra artık FIN gönderen taraf veri gönderemez ama alabilir, 
    ACK gönderen taraf ise veri alamaz ama gönderebilir:

          Peer - 1                               Peer - 2

    +-----------------+                    +-----------------+
    |   ESTABLISHED   |                    |   ESTABLISHED   |
    +-----------------+                    +-----------------+
                        ------- FIN ----->
    +-----------------+                    +-----------------+
    |    FIN-WAIT-1   |                    |    CLOSE_WAIT   |
    +-----------------+                    +-----------------+
                        <------ ACK ------
                                           +-----------------+
                                           |     CLOSING     |
                                           +-----------------+
                                           +-----------------+
                                           |    TIME_WAIT    |
                                           +-----------------+

    Bunun tersi de şöyle söz konusu olabilir:

          Peer - 1                               Peer - 2

                        <------ FIN ------
    +-----------------+                    +-----------------+
    |    CLOSE_WAIT   |                    |    FIN-WAIT-1   |
    +-----------------+                    +-----------------+
                        ------- ACK ----->
    +-----------------+
    |     CLOSING     |
    +-----------------+
    +-----------------+
    |     TIME_WAIT   |
    +-----------------+

    Burada da artık Peer-2 veri gönderemez ama alabilir, Peer-1 ise veri veri alamaz fakat gönderebilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                118. Ders 09/02/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi shutdown fonksiyonunun "half close" işlemindeki etkisi nasıldır? Aslında shutdown fonksiyonunun ikinci parametresinde
    belirtilen SHUT_WR, SHUT_RD ve SHUT_RDWR değerlerinin protokoldeki bağlantının kopartılması süreciyle bir ilgisi yoktur. 
    shutdown fonksiyonu her durumda "half close" uygulamaktadır. Yani shutdown fonksiyonunun ikinci parametresi ne olursa olsun
    bu fonksiyonu çağıran taraf karşı tarafa FIN paketi yollar, karşı taraf da bu tarafa ACK paketi yollar. Zaten protokolün 
    kendisinde "half close" işlemi SHUT_WR, SHUT_RD ya da SHUT_RDWR biçiminde bir bilgi taşımamaktadır. TCP protokolü tasarlandığında 
    "half close" işleminin "bir tarafı göndermeye kapatıp diğer tarafı almaya kapatmak" gibi bir işlev göreceği düşünülmüştür.
    Ancak bu "half close" işleminin işletim sistemleri tarafından tam olarak nasıl ele alınacağı TCP/IP soket gerçekleştirimini 
    yapanlar tarafından belirlenmektedir.

    Şimdi Linux sistemlerinde shutdown fonksiyonunun muhtemel gerçekleştirimi ve arka planda gerçekleşen muhtemel işlemler konusunda 
    bilgi verelim. Örneğin bir taraf shutdown fonksiyonunu SHUT_WR parametresiyle aşağıdaki gibi çağırmış olsun. Ancak karşı taraf 
    shutdown fonksiyonunu çağırmamış olsun:

    shutdown(sock, SHUT_WR);

    Burada SHUT_WR uygulayan taraf diğer tarafa FIN paketi gönderir, diğer taraf da buna ACK ile yanıt verir ve "half close" işlemi 
    gerçekleşir. Artık SHUT_WR uygulayan taraf bundan sonra diğer tarafa veri göndermemeli diğer taraf da karşı taraftan veri almamalıdır. 
    Bir taraf SHUT_WR ile "half close" uyguladığında karşı taraf recv işlemi yaparsa sanki soket kapatılmış gibi recv fonksiyonu 
    0 ile geri dönecektir. SHUT_WR yapan taraf send fonksiyonunu kullandığında ise SIGPIPE sinyali oluşacaktır.

    Şimdi de bir taraf shutdown fonksiyonunu SHUT_RD ile çağırmış olsun.

    shutdown(sock, SHUT_RD);

    Bu durumda yine SHUT_RD uygulayan taraf karşı tarafa FIN paketi gönderir ve karşı taraftan ACK paketi alır. Böylece "half close" 
    işlemi gerçekleşir. Artık SHUT_RD uygulayan taraf veri almayacak fakat veri gönderebilecektir. Karşı taraf ise veri alabilecek 
    ancak veri gönderemeyecektir. Tabii aslında karşı taraf shutdown fonksiyonunun aslında hangi parametreyle çağrıldığını bilmemektedir. 
    Dolayısıyla aslında soket fonksiyonlarıyla veri göndermeye devam edebilecektir. Karşı taraf eğer send işlemi yaparsa 
    burada işletim sistemi değişik davranışlar gösterebilmektedir. Karşı tarafın gönderdiği paketler karşı tarafa ulaştığında SHUT_RD 
    yapan taraftaki işletim sistemi bu paketleri hiç dikkate almayabilir. Böylece SHUT_RD yapan taraf recv fonksiyonunu çağırsa 
    bile recv 0 ile geri döner. Ya da işletim sistemi böylesi bir durumda karşı taraf veri gönderdiğinde ona RST bayrağı set edilmiş 
    paket gönderip (buna "connection reset" denilmektedir) karşı tarafın artık send işlemlerinde SIGPIPE sinyali üretmesini sağlayabilir.

    Şimdi de shutdown fonksiyonunun SHUT_RDWR parametresi ile çağrıldığını düşünelim. Bu en çok kullanılan parametredir. Bu durumda yine 
    fonksiyonu çağıran taraf karşı tarafa FIN paketi gönderir, karşı taraftan ACK paketi alır. Yine "half close" işlemi gerçekleşir. 
    Ancak artık SHUT_RDWR uygulayan taraf recv ve send işlemlerini yapamayacaktır. SHUT_RDWR uygulayan taraf recv fonksiyonunu çağırırsa 
    fonksiyon 0 ile geri dönecek, send fonksiyonunu çağırırsa doğrudan SIGPIPE sinyali oluşacaktır. Bu durumda SHUT_RDWR uygulayan 
    tarafın karşı tarafı, artık send işlemi yaparsa yine davranış yukarıda SHUT_RD fonksiyonunda belirtildiği gibi gerçekleşecektir.

    Tabii normal olarak iki tarafın da aslında ayrı ayrı shutdown fonksiyonunu çağırması gerekir. Bu durumda 4'lü el sıkışma
    gerçekleşecektir. TCP/IP soket programlamada önce bir taraf shutdown uygulayıp "half close" oluşturabilir. Diğer taraf da bunu
    anlayıp o da shutdown uygulayarak 4'lü el sıkışma oluşturabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP'de akış kontrolü için "acknowledgement" yani "alındı" bildirimi kullanılmaktadır. Bir taraf bir tarafa bir paket veri 
    gönderirken verinin yanı sıra aynı zamanda paketin Flags kısmındaki PSH bitini 1 yapar. Karşı taraf da paketi aldığını diğer 
    tarafa haber vermek için diğer tarafa ACK biti set edilmiş bir paket gönderir. TCP'de her gönderilen paket için bir "alındı" 
    bilgisinin alınması gerekir. Eğer paketi gönderen taraf bu paketi içeren bir ACK paketi alamazsa bu durumda "paketin karşı 
    tarafa ulaşmadığından" şüphelenmektedir. Bu durumda paketi gönderen taraf belli bir algoritma ile zaman aralıklarıyla aynı paketi yeniden 
    göndermektedir. Böylesi bir durumda paketi alan taraf aynı paketi birden fazla kez de alabilir. Bunun yalnızca tek bir kopyasını 
    işleme sokmak alan tarafın sorumluluğundadır. Tabii gönderen tarafın paketi yolda kaybolabileceği gibi alan tarafın ACK paketi de
    yolda kaybolabilir. Bu durumda yine gönderen taraf ACK alamadığına göre göndermeye devam edecektir. Bu durumda alıcı taraf bunun 
    için yine ACK gönderecektir.

    Yukarıda da belirttiğimiz gibi paketin "data" kısmı dolu olmak zorunda değildir. Bağlantı sağlanırken ve sonlandırırken gönderilen 
    SYN ve FIN paketleri "data" içermemektedir. ACK paketi ayrı bir paket olarak gönderilmek zorunda değildir. Bilgiyi alan 
    taraf hem bilgi gönderirken hem de ACK işlemi yapabilir. Örneğin:

    +---------+
    |   PSH   |
    +---------+
                --- data --->
                               +---------------+
                               |   PSH + ACK   |
                               +---------------+
                <--- data ---
    +---------+
    |   ACK   |
    +---------+
                ------------>

    Aslında izleyen paragraflarda da ele alınacağı gibi ACK biti yalnızca "alındığını bildirme için değil" pencere genişliklerinin 
    ayarlanması için de kullanılmaktadır. Yani bir taraf karşı taraftan bilgi almadığı halde yine ACK gönderebilir.

    TCP'de kümülatif bir "acknowledgement" sistemi kullanılmaktadır. Yani paketi gönderen taraf bu paket için ACK almadan başka paketleri 
    gönderebilir. Paketleri alan taraf birden fazla paket için tek bir ACK yollayabilir. Kümülatif ACK işlemi için "sıra numarası 
    (sequence number)" denilen bir değerden faydalanılmaktadır. Sıra numarası (sequence number) gönderilen paketin bütün içerisindeki 
    kaçıncı byte'tan başladığını belirten bir değerdir. Bunu dosyalardaki dosya göstericisine benzetebiliriz. Sıra numarası TCP 
    başlığında 32 bitlik bir alanda tutulmaktadır. Sıra numarası 32 bitlik değerin sonuna geldiğinde yeniden başa dönmektedir (wrapping).
    Sıra numarası bağlantı kurulduğunda sıfırdan başlatılmaz, rastgele bir değerden başlatılmaktadır. Örneğin belli bir anda bir tarafın 
    sıra numarası 1552 olsun. Şimdi bu taraf karşı tarafa 300 byte göndersin. Artık bu gönderimden sonra sıra numarası 1852 olacaktır. 
    Yani bir sonraki gönderimde bu taraf sıra numarası olarak 1852'yi kullanacaktır. Sıra numarası her bilgi gönderiminde bulundurulmak 
    zorundadır. Bilgiyi alan taraf ACK paketini gönderirken paketteki sıra numarasını "talep ettiği sonraki sıra numarası" olarak paketin 
    sıra numarasını belirten kısmına yerleştirir. Örneğin:

    Peer-1                                        Peer-2

    300 byte (sequence Number: 3560) ----->
    100 byte (sequence Number: 3860) ----->
                                                  <---- ACK (Acknowledgement Number: 3960)
    50 byte  (sequence Number: 3960) ------>
                                                  <---- ACK (Acknowledgement Number: 4010)
    10 byte  (sequence Number: 4010) ------>

    Buradaki örnek gönderimde gönderen taraf önce 300 byte'lık bir paketi sonra 100 byte'lık bir paketi karşı tarafa göndermiştir. Karşı taraf 
    ise bu iki paket için tek bir ACK göndermiştir. Karşı tarafın gönderdiği ACK aslında diğer taraftan yeni talep edeceği sıra numarasındaki 
    bilgiyi belirtmektedir. İki paketi gönderen taraf karşı taraftan gelen ACK içerisindeki bu sıra numarasına baktığında bu iki paketinde 
    alındığını anlamaktadır. Görüldüğü gibi her paket için ayrı bir ACK yollanmak zorunda değildir. Buna "kümülatif alındı (cumulative 
    acknowledgment)" bildirimi denilmektedir. Örneğin bir tarafın karşı tarafa peş peşe 5 paket gönderdiğini düşünelim. Karşı taraftan 
    bir ACK gelmiş olsun. Gönderen taraf bu ACK paketine bakarak gönderdiği bilginin ne kadarının karşı taraf tarafından alındığını 
    anlayabilmektedir.

    Pekiyi bir TCP paketi (TCP segment) gönderici (sender) tarafından gönderildikten sonra alıcı (receiver) bunu alamamışsa ne olacaktır? 
    Çünkü TCP'nin güvenli bir protokol olması demek bir biçimde böyle bir durumda bir telafinin yapılması demektir. İşte yukarıda da 
    belirttiğimiz gibi TCP protokolü şöyle yöntem izlemektedir: Gönderen taraf her gönderdiği paket (TCP segment) için bir zamanlayıcı 
    kurar. Bu zamanlayıcıya "retransmission timer" denilmektedir. Eğer belli süre içerisinde gönderilen TCP paketini kapsayan bir
    ACK gelmediyse gönderici taraf aynı paketi yeniden göndermektedir. Böylece aslında gönderilen paket henüz onun için ACK gelmedikçe 
    gönderme tamponundan atılmaz. Retransmission timer bazı değerlere göre dinamik bir biçimde oluşturulmaktadır. Bunun detayları için 
    önerilen kaynaklara bakılabilir. Tabii böyle bir sistemde alıcı taraf aynı paketi birden fazla kez alabilmektedir. Yukarıda da belirttiğimiz 
    gibi bu durumda bu paketlerin yalnızca tek bir kopyasını alıp diğerlerini atmak alıcı tarafın sorumluluğundadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                119. Ders 11/02/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP protokolünün bir "akış kontrolü (flow control)" oluşturduğunu belirtmiştik. Akış kontrolünün amacı tampon taşmasının 
    engellenmesidir. Bağlantı sağlandıktan sonra bir tarafın diğer tarafa sürekli bilgi gönderdiğini düşünelim. Bu bilgileri 
    işletim sistemi alacak ve bekletecektir. Pekiyi ya ilgili proses soketten okuma yapmazsa? Bu durumda hala karşı taraf bilgi 
    gönderirse işletim sisteminin ayırdığı tampon taşabilir.

    Tipik olarak işletim sistemleri bağlantı yapılmış her soket için iki tampon bulundurmaktadır: Gönderme tamponu (send buffer) ve
    alma tamponu (receive buffer). Biz send fonksiyonunu kullandığımızda göndermek istediğimiz bilgiler gönderme tamponuna 
    yazılır ve hemen send fonksiyonu geri döner. Gönderme tamponundaki bilgilerin paketlenerek gönderilmesi belli bir zaman sonra
    işletim sistemi tarafından yapılmaktadır. Eğer send işlemi sırasında zaten gönderme tamponu doluysa send fonksiyonu gönderilecek 
    olanları tamamen tampona yazana kadar blokede beklemektedir. Alma tamponu (receive buffer) karşı tarafın gönderdiği bilgilerin 
    alınması için kullanılan tampondur. Karşı tarafın gönderdiği bilgiler alındığında işletim sistemi bu bilgileri alma tamponuna 
    yerleştirir. Aslında recv fonksiyonu bu tampondan bilgileri almaktadır.

    send ---> [gönderme tamponu] ---> işletim sistemi gönderiyor ---> ||||| <--- işletim sistemi alıyor ---> [alma tamponu] <--- recv

    Akış kontrolünün en önemli unsurlarından biri alma tamponunun taşmasını engellemektir. Örneğin gönderici taraf sürekli bilgi gönderirse 
    fakat alıcı taraftaki proses recv işlemiyle hiç okuma yapmazsa alıcı taraftaki işletim sisteminin alıcı tamponu dolabilir ve 
    sistem çökebilir. İşte akış kontrolü sayesinde alıcı taraf gönderici tarafa "artık gönderme, benim tamponum doldu" diyebilmektedir. 
    Şimdi bir taraftaki prosesin diğer tarafa bir döngü içerisinde send fonksiyonuyla bilgi gönderdiğini ancak diğer taraftaki prosesin
    bu bilgiyi almadığını varsayalım. Akış kontrolünün uygulandığı durumda ne olacaktır? İşte önce send ile gönderilenler karşı tarafa 
    iletilecektir. Karşı tamponu dolduğunda karşı taraf gönderen tarafa "artık gönderme" diyecektir. Bu durumda göndermeyi 
    kesen taraftaki proses hala send işlemi yapacağına göre o tarafın gönderme tamponu dolacak ve send fonksiyonu blokeye 
    yol açacaktır. Linux sistemlerinde tek bir send ile gönderme tamponundan daha büyük bir bilgiyi göndermek istediğimizde 
    tüm bilgi yine tampona yerleştirilene kadar bloke oluşmaktadır.

    Aşağıdaki örnekte client program bağlantı kurduktan sonra bir döngü içerisinde server programa send fonksiyonu ile bilgi
    göndermektedir. Ancak server program bu bilgiyi recv ile okumamaktadır. Yukarıda da belirttiğimiz gibi bu durumda server 
    programın tamponu dolacak ve server program karşı tarafa "artık gönderme" diyecek. Bu kez de karşı tarafın gönderme tamponu 
    dolacak dolayısıyla send fonksiyonu da bir süre sonra blokede bekleyecektir. Bu programları farklı terminallerden aşağıdaki 
    gibi çalıştırabilirsiniz:

    $ ./server 55555
    $ ./client localhost 55555
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock_server, sock_client;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    char ntopbuf[INET_ADDRSTRLEN];
    in_port_t port;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((sock_server = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock_server, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    if (listen(sock_server, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");

    sinaddr_len = sizeof(sinaddr_client);
    if ((sock_client = accept(sock_server, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
        exit_sys("accept");

    printf("Connected: %s : %u\n", inet_ntop(AF_INET, &sinaddr_client, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sinaddr_client.sin_port));

    printf("Press any key to EXIT...\n");
    getchar();

    shutdown(sock_client, SHUT_WR);
    close(sock_client);
    close(sock_server);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct addrinfo *ai, *ri;
    struct addrinfo hints = {0};
    char buf[BUFFER_SIZE] = {0};
    int result;
    ssize_t sresult;
    ssize_t stotal;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    if ((result = getaddrinfo(argv[1], argv[2], &hints, &ai)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(result));
        exit(EXIT_FAILURE);
    }

    for (ri = ai; ri != NULL; ri = ri->ai_next)
        if (connect(sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(ai);

    printf("Connected...\n");

    stotal = 0;
    for (;;) {
        printf("send calls...\n");
        if ((sresult = send(sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("send");
        stotal += sresult;
        printf("bytes sent: %jd, total bytes sent: %jd\n", sresult, stotal);
    }

    close(sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda basit olarak açıkladığımız akış kontrolünün TCP'de bazı detayları vardır.

    TCP'de bunun için "pencere (window)" kavramı kullanılmaktadır. Pencerenin bir büyüklüğü (window size) vardır. Pencere büyüklüğü
    TCP başlığında belirtilmektedir. Pencere büyüklüğü demek "hiç ACK gelmediği durumda göndericinin en fazla gönderebileceği 
    byte sayısı" demektir. Örneğin pencere genişliğinin 8K olması demek "alıcı ACK göndermedikten sonra göndericinin en fazla 
    8K gönderebilmesi" demektir. Pencere genişliği alıcı taraf tarafından gönderici tarafa bildirilir. Örneğin pencere genişliği
    alıcı taraf için 8K olsun. Bu durumda gönderici taraf sırasıyla 1K + 1K + 1K + 1K + 1K uzunluğunda toplam 5K'lık bilgiyi 
    karşı tarafa göndermiş olsun. Eğer henüz ACK gelmemişse gönderici taraf en fazla 3K kadar daha bilgi gönderebilir.

    TCP'de her ACK sırasında yeni pencere genişliği de karşı tarafa gönderilmek zorundadır. Yani ACK paketi gönderilirken aynı 
    zamanda yeni pencere genişliği de gönderilmektedir. ACK paketi yalnızca alındı bilgisini göndermek için değil pencere genişliğini
    ayarlamak için de gönderilebilmektedir. Başka bir deyişle bir taraf "yalnızca bilgi aldığı için" ACK göndermek zorunda değildir. 
    Hiç bilgi almadığı halde yeni pencere genişliğini karşı tarafa bildirmek için de ACK gönderebilir. Pencere genişliği en fazla 
    64K olabilir. Çünkü bunun için TCP başlığında 16 bit yer ayrılmıştır.

    Şimdi bir tarafın diğer tarafa send fonksiyonu ile sürekli bilgi gönderdiğini ancak diğer tarafın bilgiyi recv ile okumadığını 
    düşünelim. İşletim sisteminin alıcı taraf için oluşturduğu alma tamponunun 1 MB olduğunu düşünelim. Alıcı taraf muhtemelen bilgi
    geldikçe ACK yaparken 64K'lık pencere genişliğini karşı tarafa bildirecektir. Ancak zamanla alma tamponu dolduğu için bu pencere 
    genişliğini düşürecek en sonunda ACK ile pencere genişliğini 0 yapacak ve karşı tarafa "artık gönderme" diyecektir. Pencere 
    genişliği ile alma tamponunun genişliği birbirine karıştırılmamalıdır. Alma tamponu gelen bilgilerin yerleştirildiği tampondur. 
    Pencere genişliği karşı tarafın ACK almadıktan sonra gönderebileceği maksimum byte sayısıdır.

    Pekiyi pencere genişlikleri ve sıra numaraları bağlantı sırasında nasıl karşı tarafa bildirilmektedir? İşte bağlantı kurulurken 
    client taraf SYN paketi içerisinde kendi başlangıç sıra numarasını karşı tarafa iletmektedir. Server da bağlantıyı kabul ederken 
    yine SYN (ya da SYN + ACK) paketinde kendi sıra numarasını karşı tarafa bildirmektedir. Pencere genişliği de aslında ilk kez 
    bağlantı yapılırken ACK paketlerinde belirtilmektedir.

    TCP/IP stack gerçekleştirimleri ACK stratejisi için bazı yöntemler uygulamaktadır. Örneğin eğer gönderilecek paket varsa 
    bununla birlikte ACK paketinin gönderilmesi, ACK'ların iki paket biriktirildikten sonra gönderilmesi gibi. Benzer biçimde 
    pencere genişliklerinin ayarlanması için de bazı stratejiler izlenebilmektedir. Bunun için "TCP/IP Protocol Suite" kitabının 
    466'ıncı sayfasına başvurabilirsiniz.

    TCP paketindeki önemli Flag'lerden birisi de "RST" bitidir. Buna "reset isteği" denilmektedir. Bir taraf RST bayrağı set 
    edilmiş paket alırsa artık karşı tarafın "abnormal" bir biçimde bağlantıyı kopartıp yeniden bağlanma talep ettiği anlaşılır. 
    Normal sonlanma el sıkışarak başarılı bir biçimde yapılırken RST işlemi anormal sonlanmaları temsil eder. Örneğin soket 
    kütüphanelerinde hiç shutdown yapmadan soket close edilirse close eden taraf karşı tarafa RST paketi göndermektedir. 
    Halbuki önce shutdown yapılırsa el sıkışmalı sonlanma gerçekleştirilir. O halde her zaman aktif soketler shutdown yapıldıktan 
    sonra close edilmelidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                120. Ders 16/02/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UDP protokolü aslında saf IP protokolüne çok benzerdir. UDP'yi IP'den ayıran iki önemli farklılık şudur:

    1) UDP port numarası kavramına sahiptir.
    2) UDP'nin hata için bir checksum mekanizması vardır. Yani bir taraf diğer tarafa UDP paketi gönderirken gönderdiği veri için
    checksum bilgisini de UDP başlık kısmına iliştirmektedir.

    Bir UDP paketi yine aslında IP paketinin data kısmında bulunmaktadır. UDP header'ı 8 byte'tan oluşmaktadır ve yapısı aşağıdaki gibidir.

    <------- Byte 1 -------><------- Byte 2 -------><------- Byte 3 -------><------- Byte 4 ------->
    +----------------------------------------------+-----------------------------------------------+             ^
    |                  Source Port                 |                Destination Port               |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             |  8 bytes
    |                    Length                    |                   Checksum                    |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             v
    |                                    Application Layer Data                                    |
    |                                         (Size Varies)                                        |
    +----------------------------------------------------------------------------------------------+

    Burada UDP paketinin toplam uzunluğunun bulunması aslında gereksizdir. Çünkü uzunluk TCP'de olduğu gibi aslında IP paketinin 
    başlığına bakılarak tespit edilebilmektedir. Ancak hesaplama kolaylığı oluşturmak için bu uzunluk UDP başlığında ayrıca 
    bulundurulmuştur. Ayrıca checksum UDP paketlerinde bulunmak zorunda değildir. Eğer gönderici checksum kontrolü istemiyorsa 
    burayı 0 bitleriyle doldurur. (Eğer zaten checksum 0 ise burayı 1 bitleriyle doldurmaktadır.) Alan taraf checksum hatasıyla 
    karşılaşırsa TCP'de olduğu gibi paketi yeniden talep etmez. Yalnızca onu atar.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bazen TCP ve UDP yerine doğrudan IP protokolünü kullanmak isteyebiliriz. Buna soket programlamada "raw socket" denilmektedir. 
    Diğer protokol ailelerinde de "raw socket" ağ katmanı protokolünü belirtmektedir. Biz kursumuzda "raw socket" işlemleri üzerinde
    durmayacağız. Ancak daha aşağı seviyeli çalışmalar için ya da örneğin aktarım katmanını gerçekleştirmek (implemente etmek)
    için "raw socket" kullanımını bilmek gerekir.

    Genel bir "raw soket" oluşturmak için soket nesnesi yaratılırken protokol ailesi için AF_PACKET girilir. Soket türü için de 
    SOCK_RAW girilmelidir. IP protokolü için protokol ailesi yine AF_INET ya da AF_INET6 girilip soket türü SOCK_RAW olarak 
    girilebilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bu bölümde UNIX/Linux sistemlerinde kullanılan kütüphane dosyaları ve onların ayrıntıları üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kütüphane "hazır kodların bulunduğu topluluklar" için kullanılan bir terimdir. Ancak aşağı seviyeli dünyada kütüphane 
    kavramı daha farklı bir biçimde kullanılmaktadır. Aşağı seviyeli dünyada "içerisinde derlenmiş bir biçimde fonksiyonların 
    bulunduğu dosyalara kütüphane (library)" denilmektedir. Aslında kütüphaneler yalnızca fonksiyon değil, global nesneler 
    de içerebilmektedir.

    Kütüphaneler "statik" ve "dinamik" olmak üzere ikiye ayrılmaktadır. Statik kütüphane dosyalarının uzantıları UNIX/Linux 
    sistemlerinde ".a (archive)" biçiminde, Windows sistemlerinde ".lib (library)" biçimindedir. Dinamik kütüphane dosyalarının 
    uzantıları ise UNIX/Linux sistemlerinde ".so (shared object), Windows sistemlerinde ".dll (dynamic link library)" biçimindedir. 
    UNIX/Linux dünyasında kütüphane dosyaları geleneksel olarak başında "lib" öneki olacak biçimde isimlendirilmektedir. 
    (Örneğin "x" isimli bir statik kütüphane dosyası UNIX/Linux sistemlerinde genellikle "libx.a" biçiminde, "x" isimli bir 
    dinamik kütüphane dosyası ise UNIX/Linux sistemlerinde genellikle "libx.so" biçiminde isimlendirilmektedir.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Statik kütüphaneler aslında "object modülleri (yani .o dosyalarını)" tutan birer kap gibidir. Yani statik kütüphaneler 
    object modüllerden oluşmaktadır. Statik kütüphanelere link aşamasında linker tarafından bakılır. Bir program statik 
    kütüphane dosyasından bir çağırma yaptıysa (ya da o kütüphaneden bir global değişkeni kullandıysa) linker o statik kütüphane 
    içerisinde ilgili fonksiyonun bulunduğu object modülü link aşamasında statik kütüphane dosyasından çekerek çalıştırılabilir 
    dosyaya yazar. (Yani statik kütüphaneden bir tek fonksiyon çağırsak bile aslında o fonksiyonun bulunduğu object modülün 
    tamamı çalıştırılabilen dosyaya yazılmaktadır.) Statik kütüphaneleri kullanan programlar artık o statik kütüphaneler olmadan 
    çalıştırılabilirler.

    Statik kütüphane kullanımının şu dezavantajları vardır:

    1) Kütüphaneyi kullanan farklı programlar aynı fonksiyonun (onun bulunduğu object modülün) bir kopyasını çalıştırılabilir 
    dosya içerisinde bulundururlar. Yani örneğin printf fonksiyonu statik kütüphanede ise her printf kullanan C programı aslında 
    printf fonksiyonunun bir kopyasını da barındırıyor durumda olur. Bu da programların diskte fazla yer kaplamasına yol açacaktır.

    2) Aynı statik kütüphaneyi kullanan programlar belleğe yüklenirken işletim sistemi aynı kütüphane kodlarınını yeniden fiziksel 
    belleğe yükleyecektir. İşletim sistemi bu kodların ortak olarak kullanıldığını anlayamamaktadır.

    3) Statik kütüphanede bir değişiklik yapıldığında onu kullanan programların yeniden link edilmesi gerekir.

    Statik kütüphane kullanımının şu avantajları vardır:

    1) Kolay konuşlandırılabilirler. Statik kütüphane kullanan bir programın yüklenmesi için başka dosyalara gereksinim 
    duyulmamaktadır.

    2) Statik kütüphanelerin kullanımları kolaydır, statik kütüphane kullanan programlar için daha kolay build ya da make işlemi 
    yapılabilmektedir.

    3) Statik kütüphane kullanan programların yüklenmesi dinamik kütüphane kullanan programların yüklenmesinden çoğu kez daha hızlı
    yapılmaktadır. Ancak bu durum çeşitli koşullara göre tam ters bir hale de gelebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde statik kütüphane dosyaları üzerinde işlemler "ar" isimli utility program yoluyla yapılmaktadır. 
    "ar" programına önce bir seçenek, sonra statik kütüphane dosyasının ismi, sonra da bir ya da birden fazla object modül ismi 
    komut satırı argümanı olarak verilir. Örneğin:

    $ ar r libmyutil.a x.o y.o

    Burada "r" seçeneği belirtmektedir. ar eski bir komut olduğu için burada seçenekler '-' ile başlatılarak verilmeyebilir. 
    Ancak POSIX standartlarında seçenekler yine "-" ile belirtilmektedir. Komuttaki "libmyutil.a" işlemden etkilenecek statik 
    kütüphane dosyasını "x.o" ve "y.o" argümanları ise object modülleri belirtmektedir. Biz buradaki seçeneği "-" ile de 
    belirtebiliriz:

    $ ar -r libmyutil.a x.o y.o

    Tipik ar seçenekleri ve yaptıkları işler şunlardır:

    -r (replace) seçeneği ilgili object modüllerin kütüphaneye yerleştirilmesini sağlar. Eğer kütüphane dosyası yoksa komut aynı 
    zamanda onu yaratmaktadır. Örneğin:

    $ ar -r libmyutil.a x.o y.o

    Burada "libmyutil.a" statik kütüphane dosyasına "x.o" ve "y.o" object modülleri yerleştirilmiştir. Eğer "libmyutil.a" dosyası
    yoksa aynı zamanda bu dosya yaratılacaktır. Bu seçenekte eğer kütüphaneye yerleştirilmek istenen amaç dosya zaten kütüphane
    içerisinde varsa değiştirilmektedir ("replace" zaten buradan geliyor).

    -t seçeneği kütüphane içerisindeki object modüllerin listesini almakta kullanılır. Örneğin:

    $ ar -t libsample.a

    -d (delete) seçeneği kütüphaneden bir object modülü silmekte kullanılır. Örneğin:

    $ ar -d libmyutil.a x.o

    -x (extract) seçeneği kütüphane içerisindeki object modülü bir dosya biçiminde diske save etmekte kullanılır. Ancak bu object 
    modül kütüphane dosyasından silinmeyecektir. Örneğin:

    $ ar -x libmyutil.a x.o

    -m (modify) seçeneği de bir object modülün yeni versiyonunu eski versiyonla değiştirmekte kullanılır.

    O halde "x.c" ve "y.c" dosyalarının içerisindeki fonksiyonları statik kütüphane dosyasına eklemek için sırasıyla şunlar
    yapılmalıdır:

    $ gcc -c x.c
    $ gcc -c y.c
    $ ar r libmyutil.a x.o y.o
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Statik kütüphane kullanan programlar derlenirken statik kütüphane dosyaları komut satırında belirtilebilir. Bu durumda gcc 
    ve clang derleyicileri o dosyayı bağlama (link) işleminde kullanmaktadır. Örneğin:

    $ gcc -o app app.c libmyutil.a

    Burada "libmyutil.a" dosyasına C derleyicisi bakmamaktadır. gcc aslında bu dosyayı bağlayıcıya (linker) iletmektedir. Biz bu 
    işlemi iki adımda da yapabilirdik:

    $ gcc -c app.c
    $ gcc -o app app.o libmyutil.a

    Her ne kadar GNU'nun bağlayıcı programı aslında "ld" isimli programsa da genellikle programcılar bu ld bağlayıcısını doğrudan 
    değil yukarıdaki gibi gcc yoluyla kullanırlar. Çünkü ld bağlayıcısını kullanılırken "libc" kütüphanesinin start-up amaç dosyaların
    (start-up object modules) programcı tarafından ld bağlayıcısına verilmesi gerekmektedir. Bu da oldukça sıkıcı bir işlemdir. 
    Halbuki biz ld bağlayıcısını gcc yoluyla çalıştırdığımızda libc kütüphanesi ve bu start-up amaç dosyalar ld bağlayıcısına gcc 
    tarafından verilmektedir.

    gcc eskiden C derleyicisi anlamına geliyordu (GNU C Compiler). Ancak zamanla derleyicileri çalıştıran bir önyüz (front-end) 
    program haline getirildi ve ismi de "GNU Compiler Collection" biçiminde değiştirildi. Yani aslında uzunca bir süredir gcc 
    programı ile yalnızca C programlarını değil diğer programlama dillerinde yazılmış olan programları da derleyebilmekteyiz.

    Komut satırında kütüphane dosyalarının komut satırı argümanlarının sonunda belirtilmesi uygundur. Çünkü gcc programı kütüphane 
    dosyalarını yalnızca onların solunda belirtilen dosyaların bağlanmasında kullanmaktadır. Örneğin:

    $ gcc -o app app1.o libmyutil.a app2.o

    Böylesi bir kullanımda "libmyutil.a" kütüphanesinin solunda yalnızca "app1.o" dosyası vardır. Dolayısıyla bağlayıcı yalnızca 
    bu modül için bu kütüphaneye bakacaktır, "app2.o" için bu kütüphaneye bakılmayacaktır.

    Şüphesiz statik kütüphane kullanmak yerine aslında amaç dosyaları da doğrudan bağlama işlemine sokabiliriz. Örneğin:

    $ gcc -o sample sample.c x.o y.o

    Ancak çok sayıda object modül söz konusu olduğunda bu işlemin zorlaşacağına dikkat ediniz. Yani amaç dosyalar (object modules) 
    dosyalara benzetilirse statik kütüphane dosyaları dizinler gibi düşünülebilir.

    Derleme işlemi sırasında kütüphane dosyası -l<isim> biçiminde de belirtilebilir. Bu durumda arama sırasında "lib" öneki 
    ve ".a" uzantısı aramaya dahil edilmektedir. Yani örneğin:

    $ gcc -o sample sample.c -lmyutil

    İşleminde aslında "libmyutil.a" (ya da "libmyutil.so") dosyaları aranmaktadır. Arama işlemi sırasıyla bazı dizinlerde 
    yapılmaktadır. Örneğin "/lib" dizini, "/usr/lib dizini", "/usr/local/lib" dizini gibi dizinlere bakılmaktadır. Ancak 
    "bulunulan dizine (current working directory)" bakılmamaktadır. -l seçeneği ile belli bir dizine de bakılması isteniyorsa 
    "-L" seçeneği ile ilgili dizin belirtilebilir. Örneğin:

    $ gcc -o sample sample.c -lmyutil -L.

    Buradaki '.' çalışma dizinini temsil etmektedir. Artık "libmyutil.a" kütüphanesi için bulunulan dizine de (current working 
    directory) bakılacaktır. Birden fazla dizin için -L seçeneğinin yinelenmesi gerekmektedir. Örneğin:

    $ gcc -o sample sample.c -lmyutil -L. -L/home/csd

    Geleneksel olarak "-l" ve "-L" seçeneklerinden sonra boşluk bırakılmamaktadır. Ancak boşluk bırakılmasında bir sakınca 
    yoktur.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir statik kütüphane başka bir statik kütüphaneye bağımlı olabilir. Örneğin biz "liby.a" kütüphanesindeki kodda "libx.a" 
    kütüphanesindeki fonksiyonları kullanmış olabiliriz. Bu durumda "liby.a" kütüphanesini kullanan program "libx.a" kütüphanesini
    de komut satırında belirtmek zorundadır. Örneğin:

    $ gcc -o sample sample.c libx.a liby.a
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                121. Ders 18/02/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphane dosyalarının UNIX/Linux sistemlerinde uzantıları ".so" (shared object'ten kısaltma), Windows sistemlerinde 
    ise ".dll" (Dynamic Link Library) biçimindedir.

    Bir dinamik kütüphaneden bir fonksiyon çağrıldığında linker statik kütüphanede olduğu gibi gidip fonksiyonun kodunu (fonksiyonun 
    bulunduğu amaç dosyayı) çalıştırılabilen dosyaya yazmaz. Bunun yerine çalıştırılabilen dosyaya çağrılan fonksiyonun hangi 
    dinamik kütüphanede olduğu bilgisini yazar. Çalıştırılabilen dosyayı yükleyen işletim sistemi o dosyanın çalışması için 
    gerekli olan dinamik kütüphaneleri çalıştırılabilen dosyayla birlikte bütünsel olarak prosesin sanal bellek alanına yüklemektedir. 
    Böylece birtakım ayarlamalar yapıldıktan sonra artık çağrılan fonksiyon için gerçekten o anda sanal belleğe yüklü olan dinamik 
    kütüphane kodlarına gidilmektedir. Örneğin biz "app" programımızda "libmyutil.so" dinamik kütüphanesinden foo isimli fonksiyonu 
    çağırmış olalım. Bu foo fonksiyonunun kodları dinamik kütüphaneden alınıp "app" dosyasına yazılmayacaktır. Bu "app" dosyası 
    çalıştırıldığında işletim sistemi bu "app" dosyası ile birlikte "libmyutil.so" dosyasını da sanal belleğe yükleyecektir. 
    Programın akışı foo çağrısına geldiğinde akış "libmyutil.so" dosyası içerisindeki foo fonksiyonunun kodlarına aktarılacaktır. 
    Dinamik kütüphane dosyalarının bir kısmının değil hepsinin prosesin adres alanına yüklendiğine dikkat ediniz. (Tabii işletim 
    sisteminin sanal bellek mekanizması aslında yalnızca bazı sayfaları fiziksel belleğe yükleyebilecektir.)

    Dinamik kütüphane kullanımının avantajları şunlardır:

    1) Çalıştırılabilen dosyalar fonksiyon kodlarını içermezler. Dolayısıyla önemli bir disk alanı kazanılmış olur. Oysa statik 
    kütüphanelerde statik kütüphanelerden çağrılan fonksiyonlar çalıştırılabilen dosyalara yazılmaktadır.

    2) Dinamik kütüphaneler birden fazla proses tarafından fiziksel belleğe tekrar tekrar yüklenmeden kullanılabilmektedir.
    Yani işletim sistemi arka planda aslında aynı dinamik kütüphaneyi kullanan programlarda bu kütüphaneyi tekrar tekrar fiziksel 
    belleğe yüklememektedir. Bu da statik kütüphanelere göre önemli bir bellek kullanım avantaj oluşturmaktadır. Bu durumda eğer 
    dinamik kütüphanenin ilgili kısmı daha önce fiziksel belleğe yüklenmişse bu durum dinamik kütüphane kullanan programın daha 
    hızlı yüklemesine de yol açabilmektedir. Prog1 ve Prog2 biçiminde iki programın çalıştığını düşünelim. Bunlar aynı dinamik 
    kütüphaneyi kullanıyor olsun. İşletim sistemi bu dinamik kütüphaneyi bu proseslerin sanal bellek alanlarının farklı yerlerine 
    yükleyebilir. Ancak aslında işletim sistemi sayfa tablolarını kullanarak mümkün olduğunca bu iki dinamik kütüphaneyi aynı 
    fiziksel sayfaya eşlemeye çalışacaktır. Tabii bu durumda proseslerden biri dinamik kütüphane içerisindeki bir statik 
    nesneyi değiştirdiğinde artık "copy on write" mekanizması devreye girecek ve dinamik kütüphanenin o sayfasının yeni bir 
    kopyası oluşturulacaktır. Aslında bu durum fork fonksiyonu ile yeni bir prosesin yaratılması durumuna çok benzemektedir. 
    Burada anlatılan unsurların ayrıntıları "sayfalama ve sanal bellek" kullanımın açıklandığı paragraflarda ele alınmıştır.

    3) Dinamik kütüphaneleri kullanan programlar bu dinamik kütüphanelerdeki değişikliklerden etkilenmezler. Yani biz dinamik 
    kütüphanenin yeni bir versiyonunu oluşturduğumuzda bunu kullanan programları yeniden derlemek ya da bağlamak zorunda kalmayız. 
    Örneğin bir dinamik kütüphaneden foo fonksiyonunu çağırmış olalım. Bu foo fonksiyonunun kodları bizim çalıştırılabilir 
    dosyamızın içerisinde değil de dinamik kütüphanede olduğuna göre dinamik kütüphanedeki foo fonksiyonu değiştirildiğinde 
    bizim programımız artık değişmiş olan foo fonksiyonunu çağıracaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphanelerin gerçekleştiriminde ve kullanımında önemli bir sorun vardır. Dinamik kütüphanelerin tam olarak sanal 
    belleğin neresine yükleneceği baştan belli değildir. Halbuki çalıştırılabilen dosyanın sanal belleğin neresine yükleneceği 
    baştan bilinebilmektedir. Yani çalıştırılabilen dosyanın tüm kodları aslında derleyici ve bağlayıcı tarafından zaten "onun 
    sanal bellekte yükleneceği yere göre" oluşturulmaktadır. Fakat dinamik kütüphanelerin birden fazlası prosesin sanal adres 
    alanına yüklenebildiğinden bunlar için yükleme adresinin önceden tespit edilmesi mümkün değildir. İşte bu sorunu giderebilmek 
    için işletim sistemlerinde değişik teknikler kullanılmaktadır. Windows sistemlerinde "import-export tablosu ve "load time 
    relocation" yöntemleri tercih edilmiştir. Bu sistemlerde dinamik kütüphane belli bir adrese yüklendiğinde işletim sistemi 
    o dinamik kütüphanenin "relocation" tablosuna bakarak gerekli makine komutlarını düzeltmektedir. Dinamik kütüphane 
    fonksiyonlarının çağrımı için de "import tablosu" ve "export tablosu" denilen tablolar kullanılmaktadır. UNIX/Linux dünyasında 
    dinamik kütüphanelerin herhangi bir yere yüklenebilmesi ve minimal düzeyde relocation uygulanabilmesi için "Konumdan Bağımsız 
    Kod (Position Independent Code - PIC)" denilen teknik kullanılmaktadır. Konumdan bağımsız kod "nereye yüklenirse yüklenilsin 
    çalışabilen kod" anlamına gelmektedir. Konumdan bağımsız kod oluşturabilmek derleyicinin yapabileceği bir işlemdir. Konumdan 
    bağımsız kod oluşturabilmek için gcc ve clang derleyicilerinde derleme sırasında "-fPIC" seçeneğinin bulundurulması gerekmektedir. 
    Biz kursumuzda konumdan bağımsız kod oluşturmanın ayrıntıları üzerinde durmayacağız.

    Pekiyi Windows sistemlerinin kullandığı "relocation" tekniği ile UNIX/Linux sistemlerinde kullanılan "konumdan bağımsız
    kod tekniği" arasında performans bakımından ne farklılıklar vardır? İşte bu tekniklerin kendi aralarında bazı avantaj 
    ve dezavantajları bulunmaktadır. Windows'taki teknikte "relocation" işlemi bir zaman kaybı oluşturabilmektedir. Ancak 
    bir "relocation" işlemi yapıldığında kodlar daha hızlı çalışma eğilimindedir. Konumdan bağımsız kod tekniğinde ise
    "relocation" işlemine minimal düzeyde gereksinim duyulmaktadır. Ancak dinamik kütüphanelerdeki fonksiyonlar çağrılırken 
    göreli biçimde daha fazla zaman kaybedilmektedir. Aynı zamanda bu teknikte kodlar biraz daha fazla yer kaplamaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde aslında dinamik kütüphaneler ismine "dinamik linker (dynamic linker)" denilen bir dinamik kütüphane 
    tarafından yüklenmektedir. Bu dinamik kütüphane "ld.so" ya da "ld-linux.so" ismiyle bulunmaktadır. Programın yüklenmesinin
    execve sistem fonksiyonu tarafından yapıldığını anımsayınız. Bu sistem fonksiyonu ayrıntılı birtakım işlemler yaparak 
    tüm yüklemeyi gerçekleştirmektedir. Bu sürecin ayrıntıları olmakla birlikte kabaca execve süreci bu bağlamda şöyle 
    yürütülmektedir: execve fonksiyonu önce işletim sistemi için gereken çeşitli veri yapılarını oluşturur sonra çalıştırılabilen 
    dosyayı belleğe yükler. Sonra da dinamik linker kütüphanesini belleğe yükler. Bundan sonra akış dinamik linker'daki koda
    aktarılır. Dinamik linker da çalıştırılabilir dosyada belirtilen dinamik kütüphaneleri yükler. Sonra da akışı çalıştırılabilen
    dosyada belirtilen gerçek başlangıç adresine (entry point) aktarır. Dinamik linker kodları aslında user mode'da mmap sistem 
    fonksiyonunu kullanarak diğer dinamik kütüphaneleri yüklemektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi neden dinamik kütüphane dosyaları linker tarafından tıpkı çalıştırılabilir dosyalarda olduğu gibi sanal bellekte belli 
    bir yere yüklenince sorunsuz çalışacak biçimde oluşturulmuyor? Çalıştırılabilir dosyalar sanal bellek boşken yüklendiğinden 
    onların belli bir yere yüklenmesinde bir sorun oluşmamaktadır. Ancak bir program çok fazla dinamik kütüphane kullanabileceğine 
    göre bu dinamik kütüphanelerin baştan yerinin belirlenmesi olanaksızdır.

    Pekiyi dinamik kütüphaneler içerisindeki global değişkenlerin ve fonksiyonların yükleme yerinden bağımsız bir biçimde dinamik 
    kütüphane içerisinden kullanılması nasıl sağlanabilir? Dinamik kütüphane içerisinde aşağıdaki gibi bir kod parçası bulunuyor 
    olsun:

    int g_a;
    ...

    g_a = 10;

    Burada derleyicinin yukarıdaki ifadeye ilişkin makine kodlarını üretebilmesi için g_a değişkeninin tüm bellekteki adresini 
    (yani tepeden itibaren adresini) bilmesi gerekir. Bir nesnenin belleğin tepesinden itibarenki adresine "mutlak adres (absolute
    address) de denilmektedir. Örneğin Intel işlemcilerinde yukarıdaki ifade aşağıdaki gibi makine komutlarına dönüştürülmektedir:

    MOV EAX, 10
    MOV [g_a'nın mutlak adresi], EAX

    İşte sorun buradaki g_a değişkeninin mutlak adresinin program yüklenene kadar bilinmemesidir. Bu sorunu çözmenin de iki yolu 
    vardır:

    1) Derleyici ve linker g_a'nın mutlak adresinin bulunduğu yeri boş bırakır. Yükleyicinin bu yeri yükleme adresine göre 
    doldurmasını ister. İşte bu işlem yükleyicinin yaptığı "relocation" işlemidir. Bu tür relocation işlemlerine "load time 
    relocation" da denilmektedir. Windows sistemleri bu yöntemi kullanmaktadır.

    2) Derleyici makine komutunu o anda komutun yürütüldüğü yerin adresini barındıran ve ismine "Instruction Pointer" denilen 
    yazmaca dayalı olarak oluşturabilir. Çünkü linker komutun bulunduğu yerden g_a'ya kadar kaç byte'lık bir açıklık olduğunu 
    bilmektedir. İşte buna "konumdan bağımsız kod (position independent code)" denilmektedir.

    Yukarıda da belirttiğimiz gibi birinci teknik (Windows sistemlerinin kullandığı teknik) relocation yapıldıktan sonra kodun
    hızlı çalışmasını sağlamaktadır. Ancak bu teknikte relocation zamanı yüklemeyi uzatabilmektedir. İkinci teknikte ise relocation
    minimal düzeyde tutulmaktadır. Ancak bu global değişkenlere erişim birkaç makine komutu ile daha yavaş yapılmaktadır. 
    UNIX/Linux sistemleri genel olarak bu tekniği kullanmaktadır. Ayrıca birinci teknikte kod üzerinde relocation uygulandığı 
    için mecburen "copy on write" mekanizması devreye sokulmaktadır. Bu da fiziksel belleğin kullanım verimini düşürebilmektedir.

    Bu noktada ek olarak işlemcilerde bazı makine komutlarının (MOV, LOAD, STORE gibi) mutlak adres kullandığını ancak CALL 
    ve JMP gibi bazı makine komutlarının hem mutlak hem de göreli adres kullanabildiğini belirtelim. Aslında işlemcileri 
    tasarlayanlar relocation işlemi gerekmesin diye CALL ve JMP komutlarının göreli (relative) versiyonlarını da oluşturmuşlardır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde dinamik kütüphaneler şöyle oluşturulmaktadır:

    1) Önce dinamik kütüphaneye yerleştirilecek amaç dosyaların (object files) -fPIC seçeneği ile "Konumdan Bağımsız Kod 
    (Position Independent Code)" tekniği kullanılarak derlenmesi gerekir. (-fPIC seçeneğinde -f'ten sonra boşluk bırakılmamalıdır.)

    2) Bağlama işleminde "çalıştırılabilir (executable)" değil de "dinamik kütüphane" dosyasının oluşturulması için -shared 
    seçeneğinin kullanılması gerekir. "-shared" seçeneği kullanılmazsa bağlayıcı dinamik kütüphane değil, normal çalıştırılabilir 
    dosya oluşturmaya çalışmaktadır. (Zaten bu durumda main fonksiyonu olmadığı için linker hata mesajı verecektir.) Örneğin:

    $ gcc -fPIC a.c b.c c.c
    $ gcc -shared -o libmyutil.so a.o b.o c.o

    Dinamik kütüphanelere daha sonra dosya eklenip çıkartılamaz. Onların her defasında yeniden bütünsel biçimde oluşturulmaları 
    gerekmektedir. Yukarıdaki işlem aslında tek hamlede de aşağıdaki gibi yapılabilmektedir:

    $ gcc -shared -o libmyutil.so -fPIC a.c b.c c.c
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz -fPIC seçeneğini kullanmadan yani "konumdan bağımsız kod" üretmeden dinamik kütüphane oluşturmaya çalışırsak
    ne olur? Mevcut GNU linker programları "-shared" seçeneği kullanıldığında global değişkenler için relocation işlemi söz 
    konusu ise bir mesaj vererek link işlemini yapmamaktadır. Yani bu durumda mevcut GNU linker programları kodun "-fPIC" 
    seçeneği ile derlenmesini zorunlu tutmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                122. Ders 23/02/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda dinamik kütüphanelerin nasıl oluşturulduğunu gördük. Pekiyi dinamik kütüphaneler nasıl kullanılmaktadır?

    Dinamik kütüphane kullanan bir program bağlanırken kullanılan dinamik kütüphanenin komut satırında belirtilmesi gerekir. 
    Örneğin:

    $ gcc -o app app.c libmyutil.so

    Tabii bu işlem yine -l seçeneği ile de yapılabilirdi:

    $ gcc -o app app.c -lmyutil -L.

    Bu biçimde çalıştırılabilir dosya oluşturulduğunda linker bu çalıştırılabilir dosyanın çalıştırılabilmesi için hangi 
    dinamik kütüphanelerin yüklenmesi gerektiğini ELF formatının ".dynamic" isimli bölümüne yazmaktadır. Böylece yükleyici 
    bu programı yüklerken onun kullandığı dinamik kütüphaneleri de yükleyecektir. Ancak linker bu ".dynamic" bölümüne çalıştırılabilir
    dosyanın kullandığı dinamik kütüphanelerin yol ifadesini (yani tam olarak nerede olduğunu) yazmaz. Yalnızca isimlerini 
    yazmaktadır. İşte yükleyici (dinamik linkler) bu nedenle dinamik kütüphaneleri önceden belirlenen bazı yerlerde aramaktadır. 
    Bu yere çalıştırılabilir dosyanın yüklendiği dizin (current working directory) dahil değildir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İster statik kütüphane isterse dinamik kütüphane yazacak olalım yazdığımız kütüphaneler için bir başlık dosyası oluşturmak 
    iyi bir tekniktir. Örneğin içerisinde çeşitli fonksiyonların bulunduğu "libmyutil.so" dinamik kütüphanesini "libmyutil.c" 
    dosyasından hareketle oluşturmak isteyelim. İşte "libmyutil.c" dosyasındaki fonksiyonların prototipleri, gerekli olan sembolik 
    sabitler, makrolar, inline fonksiyonlar, yapı bildirimleri gibi "nesne yaratmayan bildirimler" bir başlık dosyasına yerleştirilmelidir. 
    Böylece bu kütüphaneyi kullanacak kişiler bu dosyayı include ederek gerekli bildirimlerin kodlarını oluşturmuş olurlar. 
    Başlık dosyaları oluşturulurken iki önemli noktaya dikkat edilmelidir:

    1) Başlık dosyalarına yalnızca "nesne yaratmayan bildirimler (declarations)" yerleştirilmelidir.
    2) Başlık dosyalarının başına "include koruması (include guard)" yerleştirilmelidir. Include koruması aşağıdaki gibi yapılabilir:

    #ifndef SOME_NAME
    #define SOME_NAME

    <dosyanın içeriği>

    #endif

    Buradaki SOME_NAME dosya isminden hareketle uydurulmuş olan herhangi bir isim olabilir. Örneğin:

    #ifndef MYUTIL_H_
    #define MYUTIL_H_

    <dosyanın içeriği>

    #endif

    Örneğin "myutil.so" dinamik kütüphanesinde foo ve bar isimli iki fonksiyon bulunuyor olsun. Bunun için "myutil.h" isimli
    başlık dosyası aşağıdaki gibi oluşturulabilir:

    #ifndef MYUTIL_H_
    #define MYUTIL_H_

    void foo(void);
    void bar(void);

    #endif
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Standart C fonksiyonlarının ve POSIX fonksiyonlarının bulunduğu "libc" kütüphanesi gcc ve clang programlarıyla derleme 
    yapıldığında otomatik olarak bağlama aşamasında devreye sokulmaktadır. Yani biz standart fonksiyonları ve POSIX fonksiyonları 
    için bağlama aşamasında kütüphane belirtmek zorunda değiliz. Default durumda gcc ve clang programları standart C fonksiyonlarını 
    ve POSIX fonksiyonlarını dinamik kütüphaneden alarak kullanır. Ancak programcı isterse "-static" seçeneği ile statik bağlama 
    işlemi de yapabilir. Bu durumda bu fonksiyonlar statik kütüphanelerden alınarak çalıştırılabilen dosyalara yazılacaktır. 
    Örneğin:

    $ gcc -o app -static app.c

    "-static" seçeneği ile bağlama işlemi yapıldığında artık üretilen çalıştırılabilir dosyanın dinamik kütüphanelerle hiçbir ilgisi 
    kalmamaktadır. Zaten "-static" seçeneği belirtildiğinde artık dinamik kütüphaneler bağlama aşamasına programcı tarafından da 
    dahil edilememektedir. Tabii bu biçimde statik bağlama işlemi yapıldığında çalıştırılabilen dosyanın boyutu çok büyüyecektir.

    Eğer "libc" kütüphanesinin default olarak bağlama aşamasında devreye sokulması istenmiyorsa "-nodefaultlibs" seçeneğinin 
    kullanılması gerekir. Örneğin:

    $ gcc -nodefaultlibs -o app app.c

    Burada glibc kütüphanesi devreye sokulmadığı için bağlama aşamasında hata oluşacaktır. Tabii bu durumda da kütüphane açıkça 
    belirtilebilir:

    $ gcc -nodefaultlibs -o app app.c -lc

    Bir kütüphanenin statik ve dinamik biçimi aynı anda bulunuyorsa ve biz bu kütüphaneyi "-l" seçeneği ile belirtiyorsak bu 
    durumda default olarak kütüphanenin dinamik versiyonu devreye sokulmaktadır. Eğer bu durumda kütüphanelerin statik versiyonlarının 
    devreye sokulması isteniyorsa "-static" seçeneğinin kullanılması ya da komut satırında açıkça statik kütüphaneye referans 
    edilmesi gerekir. Örneğin:

    $ gcc -o app app.c -lmyutil -L.

    Burada eğer hem "libmyutil.so" hem de "libmyutil.a" dosyaları varsa "libmyutil.so" dosyası kullanılacaktır. Yani dinamik bağlama 
    yapılacaktır. Tabii biz açıkça statik kütüphanenin ya da dinamik kütüphanenin kullanılmasını sağlayabiliriz:

    $ gcc -o app app.c libmyutil.a

    Aynı etkiyi şöyle de sağlayabilirdik:

    $ gcc -static -o app app.c -lmyutil -L.

    Burada "libc" kütüphanesinin dinamik biçimi devreye sokulacaktır. Ancak "libmyutil" kütüphanesi statik biçimde bağlanmıştır.
    Eğer "-static" seçeneği kullanılırsa bu durumda tüm kütüphanelerin statik versiyonları devreye sokulmaktadır. Tabii bu durumda 
    biz açıkça dinamik kütüphanelerin bağlama işlemine sokulmasını isteyemeyiz. Örneğin:

    $ gcc -static -o app app.c libmyutil.so

    Bu işlem başarısız olacaktır. Çünkü "-static" seçeneği zaten "tüm kütüphanelerin statik olarak bağlanacağı" anlamına 
    gelmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir programın kullandığı dinamik kütüphaneler ldd isimli utility program ile basit bir biçimde görüntülenebilir. Örneğin:

    $ ldd sample
    linux-vdso.so.1 (0x00007fff38162000)
    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7ec0b5c000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f7ec114f000

    ldd programı dinamik kütüphanelerin kullandığı dinamik kütüphaneleri de görüntülemektedir. Programın doğrudan kullandığı 
    dinamik kütüphanelerin listesi readelf komutuyla aşağıdaki gibi de elde edilebilir:

    $ readelf -d sample | grep "NEEDED"
    0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde dinamik kütüphane kullanan programların yüklenmesi süreci biraz ilginçtir. Anımsanacağı gibi aslında
    her türlü program exec fonksiyonları tarafından yüklenip çalıştırılmaktadır. Bu exec fonksiyonlarının taban olanı "execve"
    isimli fonksiyondur. (Yani diğer exec fonksiyonları bunu çağırmaktadır.) execve fonksiyonu da bir sistem fonksiyonu olarak 
    yazılmıştır.

    Dinamik kütüphane kullanan programların kullandığı dinamik kütüphaneler ismine "dinamik linker (dynamic linker)" denilen
    özel bir program tarafından yüklenmektedir. exec fonksiyonları aslında sıra dinamik kütüphanelerin yüklenmesine geldiğinde 
    dinamik linker denilen bu programı çalıştırmaktadır. Dinamik linker "ld.so" ismiyle temsil edilmektedir. Programın kullandığı 
    dinamik kütüphanelerin başka bir program tarafından yüklenmesi esneklik sağlamaktadır. Bu sayede sistem programcısı isterse 
    (genellikle istemez) bu dinamik linker programını değiştirerek yükleme sürecinde özel işlemler yapabilir. Dinamik linker 
    tamamen user mode'da çalışmaktadır.

    Programın dinamik kütüphanelerinin yüklenmesinde kullanılacak olan dinamik linker'ın yol ifadesi ELF formatında "Program Başlık 
    Tablosu'nda" INTERP türüyle belirtilmektedir. INTERP türüne ilişkin Program Başlığı'nda dinamik bağlayıcının yol ifadesinin 
    bulunduğu dosya offset'i belirtilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bizim programımız örneğin "libmyutil.so" isimli bir dinamik kütüphaneden çağrı yapıyor olsun. Bu "libmyutil.so" 
    dosyasının program çalıştırılırken nerede bulundurulması gerekir? İşte program çalıştırılırken ilgili dinamik kütüphane 
    dosyasının özel bazı dizinlerde bulunuyor olması gerekmektedir. Dinamik kütüphanelerin dinamik bağlayıcı tarafından yüklendiğini
    ve dinamik bağlayıcının da "ld.so" ismiyle temsil edildiğini anımsayınız. "ld.so" ismiyle temsil edilen dinamik bağlayıcı 
    akkında "man ld.so" komutuyla bilgi alabilirsiniz.

    "ld.so" için hazırlanan "man" sayfasında dinamik kütüphaneleri dinamik bağlayıcının nasıl ve nerelerde aradığı maddeler halinde 
    açıklanmıştır. Bu maddeleri tek tek ele almak istiyoruz:

    1) Dinamik bağlayıcı önce çalıştırılabilen dosyanın ".dynamic" bölümündeki DT_RPATH tag'ına bakar. Bu tag'ın değeri tek bir 
    dizin ya da ':' karakterleriyle ayrılmış olan birden fazla dizin belirten bir yazı olabilir. Bu durumda dinamik bağlayıcı 
    bu dizinlere sırasıyla bakmaktadır. Ancak birinci aşamada bu tag'a bakılmasının bir tasarım kusuru olduğu anlaşılmıştır. 
    Bu nedenle ".dynamic" bölümüne DT_RPATH tag'ının yerleştirilmesi "deprecated" yapılmıştır.

    2) Dinamik bağlayıcı yüklenmekte olan program dosyasına ilişkin prosesin LD_LIBRARY_PATH çevre değişkenine bakar. Eğer böyle 
    bir çevre değişkeni varsa dinamik kütüphaneleri bu çevre değişkeninde belirtilen dizinlerde sırasıyla arar. Bu çevre değişkeni 
    ':' karakterleriyle ayrılmış yol ifadelerinden oluşmaktadır. Biz programı genellikle kabuk üzerinden çalıştırdığımıza göre 
    kabukta bu çevre değişkenini aşağıdaki örnekte olduğu gibi set edebiliriz:

    $ export LD_LIBRARY_PATH=/home/kaan:/home/kaan/Study/UnixLinux-SysProg:.

    Burada artık dinamik kütüphaneler sırasıyla "/home/kaan" dizininde, "/home/kaan/Study/UnixLinux-SysProg" dizininde ve prosesin 
    çalışma dizininde (current working directory) aranacaktır. Çevre değişkeninin sonundaki "." karakterinin exec uygulayan 
    prosesin o andaki çalışma dizinini temsil ettiğine dikkat ediniz. Tabii biz kabuk programının değil çalıştırılacak programın 
    çevre değişken listesine ekleme yaparak da programı aşağıdaki gibi çalıştırabiliriz:

    $ LD_LIBRARY_PATH=:. ./app

    3) Dinamik bağlayıcı çalıştırılabilen dosyanın ".dynamic" bölümündeki DT_RUNPATH tag'ına bakar. Birinci aşamada biz DT_RPATH
    tag'ının "deprecated" yapıldığını belirtmiştik. İşte bu tag yerine artık DT_RUNPATH tag'ı kullanılmalıdır. Bu tag'ın değeri 
    de yine ':' karakterleriyle ayrılmış olan dizin listesinden oluşmaktadır. Dinamik bağlayıcı bu dizinlerde sırasıyla arama 
    yapmaktadır. DT_RPATH ile DT_RUNPATH arasındaki tek fark DT_RUNPATH tag'ına LD_LIBRARY_PATH çevre değişkeninden daha sonra 
    bakılmasıdır.

    4) Dinamik bağlayıcı daha sonra "/etc/ld.so.cache" isimli cache dosyasına bakar. Bu cache dosyası her bir dinamik kütüphanenin
    hangi dizinlerde olduğunu belirtmektedir. Bu konu izleyen paragraflarda ele alınacaktır.

    5) Nihayet dinamik bağlayıcı dinamik kütüphaneleri sırasıyla "/lib", /usr/lib" dizinlerinde de aramaktadır. 64 bit Linux 
    sistemlerininin bir bölümünde 64 bit dinamik kütüphaneler için "/lib64" ve "/usr/lib64" dizinlerine de bakılabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki üçüncü maddede aranacak yol ifadesini çalıştırılabilir dosyanın DT_RUNPATH tag'ına yerleştirmek için ld 
    bağlayıcısında "-rpath <yol ifadeleri>" bağlayıcı seçeneği kullanılmalıdır. Buradaki yol ifadelerinin mutlak olması zorunlu 
    değilse de şiddetle tavsiye edilmektedir. gcc ve clang derleyicilerinde "-rpath" seçeneğini bağlayıcıya geçirebilmek için 
    "-Wl" seçeneği kullanılabilir. "-Wl" seçeneği bitişik yazılan virgüllü alanlardan oluşmalıdır. gcc ve clang bu komut satırı 
    argümanını "ld" bağlayıcısına virgüller yerine boşluklar (SPACE) koyarak geçirmektedir. Örneğin:

    $ gcc -o app app.c -Wl,-rpath,/home/kaan/Study/UnixLinux-SysProg libmyutil.so

    Burada ELF formatının DT_RUNPATH tag'ına yerleştirme yapılmaktadır. Çalıştırılabilir dosyaya iliştirilen DT_RUNPATH bilgisi 
    "readelf" programı ile aşağıdaki gibi görüntülenebilir:

    $ readelf -d app | grep "RUNPATH"
    0x000000000000001d (RUNPATH)            Library runpath: [/home/csd/Study/UnixLinux-SysProg

    Biz bu tag'a birden fazla dizin de yerleştirebiliriz. Bu durumda yine dizinleri ':' ile ayırmamız gerekir. Örneğin:

    $ gcc -o app app.c -Wl,-rpath,/home/csd/Study/UnixLinux-SysProg:/home/kaan libmyutil.so

    Birden fazla kez "-rpath" seçeneği kullanıldığında bu seçenekler tek bir DT_RUNPATH tag'ına aralarına ':' karakteri getirilerek 
    yerleştirilmektedir. Yani aşağıdaki işlem yukarıdaki ile eşdeğerdir:

    $ gcc -o app app.c -Wl,-rpath,/home/csd/Study/UnixLinux-SysProg,-rpath,/home/kaan libmyutil.so

    "-rpath" bağlayıcı seçeneğinde default durumda DT_RUNPATH tag'ına yerleştirme yapıldığına dikkat ediniz. Eğer DT_RPATH tag'ına 
    yerleştirme yapılmak isteniyorsa bağlayıcı seçeneklerine ayrıca "--disable-new-dtags" seçeneğinin de girilmesi gerekmektedir. 
    Örneğin:

    $ gcc -o app app.c -Wl,-rpath,/home/csd/Study/UnixLinux-SysProg,--disable-new-dtags libmyutil.so

    DT_RUNPATH tag'ını da aşağıdaki gibi görüntüleyebiliriz:

    $ readelf -d app | grep "RUNPATH"
    0x000000000000001d (RUNPATH)            Library runpath: [/home/kaan/Study/UnixLinux-SysProg]

    Çalıştırılabilir dosyaya DT_RUNPATH tag'ının mutlak ya da göreli yol ifadesi biçiminde girilmesi bazı kullanım sorunlarına yol 
    açabilmektedir. Çünkü bu durumda dinamik kütüphaneler uygulamanın kurulduğu dizine göreli biçimde konuşlandırılacağı zaman 
    uygulamanın kurulum yeri değiştirildiğinde sorunlar oluşabilmektedir. Örneğin biz çalıştırılabilir dosyanın DT_RUNPATH tag'ına 
    "home/kaan/test" isimli yol ifadesini yazmış olalım. Programımızı ve dinamik kütüphanemizi bu dizine yerleştirirsek bir sorun 
    oluşmayacaktır. Ancak başka bir dizine yerleştirirsek dinamik kütüphanemiz bulunamayacaktır. İşte bunu engellemek için "-rpath" 
    seçeneğinde '$ORIGIN' argümanı kullanılmaktadır. Buradaki '$ORIGIN' argümanı "o anda çalıştırılabilen dosyanın bulunduğu dizini" 
    temsil etmektedir. Örneğin:

    $ gcc -o app app.c -Wl,-rpath,'$ORIGIN'/. libmyutil.so

    Burada artık çalıştırılabilen dosya nereye yerleştirilirse yerleştirilsin ve nereden çalıştırılırsa çalıştırılsın dinamik 
    kütüphaneler çalıştırılabilen dosyanın yerleştirildiği dizinde aranacaktır.

    Yukarıda da belirttiğimiz gibi aslında arama sırası bakımından DT_RPATH tag'ının en yukarıda olması (LD_LIBRARY_PATH'in 
    yukarısında olması) yanlış bir tasarımdır. Geriye doğru uyumu koruyarak bu yanlış tasarım DT_RUNPATH tag'ı ile telafi 
    edilmiştir. DT_RUNPATH tag'ına LD_LIBRARY_PATH çevre değişkeninden sonra başvurulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphanelerin aranması sırasında "/lib" ve "/usr/lib" dizinlerine bakılmadan önce özel bir dosyaya da bakılmaktadır. 
    Bu dosya "/etc/ld.so.cache" isimli dosyadır. "/etc/ld.so.cache" dosyası aslında binary bir dosyadır. Bu dosya hızlı aramanın 
    yapılabilmesi için "sözlük (dictionary)" tarzı yani algoritmik aramaya izin verecek biçimde bir içeriğe sahiptir. Bu dosya
    ilgili dinamik kütüphane dosyalarının hangi dizinler içerisinde olduğunu gösteren bir yapıdadır. (Yani bu dosya ".so" dosyalarının 
    hangi dizinlerde olduğunu belirten binary bir dosyadır.) Başka bir deyişle bu dosyanın içerisinde "falanca .so dosyası filanca 
    dizinde" biçiminde bilgiler vardır. İlgili ".so" dosyasının yerinin bu dosyada aranması dizinlerde aranmasından çok daha 
    hızlı yapılabilmektedir. Ayrıca dinamik kütüphaneler değişik dizinlerde bulunabilmektedir. Bunların LD_LIBRARY_PATH çevre 
    değişkeninde belirtilen dizinlerde tek tek aranması bir yavaşlık oluşturabilmektedir.

    Pekiyi bu "/etc/ld.so.cache" dosyasının içerisinde hangi ".so" dosyaları vardır? Aslında bu dosyanın içerisinde "/lib" ve 
    "/usr/lib" dizinindeki ".so" dosyalarının hepsi bulunmaktadır. Ama programcı isterse kendi dosyalarını da bu cache dosyasının 
    içerisine yerleştirebilir. Burada dikkat edilmesi gereken nokta bu cache dosyasına "/lib" ve "/usr/lib" dizinlerinden 
    daha önce bakıldığı ve bu dizinlerin içeriğinin de zaten bu cache dosyasının içerisinde olduğudur. O halde aslında "/lib" ve 
    "/usr/lib" dizinlerinde arama çok nadir olarak yapılmaktadır. Ayrıca bu cache dosyasına LD_LIBRARY_PATH çevre değişkeninden 
    daha sonra bakıldığına dikkat ediniz. O halde programcının kendi ".so" dosyalarını da -eğer uzun süreliğine konuşlandıracaksa- 
    bu cache dosyasının içerisine yerleştirmesi tavsiye edilmektedir.

    Pekiyi "/etc/ld.so.cache" dosyasına biz nasıl bir dosya ekleriz? Aslında programcı bunu dolaylı olarak yapmaktadır. Şöyle ki: 
    "/sbin/ldconfig" isimli bir program vardır. Bu program "/etc/ld.so.conf" isimli bir text dosyasına bakar. Bu dosya dizinlerden 
    oluşmaktadır. Bu "ldconfig" programı bu dizinlerin içerisindeki "so" dosyalarını "/etc/ld.so.cache" dosyasına eklemektedir. 
    Şimdilerde "/etc/ld.so.conf" dosyasının içeriği şöyledir:

    include /etc/ld.so.conf.d/*.conf

    Bu satır "/etc/ld.so.conf.d" dizinindeki tüm ".conf" uzantılı dosyaların bu işleme dahil edileceğini belirtmektedir.

    Biz "ldconfig" programını çalıştırdığımızda bu program "/lib", "/usr/lib" ve "/etc/ld.so.conf" (dolayısıyla "/etc/ld.so.conf.d" 
    dizinindeki ".conf" dosyalarına) bakarak "/etc/ld.so.cache" dosyasını yeniden oluşturmaktadır. O halde bizim bu cache'e ekleme 
    yapmak için tek yapacağımız şey "/etc/ld.so.conf.d" dizinindeki bir ".conf" dosyasına yeni bir satır olarak bir dizinin yol 
    ifadesini girmektir. (".conf" dosyaları her satırda bir dizinin yol ifadesinden oluşmaktadır.) Tabii programcı isterse bu dizine 
    yeni bir ".conf" dosyası da ekleyebilir. İşte programcı bu işlemi yaptıktan sonra "/sbin/ldconfig" programını çalıştırınca artık 
    onun eklediği dizinin içerisindeki ".so" dosyaları da "/etc/ld.so.cache" dosyasının içerisine eklenmiş olacaktır. Daha açık bir 
    anlatımla programcı bu cache dosyasına ekleme işini adım adım şöyle yapar:

    1) Önce ".so" dosyasını bir dizine yerleştirir.
    2) Bu dizinin ismini "/etc/ld.so.conf.d" dizinindeki bir dosyanın sonuna ekler. Ya da bu dizinde yeni ".conf" dosyası oluşturarak
    dizini bu dosyanın içerisine yazar.
    3) "/sbin/ldconfig" programını çalıştırır.

    "ldconfig" programının "sudo" ile çalıştırılması gerektiğine dikkat ediniz. Zaten "/sbin" dizinindeki tüm programlar "super user"
    için bulundurulmuştur.

    Programcı "/etc/ld.so.conf.d" dizinindeki herhangi bir dosyaya değil de "-f" seçeneği sayesinde kendi belirlediği bir dosyaya 
    da ilgili dizinleri yazabilmektedir. Başka bir deyişle "-f" seçeneği "şu config dosyasına da bak" anlamına gelmektedir. "ldconfig"
    her çalıştırıldığında sıfırdan yeniden cache dosyasını oluşturmaktadır.

    Programcı "/lib" ya da "/usr/lib" dizinine bir ".so" dosyası eklediğinde "ldconfig" programını çalıştırması -zorunlu olmasa da- 
    iyi bir tekniktir. Çünkü o dosya da cache dosyasına yazılacak ve daha hızlı bulunacaktır.

    ldconfig programında "-p" seçeneği ile cache dosyası içerisindeki tüm dosyalar görüntülenebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kütüphane dosyalarının "so" isimleri denilen bir isimleri de bulunabilmektedir. Kütüphane dosyalarının "so" isimleri linker 
    tarafından kullanılan isimleridir. Kütüphane dosyası oluşturulurken "so" isimleri verilmeyebilir. Yani bir kütüphane dosyasının 
    "so" ismi olmak zorunda değildir. Kütüphane dosyalarına "so" isimlerini vermek için "-soname <isim>" linker seçeneği 
    kullanılmaktadır. Kütüphanelere verilen "so" isimleri ELF formatının dinamik bölümündeki (dynamic section) SONAME isimli 
    bir tag'ına yerleştirilmektedir. "-soname" komut satırı argümanı linker'a ilişkin olduğu için "-Wl" seçeneği ile kullanılmalıdır. 
    Örneğin biz libx.so isimli bir dinamik kütüphaneyi "so" ismi vererek oluşturmak isteyelim. Bu işlemi şöyle yapabiliriz:

    $ gcc -o libx.so -fPIC -shared -Wl,-soname,liby.so libx.c

    Burada "libx.so" kütüphane dosyasına "liby.so" "so" ismi verilmiştir. Kütüphane dosyalarına iliştirilen "so" isimleri 
    readelf ile aşağıdaki gibi görüntülenebilir:

    $ readelf -d libx.so | grep "SONAME"
    0x000000000000000e (SONAME)             Kitaplık so_adı: [liby.so]

    Aynı işlem objdump programıyla da şöyle yapılabilir:

    objdump -x libx.so | grep "SONAME"
    SONAME               liby.so

    Tabii yukarıda da belirttiğimiz gibi biz dinamik kütüphanelere "so" ismi vermek zorunda değiliz.

    "so" ismi içeren bir kütüphaneyi kullanan bir program link edilirken linker çalıştırılabilen dosyaya "so" ismini içeren 
    kütüphanenin ismini değil "so" ismini yazmaktadır. Yukarıdaki örneğimizde "libx.so" kütüphanesi "so" ismi olarak "liby.so"
    ismini içermektedir. Şimdi libx.so dosyasını kullanan "app.c" dosyasını derleyip link edelim:

    $ gcc -o app app.c libx.so

    Burada link işleminde "libx.so" dosya ismi kullanılmıştır. Ancak oluşturulan "app" dosyasının içerisine linker bu ismi 
    değil, "so" ismi olan "liby.so" ismini yazacaktır. Örneğin:

    $ readelf -d app | grep "NEEDED"
    0x0000000000000001 (NEEDED)             Paylaşımlı kitaplık: [liby.so]
    0x0000000000000001 (NEEDED)             Paylaşımlı kitaplık: [libc.so.6]

    O halde biz buradaki "app" dosyasını çalıştırmak istediğimizde yükleyici (yani dinamik linker) artık "libx.so" dosyasını 
    değil, "liby.so" dosyasını yüklemeye çalışacaktır. Örneğin.

    $ export LD_LIBRARY_PATH=.
    $ ./app
    ./app: error while loading shared libraries: liby.so: cannot open shared object file: No such file or directory

    Tabii yukarıda belirttiğimiz gibi eğer kütüphaneyi oluştururken ona "so" ismi vermeseydik bu durumda linker "app" dosyasına
    "libx.so" dosyasını yazacaktı ve yükleyici de (dynamic linker) bu dosyası yükleyecekti.

    Pekiyi yukarıdaki örnekte "app" programı artık "liby.so" dosyasını kullanıyor gibi olduğuna göre ve böyle de bir dosya 
    olmadığına göre bu işlemlerin ne anlamı vardır? İşte biz bu örnekte "so" ismine ilişkin dosyayı bir sembolik link dosyası 
    haline getirirsek ve bu sembolik link dosyası da "libx.so" dosyasını gösterir hale gelirse sorunu ortadan kaldırabiliriz. 
    Örneğin:

    $ ln -s libx.so liby.so
    $ ls -l liby.so
    lrwxrwxrwx 1 kaan study 7 Şub 25 16:44 liby.so -> libx.so

    Şimdi artık "app" dosyasını çalıştırmak istediğimizde yükleyici "liby.so" dosyasını yüklemek isteyecektir. Ancak "liby.so" 
    dosyası da zaten "libx.so" dosyasını belirttiği için yine "libx.so" dosyası yüklenecektir. Yani artık "app" dosyasını 
    çalıştırabiliriz. Tabii burada tüm bunları neden yapmış olduğumuza bir anlam verememiş olabilirsiniz. İşte bunun anlamını 
    izleyen paragraflarda dinamik kütüphanelerin versiyonlanması konusunda açıklayacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde dinamik kütüphane dosyalarına isteğe bağlı olarak birer versiyon numarası verilebilmektedir. Bu 
    versiyon numarası dosya isminin bir parçası durumundadır. Linux sistemlerinde izlenen tipik numaralandırma (convention) 
    şöyledir:

    <dosya_ismi>.so.<majör_numara>.<minör_yüksek_numara>.<minör_alçak_numara>

    Örneğin:

    libmyutil.so.2.4.6

    Majör numaralar büyük değişiklikleri, minör numaralar ise küçük değişiklikleri anlatmaktadır. Majör numara değişirse yeni 
    dinamik kütüphane eskisiyle uyumlu olmaz. Burada "uyumlu değildir" lafı eski dinamik kütüphaneyi kullanan programların 
    yenisini kullanamayacağı anlamına gelmektedir. Çünkü muhtemelen bu yeni versiyonda fonksiyonların isimlerinde, parametrik 
    yapılarında değişiklikler söz konusu olmuş olabilir ya da bazı fonksiyonlar silinmiş olabilir. Fakat majör numarası aynı 
    ancak minör numaraları farklı olan kütüphaneler birbirleriyle uyumludur. Yani alçak minör numarayı kullanan program yüksek 
    minör numarayı kullanırsa sorun olmayacaktır. Bu durumda tabii yüksek minör numaralı kütüphanede hiçbir fonksiyonun ismi, 
    parametrik yapısı değişmemiş ve hiçbir fonksiyon silinmemiş olmalıdır. Örneğin yüksek minör numaralarda fonksiyonlarda 
    daha hızlı çalışacak biçimde optimizasyonlar yapılmış olabilir. Ya da örneğin yüksek minör numaralarda yeni birtakım 
    fonksiyonlar da eklenmiş olabilir. Çünkü yeni birtakım fonksiyonlar eklendiğinde eski fonksiyonlar varlığını devam ettirmektedir. 
    Tabii yine de bu durum dinamik kütüphanenin eski versiyonunu kullanan programların düzgün çalışacağı anlamına gelmemektedir. 
    Çünkü programcılar kodlarına yeni birtakım şeyler eklerken istemeden eski kodların çalışmasını da bozabilmektedir. (Bu tür 
    problemler Windows sistemlerinde eskiden ciddi sıkıntılara yol açmaktaydı. Bu probleme Windows sistemlerinde "DLL cehennemi 
    (DLL Hell)" deniyordu.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde versiyonlama bakımından bir dinamik kütüphanenin üç ismi bulunmaktadır:

    1) Gerçek ismi (real name)
    2) so ismi (so name)
    3) Linker ismi (linker name)

    Kütüphanenin majör ve çift minör versiyonlu ismine gerçek ismi denilmektedir. Örneğin:

    libmyutil.so.2.4.6

    "so" ismi ise yalnızca majör numara içeren ismidir. Örneğin yukarıdaki gerçek ismin "so" ismi şöyledir:

    libmyutil.so.2

    Linker ismi ise hiç versiyon numarası içermeyen ismidir. Örneğin yukarıdaki kütüphanelerin linker ismi ise şöyledir:

    libmyutil.so

    İşte tipik olarak "so" ismi gerçek isme sembolik link, linker ismi de en yüksek numaralı "so" ismine sembolik link yapılır.

    linker ismi ---> so ismi ---> gerçek ismi

    Örneğin:

    $ gcc -o libmyutil.so.1.0.0 -shared -fPIC libmyutil.c     (gerçek isimli kütüphane dosyası oluşturuldu)
    $ ln -s libmyutil.so.1.0.0 libmyutil.so.1                 (so ismi oluşturuldu)
    $ ln -s libmyutil.so.1 libmyutil.so                       (linker ismi oluşturuldu)

    Burada oluşturulan üç dosyayı "ls -l" komutu ile görüntüleyelim:

    lrwxrwxrwx 1 kaan study    14 Şub 25 15:45 libmyutil.so -> libmyutil.so.1
    lrwxrwxrwx 1 kaan study    18 Şub 25 15:45 libmyutil.so.1 -> libmyutil.so.1.0.0
    -rwxr-xr-x 1 kaan study 15736 Şub 25 15:45 libmyutil.so.1.0.0
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                123. Ders 25/02/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphanelerin linker isimleri o kütüphaneyi kullanan programlar link edilirken link aşamasında (link ederken) 
    kullanılan isimlerdir. Bu sayede link işlemini yapan programcıların daha az tuşa basarak genel bir isim kullanması 
    sağlanmıştır. Bu durumda örneğin biz libmyutil isimli kütüphaneyi kullanan programı link etmek istersek şöyle yapabiliriz:

    $ gcc -o app app.c libmyutil.so

    Ya da şöyle yapabiliriz:

    $ gcc -o app app.c -lmyutil -L.

    Burada aslında "libmyutil.so" dosyası "so ismine" "so" ismi de "gerçek isme link yapılmış" durumdadır. Yani bu komutun 
    aslında eşdeğeri şöyledir:

    $ gcc -o app app.c libmyutil.so.1.0.0
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                124. Ders 01/03/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda anlattıklarımızı özetlersek geldiğimiz noktayı daha iyi kavrayabiliriz:

    1) Bir dinamik kütüphane oluştururken ona bir versiyon numarası da atanabilmektedir. Örneğin biz oluşturduğumuz "myutil" 
    dinamik kütüphanesine "1.0.0" versiyon numarası atamış olalım. Bu durumda kütüphanemizin gerçek ismi "libmyutil.so.1.0.0" 
    olacaktır. Kütüphanemizi aşağıdaki gibi derlemiş olalım:

    $ gcc -fPIC -shared -o libmyutil.so.1.0.0 -Wl,-soname,libmyutil.so.1 libmyutil.c

    2) Dinamik kütüphanelerin "so ismi" kütüphanelerin içerisine yazılan ismidir. Yukarıdaki gibi bir derlemede biz "libmyutil.so.1.0.0"
    kütüphanesinin içerisine "so ismi" olarak "libmyutil.so" ismini yerleştirdik. "so isimleri" genel olarak yalnızca majör 
    numara içeren isimlerdir. Bizim bu aşamada tipik olarak bir sembolik link oluşturarak "so" ismine ilişkin dosyanın gerçek 
    kütüphane dosyasını göstermesini sağlamamız gerekir. Bunu şöyle yapabiliriz:

    $ ln -s libmyutil.so.1.0.0 libmyutil.so.1

    Şimdi her iki dosyayı da görüntüleyelim:

    lrwxrwxrwx 1 kaan study    18 Mar  1 20:02 libmyutil.so.1 -> libmyutil.so.1.0.0
    -rwxr-xr-x 1 kaan study 15736 Mar  1 19:57 libmyutil.so.1.0.0

    3) Dinamik kütüphanenin link aşamasında kullanılmasını kolaylaştırmak için sonunda versiyon uzantısı olmayan bir "linker ismi"
    oluşturabiliriz. Tabii bu linker ismi aslında gerçek kütüphaneye referans edecektir. Ancak bu referansın doğrudan değil de "so ismi"
    üzerinden yapılması daha esnek bir kullanıma yol açacaktır. Örneğin:

    $ ln -s libmyutil.so.1 libmyutil.so

    Artık kütüphanenin "linker ismi" "so ismine", "so ismi" de gerçek ismine sembolik link yapılmış durumdadır. Bu üç dosyayı 
    aşağıda yeniden görüntüleyelim:

    lrwxrwxrwx 1 kaan study    14 Mar  1 20:07 libmyutil.so -> libmyutil.so.1
    lrwxrwxrwx 1 kaan study    18 Mar  1 20:02 libmyutil.so.1 -> libmyutil.so.1.0.0
    -rwxr-xr-x 1 kaan study 15736 Mar  1 19:57 libmyutil.so.1.0.0

    Aşağıdaki gibi bir durum elde ettiğimize dikkat ediniz:

    Linker ismi ---> so ismi ---> gerçek isim

    4) Şimdi kütüphaneyi kullanan bir "app" programını derleyip link edelim:

    $ gcc -o app app.c libmyutil.so

    Şimdi LD_LIBRARY_PATH çevre değişkenini belirleyip programı çalıştıralım:

    $ LD_LIBRARY_PATH=. ./app
    30.000000
    -10.000000
    200.000000
    0.500000

    Burada app programının kullandığı kütüphane ismi app dosyasının içerisinde kütüphanenin "so ismi" olarak set edilecektir. 
    Yani burada "app" dosyası sanki "libmyutil.so.1" dosyasını kullanıyor gibi olacaktır. Örneğin:

    $ readelf -d app | grep "NEEDED"
    0x0000000000000001 (NEEDED)             Paylaşımlı kitaplık: [libmyutil.so.1]
    0x0000000000000001 (NEEDED)             Paylaşımlı kitaplık: [libc.so.6]

    İşte "app" programını yükleyecek olan dinamik linker aslında "libmyutil.so.1" dosyasını yüklemeye çalışacaktır. Bu dosyann 
    kütüphanenin gerçek ismine sembolik link yapıldığını anımsayınız. Bu durumda gerçekte yüklenecek olan dosya "libmyutil.so.1" 
    dosyası değil, "libmyutil.so.1.0.0" dosyası olacaktır. Yani çalışmada bir sorun ortaya çıkmayacaktır. Pekiyi tüm bunların 
    amacı nedir? Bunu şöyle açıklayabiliriz:

    1) Örneğin kütüphanemizin libmyutil.so.1.1.0 biçiminde majör numarası aynı, minör numarası farklı öncekiyle uyumlu yeni bir 
    versiyonunun daha oluşturulduğunu düşünelim. Şimdi biz uygulamamızı çektiğimiz dizin içerisindeki "libmyutil.so" dosyasını 
    bu yeni versiyonu referans edecek biçimde değiştirebiliriz. Bu durumda dinamik linker "app" programını yüklemeye çalışırken 
    aslında artık "libmyutil.so.1.1.0" kütüphanesini yükleyecektir. Burada biz hiç "app" dosyasının içini değiştirmeden artık "app"
    dosyasının kütüphanenin yeni minör versiyonunu kullanmasını sağlamış olduk.

    2) Şimdi de kütüphanemizin "libmyutil.so.2.0.0" biçiminde yeni bir majör versiyonunun oluşturulduğunu varsayalım. 1 numaralı 
    majör versiyonla 2 numaralı majör versiyon birbirleriyle uyumlu değildir. Biz bu "libmyutil.so.2.0.0" yeni versiyonu derlerken ona
    "so ismi" olarak artık "libmyutil.so.2" ismini vermeliyiz. Tabii bu durumda biz yine "libmyutil.so.2" sembolik bağlantı dosyasının 
    "libmyutil.so.2.0.0" dosyasını göstermesini sağlamalıyız. Artık kütüphanenin 2'nci versiyonunu kullanan programlarda yüklenecek 
    kütüphane "libmyutil.so.2" kütüphanesi olacaktır. Bu kütüphanede 2'nci versiyonunun gerçek kütüphane ismine sembolik link yapılmış 
    durumdadır.

    "so ismine" ilişkin sembolik link çıkartma ve "/etc/ld.so.cache" dosyasının güncellenmesi işlemi ldconfig tarafından otomatik 
    yapılabilmektedir. Yani aslında örneğin biz kütüphanenin gerçek isimli dosyasını "/lib" ya da "/usr/lib" içerisine yerleştirip 
    "ldconfig" programını çalıştırdığımızda bu program zaten "so ismine" ilişkin sembolik linki de oluşturmaktadır. Örneğin biz 
    "libmyutil.so.1.0.0" dosyasını "/usr/lib" dizinine kopyalayalım ve "ldconfig" programını çalıştıralım. "ldconfig" programı 
    "libmyutil.so.1" sembolik link dosyasını oluşturup bu sembolik link dosyasının "libmyutil.so.1.0.0" dosyasına referans etmesini 
    sağlayacaktır. Tabii cache'e de "libmyutil.so.1" dosyasını yerleştirecektir. Örneğin:

    $ ldconfig -p | grep "libmyutil"
    libmyutil.so.1 (libc6,x86-64) => /lib/libmyutil.so.1
    $ ls -l /usr/lib | grep "libmyutil"
    lrwxrwxrwx  1 root root       18 Mar  1 21:02 libmyutil.so.1 -> libmyutil.so.1.0.0
    -rwxr-xr-x  1 root root    15736 Mar  1 21:01 libmyutil.so.1.0.

    Özetle Dinamik kütüphane kullanırken şu konvansiyona uymak iyi bir tekniktir:

    - Kütüphane ismini "lib" ile başlatarak vermek
    - Kütüphane ismine majör ve minör numara vermek
    - Gerçek isimli kütüphane dosyasını oluştururken "so ismi" olarak "-Wl,-soname" seçeneği ile kütüphanenin "so ismini" yazmak
    - Kütüphane için "linker ismi" ve "so ismini" sembolik link biçiminde oluşturmak
    - Kütüphane paylaşılacaksa onu "/lib" ya da tercihen "/usr/lib" dizinine yerleştirmek ve ldconfig programı çalıştırarak 
    /etc/ld.so.cache dosyasının güncellenmesini sağlamak
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphane dosyaları program çalıştırıldıktan sonra çalışma zamanı sırasında çalışmanın belli bir aşamasında 
    da yüklenebilir. Buna "dinamik kütüphane dosyalarının dinamik yüklenmesi" de denilmektedir. Dinamik kütüphane dosyalarının 
    baştan "dinamik linker" tarafından değil de programın çalışma zamanı sırasında yüklenmesinin bazı avantajları şunlar 
    olabilmektedir:

    1) Dinamik kütüphaneler baştan yüklenmediği için program başlangıçta daha hızlı yüklenebilir.

    2) Programın sanal bellek alanı gereksiz bir biçimde doldurulmayabilir. Örneğin nadiren çalışacak bir fonksiyon dinamik 
    kütüphanede olabilir. Bu durumda o dinamik kütüphanenin işin başında yüklenmesi gereksiz bir yükleme zamanı ve bellek 
    israfına yol açabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphanelerin dinamik yüklenmesi dlopen, dlsym, dlerror ve dlclose fonksiyonlarıyla yapılmaktadır. Bu fonksiyonlar 
    "libdl" kütüphanesi içerisindedir. Dolayısıyla link işlemi için -ldl seçeneğinin bulundurulması gerekir. Dinamik kütüphanelerin
    dinamik yüklenmesi için önce "dlopen" fonksiyonu ile dinamik kütüphanenin yüklenmesinin sağlanması gerekir. dlopen fonksiyonunun 
    prototipi şöyledir:

    #include <dlfcn.h>

    void *dlopen(const char *filename, int flag);

    Fonksiyonun birinci parametresi yüklenecek dinamik kütüphanenin yol ifadesini, ikinci parametresi seçenek belirten bayrakları 
    almaktadır. Fonksiyon başarı durumunda kütüphaneyi temsil eden bir handle değerine, başarısızlık durumunda NULL adrese geri 
    dönmektedir. Başarısızlık durumunda fonksiyon errno değişkenini set etmez. Başarısızlığa ilişkin yazı doğrudan dlerror 
    fonksiyonuyla elde edilmektedir:

    char *dlerror(void);

    dlopen fonksiyonunun birinci parametresindeki dinamik kütüphane isminde eğer hiç / karakteri yoksa bu durumda kütüphanenin 
    aranması daha önce ele aldığımız prosedüre göre yapılmaktadır. Eğer dosya isminde en az bir / karakteri varsa dosya yalnızca 
    bu mutlak ya da göreli yol ifadesinde aranmaktadır. Dinamik yükleme sırasında yüklenecek kütüphanenin SONAME alanında yazılan 
    isme hiç bakılmamaktadır. (Bu SONAME alanındaki isim yalnızca link aşamasında linker tarafından kullanılmaktadır.)

    Örneğin:

    void *dlh;

    if ((dlh = dlopen("libmyutil.so.1.0.0", RTLD_NOW)) == NULL) {
        fprintf(stderr, "dlopen: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    Burada dlopen fonksiyonunun ikinci parametresine RTLD_NOW bayrağı geçilmiştir. Bu bayrağın etkisi izleyen paragraflarda ele
    alınacaktır.

    Kütüphanenin adres alanından boşaltılması ise dlclose fonksiyonuyla yapılmaktadır:

    #include <dlfcn.h>

    int dlclose(void *handle);

    Aynı kütüphane dlopen fonksiyonu ile ikinci kez yüklenebilir. Bu durumda gerçek bir yükleme yapılmaz. Ancak yüklenen 
    sayıda close işleminin yapılması gerekmektedir.

    Kütüphanenin içerisindeki fonksiyonlar ya da global nesneler adresleri elde edilerek kullanılırlar. Bunların adreslerini 
    elde edebilmek için dlsym isimli fonksiyon kullanılmaktadır:

    #include <dlfcn.h>

    void *dlsym(void *handle, const char *symbol);

    Fonksiyon başarı durumunda ilgili sembolün adresine, başarısızlık durumunda NULL adrese geri döner. Örneğin:

    double (*padd)(double, double);
    ...

    if ((padd = (double (*)(double, double))(dlsym(dlh, "add")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    result = padd(10, 20);
    printf("%f\n", result);

    Ancak burada C standartları bağlamında bir pürüz vardır. C'de (ve tabii C++'ta) fonksiyon adresleri ile data adresleri tür
    dönüştürme operatörü ile bile dönüştürülememektedir. Yani yukarıdaki tür dönüştürmesi ile atama geçersizdir. Ayrıca void * türü
    data adresi için anlamlıdır. Yani biz C'de de C++'ta da void bir adresi fonksiyon göstericisine, fonksiyon adresini de 
    void bir göstericiye atayamayız. Ancak pek çok derleyici default durumda bu biçimdeki dönüştürmeleri kabul etmektedir. Yani 
    yukarıdaki kod aslında C'de geçersiz olmasına karşın gcc ve clang derleyicilerinde sorunsuz derlenecektir. (Derleme sırasında 
    -pedantic-errors seçeneği kullanılırsa derleyiciler standartlara uyumu daha katı bir biçimde ele almaktadır. Dolayısıyla 
    yukarıdaki kod bu seçenek kullanılarak derlenirse error oluşacaktır.) Pekiyi bu durumda ne yapabiliriz? İşte bunun için bir 
    hile vardır. Fonksiyon göstericisinin adresini alırsak artık o bir data göstericisi haline gelir. Bir daha * kullanırsak 
    data göstericisi gibi aslında fonksiyon göstericisinin içerisine değer atayabiliriz. Örneğin:

    if ((*(void **)&padd = dlsym(dlh, "add")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    Sembol isimleri konusunda dikkat etmek gerekir. Çünkü bazı derleyiciler bazı koşullar altında isimleri farklı isim gibi 
    object dosyaya yazabilmektedir. Buna "name decoration" ya da "name mangling" denilmektedir. Örneğin C++ derleyicileri 
    fonksiyon isimlerini parametrik yapıyla kombine ederek başka bir isimle object dosyaya yazar. Halbuki dlsym fonksiyonunda 
    sembolün dinamik kütüphanedeki dekore edilmiş isminin kullanılması gerekmektedir. Sembollerin dekore edilmiş isimlerini 
    elde edebilmek için "nm" utility'sini kullanabilirsiniz. Örneğin:

    $ nm libmyutil.so.1.0.0

    nm utility'si ELF formatının string tablosunu görüntülemektedir. Aynı işlem readelf programında -s ile de yapılabilir:

    $ readelf -s libmyutil.so.1.0.0

    Aşağıda bir dinamik kütüphane dinamik olarak yüklenmiş ve oradan bir fonksiyon ve data adresi alınarak kullanılmıştır. 
    Buradaki dinamik kütüphaneyi daha önce yaptığımız gibi derleyebilirsiniz:

    $ gcc -fPIC -shared -o libmyutil.so.1.0.0 -Wl,-soname,libmyutil.so.1 libmyutil.c
---------------------------------------------------------------------------------------------------------------------------*/

/* libmyutil.c */

#include <stdio.h>

double add(double a, double b)
{
    return a + b;
}

double sub(double a, double b)
{
    return a - b;
}

double multiply(double a, double b)
{
    return a * b;
}

double divide(double a, double b)
{
    return a / b;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

typedef double (*PROC)(double, double);

int main(void)
{
    void *dlh;
    PROC padd, psub, pmul, pdiv;
    double result;

    if ((dlh = dlopen("libmyutil.so.1.0.0", RTLD_NOW)) == NULL) {
        fprintf(stderr, "dlopen: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    if ((*(void **)&padd = dlsym(dlh, "add")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    result = padd(10, 20);
    printf("%f\n", result);

    if ((*(void **)&psub = dlsym(dlh, "sub")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    result = psub(10, 20);
    printf("%f\n", result);

    if ((*(void **)&pmul = dlsym(dlh, "multiply")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    result = pmul(10, 20);
    printf("%f\n", result);

    if ((*(void **)&pdiv = dlsym(dlh, "divide")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    result = pdiv(10, 20);
    printf("%f\n", result);

    dlclose(dlh);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphane dlopen fonksiyonuyla yüklenirken global değişkenlerin ve fonksiyonların nihai yükleme adresleri bu dlopen 
    işlemi sırasında hesaplanabilir ya da onlar kullanıldıklarında hesaplanabilir. İkisi arasında kullanıcı açısından bir fark 
    olmamakla birlikte tüm sembollerin adreslerinin yükleme sırasında hesaplanması bazen yükleme işlemini (eğer çok sembol varsa) 
    uzatabilmektedir. Bu durumu ayarlamak için dlopen fonksiyonunun ikinci parametresi olan flags parametresi kullanılır. Bu flags 
    parametresi RTLD_NOW olarak girilirse (yukarıdaki örnekte böyle yaptık) tüm sembollerin adresleri dlopen sırasında, RTLD_LAZY 
    girilirse kullanıldıkları noktada hesaplanmaktadır. İki biçim arasında çoğu kez programcı için bir farklılık oluşmamaktadır. 
    Ancak aşağıdaki örnekte bu iki biçimin ne anlama geldiği gösterilmektedir.

    Aşağıdaki örnekte "libmyutil.so.1.0.0" kütüphanesindeki foo fonksiyonu gerçekte olmayan bir bar fonksiyonunu çağırmıştır. Bu 
    fonksiyonun gerçekte olmadığı foo fonksiyonunun sembol çözümlemesi yapıldığında anlaşılacaktır. İşte eğer bu kütüphaneyi 
    kullanan "app.c" programı kütüphaneyi RTLD_NOW ile yüklerse tüm semboller o anda çözülmeye çalışılacağından dolayı bar 
    fonksiyonunun bulunmuyor olması hatası da dlopen sırasında oluşacaktır. Eğer kütüphane RTLD_LAZY ile yüklenirse bu durumda 
    sembol çözümlemesi foo'nun kullanıldığı noktada (yani dlsym fonksiyonunda) gerçekleşecektir. Dolayısıyla hata da o noktada 
    oluşacaktır. Bu programı RTLD_NOW ve RTLD_LAZY bayraklarıyla ayrı ayrı derleyip çalıştırınız.
---------------------------------------------------------------------------------------------------------------------------*/

/* libmyutil.c */

#include <stdio.h>

void bar(void);

void foo(void)
{
    bar();
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

int main(void)
{
    void *dlh;
    void (*pfoo)(void);
    double result;

    if ((dlh = dlopen("libmyutil.so.1.0.0", RTLD_LAZY)) == NULL) {
        fprintf(stderr, "dlopen: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    printf("dlopen called\n");

    if ((*(void **)&pfoo = dlsym(dlh, "foo")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    pfoo();

    dlclose(dlh);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                125. Ders 03/03/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bazen bir dinamik kütüphane içerisindeki sembollerin o dinamik kütüphaneyi kullanan kodlar tarafından kullanılması istenmeyebilir. 
    Örneğin dinamik kütüphanede "bar" isimli bir fonksiyon vardır. Bu fonksiyon bu dinamik kütüphanenin kendi içerisinden başka 
    fonksiyonlar tarafından kullanılıyor olabilir. Ancak bu fonksiyonun dinamik kütüphanenin dışından kullanılması istenmeyebilir.
    (Bunun çeşitli nedenleri olabilir. Örneğin kapsülleme sağlamak için, dışarıdaki sembol çakışmalarını ortadan kaldırmak için vs.) 
    İşte bunu sağlamak amacıyla gcc ve clang derleyicilerine özgü "__attribute__((...))" eklentisinden faydalanılmaktadır. "__attribute__((...))" 
    eklentisi pek çok seçeneğe sahip platform spesifik bazı işlemlere yol açmaktadır. Bu eklentinin seçeneklerini gcc dokümanlarından 
    elde edebilirsiniz. Bizim bu amaçla kullanacağımız "__attribute__((...))" seçeneği "visibility" isimli seçenektir.

    Aşağıdaki örnekte bar fonksiyonu foo fonksiyonu tarafından kullanılmaktadır. Ancak kütüphanenin dışından bu fonksiyonun 
    kullanılması istenmemiştir. Eğer fonksiyon isminin soluna "__attribute__((visibility("hidden")))" yazılırsa bu durumda 
    bu fonksiyon dinamik kütüphanenin dışından herhangi bir biçimde kullanılamaz. Örneğin:

    void __attribute__((visibility("hidden"))) bar(void)
    {
        // ...
    }

    Burada fonksiyon özelliğinin (yani __attribute__ sentaksının) fonksiyon isminin hemen soluna getirildiğine ve çift parantez 
    kullanıldığına dikkat ediniz. Burada kullanılan özellik "visibility" isimli özelliktir ve bu özelliğin değeri "hidden" 
    biçiminde verilmiştir.

    Aşağıdaki örnekte "libmyutil.so.1.0.0" kütüphanesindeki foo fonksiyonu dışarıdan çağrılabildiği halde bar fonksiyonu 
    dışarıdan çağrılamayacaktır. Tabii kütüphane içerisindeki foo fonksiyonu bar fonksiyonunu çağırabilmektedir. Dosyaları
    aşağıdaki gibi derleyebilirsiniz:

    $ gcc -shared -fPIC -Wl,-soname,libmyutil.so.1 -o libmyutil.so.1.0.0 libmyutil.c
    $ gcc -o app app.c libmyutil.so.1.0.0 -ldl
---------------------------------------------------------------------------------------------------------------------------*/

/* libmyutil.c */

#include <stdio.h>

void __attribute__((visibility("hidden"))) bar(void)
{
    printf("bar\n");
}

void foo(void)
{
    printf("foo\n");

    bar();
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

int main(void)
{
    void *dlh;
    void (*pfoo)(void);
    void (*pbar)(void);
    double result;

    if ((dlh = dlopen("./libmyutil.so.1.0.0", RTLD_NOW)) == NULL) {
        fprintf(stderr, "dlopen: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    if ((*(void **)&pfoo = dlsym(dlh, "foo")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    pfoo();

    if ((*(void **)&pbar = dlsym(dlh, "bar")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    pbar();

    dlclose(dlh);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi dinamik kütüphaneyi dinamik yüklemeyip normal yöntemle kullansaydık ne olacaktı? İşte bu durumda hata, programı link
    ederken oluşmaktadır. Örneğin:

    $ gcc -shared -fPIC -Wl,-soname,libmyutil.so.1 -o libmyutil.so.1.0.0 libmyutil.c
    $ gcc -o app app.c libmyutil.so.1.0.0 -ldl
    /usr/bin/ld: /tmp/ccK2cCXC.o: in function `main':
    app.c:(.text+0xe): undefined reference to `bar'
    collect2: error: ld returned 1 exit status

    Bu testi yapabilmek için app.c programı şöyle olabilir:

    #include <stdio.h>

    void __attribute__((visibility("hidden"))) bar(void)
    {
        printf("bar\n");
    }

    void foo(void)
    {
        printf("foo\n");

        bar();
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir dinamik kütüphane normal olarak ya da dinamik olarak yüklendiğinde birtakım ilk işlerin yapılması gerekebilir. (Örneğin
    kütüphane thread güvenli olma iddiasındadır ve birtakım senkronizasyon nesnelerinin ve thread'e özgü alanların yaratılması 
    gerekebilir.) Bunun için gcc ve clang derleyicilerine özgü olan __attribute__((constructor)) fonksiyon özelliği (function 
    attribute) kullanılmaktadır. Benzer biçimde dinamik kütüphane programın adres alanından boşaltılırken de birtakım son işlemler 
    için __attribute__((destructor)) ile belirtilen fonksiyon çağrılmaktadır. (Aslında bu "constructor" ve "destructor" fonksiyonları 
    normal programlarda da kullanılabilir. Bu durumda ilgili fonksiyonlar main fonksiyonundan önce ve main fonksiyonundan sonra 
    çağrılmaktadır.) Dinamik kütüphane birden fazla kez yüklendiğinde yalnızca ilk yüklemede toplamda bir kez constructor 
    fonksiyonu çağrılmaktadır. Benzer biçimde destructor fonksiyonu da yalnızca bir kez çağrılır.

    Aşağıda normal bir programda __attribute__((constructor)) ve __attribute__((destructor)) fonksiyon özelliklerinin 
    kullanımına bir örnek verilmiştir. Ekranda şunları göreceksiniz:

    constructor foo begins...
    constructor foo ends...
    main begins...
    main ends...
    destructor bar begins...
    destructor bar ends...
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>

void __attribute__((constructor)) foo(void)
{
    printf("constructor foo begins...\n");
    printf("constructor foo ends...\n");
}

void __attribute__((destructor)) bar(void)
{
    printf("destructor bar begins...\n");
    printf("destructor bar ends...\n");
}

int main(void)
{
    printf("main begins...\n");

    printf("main ends...\n");

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda da dinamik kütüphane içerisinde __attribute__((constructor)) ve __attribute__((destructor)) fonksiyon özelliklerinin
    kullanımına bir örnek verilmiştir. Derlemeyi aşağıdaki gibi yapabilirsiniz:

    $ gcc -shared -fPIC -Wl,-soname,libmyutil.so.1 -o libmyutil.so.1.0.0 libmyutil.c
    $ gcc -o app app.c libmyutil.so.1.0.0 -ldl

    Kütüphaneye "so ismi" verdiğimiz için sembolik link oluşturmayı unutmayınız:

    $ ln -s libmyutil.so.1.0.0 libmyutil.so.1

    Programı çalıştırmadan önce LD_LIBRARY_PATH çevre değişkenini de ayarlayınız:

    $ export LD_LIBRARY_PATH=.
---------------------------------------------------------------------------------------------------------------------------*/

/* libmyutil.c */

#include <stdio.h>

void __attribute__((constructor)) constructor(void)
{
    printf("constructor begins...\n");
    printf("constructor ends...\n");
}

void __attribute__((destructor)) destructor(void)
{
    printf("destructor begins...\n");
    printf("destructor ends...\n");
}

void foo(void)
{
    printf("foo\n");
}

/* app.c */

#include <stdio.h>

void foo(void);

int main(void)
{
    foo();

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir kütüphane oluşturmak isteyen kişi kütüphanesi için en azından bir başlık dosyasını kendisi oluşturmalıdır. Çünkü
    kütüphane içerisindeki fonksiyonları kullanacak kişiler en azından onların prototiplerini bulundurmak zorunda kalacaklardır. 
    Kütüphaneler için oluşturulacak başlık dosyalarında kütüphane için anlamlı sembolik sabitler, fonksiyon prototipleri,
    inline fonksiyon tanımlamaları, typedef bildirimleri gibi "nesne yaratmayan" bildirimler bulunmalıdır. Başlık dosyalarında
    include korumasının yapılması unutulmamalıdır.

    Aşağıda kütüphane için bir başlık dosyası oluşturma örneği verilmiştir. Örneği aşağıdaki gibi derleyebilirsiniz:

    $ gcc -shared -fPIC -Wl,-soname,libmyutil.so.1 -o libmyutil.so.1.0.0 libmyutil.c
    $ gcc -o app app.c libmyutil.so.1.0.0

    Sembolik bağlantı yoksa aşağıdaki gibi yaratabilirsiniz:

    $ ln -s libmyutil.so.1.0.0 libmyutil.so.1
---------------------------------------------------------------------------------------------------------------------------*/

/* util.h */

#ifndef UTIL_H_
#define UTIL_H_

/* Function prototypes */

void foo(void);
void bar(void);

#endif

/* libmyutil.c */

#include <stdio.h>
#include "util.h"

void foo(void)
{
    printf("foo\n");
}

void bar(void)
{
    printf("bar\n");
}

/* app.c */

#include <stdio.h>
#include "util.h"

int main(void)
{
    foo();
    bar();

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    C++'ta yazılmış kodların da kütüphane biçimine getirilmesinde farklı bir durum yoktur. Sınıfların bildirimleri başlık 
    dosyalarında bulundurulur. Bunlar yine C++ derleyicisi ile (g++ ya da clang++) derlenir. Aynı biçimde kullanılır.

    Aşağıda C++'ta yazılmış olan bir sınıfın dinamik kütüphaneye yerleştirilmesi ve oradan kullanılmasına bir örnek verilmiştir. 
    Derleme işlemlerini şöyle yapabilirsiniz:

    $ g++ -shared -fPIC -Wl,-soname,libmyutil.so.1 -o libmyutil.so.1.0.0 libmyutil.cpp
    $ g++ -o app app.cpp libmyutil.so.1.0.0
---------------------------------------------------------------------------------------------------------------------------*/

/* util.hpp */

#ifndef UTIL_HPP_
#define UTIL_HPP_

/* Function prototypes */

namespace CSD {
    class Date {
    public:
        Date() = default;
        Date(int day, int month, int year);
        void disp() const;
    private:
        int m_day;
        int m_month;
        int m_year;
    };
}

#endif

/* libmyutil.cpp */

#include <iostream>
#include "util.hpp"

namespace CSD
{
    Date::Date(int day, int month, int year)
    {
        m_day = day;
        m_month = month;
        m_year = year;
    }

    void Date::disp() const
    {
        std::cout << m_day << '/' << m_month << '/' << m_year << std::endl;
    }
}

/* app.cpp */

#include <iostream>
#include "util.hpp"

using namespace CSD;

int main()
{
    Date d{10, 12, 2009};

    d.disp();

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir projeyi tek bir kaynak dosya biçiminde organize etmek iyi bir teknik değildir. Böylesi bir durumda dosyada küçük bir
    değişiklik yapıldığında bile tüm kaynak dosyanın yeniden derlenmesi gerekmektedir. Aynı zamanda bu biçim kodun güncellenmesini 
    de zorlaştırmaktadır. Proje tek bir kaynak dosyada olduğu için bu durum grup çalışmasını da olumsuz yönde etkilemektedir. 
    Bu nedenle projeler birden fazla "C ya da C++" kaynak dosyası biçiminde organize edilir. Örneğin 10000 satırlık bir proje
    app1.c, app2.c, app3.c, ..., app10.c biçiminde 10 farklı kaynak dosya biçiminde oluşturulmuş olsun. Pekiyi build işlemi bu 
    durumda nasıl yapılacaktır. Build işlemi için önce her dosya bağımsız olarak "-c" seçeneği ile derlenip ".o" uzantılı "amaç 
    dosya (object module)" haline getirilir. Sonra bu dosyalar link aşamasında birleştirilir. Örneğin:

    $ gcc -c app1.c
    $ gcc -c app2.c
    $ gcc -c app3.c
    ...
    $ gcc -c app10.c

    $ gcc -o app app1.o app2.o app3.o ... app10.o

    Bu çalışma biçiminde bir kaynak dosyada değişiklik yapıldığında yalnızca değişikliğin yapılmış olduğu kaynak dosya yeniden
    derlenir ancak link işlemine yine tüm amaç dosyalar dahil edilir. Örneğin app3.c üzerinde bir değişiklik yapmış olalım:

    $ gcc -c app3.c
    $ gcc -o app app1.o app2.o app3.o ... app10.o

    İşte bu sıkıcı işlemi ortadan kaldırmak ve build işlemini otomatize etmek için "build otomasyon araçları (build automation 
    tools)" denilen araçlar geliştirilmiştir. Bunların en eskisi ve yaygın olanı "make" isimli araçtır. make aracının yanı sıra 
    "cmake" gibi "qmake" gibi daha yüksek seviyeli build araçları da zamanla geliştirilmiştir. make aracı pek çok sistemde 
    benzer biçimde bulunmaktadır. Bugün UNIX/Linux sistemlerinde "GNU make" aracı kullanılmaktadır. Microsoft klasik make
    aracının "nmake" ismiyle başka versiyonunu geliştirmiştir. Ancak Microsoft uzun bir süredir "msbuild" denilen başka bir
    build sistemini kullanmaktadır. Örneğin Microsoft'un Visual Studio IDE'si arka planda bu "msbuild" aracını kullanmaktadır. 
    Qt Framework'ünde "qmake" isimli üst düzey make aracı kullanılmaktadır. Bazı IDE'ler "cmake" kullanmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                126. Ders 10/03/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    En fazla kullanılan build otomasyon aracı "make" isimli araçtır. make aracını kullanmak için ismine "make dosyası" denilen
    bir dosya oluşturulur. Sonra bu dosya "make" isimli program ile işletilir. Dolayısıyla make aracının kullanılması için make 
    dosyalarının nasıl oluşturulduğunun bilinmesi gerekir. Make dosyaları aslında kendine özgü bir dil ile oluşturulmaktadır. 
    Bu make dilinin kendi sentaksı ve semantiği vardır. make aracı için çeşitli kitaplar ve öğretici dokümanlar (tutorials)
    oluşturulmuştur. Orijinal dokümanlarına aşağıdaki bağlantıdan erişilebilir:

    https://www.gnu.org/software/make/manual/

    Yukarıda da belirttiğimiz gibi "make" aracı değişik sistemlerde birbirine benzer biçimde bulunmaktadır. Microsoft'un make
    aracına "nmake" denilmektedir. GNU Projesi kapsamında bu make aracı yeniden yazılmıştır. Bugün ağırlıklı olarak GNU projesindeki
    make aracı kullanılmaktadır. Bu araca "GNU Make" de denilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir make dosyası "kurallardan (rules)" oluşmaktadır. Bir kuralın (rule) genel biçimi şöyledir:

    hedef (target) : ön_koşullar (prerequisites)
        işlemler (recipes)

    Örneğin:

    app: a.o b.o c.o
        gcc -o app a.o b.o c.o

    Burada "app" hedefi, "a.o b.o c.o" ön koşulları ve "gcc -o app a.o b.o c.o" satırı da "işlemleri (recipes)" belirtmektedir. 
    Hedef genellikle bir tane olur. Ancak ön koşullar birden fazla olabilir. İşlemler tek bir satırdan oluşmak zorunda değildir. 
    Eğer birden fazla satırdan oluşacaksa satırlar alt alta yazılır. İşlemler belirtilirken yukarıdaki satırdan bir TAB içeriye
    girinti verilmek zorundadır. Örneğin:

    app: a.o b.o c.o
    <TAB>gcc -o app a.o b.o c.o

    Kuraldaki hedef ve ön koşullar tipik olarak birer dosyadır. Kuralın anlamı şöyledir: Ön koşullarda belirtilen dosyaların 
    herhangi birinin tarih ve zamanı, hedefte belirtilen dosyanın tarih ve zamanından ileri ise (yani bunlar güncellenmişse)
    bu durumda belirtilen işlemler yapılır. Yukarıdaki kuralı yeniden inceleyiniz:

    app: a.o b.o c.o
        gcc -o app a.o b.o c.o

    Burada eğer "a.o" ya da "b.o" ya da "c.o" dosyalarının tarih ve zamanı "app" dosyasının tarih ve zamanından ilerideyse
    aşağıdaki kabuk komutu çalıştırılacaktır:

    $ gcc -o app a.o b.o c.o

    Bu link işlemi anlamına gelir. Link işleminden sonra artık "app" dosyasının tarih ve zamanı ön koşul dosyalarından daha
    ileride olacağı için kural "güncel (up to date)" hale gelir. Artık bu kural işletildiğinde bu link işlemi yapılmayacaktır. 
    Bu link işleminin yeniden yapılabilmesi için "a.o" ya da "b.o" ya da "c.o" dosyalarında güncelleme yapılmış olması gerekir. 
    Bu dosyalar derleme işlem sonucunda oluşacağına göre bu dosyaların güncellenmesi aslında bunlara ilişkin ".c" dosyalarının 
    derlenmesiyle olabilir. Şimdi aşağıdaki kuralları yazalım:

    a.o: a.c
        gcc -c a.c

    b.o: b.c
        gcc -c b.c

    c.o: c.c
        gcc -c c.c

    Bu kurallar "ilgili .c dosyalarında bir değişiklik olduğunda onları yeniden derle" anlamına gelmektedir. Şimdi önceki kuralla
    bu kuralları bir araya getirelim:

    app: a.o b.o c.o
        gcc -o app a.o b.o c.o
    a.o: a.c
        gcc -c a.c
    b.o: b.c
        gcc -c b.c
    c.o: c.c
        gcc -c c.c

    make programı çalıştırıldığında önce program make dosyasından hareketle bir "bağımlılık grafı (dependency graph)" 
    oluşturmaktadır. Bağımlılık grafı "hangi dosya hangi dosyanın durumuna bağlı" biçiminde oluşturulan bir graftır. 
    Yukarıdaki örnekte "a.o", "b.o" ve "c.o" dosyaları aşağıdaki kurallara bağımlıdır. Daha sonra make programı sırasıyla 
    bu grafa uygun olarak aşağıdan yukarıya kuralları işletmektedir. Yukarıdaki örnekte birinci kural ikinci, üçüncü
    ve dördüncü kurallara bağımlıdır. Dolayısıyla önce bu kurallar işletilip daha sonra birinci kural işletilir. Böylece bu
    make dosyasından şöyle sonuç çıkmaktadır: "Herhangi bir .c dosya değiştirildiğinde onu derle ve hep birlikte link işlemi 
    yap".

    Kuralın hedefindeki dosya yoksa koşulun sağlandığı kabul edilmektedir. Yani bu durumda ilgili işlemler yapılacaktır. 
    Yukarıdaki örnekte "object dosyalarını silersek" bu durumda derleme işlemlerinin hepsi yapılacaktır. Normal olarak her 
    ön koşul dosyasının bir hedefle ilişkili olması beklenir. Yani ön koşulda belirtilen dosyaların var olması gerekmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    make dosyası hazırlandıktan sonra make programı ile dosya işletilir. make programı işletilecek dosyayı "-f" ya da "--file" 
    seçeneği ile komut satırı argümanından almaktadır. Örneğin:

    $ make -f project.mak

    Ancak -f seçeneği kullanılmazsa make programı sırasıyla "GNUmakefile", "makefile" ve "Makefile" dosyalarını aramaktadır. 
    GNU dünyasındaki genel eğilim projenin make dosyasının "Makefile" biçiminde isimlendirilmesidir. Açık kaynak kodlu bir 
    yazılımda projenin make dosyasının da verilmiş olması beklenir. Böylece kaynak kodları elde eden kişiler yeniden derlemeyi
    komut satırında "make" yazarak yapabilirler.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında make programı çalıştırılırken program belli bir hedefi gerçekleştirmek için işlem yapar. Gerçekleştirilecek 
    hedef make programında komut satırı argümanı olarak verilmektedir. Eğer hedef belirtilmezse ilk hedef gerçekleştirilmeye 
    çalıştırılır. Örneğin:

    # Makefile

    app: a.o b.o c.o
        gcc -o app a.o b.o c.o
    a.o: a.c
        gcc -c a.c
    b.o: b.c
        gcc -c b.c
    c.o: c.c
        gcc -c c.c

    project: project.c
        gcc -o project project.c

    Burada birbirinden bağımsız iki hedef vardır: app ve project. Biz make programını hedef belirtmeden çalıştırırsak ilk 
    hedef gerçekleştirilmeye çalışılır. Ancak belli bir hedefin de gerçekleştirilmesini sağlayabiliriz. Örneğin:

    $ make project
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir kuralda ön koşul yoksa kuralın sağlandığı varsayılmaktadır. Yani bu durumda doğrudan belirtilen işlemler (recipes) 
    yapılır. Örneğin:

    clean:
        rm -f *.o

    Burada make programını aşağıdaki gibi çalıştırmış olalım:

    $ make clean

    Bu durumda tüm ".o" dosyaları silinecektir. Örneğin:

    # Makefile

    app: a.o b.o c.o
        gcc -o app a.o b.o c.o
    a.o: a.c
        gcc -c a.c
    b.o: b.c
        gcc -c b.c
    c.o: c.c
        gcc -c c.c

    clean:
        rm -f *.o

    install:
        sudo cp app /usr/local/bin

    Burada "clean" hedefi rebuild işlemi için object dosyaları silmektedir. "install" hedefi ise elde edilen programı belli 
    bir yere kopyalamaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir kaynak dosya bir başlık dosyasını kullanıyorsa bağımlılıkta bu başlık dosyasının da belirtilmesi uygun olur. Çünkü
    bu başlık dosyasında bir güncelleme yapıldığında bu kaynak dosyanın da yeniden derlenmesi beklenir. Örneğin:

    a.o: a.c app.h
        gcc -c app.c

    Burada artık app.h dosyası üzerinde bir değişiklik yapıldığında derleme işlemi yeniden yapılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                127. Ders 15/03/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    make dosyasına dışarıdan parametre aktarabiliriz. Bunun için komut satırında "değişken=değer" sentaksı kullanılmaktadır. 
    Burada geçirilen değer ${değişken} ifadesi ile make dosyasının içerisinden kullanılabilir. Örneğin:

    # Makefile

    ${executable}: a.o b.o c.o
        gcc -o app a.o b.o c.o
    a.o: a.c
        gcc -c a.c
    b.o: b.c
        gcc -c b.c
    c.o: c.c app.h
        gcc -c c.c

    clean:
        rm -f *.o

    install:
        sudo cp app /usr/local/bin

    Burada executable dosyanın hedefi komut satırından elde edilmektedir. Örneğin biz make programını şöyle çalıştırabiliriz:

    $ make executable=app

    Bu durumda "app" dosyası hedef olarak ele alınacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Make dosyası içerisinde değişkenler kullanılabilmektedir. Bir değişken "değişken = değer" sentaksıyla oluşturulur ve 
    make dosyasının herhangi bir yerinde ${değişken} biçiminde kullanılır. Örneğin:

    # Makefile

    CC = gcc
    OBJECTS = a.o b.o c.o
    INSTALL_DIR = /usr/local/bin
    APP_NAME = app

    ${APP_NAME}: ${OBJECTS}
        ${CC} -o app a.o b.o c.o
    a.o: a.c
        ${CC} -c a.c
    b.o: b.c
        ${CC} -c b.c
    c.o: c.c app.h
        gcc -c c.c

    clean:
        rm -f ${OBJECTS}
    install:
        sudo cp ${APP_NAME} ${INSTALL_DIR}
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir C programını derlediğimizde link işlemi için bir main fonksiyonunun bulunması gerekmektedir. Aslında GNU'nun linker
    programının ismi "ld" isimli programdır. gcc zaten bu ld linker'ını çalıştırmaktadır. Bir programın link edilebilmesi için 
    aslında main fonksiyonunun bulunması gerekmez. main fonksiyonu assembly düzeyinde anlamlı bir fonksiyon değildir. C için 
    anlamlı bir fonksiyondur. Yani örneğin biz bir assembly programı yazarsak onu istediğimiz yerden çalışmaya başlatabiliriz. 
    Bir dosya "executable" olarak link edilirken tek gerekli olan şey "entry point" denilen akışın başlatılacağı noktadır. Entry 
    point ld linker'ında "--entry" seçeneği ile belirtilmektedir. Biz bir C programını gcc ile derlediğimizde gcc aslında ld 
    linker'ını çağırırken ismine "start-up modüller" denilen bir grup modülü de link işlemine gizlice dahil etmektedir. Programın 
    gerçek entry point'i bu start-up modül içerisinde bir yerdedir. Aslında main fonksiyonunu bu start-up modül çağırmaktadır. 
    Bu start-up modülün görevi birtakım hazırlık işlemlerini yapıp komut satırı argümanlarıyla main fonksiyonunu çağırmaktır. 
    Zaten akış main fonksiyonunu bitirdiğinde yeniden start-up modüldeki koda döner orada exit işlemi yapılmıştır. Start-up modülün 
    kodlarını şöyle düşünebilirsiniz:

    ...
    ...
    ...
    call main
    call exit

    O halde link aşamasına bu start-up modül katıldığı için aslında main isimli bir fonksiyon aranmaktadır. Yani start-up modül 
    main fonksiyonunu çağırmasaydı linker onu aramayacaktı.

    Biz aslında hiçbir kütüphaneyi link aşamasına dahil etmeden programın entry-point'ini kendimiz belirleyerek akışı istediğimiz
    fonksiyondan başlatabiliriz. Tabii bu durumda sistem fonksiyonlarını bile sembolik makine dilinde ya da gcc'nin inline 
    sembolik makine dilinde kendimizin yazması gerekecektir. Aşağıda böyle bir örnek verilmiştir. Buradaki programın isminin 
    "x.c" olduğunu varsayalım. Bu programı aşağıdaki gibi derleyip link edebilirsiniz:

    $ gcc -c x.c
    $ ld -o x x.o --entry=foo
---------------------------------------------------------------------------------------------------------------------------*/

/* x.c */

#include <unistd.h>
#include <stdint.h>
#include <asm/unistd.h>

ssize_t my_write(int fd, const void *buf, size_t size)
{
    register int64_t rax __asm__ ("rax") = 1;
    register int rdi __asm__ ("rdi") = fd;
    register const void *rsi __asm__ ("rsi") = buf;
    register size_t rdx __asm__ ("rdx") = size;

    __asm__ __volatile__ (
        "syscall"
        : "+r" (rax)
        : "r" (rdi), "r" (rsi), "r" (rdx)
        : "rcx", "r11", "memory"
    );

    return rax;
}

void my_exit(int status)
{
    __asm__ __volatile__
     (
        "movl $60, %%eax\n\t"
        "movl %0, %%edi\n\t"
        "syscall"
        :
        : "g" (status)
        : "eax", "edi", "cc"
     );
}

void foo()
{
    my_write(1, "this is a test\n", 15);
    my_exit(0);
}

/*--------------------------------------------------------------------------------------------------------------------------
    O anda makinemizdeki işletim sistemi hakkındaki bilgi "uname" komutuyla elde edilebilir. Bu komut -r ile kullanılırsa o 
    makinede yüklü olan kernel versiyonu elde edilmektedir. Örneğin:

    $ uname -r
    4.15.0-20-generic
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kernel'ın bir parçası gibi işlev gören, herhangi bir koruma engeline takılmayan, kernel mode'da çalışan özel olarak hazırlanmış 
    modüllere (yani kod parçalarına) Linux dünyasında "kernel modülleri (kernel modules)" denilmektedir. Kernel modülleri 
    eğer kesme gibi bazı mekanizmaları kullanıyorsa ve bir donanım aygıtını yönetme iddiasındaysa bunlara özel olarak "aygıt 
    sürücüleri (device drivers)" da denilmektedir. Nasıl bir masaüstü bilgisayara kart taktığımızda artık o kart donanımın 
    bir parçası haline geliyorsa kernel modülleri ve aygıt sürücüleri de install edildiklerinde adeta kernel'ın bir parçası 
    haline gelmektedir. Her aygıt sürücü bir kernel modülüdür ancak her kernel modülü bir aygıt sürücü değildir. Bu nedenle
    biz yalnızca "kernel modülü" dediğimizde genel olarak aygıt sürücüleri de dahil etmiş olacağız.

    Biz bu bölümde Linux sistemleri için kernel modüllerinin ve aygıt sürücülerinin nasıl yazılacağını ele alacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kernel modülleri ve aygıt sürücüler genel bir konu değildir. Her işletim sisteminin o sisteme özgü bir aygıt sürücü mimarisi
    vardır. Hatta bu mimari işletim sisteminin versiyonundan versiyonuna da değişebilmektedir. Bu nedenle aygıt sürücü yazmak
    genel bir konu değil, o işletim sistemine hatta işletim sisteminin belirli versiyonlarına özgü bir konudur.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdek modüllerinde ve aygıt sürücülerde her türlü fonksiyon kullanılamaz. Bunları yazabilmek için özel başlık dosyalarına 
    ve ve amaç dosyalara gereksinim duyulmaktadır. Bu nedenle ilk yapılacak şey bu başlık dosyalarının ve kütüphanelerin ilgili 
    sisteme yüklenmesidir.

    Genellikle bir Linux sistemini yüklediğimizde zaten çekirdek modüllerini ve aygıt sürücüleri oluşturabilmek için gereken 
    başlık dosyaları ve diğer gerekli öğeler zaten "/usr/src" dizini içerisindeki "linux-headers-$(uname -r)" dizininde yüklü 
    biçimde bulunmaktadır. Ancak bunlar yüklü değilse Debian tabanlı sistemlerde bunları şöyle yükleyebilirsiniz:

    $ sudo apt install linux-headers-$(uname -r)

    Tabii programcı o anda çalışılan çekirdeğin kodlarının hepsini de kendi makinesine indirmek isteyebilir. Bunun için aşağıdaki 
    komut kullanılabilir:

    $ sudo apt-get install linux-source

    Bu indirmeler "/usr/src" dizinine yapılmaktadır.

    Ayrıca "/lib/modules/$(uname -r)" isimli dizindeki "build" isimli dizin de çekirdek kaynak kodlarının bulunduğu dizine ya da 
    aygıt sürücülerin derlenmesi için gereken öğelerin bulunduğu dizine (tipik olarak "linux-headers-$(uname -r)" dizinine) 
    sembolik link yapılmış durumdadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir çekirdek modülünde biz user mod için yazılmış kodları kullanamayız. Çünkü orası ayrı bir dünyadır. Ayrıca biz çekirdek 
    modüllerinde çekirdek içerisindeki her fonksiyonu da kullanamayız. Yalnızca bazı fonksiyonları kullanabiliriz. Bunlara 
    "çekirdek tarafından export edilmiş fonksiyonlar" denilmektedir. "Çekirdek tarafından export edilmiş fonksiyon" kavramıyla 
    "sistem fonksiyonu" kavramının bir ilgisi yoktur. Sistem fonksiyonları kullanıcı modundan (user mode) çağrılmak üzere tasarlanmış 
    ayrı bir grup fonksiyondur. Oysa çekirdek tarafından export edilmiş fonksiyonlar kullanıcı modundan çağrılamazlar. Yalnızca 
    çekirdek modüllerinden çağrılabilirler. Buradan çıkan sonuç şudur: Bir çekirdek modülü yazılırken ancak çekirdeğin export 
    ettiği fonksiyonlar ve nesneler kullanılabilmektedir. Tabii çekirdeğin kaynak kodları çok büyüktür ancak buradaki kısıtlı 
    sayıda fonksiyon export edilmiştir. Benzer biçimde programcının oluşturduğu bir çekirdek modül içerisindeki belli fonksiyonları 
    da programcı export edebilir. Bu durumda bu fonksiyonlar da başka çekirdek modüllerinden kullanılabilirler. O halde özetle:

    1) Çekirdek modülleri yalnızca çekirdek içerisindeki export edilmiş fonksiyonları kullanabilir.
    2) Kendi çekirdek modülümüzde biz de istediğimiz fonksiyonu export edebiliriz. Bu durumda bizim çekirdek modülümüz çekirdeğin
    bir parçası haline geldiğine göre başka çekirdek modülleri de bizim export ettiğimiz bu fonksiyonları kullanabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Mademki çekirdek modülleri işletim sisteminin çekirdek kodlarındaki fonksiyonları ve nesneleri kullanabiliyor o zaman 
    çekirdek modülleri o anda çalışılan çekirdeğin yapısına da bağlı durumdadır. Bu nedenle işletim sistemlerinde "çekirdek 
    modülü yazmak" ya da "aygıt sürücü yazmak" biçiminde genel bir konu yoktur. Her işletim sisteminin çekirdek modül ve aygıt 
    sürücü mimarisi diğerlerinden farklıdır. Dolayısıyla çekirdek modüllerinin ve aygıt sürücülerinin yazılması spesifik bir 
    işletim sistemi için geçerli olabilecek platform oldukça bağımlı bir konudur. Hatta işletim sistemlerinde bazı versiyonlarda 
    genel aygıt sürücü mimarisi bile değiştirilebilmektedir. Dolayısıyla bu tür durumlarda eski aygıt sürücüler yeni versiyonlarda, 
    yenileri de eski versiyonlarda çalışamamaktadır. Örneğin Linux'ta çekirdek versiyonları arasında çekirdekteki export edilmiş 
    bazı fonksiyonlar isim ya da parametrik yapı olarak değiştirilmiş durumdadır. Bu nedenle Linux çekirdeğinin belli bir 
    versiyonu için yazılmış olan aygıt sürücüler başka bir versiyonunda geçersiz hale gelebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdek modüllerinin ve aygıt sürücülerin yazımı için programcının çekirdek yapısını ana hatlarıyla bilmesi gerekmektedir. 
    Çünkü bunları yazarken çekirdeğin içerisindeki çeşitli veri yapıları ve export edilmiş fonksiyonlar kullanılmaktadır. 

    Linux çekirdek modülleri ve aygıt sürücüleri hakkında yazılmış birkaç kitap vardır. Bunların en klasik olanı "Linux Device 
    Drivers (3. Edition)" kitabıdır. Ancak bu kitaptaki bazı içerikler güncel çekirdeklerle uyumsuz hale gelmiştir. Bu konudaki 
    resmi dokümanlar ise "kernel.org" sitesindeki "documentation" kısmında bulunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir çekirdek modülünü derlemek ve link etmek maalesef sanıldığından daha zordur. Her ne kadar çekirdek modülleri ELF object 
    dosyaları biçimindeyse de bunlarda özel bazı "bölümler (sections)" bulunmaktadır. Dolayısıyla bu modüllerin derlenmesinde 
    özel "gcc" seçenekleri devreye sokulmaktadır. Çekirdek modüllerinin link edilmeleri de bazı kütüphane dosyalarının devreye 
    sokulmasıyla yapılmaktadır. Dolayısıyla bir çekirdek modülünün manuel biçimde "build edilmesi" için bazı ayrıntılı bilgilere 
    gereksinim duyulmaktadır. İşte çekirdek modüllerinin build edilmesinde çekirdeğin KBuild sistemi devreye sokulmaktadır. Bu 
    nedenle çekirdek modüllerinin build edilmesi için çekirdek kaynak kodlarındaki birtakım başlık dosyalarının ve Make dosyalarının 
    build işleminin yapılacağı makinede bulunması gerekir. Biz yukarıda bu dosyalara "/lib/modules/$(uname -r)/build" dizini 
    yoluyla erişilebileceğini belirtmiştik. Bu dizin aslında Linux kaynak kod ağacının bulunduğu dizini belirtmektedir. Ancak
    yukarıda da belirttiğimiz gibi çekirdek modüllerinin ve aygıt sürücülerin derlenmesi için Linux'un tüm kaynak kodlarına
    gerek yoktur. Yalnızca başlık dosyaları ve make dosyalarının bulunması yeterlidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdek modülleri o anda çalışılan host sistem için derlenebileceği gibi gömülü bir sistem için de derlenebilir. Eğer 
    derleme gömülü sistem için yapılacaksa şüphesiz çapraz derleyicilerin de ilgili sistemde kurulu olması gerekir. Yukarıda 
    da belirttiğimiz gibi çekirdek modüllerinin derlenmesi için ilgili çekirdeğe yönelik başlık dosyaları ve çeşitli make 
    dosyaları gibi bazı öğelerin de bulunuyor olması gerekir. Eğer derleme bir gömülü sistem için yapılacaksa o gömülü sistemdeki 
    çekirdeğe ilişkin bu dosyalar da host makinede bulunuyor olmalıdır. Örneğin biz masaüstü bilgisayardaki Mint dağıtımında 
    çalışıyor olalım. Bu sistemin kendisi için çekirdek modülü derleyeceksek zaten tüm gerekli öğeler hazır durumdadır.
    Ancak biz bu makinede BeagleBone Black için çekirdek modülü ve aygıt sürücü derlemesi yapacaksak çapraz derleyicimizin ve 
    BeagleBone Black'teki çekirdeğe yönelik temel başlık dosyalarının ve Make dosyalarının bulunuyor olması gerekecektir. Tabii 
    BeagleBone Black'teki çekirdek sürümüne ilişkin çekirdek kaynak kodları bu makineye çekerek bu gereksinimi karşılayabiliriz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Masaüstü bir sistem için çekirdek modül derlemesinde kullanılabilecek minimal bir Makefile dosyası aşağıdaki gibi olabilir:

    obj-m += generic.o

    all:
        make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
    clean:
        make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

    Burada önce "/lib/modules/$(uname -r)/build" dizinindeki "Makefile" dosyası çalıştırılmış ondan sonra çalışma bu yazdığımız 
    make dosyasından devam ettirilmiştir. Özetle bu make dosyası aslında çekirdeğin build sistemini kullanarak "generic.c" isimli 
    dosyanın derlenmesini ve çekirdek modülü biçiminde link edilmesini sağlamaktadır. Bu make dosyasını şöyle de düzenleyebilirdik:

    obj-m += generic.o

    KDIR := /lib/modules/$(shell uname -r)/build
    PWD := $(shell pwd)

    all:
        make -C ${KDIR} M=${PWD} modules
    clean:
        make -C ${KDIR} M=${PWD} clean

    Çekirdek modül birden fazla kaynak dosyadan oluşturulabilir. Bu durumda ilk satır şöyle oluşturulabilir:

    obj-m += a.o b.o c.o...

    Eğer bu dosyaları birden fazla satırda ayrı ayrı belirtirsek bu durumda birden fazla modül dosyası oluşturulacaktır:

    obj-m += a.o
    obj-m += b.o
    obj-m += c.o
    ...

    Bizim oluşturduğumuz Makefile dosyasındaki "all" hedefine dikkat ediniz:

    $ make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules

    make programının -C seçeneği Makefile dosyasını aramadan önce bu seçeneğin argümanında belirtilen dizine geçiş yapmaktadır.
    Dolayısıyla aslında yukarıdaki satırla "/lib/modules/$(shell uname -r)/build" dizinindeki Makefile dosyası çalıştırılacaktır.
    Buradaki M=${PWD} derlenecek kaynak dosyaların o anda çalışılan dizinde aranacağını belirtmektedir. Böylece çekirdeğin 
    KBuild sistemi yalnızca bizim dosyalarımızı derleyecektir.

    Makefile oluştururken bir noktaya dikkat ediniz. Make dilinde hedeflerin aşağısındaki yapılacak işlemler bir tab içeriden 
    yazılmaktadır. Bazı text editörler TAB tuşuna basıldığında dosyaya TAB karakter yerine belli miktar (tipik olarak 4) SPACE
    karakteri basmaktadır. TAB yerine n tane SPACE karakterinin basılması make dosyalarında bir derleme sorununa yol açacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

# Makefile

obj-m += generic.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdek modüllerini va aygıt sürücüleri derlerken iki noktaya dikkat etmelisiniz:

    1) Kullandığınız çekirdek kodları hedef makinenin çekirdek sürümüne uygun olmalıdır. Eğer bu koşul sağlanmazsa çekirdekler
    arasında farklılıklar söz konusu olabileceği için derlenmiş olan çekirdek modül dosyası hedef sisteme başarılı bir biçimde
    yüklenemeyebilir. Tabii Linux çekirdeğindeki değişiklikler daha önce yazılmış olan her çekirdek modülünü ve aygıt sürücüyü
    geçersiz hale getirmemektedir. Örneğin minör numara değişikliklerinde genellikle bir sorun oluşmamaktadır. Ancak ne olursa 
    olsun derleme yapılırken hedef sistemdeki çekirdeğe uygun kaynak dosyaların kullanılması şiddetle tavsiye edilmektedir. 
    Örneğin biz 6.9.2 çekirdeğinde çalışan makine için aygıt sürücüsü yazacaksak derleme yaptığımız makinede kullanacağımız 
    çekirdek kaynak kodlarının da bu 6.9.2 çekirdeğine ilişkin olması gerekir. Biz eski bir çekirdeğin kaynak kodlarıyla yeni 
    bir çekirdek için aygıt sürücü derlemeye çalışmamalıyız. Tabii eski bir versiyon kullanılarak derleme yapılırsa çoğu 
    durumda bir sorun ortaya çıkmayabilecektir. Ancak sorunun ortaya çıkma olasılığı da vardır.

    2) Kullanılan araç zincirinin de (yani derleyici, linker gibi programların da) çekirdeğin derlenmiş olduğu sistemle uyumlu
    olmasına dikkat ediniz. Eğer bu temel araçların versiyonlarında geçmişe doğru uyumu bozabilecek değişiklikler söz konusuysa
    yine derleme işlemi başarısız olabilir ya da çekirdek modülü yüklenirken sorun oluşabilir. Aslında çekirdeğin KBuild sistemi 
    çekirdek konfigürasyon dosyası yoluyla bu kontrolü yapabilmektedir. Ancak bu kontrol bypass da edilebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Tabii aslında make dosyası parametrik biçimde de oluşturabilmektedir:

    obj-m += $(file).o

    all:
        make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
    clean:
        make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

    Bu durumda make programı çalıştırılırken bu parametrenin değeri de belirtilmelidir. Örneğin:

    $ make file=helloworld
---------------------------------------------------------------------------------------------------------------------------*/

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi en basit bir kernel modülü oluşturup bunu bir başlangıç noktası olarak kullanalım. Bu modülümüze "helloworld" ismini
    verelim:

    /* helloworld.c */

    #include <linux/module.h>
    #include <linux/kernel.h>

    MODULE_LICENSE("GPL");

    int init_module(void)
    {
        printk(KERN_INFO "Hello World...\n");

        return 0;
    }

    void cleanup_module(void)
    {
        printk(KERN_INFO "Goodbye World...\n");
    }

    Bu kernel modül aşağıdaki gibi build edilebilir:

    $ make file=helloworld

    Build işlemi bittiğinde kernel modül "helloworld.ko" dosyası biçiminde oluşturulacaktır. Burada "ko" uzantısı "kernel 
    object" sözcüklerinden kısaltılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir çekirdek modülü, çekirdeğin içerisine "insmod" isimli programla yerleştirilmektedir. Tabii bu programın sudo ile "root" 
    önceliğinde çalıştırılması gerekmektedir. Örneğin:

    $ sudo insmod helloworld.ko

    Artık çekirdek modülümüz çekirdeğin içerisine yerleştirilmiştir. Yani modülümüz adeta çekirdeğin bir parçası gibi işlev 
    görecektir.

    Çekirdek modülleri istenildiği zaman "rmmod" isimli programla çekirdekten çıkartılabilirler. Bu programın da yine sudo 
    ile "root" önceliğinde çalıştırılması gerekir. Örneğin:

    $ sudo rmmod helloworld.ko

    rmmod komutu kullanılırken ".ko" dosya uzantısı da belirtilmeyebilir. Örneğin:

    $ sudo rmmod generic

    Aşağıda örnek için gerekli olan dosyalar verilmiştir. make işlemi şöyle yapılabilir:

    $ make file=helloworld
---------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL");

int init_module(void)
{
    printk(KERN_INFO "Hello World...\n");

    return 0;
}

void cleanup_module(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
    Modüller "modprobe" isimli programla da yüklenebilir. Ancak modprobe programı yüklenecek modülleri "/lib/modules/$(uname -r)"
    dizininde aramaktadır. Dolayısıyla biz kendi derlediğimiz modülleri bu dizine yerleştirmemişsek yüklemeyi modprobe ile 
    yapamayız. Ancak çekirdek derlenirken oluşturulmuş olan modüller bu dizinde olduğu için bunları modprobe ile yükleyebiliriz. 
    modprobe programı yüklenecek aygıt sürücünün yalnızca ismini almaktadır. Çünkü zaten arama işlemini kendisi yapmaktadır. 
    Örneğin:

    $ modprobe g_ether

    insmod programının yüklenecek aygıt sürücü dosyasının tüm yol ifadesini aldığına dikkat ediniz. modprobe programında dosyanın 
    ".ko" uzantısı da belirtilmemektedir. Halbuki insmod programında bu uzantının da belirtilmesi gerekmektedir. modprobe aslında 
    "modules.dep" isimli bir dosyaya başvurmaktadır. Bu dosya çekirdek kaynak kodlarının kök dizininde çekirdek modülleri derlenirken 
    oluşturulmaktadır. Bu dosya içerisinde bağımlılık bilgileri vardır. Bir çekirdek modülü yazılırken başka bir çekirdek modülünün 
    içerisindeki fonksiyonlar kullanılmış olabilir. Bu durumda kullanan modülün yüklenmesi için önce onun kullandığı modülün 
    yüklenmesi gerekir. İşte bu biçimde durum karmaşık bir hal alabilmektedir. "modules.dep" dosyası içerisinde bir modülün 
    yüklenebilmesi için hangi modüllerin de yüklenmesi gerektiği bilgileri bulunmaktadır. Eğer biz kendi çekirdek modülümüzün de 
    modprobe ile yüklenmesini istiyorsak önce onu "/lib/modules/$(uname -r)/kernel" dizininin içerisindeki dizinlerden birine 
    yerleştirip sonra bu "modules.dep" dosyasının güncellenmesini sağlamamız gerekir. Bu işlem "depmod" programıyla "-a" seçeneği 
    kullanılarak yapılmaktadır:

    $ sudo depmod -a

    Kendi çekirdek modülünüzü ya da aygıt sürücünüzü örneğin "/lib/modules/$(uname -r)/kernel/drivers/misc" dizinine yerleştirebilirsiniz.
    Tabii aygıt sürücü geliştirirken ikide bir modülü buraya yerleştirmenin bir anlamı yoktur. Bu nedenle geliştirme aşamasında 
    genellikle "insmod" programı kullanılmaktadır.

    modprobe ile yüklenen aygıt sürücü "modeprobe -r" ile boşaltılabilir. Örneğin:

    $ modprobe -r g_ether

    Tabii boşaltım sırasında yine eğer aygıt sürücünün bağımlı olduğu çekirdek modülleri başka modüller tarafından kullanılmıyorsa
    onlar da çekirdekten çıkartılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sistem açılır açılmaz otomatik olarak bir çekirdek modülünün ya da aygıt sürücünün yüklenmesi için birkaç yöntem kullanılabilmektedir. 
    "/etc/modules" dosyası "klasik sysvinit" ve "systemd" init tarafından işletilmektedir. Dolayısıyla bu dosyanın içerisine bir 
    satıra çekirdek modülünüzün ismini (yalnızca ismini) yazarsanız sistem açıldığında çekirdek modülü de otomatik yüklenmiş olur. 
    Ancak init programları bu dosyada belirtilen çekirdek modüllerini modprobe ile yüklemektedir. Dolayısıyla sizin de çekirdek 
    modülünüzü "/lib/modules/$(uname -r)/kernel" içerisindeki bir dizine (örneğin "/lib/modules/$(uname -r)/kernel/drivers/misc"
    dizinine) yerleştirip "sudo depmod -a" komutunu uygulamanız gerekir. Eğer systemd init sistemi ile çalışıyorsanız yüklemeyi 
    yapacak bir "servis birim dosyası" oluşturabilirsiniz. Örneğin.

    [Unit]
    Description=Modül Yükleme Servisi
    After=network.target

    [Service]
    Type=oneshot
    ExecStart=/sbin/modprobe <modül_adı>
    RemainAfterExit=true

    [Install]
    WantedBy=multi-user.target

    Diğer bir yöntem de klasik systemvinit ve systemd tarafından bakılan "/etc/rc.local" dosyasının içerisine yükleme komutunu 
    yazmaktır. Örneğin:

    "sudo insmod /path/hellowold.ko"

    Tabii burada modprobe da kullanılabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                128. Ders 17/03/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    En basit bir çekirdek modülünde aşağıdaki iki temel dosya include edilmelidir:

    #include <linux/module.h>
    #include <linux/kernel.h>

    Bu iki dosya "/lib/modules/$(uname -r)/build/include" dizini içerisindedir. (Bu dizinin çekirdek kaynak kodlarındaki "include"
    dizini olduğuna dikkat ediniz. Bu iki başlık dosyası "libc" ve POSIX kütüphanelerinin başlık dosyalarının bulunduğu "/usr/include" 
    içerisinde değildir.) Yukarıda kullandığımız make dosyası include dosyalarının bu dizinde aranmasını sağlamaktadır.

    Eskiden çekirdek modüllerine modül lisansının eklenmesi zorunlu değildi. Ancak belli bir zamandan sonra bu zorunlu hale
    getirilmiştir. Modül lisansı MODULE_LICENSE isimli makro ile belirtilmektedir. Bu makro <linux/module.h> dosyası içerisinde
    bildirilmiştir. Tipik modül lisansı aşağıdaki gibi "GPL" biçiminde oluşturulabilir:

    MODULE_LICENSE("GPL");

    Bir çekirdek modülü yüklendiğinde çekirdek modülü içerisinde belirlenmiş olan bir fonksiyon çağrılır (bu fonksiyon C++'taki 
    "constructor" gibi düşünülebilir.) Default çağrılacak fonksiyonun ismi init_module biçimindedir. Bu fonksiyonun geri 
    dönüş değeri int türdendir ve parametresi yoktur. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda negatif 
    hata koduna (negatif errno değerine) geri dönmelidir. Bu fonksiyon başarısızlıkla geri dönerse modülün yüklenmesinden 
    vazgeçilmektedir. Benzer biçimde bir modül çekirdek alanından boşaltılırken de yine bir fonksiyon çağrılmaktadır. (Bu 
    fonksiyon da C++'taki "destructor" gibi düşünülebilir.) Default çağrılacak fonksiyonun ismi cleanup_module biçimindedir. 
    Bu fonksiyonun geri dönüş değeri ve parametresi void biçimdedir.

    Çekirdek modülleri tıpkı daha önce görmüş olduğumuz daemon'lar gibi ekrana değil log dosyalarına yazarlar. Bunun için çekirdek 
    içindeki printk isimli fonksiyon kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                129. Ders 22/03/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    helloworld modülünde kullanmış olduğumuz printk fonksiyonu "çekirdeğin printf fonksiyonu" gibi düşünülebilir. printk fonksiyonunun 
    genel kullanımı printf fonksiyonu gibidir. Default durumda bu fonksiyon mesajların "/var/log/syslog" dosyasına yazdırılmasını 
    sağlamaktadır. printk fonksiyonunun prototipi <linux/kernel.h> dosyası içerisindedir. printk fonksiyonunun örnek kullanımı 
    şöyledir:

    printk(KERN_INFO "This is test\n");

    Mesajın solundaki KERN_XXX biçimindeki makrolar aslında bir string açımı yapmaktadır. Dolayısıyla yan yana iki string 
    birleştirildiği için mesaj yazısının başında küçük bir önek bulunur. Bu önek (yani bu makro) mesajın türünü ve aciliyetini 
    belirtmektedir. Tipik KERN_XXX makroları şunlardır:

    KERN_EMERG
    KERN ALERT
    KERN_CRIT
    KERN_ERR
    KERN_WARN
    KERN_NOTICE
    KERN_INFO
    KERN_DEBUG

    Bu makroların tipik yazım biçimi şöyledir:

    #define KERN_SOH        "\001"        /* ASCII Start Of Header */
    #define KERN_SOH_ASCII    '\001'

    #define KERN_EMERG        KERN_SOH "0"        /* system is unusable */
    #define KERN_ALERT        KERN_SOH "1"        /* action must be taken immediately */
    #define KERN_CRIT        KERN_SOH "2"        /* critical conditions */
    #define KERN_ERR        KERN_SOH "3"        /* error conditions */
    #define KERN_WARNING    KERN_SOH "4"        /* warning conditions */
    #define KERN_NOTICE        KERN_SOH "5"        /* normal but significant condition */
    #define KERN_INFO        KERN_SOH "6"        /* informational */
    #define KERN_DEBUG        KERN_SOH "7"        /* debug-level messages */

    Ancak bu makrolarda çeşitli çekirdek versiyonlarında değişiklikler yapılabilmektedir. C'de aralarında hiçbir operatör 
    bulunmayan iki string'in derleyici tarafından birleştirildiğini anımsayınız. Bu durumda aslında örneğin:

    printk(KERN_INFO "Hello World...\n");

    ile aşağıdaki çağrı eşdeğerdir:

    printk("\0017Hello World...\n");

    Ancak yukarıda da belirttiğimiz gibi bu makrolar üzerinde değişiklikler yapılabilmektedir. Dolayısıyla makroların kendisinin 
    kullanılması gerekir.

    Aslında KERN_XXX makroları ile printk fonksiyonunu kullanmak yerine pr_xxx makroları da kullanılabilir. Şöyle ki:

    printk(KERN_INFO "Hello World...\n");

    ile

    pr_info("Hello World...\n");

    tamamen eşdeğerdir. Diğer pr_xxx makroları şunlardır:

    pr_emerg
    pr_alert
    pr_crit
    pr_err
    pr_warning
    pr_notice
    pr_info
    pr_debug

    printk fonksiyonunun yazdıklarını "/var/log/syslog" dosyasına bakarak görebiliriz. Örneğin:

    $ tail /var/log/syslog

    Ya da "dmesg" programı ile de aynı bilgi elde edilebilir.

    En çok kullanılan log düzeyini belirten makrolar KERN_INFO, KERN_ERR ve KERN_WARNING makrolarıdır. Çekirdek modülü ya da 
    aygıt sürücü içerisinde bazı durumlara yönelik bilgi vermek için KERN_INFO, hatalı bir durumlar karşılaştığında KERN_ERR 
    ve bir uyarı oluşturulacağı zaman KERN_WARNING kullanılmaktadır. Diğer makrolar geliştiriciler tarafından çok seyrek 
    kullanılmaktadır.

    Çekirdek modülleri çekirdeğin içerisine yerleştirildiği için çekirdek modüllerinde biz kullanıcı modundaki (user mode'daki) 
    kütüphaneleri kullanamayız. (Örneğin çekirdek modunda standart C fonksiyonlarını ve POSIX fonksiyonlarını kullanamayız.) 
    Çünkü standart C fonksiyonları ve POSIX fonksiyonları "kullanıcı modundaki (user mode)" programlar için oluşturulmuş kütüphanelerin 
    içerisindedir. Biz çekirdek modüllerinin içerisinde yalnızca "export edilmiş çekirdek fonksiyonlarını" kullanabiliriz.

    Çekirdek modülleri içerisinde kullanılabilecek export edilmiş çekirdek fonksiyonları "Linux Kernel API" ismi altında 
    "kernel.org" tarafından dokümante edilmiştir. Örneğin bu fonksiyonların dokümantasyonuna aşağıdaki bağlantıdan erişebilirsiniz:

    https://docs.kernel.org/core-api/kernel-api.html

    Ancak maalesef bu export edilmiş fonksiyonlar hakkında ayrıntılı açıklamalar bulmak zordur. Bu nedenle bazen çekirdek 
    kaynak kodlarına başvurmak da gerekebilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Belli bir anda yüklenmiş olan çekirdek modülleri "/proc/modules" dosyasından elde edilebilir. "/proc/modules" bir text 
    dosyadır. Dosyanın her satırında bir çekirdek modülünün bilgisi vardır. Örneğin:

    $ cat /proc/modules
    helloworld 16384 0 - Live 0x0000000000000000 (OE)
    vmw_vsock_vmci_transport 32768 2 - Live 0x0000000000000000
    vsock 40960 3 vmw_vsock_vmci_transport, Live 0x0000000000000000
    snd_ens1371 28672 2 - Live 0x0000000000000000
    snd_ac97_codec 131072 1 snd_ens1371, Live 0x0000000000000000
    gameport 20480 1 snd_ens1371, Live 0x0000000000000000
    ac97_bus 16384 1 snd_ac97_codec, Live 0x0000000000000000
    binfmt_misc 24576 1 - Live 0x0000000000000000
    intel_rapl_msr 20480 0 - Live 0x0000000000000000
    ...

    Yüklü modüllerin bilgileri "lsmod" isimli bir yardımcı programla da görüntülenebilmektedir. Tabii aslında "lsmod" 
    "/proc/modules" dosyasını okuyup onu daha anlaşılır biçimde görüntülemektedir. Örneğin:

    $ lsmod
    Module                  Size  Used by
    helloworld             16384  0
    btrfs                1564672  0
    blake2b_generic        20480  0
    xor                    24576  1 btrfs
    zstd_compress         229376  1 btrfs
    raid6_pq              122880  1 btrfs
    ufs                   106496  0
    qnx4                   16384  0
    hfsplus               118784  0
    hfs                    65536  0
    ...
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında init_module ve cleanup_module fonksiyonlarının ismi değiştirilebilir. Fakat bunun için bildirimde bulunmak gerekir. 
    Bildirimde bulunmak için ise module_init(...) ve module_exit(...) makroları kullanılmaktadır. Bu makrolar kaynak kodun 
    herhangi bir yerinde bulundurulabilir. Ancak makro içerisinde belirtilen fonksiyonların daha yukarıda bildirilmiş olması 
    gerekmektedir. Bu makrolar tipik olarak kaynak kodun sonuna yerleştirilmektedir. Örneğin:

    #include <linux/module.h>
    #include <linux/kernel.h>

    int helloworld_init(void)
    {
        printk(KERN_INFO "Hello World...\n");

        return 0;
    }

    void helloworld_exit(void)
    {
        printk(KERN_INFO "Goodbye World...\n");
    }

    module_init(helloworld_init);
    module_exit(helloworld_exit);

    Aşağıda örnek bütünsel olarak verilmiştir. make işlemi şöyle yapılabilir:

    $ make file=helloworld
---------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

int helloworld_init(void)
{
    printk(KERN_INFO "Hello World...\n");

    return 0;
}

void helloworld_exit(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

module_init(helloworld_init);
module_exit(helloworld_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
    Genellikle çekirdek modülü içerisindeki global değişkenlerin ve fonksiyonların "içsel bağlamaya (internal linkage)" sahip 
    olması tercih edilmektedir. Bu durum birtakım isim çakışmalarını da engelleyecektir. Biz de genel olarak örneklerimizde 
    zorunlu olmadıkça fonksiyonları hep static biçimde tanımlayacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

static int helloworld_init(void)
{
    printk(KERN_INFO "Hello World...\n");

    return 0;
}

static void helloworld_exit(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

module_init(helloworld_init);
module_exit(helloworld_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdek modüllerinin init ve cleanup fonksiyonlarında fonksiyon isimlerinin soluna __init ve __exit makroları getirilebilmektedir. 
    Bu makrolar <linux/init.h> dosyası içerisindedir. Bu dosya da <linux/module.h> dosyası içerisinde include edilmiştir. 
    __init makrosu ilgili fonksiyonu ELF dosyasının özel bir bölümüne (section) yerleştirir. Modül yüklendikten sonra bu bölüm 
    çekirdek alanından atılmaktadır. __exit makrosu ise çekirdeğin içine gömülmüş modüllerde fonksiyonun dikkate alınmayacağını 
    (dolayısıyla hiç yüklenmeyeceğini) belirtir. Ancak sonradan yüklemelerde bu makronun bir etkisi yoktur.
---------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

static int __init helloworld_init(void)
{
    printk(KERN_INFO "Hello World...\n");

    return 0;
}

static void __exit helloworld_exit(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

module_init(helloworld_init);
module_exit(helloworld_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerine 2003 yılında 2.6 çekirdekleriyle birlikte "sysfs (kısaca sys)" isimli bellek tabanlı yeni bir dosya sistemi
    daha eklenmiştir. Bu dosya sistemi de tıpkı proc dosya sistemi gibi çekirdeğin içinde bulunduğu durumu dış dünyaya bildirmek 
    ve çekirdek davranışının dışarıdan değiştirilmesine olanak sağlamak amacıyla oluşturulmuştur. Ancak "sysfs" dosya sistemi 
    daha "nesne yönelimli" bir tasarıma sahiptir. Yani birtakım olgular dizinlerle onların özellikleri de o dizinler içerisindeki 
    dosyalarla temsil edilmektedir. Bu bakımdan "sysfs" dosya sistemi "proc" dosya sisteminin bazı eksikliklerini tamamlamaktadır. 
    sysfs dosya sistemine "/sys" dizini yoluyla erişilmektedir.

    insmod ile yüklediğimiz her modül için "/sys/module" dizinin içerisinde ismi modül ismiyle aynı olan bir dizin yaratılmaktadır. 
    "/proc/modules" dosyası ile bu dizini karıştırmayınız. "/proc/modules" dosyasının satırları yüklü olan modüllerin isimlerini 
    ve bazı temel bilgilerini tutmaktadır. Modüllere ilişkin asıl önemli bilgiler ise çekirdek tarafından "/sys/module" dizininde 
    tutulmaktadır. sysfs dosya sistemi de proc dosya sistemi gibi çekirdek tarafından bellek üzerinde oluşturulan ve içeriği çekirdek
    tarafından güncellenen bir dosya sistemidir. Örneğin "helloworld.ko" modülünü yükledikten sonra bu dizin aşağıdaki gibi bir 
    içeriğe sahip olacaktır:

    $ ls /sys/module/helloworld -l
    toplam 0
    -r--r--r-- 1 root root 4096 Mar 22 21:25 coresize
    drwxr-xr-x 2 root root    0 Mar 22 21:25 holders
    -r--r--r-- 1 root root 4096 Mar 22 21:25 initsize
    -r--r--r-- 1 root root 4096 Mar 22 21:25 initstate
    drwxr-xr-x 2 root root    0 Mar 22 21:25 notes
    -r--r--r-- 1 root root 4096 Mar 22 21:25 refcnt
    drwxr-xr-x 2 root root    0 Mar 22 21:25 sections
    -r--r--r-- 1 root root 4096 Mar 22 21:25 srcversion
    -r--r--r-- 1 root root 4096 Mar 22 21:25 taint
    --w------- 1 root root 4096 Mar 22 21:22 uevent
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Nasıl kullanıcı modu programlarında main fonksiyonuna komut satırı argümanları geçirilebiliyorsa benzer biçimde çekirdek 
    modüllerine de argüman (ya da parametre diyebiliriz) geçirilebilmektedir. Bu konuya genel olarak "çekirdek modül parametreleri" 
    denilmektedir.

    Çekirdek modüllerine parametre geçirme işlemi insmod komutu ile modül yüklenirken komut satırında modül isminden sonra 
    "değişken=değer" çiftleriyle yapılmaktadır. Örneğin:

    $ sudo insmod helloworld.ko number=10 msg="\"This is a test\"" values=10,20,30,40,50

    Bu örnekte number parametresi int bir değerden, msg parametresi bir yazıdan values parametresi ise birden fazla int değerden 
    oluşmaktadır. Bu tür parametrelere modülün dizi parametreleri denilmektedir.

    Çekirdek modüllerine geçirilen parametreleri modül içerisinde almak için module_param ve module_param_array isimli makrolar 
    kullanılır. module_param makrosunun üç parametresi vardır:

    module_param(name, type, perm);

    name parametresi ilgili değişkenin ismini belirtmektedir. Biz makroyu çağırmadan önce bu isimde bir global değişkeni tanımlamalıyız. 
    Ancak buradaki değişken isminin komut satırında verilen parametre (argüman da diyebiliriz) ismi ile aynı olması gerekmektedir. 
    type ilgili parametrenin türünü belirtir. Bu tür şunlardan biri olabilir:

    int
    long
    short
    uint
    ulong
    ushort
    charp
    bool
    invbool

    Buradaki charp char türden adresi, invbool ise geçirilen argümanın bool bakımdan tersini temsil etmektedir. module_param
    makrosunun perm parametresi "/sys/modules/<modül ismi>" dizininde yaratılacak olan "parameters" dizininin erişim haklarını 
    belirtir. Bu makrolar global alanda herhangi bir yere yerleştirilebilir.

    Örneğin kernel modülümüzde count ve msg isimli iki parametre olsun. Bunlara ilişkin module_param makroları şöyle oluşturulmalıdır:

    int count = 0;
    char *msg = "Ok";

    module_param(count, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
    module_param(msg, charp, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

    char * türünden modül parametresi için makrodaki türün "charp" biçiminde olduğuna dikkat ediniz. Buradaki gösterici const 
    olamamaktadır. Bizim bir parametre için module_param makrosunu kullanmış olmamız modül yüklenirken bu parametrenin belirtilmesini 
    zorunlu hale getirmemektedir. Bu durumda bu parametreler default değerlerde kalacaktır. Yukarıdaki parametreleri helloworld 
    modülüne aşağıdaki gibi geçirebiliriz:

    $ sudo insmod helloworld.ko count=100 msg="\"this is a test\""

    Burada neden iç içe tırnakların kullanıldığını merak edebilirsiniz. Kabuk üzerinde tırnaklar "boşluklarla ayrılmış olan yazıların 
    tek bir komut satırı argümanı olarak ele alınacağını belirtmektedir. Ancak bizim ayrıca yazısal argümanları modüllere parametre 
    yoluyla aktarırken onları tırnaklamamız gerekir. Bu nedenle iç içe iki tırnak kullanılmıştır.

    Modül parametreleri kernel tarafından "/sys/module" içerisindeki modül ismine ilişkin dizinin altındaki parameters dizininde 
    dosyalar biçiminde dış dünyaya sunulmaktadır. İşte makrodaki erişim hakları buradaki parametre dosyalarının erişim haklarını 
    belirtmektedir. Kernel modül root kullanıcısı tarafından yüklendiğine göre bu dosyaların da kullanıcı ve grup id'leri root 
    olacaktır. Örneğin helloworld modülü için bu dosyalar "/sys/module/helloworld/parameters" dizini içerisindedir:

    $ ls -l /sys/module/helloworld/parameters
    toplam 0
    -rw-r--r-- 1 root root 4096 Mar 22 22:24 count
    -rw-r--r-- 1 root root 4096 Mar 22 22:24 msg

    Bu dosyalar doğrudan kernel modüldeki parametre değişkenlerini temsil etmektedir. Yani örneğin biz buradaki count dosyasına
    başka bir değer yazdığımızda kernel modülümüzdeki count değeri de değişmiş olacaktır. Tabii yukarıdaki erişim haklarıyla biz
    dosyaya yazma yapamayız. Bu erişim haklarıyla yazma yapabilmemiz için yazmayı yapan programın root olması gerekir. Terminalden 
    bu işlem aşağıdaki gibi yapılabilir:

    $ sudo bash -c "echo 200 > /sys/module/helloworld/parameters/count"

    yada

    $ echo 200 | sudo tee /sys/module/helloworld/parameters/count

    Burada işlemi aşağıdaki gibi yapamayacağımıza dikkat ediniz:

    $ sudo echo 200 > /sys/module/helloworld/parameters/count

    Çünkü burada her ne kadar echo programı root önceliğinde çalıştırılıyorsa da dosyayı açan kullanıcı root değildir. Çünkü 
    > işareti ve onun sağının sudo ile bir ilgisi yoktur.

    Bu denemeyi aşağıdaki modülle yapabilirsiniz. Modülü önce insmod ile aşağıdaki gibi yükleyiniz:

    $ sudo insmod helloworld.ko count=200 msg="\"this is a generic module\""

    Sonra "/sys/module/helloworld/parameters" dizinine geçip aşağıdaki komutları uygulayınız:

    $ echo 500 | sudo tee count
    $ echo "this is a new message" | sudo tee msg

    Modülü "rmmod" ile çekirdek alanından çıkarttıktan sonra yeniden "dmesg" yapınız. Artık modül içerisindeki parametrelerin
    aşağıdaki gibi değiştiğini göreceksiniz:

   [ 7668.582978] count = 500, msg=this is a new message
---------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL");

static int count = 0;
static char *msg = "Ok";

module_param(count, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
module_param(msg, charp, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int __init helloworld_init(void)
{
    printk(KERN_INFO "Hello World...\n");

    return 0;
}

static void __exit helloworld_exit(void)
{
    printk(KERN_INFO "Goodbye World...\n");
    printk(KERN_INFO "count = %d, msg=%s\n", count, msg);
}

module_init(helloworld_init);
module_exit(helloworld_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
                                                130. Ders 24/03/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

//*-----------------------------------------------------------------------------------------------------------------------------
    Çekirdek modülene birden fazla değer de bir dizi gibi aktarılabilir. Bunun için module_param_array makrosu kullanılmaktadır. 
    module_param_array makrosu da şöyledir:

    module_param_array(name, type, nump, perm)

    Makronun birinci ve ikinci parametreleri yine değişken ismi ve türünü belirtir. Tabii buradaki değişken isminin bir dizi 
    ismi olarak, türün de bu dizinin eleman türü olarak girilmesi gerekmektedir. Üçüncü parametre toplam kaç değerin modüle dizi 
    biçiminde aktarıldığını belirten int bir nesnenin adresini (ismini değil) alır. Son parametre yine oluşturulacak dosyanın 
    erişim haklarını belirtmektedir. Örneğin:

    static int values[5];
    static int size;

    module_param_array(values, int, &size, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

    module_param_array makrosuyla bir diziye değer aktarırken değerlerin virgüllerle ayrılmış bir biçimde girilmesi gerekmektedir.
    Örneğin:

    $ sudo insmod helloworld.ko values=1,2,3,4,5

    Burada eğer verilen değerler dizinin uzunluğundan fazla olursa zaten modül yüklemesi başarısız olmaktadır. Yani "insmod" 
    bir hata mesajı ile işlemini sonlandıracaktır. Tabii verilen değerlerin dizinin uzunluğundan daha az olabilir. Girilen değerlerin
    sayısı zaten örneğimizde size nesnesine yerleştirilecektir.

    Aşağıdaki örnekte üç parametre komut satırından çekirdek modülüne geçirilmiştir. Komut satırındaki isimlerle programın içerisindeki 
    değişken isimlerinin aynı olması gerektiğini anımsayınız. Dizi elemanlarını virgüllerle belirtirken yanlışlıkla virgüllerin 
    arasına boşluk karakterleri yerleştirmeyiniz. Programı şöyle make yapabilirsiniz:

    $ make file=helloworld

    Yüklemeyi şöyle yapabilirsiniz:

    $ sudo insmod helloworld.ko count=200 msg="\"this is a generic module\"" values=10,20,30,40,50
-----------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL");

static int count = 0;
static char *msg = "Ok";
static int values[5];
static int size;

module_param(count, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
module_param(msg, charp, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
module_param_array(values, int, &size, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int __init helloworld_init(void)
{
    int i;

    printk(KERN_INFO "Hello World...\n");

    printk(KERN_INFO "count = %d\n", count);
    printk(KERN_INFO "msg = %s\n", msg);
    printk(KERN_INFO "Values:\n");
    for (i = 0; i < size; ++i)
        printk(KERN_INFO "%d ", values[i]);
    printk(KERN_INFO "\n");

    return 0;
}

static void __exit helloworld_exit(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

module_init(helloworld_init);
module_exit(helloworld_exit);

/*--------------------------------------------------------------------------------------------------------------------------
    errno değişkeni aslında "libc" kütüphanesinin (libc standart C ve POSIX kütüphanesidir) içerisinde tanımlanmış bir değişkendir. 
    Çekirdek modunda yani çekirdeğin içerisinde errno isimli bir değişken yoktur. Bu nedenle çekirdekteki fonksiyonlar pek çok 
    POSIX fonksiyonunda olduğu gibi başarısızlık durumunda -1 ile geri dönüp errno değişkenini set etmezler. Çekirdek içerisindeki 
    fonksiyonlar başarısızlık durumunda negatif errno değeri ile geri dönerler. Örneğin "open" POSIX fonksiyonu "sys_open" isimli 
    çekirdek içerisinde bulunan sistem fonksiyonunu çağırdığında onun negatif bir değerle geri dönüp dönmediğine bakar. Eğer "sys_open" 
    fonksiyonu negatif değerle geri dönerse bu durumda bu değerin pozitiflisini errno değişkenine yerleştirip -1 ile geri dönmektedir. 
    Başka bir deyişle aslında bizim çağırdığımız int geri dönüş değerine sahip POSIX fonksiyonları sistem fonksiyonlarını çağırıp 
    o fonksiyonlar negatif bir değerle geri dönmüş ise bir hata oluştuğunu düşünerek o negatif değerin pozitiflisini errno değişkenine 
    yerleştirip -1 ile geri dönmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux'ta bir kernel modül artık user mode'dan kullanılabilir hale getirildiyse buna "aygıt sürücü (device driver)" denilmektedir. 
    Aygıt sürücüler open fonksiyonuyla bir dosya gibi açılırlar. Bu açma işleminden bir dosya betimleyicisi elde edilir. Bu 
    dosya betimleyicisi read, write, lseek, close gibi fonksiyonlarda kullanılabilir. Aygıt sürücülere ilişkin dosya betimleyicileri
    bu fonksiyonlarla kullanıldığında aygıt sürücü içerisindeki belirlenen bazı fonksiyonlar çağrılmaktadır. Yani tersten gidersek 
    biz örneğin aygıt sürücümüze ilişkin dosya betimleyicisi ile read ve write fonksiyonlarını çağırdığımızda aslında aygıt 
    sürücümüzdeki belli fonksiyonlar çalıştırılmaktadır. Böylece aygıt sürücü ile user mode arasında veri transferleri yine 
    dosyalarda olduğu gibi dosya fonksiyonlarıyla yapılabilmektedir. Ayrıca user mode'dan aygıt sürücümüzdeki herhangi bir 
    fonksiyonu da çağırabiliriz. Bunun için ioctl isimli bir POSIX fonksiyonu (tabii bu POSIX fonksiyonu sys_ioctl isimli sistem 
    fonksiyonunu çağırmaktadır) kullanılmaktadır. Aygıt sürücü içerisinde fonksiyonlara birer kod numarası atanır. Sonra ioctl 
    fonksiyonunda bu kod numarası belirtilir. Böylece akış user mode'dan kernel mode'a geçerek belirlenen fonksiyonu kernel 
    mode'da çalıştıracaktır.

    Özetle bir aygıt sürücüsü kernel mode'da çalışmaktadır. Biz aygıt sürücüsünü open fonksiyonu ile açıp elde ettiğimiz betimleyici 
    ile read, write, lseek ve close fonksiyonlarını çağırdığımızda aygıt sürücü içerisindeki ilgili fonksiyon çalıştırılmaktadır. 
    Aygıt sürücüsü içerisindeki herhangi bir fonksiyon ise user mode'dan ioctl isimli fonksiyonla çalıştırılmaktadır. Tabii user 
    mode programlar aygıt sürücü içerisindeki kodları read, write, lseek, close, ioctl gibi fonksiyonlar yoluyla çalıştırdıklarında 
    proses user mode'dan geçici süre kernel mode'a geçer, ilgili kodlar kernel mode'da koruma engeline takılmadan çalıştırılır. 
    Fonksiyonların çalışması bittiğinde proses yine user mode'da döner.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda ele aldığımız konuyu şöyle özetleyebiliriz:

    1) Bir çekirdek fonksiyonu tamsayı türlerine ilişkin bir değere geri dönüyorsa geri dönüş değerinin negatif olması 
    fonksiyonun başarısız olduğunu gösterir. Bu negatif değerin pozitiflisi errno değerini vermektedir.

    2) Bir çekirdek fonksiyonu bir adrese geri dönüyorsa fonksiyonun başarısı verilen adresin değerine bağlıdır. Eğer verilen 
    adres çok bir büyük bir adresse fonksiyon başarısız olmuştur. Bu kontrol IS_ERR inline fonksiyonuyla yapılmaktadır.

    3) Adrese geri dönen çekirdek fonksiyonu eğer başarısızsa negatif errno değeri PTR_ERR inline fonksiyonuyla elde edilir.

    4) Biz negatif bir errno değerini bir adres gibi geri döndüreceksek bunun için ERR_PTR inline fonksiyonunu kullanmalıyız.

    5) Biz de çekirdek modüllerini ve aygıt sürücülerini yazarken çekirdekte uygulanan bu biçime (convention) uymalıyız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir çekirdek modülünü yazarken o modül ile ilgili önemli bazı belirlemeler "modül makroları" denilen MODULE_XXX biçimindeki 
    makrolarla yapılmaktadır. Her ne kadar bu modül makrolarının bulundurulması zorunlu değilse de şiddetle tavsiye edilmektedir. 
    En önemli üç makronun tipik kullanımı şöyledir:

    MODULE_LICENSE("GPL");
    MODULE_AUTHOR("Kaan Aslan");
    MODULE_DESCRIPTION("General Character Device Driver");

    Modül lisansı herhangi bir açık kaynak kod lisansı olabilir. Tipik olarak "GPL" tercih edilmektedir. MODULE_AUTHOR makrosu 
    ile modülün yazarı belirtilir. MODULE_DESCRPTION modülün ne iş yapacağına yönelik kısa bir başlık yazısı içermektedir.

    Bu makrolar global alanda herhangi bir yere yerleştirilebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                131. Ders 29/03/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi kullanıcı modundaki programlar aygıt sürücülerle dosya sistemi yoluyla iletişim kurmaktadır. 
    Aygıt sürücüler sanki birer dosyaymış gibi açılırlar ve birer dosyaymış gibi işleme sokulurlar. Pekiyi aygıt sürücüleri açmak 
    için yol ifadesi olarak (yani dosya ismi olarak) ne kullanılmaktadır? İşte aygıt sürücüler dosya sisteminde bir dizin girişiyle 
    temsil edilmektedir. O dizin girişi open fonksiyonuyla ile açıldığında aslında o dizin girişinin temsil ettiği aygıt sürücü 
    açılmış olur. Bu biçimdeki aygıt sürücüleri temsil eden dizin girişlerine "aygıt dosyaları (device files)" denilmektedir. 
    Aygıt dosyaları diskte bir dosya belirtmemektedir. Çekirdek içerisindeki aygıt sürücüyü temsil eden bir dizin girişi belirtmektedir. 
    Aygıt dosyalarının i-node tablosunda bir i-node elemanı vardır ancak bu i-node elemanı diskte bir yer değil çekirdekte bir 
    aygıt sürücü belirtmektedir.

    Pekiyi bir aygıt dosyası nasıl yaratılmaktadır ve nasıl bir aygıt sürücüyü temsil eder hale getirilmektedir? İşte her aygıt 
    sürücünün majör ve minör numarası vardır. Bu majör ve minör numarayı aygıt sürücüye erişmek için kullanılan bir adres gibi 
    düşünebilirsiniz. Aynı zamanda aygıt dosyalarının da majör ve minör numaraları vardır. Bir aygıt sürücünün majör ve minör 
    numarası bir aygıt dosyasının majör ve minör numarasıyla aynıysa bu durumda o aygıt dosyası o aygıt sürücüyü temsil eder.
    Yani o aygıt dosyası açıldığında o aygıt sürücüyle iletişim kurulacaktır.

    Aygıt dosyaları özel dosyalardır. Bir dosyanın aygıt dosyası olup olmadığı "ls -l" komutunda dosya türü olarak 'c' (karakter 
    aygıt sürücüsü) ya da 'b' (blok aygıt sürücüsü) ile temsil edilmektedir. Anımsanacağı gibi dosya bilgileri stat, fstat, lstat 
    POSIX fonksiyonlarıyla elde ediliyordu. İşte struct stat yapısının dev_t türünden st_rdev elemanı eğer dosya bir aygıt dosyasıysa 
    dosyanın majör ve minör numaralarını belirtir. Biz de <sys/stat.h> dosyasındaki S_ISCHR ve S_ISBLK makrolarıyla ilgili dosyanın 
    bir aygıt dosyası olup olmadığını öğrenebiliriz.

    Yukarıda da belirttiğimiz gibi aygıt sürücüler "karakter aygıt sürücüleri (character device driver)" ve "blok aygıt sürücüleri
    (block device driver)" olmak üzere ikiye ayrılmaktadır. Karakter aygıt sürücüleri daha yaygın kullanılmaktadır. Biz kursumuzda
    önce karakter aygıt sürücülerini sonra blok aygıt sürücülerini ele alacağız. Blok aygıt sürücüleri tipik olarak disk gibi 
    medyalara erişmek amacıyla kullanılan aygıt sürücülerdir. Bunlar aktarım işlemini blok blok yaparlar. Bu işlemlerin daha 
    etkin gerçekleştirilmesi için çekirdeğin "buffer cache" (ya da yeni ismiyle "page cache") alt sistemleri devreye sokulmaktadır. 
    Karakter aygıt sürücüleri blok blok aktarım yapmayan aygıtlarla iletişim kuran aygıt sürücülerdir. Örneğin seri porttan bilgi 
    okuyan seri porta bilgi yazan aygıt sürücüler karakter aygıt sürücüleridir. Fakat RAM Disk oluşturan aygıt sürücüleri blok
    aygıt sürücüleridir. Karakter aygıt sürücülerinin yazımı blok aygıt sürücülerinden daha kolaydır.

    O halde şimdi bizim bir aygıt dosyasını nasıl oluşturacağımızı ve aygıt sürücüye nasıl majör ve minör numara atayacağımızı 
    bilmemiz gerekir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt dosyaları mknod isimli POSIX fonksiyonuyla (bu fonksiyon Linux'ta doğrudan sys_node isimli sistem fonksiyonunu 
    çağırmaktadır) ya da komut satırından mknod komutuyla (bu komut da mknod fonksiyonu ile işlemini yapmaktadır) yaratılabilir. 
    mknod fonksiyonunun prototipi şöyledir:

    #include <sys/stat.h>

    int mknod(const char *pathname, mode_t mode, dev_t dev);

    Fonksiyonun birinci parametresi yaratılacak aygıt dosyasının yol ifadesini, ikinci parametresi erişim haklarını ve üçüncü 
    parametresi de aygıt dosyasının majör ve minör numaralarını belirtmektedir. Aygıt dosyasının majör ve minör numaraları dev_t 
    türünden tek bir değer ile belirtilmektedir. dev_t türü POSIX standartlarına göre herhangi bir tamsayı türü olabilmektedir. 
    Biz majör ve minör numaraları user mod programlarda makedev isimli makroyla oluştururuz. Bir dev_t türünden değerin içerisinden 
    major numarayı almak için major makrosu, minor numarayı almak için ise minor makrosu bulunmaktadır:

    #include <sys/sysmacros.h>

    dev_t makedev(unsigned int maj, unsigned int min);
    unsigned int major(dev_t dev);
    unsigned int minor(dev_t dev);

    Yani aslında majör ve minör numaralar dev_t türünden bir değerin belli bitlerinde bulunmaktadır. Ancak bu numaraların dev_t 
    türünden değerin hangi bitlerinde bulunduğu sistemden sisteme değişebileceği için bu makrolar kullanılmaktadır.

    Ancak çekirdek dev_t nesnesini oluşturmak için büyük harflerle isimlendirilmiş aşağıdaki makrolar kullanılmaktadır:

    #include <linux/fs.h>

    MKDEV(major, minor)
    MAJOR(dev)
    MINOR(dev)

    Linux'ta son versiyonlar da dikkate alındığında dev_t 32 bitlik işaretsiz bir tamsayı türündendir. Bu 32 bitin yüksek anlamlı 
    12 biti majör numarayı, düşük anlamlı 20 biti ise minör numarayı temsil etmektedir. Ancak programcı bu varsayımlarla 
    kodunu düzenlememeli yukarıda belirtilen makroları kullanmalıdır.

    mknod fonksiyonunun ikinci parametresindeki erişim haklarına aygıt dosyasının türünü belirten aşağıdaki sembolik sabitlerden 
    biri de bit OR operatörü ile eklenmelidir:

    S_IFCHR (Karakter Aygıt Sürücüsü)
    S_IFBLK (Blok Aygıt Sürücüsü)

    Aslında mknod fonksiyonu ile Linux sistemlerinde isimli boru dosyaları, UNIX domain soket dosyaları ve hatta normal dosyalar 
    da yaratılabilmektedir. Bu durumda fonksiyonun aygıt numarasını belirten üçüncü parametresi fonksiyon tarafından dikkate 
    alınmamaktadır. Bu özel dosyalar için erişim haklarına eklenecek makrolar da şunlardır:

    S_IFREG (Disk dosyası yaratmak için)
    S_IFIFO (İsimli boru dosyası yaratmak için)
    S_IFSOCK (UNIX domain soket dosyası yaratmak için)

    Aslında mknod fonksiyonu aygıt dosyaları yaratmak için kullanılıyor olsa da yukarıda belirttiğimiz özel dosyaları da 
    yaratabilmektedir. Tabii zaten isimli boru dosyasını yaratmak için mkfifo fonksiyonu, normal dosyaları yaratmak için 
    open fonksiyonu kullanılabilmektedir.

    mknod fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    Ayrıca mknod POSIX fonksiyonunun mknodat isimli at'li bir versiyonu da bulunmaktadır:

    #include <fcntl.h>

    int mknodat(int fd, const char *path, mode_t mode, dev_t dev);

    Bu at'li versiyon daha önce görmüş olduğumuz at'li fonksiyonlar gibi çalışmaktadır. Yani fonksiyon ilgili dizine ilişkin 
    dosya betimleyicisini ve göreli yol ifadesini parametre olarak alır. O dizinden göreli biçimde yol ifadesini oluşturur. 
    Yine fonksiyonun birinci parametresine AT_FDCWD özel değeri geçilebilir. Bu durumda fonksiyon at'siz versiyondaki gibi 
    çalışır. Diğer at'li fonksiyonlarda olduğu gibi bu fonksiyonun da ikinci parametresindeki yol ifadesi mutlak ise birinci 
    parametresindeki dizin hiç kullanılmamaktadır.

    mknod ve mknodat fonksiyonları prosesin umask değerini dikkate almaktadır. Bu fonksiyonlarla aygıt dosyası yaratabilmek için
    (diğer özel dosyalar için gerekmemektedir) prosesin uygun önceliğe sahip olması gerekmektedir.

    Aşağıdaki aygıt dosyası yaratan mymknode isimli bir fonksiyon yazılmıştır. Fonksiyonun genel kullanımı şöyledir:

    ./mymknod [-m ya da --mode <erişim hakları>] <path> <c ya da b> <majör numara> <minör numara>

    Örnek bir çalıştırma şöyle olabilir:

    $ sudo ./mymknode -m 666 mydriver c 25 0

    Programı sudo ile çalıştırmayı unutmayınız.
---------------------------------------------------------------------------------------------------------------------------*/

/* mymknod.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <getopt.h>
#include <sys/sysmacros.h>

bool ismode_correct(const char *mode);
void exit_sys(const char *msg);

int main(int argc, char *argv[])        /* ./mymknod [-m <mode>] <path> <type> <major> <minor> */
{
    int m_flag;
    int err_flag;
    char *m_arg;
    int result;
    int mode;
    dev_t dev;

    struct option options[] = {
        {"mode", required_argument, NULL, 'm'},
        {0, 0, 0, 0}
    };

    m_flag = err_flag = 0;

    opterr = 0;
    while ((result = getopt_long(argc, argv, "m:", options, NULL)) != -1) {
        switch (result) {
        case 'm':
            m_flag = 1;
            m_arg = optarg;
            break;
        case '?':
            if (optopt == 'm')
                fprintf(stderr, "option -m or --mode without argument!...\n");
            else if (optopt != 0)
                fprintf(stderr, "invalid option: -%c\n", optopt);
            else
                fprintf(stderr, "invalid long option!...\n");

            err_flag = 1;
            break;
        }
    }
    if (err_flag)
        exit(EXIT_FAILURE);

    if (argc - optind != 4) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (m_flag) {
        if (!ismode_correct(m_arg)) {
            fprintf(stderr, "incorrect mode argument!...\n");
            exit(EXIT_FAILURE);
        }
        sscanf(m_arg, "%o", &mode);
    }
    else
        mode = 0644;

    if (argv[optind + 1][1] != '\0') {
        fprintf(stderr, "invalid type argument: %s\n", argv[optind + 1]);
        exit(EXIT_FAILURE);
    }
    if (argv[optind + 1][0] == 'c')
        mode |= S_IFCHR;
    else if (argv[optind + 1][0] == 'b')
        mode |= S_IFBLK;
    else {
        fprintf(stderr, "invalid type argument: %s\n", argv[optind + 1]);
        exit(EXIT_FAILURE);
    }

    dev = makedev(atoi(argv[optind + 2]), atoi(argv[optind + 3]));

    umask(0);
    if (mknod(argv[optind + 0], mode, dev) == -1)
        exit_sys("mknod");

    return 0;
}

bool ismode_correct(const char *mode)
{
    if (strlen(mode) > 3)
        return false;

        while (*mode != '\0') {
        if (*mode < '0' || *mode > '7')
            return false;
        ++mode;
    }

    return true;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında yukarıda yazdığımız mymknod programının aynısı zaten mknod isimli kabuk komutu biçiminde bulunmaktadır. Bu komutun
    genel biçimi şöyledir:

    sudo mknod [-m ya da --mode <erişim hakları>] <dosya ismi> <c ya da b> <majör numara> <minör numara>

    Örneğin:

    $ sudo mknod devfile c 25 0

    mknod komutunu sudo ile çalıştırmayı unutmayınız. Yukarıdaki komut uygulandığında oluşturulan dosya şöyle olacaktır:

    crw-rw-rw- 1 root root 25, 0 Mar 29 22:05 mydriver
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir çekirdek modülünün karakter aygıt sürücüsü haline getirilebilmesi için öncelikle bir aygıt numarasıyla (majör ve minör 
    numara ile) temsil edilip çekirdeğe kaydettirilmesi (register ettirilmesi) gerekmektedir. Bu işlem tipik olarak 
    register_chrdev_region isimli çekirdek fonksiyonuyla yapılır. Fonksiyonun prototipi şöyledir:

    #include <linux/fs.h>

    int register_chrdev_region(dev_t from, unsigned count, const char *name);

    Fonksiyonun birinci parametresi aygıt sürücünün majör ve minör numaralarına ilişkin dev_t türünden değeri almaktadır. Bu 
    parametre için argüman genellikle MKDEV makrosuyla oluşturulmaktadır. MKDEV makrosu majör ve minör numarayı argüman olarak alıp 
    bunlardan dev_t türünden aygıt numarası oluşturmaktadır. Fonksiyonun ikinci parametresi ilk parametrede belirtilen minör numaradan 
    itibaren kaç minör numaranın kaydettirileceğini belirtmektedir. Örneğin biz majör = 20, minör = 0'dan itibaren 5 minör numarayı 
    kaydettirebiliriz. Fonksiyonun son parametresi proc ve sys dosya sistemlerinde görüntülenecek olan aygıt sürücünün ismini 
    belirtmektedir. Çekirdek modüllerinin isimleri çekirdek modül dosyasından gelmektedir. Ancak karakter aygıt sürücülerinin isimlerini 
    biz istediğimiz gibi verebiliriz. Tabii her aygıt sürücü bir çekirdek modülü biçiminde yazılmak zorundadır.

    register_chrdev_region fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda negatif errno değerine geri dönmektedir. 
    Fonksiyon tipik olarak çekirdek modülünün "init" fonksiyonunda çağrılır. Eğer fonksiyon başarısız olursa init fonksiyonu da 
    bu fonksiyonun geri döndürdüğü değerle geri döndürülür. Örneğin:

    static int __init generic_init(void)
    {
        int result;

        printk(KERN_INFO "generic-char-driver module initialization...\n");

        if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
            printk(KERN_ERR "cannot register device!...\n");
            return result;
        }

        return 0;
    }

    Sistemde zaten yüklü olan aynı majör numaraya ilişkin bir aygıt sürücü varsa ya da fonksiyona girilen aygıt numarası geçersiz
    ise fonksiyon başarısız olabilir.

    register_chrdev_region fonksiyonu ile register ettirilmiş olan majör ve minör numaralar unregister_chrdev_region fonksiyonuyla 
    geri bırakılmalıdır. Aksi halde modül çekirdek alanından "rmmod" komutuyla atılsa bile bu aygıt numaraları tahsis edilmiş bir 
    biçimde kalmaya devam edecektir. Bu da önemli sorunlar doğurabilir. unregister_chrdev_region fonksiyonunun prototipi şöyledir:

    #include <linux/fs.h>

    void unregister_chrdev_region (dev_t from, unsigned count);

    Fonksiyonun birinci parametresi aygıt sürücünün register ettirilmiş olan majör ve minör numarasını, ikinci parametresi ise yine 
    o noktadan başlayan kaç minör numaranın unregister ettirileceğini belirtmektedir. Bu fonksiyon da tipik olarak aygıt sürücünün
    cleanup fonksiyonunda (exit fonksiyonunda) çağrılmalıdır. Örneğin:

    static void __exit helloworld_exit(void)
    {
        printk(KERN_INFO "generic-char-driver exit...\n");

        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
    }

    Bir aygıt sürücü register_chrdev_region fonksiyonuyla majör ve minör numarayı register ettirdiğinde artık "/proc/devices" 
    dosyasında bu aygıt sürücü için bir satır yaratılır. Aygıt sürücü unregister_chrdev_region fonksiyonuyla yok edildiğinde 
    "/proc/devices" dosyasındaki satır silinir. Örneğin aygıt sürücümüzü yükledikten sonra "/proc/devices" dosyasının içeriği 
    aşağıdakine benzer görüntülenecektir:

    Character devices:
    1 mem
    4 /dev/vc/0
    4 tty
    4 ttyS
    5 /dev/tty
    5 /dev/console
    5 /dev/ptmx
    5 ttyprintk
    6 lp
    7 vcs
    10 misc
    13 input
    14 sound/midi
    14 sound/dmmidi
    21 sg
    29 fb
    89 i2c
    99 ppdev
    108 ppp
    116 alsa
    128 ptm
    130 generic-char-driver
    136 pts
    ...

    Buradan da görüldüğü gibi aygıt sürücümüz "generic-char-driver" ismiyle 130 majör numaraya sahip olacak biçimde yüklenmiştir.

    Aşağıdaki örnekte çekirdek modülünün init fonksiyonunda register_chrdev_region fonksiyonu Majör = 139, Minor = 1 olacak 
    biçimde bir aygıt numarası çekirdeğe kaydettirilmiştir. Bu kayıt modülün exit fonksiyonunda unregister_chrdev_region fonksiyonu 
    ile silinmiştir. çekirdek modülünü aşağıdaki gibi derleyebilirsiniz:

    $ make file=generic-char-driver

    Modülü install ettikten sonra "/proc/modules" ve "/proc/devices" dosyalarına bakınız. "proc/devices" dosyasında aygıt
    sürücünün belirlediğimiz isimle ve majör numarayla kaydettirildiğini göreceksiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>

#define DEV_MAJOR    130
#define DEV_MINOR    0

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "Cannot load generic-char-driver!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    printk(KERN_INFO "generic-char-driver exit...\n");

    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
                                                132. Ders 05/04/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi aygıt sürücümüzü belli bir majör ve minör numarayla sisteme register ettirdikten sonra ne yapacağız? İşte aygıt 
    sürücüleri kabaca bir grup fonksiyondan oluşan modüller biçiminde düşünebiliriz. Aygıt sürücü içerisindeki fonksiyonlar 
    kullanıcı modunda bazı işlemler sonucunda çekirdek tarafından çağrılmaktadır. Örneğin:

    - Programcı aygıt sürücüye ilişkin aygıt dosyasını open fonksiyonu ile açtığı zaman aygıt sürücü içerisindeki "open" 
    fonksiyonu çağrılır.

    - Programcı aygıt dosyasından elde ettiği dosya betimleyicisi ile read işlemi yaptığında aygıt sürücü içerisindeki "read" 
    fonksiyonu çağrılır.

    - Programcı aygıt dosyasından elde ettiği dosya betimleyicisi ile write işlemi yaptığında aygıt sürücü içerisindeki "write" 
    fonksiyonu çağrılır.

    - Programcı aygıt dosyasından elde ettiği dosya betimleyicisi ile close işlemi yaptığında aygıt sürücü içerisindeki "close" 
    fonksiyonu çağrılır.

    Buradaki aygıt sürücü içerisindeki open, read, write, close fonksiyonlarına aygıt sürücüyü yazanlar istedikleri ismi verebilmektedir.
    Tabii yukarıda belirtmediğimiz ancak konular içerisinde göreceğimiz başka işlemler sonucunda yine aygıt sürücünün o işlemlere
    ilişkin fonksiyonları çağrılmaktadır. Aynı zamanda aygıt sürücüleri yazanlar dosya işlemleriyle doğrudan ilgili olmayan 
    aygıt sürücü fonksiyonlarına numaralar atayarak onların kullanıcı modundan ioctl isimli POSIX fonksiyonuyla (tabii bu POSIX 
    fonksiyonu da sys_ioctl isimli sistem fonksiyonunu çağırmaktadır) çağrılmasını sağlayabilmektedir. Tabii şüphesiz aygıt sürücü 
    içerisindeki bu fonksiyonlar çekirdek modunda çalıştırılmaktadır. Zaten aygıt sürücü yazmanın ana nedenlerinden biri kullanıcı
    modunda yapılamayan işlemlerin çekirdek modunda yapılmasını sağlamak içindir.

    Ancak aygıt sürücüleri yalnızca kullanıcı modundan çekirdek modunda çalışacak fonksiyon çağırma mekanizması olarak düşünmemek 
    gerekir. Aygıt sürücüler birtakım kesmelere o anda yanıt verebilmektedir. Dolayısıyla aynı zamanda onları çekirdek modunda 
    çalışan birer program gibi de düşünebiliriz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir çekirdek modülü bir aygıt numarasıyla ilişkilendirdikten sonra artık ona gerçek anlamda bir karakter aygıt sürücü kimliğinin 
    kazandırılması gerekir. Bu işlem struct cdev isimli bir yapının içinin doldurularak sisteme eklenmesi (yerleştirilmesi) 
    ile yapılmaktadır. Linux çekirdeği tüm çekirdek modüllerini ve aygıt sürücülerini çeşitli veri yapılarıyla tutmaktadır. 
    Aygıt sürücü yazan programcılar çekirdeğin bu organizasyonunu bilmek zorunda değillerdir. Ancak bazı işlemleri tam gerektiği 
    gibi yapmak zorundadırlar. (Linux çekirdeğinin aygıt sürücü mimarisi oldukça karmaşıktır. Bu konu "Linux Kernel" kursunda ele 
    alınmaktadır.)

    cdev aşağıdaki gibi bir yapıdır:

    #include <linux/fs.h>

    struct cdev {
        struct kobject kobj;
        struct module *owner;
        const struct file_operations *ops;
        struct list_head list;
        dev_t dev;
        unsigned int count;
    };

    Bu türden bir yapı nesnesi programcı tarafından global olarak (statik ömürlü olarak) tanımlanabilir ya da alloc_cdev isimli 
    çekirdek fonksiyonuyla çekirdeğin heap sistemi (slab allocator) kullanılarak dinamik bir biçimde tahsis edilebilir. (İşletim 
    sistemlerinin çekirdeklerinin ayrı bir heap sistemi vardır. Linux çekirdeğinde spesifik türden nesnelerin hızlı tahsis edilmesi 
    için "slab allocator" denilen bir heap sistemi kullanılmaktadır.) Bu yapı nesnesini yerel bir nesne biçiminde oluşturmayınız. 
    Çünkü yerel değişkenler fonksiyon sonlandığında yok edilirler. Halbuki bu yapı nesnesinin aygıt sürücü yüklü olduğu sürece 
    bellekte bulunuyor olması gerekir.

    Eğer cdev türünden bu yapı nesnesi programcı tarafından global bir biçimde tanımlanacaksa yapının elemanlarına ilk değer 
    vermek için cdev_init fonksiyonu çağrılmalıdır. Eğer cdev yapısı cdev_alloc fonksiyonuyla dinamik bir biçimde tahsis edilecekse 
    artık yapı elemanlarına ilkdeğerlerin verilmesi işlemi cdev_init fonksiyonuyla yapılmaz. Çünkü zaten cdev_alloc bu işlemi 
    kendi içerisinde yapmaktadır. Fakat yine de programcının bu durumda manuel olarak yapının bazı elemanlarına değer ataması 
    da gerekmektedir. Bu iki yoldan biriyle oluşturulmuş olan cdev yapı nesnesi cdev_add isimli fonksiyonla çekirdeğin veri 
    yapılarına yerleştirilmelidir. Tabii aygıt sürücü boşaltılırken bu yerleştirme işlemi cdev_del fonksiyonuyla geri alınmalıdır. 
    cdev_del fonksiyonu, struct cdev yapısı cdev_alloc ile tahsis edilmişse aynı zamanda onu free hale de getirmektedir. Özetle 
    çekirdek modülümüzün tam bir karakter aygıt sürücüsü haline getirilmesi için şunlar yapılmalıdır:

    1) struct cdev isimli bir yapı türünden nesne global olarak (statik ömürlü olarak) tanımlanmalı ya da cdev_alloc fonksiyonu 
    ile çekirdeğin heap sistemi içerisinde tahsis edilmelidir. Eğer bu nesne global olarak tanımlanacaksa nesneye cdev_init 
    fonksiyonu ile ilkdeğerleri verilmelidir. Eğer nesne cdev_alloc fonksiyonu ile çekirdeğin heap alanında tahsis edilecekse 
    bu durumda ilkdeğer verme işlemi bu fonksiyon tarafından yapılmaktadır. Ancak programcının yine yapının bazı elemanlarını 
    manuel olarak doldurması gerekmektedir.

    2) Oluşturulan bu struct cdev nesnesi cdev_add çekirdek fonksiyonu ile çekirdeğe eklenmelidir.

    3) Çekirdek modülü çekirdek alanından atılırken modülün exit fonksiyonunda cdev_add işleminin geri alınması için cdev_del 
    fonksiyonunun çağrılması gerekmektedir.

    cdev_init fonksiyonunun parametrik yapısı şöyledir:

    #include <linux/cdev.h>

    void cdev_init(struct cdev *cdev, const struct file_operations *fops);

    Fonksiyonun birinci parametresi ilk değer verilecek global cdev nesnesinin adresini alır. İkinci parametre ise file_operations 
    türünden bir yapı nesnesinin adresi almaktadır. file_operations isimli yapı birtakım fonksiyon adreslerinden oluşmaktadır. 
    Yani yapının tüm elemanları birer fonksiyon göstericisidir. Bu yapı kullanıcı modundaki program tarafından ilgili aygıt 
    dosyası açılıp çeşitli işlemler yapıldığında çağrılacak fonksiyonların adreslerini tutmaktadır. Örneğin kullanıcı modundaki 
    program open, close, read, write yaptığında çağrılacak fonksiyonlarımızı burada belirtiriz. file_operations büyük bir yapıdır:

    struct file_operations {
        struct module *owner;
        loff_t (*llseek) (struct file *, loff_t, int);
        ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
        ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
        ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
        ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
        int (*iopoll)(struct kiocb *kiocb, bool spin);
        int (*iterate) (struct file *, struct dir_context *);
        int (*iterate_shared) (struct file *, struct dir_context *);
        __poll_t (*poll) (struct file *, struct poll_table_struct *);
        long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
        long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
        int (*mmap) (struct file *, struct vm_area_struct *);
        unsigned long mmap_supported_flags;
        int (*open) (struct inode *, struct file *);
        int (*flush) (struct file *, fl_owner_t id);
        int (*release) (struct inode *, struct file *);
        int (*fsync) (struct file *, loff_t, loff_t, int datasync);
        int (*fasync) (int, struct file *, int);
        int (*lock) (struct file *, int, struct file_lock *);
        ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
        unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
        int (*check_flags)(int);
        int (*flock) (struct file *, int, struct file_lock *);
        ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
        ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
        int (*setlease)(struct file *, long, struct file_lock **, void **);
        long (*fallocate)(struct file *file, int mode, loff_t offset, loff_t len);
        void (*show_fdinfo)(struct seq_file *m, struct file *f);
    #ifndef CONFIG_MMU
        unsigned (*mmap_capabilities)(struct file *);
    #endif
        ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);
        loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in, struct file *file_out, loff_t pos_out,
                    loff_t len, unsigned int remap_flags);
        int (*fadvise)(struct file *, loff_t, loff_t, int);
    };

    Bu yapının yalnızca bazı elemanlarına atama yapabiliriz. Bunun için gcc eklentilerinden faydalanılabilir. (Bu eklentiler 
    C99 ile birlikte C'ye eklenmiştir.) Örneğin:

    static int generic_open(struct inode *inodep, struct file *filp);
    static int generic_release(struct inode *inodep, struct file *filp);

    struct file_operations g_file_ops = {
        .owner = THIS_MODULE,
        .open = generic_open,
        .release = generic_release
    };

    Yapının owner elemanına THIS_MODULE makrosunun atanması iyi bir tekniktir. Biz burada "aygıt sürücümüz open fonksiyonuyla 
    açıldığında generic_open isimli fonksiyon çağrılsın", aygıt sürücümüz close fonksiyonu ile kapatıldığında "generic_release 
    isimli fonksiyonumuz çağrılsın" demiş olmaktayız.

    Yukarıda da belirttiğimiz gibi cdev yapısı cdev_alloc fonksiyonuyla dinamik bir biçimde de tahsis edilebilir. cdev_alloc 
    fonksiyonunun prototipi şöyledir:

    #include <linux/cdev.h>

    struct cdev *cdev_alloc(void);

    Fonksiyon başarı durumunda cdev yapısının adresine, başarısızlık durumunda NULL adrese geri dönmektedir. Yukarıda da belirttiğimiz
    gibi cdev yapısı cdev_alloc fonksiyonu ile tahsis edilmişse cdev_init yapılmasına gerek yoktur. Ancak bu durumda programcının 
    manuel olarak yapının owner ve ops elemanlarına değer ataması gerekir. Örneğin:

    struct cdev *g_cdev;
    ...
    if ((gcdev = cdev_alloc()) == NULL) {
        printk(KERN_ERROR "cannot allocate cdev!...\n");
        return -ENOMEM;
    }
    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;

    cdev_alloc fonksiyonu başarısız olduğunda bunu çağıran fonksiyonun -ENOMEM değeri ile geri döndürülmesi uygun olur. ENOMEM 
    errno değeri bellek yetersizliği nedeniyle başarısızlık oluştuğunu belirtmektedir. cdev yapı nesnesi başarılı bir biçimde 
    oluşturulduktan sonra artık bu yapının çekirdek modülü içerisine yerleştirilmesi gerekir. Bu da cdev_add fonksiyonuyla 
    yapılmaktadır. cdev_add fonksiyonunun prototipi de şöyledir:

    #include <linux/cdev.h>

    int cdev_add(struct cdev *devp, dev_t dev, unsigned count);

    Fonksiyonun birinci parametresi cdev türünden yapı nesnesinin adresini almaktadır. Fonksiyonun ikinci parametresi aygıt sürücünün 
    majör ve minör numaralarını, üçüncü parametresi ise ilgili minör numaradan itibaren kaç minör numaranın kullanılacağı belirtmektedir.
    Fonksiyon başarı durumunda sıfır değerine, başarısızlık durumunda negatif errno değerine geri döner. Örneğin:

    if ((result = cdev_add(&g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        ...
        return result;
    }

    Aygıt sürücü boşaltılırken cdev_add ile yapılan işlemin geri alınması gerekir. Bu da cdev_del fonksiyonuyla yapılmaktadır. 
    (cdev_alloc işlemi için bunu free hale getiren ayrı bir fonksiyon yoktur. cdev_alloc ile tahsis edilen alan cdev_del fonksiyonu 
    tarafından otomatik olarak free hale getirilmektedir.)

    #include <linux/cdev.h>

    void cdev_del(struct cdev *devp);

    Fonksiyon parametre olarak cdev yapısının adresini almaktadır.

    Buradaki önemli bir nokta şudur: cdev_add fonksiyonu cdev nesnesinin içini çekirdekteki uygun veri yapısına kopyalamamaktadır. 
    Bizzat bu nesnenin adresini kullanmaktadır. Yani çekirdek modülü var olduğu sürece bu cdev nesnesinin de yaşıyor olması gerekir.
    Bu da cdev nesnesinin ve file_operations nesnesinin global biçimde (ya da statik ömürlü biçimde) tanımlanmasını gerektirmektedir.

    Aşağıda bu işlemlerin yapıldığı örnek bir karakter aygıt sürücüsü verilmiştir. Bu aygıt sürücü majör=130, minör=0 aygıtını 
    kullanmaktadır. Dolayısıyla aşağıdaki programın testi için şöyle bir aygıt dosyasının yaratılmış olması gerekir. Yaratımı
    aşağıdaki gibi yapabilirsiniz:

    $ sudo mknod mydriver -m 666 c 130 0

    Bu aygıt sürücü insmod ile yüklendiğinde artık biz kullanıcı modunda "mydriver" dosyasını açıp kapattığımızda file_operations
    yapısına yerleştirdiğimiz generic_open ve generic_release fonksiyonları çağrılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define DEV_MAJOR    130
#define DEV_MINOR    0

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);

static struct cdev g_cdev;
struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release
};

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "Cannot load generic-char-driver!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        printk(KERN_ERR "Cannot add device...\n");
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    printk(KERN_INFO "generic-char-driver exit...\n");

    cdev_del(&g_cdev);
    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic_open called...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic_release called...\n");

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open("mydriver", O_RDONLY)) == -1)
        exit_sys("open");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki programda biz cdev nesnesini global olarak tanımladık. Aşağıda ise cdev nesnesinin cdev_alloc fonksiyonu ile 
    dinamik biçimde tahsis edilmesine bir örnek veriyoruz. cdev_alloc fonksiyonu ile tahsis edilmiş alanların zaten cdev_del 
    fonksiyonu ile geri bırakıldığını belirtmiştik. Ancak cdev_add fonksiyonu başarısız olursa cdev_del fonksiyonunun çağrılması
    anlamsız olacağı için cdev_alloc fonksiyonu ile tahsis edilmiş olan alan kfree fonksiyonuyla serbest bırakılmıştır. kfree
    fonksiyonu çekirdek heap sistemine ilişkin genel bir bir fonksiyondur. Çekirdek heap sistemine "dilimli tahsisat sistemi 
    (slab allocator)" denilmektedir. Bu konu ileride ele alınacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/slab.h>

#define DEV_MAJOR    130
#define DEV_MINOR    0

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);

static struct cdev *g_cdev;
struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release
};

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "Cannot load generic-char-driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_ERR "cannot allocate cdev!...\n");
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        return -ENOMEM;
    }
    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_fops;

    if ((result = cdev_add(g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        printk(KERN_ERR "Cannot add device..\n");
        kfree(g_cdev);
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    printk(KERN_INFO "generic-char-driver exit...\n");

    cdev_del(g_cdev);
    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic_open called...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic_release called...\n");

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open("mydriver", O_RDONLY)) == -1)
        exit_sys("open");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                133. Ders 07/04/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdek kodlarının ve aygıt sürücü kodlarının çekirdek modunda (kernel mode) çalıştığını belirtmiştik. Çekirdeğin bulunduğu
    bellek alanı ile kullanıcı proseslerinin bulunduğu bellek alanı birbirlerinden izole edilmiştir. Daha önceden de belirttiğimiz 
    gibi kullanıcı modunda çalışan prosesler çekirdek alanına erişemezler. Çünkü çekirdek kendisini sayfa tabanlı koruma mekanizması 
    yoluyla sıradan proseslerden korumaktadır. Fakat bazı durumlarda çekirdek alanı alanı kullanıcı proseslerinin bulunduğu kullanıcı 
    alanı arasında veri transferlerinin yapılması gerekebilmektedir. Örneğin sys_read sistem fonksiyonu çekirdek tarafından okunan 
    bilgileri kendisini çağıran prosesin kullanıcı alanına aktarmaktadır. sys_write fonksiyonu ise bunun tersini yapmaktadır.

    Çekirdek alanı ile kullanıcı alanı arasında memcpy fonksiyonu ile transfer yapmaya çalışmak uygun değildir. Bunun birkaç 
    nedeni vardır. Bu tür transferlerde çekirdek modunda çalışan kodların kullanıcı alanındaki adresin geçerliliğini kontrol 
    etmesi gerekir. Aksi takdirde çekirdek modunda geçersiz bir alana kopyalama yapmak sistemin çökmesine yol açabilmektedir. 
    Örneğin biz sys_read sistem fonksiyonu ile dosyadan belirttiğimiz adrese aktarım yapmak isteyelim. Eğer biz kendi prosesimize 
    ilişkin bir adres vermek yerine çekirdeğin çalıştığı alana ilişkin bir adres verirsek tüm sistem çökebilir. İşte sys_read 
    fonksiyonu aktarımı yapmadan önce verilen adresin gerçekten prosesin adres alanı içerisindeki bir adres olup olmadığını 
    kontrol etmektedir. Ayrıca kullanıcı alanına ilişkin prosesin sayfa tablosunun bazı bölümleri o anda RAM'de olmayabilir 
    (yani swap out yapılmış olabilir). Böyle bir durumda işleme devam etmek çekirdek tasarımı bakımından sorun oluşturmaktadır. 
    Eğer böyle bir durum varsa çekirdek kodlarının önce sayfa tablosunu RAM'e geri yükleyip işlemine devam etmesi gerekmektedir.

    İşte yukarıda açıklanan bazı nedenlerden dolayı çekirdek alanı ile kullanıcı alanı arasında aktarım işlemi için özel çekirdek 
    fonksiyonları kullanılmaktadır. Yani biz kullanıcı modunda çalışan programlar ile çekirdek modülümüz arasında aktarımları 
    özel bazı çekirdek fonksiyonlarıyla yapmalıyız. Bu amaçla kullanılan çeşitli çekirdek fonksiyonları ve makroları bulunmaktadır. 
    En temel iki fonksiyon copy_to_user ve copy_from_user fonksiyonlarıdır. Bu fonksiyonların prototipleri şöyledir:

    #include <linux/uaccess.h>

    unsigned long copy_to_user(void *to, const void *from, unsigned len);
    unsigned long copy_from_user(void *to, const void *from, unsigned len);

    Fonksiyonların birinci parametreleri kopyalamanın yapılacağı hedef adresi belirtmektedir. Yani copy_to_user için birinci 
    parametre user alanındaki adres, copy_from_user için birinci parametre çekirdek alanındaki adrestir. İkinci parametre kaynak 
    adresi belirtmektedir. Bu kaynak adres copy_to_user için çekirdek alanındaki adres, copy_from_user için kullanıcı alanındaki 
    adrestir. Son parametre aktarılacak byte sayısını belirtmektedir. Fonksiyonlar başarı durumunda 0 değerine, başarısızlık 
    durumunda aktarılamayan byte sayısına geri dönerler. Çekirdek mod programcılarının bu fonksiyonlar başarısız olursa kendi
    fonksiyonlarını -EFAULT (Bad address) ile geri döndürmesi uygun olur. (Örneğin sys_read ve sys_write fonksiyonlarına 
    biz geçersiz bir user mode adresi verirsek bu sistem fonksiyonları da -EFAULT değeri ile geri dönmektedir. Bu hata kodunun 
    yazısal karşılığı "Bad address" biçimindedir.) Örneğin:

    if (copy_to_user(...) != 0)
        return -EFAULT;

    Bazen kullanıcı alanındaki adresin geçerliliği zaten daha önceden sınanmıştır. Bu durumda yeniden geçerlilik sınaması yapmadan 
    yukarıdaki işlemleri yapan __copy_to_user ve __copy_from_user fonksiyonları kullanılabilir. Bu fonksiyonların parametrik 
    yapıları copy_to_user ve copy_from_user fonksiyonları ile aynıdır. Aralarındaki tek fark ise bu fonksiyonların adres geçerliliğine 
    ilişkin sınama yapmamalarıdır:

    #include <linux/uaccess.h>

    unsigned long __copy_to_user(void *to, const void *from, unsigned len);
    unsigned long __copy_from_user(void *to, const void *from, unsigned len);

    Bazı durumlarda programcı 1 byte, 2 byte, 4 byte, 8 byte'lık verileri transfer etmek isteyebilir. Bu küçük miktardaki verilerin 
    transfer edilmesi için daha hızlı çalışan özel iki makro bulundurulmuştur: put_user ve get_user. Bu makroların parametrik 
    yapısı şöyledir:

    #include <linux/uaccess.h>

    put_user(x, ptr);
    get_user(x, ptr);

    Burada x aktarılacak nesneyi belirtir. (Bu nesnenin adresini programcı almaz, makro içinde bu işlem yapılmaktadır.) ptr 
    ise aktarım adresini belirtmektedir. Aktarım ikinci parametrede belirtilen adresin türünün uzunluğu kadar yapılmaktadır. 
    Başka bir deyişle biz makroya hangi türden nesne verirsek zaten makro o uzunlukta aktarım yapmaktadır.

    Makrolar başarı durumunda 0, başarısızlık durumunda negatif hata koduna geri dönerler. Kullanımları şöyle olabilir:

    if (put_user(...) != 0)
        return -EFAULT;

    Bu makroların da geçerlilik kontrolü yapmayan __put_user ve __get_user isimli versiyonları vardır:

    #include <linux/uaccess.h>

    __put_user(x, ptr);
    __get_user(x, ptr);

    Örneğin biz çekirdek modülümüzdeki 4 byte'lık int bir x nesnesinin içerisindeki bilgiyi puser ile temsil edilen kullanıcı 
    alanındaki adrese kopyalamak isteyelim. Bu işlemi şöyle yaparız:

    int x;
    int *puser;
    ...
    if (put_user(x, puser) != 0)
        return -EFAULT;

    Nihayet kullanıcı alanındaki adresin geçerliliği de access_ok isimli makroyla sorgulanabilmektedir. Makro şöyledir:

    #include <linux/uaccess.h>

    access_ok(type, addr, size);

    Buradaki type sınama geçerliliğinin türünü belirtmektedir. Okuma geçerliliği için bu parametre VERIFY_READ, yazma geçerliliği 
    için VERIFY_WRITE ve hem okuma hem de yazma geçerliliği için VERIFY_READ|VERIFY_WRITE biçiminde girilmelidir. İkinci 
    parametre geçerliliği sınanacak adresi ve üçüncü parametre de o adresten başlayan alanın uzunluğunu belirtmektedir. 
    Fonksiyon başarı durumunda sıfır dışı bir değere, başarısızlık durumunda sıfır değerine geri dönmektedir. Örneğin biz 
    kullanıcı alanında puser adresiyle başlayan 100 byte'lık alanın yazma bakımından geçerli bir alan olup olmadığını sınamak 
    isteyelim. Bu sınamayı çekirdek modülümüzde şöyle yapabiliriz:

    if (access_ok(VERIFY_WRITE, puser, 100)) {        // adres geçerli
        ...
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar aygıt dosyası open ile açıldığında ve close ile kapatıldığında aygıt sürücümüz içerisindeki fopen ve release 
    fonksiyonlarımızın çağrılmasını sağladık. Şimdi de aygıt dosyası üzerinde read ve write fonksiyonları uygulandığında aygıt 
    sürücümüzdeki read ve write fonksiyonlarının çağrılması üzerinde duracağız.

    Aygıt dosyası open POSIX ile açılıp read POSIX fonksiyonu ile okunduğunda aygıt sürücümüz içerisinde belirlediğimiz "read" 
    fonksiyonumuz, write POSIX fonksiyonu çağrıldığında da aygıt sürücümüz içerisinde belirlediğimiz write fonksiyonumuz çağrılmaktadır. 
    Bunu sağlamak için file_operations yapısının read ve write elemanlarına çağrılacak fonksiyonların adreslerini girmeliyiz. 
    Karakter aygıt sürücülerinin read ve write fonksiyonlarının prototipleri aşağıdaki gibi olmak zorundadır:

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
    static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

    Aygıt sürücüsü için read ve write fonksiyonları yukarıdaki prototipe uygun bir biçimde tanımlandıktan sonra bunların adresleri 
    aşağıdaki gibi file_operations türünden yapı nesnesinin read ve write elemanlarına atanmalıdır:

    static struct file_operations g_file_ops = {
        .owner = THIS_MODULE,
        .open = generic_open,
        .release = generic_release,
        .read = generic_read,
        .write = generic_write,
    };

    Artık aygıt dosyası üzerinde read POSIX fonksiyonu çağrıldığında aygıt sürücümüzdeki generic_read fonksiyonu, write POSIX 
    fonksiyonu çağrıldığında da aygıt sürücümüzdeki generic_write POSIX fonksiyonu çağrılacaktır.

    Aygıt sürücümüzdeki read ve write fonksiyonlarının birinci parametresi açılmış dosyaya ilişkin struct file nesnesinin adresini 
    belirtir. Bu nesneye "dosya nesnesi (file object)" de denilmektedir.

    Anımsanacağı gibi bir dosya açıldığında çekirdek sys_open fonksiyonunda bir dosya nesnesi (struct file) tahsis edip bu dosya 
    nesnesinin adresini dosya betimleyici tablosundaki bir slota yerleştirip onun indeksini dosya betimleyicisi olarak geri 
    döndürüyordu. İşte bu read ve write fonksiyonlarının birinci parametreleri bu dosya nesnesinin adresini belirtmektedir. 
    Çekirdek açık dosya ilgili her türlü işlemi bu dosya nesnesindeki bilgilerden hareketle yapmaktadır.

    Dosya Betimleyici Tablosu

    0   ---------> Dosya Nesnesi
    1   ---------> Dosya Nesnesi
    2   ---------> Dosya Nesnesi
    3   ---------> Dosya Nesnesi
    4   ---------> Dosya Nesnesi
    5   ---------> Dosya Nesnesi
    ...

    Daha önceden de belirttiğimiz gibi file yapısı içerisinde dosya göstericisinin konumu, dosyanın erişim hakları, referans sayacının 
    değeri, dosyanın açış modu ve açış bayrakları ve başka birtakım bilgiler bulunmaktadır. Linux çekirdeğinin 2.4.30'daki 
    sürümündeki file yapısı şöyledir:

    struct file {
        struct list_head        f_list;
        struct dentry            *f_dentry;
        struct vfsmount            *f_vfsmnt;
        struct file_operations    *f_op;
        atomic_t                f_count;
        unsigned int            f_flags;
        mode_t                    f_mode;
        loff_t                    f_pos;
        unsigned long            f_reada, f_ramax, f_raend, f_ralen, f_rawin;
        struct fown_struct        f_owner;
        unsigned int            f_uid, f_gid;
        int                        f_error;

        size_t                    f_maxcount;
        unsigned long            f_version;

        // needed for tty driver, and maybe others
        void                    *private_data;

        // preallocated helper kiobuf to speedup O_DIRECT
        struct kiobuf            *f_iobuf;
        long                    f_iobuf_lock;
    };

    Biz burada bilerek sadelik sağlamak için eski bir çekirdeğin file yapısını verdik. Yeni çekirdeklerde buna birkaç eleman daha 
    eklenmiştir. Ancak temel elemanlar yine aynıdır. Biz aygıt sürücümüzün read ve write fonksiyonlarında söz konusu aygıt 
    dosyasının birtakım özelliklerine erişmek istediğimizde bu yapıyı kullanırız.

    Aygıt sürücüdeki read ve write fonksiyonlarının ikinci parametresi kullanıcı alanındaki transfer adresini belirtir. Kullanıcı 
    modunda read POSIX fonksiyonu çağrıldığında aygıt sürücüdeki read fonksiyonunun copy_to_user gibi bir fonksiyonla bu adrese
    transfer yapması gerekir. Benzer biçimde kullanıcı modunda write POSIX fonksiyonu çağrıldığında da aygıt sürücü içerisindeki 
    write fonksiyonunun kullanıcı modundaki bu adresten copy_from_user gibi bir fonksiyonla transfer yapması gerekir. Aygıt 
    sürücüdeki read ve write fonksiyonlarının üçüncü parametreleri okunacak ya da yazılacak byte miktarını belirtmektedir. Son 
    parametre ise dosya göstericisinin konumunu belirtir. Ancak bu parametre file yapısı içerisindeki f_pos elemanının adresi 
    değildir. Çekirdek tarafından aygıt sürücünün read ve write fonksiyonları çağrılmadan önce file yapısı içerisindeki f_pos 
    elemanının değeri başka bir nesneye atanıp o nesnenin adresi read ve write fonksiyonlarına geçirilmektedir. read ve write 
    fonksiyonları sonlandığında çekirdek adresini geçirdiği nesnenin değerini file yapısının f_pos elemanına kendisi yerleştirmektedir.
    Yani aygıt sürücümüzdeki read ve write fonksiyonları içerisinde biz her zaman dosya göstericisinin konumunu bu parametrenin
    gösterdiği nesneden alıp bu parametrenin gösterdiği yerdeki nesneyi güncellemeliyiz.

    Aygıt sürücü içerisindeki read ve write fonksiyonları başarı durumunda transfer edilen byte sayısına, başarısızlık durumunda 
    negatif errno değerine geri dönmelidir.

    Biz aygıt sürücümüz için read ve write fonksiyonlarını yazarken read ve write fonksiyonları içerisinde transfer edilen byte 
    miktarı kadar dosya göstericisini ilerletmemiz gerekir. Bu işlem yukarıda da belirttiğimiz gibi fonksiyonların son parametresi 
    olan off göstericisinin gösterdiği yerin güncellenmesi ile yapılmalıdır. Örneğin n byte transfer edilmiş olsun. Bu durumda 
    dosya göstericisinin konumu aşağıdaki gibi güncellenebilir:

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        ...
        *off += n;
        ...

        return n;
    }

    Yukarıda da belirttiğimiz gibi aygıt sürücünüzün read ve write fonksiyonlarında dosya göstericisini konumlandırmak için 
    file yapısının f_pos elemanını güncellemeyiniz. Dosya göstericisinin konumlandırılması her zaman read ve write fonksiyonlarının 
    son parametresi yoluyla yapılmaktadır. Çekirdeğin dosya göstericisini nasıl güncellediğine ilişkin aşağıdaki gibi bir 
    temsili kod örneği verebiliriz:

    loff_t off;
    ...
    off = filp->f_pos;
    read(filp, buf, size, &off);
    filp->f_pos = off;

    Aşağıda aygıt sürücüye read ve write fonksiyonları içi boş bir biçimde yerleştirilmiştir. Kullanıcı mode'undan read ve 
    write yapıldığında aygıt sürücümüzün içerisindeki bu fonksiyonların çalıştığını gözlemleyiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define DEV_MAJOR        25
#define DEV_MINOR        0

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver module initialization...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);

    printk(KERN_INFO "generic-char-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "generic_read called...\n");

    return size;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "generic_write called...\n");

    return size;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[100];

    if ((fd = open("mydriver", O_RDWR)) == -1)
        exit_sys("open");

    read(fd, buf, 100);
    write(fd, buf, 100);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                134. Ders 19/04/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de aygıt sürücümüzün read fonksiyonunun gerçekten bir dosyadan okuma yapıyormuş gibi davranmasını sağlayalım. Bunun 
    için dosyamızı temsil eden aşağıdaki gibi global bir dizi kullanacağız:

    static char g_file_buf[] = "01234567890ABCDEFGH";

    Buradaki diziyi sanki bir dosya gibi ele alacağız. Aygıt sürücümüzün read fonksiyonu aşağıdaki gibi olacaktır:

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        size_t esize;
        size_t slen;

        slen = strlen(g_buf);
        esize = *off + size > slen ? slen - *off : size;

        if (copy_to_user(buf, g_buf + *off, esize) != 0)
            return -EFAULT;

        *off += esize;

        return esize;
    }

    Burada önce dosya göstericisinin gösterdiği yerden itibaren "size" kadar byte'ın gerçekten dizi içerisinde olup olmadığına 
    bakılmıştır. Eğer "*off + size" değeri bu dizinin uzunluğundan fazlaysa "size" kadar değer değil, "slen - *off" kadar değer 
    okunmuştur. Aygıt sürücülerin read ve write fonksiyonlarında dosya göstericisinin ilerletilmesi programcının sorumluluğundadır.
    Bu nedenle okuma işlemi yapıldığında dosya göstericisinin konumu aşağıdaki gibi artırılmıştır:

    *off += esize;

    read fonksiyonunun okunabilen byte sayısına geri döndürüldüğüne dikkat ediniz. copy_to_user fonksiyonu ile tüm byte'lar
    kullanıcı alanına kopyalanamamışsa fonksiyon -EFAULT değeri ile geri döndürülmüştür.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define DEV_MAJOR        130
#define DEV_MINOR        0

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};
static char g_file_buf[] = "01234567890ABCDEFGH";

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize;
    size_t slen;

    slen = strlen(g_file_buf);
    esize = size > slen - *off ? slen - *off : size;

    if (copy_to_user(buf, g_file_buf + *off, esize) != 0)
        return -EFAULT;

    *off += esize;

    return esize;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "generic_write called...\n");

    return size;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[4096 + 1];
    ssize_t result;
    unsigned n;

    if ((fd = open("mydriver", O_RDONLY)) == -1)
    exit_sys("open");

    for (;;) {
        printf("number of bytes to read? ");
        scanf("%u", &n);

        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0)
            break;
        buf[result] = '\0';
        puts(buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücü için write fonksiyonu da tamamen read fonksiyonuna benzer biçimde yazılmaktadır. write fonksiyonu içerisinde
    biz kullanıcı modundaki bilgiyi copy_from_user ya da get_user fonksiyonlarıyla alırız. Yine write fonksiyonu da istenilen 
    kadar byte'ın transfer edilememesi durumunda -EFAULT değeri ile, başarılı sonlanmada ise yazılan (çekirdek alanına yazılan) 
    byte miktarı ile geri dönmelidir.

    Aşağıdaki örnekte aygıt sürücü bellekte oluşturulmuş bir dosya gibi davranmaktadır. Aygıt sürücünün taklit ettiği dosya
    en fazla 4096 byte olabilmektedir:

    #define FILE_BUF_SIZE        4096
    ...
    static char g_file_buf[FILE_BUF_SIZE];

    Ancak buradaki FILE_BUF_SIZE bellek dosyasının maksimum uzunluğunu belirtmektedir. Bellek dosyasının gerçek uzunluğu 
    g_fsize nesnesinde tutulmaktadır. Aygıt sürücünün write fonksiyonu aşağıdaki gibi yazılmıştır:

    static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        size_t esize;

        esize = size > FILE_BUF_SIZE - *off ? FILE_BUF_SIZE - *off : size;

        if (esize > 0) {
            if (copy_from_user(g_file_buf + *off, buf, esize) != 0)
                return -EFAULT;
            *off += esize;

            if (*off > g_fsize)
                g_fsize = *off;
        }

        return esize;
    }

    Burada yine dosya göstericisinin gösterdiği yerden itibaren yazılmak istenen byte sayısı FILE_BUF_SIZE değerini aşıyorsa 
    geri kalan miktar kadar yazma yapılmıştır. Dosya göstericisinin yine ilerletildiğine dikkat ediniz. Dosya göstericisinin 
    ilerletilmesi her zaman programcının sorumluluğundadır. Aygıt sürücümüzün read fonksiyonu da şöyledir:

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        size_t esize;

        esize = size > g_fsize - *off ? g_fsize - *off : size;

        if (esize > 0) {
            if (copy_to_user(buf, g_file_buf + *off, esize) != 0)
                return -EFAULT;
            *off += esize;
        }

        return esize;
    }

    Burada da dosya göstericisinin gösterdiği yerden itibaren okunmak istenen byte sayısının g_fsize değerinden büyük olup 
    olmadığına bakılmıştır. Yine dosya göstericisi fonksiyon tarafından güncellenmiştir.

    Programın testi için önce aygıt sürücüye aşağıdaki gibi birtakım byte'ları aktarabilirsiniz:

    $ echo -n "0123456789" | sudo tee mydriver

    Burada -n parametresi '\n' karakterinin dosyaya yazılmasını engellemektedir. Bundan sonra artık yukarıdaki "app.c" programı
    ile testi yapabilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define DEV_MAJOR        130
#define DEV_MINOR        0

#define FILE_BUF_SIZE        4096

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};
static char g_file_buf[FILE_BUF_SIZE];
static size_t g_fsize = 0;

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize;

    esize = size > g_fsize - *off ? g_fsize - *off : size;

    if (esize > 0) {
        if (copy_to_user(buf, g_file_buf + *off, esize) != 0)
            return -EFAULT;
        *off += esize;
    }

    return esize;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize;

    esize = size > FILE_BUF_SIZE - *off ? FILE_BUF_SIZE - *off : size;

    if (esize > 0) {
        if (copy_from_user(g_file_buf + *off, buf, esize) != 0)
            return -EFAULT;
        *off += esize;

        if (*off > g_fsize)
            g_fsize = *off;
    }

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[4096 + 1];
    ssize_t result;
    unsigned n;

    if ((fd = open("mydriver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("number of bytes to read? ");
        scanf("%u", &n);

        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0)
            break;
        buf[result] = '\0';
        puts(buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Kullanıcı modundan aygıt dosyası betimleyicisi ile lseek POSIX fonksiyonu çağrıldığında (bu fonksiyon da sys_lseek sistem 
    fonksiyonunu çağırmaktadır) karakter aygıt sürücüsünün file_operations yapısı içerisine yerleştirilen llseek fonksiyonu 
    çağrılmaktadır. llseek fonksiyonunun parametrik yapısı şöyledir:

    static loff_t generic_llseek(struct file *filp, loff_t off, int whence);

    Fonksiyonun birinci parametresi dosya nesnesini, ikinci parametresi konumlandırılmak istenen offset'i, üçüncü parametresi 
    ise konumlandırmanın nereye göre yapılacağını belirtmektedir. Bu fonksiyonu gerçekleştirirken programcı file yapısı 
    içerisindeki f_pos elemanını güncellemelidir. whence parametresi lseek fonksiyonundaki (ya da C'nin fseek fonksiyonundaki)
    orijini belirten parametreyle aynı anlamdadır. Tipik olarak programcı whence parametresini switch içerisine alır. Hedeflenen 
    offset'i hesaplar ve en sonunda file yapısının f_pos elemanına bu hedeflenen offset'i yerleştirir. Hedeflenen offset uygun 
    değilse fonksiyon tipik olarak -EINVAL değeriyle geri döndürülür. Eğer konumlandırma offset'i başarılı ise fonksiyon 
    dosya göstericisinin yeni değerine geri dönmelidir.

    Aşağıda daha önce yapmış olduğumuz bellek dosyası örneğine llseek fonksiyonu da eklenmiştir. Fonksiyon aşağıdaki gibi 
    yazılmıştır:

    static loff_t generic_llseek(struct file *filp, loff_t off, int whence)
    {
        loff_t newpos;

        switch (whence) {
            case 0:
                newpos = off;
                break;
            case 1:
                newpos = filp->f_pos + off;
                break;
            case 2:
                newpos = g_fmem_size + off;
                break;
            default:
                return -EINVAL;
        }

        if (newpos < 0 || newpos > g_fmem_size)
            return -EINVAL;

        filp->f_pos = newpos;

        return newpos;
    }

    Burada önce whence parametresine bakılarak dosya göstericisinin konumlandırılacağı offset belirlenmiştir. Sonra dosya 
    nesnesinin f_pos elemanı güncellenmiştir. Çekirdek kodlarında da kullanıcı modunda kullandığımız SEEK_SET (0), SEEK_CUR (1)
    ve SEEK_END (2) sembolik sabitleri tanımlanmış durumdadır.

    Aşağıdaki örnekte aygıt sürücüyü yükledikten sonra yine onun içerisinde oluşturduğumuz dosyaya komut satırından birşeyler
    yazabilirsiniz:

    $ echo -n "0123456789" | sudo tee mydriver

    Test programında lseek ile konumlandırma yapıp sonra okuma yaptık. Test kodunu değiştirerek lseek fonksiyonunun 
    çalışıp çalışmadığını kontrol edebilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define DEV_MAJOR                25
#define DEV_MINOR                0

#define FILE_MEMORY_MAX_SIZE    4096

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static loff_t generic_llseek(struct file *filp, loff_t off, int whence);

static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .llseek = generic_llseek,
    .release = generic_release
};
static char g_fmem[FILE_MEMORY_MAX_SIZE];
static size_t g_fmem_size;

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver module initialization...\n");

    if ((result = register_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, MKDEV(DEV_MAJOR, DEV_MINOR), 1)) < 0) {
        unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(MKDEV(DEV_MAJOR, DEV_MINOR), 1);

    printk(KERN_INFO "generic-char-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize;

    esize = *off + size > g_fmem_size ? g_fmem_size - *off : size;

    if (copy_to_user(buf, g_fmem + *off, esize) != 0)
        return -EFAULT;

    *off += esize;

    return esize;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize;

    esize = *off + size > FILE_MEMORY_MAX_SIZE ? FILE_MEMORY_MAX_SIZE - *off : size;

    if (copy_from_user(g_fmem + *off, buf, esize) != 0)
        return -EFAULT;

    *off += esize;

    if (*off > g_fmem_size)
        g_fmem_size = *off;

    return esize;
}

static loff_t generic_llseek(struct file *filp, loff_t off, int whence)
{
    loff_t newpos;

    switch (whence) {
        case 0:
            newpos = off;
            break;
        case 1:
            newpos = filp->f_pos + off;
            break;
        case 2:
            newpos = g_fmem_size + off;
            break;
        default:
            return -EINVAL;
    }

    if (newpos < 0 || newpos > g_fmem_size)
        return -EINVAL;

    filp->f_pos = newpos;

    return newpos;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    ssize_t result;
    char buf[4096 + 1];

    if ((fd = open("mydriver", O_RDWR)) == -1)
        exit_sys("open");

    if ((result = write(fd, "ankara", 6)) == -1)
        exit_sys("write");

    printf("%jd bytes written\n", (intmax_t)result);

    if ((result = write(fd, "izmir", 5)) == -1)
        exit_sys("write");

    printf("%jd bytes written\n", (intmax_t)result);

    if (lseek(fd, 0, 0) == -1)
        exit_sys("lseek");

    if ((result = read(fd, buf, 8)) == -1)
        exit_sys("read");
    buf[result] = '\0';

    printf("%s\n", buf);

    if (lseek(fd, -2, 1) == -1)
        exit_sys("lseek");

    if ((result = read(fd, buf, 8)) == -1)
        exit_sys("read");
    buf[result] = '\0';

    if (lseek(fd, -2, 2) == -1)
        exit_sys("lseek");

    if ((result = read(fd, buf, 8)) == -1)
        exit_sys("read");
    buf[result] = '\0';

    printf("%s\n", buf);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                135. Ders 21/04/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadarki örneklerimizde aygıt sürücümüzün majör ve minör numarasını baştan belirledik. Bunun en önemli sakıncası 
    belirlediğimiz majör numaralı bir aygıt sürücünün zaten yüklü olarak bulunuyor olmasıdır. Bu durumda aygıt sürücümüz yüklenemeyecektir. 
    Aslında daha doğru bir strateji tersten gitmektir. Yani önce aygıt sürücümüz içerisinde biz boş bir majör numara bulup onu 
    kullanabiliriz. Tabii sonra kullanıcı modundan bu aygıt numarasına ilişkin bir aygıt dosyasını da yaratmamız gerekir.

    Boş bir aygıt numarasını bize veren alloc_chrdev_region isimli bir çekirdek fonksiyonu vardır. Fonksiyonun parametrik yapısı 
    şöyledir:

    int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name);

    Fonksiyonun birinci parametresi aygıt numarasının yerleştirileceği dev_t nesnesinin adresini alır. İkinci ve üçüncü parametreler 
    başlangıç minör numarası ve onun sayısını belirtir. Son parametre ise aygıt sürücüsünün "/proc/devices" dosyasında ve "/sys/module" 
    dizininde görüntülenecek olan ismini belirtmektedir. alloc_chrdev_region fonksiyonu zaten register_chrdev_region fonksiyonunun 
    yaptığını da yapmaktadır. Dolayısıyla bu iki fonksiyondan yalnızca biri kullanılmalıdır. Fonksiyon başarı durumunda 0 değerine, 
    başarısızlık durumunda negatif errno değerine geri döner. Örneğin:

    dev_t g_dev;
    ...

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "generic-char-driver")) != 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    Aygıt sürücülerin majör numaraları birbirinden farklı olmak zorundadır. Biz kullanılan bir majör numaraya ilişkin kullanılmayan 
    bir numara eşliğinde aygıt sürücümüzü register ettiremeyiz.

    Aygıt sürücümüzde alloc_chrdev_region fonksiyonu ile boş bir majör numara numaranın bulunup aygıt sürücümüzün register 
    ettirildiğini düşünelim. Pekiyi biz bu numarayı nasıl bilip de komut satırından bu numaraya uygun aygıt dosyası yaratacağız? 
    İşte bunun için genellikle izlenen yöntem "/proc/devices" dosyasına bakıp oradan majör numarayı alıp aygıt dosyasını yaratmaktır. 
    Tabii bu manuel olarak yapılabilir ancak bir "shell script" ile otomatize de edilebilir. Aşağıdaki bu işlemi yapan "load" 
    isimli bir "shell script" verilmiştir:

    #!/bin/bash

    module=$1
    mode=666

    /sbin/insmod ./${module}.ko ${@:2} || exit 1
    major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
    rm -f $module
    mknod -m $mode $module c $major 0

    Artık biz bu "load" script'i ile aygıt sürücümüzü yükleyip aygıt dosyamızı yaratabileceğiz. Bu script'i "load" ismiyle yazıp 
    aşağıdaki gibi dosyaya "x" hakkı vermelisiniz:

    $ chmod +x load

    Çalıştırmayı komut satırı argümanı vererek aşağıdaki gibi yapmalısınız:

    $ sudo ./load generic-char-driver

    Burada "load" script'i çalıştırıldığında hem aygıt sürücü çekirdek alanına yüklenmekte hem de yüklenen aygıt sürücünün 
    majör numarasıyla (minör numarası da 0 olacak biçimde) "generic-char-driver" isimli aygıt dosyası yaratılmaktadır. Aygıt 
    sürücünün çekirdek alanından atılması manuel bir biçimde "rmmod" komutuyla yapılabilir. Tabii aynı zamanda bu aygıt sürücü 
    için yaratılan aygıt dosyasının da silinmesi uygun olabilir. Yukarıdaki script'te aygıt dosyası zaten varsa aynı zamanda o 
    dosya silinmektedir. Tabii aygıt dosyasını çekirdek alanından atarak silen ayrı bir "unload" isimli script'i de aşağıdaki 
    gibi yazabiliriz:

    #!/bin/bash

    module=$1

    /sbin/rmmod ./$module.ko || exit 1
    rm -f $module

    Tabii yine bu script dosyasının da "x" hakkına sahip olması gerekmektedir:

    $ chmod +x unload

    "unload" script'ini aşağıdaki gibi çalıştırabilirsiniz:

    $ sudo ./unload generic-char-driver

    Aşağıdaki örnekte alloc_chrdev_region fonksiyonuyla hem boş bir aygıt numarası elde edilip hem de bu aygıt numarası register 
    ettirilmiştir. Yükleme işlemi yukarıdaki "load" script'i ile yapılmalıdır. çekirdek modülünün boşaltılması işlemi manuel 
    olarak ya da "unload" script'i ile yapılabilir. Örneğin:

    $ sudo ./load generic-char-driver
    ...
    $ sudo ./unload generic-char-driver
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define FILE_BUF_SIZE        4096

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static loff_t generic_llseek(struct file *filp, loff_t off, int whence);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .llseek = generic_llseek,
    .release = generic_release
};

static char g_file_buf[FILE_BUF_SIZE];
static size_t g_fsize = 0;

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "generic-char-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");

        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize;

    esize = size > g_fsize - *off ? g_fsize - *off : size;

    if (esize > 0) {
        if (copy_to_user(buf, g_file_buf + *off, esize) != 0)
            return -EFAULT;
        *off += esize;
    }

    return esize;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize;

    esize = size > FILE_BUF_SIZE - *off ? FILE_BUF_SIZE - *off : size;

    if (esize  > 0) {
        if (copy_from_user(g_file_buf + *off, buf, esize) != 0)
            return -EFAULT;
        *off += esize;

        if (*off > g_fsize)
            g_fsize = *off;
    }

    return esize;
}

static loff_t generic_llseek(struct file *filp, loff_t off, int whence)
{
    loff_t newpos;

    switch (whence) {
    case 0:
        newpos = off;
        break;
    case 1:
        newpos = filp->f_pos + off;
        break;
    case 2:
        newpos = g_fsize + off;
        break;
    default:
        return -EINVAL;
    }
    if (newpos < 0 || newpos >= g_fsize)
        return -EINVAL;

    filp->f_pos = newpos;

    return newpos;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[4096 + 1];
    ssize_t result;
    unsigned n;

    if ((fd = open("generic-char-driver", O_RDONLY)) == -1)
        exit_sys("open");

    if (lseek(fd, 5, 0) == -1)
        exit_sys("lseek");

    for (;;) {
        printf("number of bytes to read? ");
        scanf("%u", &n);

        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0)
            break;
        buf[result] = '\0';
        puts(buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                136. Ders 26/04/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
     Bizim boru örneğimizde bir proses boruyu yazma modunda açtığında prosesin write fonksiyonuyla yazdıkları aygıt sürücü 
    içerisindeki bir FIFO kuyruk sistemine yazılmaktadır. Diğer proses de read fonksiyonuyla okuma yaptığında aslında bu bu 
    FIFO kuyruk sisteminden okuma yapılmaktadır. Burada yapacağımız gerçekleştirim UNIX/Linux sistemlerindeki "isimli borulara 
    (named pipes)" benzemektedir. Biz bu örneği çeşitli konuları gördükçe geliştireceğiz. Anımsayacağınız gibi UNIX/linux 
    sistemlerindeki boruları kullanırken eğer boru tamamen boşsa karşı taraf boruya en az 1 byte yazana kadar bloke oluşmaktadır. 
    Boru tamamen doluysa yazma sırasında karşı taraf okuma yapıp boruda yazılacak miktar kadar alan açana kadar bloke oluşmaktadır. 
    Ayrıca isimli borularda boruyu bir taraf okuma modunda açmaya çalıştığında diğer taraf boruyu yazma modunda açana kadar, 
    yazma modunda açmaya çalıştığında diğer taraf boruyu okuma modunda açana kadar da bloke oluşmaktadır. Biz bu gerçekleştirimde 
    henüz bloke oluşturmayı görmediğimizden dolayı bu özellikleri sağlamayacağız.

    Boruya ilişkin bir FIFO kuysuk sistemini oluşturabilmek için aşağıdaki nesnelerin tanımlanması gerekmektedir:

    #define PIPE_BUFFER_SIZE        8192

    static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
    static size_t g_head;
    static size_t g_tail;
    static size_t g_count;

    Burada g_pipebuf FIFO kuyruk sistemi için kullanılacak olan tamponu belirtmektedir. Bu tamponun PIPE_BUFFER_SIZE kadar 
    olduğuna dikkat ediniz. g_head kuyruğun başını, g_tail ise sonunu göstermektedir. Kuyruğa yazan taraf g_tail indeksinden 
    itibaren yazmayı yapar, kuyruktan okuma yapan taraf ise g_head indeksinden itibaren okuma yapar. Tabii bu indeksler dizinin
    sonuna geldiğinde yeniden başa geçirilmelidir. g_count ise kuyrukta kaç byte'ın bulunduğunu belirtmektedir. Başlangıçta 
    g_head, g_tail ve g_count 0 değerindedir. Yani kuyruk boştur.

    Aygıt sürücünün write fonksiyonu şöyle yazılmıştır:

    static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        size_t esize, size1, size2;

        if (g_count == PIPE_BUFFER_SIZE)
            return 0;

        esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
        if (g_tail >= g_head)
            size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
        else
            size1 = esize;
        size2 = esize - size1;

        if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
            return -EFAULT;
        if (size2 != 0)
            if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
                return -EFAULT;

        g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
        g_count += esize;

        return esize;
    }

    Burada kullanıcı modundaki proses write işlemi yaptığında bizim yazılmak istenen byte'ları copy_from_user fonksiyonu ile 
    alarak g_pipebuf içerisine g_tail indeksinden itibaren yazmamız gerekir. Ancak burada iki durum söz konusudur. Eğer g_tail 
    indeksi g_head indeksinden büyük ya da ona eşitse iki parçalı bir yazım gerekebilir. Ancak eğer g_tail indeksi g_head 
    indeksinden küçükse yazım tek seferde yapılabilir. Biz kodumuzda önce boru tamponunun dolu olup olmadığına baktık:

    if (g_count == PIPE_BUFFER_SIZE)
        return 0;

    Boru tamponu tamamen dolu ise fonksiyonu 0 ile geri döndürdük. Kullanıcı modunda write fonksiyonun geri dönüş değerini 0 
    olarak gören programcı borunun dolu olduğunu anlayacaktır. Biz kodumuzda, yazma işlemi sanki iki parça halinde yapılacakmış 
    gibi bu iki parçanın uzunluklarını elde ettik:

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;
    size2 = esize - size1;

    Tabii eğer g_tail indeksi g_head indeksinin gerisindeyse burada size2 zaten 0 olacaktır. Ayrıca g_tail indeksi g_head indeksinin
    ilerisinde olduğu halde yazılacak miktar PIPE_BUFFER_SIZE - g_tail miktarından küçük ya da ona eşit ise yine size2 0 olacaktır.
    Kopyalama şöyle yapılmıştır:

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        return -EFAULT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            return -EFAULT;

    Tabii bu işlemlerden sonra g_tail artık yeni pozisyonuna çekilmeli ve g_count da yazılan miktar kadar artırılmalıdır:

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;

    write fonksiyonunun başarılı biçimde yazılan byte sayısıyla geri döndüğünü anımsayınız. İsimli borularda aslında yazılmak 
    istenen miktar kadar boruda boş yer yoksa ve blokeli mod söz konusuysa bloke oluştuğunu ancak blokesiz mod söz konusuysa write 
    fonksiyonunun başarısız olduğunu ve errno değerinin EAGAIN ile set edildiğini anımsayınız. Bizim buradaki tasarımımız blokesiz 
    mod gibi de değildir. Biz burada eğer boruda yazmak istenilen miktar kadar yer yoksa yazılabilecek kadar bilgiyi boruya yazmayı 
    tercih ettik.

    Aygıt sürücümüzün read fonksiyonu da benzer biçimde yazılabilir:

    static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        size_t esize, size1, size2;

        if (g_count == PIPE_BUFFER_SIZE)
            return 0;

        esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
        if (g_tail >= g_head)
            size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
        else
            size1 = esize;
        size2 = esize - size1;

        if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
            return -EFAULT;
        if (size2 != 0)
            if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
                return -EFAULT;

        g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
        g_count += esize;

        return esize;
    }

    Buradaki aygıt sürücümüzde şu kusurlar vardır:

    - Aygıt sürücümüzde read/write fonksiyonlarında hiçbir senkronizasyon uygulamadık. Dolayısıyla eş zamanlı işlemlerde boru 
    mekanizması birbirine girebilir. Örneğin iki farklı proses bu boruya aynı anda yazma yaparsa senkronizasyondan kaynaklanan 
    sorunlar oluşabilir.

    - Bu gerçekleştirimimizde ayrıca iki proses de boruyu kapatsa bile borunun içerisindekiler silinmemektedir. Halbuki 
    orijinal isimli borularda prosesler boruyu kapatınca boru içerisindeki tüm bilgiler silinmektedir.

    - Bu gerçekleştirimimizde sistem genelinde tek bir boru yaratılmaktadır. Yani bizim boru aygıt sürücümüz tek bir boru 
    üzerinde işlemler yapmaktadır. Halbuki orijinal isimli borularda programcılar birbirinden bağımsız istedikleri kadar 
    çok isimli boru yaratabilmektedir.

    Aygıt sürücümüzü önce build edip sonra aşağıdaki gibi yüklemelisiniz:

    $ make file=pipe-driver
    $ sudo ./load pipe-driver

    Buradaki boru aygıt sürücüsünü test etmek için "pwriter" ve "preader" isimli iki program yazılmıştır. "pwriter" programı 
    klavyeden (stdin dosyasından) alınan yazıları boruya yazmakta, "preader" ise klavyeden (stdin dosyasından) alınan uzunlukta 
    byte'ı borudan okumaktadır. Test işlemini yaparken boru uzunluğunu azaltabilirsiniz. Biz örneğimizde boru uzunluğunu 
    8192 aldık.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#define PIPE_BUFFER_SIZE        8192
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;

    if (g_count == 0)
        return 0;

    esize = MIN(size, g_count);

    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        return -EFAULT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            return -EFAULT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    return esize;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;

    if (g_count == PIPE_BUFFER_SIZE)
        return 0;

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        return -EFAULT;

    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            return -EFAULT;

    g_tail = (g_tail + esize) % PIPE_BUFFER_SIZE;
    g_count += esize;

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        if (result > 0)
            printf("%jd bytes written...\n", (intmax_t)result);
        else
            printf("pipe full, try again...\n");
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0) {
            printf("pipe is empty, try again..\n");
            continue;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                137. Ders 28/04/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücülerdeki kodlar kullanıcı modundan farklı prosesler tarafından kullanılıyor olabilir. Ayrıca ileride göreceğimiz 
    gibi aygıt sürücüler donanım kesmelerini de kullanıyor olabilir. Dolayısıyla aygıt sürücü kodları eş zamanlı (concurrent) 
    erişime uygun biçimde yazılmalıdır. Kullanıcı modundaki bir proses aygıt sürücü içerisindeki bir kaynağı kullanıyorken 
    kullanıcı modundaki diğer prosesin o kaynağın bozulmaması için diğerini beklemesi gerekebilmektedir.

    Çekirdek modunda aygıt sürücü kodları daha önce kullanıcı modunda gördüğümüz senkronizasyon nesnelerini kullanamaz. Çünkü 
    daha önce gördüğümüz senkronizasyon nesneleri user mode'dan kullanılsın diye oluşturulmuştur. Çekirdeğin içerisinde çekirdek
    modundan kullanılabilecek ayrı senkronizasyon nesneleri bulunmaktadır. Bu bölümde aygıt sürücülerin çekirdek modunda 
    kullanabileceği senkronizasyon nesnelerini göreceğiz.

    Çekirdek modu için user mode'dakine benzer senkronizasyon nesneleri kullanılmaktadır. Bunların genel çalışma biçimi kullanıcı
    modundakilere benzemektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Mutex nesneleri Linux çekirdeğine 2.6 versiyonu ile eklenmiştir. Bundan önce mutex işlemleri binary semaphore'larla yapılıyordu. 
    Çekirdeğin mutex mekanizması kullanıcı modundaki mutex mekanizmasına çok benzemektedir. Çekirdek mutex nesnelerinin yine 
    thread temelinde sahipliği vardır. Çekirdek mutex nesneleri thread'i bloke edip onu bekleme kuyruklarında bekletebilmektedir.

    Mutex mekanizması şöyle işletilmektedir: Önce bir mutex nesnesi yaratılır. Kritik koda girişte bu mutex nesnesinin sahipliği
    ele geçirilmeye çalışılır. Mutex'in sahipliğinin ele geçirilmesine "mutex'in kilitlenmesi (mutex lock)" de denilmektedir. Eğer 
    mutex'in sahipliği ele geçirilirse (yani mutex kilitlenirse) sahiplik bırakılana kadar (yani kilit bırakılana kadar) başka bir 
    thread kritik koda giremez. Mutex'in sahipliğini almaya çalışan thread mutex kilitli ise bloke olarak mutex kilidi açılana kadar 
    bekler. Mutex'in sahipliğini almış olan thread kritik koddan çıkarken mutex'in sahipliğini bırakır (yani mutex'in kilidini açar). 
    Böylece blokede bekleyen thread'lerden biri mutex'in sahipliğini alarak kritik koda girer. Kritik kod tipik olarak şöyle 
    oluşturulmaktadır:

     mutex_lock(...)
    ...
    ...    KRİTİK KOD
    ...
    mutex_unlock(...)

    Thread'lerden biri mutex_lock fonksiyonuna geldiğinde eğer mutex kilitlenmemişse mutex'i kilitler ve kritik koda giriş yapar. 
    Eğer mutex zaten kilitlenmişse mutex_lock fonksiyonunda thread bloke edilir ve bekleme kuyruğuna alınır. Kritik koda girmiş
    olan thread mutex_unlock fonksiyonu ile mutex nesnesinin kilidini bırakır. Böylece nesneyi bekleyen thread'lerden biri 
    nesnenin sahipliğini alarak mutex'i kilitler. Birden fazla thread'in mutex_lock fonksiyonunda bloke edilmesi durumunda mutex'in 
    kilidi açıldığında bunlardan hangisinin mutex kilidini alarak kritik koda gireceği konusunda bir garanti verilmemektedir. 
    (İlk bloke olan thread'in mutex kilidini alarak kritik koda gireceğini düşünebilirsiniz, ancak bunun bir garantisi yoktur.)

    Çekirdekteki mutex mekanizmasının tipik gerçekleştirimi şöyledir:

    1) mutex_lock işlemi sırasında işlemcinin maliyetsiz compare/set (compare/exchange) komutlarıyla mutex'in kilitli olup 
    olmadığına bakılır.
    2) Diğer bir işlemcideki thread mutex'i kilitlemişse boşuna bloke olmamak için yine compare/set komutlarıyla biraz spin 
    işlemi yapılır.
    3) Spin işleminden sonuç elde edilemezse bloke oluşturulur.

    Çekirdeğin mutex nesneleri tipik olarak şöyle kullanılmaktadır:

    1) Mutex nesnesi mutex isimli bir yapıyla temsil edilmektedir. Sistem programcısı bu yapı türünden global bir nesne yaratır 
    ve ona ilk değerini verir. DEFINE_MUTEX(name) makrosu hem struct mutex türünden nesneyi tanımlamakta hem de ona ilk değerini 
    vermektedir. Örneğin:

    #include <linux/mutex.h>

    static DEFINE_MUTEX(g_mutex);

    Burada biz hem g_mutex isminde bir global nesne tanımlamış olduk hem de ona ilk değer vermiş olduk. Aynı işlem önce nesneyi 
    tanımlayıp sonra mutex_init fonksiyonunun çağrılmasıyla da yapılabilmektedir. Örneğin:

    static struct mutex g_mutex;
    ...
    mutex_init(&g_mutex);

    DEFINE_MUTEX makrosuna nesnenin adresinin verilmediğine dikkat ediniz. Bu makro ve mutex_init fonksiyonunun prototipleri
    <linux/mutex.h> başlık dosyasında bulunmaktadır.

    Her ne kadar mutex_init bir fonksiyon görünümündeyse de aslında çekirdek kodlarında hem bir makro olarak hem de bir fonksiyon 
    olarak bulunmaktadır. Mevcut Linux çekirdeklerinde fonksiyonların makro gerçekleştirimleri aşağıdaki gibidir:

    #define DEFINE_MUTEX(mutexname)                            \
        struct mutex mutexname = __MUTEX_INITIALIZER(mutexname)

    #define mutex_init(mutex)                \
    do {                            \
        static struct lock_class_key __key;        \
                                \
        __mutex_init((mutex), #mutex, &__key);        \
    } while (0)

    2) Mutex nesnesini kilitlemek için mutex_lock fonksiyonu kullanılır:

    #include <linux/mutex.h>

    void mutex_lock(struct mutex *lock);

    Mutex'in kilitli olup olmadığı ise mutex_trylock fonksiyonuyla kontrol edilebilir:

    #include <linux/mutex.h>

    int mutex_trylock(struct mutex *lock);

    Eğer mutex kilitliyse fonksiyon bloke olmadan 0 değeriyle geri döner. Eğer mutex kilitli değilse mutex kilitlenir ve fonksiyon
    1 değeri ile geri döner.

    Mutex nesnesi mutex_lock ile kilitlenmek istendiğinde bloke oluşursa bu blokeden sinyal yoluyla çıkılamamaktadır. Örneğin 
    mutex_lock ile çekirdek modunda biz mutex kilidini alamadığımızdan dolayı bloke oluştuğunu düşünelim. Bu durumda ilgili prosese 
    bir sinyal gelirse ve eğer o sinyal için sinyal fonksiyonu set edilmişse thread uyandırılıp sinyal fonksiyonu çalıştırılmamaktadır. 
    Ayrıca bu durumda biz ilgili prosese SIGINT gibi, SIGKILL gibi sinyaller göndererek de prosesi sonlandıramayız. İşte eğer mutex'in 
    kilitli olması nedeniyle bloke oluştuğunda sinyal yoluyla thread'in uyandırılıp sinyal fonksiyonunun çalıştırması ya da sinyal 
    fonksiyonu set edilmemişse prosesin sonlandırılması isteniyorsa mutex nesnesi mutex_lock ile değil, mutex_lock_interrupible 
    fonksiyonu ile kilitlenmeye çalışılmalıdır. mutex_lock_interruptible fonksiyonunun prototipi şöyledir:

    #include <linux/mutex.h>

    int mutex_lock_interruptible(struct mutex *lock);

    Fonksiyon eğer mutex kilidini alarak sonlanırsa 0 değerine, bloke olup sinyal dolayısıyla sonlanırsa -EINTR değerine geri 
    dönmektedir. Programcı bu fonksiyonun 0 ile geri dönmediğini ya da -EINTR ile geri döndüğünü tespit ettiğinde ilgili sistem 
    fonksiyonunun yeniden çalıştırılabilirliğini sağlamak için -ERESTARTSYS ile geri dönebilir. Örneğin:

    if (mutex_lock_interruptible(&g_mutex) != 0)
        return -ERESTARTSYS;

    3) Mutex nesnesinin kilidini bırakmak için (nesneyi unlock etmek için) mutex_unlock fonksiyonu kullanılmaktadır:

    void mutex_unlock(struct mutex *lock);

    Bu durumda örneğin tipik olarak aygıt sürücü içerisinde belli bir bölgeyi mutex yoluyla koruma şöyle yapılmaktadır:

    DEFINE_MUTEX(g_mutex);
    ...

    if (mutex_lock_interruptible(&g_mutex) != 0)
        return -ERESTARTSYS;

    ...
    ... <KRİTİK KOD>
    ...

    mutex_unlock(&g_mutex);

    Mutex nesnesini kilitledikten sonra fonksiyonlarınızı geri döndürürken kilidi açmayı unutmayınız.

    Aşağıdaki örnekte yukarıdaki boru aygıt sürücüsü daha güvenli olacak biçimde mutex nesneleriyle senkronize edilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/mutex.h>

#define PIPE_BUFFER_SIZE        8192
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;

static DEFINE_MUTEX(g_mutex);

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (mutex_lock_interruptible(&g_mutex) != 0)
        return -ERESTARTSYS;

    if (g_count == 0) {
        result = 0;
        goto EXIT;
    }

    esize = MIN(size, g_count);
    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            goto EXIT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    result = esize;
EXIT:
    mutex_unlock(&g_mutex);

    return result;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (mutex_lock_interruptible(&g_mutex) != 0)
        return -ERESTARTSYS;

    if (g_count == PIPE_BUFFER_SIZE) {
        result = 0;
        goto EXIT;
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            goto EXIT;

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;

    result = esize;

EXIT:
    mutex_unlock(&g_mutex);

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        if (result > 0)
            printf("%jd bytes written...\n", (intmax_t)result);
        else
            printf("pipe full, try again...\n");
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0) {
            printf("pipe is empty, try again..\n");
            continue;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                138. Ders 03/05/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdekte de kullanıcı modundakine benzer semaphore nesneleri vardır. Kernel semaphore nesneleri de sayaçlıdır. Yine 
    bunların sayaçları 0'dan büyükse semaphore açık durumdadır, sayaçlar 0 değerinde ise semaphore kapalı durumdadır. Kritik 
    koda girildiğinde yine sayaç 1 eksiltilir. Sayaç 0 olduğunda thread bloke edilir. Yine bloke işleminde biraz spin işlemi 
    yapılıp sonra bloke uygulanmaktadır. Çekirdek semaphore nesneleri şöyle kullanılmaktadır:

     1) Semaphore nesnesi struct semaphore isimli bir yapıyla temsil edilmiştir. Bir semaphore nesnesi DEFINE_SEMAPHORE(name) 
    makrosuyla aşağıdaki gibi oluşturulabilir.

    #include <linux/semaphore.h>

    static DEFINE_SEMAPHORE(g_sem);

    Bu biçimde yaratılan semaphore nesnesinin başlangıçta sayaç değeri 1'dir. Yeni çekirdeklerde (v6.4-rc1 ve sonrası) bu makro 
    iki parametreli olarak da kullanılabilmektedir:

    static DEFINE_SEMAPHORE(g_sem);

    Buradaki ikinci parametre semaphore sayacının başlangıçtaki değerini belirtmektedir.

    Semaphore nesneleri sema_init fonksiyonuyla da yaratılabilmektedir:

    static struct semaphore g_sem;
    ...
    sema_init(&g_sem, 1);

    Fonksiyonun ikinci parametresi başlangıç sayaç numarasıdır.

    2) Kritik kod "down" ve "up" fonksiyonları arasına alınır. "down" fonksiyonları sayacı bir eksilterek kritik koda giriş yapar. 
    "up" fonksiyonu ise sayacı bir artırmaktadır. Fonksiyonların prototipleri şöyledir:

    #define <linux/semaphore.h>

    void down(struct semaphore *sem);
    int down_interruptible(struct semaphore *sem);
    int down_killable(struct semaphore *sem);
    int down_trylock(struct semaphore *sem);
    int down_timeout(struct semaphore *sem, long jiffies);
    void up(struct semaphore *sem);

    Kritik kod "down" fonksiyonu ile oluşturulduğunda thread bloke olursa sinyal yoluyla uyandırılamamaktadır. Ancak kritik kod 
    "down_interruptible" fonksiyonu ile oluşturulduğunda thread bloke olursa sinyal yoluyla uyandırılabilmektedir. down_killable
    bloke olmuş thread'in yalnızca SIGKILL sinyalini kabul edip sonlandırılabilmesini sağlamaktadır. down_killable fonksiyonunda 
    eğer thread bloke olursa diğer sinyaller yine blokeyi sonlandıramamaktadır. down_trylock yine nesnenin açık olup olmadığına 
    bakmak için kullanılır. Eğer nesne açıksa yine sayaç 1 eksiltilir ve kritik koda girilir. Bu durumda fonksiyon 0 dışı bir 
    değerle geri döner. Nesne kapalıysa (yani semaphore sayacı 0 ise) fonksiyon bloke olmadan 0 değerine geri döner. down_timeout 
    ise en kötü olasılıkla belli miktar "jiffy" zamanı kadar blokeye yol açmaktadır. ("jiffy" kavramı ileride ele alınacaktır.) 
    Fonksiyon zaman aşımı dolduğundan dolayı sonlanmışsa negatif hata koduna, normal bir biçimde sonlanmışsa 0 değerine geri 
    dönmektedir. down_interruptible fonksiyonu normal sonlanmada 0 değerine, sinyal yoluyla sonlanmada -ERESTARTSYS değeri ile 
    geri döner. Normal uygulama eğer bu fonksiyonlar -ERESTARTSYS ile geri dönerse aygıt sürücüdeki fonksiyonun da aynı değerle 
    geri döndürülmesidir. Zaten çekirdek bu -ERESTARTSYS geri dönüş değerini aldığında asıl sistem fonksiyonunu eğer sinyal için 
    otomatik restart mekanizması aktif değilse -EINTR değeri ile geri döndürmektedir. Bu da tabii POSIX fonksiyonlarının başarısız 
    olup errno değerini EINTR biçiminde set edilmesine yol açmaktadır. "up" fonksiyonu yukarıda da belirttiğimiz gibi semaphore 
    sayacını 1 artırmaktadır.

    Kernel semaphore nesneleriyle kritik kod aşağıdaki gibi oluşturulmaktadır:

    DEFINE_SEMAPHORE(g_sem);
    ...

    down_interruptible(&g_sem);
    ...
    ... <KRİTİK KOD>
    ...
    up(&g_sem);

    Yukarıdaki boru örneğinde biz mutex nesnesi yerine binary semaphore nesnesi de kullanabilirdik. Aşağıda aynı örneğin 
    binary semaphore ile gerçekleştirimi görülmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>

#define PIPE_BUFFER_SIZE        8192
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;

static DEFINE_SEMAPHORE(g_sem);

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (g_count == 0) {
        result = 0;
        goto EXIT;
    }

    esize = MIN(size, g_count);
    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            goto EXIT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    result = esize;
EXIT:
    up(&g_sem);

    return result;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (g_count == PIPE_BUFFER_SIZE) {
        result = 0;
        goto EXIT;
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            goto EXIT;

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;

    result = esize;

EXIT:
    up(&g_sem);

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        if (result > 0)
            printf("%jd bytes written...\n", (intmax_t)result);
        else
            printf("pipe full, try again...\n");
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0) {
            printf("pipe is empty, try again..\n");
            continue;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Kullanıcı modunda gördüğümüz diğer senkronizasyon nesnelerinin benzerleri de çekirdek içerisinde bulunmaktadır. Örneğin 
    spinlock kullanımına çekirdek kodlarında ve aygıt sürücülerde sıkça rastlanmaktadır. Anımsanacağı gibi spinlock uykuya 
    dalarak değil, (yani bloke olarak değil) meşgul bir döngü içerisinde kilidin açılmasını bekleyen senkronizasyon nesnelerini 
    belirtiyordu. Spinlock kullanımının çok işlemcili ya da çekirdekli sistemlerde anlamlı olduğunu da belirtmiştik. Spinlock nesneleri 
    küçük kod blokları için ve özellikle çok işlemcili ya da çok çekirdekli sistemlerde kullanılması gereken senkronizasyon nesneleridir. 
    Spinlock nesnesinin kilidini alan thread'in bloke olmaması gerekir. Aksi takdirde istenmeyen sonuçlar oluşabilir. Özetle spinlock 
    nesnesinin kilidini alan thread şu durumlara dikkat etmelidir:

    - Spinlock ile kritik koda giren thread spinlock kilidini uzun süre kapalı tutmamalıdır. Yani spinlock kısa kodlar için 
    uygulanmalıdır.
    - Spinlock ile kritik koda giren thread bloke olmamalıdır.
    - Spinlock ile kritik koda giren thread CPU'yu IRQ'lara açma konusunda dikkatli olmalıdır.

    Linux'ta bir thread spinlock kilidini almışsa artık quanta süresi dolsa bile thread'ler arası geçiş kapatılmaktadır.

    Çekirdekteki spinlock nesneleri tipik olarak şöyle kullanılmaktadır:

    1) Spinlock nesnesi spinlock_t türü ile temsil edilmektedir. Spinlock nesnesini aşağıdaki gibi tanımlayabilirsiniz:

    static spinlock_t g_spinlock;

    Linux'un 2.6.9 çekirdeği ile birlikte spinlock nesnesini tanımlayıp ona ilkdeğer vermek için DEFINE_SPINLOCK makrosu da 
    çekirdeğe eklenmiştir. Bu makro kullanılarak spinlock nesnesi açık bir biçimde şöyle oluşturulabilir:

    #include <linux/spinlock.h>

    static DEFINE_SPINLOCK(g_spinlock);

    spinlock_t nesnesine ilkdeğer verme işlemi spin_lock_init fonksiyonuyla da yapılabilmektedir. spin_lock_init fonksiyonu 
    spinlock_t nesnesine açık olacak biçimde (unlocked) ilkdeğerlerini vermektedir:

    #include <linux/spinlock.h>

    void spin_lock_init(spinlock_t *lock);

    Örneğin:

    spinlock_init(&g_spinlock);

    2) Kritik koda giriş için aşağıdaki fonksiyonlar kullanılmaktadır:

    #include <linux/spinlock.h>

    void spin_lock(spinlock_t *lock);
    void spin_lock_irq(spinlock_t *lock);
    void spin_lock_irqsave(spinlock_t *lock, unsigned long flags);
    void spin_lock_bh(spinlock_t *lock);

    "spin_lock" fonksiyonu klasik spin yapan fonksiyondur. "spin_lock_irq" fonksiyonu o anda çalışılan işlemci ya da çekirdekteki 
    IRQ'ları (yani donanım kesmelerini) kapatarak kilidi almaktadır. Yani biz bu fonksiyonla kilidi almışsak kilidi bırakana 
    kadar donanım kesmeleri oluşmayacaktır. "spin_lock_irqsave" fonksiyonu kritik koda girerken donanım kesmelerini kapatmakla 
    birlikte önceki bir durumu geri yükleme yeteneğine sahiptir. Aslında bu fonksiyonların bazıları makro olarak yazılmıştır. 
    Örneğin spin_lock_irqsave aslında bir makrodur. Biz bu fonksiyonun ikinci parametresine nesne adresini geçmemiş olsak da 
    bu bir makro olduğu için aslında ikinci parametrede verdiğimiz nesnenin içerisine IRQ durumları yazılmaktadır. spin_lock_bh
    fonksiyonu yalnızca yazılım kesmelerini kapatmaktadır.

    3) Kilidin geri bırakılması için spin_unlock fonksiyonları kullanılmaktadır:

    #include <linux/spinlock.h>

    void spin_unlock(spinlock_t *lock);
    void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags);
    void spin_unlock_irq(spinlock_t *lock);
    void spin_unlock_bh(spinlock_t *lock);

    Yukarıdaki lock fonksiyonlarının hepsinin bir unlock karşılığının olduğunu görüyorsunuz. Biz kilidi hangi lock fonksiyonu 
    ile almışsa o unlock fonksiyonu ile bırakmalıyız. Örneğin:

    spin_lock(&g_spinlock);
    ...
    ... <KRİTİK KOD>
    ...
    spin_unlock(&g_spinlock);

    Ya da örneğin:

    ...
    unsigned long irqstate;
    ...

    spin_lock_irqsave(&g_spinlock, irqstate);
    ...
    ... <KRİTİK KOD>
    ...
    spin_unlock_irqrestore(&g_spinlock, irqstate);

    Yine kernel spinlock nesnelerinde de try'lı lock fonksiyonları bulunmaktadır:

    #include <linux/spinlock.h>

    int spin_trylock(spinlock_t *lock);
    int spin_trylock_bh(spinlock_t *lock);

    Bu fonksiyonlar eğer spinlock kilitliyse spin yapmazlar ve 0 ile geri dönerler. Eğer kilidi alırlarsa sıfır dışı bir 
    değerle geri dönerler.

    Her ne kadar yukarıdaki boru sürücüsündeki read ve write fonksiyonlarında kuyruğu korumak için spinlock kullanımı uygun 
    değilse de biz yine kullanım biçimini göstermek için aşağıdaki örneği veriyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/spinlock.h>

#define PIPE_BUFFER_SIZE        8192
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;

static DEFINE_SPINLOCK(g_spinlock);

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "generic-char-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "generic-char-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "generic-char-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    spin_lock(&g_spinlock);

    if (g_count == 0) {
        result = 0;
        goto EXIT;
    }

    esize = MIN(size, g_count);
    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            goto EXIT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    result = esize;
EXIT:
    spin_unlock(&g_spinlock);

    return result;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    spin_lock(&g_spinlock);

    if (g_count == PIPE_BUFFER_SIZE) {
        result = 0;
        goto EXIT;
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);
    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            goto EXIT;

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;

    result = esize;

EXIT:
    spin_unlock(&g_spinlock);

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        if (result > 0)
            printf("%jd bytes written...\n", (intmax_t)result);
        else
            printf("pipe full, try again...\n");
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0) {
            printf("pipe is empty, try again..\n");
            continue;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz daha önce user mode'da reader/writer lock nesnelerini görmüştük. Bu nesneler birden fazla thread'in kritik koda okuma
    amaçlı girmesine izin veriyordu. Ancak bir thread kritik koda yazma amaçlı girmişse diğer bir thread'in okuma ya da 
    yazma amaçlı kritik koda girmesine izin vermiyordu. İşte user mode'daki reader/write lock nesnelerinin bir benzeri kernel 
    mode'da reader/writer spinlock nesneleri biçiminde bulunmaktadır. Yine kernel mode'da da kritik koda okuma amaçlı ya da 
    yazma amaçlı giren fonksiyonlar vardır.

    reader/writer spinlock nesneleri rwlock_t türüyle temsil edilmektedir. Bunların yaratılması rwlock_init fonksiyonuyla 
    yapılmaktadır:

    #include <linux/rwlock.h>

    void rwlock_init(rwlock_t *lock);

    reader/writer spinlock nesneleri ile ilgili diğer çekirdek fonksiyonları şunlardır:

    #include <linux/rwlock.h>

    void read_lock(rwlock_t *lock);
    void read_lock_irqsave(rwlock_t *lock, unsigned long flags);
    void read_lock_irq(rwlock_t *lock);
    void read_lock_bh(rwlock_t *lock);

    void read_unlock(rwlock_t *lock);
    void read_unlock_irqrestore(rwlock_t *lock, unsigned long flags);
    void read_unlock_irq(rwlock_t *lock);
    void read_unlock_bh(rwlock_t *lock);

    void write_lock(rwlock_t *lock);
    void write_lock_irqsave(rwlock_t *lock, unsigned long flags);
    void write_lock_irq(rwlock_t *lock);
    void write_lock_bh(rwlock_t *lock);
    int write_trylock(rwlock_t *lock);

    void write_unlock(rwlock_t *lock);
    void write_unlock_irqrestore(rwlock_t *lock, unsigned long flags);
    void write_unlock_irq(rwlock_t *lock);
    void write_unlock_bh(rwlock_t *lock);

    Nesne read amaçlı lock edilmişse read amaçlı unlock işlemi, write amaçlı lock edilmişse write amaçlı unlock işlemi 
    uygulanmalıdır. Fonksiyonların diğer işlevleri normal spinlock nesnelerinde olduğu gibidir.

    Örneğin biz bu fonksiyonlarla okuma yazma işlemlerini aşağıdaki gibi senkronize edebiliriz:

    static DEFINE_RWLOCK(g_rwlock);

    read()
    {
        read_lock(&g_rwlock);
        <okuma işlemi yapılıyor>
        read_unlock(&g_rwlock);
    }

    write()
    {
        write_lock(&g_rwlock);
        <yazma işlemi yapılıyor>
        write_unlock(&g_rwlock);
    }

    Burada artık okuma yapmak isteyen thread read fonksiyonunu çağırdığında read_lock fonksiyonu ile spinlock kilidi alınır, 
    başka bir thread bu kilidi write_lock ile alamaz ve spin yapmaya başlar. Ancak başka bir thread kilidi yine read_lock 
    ile alabilir. Eğer bir thread kilidi write_lock ile almışsa başka bir thread kilidi read_lock ile de write_lock ile de 
    alamaz ve spin yaparak bekler.

    read_lock ve write_lock fonksiyonlarının irq sonekli versiyonları yine akış kritik kodda girdiğinde ilgili CPU ya da 
    çekirdeğin yerel kesmelerini kapatmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kullanıcı modundaki senkronizasyon nesnelerinin benzerlerinin çekirdek içerisinde de bulunduğunu görüyorsunuz. Ancak 
    kullanıcı modundaki her senkronizasyon nesnesinin bir çekirdek mod karşılığı yoktur. Örneğin kullanıcı modundaki "koşul 
    değişkenlerinin (condition variables)" bir çekirdek mod karşılığı bulunmamaktadır. Ayrıca burada ele almadığımız (belki 
    ileride ele alacağımız) yalnızca çekirdek içerisinde kullanılan birkaç senkronizasyon nesnesi daha bulunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Tıpkı kullanıcı modunda olduğu gibi aygıt sürücülerde de basit atama, artırma, eksiltme gibi işlemlerin atomic yapılmasını 
    sağlayan özel inline fonksiyonlar vardır. Aslında bu işlemler thread'ler konusunda görmüş olduğumuz gcc'nin built-in atomic 
    fonksiyonlarıyla yapılabilir. Ancak çekirdek içerisindeki fonksiyonların kullanılması uyum bakımından daha uygundur. Bu 
    inline fonksiyonların hepsi nesneyi atomic_t türü biçiminde istemektedir. Bu aslında içerisinde yalnızca int bir nesne olan bir 
    yapı türüdür. Bu yapı nesnesinin içerisindeki değeri alan atomic_read isimli bir inline fonksiyon da vardır. Atomic 
    inline fonksiyonların bazıları şunlardır:

    #include <asm/atomic.h>

    int atomic_read(const atomic_t *v);
    void atomic_set(atomic_t *v, int i);
    void atomic_add(int i, atomic_t *v);
    void atomic_sub(int i, atomic_t *v);
    void atomic_inc(atomic_t *v);
    void atomic_dec(atomic_t *v)
    ...

    Bu fonksiyonların hepsinin atomic_t türünden nesnenin adresini alan bir parametresi vardır. atomic_set fonksiyonunun ikinci 
    parametresi set edilecek değeri almaktadır.

    Yukarıda da belirttiğimiz gibi atomic_t türü aslında int bir elemana sahip bir yapı biçimindedir. atomic_t türünden 
    bir değişkene ilkdeğer vermek için ATOMIC_INIT makrosu da kullanılabilir. Örneğin:

    atomic_t g_count = ATOMIC_INIT(0);

    Yukarıda da belirttiğimiz gibi atomic_t nesnesi içerisindeki değeri atomic_read makrosuyla elde edebiliriz. Örneğin:

    val = atomic_read(&g_count);

    Pekiyi mademki atomic_t türü içerisinde bir int değerin bulunduğu bir yapı belirtiyor bu durumda neden doğrudan int nesne
    kullanılmıyor da içerisinde int bir eleman olan yapı kullanılıyor? İşte bunun amacı bu atomik nesnenin ++, --, += gibi 
    operatörlerle kullanımı konusunda cesareti kırmaktır.

    Bit işlemlerine yönelik atomik işlemler de yapılabilmektedir:

    void set_bit(nr, void *addr);
    void clear_bit(nr, void *addr);
    void change_bit(nr, void *addr);
    test_bit(nr, void *addr);
    int test_and_set_bit(nr, void *addr);
    int test_and_clear_bit(nr, void *addr);
    int test_and_change_bit(nr, void *addr);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                139. Ders 05/05/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz kullanıcı modunda çeşitli fonksiyonların çeşitli koşullar altında blokeye yol açtığını belirtmiştik. Bir thread bloke 
    olduğunda thread belli bir koşul sağlanana kadar ilgili CPU'nun "çalışma kuyruğundan (run queue)" çıkartılır, ismine 
    "bekleme kuyruğu (wait queue)" denilen bir kuyruğa yerleştirilir. Blokeye yol açan koşul ortadan kalktığında ise thread 
    yeniden bekleme kuyruğundan alınarak ilgili CPU'nun çalışma kuyruğuna yerleştirilir. Biz şimdiye kadar kullanıcı modunda 
    hep sistem fonksiyonları yoluyla blokelerin oluştuğunu gördük. Ancak çekirdek modundaki aygıt sürücülerde blokeyi aygıt 
    sürücünün kendisi oluşturmaktadır. Örneğin biz boru aygıt sürücümüzde read işlemi yapıldığında eğer boruda okunacak hiç 
    bilgi yoksa read işlemini yapan user mode'daki thread'i bloke edebiliriz. Boruya bilgi geldiğinde de thread'i yeniden 
    çalışma kuyruğuna yerleştirip blokeyi çözebiliriz. İşte bu bölümde aygıt sürücüde thread'lerin nasıl bloke edileceği ve 
    blokenin nasıl çözüleceği üzerinde duracağız.

    Daha önceden de belirttiğimiz gibi mevcut Linux sistemlerinde her CPU ya da çekirdeğin ayrı bir "çalışma kuyruğu (run queue)" 
    bulunmaktadır. Ancak bir ara O(1) çizelgelemesi ismiyle Linux'ta bu konuda bir değişikliğe gidilmişti ((2.6.0 ile 2.6.22
    arasındaki çekirdekler)O(1) çizelgelemesi tekniğinde toplam tek bir çalışma kuyruğu bulunuyordu. Hangi CPU ya da çekirdeğe 
    atama yapılacaksa bu tek olan çalışma kuyruğundan thread alınıyordu. O(1) çizelgelemesi Linux'ta kısa bir süre kullanılmıştır. 
    Bunun yerine "CFS (Completely Fair Scheduling)" çizelgeleme sistemine geçilmiştir. Bugün ağırlıklı olarak CFS çizelgeleme 
    algoritmasının iyileştirilmiş biçimleri kullanılmaktadır.

    Daha önceden de belirttiğimiz gibi çalışmakta olan bir thread'in bloke olması sırasında thread'in yerleştirileceği tek bir 
    "bekleme kuyruğu (wait queue)" yoktur. Her CPU ya da çekirdek için de ayrı bir bekleme kuyruğu bulundurulmamaktadır. Bekleme 
    kuyrukları ilgili olay temelinde oluşturulmaktadır. Örneğin sleep fonksiyonu dolayısıyla bloke olan thread'ler ayrı bir 
    bekleme kuyruğuna, boru dolayısıyla bloke olan thread'ler ayrı bir bekleme kuyruğuna yerleştirilmektedir. Aygıt sürücüleri 
    yazanlar da kendi olayları için kendi bekleme kuyruklarını yaratırlar. Tabii çekirdekteki mutex ve semaphore fonksiyonları 
    da aslında kendi içerisinde bir bekleme kuyruğu kullanmaktadır. Çünkü bu fonksiyonlar da blokeye yol açmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                140. Ders 10/05/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi her aygıt sürücü kendi bloke olayları için kendinin kullanacağı bekleme kuyrukları 
    yaratabilmektedir. Çekirdek içerisinde bekleme kuyruklarını yaratan ve yok eden çekirdek fonksiyonları bulunmaktadır. Yine 
    çekirdek içerisinde bir thread'i çalışma kuyruğundan çıkartıp bekleme kuyruğuna yerleştiren, bekleme kuyruğundan çıkartıp 
    çalışma kuyruğuna yerleştiren fonksiyonlar bulunmaktadır.

    Linux'ta bekleme kuyrukları wait_queue_head_t isimli bir yapıyla temsil edilmektedir. Bir bekleme kuyruğu DECLARE_WAIT_QUEUE_HEAD(name) 
    makrosuyla oluşturulabilir. Örneğin:

    #include <linux/wait.h>

    static DECLARE_WAIT_QUEUE_HEAD(g_wq);

    Bu makro hem wait_queue_head_t nesnesini tanımlayıp hem de ona küme parantezleriyle ilkdeğerlerini vermektedir. Alternatif 
    olarak önce nesne tanımlanıp sonra init_waitqueue_head fonksiyonuyla da ilk değer verilebilir. Bu fonksiyon aslında bir 
    makro biçiminde yazılmıştır. Örneğin:

    #include <linux/wait.h>

    static wait_queue_head_t g_wq;
    ...
    init_waitqueue_head(&g_wq);

    Bir thread'i (yani task_struct nesnesini) çalışma kuyruğundan çıkartıp istenilen bekleme kuyruğuna yerleştirme işlemi wait_event 
    makrolarıyla gerçekleştirilmektedir. Temel wait_event makroları şunlardır:

    wait_event(wq_head, condition);
    wait_event_interruptible(wq_head, condition);
    wait_event_killable(wq_head, condition);
    wait_event_timeout(wq_head, condition, timeout);
    wait_event_interruptible_timeout(wq_head, condition, timeout);
    wait_event_interruptible_exclusive(wq_head, condition);

    wait_event makrosu thread'i "uninterruptible" biçimde bekleme kuyruğuna yerleştirir. Bu biçimde bloke olmuş thread'lerin
    blokeleri sinyal dolayısıyla çözülememektedir. wait_event_interruptible makrosu ise aynı işlemi "interruptible" olarak 
    yapmaktadır. Yani sinyal geldiğinde thread bekleme kuyruğundan uyandırılır. wait_event_killable makrosu yalnızca SIGKILL 
    sinyali için thread'i uyandırmaktadır. Yani bu biçimde bekleme kuyruğuna yerleştirilmiş bir thread'in blokesi sinyal geldiğinde 
    çözülmez, ancak SIGKILL sinyali ile thread yok edilebilir. wait_event_timeout ve wait_event_interruptible_timeout makrolarının 
    wait_event makrolarından farkı thread'i en kötü olasılıkla belli bir jiffy zaman aşımı ile uyandırabilmesidir. Jiffy kavramı 
    izleyen bölümlerde ele alınacaktır. Makrolardaki ilk parametre bekleme kuyruğunu belirtmektedir. Bu parametreye argüman hiç 
    adresi alınmadan geçirilmelidir.

    Makrolardaki "condition (koşul)" parametresi bool bir ifade biçiminde oluşturulmalıdır. Bu ifade ya sıfır olur ya da sıfır 
    dışı bir değer olur. Bu koşul ifadesi "uyanık kalmak için bir koşul" belirtmektedir. Yani bu koşul uyandırma koşulu değildir, 
    uyanık kalma koşuludur. Çünkü bu makrolarda koşula bakılması uyumadan önce ve uyandırılma işleminden sonra yapılmaktadır. 
    Yani önce koşula bakılır. Koşul sağlanmıyorsa thread uyutulur. Thread uyandırıldığında yeniden koşula bakılır. Koşul sağlanmıyorsa 
    yeniden uyutulur. Dolayısıyla uyanma işlemi çekirdek kodlarında tıpkı koşul değişkenlerinde (condition variable) olduğu gibi 
    döngü içerisinde yapılmaktadır. Örneğin:

    DECLARE_WAIT_QUEUE_HEAD(g_wq);
    int g_flag = 0;
    ...

    wait_event(g_wq, g_flag != 0);

    Burada koşul g_flag != 0 biçimindedir. wait_event makroları fonksiyon değil makro biçiminde yazıldığı için bu koşul bu 
    haliyle makronun içinde kullanılmaktadır. (Yani koşul ifadesinin sonucu değil, kendisi makroda kullanılmaktadır.) Makronun 
    içerisinde önce koşula bakılmakta, bu koşul sağlanıyorsa thread zaten uyutulmamaktadır. Eğer koşul sağlanmıyorsa thread 
    uyutulmaktadır. Thread uykudan uyandırıldığında tıpkı koşul değişkenlerinde olduğu gibi yeniden koşula bakılmakta eğer koşul 
    sağlanmıyorsa thread yeniden uyutulmaktadır. wait_event makrosunun geri döndürdüğü bir değer yoktur. wait_event makrosu şöyle 
    çalışmaktadır:

    1) Makro önce koşula bakar, koşul zaten sağlanıyorsa hemen işlemini sonlandırır.
    2) Eğer koşul sağlanmıyorsa thread çalışma kuyruğundan çıkartılıp bekleme kuyruğuna yerleştirilir.
    3) Thread uyandırıldığında aslında çalışma yine wait_event makrosunun içerisinden devam edecektir. Bu noktada makro yeniden 
    koşula bakar, koşulu sağlamayan thread'leri yeniden uyutur.

    Burada en çok tereddüt edilen nokta koşulun ne işe yaradığıdır. wake_up makroları izleyen paragraflarda da göreceğimiz gibi 
    yalnızca koşulu sağlayan thread'leri uyandıramamaktadır. Böyle bir mekanizmanın etkin bir biçimde oluşturulması da mümkün 
    değildir. Bu nedenle wake_up makroları koşula bakmaksızın bekleme kuyruğundaki birden fazla thread'i uyandırır. Uyanan 
    thread'lerin kendileri koşula bakmaktadır.

    wait_event_interruptible makrosunun wait_event makrosundan farkı eğer thread uyutulmuşsa uykudan bir sinyalle uyandırılabilmesidir. 
    Halbuki wait_event ile uykuya dalmış olan thread sinyal oluşsa bile uykudan uyandırılmamaktadır. wait_event_killable ile thread 
    uykuya dalındığında ise yalnızca SIGKILL sinyali ile thread uykudan uyandırılabilmektedir. Tabii programcı wait_event_interruptible
    makrosunun geri dönüş değerine bakmalı, eğer thread sinyal dolayısıyla uykudan uyandırılmışsa -ERESTARTSYS değeriyle kendi 
    fonksiyonundan geri dönmelidir. wait_event_interruptible makrosu eğer sinyal dolayısıyla uyanmışsa -ERESTARTSYS değeri ile, 
    koşul sağlandığından dolayı uyanmışsa 0 değeri ile geri dönmektedir. Örneğin:

    DECLARE_WAIT_QUEUE_HEAD(g_wq);
    int g_flag = 0;
    ...

    if (wait_event_interruptible(g_wq, g_flag != 0) != 0)
        return -ERESTARTSYS;

    Bu tür durumlarda koşulda kullanılan değişkenleri atomic olarak tanımlama iyi bir tekniktir. Örneğin:

    DECLARE_WAIT_QUEUE_HEAD(g_wq);
    static atomic_t g_flag = ATOMIC_INIT(0);
    ...

    if (wait_event_interruptible(g_wq, atomic_read(&g_flag) != 0) != 0)
        return -ERESTARTSYS;

    wait_event_interruptible_exclusive (bunun interrutible olmayan biçimi yoktur) makrosu Linux çekirdeklerine 2.6'nın belli 
    sürümünden sonra sokulmuştur. Yine bu makroyla birlikte aşağıda ele alınan wake_up_xxx_nr makroları da eklenmiştir. Bir 
    prosesin exclusive olarak wait kuyruğuna yerleştirilmesi onlardan belli sayıda olanların uyandırılabilmesini sağlamaktadır.

    Tabii wait_event makroları o andaki thread'i çizelgeden (yani run kuyruğundan) çıkartıp wait kuyruğuna yerleştirdikten 
    sonra "bağlamsal geçiş (context switch)" işlemini de yapmaktadır. Bağlamsal geçiş işlemi sonrasında artık çalışma kuyruğundaki 
    yeni bir thread CPU'ya atanarak çalıştırılır.

    wait_event makrolarının temsili kodunu şöyle düşünebilirsiniz:

    while (koşul_sağlanmadığı_sürece) {
        <thread'i bekleme kuyruğuna ekle>
        ---> <thread uyandırıldığında buradan çalışmaya devam eder>
    }

    Eski çekirdeklerde (yenilerinde de önemli değişiklik yoktur) wait_event makrosu şöyle yazılmıştır:

   #define __wait_event(wq, condition)                 \
    do {                                            \
        wait_queue_t __wait;                        \
        init_waitqueue_entry(&__wait, current);        \
                                                    \
        add_wait_queue(&wq, &__wait);                \
        for (;;) {                                    \
            set_current_state(TASK_UNINTERRUPTIBLE);        \
            if (condition)                            \
                break;                                \
            schedule();                                \
        }                                            \
        current->state = TASK_RUNNING;                \
        remove_wait_queue(&wq, &__wait);            \
    } while (0)

    #define wait_event(wq, condition)                 \
    do {                                            \
        if (condition)                                 \
            break;                                    \
        __wait_event(wq, condition);                \
    } while (0)

    Burada uyandırılan thread aslında schedule fonksiyonunun içerisinde çalışmaya devam edecekir. Koddan da gördüğünüz gibi akış
    schedule fonksiyonundan çıktığında döngü başa saracak ve yeniden koşul kontrol edilecektir.

    Bekleme kuyruğunda blokede bekletilen thread'ler wake_up makrolarıyla uyandırılmaktadır. Uyandırılmaktan kastedilen şey 
    thread'in bekleme kuyruğundan çıkartılıp yeniden çalışma kuyruğuna (run queue) yerleştirilmesidir. wait_event makrolarındaki 
    koşula wake_up bakmamaktadır. wake_up makroları yalnızca thread'i bekleme kuyruğundan çıkartıp çalışma kuyruğuna taşımaktadır. 
    Koşula uyandırılmış thread'in kendisi bakmaktadır. Eğer koşul sağlanmıyorsa thread yeniden uyutulmaktadır. Yani biz koşulu 
    sağlanır duruma getirmeden wake_up işlemi yaparsak thread yeniden uykuya dalacaktır. (Zaten yukarıda da belirttiğimiz gibi 
    yalnızca "koşulu sağlayan thread'i uyandırması" mümkün değildir.)

    En çok kullanılan wake_up makroları şunlardır:

    wake_up(wq_head);
    wake_up_nr(wq_head, nr);
    wake_up_all(wq_head);
    wake_up_interruptible(wq_head);
    wake_up_interruptible_nr(wq_head, nr);
    wake_up_interruptible_all(wq_head);

    Bu makroların hepsi birinci parametre olarak bekleme kuyruğunun adresini almaktadır. Bu makroların çalışmasının anlaşılması 
    için bekleme kuyrukları hakkında biraz ayrıntıya girmek gerekir. Bekleme kuyruğunu temsil eden wait_queue_head_t yapısı şöyle 
    bildirilmiştir:

    struct wait_queue_head {
        spinlock_t lock;
        struct list_head head;
    };

    typedef struct wait_queue_head wait_queue_head_t;

    Görüldüğü gibi bu bir bağlı listedir. Bağlı liste spinlock ile korunmaktadır. Bu bağlı listenin düğümleri wait_queue_entry
    yapılarından oluşmaktadır.

    struct wait_queue_entry {
        unsigned int flags;
        void *private;
        wait_queue_func_t func;
        struct list_head entry;
    };

    Bu yapının ayrıntısına girmeyeceğiz. Ancak yapıdaki flags elemanına dikkat ediniz. Bekleme kuyruğuna yerleştirilen bir 
    thread'in exclusive bekleme yapıp yapmadığı (yani wait_event_intrerruptible_exclusive ile bekleme yapıp yapmadığı)
    bu flags elemanında saklanmaktadır. Bu wait kuyruğunun bekleyen thread'leri (onların task_struct adreslerini) tutan
    bir bağlı liste olduğunu varsayabilirsiniz. (Yapının private elemanı thread'leri temsil eden task_struct yapı nesnelerinin 
    adreslerini tutmaktadır.) Yani bekleme kuyrukları aşağıdaki gibi düşünülebilir:

    T1 ---> T2 ---> T3 ---> T4 ---> T5 ---> T6 ---> T7 ---> T8 ---> NULL

    Bu thread'lerden bazıları exclusive bekleme yapmış olabilir. Bunları (E) ile belirtelim:

    T1 ---> T2 ---> T3 ---> T4(E) ---> T5 ---> T6(E) ---> T7 ---> T8(E) ---> NULL

    Artık wake_up makrolarını açıklayabiliriz. wake_up makrosu kuyruğun başından itibaren ilk exclusive bekleme yapan thread'e 
    kadar bu thread de dahil olmak üzere tüm thread'leri uyandırmaktadır. Tabii bu thread'lerin hepsi uyandırıldıktan sonra 
    ayrıca koşula da bakacaktır. Örneğimizde wake_up makrosu çağrıldığında T1, T2, T3 ve T4 thread'leri uyandırılacaktır. 
    Görüldüğü gibi wake_up makrosu aslında 1 tane exclusive thread uyandırmaya çalışmaktadır. Ancak onu uyandırırken kuyruğun 
    önündeki exclusive olmayanları da uyandırmaktadır. Tabii bu anlatımdan anlaşılacağı gibi wake_up makrosu eğer kuyrukta hiç 
    exclusive bekleme yapan thread yoksa thread'lerin hepsini uyandırmaktadır.

    wake_up_nr makrosu, wake_up makrosu gibi davranır ancak 1 tane değil en fazla nr parametresiyle belirtilen sayıda exclusive 
    thread'i uyandırmaya çalışır. Başka bir deyişle wake_up(g_wq) çağrısı ile wake_up_nr(g_qw, 1) çağrısı aynı anlamdadır.
    Eğer yukarıdaki örnekte wake_up_nr(g_wq, 2) çağrısını yapmış olsaydık T1, T2, T2, T4, T5, T6 thread'leri uyandırılırdı. 
    Tabii yukarıda da belirttiğimiz gibi bu thread'lerin uyandırılmış olması wait_event makrolarından çıkılacağı anlamına gelmemektedir. 
    Uyandırma işleminden sonra koşula yeniden bakılmaktadır.

    wake_up_all makrosu bekleme kuyruğundaki tüm exclusive thread'leri ve exclusive olmayan thread'leri yani kısaca tüm thread'leri 
    uyandırmaktadır. Tabii yine uyanan thread'ler koşula bakacaktır.

    wake_up_interruptible, wake_up_interruptible_nr ve wake_up_interruptible_all makroları interruptible olmayan makrolar 
    gibi çalışmaktadır. Ancak bu makrolar bekleme kuyruğunda yalnızca "interruptible" wait_event fonksiyonlarıyla bekletilmiş 
    thread'lerle ilgilenmektedir. Diğer thread'ler kuyrukta yokmuş gibi davranmaktadır.

    wake_up makroları birden fazla thread'i uyandırabildiğine göre uyanan thread'lerin yeniden uykuya dalması gerekebilir. 
    Çünkü programcı yalnızca bir thread'in çalışmaya devam etmesini isteyebilir. Bu durumda tıpkı kullanıcı modundaki koşul 
    değişkenlerindeki gibi bir kalıp kullanılabilir:

    if (mutex_lock_interruptible(&g_mutex) < 0)
        return -ERESTARTSYS;

    while (koşul_sağlanmadığı_sürece) {
        mutex_unlock(&g_mutex);
        if (wait_event_interruptible(g_wq, uyanık_kalma_koşulu) != 0)
            return -ERESTARTSYS;
        if (mutex_lock_interruptible(&g_mutex) < 0)
            return -ERESTARTSYS;
    }

    /* KRİTİK KOD, bu noktaya koşulu sağlayan ve uyandırılan tek bir thread gelir */

    mutex_unlock(&g_mutex);

    Burada birden fazla thread uyandırıldığında bunlardan yalnızca biri mutex kilidini alarak kritik koda girmektedir. Eğer 
    kritik kod içerisinde koşul sağlanmaz hale getirilirse bu durumda diğer thread'ler while döngüsü nedeniyle yeniden uykuya 
    dalacaktır.

    Örneğin boru aygıt sürücüsünde okuma yapan thread'ler eğer boruda hiç byte yoksa bloke olmalıdır. O halde buradaki koşul 
    g_count > 0 olmalıdır. Boruya yazan thread g_count değerini güncelledikten sonra eğer g_count önceden sıfırsa wake_up 
    makrolarıyla bekleyen thread'leri uyandırır. Thread'ler uyandıktan sonra yukarıdaki while döngüsünde bunlardan yalnızca 
    biri mutex kildini alır. Mutex kilidini alan thread'de borudan okuma yapar. Eğer okuma sonucunda g_count hala > 0 durumunda
    ise başka bir therad daha okuma yapacaktır. Ta ki g_count değeri 0 olana kadar. Bu durumda diğer thread'ler boruya yeni 
    bir yazma yapılana kadar blokede bekleyeceklerdir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücümüzün read ve write fonksiyonları aşağıdaki gibi olsun:

    wait_queue_head_t g_wq;
    atomic_t g_flag;
    ...

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        printk(KERN_INFO "wait-driver read...\n");

        atomic_set(&g_flag, 0);
        if (wait_event_interruptible(g_wq, atomic_read(&g_flag) != 0) != 0) {
            printk(KERN_INFO "Signal occurred...");
            return -ERESTARTSYS;
        }

        return 0;
    }

    static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        printk(KERN_INFO "wait-driver write...\n");

        atomic_set(&g_flag, 1);
        wake_up_interruptible(&g_wq);

        return 0;
    }

    Burada eğer birden fazla thread read yaparsa exclusive olmayan bir biçimde bekleme kuyruğunda bekleyecektir. write işleminde
    wake_up_interruptible makrosu ile uyandırma yapıldığına dikkat ediniz. Bekleme kuyruğunda exclusive bekleyen thread 
    olmadığına göre burada tüm read yapan thread'ler uyandırılacaktır. Onların koşulları sağlandığı için hepsi read fonksiyonundan
    çıkacaktır. Şimdi bu read fonksiyonunda exclusive bekleme yapmış olalım:

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        printk(KERN_INFO "wait-driver read...\n");

        atomic_set(&g_flag, 0);
        if (wait_event_interruptible_exclusive(g_wq, atomic_read(&g_flag) != 0) != 0) {
            printk(KERN_INFO "Signal occurred...");
            return -ERESTARTSYS;
        }

        return 0;
    }

    Artık write fonksiyonunda wake_up makrosu çağrıldığında yalnızca bir tane exclusive bekleme yapan thread uyandırılacağı 
    için read fonksiyonundan yalnızca bir thread çıkacaktır. Test için aşağıdaki kodları kullanabilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Birden fazla thread'in uyandırıldığı durumda bunların yalnızca bir tanesinin kritik koda girmesini sağlayan kalıbı 
    anımsayınız:

    if (mutex_lock_interruptible(&g_mutex) < 0)
        return -ERESTARTSYS;

    while (koşul_sağlanmadığı_sürece) {
        mutex_unlock(&g_mutex);
        if (wait_event_interruptible(g_wq, uyanık_kalma_koşulu) != 0)
            return -ERESTARTSYS;
        if (mutex_lock_interruptible(&g_mutex) < 0)
            return -ERESTARTSYS;
    }

    /* KRİTİK KOD, bu noktaya koşulu sağlayan ve uyandırılan tek bir thread  gelir */

    mutex_unlock(&g_mutex);

    Aşağıdaki kodda bu kalıp uygulanmıştır. Böylece her write işlemi yapıldığında yalnızca tek bir thread gerçek anlamda uyanıp
    kritik koda girecektir. Aygıt sürücünün read ve write fonksiyonları aşağıda verilmiştir:
---------------------------------------------------------------------------------------------------------------------------*/

/* wait-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <asm/atomic.h>
#include <linux/wait.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Wait-Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static wait_queue_head_t g_wq;
static atomic_t g_flag;

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "wait-driver module initialization...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "wait-driver")) < 0) {
        printk(KERN_INFO "cannot alloc char driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "cannot allocate cdev!...\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_fops;

    if ((result = cdev_add(g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    init_waitqueue_head(&g_wq);

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "wait-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "wait-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "wait-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "wait-driver read...\n");

    atomic_set(&g_flag, 0);
    if (wait_event_interruptible_exclusive(g_wq, atomic_read(&g_flag) != 0) != 0) {
        printk(KERN_INFO "Signal occurred...");
        return -ERESTARTSYS;
    }

    return 0;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "wait-driver write...\n");

    atomic_set(&g_flag, 1);
    wake_up_interruptible(&g_wq);

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* wait-test-read.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[32];
    ssize_t result;

    if ((fd = open("wait-driver", O_RDONLY)) == -1)
        exit_sys("open");

    printf("reading begins...\n");
    if ((result = read(fd, buf, 32)) == -1)
        exit_sys("result");

    printf("Ok\n");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* wait-test-write.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[32] = {0};

    if ((fd = open("wait-driver", O_WRONLY)) == -1)
        exit_sys("open");

    if (write(fd, buf, 32) == -1)
        exit_sys("write");

    printf("Ok\n");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* blocking-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <asm/atomic.h>
#include <linux/wait.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("General Character Device Driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};
static int g_flag;
static wait_queue_head_t g_wq;
static DEFINE_MUTEX(g_mutex);

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "blocking-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "blocking-driver")) < 0) {
        printk(KERN_ERR "cannot #include <asm/atomic.h> register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");

        return result;
    }

    init_waitqueue_head(&g_wq);

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);
    printk(KERN_INFO "blocking-driver exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "blocking-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "blocking-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "blocking...\n");

    g_flag = 0;

    if (mutex_lock_interruptible(&g_mutex) < 0)
        return -ERESTARTSYS;

    while (g_flag == 0) {
        mutex_unlock(&g_mutex);
        if (wait_event_interruptible(g_wq, g_flag != 0) < 0)
            return -ERESTARTSYS;
        if (mutex_lock_interruptible(&g_mutex) < 0)
            return -ERESTARTSYS;
        printk(KERN_INFO "waking up...\n");
    }
    g_flag = 0;
    printk(KERN_INFO "enters critical section...\n");

    mutex_unlock(&g_mutex);

    return 0;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "wake up...\n");
    g_flag = 1;
    wake_up_interruptible(&g_wq);

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* wait-test-read.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[32];
    ssize_t result;

    if ((fd = open("wait-driver", O_RDONLY)) == -1)
        exit_sys("open");

    printf("reading begins...\n");
    if ((result = read(fd, buf, 32)) == -1)
        exit_sys("result");

    printf("Ok\n");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* wait-test-write.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[32] = {0};

    if ((fd = open("wait-driver", O_WRONLY)) == -1)
        exit_sys("open");

    if (write(fd, buf, 32) == -1)
        exit_sys("write");

    printf("Ok\n");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                141. Ders 12/05/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Burada bir noktaya dikkatinizi çekmek istiyoruz. Daha önce görmüş olduğumuz mutex, semaphore, read/write kilitleri gibi 
    senkronizasyon nesnelerinin kendilerinin oluşturduğu bekleme kuyrukları vardır. Bu senkronizasyon nesneleri bloke oluşturmak
    için kendi bekleme kuyruklarını kullanmaktadır. Çekirdek kodları içerisinde bu senkronizasyon nesneleri için oluşturulmuş 
    bekleme kuyruklarını görebilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de daha önce yapmış olduğumuz boru örneğimizi gerçek bir boru haline getirelim. Yani eğer boruda en az 1 byte boş 
    alan kalmadıysa read fonksiyonu blokede en az 1 byte okuyana kadar beklesin. Eğer boruda tüm bilgileri yazacak kadar boş 
    yer kalmadıysa bu kez de yazan taraf blokede beklesin. Burada izlenecek temel yöntem aslında kursumuzda "koşul değişkenleri 
    (condition variable)" denilen senkronizasyon nesnelerindeki yöntemin aynısı olmalıdır. Okuyan thread kuyruktaki byte sayısını 
    belirten g_count == 0 olduğu sürece bekleme kuyruğunda beklemelidir. Tabii bizim kuyruk üzerinde işlem yaptığımız kısımları 
    senkronize etmemiz gerekir. Bunu da bir binary semaphore nesnesi ya da mutex nesnesi ile sağlayabiliriz. Semaphore nesnesini 
    ve bekleme kuyruğunu aşağıdaki gibi yaratabiliriz:

    static wait_queue_head_t g_wq;
    DEFINE_SEMAPHORE(g_sem);

    Okuyan taraf önce semaphore kilidini eline almalı ancak eğer uykuya dalacaksa onu serbest bırakıp uykuya dalmalıdır. Kuyruk 
    üzerinde aynı anda işlemler yapılabileceği için tüm işlemlerin kritik kod içerisinde ele alınması uygun olur. O halde read 
    işlemindeki bloke olmanın tipik çatısı şöyle oluşturulabilir:

    ...
    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (g_count == 0) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqread, g_count > 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    // kuyruktan okuma işlemleri

    up(&g_sem);

    Burada önce down_interruptible fonksiyonu ile semaphore kilitlenmeye çalışılmıştır. Eğer semaphore zaten kilitliyse semaphore'un 
    kendi bekleme kuyruğunda thread uykuya dalacaktır. Daha sonra g_count değerine bakılmıştır. Eğer g_count değeri 0 ise önce 
    semaphore serbest bırakılıp sonra thread bekleme kuyruğunda uyutulmuştur. Thread bekleme kuyruğundan uyandırıldığında yeniden 
    semaphore kontrolünü ele almaktadır. Tabii eğer birden fazla thread bekleme kuyruğundan uyandırılırsa yalnızca bunlardan biri 
    semaphore kontrolünü ele alacaktır. Semaphore kilidini alan thread bundan sonra kuyruktan bilgiler okunacak ve semaphore 
    kilidini serbest bırakılacaktır. Eğer birden fazla thread bekleme kuyruğundan uyanmışsa bu kez diğer bir thread semaphore 
    kontrolünü ele alacak ve g_count değerine bakacaktır. Yukarıda da belirttiğimiz gibi aslında bu bir "koşul değişkeni" kodu 
    gibidir. Çekirdek içerisinde böyle bir nesne olmadığı için manuel uygulanmıştır.

    Benzer biçimde write işleminin de çatısı aşağıdaki gibidir:

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (PIPE_BUFFER_SIZE - g_count < size) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_count >= size) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    // kuyruğa yazma işlemleri

    up(&g_sem);

    Burada benzer işlemler uygulanmıştır. Eğer kuyrukta yazma yapılmak istenen kadar boş alan varsa akış while döngüsünün 
    içerisine girmeyecektir. (Buradaki while koşulunun "PIPE_BUFFER_SIZE - g_count < size" biçiminde olduğuna dikkat ediniz.) 
    Dolayısıyla yazma işlemi kritik kod içerisinde yapılabilecektir. Ancak kuyrukta yeteri kadar yer yoksa semaphore kilidi 
    serbest bırakılıp thread bekleme kuyruğunda bekletilecektir. Çıkışta benzer işlemler yapılmaktadır.

    Aslında burada spinlock nesneleri de kullanılabilir. Ancak zaten mutex, semaphore ve read/write lock nesneleri kendi içerisinde 
    bir miktar spin yapmaktadır. Spinlock için şu durumları gözden geçirmelisiniz:

    - Spinlock nesnesinde bekleme CPU zamanı harcanarak meşgul bir döngü içerisinde yapılmaktadır. Dolayısıyla spinlock nesneleri 
    kilidin kısa süreli bırakılacağından emin olunabiliyorsa kullanılmalıdır.

    - Spinlock içerisinde bağlamsal geçiş kapatılmakta ve sinyal işlemleri de bekletilmektedir. Yani spinlock beklemelerinin 
    "interruptible" bir biçimi yoktur.

    Örneğimizde kilitli kalınan kod miktarı dikkate alındığında semaphore ya da mutex nesnelerinin kullanılmasının daha uygun 
    olacağı söylenebilir.

    Burada yazma işlemleri için "yazma bekleme kuyruğu" ve okuma işlemleri için "okuma bekleme kuyruğu" biçiminde iki bekleme
    kuyruğu olduğuna dikkat ediniz. Çünkü yazan taraf okuma bekleme kuyruğundaki thread'leri okuyan taraf ise yazma bekleme 
    kuyruğundaki thread'leri uyandırmak isteyecektir.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>

#define PIPE_BUFFER_SIZE        10
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = pipe_driver_open,
    .read = pipe_driver_read,
    .write = pipe_driver_write,
    .release = pipe_driver_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;
static wait_queue_head_t g_wqread;
static wait_queue_head_t g_wqwrite;
static int n_readers;
static int n_writers;

static DEFINE_SEMAPHORE(g_sem);

static int __init pipe_driver_init(void)
{
    int result;

    printk(KERN_INFO "pipe-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    init_waitqueue_head(&g_wqread);
    init_waitqueue_head(&g_wqwrite);

    return 0;
}

static void __exit pipe_driver_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "pipe-driver exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "pipe-driver opened...\n");

    return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "pipe-driver closed...\n");

    return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (g_count == 0) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqread, g_count > 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, g_count);
    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            goto EXIT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    result = esize;
EXIT:
    wake_up_interruptible(&g_wqwrite);
    up(&g_sem);

    return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (size > PIPE_BUFFER_SIZE)
        size = PIPE_BUFFER_SIZE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (PIPE_BUFFER_SIZE - g_count < size) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_count >= size) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);

    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            goto EXIT;

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;

    result = esize;

EXIT:
    wake_up_interruptible(&g_wqread);
    up(&g_sem);

    return esize;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");

        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda vermiş olduğumuz blokeli boru aygıt sürücüsü örneği UNIX/Linux sistemlerinde bulunan isimli borulara oldukça 
    benzemektedir. Ancak UNIX/Linux sistemlerindeki isimli boruların yukarıdaki aygıt sürücümüzde olmayan şu ek özellikleri 
    vardır:

    - Anımsanacağı gibi isimli boruyu bir prosesin thread'i O_RDONLY bayrağı ile okuma amaçlı açmak istediğinde eğer bu 
    boruyu herhangi bir prosesin thread'i O_WRONLY bayrağı ile yazma amaçlı açmamışsa okuma amaçlı açmaya çalışan thread boru 
    yazma amaçlı açılana kadar open fonksiyonunda bloke olmaktadır. Benzer biçimde bir thread isimli boruyu O_WRONLY bayrağı 
    ile yazma amaçlı açmak istediğinde bu boruyu herhangi bir prosesin thread'i O_RDONLY bayrağı ile okuma modunda açmamışsa 
    yazma amaçlı açmaya çalışan thread boru okuma amaçlı açılana kadar open fonksiyonunda bloke olmaktadır. Bizim aygıt 
    sürücümüzde böyle bir özellik yoktur.

    - İsimli borularda boru boşken okuma yapılmak istendiğinde eğer boruya yazma yapma potansiyelinde hiçbir thread kalmamışsa
    read fonksiyonu blokeye yol açmamakta 0 ile geri dönmektedir. Zaten boru haberleşmesi bu biçimde sonlandırılır. Yani boruya 
    yazan taraf önce boruyu kapatır. Borudan okuyan taraf borudakileri okur. Eğer boruda hiçbir şey kalmazsa read fonksiyonu 
    0 ile geri döner. Okuyan taraf da döngüden çıkarak işlemini sonlandırır. Bizim yukarıdaki boru aygıt sürücümüzde bu özellik 
    yoktur.

    - İsimli borularda borudan okuma yapma potansiyelinde olan hiçbir thread yoksa boruya yazma yapıldığında SIGPIPE sinyali 
    oluşturulmaktadır. Bu sinyal de ele alınmadıysa yazma yapan prosesin sonlanmasına yol açar. Bizim boru aygıt sürücümüzde
    de bu özellik yoktur.

    Pekiyi bu özellikler nasıl sağlanabilir? Bizim open fonksiyonunda bloke oluşturabilmemiz için boruya yazma potansiyelinde 
    olan ve borudan okuma yapma potansiyelinde olan kaç thread'in bulunduğunu tutmamız gerekir. Tüm prosesler aygıt sürücüyü 
    açtığına göre bu işlem aygıt sürücünün open fonksiyonunda ve release fonksiyonunda yapılabilir. Dosya open fonksiyonu 
    ile açıldığında filp parametresinin gösterdiği yerdeki file nesnesinin f_flags elemanı open fonksiyonunda kullanılan açma
    bayrağını belirtmektedir. Biz de iki sayaç alıp kaç thread'in okuma amaçlı kaç thread'in yazma amaçlı olarak boruyu açtığını
    tutabiliriz.

    Aşağıdaki örnekte boru aygıt sürücümüzün yukarıdaki belirtilen eksiklikleri giderilmiştir. Burada aygıt sürücünün open 
    fonksiyonunda bloke işlemi şöyle sağlanmıştır:

    static int pipe_driver_open(struct inode *inodep, struct file *filp)
    {
        int accmode = filp->f_flags & O_ACCMODE;

        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;

        if (accmode == O_RDONLY) {
            ++g_nreaders;
            wake_up_interruptible(&g_writeopen);
            while (g_nwriters == 0) {
                up(&g_sem);
                if (wait_event_interruptible(g_readopen, g_nwriters > 0))
                    return -ERESTARTSYS;
                if (down_interruptible(&g_sem))
                    return -ERESTARTSYS;
            }
        }
        else if (accmode == O_WRONLY) {
            ++g_nwriters;
            wake_up_interruptible(&g_readopen);
            while (g_nreaders == 0) {
                up(&g_sem);
                if (wait_event_interruptible(g_writeopen, g_nreaders > 0))
                    return -ERESTARTSYS;
                if (down_interruptible(&g_sem))
                    return -ERESTARTSYS;
            }
        }

        else if (accmode == O_RDWR) {
            ++g_nreaders;
            ++g_nwriters;
            wake_up_interruptible(&g_readopen);
            wake_up_interruptible(&g_writeopen);
        }
        up(&g_sem);

        return 0;
    }

    Aygıt dosyasının hangi bayrakla açıldığının belirlenmesi için filp göstericisinin gösterdiği yerdeki file nesnesinin 
    f_ops elemanına bakılmıştır. Bu elemanın ilk 2 biti dışındaki bitleri başka bayraklarla ilgili olduğu için önce ilk 
    2 bit maskelenmiştir:

    int accmode = filp->f_flags & O_ACCMODE;

    Sonra eğer aygıt dosyası yazma amaçlı açılmışsa okuma amaçlı açış yapılmış mı diye, okuma amaçlı açılmışsa yazma amaçlı
    açış var mı diye bakılmıştır. Kodumuzda open fonksiyonunda bloke oluşturmak için iki ayrı bekleme kuyruğunun daha yaratıldığını 
    görüyorsunuz. Aygıt sürücümüzün release fonksiyonunda bu sayaçlar aşağıdaki gibi eksiltilmiştir:

    static int pipe_driver_release(struct inode *inodep, struct file *filp)
    {
        int accmode = filp->f_flags & O_ACCMODE;

        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;

        if (accmode == O_RDONLY)
            --g_nreaders;
        else if (accmode == O_WRONLY)
            --g_nwriters;
        else if (accmode == O_RDWR) {
            --g_nreaders;
            --g_nwriters;

        }
        up(&g_sem);

        printk(KERN_INFO "pipe-driver closed...\n");

        return 0;
    }

    Aygıt sürücümüzün read fonksiyonunda eğer boruya yazma potansiyelinde olan hiçbir thread kalmamışsa read fonksiyonu 0 ile 
    geri döndürülmüştür:

    ...
    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (g_count == 0) {
        if (g_nwriters == 0) {
            result = 0;
            goto EXIT;
        }
        up(&g_sem);
        if (wait_event_interruptible(g_wqread, g_count > 0 || g_nwriters == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }
    ...

    Benzer biçimde aygıt sürücümüzün write fonksiyonunda eğer borudan okuma yapma potansiyelinde hiçbir thread kalmamışsa 
    SIGPIPE sinyali oluşturulmuştur:

    ...
    if (g_nreaders == 0) {
        up(&g_sem);
        send_sig(SIGPIPE, current, 0);
        return -EPIPE;
    }
    while (PIPE_BUFFER_SIZE - g_count < size) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_count >= size || g_nreaders == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
        if (g_nreaders == 0) {
            up(&g_sem);
            send_sig(SIGPIPE, current, 0);
            return -EPIPE;
        }
    }
    ...

    Aygıt sürücümüzün release fonksiyonunda da sayaçlar eksiltilmiştir:

    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY)
        --g_nreaders;
    else if (accmode == O_WRONLY)
        --g_nwriters;
    else if (accmode == O_RDWR) {
        --g_nreaders;
        --g_nwriters;
    }

    if (g_nreaders + g_nwriters == 0) 
		g_count = g_head = g_tail = 0;

    up(&g_sem);

    Aşağıda örnek bir bütün olarak verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>

#define PIPE_BUFFER_SIZE        10
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = pipe_driver_open,
    .read = pipe_driver_read,
    .write = pipe_driver_write,
    .release = pipe_driver_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;
static wait_queue_head_t g_wqwriteopen;
static wait_queue_head_t g_wqreadopen;
static wait_queue_head_t g_wqread;
static wait_queue_head_t g_wqwrite;
static int g_nreaders;
static int g_nwriters;

static DEFINE_SEMAPHORE(g_sem);

static int __init pipe_driver_init(void)
{
    int result;

    printk(KERN_INFO "pipe_driver-char-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    init_waitqueue_head(&g_wqreadopen);
    init_waitqueue_head(&g_wqwriteopen);
    init_waitqueue_head(&g_wqread);
    init_waitqueue_head(&g_wqwrite);

    return 0;
}

static void __exit pipe_driver_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "pipe_driver-char-driver exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY) {
        ++g_nreaders;
        wake_up_interruptible(&g_wqwriteopen);
        while (g_nwriters == 0) {
            up(&g_sem);
            if (wait_event_interruptible(g_wqreadopen, g_nwriters > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_WRONLY) {
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        while (g_nreaders == 0) {
            up(&g_sem);
            if (wait_event_interruptible(g_wqwriteopen, g_nreaders > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }

    else if (accmode == O_RDWR) {
        ++g_nreaders;
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        wake_up_interruptible(&g_wqwriteopen);
    }
    up(&g_sem);

    return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY)
        --g_nreaders;
    else if (accmode == O_WRONLY)
        --g_nwriters;
    else if (accmode == O_RDWR) {
        --g_nreaders;
        --g_nwriters;

    }
    if (g_nreaders == 0)
        wake_up_interruptible(&g_wqwrite);
    if (g_nwriters == 0)
        wake_up_interruptible(&g_wqread);

    if (g_nreaders + g_nwriters == 0) 
		g_count = g_head = g_tail = 0;

    up(&g_sem);

    return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (g_count == 0) {
        if (g_nwriters == 0) {
            result = 0;
            goto EXIT;
        }
        up(&g_sem);
        if (wait_event_interruptible(g_wqread, g_count > 0 || g_nwriters == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, g_count);
    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            goto EXIT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    result = esize;
EXIT:
    wake_up_interruptible(&g_wqwrite);
    up(&g_sem);

    return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (size > PIPE_BUFFER_SIZE)
        size = PIPE_BUFFER_SIZE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (g_nreaders == 0) {
        up(&g_sem);
        send_sig(SIGPIPE, current, 0);
        return -EPIPE;
    }
    while (PIPE_BUFFER_SIZE - g_count < size) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_count >= size || g_nreaders == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
        if (g_nreaders == 0) {
            up(&g_sem);
            send_sig(SIGPIPE, current, 0);
            return -EPIPE;
        }
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);

    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            goto EXIT;

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;

    result = esize;

EXIT:
    wake_up_interruptible(&g_wqread);
    up(&g_sem);

    return esize;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");

        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1)
            exit_sys("read");
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                142. Ders 24/05/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında bekleme kuyrukları wait_queue_entry isimli yapı nesnelerinden oluşan bir çift bağlı listedir. wait_queue_head_t 
    yapısı da bağlı listenin ilk ve son elemanlarının adresini tutmaktadır:

    wait_queue_head_t <-----> wait_queue_entry <-----> wait_queue_entry <-----> wait_queue_entry <-----> wait_queue_entry ...

    Çekirdek kodlarında bu yapılar "include/linux/wait.h" dosyası içerisinde aşağıdaki gibi bildirilmiştir:

    struct wait_queue_head {
        spinlock_t    lock;
        struct list_head head;
    };

    typedef struct wait_queue_head wait_queue_head_t;

    struct wait_queue_entry {
        unsigned int flags;
        void *private;
        wait_queue_func_t func;
        struct list_head entry;
    };

    wait_queue_head yapısının içerisindeki list_head elemanı bağlı listenin ilk ve son elemanlarının adreslerini tutmaktadır. 
    Yapının lock elemanı ise bekleme kuyruğuna erişirken kullanılacak olan spinlock nesnesini belirtmektedir. Biz burada 
    wait_queue_entry yapısının ayrıntılarına girmeyeceğiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz aygıt sürücü kodumuzda o anda quanta süresini bırakıp çizelgeleyicinin kendi algortimasına göre sıradaki thread'i 
    çizelgelemesini sağlayabiliriz. Bunun için schedule isimli çekirdek fonksiyonu kullanılmaktadır. Bu fonksiyon bloke 
    oluşturmamaktadır. Yalnızca thread'ler arası geçiş (context switch) oluşturmaktadır. schedule fonksiyonu herhangi bir 
    parametre almamaktadır:

    #include <linux/kernel.h>

    void schedule(void);

    Tabii koşullara bağlı olarak biz schedule fonksiyonunu çağırmış olsak bile işletim sistemi başka bir thread olmadığı için 
    ya da thread önceliklerinden dolayı yine bizim thread'imizi çizelgeleyebilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında wait_event fonksiyonları export edilmiş birkaç fonksiyon çağrılarak yazılmıştır. Dolayısıyla wait_event fonksiyonlarını 
    çağırmak yerine programcı daha aşağı seviyeli (zaten wait_event fonksiyonlarının çağırmış olduğu) fonksiyonları çağırabilir. 
    Yani bu işlemi daha aşağı seviyede manuel de yapabilir. Prosesin manuel olarak wait kuyruğuna alınması prepare_to_wait ve 
    prepare_to_wait_exclusive isimli fonksiyonlar tarafından yapılmaktadır:

    #include <linux/wait.h>

    void prepare_to_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);
    void prepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);

    Bu fonksiyonların birinci parametreleri bekleme kuyruğu nesnesinin adresini, ikinci parametreleri bu kuyruğa yerleştirilecek 
    wait_queue_entry nesnesinin adresini almaktadır. Fonksiyonların üçüncü parametreleri TASK_UNINTERRUPTIBLE ya da TASK_INTERRUPTIBLE 
    biçiminde geçilebilir. Bir wait_queue_entry nesnesi şöyle oluşturulabilir:

    DEFINE_WAIT(wqentry);

    Ya da açıkça tanımlanıp init_wait makrosuyla ilk değerlenebilir. Örneğin:

    struct wait_queue_entry wqentry;
    ...
    init_wait(&wqentry);

    DEFINE_WAIT makrosu global tanımlamalarda kullanılamamaktadır. Çünkü bu makro küme parantezleri içerisinde sabit ifadesi olmayan 
    ifadeler barındırmaktadır. Ancak makro yerel tanımlamalarda kullanılabilir.

    Aslında prepare_to_wait ve prepare_to_wait_exclusive fonksiyonları bekleme kuyruğuna bir wait_queue_entry nesnesi eklemektedir. 
    Yani programcının bunun için yeni bir wait_queue_entry nesnesi oluşturması gerekmektedir. prepare_to_wait_exclusive fonksiyonu 
    exclusive uyuma için kullanılmaktadır.

    prepare_to_wait ve prepare_to_wait_exclusive fonksiyonları şunları yapmaktadır:

    1) Thread'i çalışma kuyruğundan çıkartıp bekleme kuyruğuna yerleştirir. (Çalışma kuyruğunun organizasyonu ve bu işlemin gerçek 
    ayrıntıları biraz karmaşıktır. Biz burada çalışma kuyruğunun organizasyonu üzerinde durmayacağız.)
    2) Thread'in durum bilgisini (task state) state parametresiyle belirtilen duruma çeker.
    3) prepare_to_wait fonksiyonu kuyruk elemanını exclusive olmaktan çıkartırken, prepare_to_wait_exclusive onu exclusive yapar.

    Thread'in çalışma kuyruğundan bekleme kuyruğuna aktarılması onun uykuya dalması anlamına gelmemektedir. Programcı artık thread 
    çalışma kuyruğunda olmadığına göre schedule fonksiyonu ile thread'ler arası geçiş (context switch) uygulamalı ve akış kontrolünü 
    başka bir thread'e bırakmalıdır. Zaten thread'in çalışma kuyruğundan çıkartılması artık yeniden çalışma kuyruğuna alınmadıktan 
    sonra uykuda bekletilmesi anlamına gelmektedir.

    Tabii biz prepare_to_wait ya da prepare_to_wait_exclusive fonksiyonlarını çağırdıktan sonra bir biçimde koşul durumuna bakmalıyız. 
    Eğer koşul sağlanmışsa hiç prosesi uykuya daldırmadan hemen bekleme kuyruğundan çıkarmalıyız. Eğer koşul sağlanmamışsa gerçekten 
    artık schedule fonksiyonuyla "thread'ler arası geçiş" uygulamalıyız. Thread'imiz schedule fonksiyonunu çağırdıktan sonra artık 
    uyandırılana kadar bir daha çizelgelenmeyecektir. Bu da bizim uykuya dalmamız anlamına gelmektedir.

    Pekiyi thread'imiz uyandırıldığında nereden çalışmaya devam edecektir? İşte schedule fonksiyonu thread'ler arası geçiş yaparken 
    kalınan yeri thread'e ilişkin task_struct yapısının içerisine kaydetmektedir. Kalınan yer schedule fonksiyonunun içerisinde 
    bir yerdir. O halde thread'imiz uyandırıldığında schedule fonksiyonunun içerisinden çalışmaya devam edecektir. Sonra schedule 
    fonksiyonu geri dönecek ve thread akışı devam edecektir.

    wake_up fonksiyonları thread'i bekleme kuyruklarından çıkartıp çalışma kuyruğuna eklemektedir. Ancak prepare_to_wait ve 
    prepare_to_wait_exclusive fonksiyonları çağrıldıktan sonra eğer koşulun zaten sağlandığı görülürse bu durumda uyandırma 
    wake_up fonksiyonlarıyla yapılmadığı için bekleme kuyruğundan thread'in geri çıkartılması da programcının sorumluluğundadır. 
    Bu işlem finish_wait fonksiyonu ile yapılmaktadır.

    #include <linux/wait.h>

    void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);

    Bu fonksiyon zaten thread wake_up fonksiyonları tarafından bekleme kuyruğundan çıkartılmışsa herhangi bir işlem yapmaz. 
    Bu durumda manuel uyuma şöyle yapılabilir.

    DEFINE_WAIT(wqentry);

    prepare_to_wait(&g_wq, &wqentry, TASK_UNINTERRUPTIBLE);
    if (!condition)
        schedule();
    finish_wait(&wqentry);

    Tabii eğer thread INTERRUPTIBLE olarak uyuyorsa schedule fonksiyonundan çıkıldığında sinyal dolayısıyla da çıkılmış olabilir. 
    Bunu anlamak için signal_pending isimli fonksiyon çağrılır. Bu fonksiyon sıfır dışı bir değerle geri dönmüşse uyandırma 
    işleminin sinyal yoluyla yapıldığı anlaşılır. Bu durumda tabii aygıt sürücüdeki fonksiyon -ERESTARTSYS ile geri döndürülmelidir. 
    signal_pending fonksiyonunun prototipi şöyledir:

    #include <linux/kernel.h>

    int signal_pending(struct task_struct *p);

    Fonksiyon parametre olarak thread'e ilişkin task_struct yapısının adresini almaktadır. Bu durumda INTERRUPTIBLE uyuma aşağıdaki 
    gibi yapılabilir:

    DEFINE_WAIT(wqentry);

    prepare_to_wait(&g_wq, &wqentry, TASK_INTERRUPTIBLE);
    if (!condition)
        schedule();
    if (signal_pending(current))
        return -ERESTARTSYS;
    finish_wait(&wqentry);

    wake_up makrolarının şunları yaptığını anımsayınız:

    1) Wait kuyruğundaki prosesleri çıkartarak run kuyruğuna yerleştirir.
    2) Prosesin durumunu TASK_RUNNING haline getirir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                143. Ders 26/05/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında wait_event fonksiyonları yukarıda açıkladığımız daha aşağı seviyeli fonksiyonlar kullanılarak gerçekleştirilmiştir. 
    Mevcut son Linux çekirdeğinde wait_event_interruptible makrosu şöyle yazılmıştır:

    #define wait_event_interruptible(wq_head, condition)                \
    ({                                                                    \
        int __ret = 0;                                                    \
        might_sleep();                                                    \
        if (!(condition))                                                \
            __ret = __wait_event_interruptible(wq_head, condition);        \
        __ret;                                                            \
    })

    Burada gcc'nin bileşik ifade de denilen bir eklentisi (extension) kullanılmıştır. Bu makro ayrıntılar göz ardı edilirse 
    __wait_event_interruptible makrosunu çağırmaktadır. Bu makro şöyle tanımlanmıştır:

    #define __wait_event_interruptible(wq_head, condition)                \
    ___wait_event(wq_head, condition, TASK_INTERRUPTIBLE, 0, 0,            \
              schedule())

    Burada ___wait_event makrosunun interruptible olan ve olmayan kodların ortak makrosu olduğu görülmektedir. Bu 
    makro da şöyle tanımlanmıştır:

    #define ___wait_event(wq_head, condition, state, exclusive, ret, cmd)        \
    ({                                                                            \
        __label__ __out;                                                        \
        struct wait_queue_entry __wq_entry;                                        \
        long __ret = ret;    /* explicit shadow */                                \
                                                                                \
        init_wait_entry(&__wq_entry, exclusive ? WQ_FLAG_EXCLUSIVE : 0);        \
        for (;;) {                                                                \
            long __int = prepare_to_wait_event(&wq_head, &__wq_entry, state);   \
                                                                                \
            if (condition)                                                        \
                break;                                                            \
                                                                                \
            if (___wait_is_interruptible(state) && __int) {                        \
                __ret = __int;                                                    \
                goto __out;                                                        \
            }                                                                    \
                                                                                \
            cmd;                                                                \
        }                                                                        \
        finish_wait(&wq_head, &__wq_entry);                                        \
    __out:    __ret;                                                                \
    })
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücülerimize arzu edersek "blokesiz (non-blocking)" okuma yazma desteği de verebiliriz. Tabii bu desteğin verilebilmesi
    için aygıt sürücünün okuma yazma sırasında bloke oluşturması gerekmektedir. Anımsanacağı gibi blokesiz işlem yapabilmek için 
    open POSIX fonksiyonunda fonksiyonun ikinci parametresine O_NONBLOCK bayrağı ekleniyordu. Normal disk dosyalarında O_NONBLOCK 
    bayrağının bir anlamı yoktur. Ancak boru gibi özel dosyalarda ve aygıt sürücülerde daha önceden de belirttiğimiz gibibu bayrak 
    şu anlama gelmektedir:

    1) Okuma sırasında eğer okunacak bir bilgi yoksa read fonksiyonu bloke oluşturmaz, başarısızlıkla geri döner ve errno değeri 
    EAGAIN olarak set edilir.

    2) Yazma sırasında yazma eylemi meşguliyet yüzünden yapılamıyorsa write fonksiyonu bloke oluşturmaz, başarısızlıkla geri döner 
    ve errno değeri yine EAGAIN olarak set edilir.

    Aygıt sürücü açıldığında open fonksiyonunun ikinci parametresi file yapısının (dosya nesnesinin) f_flags elemanına 
    yerleştirilmektedir. Dosya nesnesinin adresinin aygıt sürücüdeki fonksiyonlara filp parametresiyle aktarıldığını anımsayınız. 
    Bu durumda biz aygıt dosyasının blokesiz modda açılıp açılmadığını şöyle test edebiliriz:

    if (filp->f_flags & O_NONBLOCK) {        /* blokesiz modda mı açılmış */

        /* open fonksiyonunda aygıt O_NONBLOCK bayrağı ile açılmış */

    }

    Aygıt sürücümüz blokesiz modda işlemlere izin vermiyorsa biz bu durumu kontrol etmeyebiliriz. Yani böyle bir aygıt sürücüde 
    programcı aygıt sürücüyü O_NONBLOCK bayrağını kullanarak açmışsa bu durumu hiç dikkate almayabiliriz. (Örneğin disk dosyalarında
    blokesiz işlemlerin bir anlamı olmadığı halde Linux çekirdeği disk dosyaları O_NONBLOCK bayrağıyla açıldığında hata ile geri 
    dönmeden bayrağı dikkate almamaktadır.) Eğer bu kontrol yapılmak isteniyorsa aygıt sürücünün açılması sırasında kontrol 
    aygıt sürücünün open fonksiyonunda yapılabilir. Bu durumda open fonksiyonunu -EINVAL değeriyle geri döndürebilirsiniz. Örneğin:

    static int generic_open(struct inode *inodep, struct file *filp)
    {
        if (filp->f_flags & O_NONBLOCK)
            return -EINVAL;

        return 0;
    }

    Pekiyi boru aygıt sürücümüze nasıl blokesiz mod desteği verebiliriz? Aslında bunun için iki şeyi yapmamız gerekir:

    1) Yazma yapıldığı zaman boruda yazılanları alacak kadar yer yoksa aygıt sürücümüzün write fonksiyonunu -EAGAIN değeriyle 
    geri döndürmeliyiz. Örneğin:

    ...
    if (down_interruptible(&g_sem))
        return -ERESTARTSYS;

    while (PIPE_BUFSIZE - g_count < size) {
        up(&g_sem);

        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;

        if (wait_event_interruptible(g_wqwrite, PIPE_BUFSIZE - g_count >= size))
            return -ERESTARTSYS;

        if (down_interruptible(&g_sem))
            return -ERESTARTSYS;
    }
    ...

    2) Okuma yapıldığı zaman eğer boruda hiç bilgi yoksa aygıt sürücümüzün read fonksiyonunu -EAGAIN değeriyle geri döndürmeliyiz.
    Örneğin:

    ...
    if (down_interruptible(&g_sem))
        return -ERESTARTSYS;

    while (g_count == 0) {
        up(&g_sem);

        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;

        if (wait_event_interruptible(g_wqread, g_count > 0))
            return -ERESTARTSYS;

        if (down_interruptible(&g_sem))
            return -ERESTARTSYS;
    }
    ...

    read ve write fonksiyonlarının -EAGAIN değeriyle geri döndürülmeden önce aygıt dosyasının blokesiz modda açılıp açılmadığının
    kontrol edilmesi gerektiğine dikkat ediniz.

    Aşağıdaki örnekte boru aygıt sürücüsüne blokesiz okuma ve yazma desteği verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>

#define PIPE_BUFFER_SIZE        10
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = pipe_driver_open,
    .read = pipe_driver_read,
    .write = pipe_driver_write,
    .release = pipe_driver_release
};

static unsigned char g_pipebuf[PIPE_BUFFER_SIZE];
static size_t g_head;
static size_t g_tail;
static size_t g_count;
static wait_queue_head_t g_wqwriteopen;
static wait_queue_head_t g_wqreadopen;
static wait_queue_head_t g_wqread;
static wait_queue_head_t g_wqwrite;
static int g_nreaders;
static int g_nwriters;

static DEFINE_SEMAPHORE(g_sem);

static int __init pipe_driver_init(void)
{
    int result;

    printk(KERN_INFO "pipe-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        return result;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    init_waitqueue_head(&g_wqreadopen);
    init_waitqueue_head(&g_wqwriteopen);
    init_waitqueue_head(&g_wqread);
    init_waitqueue_head(&g_wqwrite);

    return 0;
}

static void __exit pipe_driver_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "pipe-driver exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY) {
        ++g_nreaders;
        wake_up_interruptible(&g_wqwriteopen);
        while (g_nwriters == 0) {
            up(&g_sem);
            if (filp->f_flags & O_NONBLOCK)
                return 0;
            if (wait_event_interruptible(g_wqreadopen, g_nwriters > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_WRONLY) {
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        while (g_nreaders == 0) {
            if (filp->f_flags & O_NONBLOCK) {
                --g_nwriters;
                up(&g_sem);
                return -ENXIO;
            }
            up(&g_sem);
            if (wait_event_interruptible(g_wqwriteopen, g_nreaders > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_RDWR) {
        ++g_nreaders;
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        wake_up_interruptible(&g_wqwriteopen);
    }
    up(&g_sem);

    return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY)
        --g_nreaders;
    else if (accmode == O_WRONLY)
        --g_nwriters;
    else if (accmode == O_RDWR) {
        --g_nreaders;
        --g_nwriters;
    }
    if (g_nreaders == 0)
        wake_up_interruptible(&g_wqwrite);
    if (g_nwriters == 0)
        wake_up_interruptible(&g_wqread);

    if (g_nreaders + g_nwriters == 0) 
		g_count = g_head = g_tail = 0;

    up(&g_sem);

    return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (g_count == 0) {
        if (g_nwriters == 0) {
            result = 0;
            goto EXIT;
        }
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_wqread, g_count > 0 || g_nwriters == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, g_count);
    if (g_head >= g_tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_head);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_to_user(buf, g_pipebuf + g_head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipebuf, size2) != 0)
            goto EXIT;

    g_head = (g_head + esize) % PIPE_BUFFER_SIZE;
    g_count -= esize;

    result = esize;

    wake_up_interruptible(&g_wqwrite);
EXIT:
    up(&g_sem);

    return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (size > PIPE_BUFFER_SIZE)
        size = PIPE_BUFFER_SIZE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (g_nreaders == 0) {
        up(&g_sem);
        send_sig(SIGPIPE, current, 0);
        return -EPIPE;
    }
    while (PIPE_BUFFER_SIZE - g_count < size) {
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_count >= size || g_nreaders == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
        if (g_nreaders == 0) {
            up(&g_sem);
            send_sig(SIGPIPE, current, 0);
            return -EPIPE;
        }
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_count);

    if (g_tail >= g_head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_tail);
    else
        size1 = esize;

    size2 = esize - size1;

    if (copy_from_user(g_pipebuf + g_tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipebuf, buf + size1, size2) != 0)
            goto EXIT;

    g_tail = (g_tail + esize ) % PIPE_BUFFER_SIZE;
    g_count += esize;
    result = esize;

EXIT:
    wake_up_interruptible(&g_wqread);
    up(&g_sem);

    return result;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY|O_NONBLOCK)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");

        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1) {
            if (errno != EAGAIN)
                exit_sys("read");
            printf("pipe is empty, let's do something else...\n");
            continue;
        }
        if (result == 0) {
            putchar('\n');
            break;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                144. Ders 31/05/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdek modülleri ve aygıt sürücüler dinamik bellek tahsis etmeye gereksinim duyabilirler. Ancak çekirdek modunda çalışan 
    programlar dinamik tahsisatları malloc, calloc ve realloc gibi standart C fonksiyonlarıyla yapamazlar. Çünkü bu fonksiyonlar 
    kullanıcı modundaki programlar tarafından kullanılacak biçimde prosesin bellek alanında tahsisat yapmak için tasarlanmışlardır. 
    Oysa çekirdeğin ayrı bir heap sistemi vardır. Bu nedenle çekirdek modülleri ve aygıt sürücüler çekirdeğin sunduğu fonksiyonlarla 
    çekirdeğin heap alanında tahsisat yapabilirler. Biz de bu bölümde çekirdeğin heap sistemi üzerinde tahsisatların nasıl 
    yapıldığı üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi Linux sistemlerinde proseslerin bellek alanları sayfa tabloları yoluyla izole edilmiştir. Ancak çekirdek 
    tüm proseslerin sayfa tablosunda aynı yerde bulunmaktadır. Başka bir deyişle her prosesin sayfa tablosunda çekirdek hep 
    aynı sanal adreslerde bulunmaktadır. Örneğin sys_open sistem fonksiyonuna girildiğinde bu fonksiyonun sanal adresi her 
    proseste aynıdır.

    32 bit Linux sistemlerinde proseslerin sanal bellek alanları 3 GB kullanıcı (user), 1 GB çekirdek (kernel) olmak üzere 
    iki bölüme ayrılmıştır. 64 bit Linux sistemlerinde ise yalnızca sanal bellek alanının 256 TB'si kullanılmaktadır. Bu 
    sistemlerde kullanıcı alanı için 128 TB, çekirdek alanı için de 128 TB yer ayrılmıştır. 32 bit Linux sistemlerindeki 
    prosesin sanal bellek alanı şöyle gösterilebilir:

    00000000
    ...            USER ALANI (3 GB)
    C0000000
    ...            KERNEL ALANI (1 GB)

    64 bit Linux sistemlerindeki sanal bellek alanı ise kabaca şöyledir:

    0000000000000000
    ...                        USER ALANI (128 TB)
    0000800000000000
    ...                        BOŞ BÖLGE (yaklaşık 16M TB)
    FFFF800000000000
    ..                         KERNEL ALANI (128 TB)
    FFFFFFFFFFFFFFFF
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir sistem fonksiyonunun çağrıldığını düşünelim. İşlemci kernel mode'a otomatik olarak geçirilecektir. Bu durumda sayfa 
    tablosu değişmeyecektir. Pekiyi kernel nasıl tüm fiziksel belleğe erişebilmektedir? İşte 32 bitlik sistemlerde proseslerin 
    sayfa tablolarının son 1 GB'yi sayfalandırdığı girişleri tamamen fiziksel belleği eşlemektedir. Başka bir deyişle bu sistemlerde 
    çekirdek alanının başlangıcı olan C0000000 adresi aslında sayfa tablosunda 00000000 fiziksel adresini belirtmektedir. Böylece 
    kernel'ın herhangi bir fiziksel adrese erişmek için yapacağı tek şey bu adrese C00000000 değerini toplamaktır. Bu sistemlerde 
    C0000000 adresinden itibaren proseslerin sayfa tabloları zaten fiziksel belleği 0'dan itibaren haritalandırmaktadır. Ancak 
    32 bit sistemlerde şöyle bir sorun vardır: Sayfa tablosunda C0000000'dan itibaren sayfalar fiziksel belleği haritalandırdığına
    göre 32 bit sistemlerin maksimum sahip olacağı 4 GB fiziksel RAM'in hepsi haritalandırılamamaktadır. İşte Linux tasarımcıları 
    sayfa tablolarında C0000000'dan itibaren fiziksel RAM'in 1 GB'sini değil 896 MB'sini haritalandırmıştır. Geri kalan 128 MB'lik 
    sayfa tablosu alanı fiziksel RAM'de 896MB'nin ötesine erişmek için değiştirilerek kullanılmaktadır. Yani 32 bit sistemlerde 
    kernel fiziksel RAM'in ilk 896 MB'sine doğrudan ancak bunun ötesine sayfa tablosunun son 128 MB'lik bölgesini değiştirerek 
    erişmektedir. 32 bit sistemlerde 896 MB'nin ötesine dolaylı biçimde erişildiği için bu bölgeye "high memory zone" denilmektedir. 
    Tabii 64 bit sistemlerde böyle bir problem yoktur. Çünkü bu sistemlerde yine sayfa tablolarının kernel alanı fiziksel RAM'i 
    başından itibaren haritalandırmaktadır. Ancak 128 TB'lik alan zaten şimdiki bilgisayarlara takılabilecek fiziksel RAM'in 
    çok ötesindedir. Bu nedenle 64 bit sistemlerde "high memory zone" kavramı yoktur.

    Çekirdek kodların kernel alanın başlangıcı PAGE_OFFSET makrosuyla belirlenmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz çekirdek modunda kod yazarken belli bir fiziksel adrese erişmek istersek onun sanal adresini bulmamız gerekir. Bu işin 
    manuel yapılması yerine bunun için __va isimli makro kullanılmaktadır. Biz bu makroya bir fiziksel adres veririz o da bize 
    o fiziksel adrese erişmek için gereken sanal adresi verir. Benzer biçimde bir sanal adresin fiziksel RAM karşılığını bulmak 
    için de __pa makrosu kullanılmaktadır. Biz bu makroya sanal adresi veririz o da bize o sanal adresin aslında RAM'deki hangi 
    fiziksel adres olduğunu verir. __va makrosu parametre olarak unsigned long biçiminde fiziksel adresi alır, o fiziksel adrese 
    erişmek için gerekli olan sanal adresi void * türünden bize verir. __pa makrosu bunun tam tersini yapmaktadır. Bu makro bizden 
    unsigned long biçiminde sanal adresi alır. O sanal adrese sayfa tablosunda karşı gelen fiziksel adresi bize verir.

    Çekirdek modunda RAM'in her yerine erişebildiğimize ve bu konuda bizi engelleyen hiçbir mekanizmanın olmadığına dikkat 
    ediniz. Dolayısıyla bir aygıt sürücüler içerisinde RAM'in istediğimiz kısmına erişip oratayı değiştirebiliriz. Ancak bu 
    durum kontrolsüz ve amaçsız bir biçimde yapılırsa bu olumsuzluktan tün sistem etkilenebilecektir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux çekirdeği için fiziksel RAM temel olarak 3 bölgeye (zone'a) ayrılmıştır:

    ZONE_DMA
    ZONE_NORMAL
    ZONE_HIGHMEM

    ZONE_DMA ilgili sistemde disk ile RAM arasında transfer yapan DMA'nın erişebildiği RAM alanıdır. Bazı sistemlerde DMA tüm 
    fiziksel RAM'in her yerine transfer yapamamaktadır. ZONE_NORMAL doğrudan çekirdeğin sayfa tablosu yoluyla haritalandırdığı 
    fiziksel bellek bölgesidir. 32 bit Linux sistemlerinde bu bölge RAM'in ilk 896 MB'sidir. Ancak 64 bit Linux sistemlerinde 
    bu bölge tüm fiziksel RAM'i içermektedir. ZONE_HIGHMEM ise 32 bit sistemlerde çekirdeğin doğrudan haritalandıramadığı 
    sayfa tablosunda değişiklik yapılarak erişilebilen fiziksel RAM alanıdır. 32 bit Linux sistemlerinde 896 MB'nin yukarısındaki 
    fiziksel RAM bölhesi ZONE_HIGHMEM alanıdır. Yukarıda da belirttiğimiz gibi 64 bit Intel işlemcilerinde ZONE_HIGHMEM biçiminde 
    bir alan zaten yoktur.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kullanıcı modundaki programlarda kullandığımız malloc fonksiyonununda en fazla uygulanan tahsisat yöntemi "boş bağlı liste" 
    denilen yöntemdir. Bu yöntemde yalnızca boş alanlar bir bağlı listede tutulmaktadır. Dolayısıyla malloc gibi bir fonksiyon 
    bu bağlı listede uygun bir elemanı bağlı listeyi dolaşarak bulmaktadır. free fonksiyonu da tahsis edilmiş olan alanı bu boş 
    bağlı listeye eklemektedir. Tabii free fonksiyonu aynı zamanda bağlı listedeki komşu alanları da daha büyük bir boş alan 
    oluşturacak biçimde birleştirmektedir. Ancak bu klasik yöntem çekirdek heap sistemi için çok yavaş bir yöntemdir. Bu nedenle 
    çekirdek heap sistemlerinde daha hızlı çalışan tahsisat algoritmaları kullanılmaktadır.

    Eğer tahsis edilecek bloklar eşit uzunlukta olursa bu durumda tahsisat işlemi ve geri bırakma işlemi O(1) karmaşıklıkta 
    yapılabilir. Örneğin heap içerisindeki tüm blokların 16 byte uzunlukta olduğunu düşünelim. Bu durumda 16 byte'lık tahsisat 
    sırasında uygun bir boş alan aramaya gerek kalmaz. Bir bağlı liste içerisinde boş alanlar tutulabilir. Bu boş alanlardan 
    herhangi biri verilebilir. Tabii uygulamalarda tahsis edilecek alanların büyükleri farklı olmaktadır.

    İşte BSD ve Linux sistemlerinde kullanılan "dilimli tahsisat sistemi (slab allocator)" denilen tahsisat sisteminin anahtar 
    noktası eşit uzunlukta olan ve ismine "dilim (slab)" denilen blokların tahsis edilmesidir. Çekirdek içerisinde çeşitli 
    nesneler için o nesnelerin uzunluğuna ilişkin farklı dilimli tahsisat sistemleri oluşturulmuştur. Örneğin bir proses 
    yaratıldığında task_struct yapısı çekirdeğin heap alanında tahsis edilmektedir. İşte dilimli tahsisat sistemlerinden biri 
    (struct task_struct yapısının uzunluğu kadar dilim uzunluklarından oluşan sistemdir. Böylece pek çok çekirdek nesnesi 
    için ayrı dilimli tahsisat sistemleri oluşturulmuştur. Bu durumu özet olarak şöyle düşünebilirsiniz: Çekirdek sanki kendi 
    içerisindeki her veri yapısı için eşit uzunluklarda bloklardan oluşan farklı heap alanı kullanıyor gibidir. 

    Çekirdek içerisindeki veri yapıları için oluşturulmuş olan dilimli tahsisat sistemlerinin dışında ayrıca bir de genel 
    kullanım için blok uzunlukları 32, 64, 96, 128, 192, 256 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, ... biçiminde 
    olan farklı dilimli tahsisat sistemleri de bulundurulmuştur. Böylece çekirdek mod programcısı belli uzunlukta bir alan 
    tahsis etmek istediğinde bu uzunluğa en yakın fakat bu uzunluktan büyük bir dilimli tahsisat sistemini kullanır. Tabii 
    çekirdek modunda çalışam programcılar isterse kendi nesneleri için de o nesnelerin uzunluğu kadar yeni dilimli tahsisat 
    sistemleri de oluşturabilmektedir.

    Burada aklınıza "mademki dilimli tahsisat sistemi çok hızlı bir sistem" o halde neden kullanıcı modundaki malloc gibi 
    fonksiyonlar da aynı mantıkla çalışmıyor" sorusu aklınıza gelebilir. Bunun iki nedeni vardır:

    1) Bu sistem hızlı olmasına karşın bellek harcaması daha yüksektir. Örneğin bu sistemde 600 byte'lık bir tahsisat yapmak 
    istesek bunu 1024'lük dilimlerin bulunduğu sistemden yaparız. Bu da kullanılmayan boş alanlar oluşturur. 

    2) Eğer programcı kendi dilim sistemini oluşturcak olsa bunun da arayüz olarak kullanımı zor olmaktadır. 

    O halde bu dilimli tahsisat sistemi çekirdek için uygun ama kullanıcı modu için pek uygun bir sistem değildir. 

    Aslında dilimli tahsisat sisteminin hazırda bulundurduğu dilimler işletim sisteminin sayfa tahsisatı yapan başka bir tahsisat
    algoritmasından elde edilmektedir. Linux sistemlerinde sayfa temelinde tahsisat yapmak için kullanılan tahsisat sistemine
    "buddy allocator" denilmektedir. (CSD işletim sisteminde buna "ikiz blok sistemi" denilmektedir.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdek modunda çekirdek alanında dinamik tahsisat yapmak için kullanılan en genel fonksiyon kmalloc isimli fonksiyondur. 
    Bu fonksiyon aslında parametresiyle belirtilen uzunluğa en yakın önceden yaratılmış olan dilimli tahsisat sisteminden dilim 
    vermektedir (yani blok tahsis etmektedir). Örneğin biz kmalloc fonksiyonu ile 100 byte tahsis etmek istesek 100 byte'lık 
    blokların bulunduğu önceden yaratılmış bir dilimli tahsisat sistemi olmadığı için kmalloc 128 byte'lık bloklara sahip dilimli 
    tahsisat sisteminden bir dilim tahsis ederek bize verecektir. Tabii bu örnekte 28 byte boşuna tahsis edilmiş olacaktır. Ancak 
    çekirdek tahsisat sisteminin amacı en uygun miktarda belleği tahsis etmek değil, talep edilen miktarda belleği daha hızlı 
    tahsis etmektir. kmalloc fonksiyonu ile tahsis edilen dilimler kfree fonksiyonu ile serbest bırakılmaktadır. Fonksiyonların 
    prototipleri şöyledir:

    #include <linux/slab.h>

    void *kmalloc (size_t size, int flags);
    void kfree (const void *objp);

    kmalloc fonksiyonunun birinci parametresi tahsis edilecek byte miktarını belirtir. İkincisi parametresi ise tahsis edilecek 
    zone ve tahsisat biçimi hakkında çeşitli bayrakları içermektedir. Bu ikinci parametre çeşitli sembolik sabitlerden oluşturulmaktadır. 
    Burada önemli birkaç bayrak şunlardır:

    GFP_KERNEL: Çekirdek alanı içerisinde normal tahsisat yapmak için kullanılır. Bu bayrak en sık bu kullanılan bayraktır. Burada 
    eğer RAM doluysa işletim sistemi prosesi bloke ederek swap işlemi ile yer açabilmektedir. Yani bu işlem sırasında akış çekirdek 
    modunda bloke olarak thread bekleme kuyruklarında bekletilebilir. Tahsisat işlemi ZONE_NORMAL alanından yapılmaktadır.

    GFP_NOWAIT: GFP_KERNEL gibidir. Ancak hazırda bellek yoksa thread uykuya dalmaz. Fonksiyon başarısız olur.

    GFP_HIGHUSER: 32 bit sistemlerde ZONE_HIGHMEM alanından tahsisat yapar.

    GFP_DMA: İlgili sistemde DMA'nın erişebildiği fiziksel RAM alanından tahsisat yapar.

    kmalloc fonksiyonu başarı durumunda tahsis edilen alanın sanal bellek adresiyle, başarısızlık durumunda NULL adresle geri
    dönmektedir. Çekirdek modülleri ve aygıt sürücüler dinamik tahsisat başarısız olursa tipik olarak -ENOMEM değerine geri 
    dönmelidir.

    kfree fonksiyonu ise daha önce kmalloc ile tahsis edilmiş olan alanın başlangıç adresini parametre olarak almaktadır.

    Aşağıda daha önce yapmış olduğumuz boru aygıt sürücüsündeki kuyruk sistemini kmalloc fonksiyonu ile tahsis edilip kfree
    fonksiyonu ile serbest bırakılmasına örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>
#include <linux/slab.h>

#define PIPE_BUFFER_SIZE       10
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = pipe_driver_open,
    .read = pipe_driver_read,
    .write = pipe_driver_write,
    .release = pipe_driver_release
};

struct PIPE {
    unsigned char buf[PIPE_BUFFER_SIZE];
    size_t head;
    size_t tail;
    size_t count;
};

static wait_queue_head_t g_wqwriteopen;
static wait_queue_head_t g_wqreadopen;
static wait_queue_head_t g_wqread;
static wait_queue_head_t g_wqwrite;
static int g_nreaders;
static int g_nwriters;
static DEFINE_SEMAPHORE(g_sem);
static struct PIPE *g_pipe;

static int __init pipe_driver_init(void)
{
    int result;

    printk(KERN_INFO "pipe-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        goto EXIT1;
    }

    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        printk(KERN_ERR "cannot add device!...\n");
        goto EXIT2;
    }

    if ((g_pipe = kmalloc(sizeof(struct PIPE), GFP_KERNEL)) == NULL) {
        printk(KERN_ERR "cannot allocate memory!...\n");
        result = -ENOMEM;
        goto EXIT3;
    }

    init_waitqueue_head(&g_wqreadopen);
    init_waitqueue_head(&g_wqwriteopen);
    init_waitqueue_head(&g_wqread);
    init_waitqueue_head(&g_wqwrite);

    return 0;

EXIT3:
    cdev_del(&g_cdev);
EXIT2:
    unregister_chrdev_region(g_dev, 1);
EXIT1:
    return result;
}

static void __exit pipe_driver_exit(void)
{
    kfree(g_pipe);
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "pipe-driver exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY) {
        ++g_nreaders;
        wake_up_interruptible(&g_wqwriteopen);
        while (g_nwriters == 0) {
            up(&g_sem);
            if (filp->f_flags & O_NONBLOCK) 
                return 0;
            if (wait_event_interruptible(g_wqreadopen, g_nwriters > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_WRONLY) {    
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        while (g_nreaders == 0) {
            if (filp->f_flags & O_NONBLOCK) {
                --g_nwriters;
                up(&g_sem);
                return -ENXIO;
            }
            up(&g_sem);
            if (wait_event_interruptible(g_wqwriteopen, g_nreaders > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_RDWR) {
        ++g_nreaders;
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        wake_up_interruptible(&g_wqwriteopen);
    }
    up(&g_sem);

    return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;
    
    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY) 
        --g_nreaders;
    else if (accmode == O_WRONLY) 
        --g_nwriters;
    else if (accmode == O_RDWR) {
        --g_nreaders;
        --g_nwriters;    
    }
    if (g_nreaders == 0)
        wake_up_interruptible(&g_wqwrite);
    if (g_nwriters == 0)
        wake_up_interruptible(&g_wqread);

    if (g_nreaders + g_nwriters == 0) 
		g_pipe->count = g_pipe->head = g_pipe->tail = 0;

    up(&g_sem);

    return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;
    
    while (g_pipe->count == 0) {
        if (g_nwriters == 0) {
            result = 0;
            goto EXIT;
        }
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK) 
            return -EAGAIN;
        if (wait_event_interruptible(g_wqread, g_pipe->count > 0 || g_nwriters == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, g_pipe->count);
    if (g_pipe->head >= g_pipe->tail) 
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_pipe->head);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_to_user(buf, g_pipe->buf + g_pipe->head, size1) != 0) 
        goto EXIT;
    
    if (size2 != 0) 
        if (copy_to_user(buf + size1, g_pipe->buf, size2) != 0) 
            goto EXIT;

    g_pipe->head = (g_pipe->head + esize) % PIPE_BUFFER_SIZE;
    g_pipe->count -= esize;

    result = esize;

    wake_up_interruptible(&g_wqwrite);
EXIT:
    up(&g_sem);

    return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;
    
    if (size > PIPE_BUFFER_SIZE)
        size = PIPE_BUFFER_SIZE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (g_nreaders == 0) {
        up(&g_sem);
        send_sig(SIGPIPE, current, 0);
        return -EPIPE;
    }
    while (PIPE_BUFFER_SIZE - g_pipe->count < size) {
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_pipe->count >= size || g_nreaders == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
        if (g_nreaders == 0) {
            up(&g_sem);
            send_sig(SIGPIPE, current, 0);
            return -EPIPE;
        }
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_pipe->count);

    if (g_pipe->tail >= g_pipe->head) 
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_pipe->tail);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_from_user(g_pipe->buf + g_pipe->tail, buf, size1) != 0) 
        goto EXIT;
    if (size2 != 0) 
        if (copy_from_user(g_pipe->buf, buf + size1, size2) != 0) 
            goto EXIT;

    g_pipe->tail = (g_pipe->tail + esize ) % PIPE_BUFFER_SIZE;
    g_pipe->count += esize;
    result = esize;

EXIT:
    wake_up_interruptible(&g_wqread);
    up(&g_sem);

    return results;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY|O_NONBLOCK)) == -1)
        exit_sys("open");
    
    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        
        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY|O_NONBLOCK)) == -1)
        exit_sys("open");
    
    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1) {
            if (errno != EAGAIN)
                exit_sys("read");
            printf("pipe is empty, let's do something else...\n");
            continue;
        }
        if (result == 0) {
            putchar('\n');
            break;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                145. Ders 02/06/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi istersek genel amaçlı kmalloc fonksiyonunu kullanmak yerine kendimiz de tam istediğimiz 
    büyüklükte dilimlere sahip olan yeni bir dilimli tahsisat sistemi yaratıp onu kullanabiliriz. Yeni bir dilimli tahsisat 
    sisteminin yaratılması kmem_cache_create fonksiyonu ile yapılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <linux/slab.h>

    struct kmem_cache *kmem_cache_create(const char *name, unsigned int size, 
            unsigned int align, slab_flags_t flags, void (*ctor)(void *));

    Fonksiyonun birinci parametresi yeni yaratılacak dilimli tahsisat sisteminin ismini belirtmektedir. (Bu isim sys dosya 
    sisteminde bir dizin biçimine görüntülenebilmektedir.) Burada dilimli tahsisat sistemine herhangi bir isim verilebilir. 
    Linux çekirdeğinde dilimli tahsisat sistemleri genellikle "xxx_cachep" biçiminde isimlendirilmektedir. İkinci parametre 
    dilimlerin büyüklüğünü belirtmektedir. Üçüncü parametre ise hizalama değerini belirtir. Bu hizalama değerine 0 geçilirse 
    default hizalama kullanılır. Varsayılan hizalama 32 bit sistemlerde 4 byte, 64 bit sistemlerde 8 byte'tır. Fonksiyonun 
    dördüncü parametresi yaratılacak dilimli tahsisat sistemine ilişkin bazı özelliklerin belirlenmesi için kullanılmaktadır. 
    Buradaki bayrakların önemli birkaç tanesi şöyledir:

    SLAB_NO_REAP: Fiziksel RAM'in dolması nedeniyle kullanılmayan dilimlerin otomatik olarak sisteme iade edileceği anlamına 
    gelir. Uç durumlarda bu bayrak kullanılabilir.

    SLAB_HWCACHE_ALIGN: Bu bayrak özellikle SMP sistemlerinde işlemci ya da çekirdeklerin cache alanları için hizalama yapılmasını
    sağlamaktadır. Yaratım sırasında bu parametreyi kullanabilirsiniz.

    SLAB_CACHE_DMA: Bu parametre DMA alanında (DMA zone) tahsisat için kullanılmaktadır. Daha önceden de belirttiğimiz gibi bazı 
    sistemlerde fiziksel RAM'ın ancak bazı bölglerine DMA tarafından erişilebilmektedir. 

    Fonksiyonun son parametresi dilim sistemi yaratıldığında çağrılacak callback fonksiyonu belirtmektedir. Bu parametre için 
    girilecek fonksiyon her yeni dilim tahsis edildiğinde çağrılmaktadır. Böylece yeni bir dilim tahsis edileceği zaman bu 
    fonksiyon içerisinde o dilime ilkdeğer verilebilir. Bu fonksiyona tahsis edilen dilimin başlangıç adresi geçirilmektedir. 
    Bu parametre NULL da geçilebilir. Bu durumda dilim tahsis edilirken herhangi bir fonksiyon çağrılmaz. kmem_cache_create 
    fonksiyonu başarı durumunda struct kmem_cache türünden bir yapı nesnesinin adresiyle, başarısızlık durumunda NULL adrese 
    geri dönmektedir. Başarısızlık durumunda aygıt sürücü fonksiyonunun -ENOMEM değeri ile geri döndürülmesi uygundur. Fonksiyon 
    şöyle kullanılabilir:

    struct kmem_cache *g_pipe_cachep;

    if ((g_pipe_cachep = kmem_cache_create("pipe_driver_cachep", 
            sizeof(struct PIPE), 0, SLAB_HWCACHE_ALIGN, NULL)) == NULL) {
        ...
        return -ENOMEM;
    }

    Yaratılmış olan bir dilim sisteminden tahsisatlar kmem_cache_alloc fonksiyonu ile yapılmaktadır. Fonksiyonun prototipi 
    şöyledir: 
    
    #include <linux/slab.h>

    void *kmem_cache_alloc(struct kmem_cache *cache, int flags);

    Fonksiyonun birinci parametresi yaratılmış olan dilim sisteminin handle değerini, ikinci parametresi ise yaratım bayraklarını 
    almaktadır. Bu bayraklar kmalloc fonksiyonundaki bayraklarla aynıdır. Yani örneğin bu parametreye GFP_KERNEL geçilebilir. 
    Fonksiyon başarı durumunda tahsis edilen dilimin sanal adresine, başarısızlık durumunda NULL adrese geri dönmektedir. 
    Başarısızlık durumunda aygıt sürücüdeki fonksiyonun -ENOMEM değeri ile geri döndürülmesi uygundur. Örneğin:

    if ((g_pipe = (struct PIPE *)kmem_cache_alloc(g_pipe_cachep, GFP_KERNEL)) == NULL) {
        ...
        return -ENOMEM;
    }

    kmem_cache_alloc fonksiyonu ile tahsis edilen dinamik alan kmem_cache_free fonksiyonu ile serbest bırakılabilir. Fonksiyonun
    prototipi şöyledir:

    #include <linux/slab.h>

    void kmem_cache_free(struct kmem_cache *cache, const void *obj);

    Fonksiyonun birinci parametresi dilim sisteminin handle değerini, ikincisi parametresi ise serbest bırakılacak dilimin 
    adresini belirtmektedir. Örneğin:

    kmem_cache_free(g_pipe_cachep, g_pipe);

    kmem_cache_create fonksiyonu ile yaratılmış olan dilim sistemi kmem_cache_destroy fonksiyonu ile serbest bırakılabilir. 
    Fonksiyonun prototipi şöyledir.

    #include <linux/slab.h>

    int kmem_cache_destroy(struct kmem_cache *cache);

    Fonksiyon dilim sisteminin handle değerini parametre olarak alır. Başarı durumunda 0 değerine, başarısızlık durumunda 
    negatif errno değerine geri döner. Örneğin:

    kmem_cache_destroy(g_pipe);

    Pekiyi kmalloc yerine yeni bir dilimli tahsisat sisteminin yaratılması tercih edilmeli midir? Yukarıda da belirttiğimiz
    gibi kmalloc fonksiyonu da aslında önceden yaratılmış belli uzunluktaki dilim sistemlerinden tahsisat yapmaktadır. Ancak 
    "çok sayıda aynı büyüklükte alanların" tahsis edildiği durumlarda programcının belli uzunlukta olan kendi dilim sistemini 
    yaratması, bunun  dışındaki durumlarda genel amaçlı kmalloc fonksiyonunu tavsiye edilmektedir. 

    Tabii kmalloc yerine yeni bir dilimli tahsisat sistemi yaratmanın anlamlı olması için çok sayıda aynı büyüklükte tahsisatın
    yapılıyor olması gerekir. Tek bir tahisat için ya da birkaç tahsisat için yeni bir dilimli tahsisat sistemi yaratmaya hiç 
    gerek yoktur. Doğrudan kmalloc fonksiyonu kullanılabilir. 
    
    Örneğin boru aygıt sürücümüzde yeni bir dilim sisteminin yaratılmasına hiç gerek yoktur. Çünkü zaten boru aygıt sürücüsünde 
    tek bir struct PIPE yapı nesnesi yaratılmaktadır. Ancak biz aşağıdaki bu dilimli tahsisat sistemlerinin nasıl kullanıldığına 
    bir örnek vermek için bu struct PIPE nesnesini kendi yarattığımız dilimli tahsisat sisteminden tahsis ediyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>
#include <linux/slab.h>

#define PIPE_BUFFER_SIZE       1024
#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = pipe_driver_open,
    .read = pipe_driver_read,
    .write = pipe_driver_write,
    .release = pipe_driver_release
};

struct PIPE {
    unsigned char buf[PIPE_BUFFER_SIZE];
    size_t head;
    size_t tail;
    size_t count;
};

static wait_queue_head_t g_wqwriteopen;
static wait_queue_head_t g_wqreadopen;
static wait_queue_head_t g_wqread;
static wait_queue_head_t g_wqwrite;
static int g_nreaders;
static int g_nwriters;
static DEFINE_SEMAPHORE(g_sem);
static struct kmem_cache *g_pipe_cachep;
static struct PIPE *g_pipe;

static int __init pipe_driver_init(void)
{
    int result;

    printk(KERN_INFO "pipe-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        goto EXIT1;
    }
    cdev_init(&g_cdev, &g_fops);
    if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
        printk(KERN_ERR "cannot add device!...\n");
        goto EXIT2;
    }
    if ((g_pipe_cachep = kmem_cache_create("pipe_cachep", sizeof(struct PIPE), 0, SLAB_HWCACHE_ALIGN, NULL)) == NULL) {
        printk(KERN_ERR "cannot create pipe cache!...\n");
        result = -ENOMEM;
        goto EXIT3;
    }
    if ((g_pipe = (struct PIPE *)kmem_cache_alloc(g_pipe_cachep, GFP_KERNEL)) == NULL) {
        printk(KERN_ERR "cannot allocate slab from pipe cache!...\n");
        result = -ENOMEM;
        goto EXIT4;
    }
    g_pipe->head = g_pipe->tail = g_pipe->count = 0;

    init_waitqueue_head(&g_wqreadopen);
    init_waitqueue_head(&g_wqwriteopen);
    init_waitqueue_head(&g_wqread);
    init_waitqueue_head(&g_wqwrite);

    return 0;
EXIT4:
    kmem_cache_destroy(g_pipe_cachep);
EXIT3:
    cdev_del(&g_cdev);
EXIT2:
    unregister_chrdev_region(g_dev, 1);
EXIT1:
    return result;
}

static void __exit pipe_driver_exit(void)
{
    kmem_cache_free(g_pipe_cachep, g_pipe);
    kmem_cache_destroy(g_pipe_cachep);
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "pipe-driver exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY) {
        ++g_nreaders;
        wake_up_interruptible(&g_wqwriteopen);
        while (g_nwriters == 0) {
            up(&g_sem);
            if (filp->f_flags & O_NONBLOCK)
                return 0;
            if (wait_event_interruptible(g_wqreadopen, g_nwriters > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_WRONLY) {
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        while (g_nreaders == 0) {
            if (filp->f_flags & O_NONBLOCK) {
                --g_nwriters;
                up(&g_sem);
                return -ENXIO;
            }
            up(&g_sem);
            if (wait_event_interruptible(g_wqwriteopen, g_nreaders > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&g_sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_RDWR) {
        ++g_nreaders;
        ++g_nwriters;
        wake_up_interruptible(&g_wqreadopen);
        wake_up_interruptible(&g_wqwriteopen);
    }
    up(&g_sem);

    return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
    int accmode = filp->f_flags & O_ACCMODE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY)
        --g_nreaders;
    else if (accmode == O_WRONLY)
        --g_nwriters;
    else if (accmode == O_RDWR) {
        --g_nreaders;
        --g_nwriters;
    }
    if (g_nreaders == 0)
        wake_up_interruptible(&g_wqwrite);
    if (g_nwriters == 0)
        wake_up_interruptible(&g_wqread);

    if (g_nreaders + g_nwriters == 0) 
		g_pipe->count = g_pipe->head = g_pipe->tail = 0;

    up(&g_sem);

    return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    while (g_pipe->count == 0) {
        if (g_nwriters == 0) {
            result = 0;
            goto EXIT;
        }
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_wqread, g_pipe->count > 0 || g_nwriters == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, g_pipe->count);
    if (g_pipe->head >= g_pipe->tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_pipe->head);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_to_user(buf, g_pipe->buf + g_pipe->head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, g_pipe->buf, size2) != 0)
            goto EXIT;

    g_pipe->head = (g_pipe->head + esize) % PIPE_BUFFER_SIZE;
    g_pipe->count -= esize;

    result = esize;

    wake_up_interruptible(&g_wqwrite);
EXIT:
    up(&g_sem);

    return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;

    if (size > PIPE_BUFFER_SIZE)
        size = PIPE_BUFFER_SIZE;

    if (down_interruptible(&g_sem) != 0)
        return -ERESTARTSYS;

    if (g_nreaders == 0) {
        up(&g_sem);
        send_sig(SIGPIPE, current, 0);
        return -EPIPE;
    }
    while (PIPE_BUFFER_SIZE - g_pipe->count < size) {
        up(&g_sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_wqwrite, PIPE_BUFFER_SIZE - g_pipe->count >= size || g_nreaders == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem) != 0)
            return -ERESTARTSYS;
        if (g_nreaders == 0) {
            up(&g_sem);
            send_sig(SIGPIPE, current, 0);
            return -EPIPE;
        }
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - g_pipe->count);

    if (g_pipe->tail >= g_pipe->head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - g_pipe->tail);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_from_user(g_pipe->buf + g_pipe->tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(g_pipe->buf, buf + size1, size2) != 0)
            goto EXIT;

    g_pipe->tail = (g_pipe->tail + esize ) % PIPE_BUFFER_SIZE;
    g_pipe->count += esize;

    result = esize;

EXIT:
    wake_up_interruptible(&g_wqread);
    up(&g_sem);

    return esize;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1)
        exit_sys("open");
    
    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        
        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1)
        exit_sys("open");
    
    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1) {
            if (errno != EAGAIN)
                exit_sys("read");
            printf("pipe is empty, let's do something else...\n");
            continue;
        }
        if (result == 0) {
            putchar('\n');
            break;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz kmem_cache_create fonksiyonlarıyla yaratılmış olan dilimli tahsisat sistemlerini proc dosya sistemi ile görüntüleyebiliriz. 
    "/proc/slabinfo" dosyası çekirdek tarafından kullanılan yaratılmış dilimli tahsisat sistemleri hakkında bilgi vermektedir. 
    Ancak bu dosya bizim kmem_cache_create fonksiyonuyla yarattığımız dilimli tahsisat sistemlerini listelememektedir. sys 
    dosya sistemindeki "/sys/kernel/slab" dizini aygıt sürücülerin yaratmış oldukları da dahil olmak üzere bütün dilimli tahsisat 
    sistemleri hakkında bilgiler vermektedir. Burada her kmem_cache_create fonksiyonu ile yaratılmış olan dilimli tahsisat 
    sistemi için ayrı bir dizin bulunmaktadır. Ayrıca çekirdeğin kullandığı dilimli tahsisat sistemlerini canlı olarak görüntülemek 
    için "slabtop" isimli bir utility program da vardır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux'un dosya sistemi için önemli üç yapı vardır. Bunlar file, dentry ve inode yapılarıdır. file isimli yapıya biz "dosya 
    nesnesi" demiştik. Anımsanacağı gibi ne zaman bir dosya açılsa dosya betimleyici tablosunda dosya betimleyicisi denilen 
    bir indeks bu dosya nesnesini gösterir duruma getirilmektedir. Dosya betimleyici tablosuna (file descriptor table) prosesi 
    temsil eden task_struct yapısından erişilmektedir. 

    task_struct ------> dosya betimleyici tablosu

    Dosya Betimleyici Tablosu
    --------------------------

    0 ----> dosya nesnesi (struct file)
    1 ----> dosya nesnesi (struct file)
    2 ----> dosya nesnesi (struct file)
    3 ----> dosya nesnesi (struct file)
    ...

    Dosya nesnesi "açık dosyaların bilgilerini" tutmaktadır. Ne zaman sys_open sistem fonksiyonu çağrılsa sys_open sistem 
    fonksiyonu yeni bir dosya nesnesini (struct file) yaratır, onun adresini dosya betimleyici tablosunda boş bir slota yazar. 
    Bu slotun indeks numarasını dosya betimleyicisi olarak geri döndürür. Aynı dosya ikinci kez kaçılsa bile yeni bir dosya nesnesi 
    (struct file nesnesi) yaratılmaktadır. Daha önce biz bu struct file yapısının içeriğini görmüştük. Bunu yeniden anımsatmak 
    istiyoruz:
   
    struct file {
        union {
            /* fput() uses task work when closing and freeing file (default). */
            struct callback_head     f_task_work;
            /* fput() must use workqueue (most kernel threads). */
            struct llist_node    f_llist;
            unsigned int         f_iocb_flags;
        };

        /*
        * Protects f_ep, f_flags.
        * Must not be taken from IRQ context.
        */
        spinlock_t                f_lock;
        fmode_t                    f_mode;
        atomic_long_t            f_count;
        struct mutex            f_pos_lock;
        loff_t                    f_pos;
        unsigned int            f_flags;
        struct fown_struct        f_owner;
        const struct cred        *f_cred;
        struct file_ra_state    f_ra;
        struct path                f_path;
        struct inode            *f_inode;    /* cached value */
        const struct file_operations    *f_op;
        u64            f_version;
    #ifdef CONFIG_SECURITY
        void            *f_security;
    #endif
        /* needed for tty driver, and maybe others */
        void            *private_data;

    #ifdef CONFIG_EPOLL
        /* Used by fs/eventpoll.c to link all the hooks to this file */
        struct hlist_head    *f_ep;
    #endif /* #ifdef CONFIG_EPOLL */
        struct address_space    *f_mapping;
        errseq_t        f_wb_err;
        errseq_t        f_sb_err; /* for syncfs */
    } __randomize_layout
    __attribute__((aligned(4)));    /* lest something weird decides that 2 is OK */

    Eskiden dosya nesnesi dentry nesnesini, dentry nesnesi de inode nesnesini gösteriyordu. Yani durum şöyleydir:

    File  ──▶ dentry ──▶ inode

    Daha sonraları dosya nesnesinin içerisinden inode nesnesine daha hızlı erişebilmek için dosya nesnesinin içerisine (yani
    file yapısının içerisine) doğrudan bir inode göstericisi daha eklenmiştir. Mevcut durum şöyledir:

    File  ──▶ dentry ──▶ inode
  ╰──────────────────────▶

    inode yapısı dosyanın diskteki bilgilerini tutmaktadır. Yani örneğin aynı dosya üç kez açılsa çekirdek üç farklı file nesnesi 
    inode yapısı dosyanın diskteki bilgilerini tutmaktadır. Yani örneğin aynı dosya üç kez açılsa çekirdek üç farklı file nesnesi 
    oluşturmaktadır. Ancak bu dosya diskte bir tane olduğuna göre çekirdek bunun için toplamda bir tane inode yapısı oluşturacaktır.
    Mevcut çekirdeklerde file yapısının içerisinde dosyanın diskteki bilgilerine ilişkin bu inode yapısına f_inode elemanı yoluyla 
    erişilebilmektedir. Linux işletim sistemi aynı zamanda diskte son erişilen dosyalara ilişkin i-node elemanlarını inode yapısı 
    biçiminde bir cache sisteminde de tutmaktadır. Buna "inode cache" denilmektedir. Örneğin biz "test.txt" isimli bir dosyayı 
    sys_open sistem fonksiyonuyla açmış olalım. İşletim sistemi bunun için bir dosya nesnesi oluşturacak ve bu dosyaya ilişkin 
    inode nesnesi zaten inode cache içerisinde varsa onu cache'ten alıp kullanacaktır. Eğer bu dosyaya ilişkin inode nesnesi 
    "inode cache" içerisinde yoksa işletim sistemi dosyaya ilişkin inode bilgilerini diskten bulup inode nesnesini oluşturacak
    ve "inode cache" içerisine yerleştirecektir. Bu dosya kapatıldığında da işletim sistemi inode yapısını çekirdek alanından 
    atmaz bu inode nesnesi "inode cache" içerisinde kalmaya devam eder. Tabii bu "inode cache" içerisinde belli sayıda inode 
    elemanı tutulmaktadır. Bu cache sistemi dolduğunda LRU (Least Recently Used) algoritmasına göre son zamanlarda en az kullanılan 
    inode elemanı cache'ten atılmaktadır.

    Linux çekirdeğinde dosyanın i-node elemanına erişmekte kullanılan dizin girişleri dentry isimli bir yapıyla temsil edilmiştir. 
    inode yapısı dosyanın diskteki bilgilerini tutarken dentry yapısı dosyanın dizin girişi bilgilerini tutmaktadır. Yukarıda 
    da belirttiğimiz gibi dentry nesnesinin içerisinde inode nesnesinin adresi tutulmaktadır. Örneğin farklı dentry nesneleri 
    aynı inode nesnesini gösteriyor olabilir. Bu tür durumlar "hard link" yoluyla oluşturulmaktadır. Açılmış dosyanın hangi 
    dizinlerin içerisinde bulunduğu bilgisi dentry nesnelerinde tutulmaktadır. Linux işletim sistemi nasıl inode nesnelerini 
    bir cache sisteminde tutuyorsa dentry nesnelerini de ismine "dentry cache" denilen bir cache sistemi içerisinde tutmaktadır. 
    Bir dosyanın open fonksiyonuyla (bu POSIX fonksiyonu doğrudan sys_open sistem fonksiyonunu çağırmaktadır) açıldığını varsayalım. 
    Dosyaya ilişkin dizin girişi bilgilerinin elde edilmesi için ismine "pathname resolution" denilen bir işlem yapılmaktadır. 
    Örneğin biz "/home/kaan/Study/test.txt" dosyasını açmak isteyelim. İşletim sistemi bunun için önce "/home" dizin girişini 
    sonra home  dizininde "kaan" dizin girişini, sonra  "kaan" dizininde "Study" dizin girişini sonra da "Study" dizininde "test.txt" 
    dizin girişini bulacaktır. İşte tüm bu dizin girişleri aynı zamanda "dentry cache" içerisinde de saklanmaktadır. Böylece bu 
    dosyaya bir daha erişilmek istendiğinde doğrudan bu dizin girişi bilgileri "dentry cache" içerisinden elde edilebilmektedir. 
    Linux işletim sistemi her zaman eğer bir dosyanın dentry nesnesi çekirdek içerisindeyse onun tüm yol ifadesine ilişkin dentry 
    nesnelerini de çekirdek içerisinde tutmaktadır. "dentry cache" sistemi de LRU prensibiyle çalışan bir cache sistemidir.  
        
    Daha önceden de gördüğümğz gibi Bir aygıt sürücü üzerinde dosya işlemi yapıldığında çekirdek aygıt sürücü fonksiyonlarına 
    dosya nesnesinin adresini (filp parametre değişkeni) geçirmektedir. Yalnızca aygıt sürücü open fonksiyonuyla açılırken ve 
    close fonksiyonu ile kapatılırken inode nesnesinin adresi de bu fonksiyonlara geçirilmektedir. Aygıt sürücünün fonksiyonlarının 
    parametrik yapılarını aşağıda yeniden veriyoruz:

    int open(struct inode *inodep, struct file *filp);
    int release(struct inode *inodep, struct file *filp);
    ssize_t read(struct file *filp, char *buf, size_t size, loff_t *off);
    ssize_t write(struct file *filp, const char *buf, size_t size, loff_t *off);
    loff_t llseek(struct file *filp, loff_t off, int whence);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücünün majör ve minör numaraları ne anlam ifade etmektedir? Majör numara aygıt sürücünün türünü, minör numara ise 
    aynı türden aygıt sürücülerin farklı örneklerini (instance'larını) belirtmektedir. Başka bir deyişle minör numara aygıt 
    sürücünün yönettiği aygıtların numaralarını belirtmektedir. Örneğin biz yukarıdaki "pipe-driver" aygıt sürücümüzün tek bir 
    boruyu değil on farklı boruyu idare etmesini isteyebiliriz. Bu durumda aygıt sürücümüzün bir tane majör numarası ancak 10 
    tane minör numarası olacaktır. Aygıt sürücülerin majör numaraları aynı ise bunların kodları da aynıdır. O aynı kod birden 
    fazla aygıt için işlev görmektedir. Örneğin seri portu kontrol eden bir aygıt sürücü söz konusu olsun. Ancak bilgisayarımızda 
    dört seri port olsun. İşte bu durumda bu seri porta ilişkin aygıt dosyalarının hepsinin majör numaraları aynıdır. Ancak minör 
    numaraları farklıdır. Ya da örneğin terminal aygıt sürücüsü bir tanedir. Ancak bu aygıt sürücü birden fazla terminali yönetebilmektedir. 
    O halde her terminale ilişkin aygıt dosyasının majör numaraları aynı minör numaraları farklı olacaktır. Örneğin:

    $ ls -l tty1 tty2 tty3 tty4 tty5
    crw--w---- 1 root tty 4, 1 Haz  2 15:05 tty1
    crw--w---- 1 root tty 4, 2 Haz  2 15:05 tty2
    crw--w---- 1 root tty 4, 3 Haz  2 15:05 tty3
    crw--w---- 1 root tty 4, 4 Haz  2 15:05 tty4
    crw--w---- 1 root tty 4, 5 Haz  2 15:05 tty5

    Örneğin diskleri yöneten bir aygıt sürücüsü olsun. Ancak bilgisayarımızda üç farklı fiziksel disk olsun. Bu disklerin 
    yönetimleri aynı biçimde aynı kodlarla yapılmaktadır. Bunları yöneten tek bir aygıt sürücü kodu dolaysıyla majör numarası 
    vardır. Ancak her disk ayrı bir minör numarayla temsil edilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                146. Ders 07/06/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de bir aygıt sürücünün aynı türden birden fazla aygıtı nasıl yönetebileceğini ele alacağız. Birden fazla aygıtı yönetecek 
    (yani birden fazla minör numaraya sahip olan) bir aygıt sürücü nasıl yazılabilir? Her şeyden önce birden fazla minör numara 
    kullanan aygıt sürücüleri yazarken dikkatli olmak gerekir. Çünkü tek bir kod birden fazla aynı türden bağımsız aygıtı idare 
    edecektir. Dolayısıyla bu tür durumlarda bazı nesnelerin senkronize edilmesi gerekebilir.

    Birden fazla minör numara üzerinde çalışacak (yani birden fazla aynı türden aygıt üzerinde çalışacak) aygıt sürücüler tipik 
    olarak şöyle yazılmaktadır:

    1) Aygıt sürücüyü yazan programcı baştan onun kaç minör numaraya ilişkin aygıtı yöneteceğini belirlemelidir. Bunun için 
    default bir değer kullanılabilir. Ancak genellikle aygıt sürücünün kaç minör numaraya ilişkin aygıtı yöneteceği aygıt 
    sürücüye komut satırı argümanlarıyla (yani modül parametreleriyle) geçirilmektedir. Biz de örneğimizde bu yöntemi kullanacağız. 
    Minör numara sayısının aşağıdaki gibi ndevices isimli parametre yoluyla komut satırından aygıt sürücüye aktarıldığını 
    varsayacağız:

    #define DEF_NDEVICES        10
    ...
    static int ndevices = DEF_NDEVICES;
    module_param(ndevices, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

    Bu durumda bu aygıt sürücü yüklenirken ndevices parametresi girilmezse DEF_NDEVICES değeri dikkate alınmaktadır. Örneğin 
    bu aygıt sürücüyü 5 aygıtı yönetecek biçimde aşağıdaki gibi yükleyebiliriz:

    ./insmod pipe-driver.ko ndevices=5

    2) Programcının aygıt sürücü için majör ve minör numaraları tahsis etmesi gerekir. Daha önce yaptığımız gibi majör numara 
    alloc_chrdev_region fonksiyonuyla dinamik olarak belirlenebilmektedir. Bu fonksiyon anımsanacağı gibi aynı zamanda belli 
    bir minör numaradan başlayarak n tane minör numarayı da tahsis edebilmektedir. Örneğin:

    if ((result = alloc_chrdev_region(&g_dev, 0, ndevices, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        goto EXIT1;
    }

    Burada 0'ıncı minör numaradan ndevices tane minör numara için aygıt tahsisatı yapılmıştır. Tabii g_dev nesnesi yalnızca 
    ilk minör numaraya ilişkin (örneğimizde 0) aygıt numarasını tutmaktadır.

    3) Her aygıt bir yapıyla temsil edilmelidir. Bunun için N elemanlı bir yapı dizisi yaratabilirsiniz. Bu dizi global düzeyde 
    tanımlanabileceği gibi kmalloc fonksiyonuyla dinamik biçimde de tahsis edilebilir. Biz örneğimizde her PIPE_DEVICE yapısını 
    ayrı bir kmalloc fonksiyonu ile tahsis ettik. Bunların adreslerini de yine kmalloc fonksiyonuyla tahsis ettiğimiz bir gösterici
    dizisine yerleştirdik. cdev nesnesi kesinlikle aygıtı temsil eden yapının (bizim örneğimizde PIPE_DEVICE yapısının) içerisinde 
    bulundurulmalıdır. Çünkü çekirdek bize bu nesnenin adresini geri verebilmektedir. Biz de bu sayede aygıt yapısına erişebiliriz. 
    Örneğimizdeki aygıtı temsil eden PIPE_DEVICE yapısı şöyledir:
       
    struct PIPE_DEVICE {
        unsigned char buf[PIPE_BUFFER_SIZE];
        size_t head;
        size_t tail;
        size_t count;
        struct semaphore sem;
        wait_queue_head_t wqwriteopen;
        wait_queue_head_t wqreadopen;
        wait_queue_head_t wqread;
        wait_queue_head_t wqwrite;
        int nreaders;
        int nwriters;
        struct cdev cdev;
    };

    Burada görüldüğü gibi her farklı borunun farklı bekleme kuyrukları ve semaphore nesnesi vardır. cdev yapı nesnesinin yapının 
    içerisine yerleştirilmesinin amacı ileride görüleceği gibi bu nenenin adresten hareketle aygıt nesnesinin başlangıç adresinin 
    elde edilmesini sağlamaktır. Bunun nasıl yapıldığı izleyen paragraflarda görülecektir.

    Aygıt nenseleri aşağıdaki gibi tahsis edilmiştir:

    if ((g_devices = (struct PIPE_DEVICE **)kmalloc(sizeof(struct PIPE_DEVICE *) * ndevices, GFP_KERNEL)) == NULL) {
        result = -ENOMEM;
        goto EXIT2;
    }
    for (i = 0; i < ndevices; ++i) {
        if ((g_devices[i] = kmalloc(sizeof(struct PIPE_DEVICE), GFP_KERNEL)) == NULL) {
            printk(KERN_ERR "cannot allocate slab from pipe cache!...\n");
            result = -ENOMEM;
            for (k = 0; k < i; ++k)    
                kfree(g_devices[k]);
            goto EXIT3;
        }
    }    

    Burada önce aygıt nesnelerini tutan gösterici dizisi için tahsisat yapımış daha sonra da aygıt nesneleri için tahsisat 
    yapılmıştır. Tabii aslında biz tek hamlede de (yanş tek bir kmalloc ile de) tüm tahsisatı yapabilirdik.

    4) N tane minör numaralı aygıt için cdev_add fonksiyonuyla aygıtlar çekirdeğe eklenmelidir. Örneğin:

        for (i = 0; i < ndevices; ++i) {
        g_devices[i]->head = g_devices[i]->tail = g_devices[i]->count = 0;
        sema_init(&g_devices[i]->sem, 1);
        init_waitqueue_head(&g_devices[i]->wqwriteopen);
        init_waitqueue_head(&g_devices[i]->wqreadopen);            
        init_waitqueue_head(&g_devices[i]->wqread);
        init_waitqueue_head(&g_devices[i]->wqwrite);
        g_devices[i]->nreaders = g_devices[i]->nwriters = 0;
        cdev_init(&g_devices[i]->cdev, &g_fops);
        dev = MKDEV(MAJOR(g_dev), i);
        if ((result = cdev_add(&g_devices[i]->cdev, dev, 1)) < 0) {
            for (k = 0; k < i; ++k) 
                cdev_del(&g_devices[k]->cdev);
            printk(KERN_ERR "cannot add device!...\n");
            goto EXIT4;
        }
    }

    Burada yapı dizisinin her elemanındaki elemanlara ilkdeğerleri verilmiştir. Sonra her boru için ayrı bir cdev nesnesi 
    cdev_add fonksiyonu ile eklenmiştir. Eklemelerden biri başarısız olursa daha önce eklenenlerin de cdev_del fonksiyonu 
    ile silindiğine dikkat ediniz.

    5) Aygıt sürücünün exit fonksiyonunda tahsis edilen tüm kaynaklar ters sırada geri bırakılmalıdır. Örneğin:

    static void __exit pipe_driver_exit(void)
    {
        int i;

        for (i = 0; i < ndevices; ++i)
            cdev_del(&g_devices[i]->cdev);
        for (i = 0; i < ndevices; ++i)
            kfree(g_devices[i]);
        kfree(g_devices);

        unregister_chrdev_region(g_dev, ndevices);
        
        printk(KERN_INFO "pipe-driver module exit...\n");
    }

    6) Bizim read, write gibi aygıt sürücü fonksiyonlarında file yapısı türünden adres belirten filp parametre değişkeni 
    yoluyla PIPE_DEVICE yapısına erişmemiz gerekir. Bu işlem dolaylı bir biçimde şöyle yapılmaktadır:
  
    - Önce aygıt sürücünün open fonksiyonunda programcı inode yapısının i_cdev elemanından hareketle cdev nesnesinin içinde 
    bulunduğu yapı nesnesinin başlangıç adresini container_of makrosuyla elde eder. inode yapısının i_cdev elemanı cdev_add
    fonksiyonuyla eklenen cdev yapı nesnesinin adresini tutmaktadır. container_of bir yapının bir elemanın adresini, o elemanın 
    ismini ve yapının ismini alarak yapı nesnesinin başlangıç adresini veren bir makrodur. container_of makrosu C standartlarında 
    bulunan bir makro değildir. Ancak bu makro C standartlarında bulunan offsetof makrosu kullanılarak yazılabilir. Anımsanacağı 
    gibi C'de offsetof makrosu bir yapının bir elemanının yapının başından itibaren kaçıncı offset'te olduğunu bize vermektedir. 
    offsetof makrosu şöyle yazabiliriz:

    #define my_offsetof(type, member)     ((size_t)&((type *)0)->member)

    Burada gerçek anlamda 0 adresine erişim yapılmamaktadır. C standartlarına göre bir gösterici ile onun gösterdiği yere erişilip 
    oranın adresi alındığında derleyici gerçek bir erişim yapmaz. İşte offsetof makrosu kullanılarak container_of makrosu de 
    şöyle yazılabilir:

    #define my_container_of(ptr, type, member)   ((type *)((char *)(ptr) - my_offsetof(type, member)))

    Makronun birinci parametresi yapı elemanın adresini, ikinci parametresi yapının tür ismini, üçüncü parametresi ise adresi 
    verilen yapı elemanının ismini almaktadır. Bu makro yapı nesnesinin bütünsel adresine geri dönmektedir. 

    Yukarıda da belirttiğimiz gibi Programcı cdev nesnesinin adresini inode yapısının i_cdev elemanından geri alabilmektedir. İşte 
    bu adres yoluyla da container_of makrosunu kullanarak aygıt nesnesinin adresini (örneğimizde PIPE_DEVICE nesnesinin adresini) 
    elde eder. İşte programcı aygıt nesnesinin adresini elde ettikten sonra onu file yapısının private_data elemanına yerleştirir. 
    file yapısının private_data elemanı programcının kendisinin yerleştirdiği bilgileri tutmak için bulundurulmuştur. Burada bir 
    noktaya dikkat ediniz: inode nesnesinin adresi yalnızca aygıt sürücünün open ve release fonksiyonlarına geçirilmektedir. read 
    ve write gibi fonksiyonlara file nesnesinin adresi (filp parametresi) geçirilmektedir. O halde programcı aygıt sürücünün open
    fonksiyonu içerisinde aygıt nesnesinin adresini elde edip onu file nesnesinin içerisine yerleştirmelidir. Bu işlemler tipik 
    olarak aşağıdaki gibi yapılabilir:

    static int pipe_open(struct inode *inodep, struct file *filp)
    {
        struct PIPE_DEVICE *pipedev;
        int accmode = filp->f_flags & O_ACCMODE;

        pipedev = container_of(inodep->i_cdev, struct PIPE_DEVICE, cdev);
        filp->private_data = pipedev;

        /* ... */

        printk(KERN_INFO "pipe-driver opened...\n");

        return 0;
    }

    7) Aygıt sürücünün read ve write fonksiyonları yazılır.

    8) release (close) işleminde yapılacak birtakım son işlemler varsa yapılır.

    9) Birden fazla minör numara için çalışacak aygıt sürücüler için birden fazla aygıt dosyasının yaratılması gerekir. Yani 
    aygıt sürücü kaç minör numarayı destekliyorsa o sayıda aygıt dosyası yaratılmalıdır. Bu da onları yüklemek için kullandığımız 
    "load" script'inde değişiklik yapmayı gerektirmektedir. N tane minör numaraya ilişkin aygıt dosyası yaratacak biçimde yeni 
    bir "loadmulti" script'i aşağıdaki gibi yazılabilir:

    #!/bin/bash

    module=$2
    mode=666

    /sbin/insmod ./${module}.ko ${@:3} || exit 1
    major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)

    for ((i = 0; i < $1; ++i))
    do
        rm -f ${module}$i
        mknod -m $mode ${module}$i c $major $i
    done

    Buradaki "loadmulti" script'i iki komut satırı argümanıyla aşağıdaki örnekteki gibi çalıştırılmalıdır:

    $ sudo ./loadmulti 10 pipe-driver ndevices=10

    Burada "loadmulti" script'i hem aygıt sürücüyü yükleyecek hem de pipe-driver0, pipe-driver1, ..., pipedriver9 biçiminde 
    aygıt dosyalarını yaratacaktır. Aşağıda yaratılmış olan örnek aygıt dosyalarına dikkat ediniz:

    crw-rw-rw- 1 root root  236, 0 Haz  7 22:09 pipe-driver0
    crw-rw-rw- 1 root root  236, 1 Haz  7 22:09 pipe-driver1
    crw-rw-rw- 1 root root  236, 2 Haz  7 22:09 pipe-driver2
    crw-rw-rw- 1 root root  236, 3 Haz  7 22:09 pipe-driver3
    crw-rw-rw- 1 root root  236, 4 Haz  7 22:09 pipe-driver4
    crw-rw-rw- 1 root root  236, 5 Haz  7 22:09 pipe-driver5
    crw-rw-rw- 1 root root  236, 6 Haz  7 22:09 pipe-driver6
    crw-rw-rw- 1 root root  236, 7 Haz  7 22:09 pipe-driver7
    crw-rw-rw- 1 root root  236, 8 Haz  7 22:09 pipe-driver8
    crw-rw-rw- 1 root root  236, 9 Haz  7 22:09 pipe-driver9

    Aygıt dosyalarının majör numaralarının hepsi aynıdır ancak minör numaraları farklıdır. Burada artık adeta birbirinden bağımsız 
    10 ayrı boru aygıtı var gibidir. Ancak aslında tek bir aygıt sürücü kodu bulunmaktadır. Tabii bizim benzer biçimde "unload"
    script'ini de tüm aygıt dosyalarını silecek biçimde düzeltmemiz gerekir. Bunun için "unloadmulti" script'ini aşağıdaki gibi
    yazabiliriz:

    #!/bin/bash

    module=$2

    /sbin/rmmod ./$module.ko || exit 1
    for ((i = 0; i < $1; ++i))
    do
        rm -f ${module}$i
    done

    Bu script'te biz önce modülü çekirdekten sonra da "loadmulti" ile yarattığımız aygıt dosyalarını dosya sisteminden silmekteyiz. 
    Script aşağıdaki örnekteki gibi kullanılmalıdır:

    $ sudo ./unloadmulti 10 pipe-driver

    Şimdi ndevices kadar minör numarayı destekleyen aygıt sürücü kodunun tamamını veriyoruz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>
#include <linux/slab.h>

#define DEF_NDEVICES            10
#define PIPE_BUFFER_SIZE           10

#define MIN(a, b)    ((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int ndevices = DEF_NDEVICES;
module_param(ndevices, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = pipe_driver_open,
    .read = pipe_driver_read,
    .write = pipe_driver_write,
    .release = pipe_driver_release
};

struct PIPE_DEVICE {
    unsigned char buf[PIPE_BUFFER_SIZE];
    size_t head;
    size_t tail;
    size_t count;
    struct semaphore sem;
    wait_queue_head_t wqwriteopen;
    wait_queue_head_t wqreadopen;
    wait_queue_head_t wqread;
    wait_queue_head_t wqwrite;
    int nreaders;
    int nwriters;
    struct cdev cdev;
};
static struct PIPE_DEVICE **g_devices;

static int __init pipe_driver_init(void)
{
    int result;
    int i, k;
    dev_t dev;

    printk(KERN_INFO "pipe-driver init...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, ndevices, "pipe-driver")) < 0) {
        printk(KERN_ERR "cannot register device!...\n");
        goto EXIT1;
    }
    if ((g_devices = (struct PIPE_DEVICE **)kmalloc(sizeof(struct PIPE_DEVICE *) * ndevices, GFP_KERNEL)) == NULL) {
        result = -ENOMEM;
        goto EXIT2;
    }
    for (i = 0; i < ndevices; ++i) {
        if ((g_devices[i] = kmalloc(sizeof(struct PIPE_DEVICE), GFP_KERNEL)) == NULL) {
            printk(KERN_ERR "cannot allocate pipe device!...\n");
            result = -ENOMEM;
            for (k = 0; k < i; ++k)    
                kfree(g_devices[k]);
            goto EXIT3;
        }
    }    
    
    for (i = 0; i < ndevices; ++i) {
        g_devices[i]->head = g_devices[i]->tail = g_devices[i]->count = 0;
        sema_init(&g_devices[i]->sem, 1);
        init_waitqueue_head(&g_devices[i]->wqwriteopen);
        init_waitqueue_head(&g_devices[i]->wqreadopen);            
        init_waitqueue_head(&g_devices[i]->wqread);
        init_waitqueue_head(&g_devices[i]->wqwrite);
        g_devices[i]->nreaders = g_devices[i]->nwriters = 0;
        cdev_init(&g_devices[i]->cdev, &g_fops);
        dev = MKDEV(MAJOR(g_dev), i);
        if ((result = cdev_add(&g_devices[i]->cdev, dev, 1)) < 0) {
            for (k = 0; k < i; ++k) 
                cdev_del(&g_devices[k]->cdev);
            printk(KERN_ERR "cannot add device!...\n");
            goto EXIT4;
        }
    }    
    return 0;

EXIT4:
    for (i = 0; i < ndevices; ++i)
        kfree(g_devices[i]);
EXIT3:
    kfree(g_devices);
EXIT2:
    unregister_chrdev_region(g_dev, ndevices);
EXIT1:
    return result;
}

static void __exit pipe_driver_exit(void)
{
    int i;

    for (i = 0; i < ndevices; ++i)
        cdev_del(&g_devices[i]->cdev);
    for (i = 0; i < ndevices; ++i)
        kfree(g_devices[i]);
    kfree(g_devices);

    unregister_chrdev_region(g_dev, ndevices);
    
    printk(KERN_INFO "pipe-driver module exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
    struct PIPE_DEVICE *pipedev;
    int accmode = filp->f_flags & O_ACCMODE;

    pipedev = container_of(inodep->i_cdev, struct PIPE_DEVICE, cdev);
    filp->private_data = pipedev;

    if (down_interruptible(&pipedev->sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY) {
        ++pipedev->nreaders;
        wake_up_interruptible(&pipedev->wqwriteopen);
        while (pipedev->nwriters == 0) {
            up(&pipedev->sem);
            if (filp->f_flags & O_NONBLOCK)
                return 0;
            if (wait_event_interruptible(pipedev->wqreadopen, pipedev->nwriters > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&pipedev->sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_WRONLY) {
        ++pipedev->nwriters;
        wake_up_interruptible(&pipedev->wqreadopen);
        while (pipedev->nreaders == 0) {
            if (filp->f_flags & O_NONBLOCK) {
                --pipedev->nwriters;
                up(&pipedev->sem);
                return -ENXIO;
            }
            up(&pipedev->sem);
            if (wait_event_interruptible(pipedev->wqwriteopen, pipedev->nreaders > 0))
                return -ERESTARTSYS;
            if (down_interruptible(&pipedev->sem))
                return -ERESTARTSYS;
        }
    }
    else if (accmode == O_RDWR) {
        ++pipedev->nreaders;
        ++pipedev->nwriters;
        wake_up_interruptible(&pipedev->wqreadopen);
        wake_up_interruptible(&pipedev->wqwriteopen);
    }
    up(&pipedev->sem);

    printk(KERN_INFO "pipe-driver opened...\n");
    
    return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
    struct PIPE_DEVICE *pipedev;
    int accmode = filp->f_flags & O_ACCMODE;

    pipedev = filp->private_data;

    if (down_interruptible(&pipedev->sem) != 0)
        return -ERESTARTSYS;

    if (accmode == O_RDONLY)
        --pipedev->nreaders;
    else if (accmode == O_WRONLY)
        --pipedev->nwriters;
    else if (accmode == O_RDWR) {
        --pipedev->nreaders;
        --pipedev->nwriters;
    }
    if (pipedev->nreaders == 0)
        wake_up_interruptible(&pipedev->wqwrite);
    if (pipedev->nwriters == 0)
        wake_up_interruptible(&pipedev->wqread);

    if (pipedev->nreaders + pipedev->nwriters == 0) 
		pipedev->count = pipedev->head = pipedev->tail = 0;

    up(&pipedev->sem);

    return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;
    struct PIPE_DEVICE *pipedev;

    pipedev = (struct PIPE_DEVICE *)filp->private_data;

    if (down_interruptible(&pipedev->sem) != 0)
        return -ERESTARTSYS;

    while (pipedev->count == 0) {
        if (pipedev->nwriters == 0) {
            result = 0;
            goto EXIT;
        }
        up(&pipedev->sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(pipedev->wqread, pipedev->count > 0 || pipedev->nwriters == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&pipedev->sem) != 0)
            return -ERESTARTSYS;
    }

    esize = MIN(size, pipedev->count);
    if (pipedev->head >= pipedev->tail)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - pipedev->head);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_to_user(buf, pipedev->buf + pipedev->head, size1) != 0)
        goto EXIT;

    if (size2 != 0)
        if (copy_to_user(buf + size1, pipedev->buf, size2) != 0)
            goto EXIT;

    pipedev->head = (pipedev->head + esize) % PIPE_BUFFER_SIZE;
    pipedev->count -= esize;

    result = esize;

    wake_up_interruptible(&pipedev->wqwrite);
EXIT:
    up(&pipedev->sem);

    return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t esize, size1, size2;
    ssize_t result = -EFAULT;
    struct PIPE_DEVICE *pipedev;

    pipedev = (struct PIPE_DEVICE *)filp->private_data;

    if (size > PIPE_BUFFER_SIZE)
        size = PIPE_BUFFER_SIZE;

    if (down_interruptible(&pipedev->sem) != 0)
        return -ERESTARTSYS;

    if (pipedev->nreaders == 0) {
        up(&pipedev->sem);
        send_sig(SIGPIPE, current, 0);
        return -EPIPE;
    }
    while (PIPE_BUFFER_SIZE - pipedev->count < size) {
        up(&pipedev->sem);
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(pipedev->wqwrite, PIPE_BUFFER_SIZE - pipedev->count >= size || pipedev->nreaders == 0) != 0)
            return -ERESTARTSYS;
        if (down_interruptible(&pipedev->sem) != 0)
            return -ERESTARTSYS;
        if (pipedev->nreaders == 0) {
            up(&pipedev->sem);
            send_sig(SIGPIPE, current, 0);
            return -EPIPE;
        }
    }

    esize = MIN(size, PIPE_BUFFER_SIZE - pipedev->count);

    if (pipedev->tail >= pipedev->head)
        size1 = MIN(esize, PIPE_BUFFER_SIZE - pipedev->tail);
    else
        size1 = esize;
    size2 = esize - size1;

    if (copy_from_user(pipedev->buf + pipedev->tail, buf, size1) != 0)
        goto EXIT;
    if (size2 != 0)
        if (copy_from_user(pipedev->buf, buf + size1, size2) != 0)
            goto EXIT;

    pipedev->tail = (pipedev->tail + esize ) % PIPE_BUFFER_SIZE;
    pipedev->count += esize;
    result = esize;

EXIT:
    wake_up_interruptible(&pipedev->wqread);
    up(&pipedev->sem);

    return result;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* loadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2
mode=666

/sbin/insmod ./${module}.ko ${@:3} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)

for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
    mknod -m $mode ${module}$i c $major $i
done

/* unloadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2

/sbin/rmmod ./$module.ko || exit 1
for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
done

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_WRONLY)) == -1)
        exit_sys("open");
    
    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        
        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

//* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE        8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char buf[BUFFER_SIZE];
    int n;
    ssize_t result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Number of bytes to read? ");
        scanf("%d", &n);
        if (n == 0)
            break;
        if ((result = read(fd, buf, n)) == -1) {
            if (errno != EAGAIN)
                exit_sys("read");
            printf("pipe is empty, let's do something else...\n");
            continue;
        }
        if (result == 0) {
            putchar('\n');
            break;
        }
        buf[result] = '\0';
        printf("%jd bytes read: %s\n", (intmax_t)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                148. Ders 16/06/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücüden bilgi okumak için read fonksiyonun, aygıt sürücüye bilgi göndermek için ise write fonksiyonun kullanıldığını 
    gördük. Ancak bazen aygıt sürücüye write fonksiyonunu kullanmadan bazı bilgilerin gönderilmesi, aygıt sürücüden read 
    fonksiyonunu kullanmadan da bazı bilgilerin alınması gerekebilmektedir. Bazen hiç bilgi okumadan ve bilgi göndermeden aygıt 
    sürüceden bazı şeyleri yapmasını da isteyebiliriz. Bu tür bazı işlemlerin read ve write fonksiyonlarıyla yaptırılması mümkün 
    olsa bile kullanışsızdır.

    Örneğin yukarıdaki boru aygıt sürücümüzde (pipe-driver) biz aygıt sürücüden kullandığı FIFO alanının uzunluğunu isteyebiliriz. 
    Ya da bu alanın boyutunu değiştirmek isteyebiliriz. Bu işlemleri read ve write fonksiyonlarıyla yapmaya çalışsak aygıt 
    sürücümüz sanki boruyu temsil eden kuyruktan okuma yazma yapmak istediğimizi sanacaktır. Tabii yukarıda da belirttiğimiz 
    gibi zorlanırsa bu tür işlemler read ve write fonksiyonlarıyla yine de yapılabilir. Ancak böyle bir kullanımın mümkün hale 
    getirilmesi ve user mode'dan kullanılması oldukça zor olacaktır.

    İşte aygıt sürücüye komut gönderip ondan bilgi almak ya da ona bazı işlemleri yaptırmak için genel amaçlı ioctl isminde 
    özel bir POSIX fonksiyonu bulundurulmuştur. Linux sistemlerinde ioctl fonksiyonu sys_ioctl isimli sistem fonksiyonunu 
    çağırmaktadır. ioctl fonksiyonunun parametrik yapısı şöyledir:

    #include <sys/ioctl.h>

    int ioctl(int fd, unsigned long request, ...);

    Fonksiyonun birinci parametresi aygıt sürücüye ilişkin dosya betimleyicisini belirtir. İkinci parametre ileride açıklanacak 
    olan komut kodudur. Aygıt sürücüsünü yazan programcı aygıt sürücüsünde farklı komutlar için farklı komut kodları (yani 
    numaralar) oluşturur. Sonra bu komut kodlarını switch içerisine sokarak hangi numaralı istekte bulunulmuşsa ona yönelik 
    işlemleri yapar. ioctl fonksiyonu iki parametreyle ya da üç parametreyle kullanılmaktadır. Yani fonksiyonun üçüncü parametresi 
    isteğe bağlıdır. Eğer bir veri transferi söz konusu değilse ioctl genellikle iki argümanla çağrılır. Ancak bir veri transferi 
    söz konusu ise ioctl üç argümanla çağrılmalıdır. Bu durumda üçüncü argüman user mode'daki transfer adresini belirtir. Tabii 
    aslında bu üçüncü parametrenin veri transferi ile ilgili olması dolayısıyla da bir adres belirtmesi zorunlu değildir.

    ioctl fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri döner. errno uygun biçimde set 
    edilmektedir. Örneğin:

    if (ioctl(fd, command_code) == -1)
        exit_sys("ioctl");

    Aslında çoğu kez uygulama programcıları ioctl çağrılarını doğrudan yapmamaktadır. Aygıt sürücüleri ayzanlar bu çağrıları 
    yapan daha yüksek seviyeli kütüphaneler (yani API'ler) oluşturup bu kütüphaneleri uygulama programcılarına vermektedir. 
    Yani çoğu kez aşaığıdaki gibi bir katmalı yapı söz konusu olmaktadır:

    +---------------------------+
    | Yüksek Seviyeli Kütüphane |
    +---------------------------+
    |        IOCTL Kodları      |
    +---------------------------+
    |        Aygıt Sürücü       |
    +---------------------------+
    |          Çekirdek         |
    +---------------------------+

    Buradaki "Yüksek Seviyeli Kütüphane" ioctl çağrılarını yapan fonksiyonlardan oluşmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
   Kullanıcı modundaki bir program aygıt sürücü için ioctl fonksiyonunu çağırdığında akış kullanıcı modundan çekirdke moduna 
    geçer ve aygıt sürücüdeki file_operations yapısının unlocked_ioctl elemanında belirtilen fonksiyon çağrılır. Bu fonksiyonun 
    parametrik yapısı şöyle olmalıdır:

    long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

    Fonksiyonun birinci parametresi yine dosya nesnesinin adresini, ikinci parametresi ioctl fonksiyonunda kullanılan komut 
    kodunu (yani ioctl fonksiyonuna geçirilen ikinci argümanı) ve üçüncü parametresi de ek argümanı (yani ioctl fonksiyonuna 
    geçirilen üçüncü argümanı) belirtmektedir. Tabii programcının eğer ioctl fonksiyonu iki argümanlı çağrılmışsa bu üçüncü 
    parametreye erişmemesi gerekir.

    Bu fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda negatif hata koduna geri dönmelidir. Fakat bazen programcı 
    doğrudan iletilecek değeri geri dönüş değeri biçiminde oluşturabilir. Bu durumda geri dönüş değeri pozitif değer olabilir.
    Örneğin:

    static long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
    ...

    static struct file_operations g_fops = {
        .owner = THIS_MODULE,
        .open = generic_open,
        .read = generic_read,
        .write = generic_write,
        .release = generic_release,
        .unlocked_ioctl = generic_ioctl
    };
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    ioctl işleminde ioctl fonksiyonunun ikinci parametresi olan kontrol kodu dört parçanın bit düzeyinde birleştirilmesiyle
    oluşturulmaktadır. Bu dört parçnın 32 bit içerisindeki bit genişlikleri ve pozisyonları şöyledir:

    31     30 29           22 21            14 13              0
    +--------+---------------+----------------+----------------+
    |  Dir   |     Type      |     Number     |     Size       |
    +--------+---------------+----------------+----------------+
      2 bits      8 bits           8 bits          14 bits 
    
    Ancak bu parçalara ilişkin bitlerin 32 bit içerisinde belli pozisyonlara yerleştirilmesini kolaylaştırmak için _IOC isimli 
    bir makro bulundurulmuştur. Bu makronun parametreleri şöyledir:

    _IOC(dir, type, nr, size)

    Bu makro buradaki parçaları bit düzeyinde birleştirerek 4 byte'lık bir değer vermektedir. Makronun parametrelerini oluşturan 
    dört parçanın anlamları ve bit uzunlukları şöyledir:

    dir (direction): Bu 2 bitlik bir alandır ([30, 31] bitler). Burada kullanılacak sembolik sabitler _IOC_NONE, _IOC_READ, 
    _IOC_WRITE ve _IOC_READ|_IOC_WRITE biçimindedir. Buradaki _IOC_READ aygıt sürücüden bilgi alınacağını _IOC_WRITE ise aygıt 
    sürücüye bilgi gönderileceğini belirtmektedir. Ancak bu yön ioctl sistem fonksiyonu tarafından dosyanın açış moduyla kontrol
    edilmemektedir. Örneğin biz buradaki yönü _IOC_READ|_IOC_WRITE biçiminde vermiş olsak bile aygıt dosyaısnı O_RDONLY modunda 
    açıp bu ioctl işlemini yapabiliriz. Çekirdek hiçbir işlemde bu yön bilgisini kontrol etmemektedir. Eğer programcı böyle bir 
    kontrol yapmak istiyorsa aygıt sürücünün ioctl fonksiyonu içerisinde bunu yapmalıdır. Buradaki sembolil sabitler tipik olarak 
    şu değerlerdedir:

    #define _IOC_NONE       0U
    #define _IOC_WRITE      1U
    #define _IOC_READ       2U
    
    type: Bu 8 bitlik bir alandır ([22, 29] bitleri). Bu alana aygıt sürücüyü yazan istediği herhangi bir byte'ı verebilir. 
    Genellikle bu byte bir karakter sabiti olarak verilmektedir. Buna "magic number" da denilmektedir.

    nr: Bu 8 bitlik bir alandır ([14, 21] bitleri). Programcı tarafından kontrol koduna verilen sıra numarasını temsil etmektedir. 
    Genellikle aygıt sürücü programcıları 0'dan başlayarak her koda bir numara vermektedir.

    size: Bu 14 bitlik bir alandır ([0, 13] bitleri). Bu alan kaç byte'lık bir transferin yapılacağını belirtmektedir. Buradaki 
    size değeri aslında çekirdek tarafından kullanılmamaktadır. Dolayısıyla biz 14 bitten daha büyük transferleri de yapabiliriz.

    Kullanım kolaylığı sağlamak için genellikle _IOC makrosu bir sembolik sabit biçiminde define edilir. Örneğin:

    #define GENERAL_DRIVER_MAGIC    'g'
    #define IOC_GENERIC_INFO         _IOC(_IOC_READ, GENERAL_DRIVER_MAGIC, 0, 4)

    Aslında _IOC makrosundan daha kolay kullanılabilen aşağıdaki makrolar da oluşturulmuştur:

    #ifndef __KERNEL__
        #define _IOC_TYPECHECK(t) (sizeof(t))
    #endif

    #define _IO(type,nr)                _IOC(_IOC_NONE,(type),(nr),0)
    #define _IOR(type,nr,size)          _IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
    #define _IOW(type,nr,size)          _IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
    #define _IOWR(type,nr,size)         _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))

    Bu makrolarda _IOC makrosunun birinci parametresinin artık belirtilmediğine dikkat ediniz. Çünkü makrolar zaten isimlerine
    göre _IOC makrosunun birinci parametresini kendisi oluşturmaktadır. Ayrıca artık uzunluk (size parametresi) byte olarak 
    değil tür olarak belirtilmelidir. Makrolar bu türleri sizeof operatörüne kendisi sokmaktadır. Görüldüğü gibi _IO makrosu 
    veri transferinin söz konusu olmadığı durumda kullanılır. _IOR aygıt sürücüden okuma yapıldığı durumda, _IOW aygıt sürücüye 
    yazma yapıldığı durumda, _IOWR ise aygıt sürücüden hem okuma hem de yazma yapıldığı durumlarda kullanılmaktadır. Örneğin:

    #define GENERAL_DRIVER_MAGIC    'g'
    #define IOC_GENERIC_INFO        _IOR(GENERAL_DRIVER_MAGIC, 0, int)

    ioctl için kontrol kodları hem aygıt sürücünün içerisinden hem de user kullanıcı modundan kullanılacağına göre ortak bir 
    başlık dosyasının oluşturulması uygun olabilir. Burada ioctl kontrol kodları bulundurulabilir. Örneğin boru aygıt sürücümüz 
    için "pipe-driver.h" dosyası aşağıdaki gibi düzenlenebilir:

    /* ioctl-driver.h */

    #ifndef IOCTL_DRIVER_H_
    #define IOCTL_DRIVER_H_

    #include <linux/stddef.h>
    #include <linux/ioctl.h>

    #define GENERIC_DRIVER_MAGIC        'g'
    #define IOC_GENERIC_TEST            _IO(GENERIC_DRIVER_MAGIC, 0)

    #endif

    Aygıt sürücüdeki ioctl fonksiyonunu yazarken iki noktaya dikkat etmek gerekir:

    1) ioctl fonksiyonunun üçüncü parametresi unsigned long türden olmasına karşın aslında genellikle kullanıcı modunda çalışan 
    programcı buraya bir nesnesin adresini geçirmektedir. Dolayısıyla bu transfer adresine aktarım gerekmektedir. Bunun için 
    copy_to_user, copy_from_use, put_user, get_user gibi "adresin geçerliliğini sorguladıktan sonra transfer yapan fonksiyonlar" 
    kullanılabilir.

    2) Kullanıcı modunda çalışan programcının olmayan bir komut kodu girmesi durumunda ioctl fonksiyonu -ENOTTY değeri ile 
    geri döndürülmelidir. Bu tuhaf hata kodu (TTY teletype terminal sözcüklerinden kısaltmadır) tarihsel bir durumdan 
    kaynaklanmaktadır. Bu hata kodu için kullanıcı modunda "Inappropriate ioctl for device" biçiminde bir hata yazısı elde 
    edilmektedir.

    Kullanıcı modundaki ioctl fonksiyonu başarı durumunda 0 değerine geri döndüğü için aygıt sürücüdeki ioctl fonksiyonu da 
    genel olarak başarı durumunda 0 ile geri döndürülmelidir. Yukarıda da belirttiğimiz gibi olmayan bir ioctl kodu için aygıt 
    sürücüdeki fonksiyonun -ENOTTY ile geri döndürülmesi uygundur. Bazı aygıt sürücülerinde başarı durumunda aygıt sürücüden 
    bilgi ioctl fonksiyonunun üçüncü parametresi yoluyla değil geri dönüş değeri yoluyla elde edilmektedir. Bu durumda aygıt 
    sürücüdeki ioctl fonksiyonu pozitif değerle de geri döndürülebilir. Ancak bu durum seyrektir. Biz veri transferinin ioctl 
    fonksiyonunun üçüncü 
    parametresi yoluyla yapılmasını tavsiye ediyoruz.

    Aygıt sürücüdeki ioctl fonksiyonu tipik olarak bir switch deyimi ile gerçekleştirilmektedir. Örneğin:

   static long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
    {
        long result;
        printk(KERN_INFO "generic_ioctl...\n");

        switch (cmd) {
            case IOC_GENERIC_TEST1:
                result = ioctl_generic_test1(filp, arg);
                break;
            case IOC_GENERIC_TEST2:
                result = ioctl_generic_test2(filp, arg);
                break;
            case IOC_GENERIC_TEST3:
                result = ioctl_generic_test3(filp, arg);
                break;
            case IOC_GENERIC_TEST4:
                result = ioctl_generic_test4(filp, arg);
                break;
            case IOC_GENERIC_TEST5:
                result = ioctl_generic_test5(filp, arg);
                break;
            default:
                result = -ENOTTY;
        }

        return result;
    }

    Burada switch deyiminin default bölümünde fonksiyonun -NOTTY değeri ile geri döndürüldüğüne dikkat ediniz. Tabii fonksiyon
    üçüncü parametresi ile belirtilen transfer adresi geçersiz bir adresse yine -EFAULT değeri ile geri döndürülmelidir.

    Aşağıda iskelet bir ioctl örneği verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* ioctl-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include "ioctl-driver.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("ioctl-driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static long ioctl_generic_test1(struct file *filp, unsigned long arg);
static long ioctl_generic_test2(struct file *filp, unsigned long arg);
static long ioctl_generic_test3(struct file *filp, unsigned long arg);
static long ioctl_generic_test4(struct file *filp, unsigned long arg);
static long ioctl_generic_test5(struct file *filp, unsigned long arg);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = generic_open,
	.read = generic_read,
	.write = generic_write,
	.release = generic_release,
    .unlocked_ioctl = generic_ioctl
};

static int __init generic_init(void)
{
	int result;

	printk(KERN_INFO "ioctl-driver module initialization...\n");

	if ((result = alloc_chrdev_region(&g_dev, 0, 1, "ioctl-driver")) < 0) {
		printk(KERN_INFO "cannot alloc char driver!...\n");
		return result;
	}
	cdev_init(&g_cdev, &g_fops);
	if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
		unregister_chrdev_region(g_dev, 1);
		printk(KERN_ERR "cannot add device!...\n");
		return result;
	}

	return 0;
}

static void __exit generic_exit(void)
{
	cdev_del(&g_cdev);
	unregister_chrdev_region(g_dev, 1);

	printk(KERN_INFO "ioctl-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "ioctl-driver opened...\n");

	return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "ioctl-driver closed...\n");

	return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
	printk(KERN_INFO "ioctl-driver read...\n");

	return 0;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
	printk(KERN_INFO "ioctl-driver write...\n");

	return 0;
}

static long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    long result;
    printk(KERN_INFO "generic_ioctl...\n");

    switch (cmd) {
        case IOC_GENERIC_TEST1:
            result = ioctl_generic_test1(filp, arg);
            break;
        case IOC_GENERIC_TEST2:
            result = ioctl_generic_test2(filp, arg);
            break;
        case IOC_GENERIC_TEST3:
            result = ioctl_generic_test3(filp, arg);
            break;
        case IOC_GENERIC_TEST4:
            result = ioctl_generic_test4(filp, arg);
            break;
        case IOC_GENERIC_TEST5:
            result = ioctl_generic_test5(filp, arg);
            break;
        default:
            result = -ENOTTY;
    }

    return result;
}

long ioctl_generic_test1(struct file *filp, unsigned long arg)
{
    printk(KERN_INFO "IOC_GENERIC_TEST1\n");

    return 0;
}

long ioctl_generic_test2(struct file *filp, unsigned long arg)
{
    printk(KERN_INFO "IOC_GENERIC_TEST2\n");

    return 0;
}

long ioctl_generic_test3(struct file *filp, unsigned long arg)
{
    printk(KERN_INFO "IOC_GENERIC_TEST3\n");

    return 0;
}

long ioctl_generic_test4(struct file *filp, unsigned long arg)
{
    printk(KERN_INFO "IOC_GENERIC_TEST4\n");

    return 0;
}

long ioctl_generic_test5(struct file *filp, unsigned long arg)
{
    printk(KERN_INFO "IOC_GENERIC_TEST5\n");

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* ioctl-driver.h */

#ifndef GENERIC_DRIVER_H_
#define GENERIC_DRIVER_H_

#include <linux/stddef.h>
#include <linux/ioctl.h>

#define GENERIC_DRIVER_MAGIC		'g'
#define IOC_GENERIC_TEST1		    _IO(GENERIC_DRIVER_MAGIC, 0)
#define IOC_GENERIC_TEST2		    _IO(GENERIC_DRIVER_MAGIC, 1)
#define IOC_GENERIC_TEST3		    _IO(GENERIC_DRIVER_MAGIC, 3)
#define IOC_GENERIC_TEST4		    _IO(GENERIC_DRIVER_MAGIC, 4)
#define IOC_GENERIC_TEST5		    _IO(GENERIC_DRIVER_MAGIC, 5)

#endif
    
/* ioctl-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "ioctl-driver.h"

void exit_sys(const char *msg);

int main(void)
{
    int fd;
		
	if ((fd = open("ioctl-driver", O_RDONLY)) == -1)
		exit_sys("open");

    if (ioctl(fd, IOC_GENERIC_TEST1) == -1)
        exit_sys("ioctl");
    if (ioctl(fd, IOC_GENERIC_TEST2) == -1)
        exit_sys("ioctl");
    if (ioctl(fd, IOC_GENERIC_TEST3) == -1)
        exit_sys("ioctl");
    if (ioctl(fd, IOC_GENERIC_TEST4) == -1)
        exit_sys("ioctl");

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                149. Ders 23/06/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/


    Bu örnek için yukarıda vermiş olduğumuz boru aygıt sürücüsünde bazı değişiklikler yaptık. Bu değişiklikler şunlardır:

    - Artık borunun uzunluğu PIPE_DEVICE yapısının içerisinde tutulmaya başlanmıştır:

    struct PIPE_DEVICE {
        unsigned char *buf;
        size_t bufsize;
        size_t head;
        size_t tail;
        size_t count;
        struct semaphore sem;
        wait_queue_head_t wqwriteopen;
        wait_queue_head_t wqreadopen;
        wait_queue_head_t wqread;
        wait_queue_head_t wqwrite;
        int nreaders;
        int nwriters;
        struct cdev cdev;
    };

    Buradaki bufsize elemanı ilgili borunun uzunluğunu belirtmektedir. Default uzunluk PIPE_DEF_BUFFER_SIZE değeri kadardır. 
    Bu değer örneğimizde test için kolaylık sağlamak amacıyla 10 olarak alınmıştır. Bu değişiklik sayesinde artık her minör 
    numaraya ilişkin  boru uzunlukları farklılaşabilecektir.

    - ioctl işlemleri farklı proseslerden aynı anda yapılabileceği için işlemlerin genel olarak senkronize edilmesi gerekir.

    - Aygıt sürücümüz içerisindeki ioctl fonksiyonu aşağıdaki gibi yazılmıştır:

    static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
    {
        struct PIPE_DEVICE *pipedev;
        int result;

        printk(KERN_INFO "ioctl\n");

        pipedev = (struct PIPE_DEVICE *)filp->private_data;

        if (down_interruptible(&pipedev->sem))
            return -ERESTARTSYS;

        switch (cmd) {
            case IOC_PIPE_GETNDEVICES:
                result =  put_user(ndevices, (size_t *)arg);
                break;
            case IOC_PIPE_GETCOUNT:
                result =  put_user(pipedev->count, (size_t *)arg);
                break;
            case IOC_PIPE_GETBUFSIZE:
                result = put_user(pipedev->bufsize, (size_t *)arg);
                break;
            case IOC_PIPE_SETBUFSIZE:
                result = set_bufsize(pipedev, arg);
                break;
            case IOC_PIPE_PEEK:
                result = read_peek(pipedev, arg);
                break;
            default:
                result = -ENOTTY;
        }

        up(&pipedev->sem);

        return result;
    }

    Burada biz ioctl fonksiyonun hemen başında bir kritik kod oluşturduk. Tabii kritik kodun mümkün olduğunca küçük bir kod
    parçasını içermesini sağlamalısınız. Ancak buradaki örneğimizde tüm fonksiyonu kilitlemenin önemli bir sakıncası yoktur. 
    set_busize fonksiyonu borunun kullandığı tamponu büyütme ya da küçültme işlevini yerine getirmektedir. peek_read fonksiyonu 
    ise borudan bilgiyi atmadan okuma yapmaktadır. Normal olarak borudan read fonksiyonu ile okuma yapıldığında okunanlar borudan 
    atılmaktadır. Ancak bu ioctl kodu ile borudan okuma yapıldığında okunanlar borudan atılmamaktadır. Bu ioctl kodu için aşağıdaki 
    gibi bir yapı oluşturulmuştur:

    struct PIPE_PEEK {
        size_t size;
        void *buf;
    };

    Yapının size elemanı kaç byte peek işleminin yapılacağını, buf elemanı ise peek edilen byte'ların yerleştirileceği adresi
    belirtmektedir. Tabii boruda mevcut olan byte sayısından daha fazla byte peek edilmek istenirse boruda olan kadar byte peek 
    edilmektedir. Peek edilen byte sayısı aygıt sürücü tarafından yapının size elemanına aktarılmaktadır. 

    Aygıt sürücümüzü yine "loadmulti" script'i ile aşağıdaki gibi yükleyebilirsiniz:

    $ sudo ./loadmulti 10 pipe-driver ndevices=10

    Aygıt sürücünün çekirdekten atılması da yine "unloadmulti" script'i ile aşağıdaki gibi yapılabilir:

    $ sudo ./unloadmulti 10 pipe-driver

    Buradaki aygıt sürücünün testi için üç ayrı program kullandık. "pipe-ioctl-test.c" programı bu IOCTL komutlarını aygıt 
    sürücüye yollamaktadır. Tabii test işlemini yalnızca bu programı değil başka bir termianlden daha önce yazmış olduğumuz 
    "pwriter" ve "preader" programlarını da çalıştırmalısınız. 

    Aşağıda tüm kodlar verilmiştir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>
#include <linux/slab.h>
#include "pipe-driver.h"

#define DEF_NDEVICES				10
#define DEF_PIPE_BUFFER_SIZE       	10
#define MAX_PIPE_BUFFER_SIZE		65535

#define MIN(a, b)	((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int ndevices = DEF_NDEVICES;
module_param(ndevices, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static dev_t g_dev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = pipe_driver_open,
	.read = pipe_driver_read,
	.write = pipe_driver_write,
	.release = pipe_driver_release,
	.unlocked_ioctl = pipe_driver_ioctl
};

struct PIPE_DEVICE {
	unsigned char *buf;
	size_t bufsize;
	size_t head;
	size_t tail;
	size_t count;
	struct semaphore sem;
	wait_queue_head_t wqwriteopen;
	wait_queue_head_t wqreadopen;
	wait_queue_head_t wqread;
	wait_queue_head_t wqwrite;
	int nreaders;
	int nwriters;
	struct cdev cdev;
};

static int set_bufsize(struct PIPE_DEVICE *pipedev, unsigned long size);
static int read_peek(struct PIPE_DEVICE *pdevice, unsigned long arg);

static struct PIPE_DEVICE **g_devices;

static int __init pipe_driver_init(void)
{
	int result;
	int i, k;
	dev_t dev;

	printk(KERN_INFO "pipe-driver init...\n");

	if ((result = alloc_chrdev_region(&g_dev, 0, ndevices, "pipe-driver")) < 0) {
		printk(KERN_ERR "cannot register device!...\n");
		goto EXIT1;
	}
	if ((g_devices = (struct PIPE_DEVICE **)kmalloc(sizeof(struct PIPE_DEVICE *) * ndevices, GFP_KERNEL)) == NULL) {
		result = -ENOMEM;
        goto EXIT2;
    }
	for (i = 0; i < ndevices; ++i) {
		if ((g_devices[i] = (struct PIPE_DEVICE *)kmalloc(sizeof(struct PIPE_DEVICE), GFP_KERNEL)) == NULL) {
			printk(KERN_ERR "cannot allocate pipe device!...\n");
			result = -ENOMEM;
			for (k = 0; k < i; ++k)	
				kfree(g_devices[k]);
			goto EXIT3;
		}
	}	
	for (i = 0; i < ndevices; ++i) {
		if ((g_devices[i]->buf = (unsigned char *)kmalloc(DEF_PIPE_BUFFER_SIZE, GFP_KERNEL)) == NULL) {
			printk(KERN_ERR "cannot allocate pipe buffer!...\n");
			result = -ENOMEM;
			for (k = 0; k < i; ++k)	
				kfree(g_devices[k]->buf);
			goto EXIT4;
		}
        g_devices[i]->head = g_devices[i]->tail = g_devices[i]->count = 0;
		g_devices[i]->bufsize = DEF_PIPE_BUFFER_SIZE;
        sema_init(&g_devices[i]->sem, 1);
	    init_waitqueue_head(&g_devices[i]->wqwriteopen);
        init_waitqueue_head(&g_devices[i]->wqreadopen);			
        init_waitqueue_head(&g_devices[i]->wqread);
        init_waitqueue_head(&g_devices[i]->wqwrite);
		g_devices[i]->nreaders = g_devices[i]->nwriters = 0;
	    cdev_init(&g_devices[i]->cdev, &g_fops);
        dev = MKDEV(MAJOR(g_dev), i);
        if ((result = cdev_add(&g_devices[i]->cdev, dev, 1)) < 0) {
            for (k = 0; k < i; ++k) 
                cdev_del(&g_devices[k]->cdev);
			printk(KERN_ERR "cannot add device!...\n");
        	goto EXIT5;
		}
    }	
	return 0;

EXIT5:
	for (i = 0; i < ndevices; ++i) 
		kfree(g_devices[i]->buf);
EXIT4:
	for (i = 0; i < ndevices; ++i) 
		kfree(g_devices[i]);
EXIT3:
	kfree(g_devices);
EXIT2:
	unregister_chrdev_region(g_dev, ndevices);
EXIT1:
	return result;
}

static void __exit pipe_driver_exit(void)
{
	int i;

    for (i = 0; i < ndevices; ++i)
		cdev_del(&g_devices[i]->cdev);
	for (i = 0; i < ndevices; ++i)
		kfree(g_devices[i]);
	kfree(g_devices);

	unregister_chrdev_region(g_dev, ndevices);
	
	printk(KERN_INFO "pipe-driver module exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
	struct PIPE_DEVICE *pipedev;
	int accmode = filp->f_flags & O_ACCMODE;

	pipedev = container_of(inodep->i_cdev, struct PIPE_DEVICE, cdev);
	filp->private_data = pipedev;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (accmode == O_RDONLY) {
		++pipedev->nreaders;
		wake_up_interruptible(&pipedev->wqwriteopen);
		while (pipedev->nwriters == 0) {
			up(&pipedev->sem);
			if (filp->f_flags & O_NONBLOCK)
				return 0;
			if (wait_event_interruptible(pipedev->wqreadopen, pipedev->nwriters > 0))
				return -ERESTARTSYS;
			if (down_interruptible(&pipedev->sem))
				return -ERESTARTSYS;
		}
	}
	else if (accmode == O_WRONLY) {
		++pipedev->nwriters;
		wake_up_interruptible(&pipedev->wqreadopen);
		while (pipedev->nreaders == 0) {
			if (filp->f_flags & O_NONBLOCK) {
				--pipedev->nwriters;
				up(&pipedev->sem);
				return -ENXIO;
			}
			up(&pipedev->sem);
			if (wait_event_interruptible(pipedev->wqwriteopen, pipedev->nreaders > 0))
				return -ERESTARTSYS;
			if (down_interruptible(&pipedev->sem))
				return -ERESTARTSYS;
		}
	}
	else if (accmode == O_RDWR) {
		++pipedev->nreaders;
		++pipedev->nwriters;
		wake_up_interruptible(&pipedev->wqreadopen);
		wake_up_interruptible(&pipedev->wqwriteopen);
	}
	up(&pipedev->sem);

	printk(KERN_INFO "pipe-driver opened...\n");
	
	return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
	struct PIPE_DEVICE *pipedev;
	int accmode = filp->f_flags & O_ACCMODE;

	pipedev = filp->private_data;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (accmode == O_RDONLY)
		--pipedev->nreaders;
	else if (accmode == O_WRONLY)
		--pipedev->nwriters;
	else if (accmode == O_RDWR) {
		--pipedev->nreaders;
		--pipedev->nwriters;
	}
	if (pipedev->nreaders == 0)
		wake_up_interruptible(&pipedev->wqwrite);
	if (pipedev->nwriters == 0)
		wake_up_interruptible(&pipedev->wqread);

	if (pipedev->nreaders + pipedev->nwriters == 0) 
		pipedev->count = pipedev->head = pipedev->tail = 0;

	up(&pipedev->sem);

	printk(KERN_INFO "pipe-driver closed...\n");

	return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
	size_t esize, size1, size2;
	ssize_t result = -EFAULT;
	struct PIPE_DEVICE *pipedev;

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	while (pipedev->count == 0) {
		if (pipedev->nwriters == 0) {
			result = 0;
			goto EXIT;
		}
		up(&pipedev->sem);
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		if (wait_event_interruptible(pipedev->wqread, pipedev->count > 0 || pipedev->nwriters == 0) != 0)
			return -ERESTARTSYS;
		if (down_interruptible(&pipedev->sem) != 0)
			return -ERESTARTSYS;
	}

	esize = MIN(size, pipedev->count);
	if (pipedev->head >= pipedev->tail)
		size1 = MIN(esize, pipedev->bufsize - pipedev->head);
	else
		size1 = esize;
	size2 = esize - size1;

	if (copy_to_user(buf, pipedev->buf + pipedev->head, size1) != 0)
		goto EXIT;

	if (size2 != 0)
		if (copy_to_user(buf + size1, pipedev->buf, size2) != 0)
			goto EXIT;

	pipedev->head = (pipedev->head + esize) % pipedev->bufsize;
	pipedev->count -= esize;

	result = esize;

	wake_up_interruptible(&pipedev->wqwrite);
EXIT:
	up(&pipedev->sem);

	return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
	size_t esize, size1, size2;
	ssize_t result = -EFAULT;
	struct PIPE_DEVICE *pipedev;

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (size > pipedev->bufsize)
		size = pipedev->bufsize;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (pipedev->nreaders == 0) {
		up(&pipedev->sem);
		send_sig(SIGPIPE, current, 0);
		return -EPIPE;
	}
	while (pipedev->bufsize - pipedev->count < size) {
		up(&pipedev->sem);
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		if (wait_event_interruptible(pipedev->wqwrite, pipedev->bufsize - pipedev->count >= size || pipedev->nreaders == 0) != 0)
			return -ERESTARTSYS;
		if (down_interruptible(&pipedev->sem) != 0)
			return -ERESTARTSYS;
		if (pipedev->nreaders == 0) {
			up(&pipedev->sem);
			send_sig(SIGPIPE, current, 0);
			return -EPIPE;
		}
	}

	esize = MIN(size, pipedev->bufsize - pipedev->count);

	if (pipedev->tail >= pipedev->head)
		size1 = MIN(esize, pipedev->bufsize - pipedev->tail);
	else
		size1 = esize;
	size2 = esize - size1;

	if (copy_from_user(pipedev->buf + pipedev->tail, buf, size1) != 0)
		goto EXIT;
	if (size2 != 0)
		if (copy_from_user(pipedev->buf, buf + size1, size2) != 0)
			goto EXIT;

	pipedev->tail = (pipedev->tail + esize ) % pipedev->bufsize;
	pipedev->count += esize;
	result = esize;

EXIT:
	wake_up_interruptible(&pipedev->wqread);
	up(&pipedev->sem);

	return result;
}

static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct PIPE_DEVICE *pipedev;
	int result;

	printk(KERN_INFO "ioctl\n");

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (down_interruptible(&pipedev->sem))
		return -ERESTARTSYS;

	switch (cmd) {
		case IOC_PIPE_GETNDEVICES:
			result =  put_user(ndevices, (size_t *)arg);
			break;
		case IOC_PIPE_GETCOUNT:
			result =  put_user(pipedev->count, (size_t *)arg);
			break;
		case IOC_PIPE_GETBUFSIZE:
			result = put_user(pipedev->bufsize, (size_t *)arg);
			break;
		case IOC_PIPE_SETBUFSIZE:
			result = set_bufsize(pipedev, arg);
			break;
		case IOC_PIPE_PEEK:
			result = read_peek(pipedev, arg);
			break;
		default:
			result = -ENOTTY;
	}

	up(&pipedev->sem);

	return result;
}

static int set_bufsize(struct PIPE_DEVICE *pipedev, unsigned long arg)
{
    char *newbuf;
    size_t size;
	
	if (arg > MAX_PIPE_BUFFER_SIZE)
        return -EINVAL;
   
	if (arg <= pipedev->count) 
		return -EINVAL;

    if ((newbuf = (char *)kmalloc(arg, GFP_KERNEL)) == NULL) 
		return -ENOMEM;
        
    if (pipedev->count != 0) {
        if (pipedev->tail <= pipedev->head) {
            size = pipedev->bufsize - pipedev->head;
            memcpy(newbuf, pipedev->buf + pipedev->head, size);
            memcpy(newbuf + size, pipedev->buf, pipedev->tail);
        }
        else
            memcpy(newbuf, pipedev->buf + pipedev->head, pipedev->count);
    }

    pipedev->head = 0;
    pipedev->tail = pipedev->count;
    kfree(pipedev->buf);
    pipedev->buf = newbuf;
    pipedev->bufsize = arg;

    return 0;
}

static int read_peek(struct PIPE_DEVICE *pipedev, unsigned long arg)
{
    size_t esize, size1, size2;
    struct PIPE_PEEK *userpp;
    struct PIPE_PEEK pp;
    
	userpp = (struct PIPE_PEEK *)arg;
	if (copy_from_user(&pp, userpp, sizeof(struct PIPE_PEEK)) != 0)
        return -EFAULT;

	if (pp.size == 0)
        return 0;

	esize = MIN(pipedev->count, pp.size);

	if (pipedev->tail >= pipedev->head)
		size1 = MIN(esize, pipedev->bufsize - pipedev->tail);
	else
		size1 = esize;
	size2 = esize - size1;

    if (copy_to_user(pp.buf, pipedev->buf + pipedev->head, size1) != 0) 
        return -EFAULT;
    if (size2 != 0)
        if (copy_to_user(pp.buf + size1, pipedev->buf, size2) != 0) 
            return -EFAULT;      
    
	if (put_user(esize, &userpp->size) != 0)
        return -EFAULT;

	return 0;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* loadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2
mode=666

/sbin/insmod ./${module}.ko ${@:3} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)

for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
    mknod -m $mode ${module}$i c $major $i
done

/* unloadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2

/sbin/rmmod ./$module.ko || exit 1
for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
done

/* pipe-driver.h */

#ifndef PIPE_DRIVER_H_
#define PIPE_DRIVER_H_

#include <linux/stddef.h>
#include <linux/ioctl.h>

#define PIPE_DRIVER_MAGIC           'p'

#define IOC_PIPE_GETNDEVICES        _IOR(PIPE_DRIVER_MAGIC, 0, size_t)
#define IOC_PIPE_GETCOUNT           _IOR(PIPE_DRIVER_MAGIC, 1, size_t)
#define IOC_PIPE_GETBUFSIZE         _IOR(PIPE_DRIVER_MAGIC, 2, size_t)
#define IOC_PIPE_SETBUFSIZE         _IO(PIPE_DRIVER_MAGIC, 3)
#define IOC_PIPE_PEEK               _IOWR(PIPE_DRIVER_MAGIC, 4, struct PIPE_PEEK)

struct PIPE_PEEK {
    size_t size;
    void *buf;
};

#endif

/* pipe-ioctl-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "pipe-driver.h"

void exit_sys(const char *msg);
void disp_pipe_info(int fd);

int main(int argc, char *argv[])
{
	int fd;
	struct PIPE_PEEK pp;
	unsigned char pbuf[1024];

    if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

	if ((fd = open(argv[1], O_RDONLY)) == -1)
		exit_sys("open");

	printf("Press ENTER to continue...\n");
	getchar();

	disp_pipe_info(fd);

	if (ioctl(fd, IOC_PIPE_SETBUFSIZE, 20ul) != 0) 
		exit_sys("ioctl");

	disp_pipe_info(fd);

	printf("number opf bytes to peek?");
	scanf("%zu", &pp.size);
	pp.buf = pbuf;

	if (ioctl(fd, IOC_PIPE_PEEK, &pp) != 0) 
		exit_sys("ioctl");

	pbuf[pp.size] = '\0';
	printf("Peek bytes: %s\n", pbuf);

	close(fd);

	return 0;
}

void disp_pipe_info(int fd)
{
	size_t ndevices, count, bufsize;

	if (ioctl(fd, IOC_PIPE_GETNDEVICES, &ndevices) != 0) 
		exit_sys("ioctl");
	printf("number of pipe: %zu\n", ndevices);

	if (ioctl(fd, IOC_PIPE_GETCOUNT, &count) != 0) 
		exit_sys("ioctl");
	printf("number of bytes in pipe: %zu\n", count);

	if (ioctl(fd, IOC_PIPE_GETBUFSIZE, &bufsize) != 0) 
		exit_sys("ioctl");
	printf("pipe buffer size: %zu\n", bufsize);
	
	printf("---------------------------\n");
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

    if ((fd = open(argv[1], O_WRONLY)) == -1)
        exit_sys("open");
    
    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        
        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE		8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
	int fd;
	char buf[BUFFER_SIZE];
	int n;
	ssize_t result;

	if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

	if ((fd = open(argv[1], O_RDONLY)) == -1)
		exit_sys("open");

	for (;;) {
		printf("Number of bytes to read? ");
		scanf("%d", &n);
		if (n == 0)
			break;
		if ((result = read(fd, buf, n)) == -1) {
			if (errno != EAGAIN)
				exit_sys("read");
			printf("pipe is empty, let's do something else...\n");
			continue;
		}
		if (result == 0) {
			putchar('\n');
			break;
		}
		buf[result] = '\0';
		printf("%jd bytes read: %s\n", (intmax_t)result, buf);
	}

	close(fd);

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
     Aşağıdaki örnekte boru aygıt sürücüsü için birkaç ioctl komutu uygulanmıştır. Buradaki IOCTL kodları şöyle oluşturulmuştur:

    #define PIPE_DRIVER_MAGIC           'p'
    
    #define IOC_PIPE_GETNDEVICES        _IOR(PIPE_DRIVER_MAGIC, 0, size_t)
    #define IOC_PIPE_GETCOUNT           _IOR(PIPE_DRIVER_MAGIC, 1, size_t)
    #define IOC_PIPE_GETBUFSIZE         _IOR(PIPE_DRIVER_MAGIC, 2, size_t)
    #define IOC_PIPE_SETBUFSIZE         _IO(PIPE_DRIVER_MAGIC, 3)
    #define IOC_PIPE_PEEK               _IOWR(PIPE_DRIVER_MAGIC, 4, struct PIPE_PEEK)

    Bu komut kodlarının ne yaptıklarını şöyle açıklayabiliriz:
    
    IOC_PIPE_GETCOUNT: Aygıt sürücünün kulllanabildiği boru sayısını (yani minör numara miktarını) elde etmek için 
    kullanılmaktadır.

    IOC_PIPE_GETCOUNT: Boruda o anda bulunan byte sayısını elde etmek için kullanılmaktadır.
    
    IOC_PIPE_GETNDEVICES: Kullanılmakta olan borunun uzunluğunu elde etmek için kullanılmaktadır. 

    IOC_PIPE_SETBUFSIZE: Kullanılmakta olan borunun uzunluğunu (yani buffer uzunluğunu) değiştirmekte kullanılmaktadır.

    IOC_PIPE_PEEK: Borudan okuma yapmakta kullamılır. Ancak okunanlar borudan atılmaz. 

     Bu örnek için yukarıda vermiş olduğumuz boru aygıt sürücüsünde bazı değişiklikler yaptık. Bu değişiklikler şunlardır:

    - Artık borunun uzunluğu PIPE_DEVICE yapısının içerisinde tutulmaya başlanmıştır:

    struct PIPE_DEVICE {
        unsigned char *buf;
        size_t bufsize;
        size_t head;
        size_t tail;
        size_t count;
        struct semaphore sem;
        wait_queue_head_t wqwriteopen;
        wait_queue_head_t wqreadopen;
        wait_queue_head_t wqread;
        wait_queue_head_t wqwrite;
        int nreaders;
        int nwriters;
        struct cdev cdev;
    };

    Buradaki bufsize elemanı ilgili borunun uzunluğunu belirtmektedir. Default uzunluk PIPE_DEF_BUFFER_SIZE değeri kadardır. 
    Bu değer örneğimizde test için kolaylık sağlamak amacıyla 10 olarak alınmıştır. Bu değişiklik sayesinde artık her minör 
    numaraya ilişkin  boru uzunlukları farklılaşabilecektir.

    - ioctl işlemleri farklı proseslerden aynı anda yapılabileceği için işlemlerin genel olarak senkronize edilmesi gerekir.

    - Aygıt sürücümüz içerisindeki ioctl fonksiyonu aşağıdaki gibi yazılmıştır:

    static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
    {
        struct PIPE_DEVICE *pipedev;
        int result;

        printk(KERN_INFO "ioctl\n");

        pipedev = (struct PIPE_DEVICE *)filp->private_data;

        if (down_interruptible(&pipedev->sem))
            return -ERESTARTSYS;

        switch (cmd) {
            case IOC_PIPE_GETNDEVICES:
                result =  put_user(ndevices, (size_t *)arg);
                break;
            case IOC_PIPE_GETCOUNT:
                result =  put_user(pipedev->count, (size_t *)arg);
                break;
            case IOC_PIPE_GETBUFSIZE:
                result = put_user(pipedev->bufsize, (size_t *)arg);
                break;
            case IOC_PIPE_SETBUFSIZE:
                result = set_bufsize(pipedev, arg);
                break;
            case IOC_PIPE_PEEK:
                result = read_peek(pipedev, arg);
                break;
            default:
                result = -ENOTTY;
        }

        up(&pipedev->sem);

        return result;
    }

    Burada biz ioctl fonksiyonun hemen başında bir kritik kod oluşturduk. Tabii kritik kodun mümkün olduğunca küçük bir kod
    parçasını içermesini sağlamalısınız. Ancak buradaki örneğimizde tüm fonksiyonu kilitlemenin önemli bir sakıncası yoktur. 
    set_busize fonksiyonu borunun kullandığı tamponu büyütme ya da küçültme işlevini yerine getirmektedir. peek_read fonksiyonu 
    ise borudan bilgiyi atmadan okuma yapmaktadır. Normal olarak borudan read fonksiyonu ile okuma yapıldığında okunanlar borudan 
    atılmaktadır. Ancak bu ioctl kodu ile borudan okuma yapıldığında okunanlar borudan atılmamaktadır. Bu ioctl kodu için aşağıdaki 
    gibi bir yapı oluşturulmuştur:

    struct PIPE_PEEK {
        size_t size;
        void *buf;
    };

    Yapının size elemanı kaç byte peek işleminin yapılacağını, buf elemanı ise peek edilen byte'ların yerleştirileceği adresi
    belirtmektedir. Tabii boruda mevcut olan byte sayısından daha fazla byte peek edilmek istenirse boruda olan kadar byte peek 
    edilmektedir. Peek edilen byte sayısı aygıt sürücü tarafından yapının size elemanına aktarılmaktadır. 

    Aygıt sürücümüzü yine "loadmulti" script'i ile aşağıdaki gibi yükleyebilirsiniz:

    $ sudo ./loadmulti 10 pipe-driver ndevices=10

    Aygıt sürücünün çekirdekten atılması da yine "unloadmulti" script'i ile aşağıdaki gibi yapılabilir:

    $ sudo ./unloadmulti 10 pipe-driver

    Buradaki aygıt sürücünün testi için üç ayrı program kullandık. "pipe-ioctl-test.c" programı bu IOCTL komutlarını aygıt 
    sürücüye yollamaktadır. Tabii test işlemini yalnızca bu programı değil başka bir termianlden daha önce yazmış olduğumuz 
    "pwriter" ve "preader" programlarını da çalıştırmalısınız. 

    Aşağıda tüm kodlar verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.h */

#ifndef PIPE_DRIVER_H_
#define PIPE_DRIVER_H_

#include <linux/stddef.h>
#include <linux/ioctl.h>

#define PIPE_DRIVER_MAGIC           'p'

#define IOC_PIPE_GETNDEVICES        _IOR(PIPE_DRIVER_MAGIC, 0, size_t)
#define IOC_PIPE_GETCOUNT           _IOR(PIPE_DRIVER_MAGIC, 1, size_t)
#define IOC_PIPE_GETBUFSIZE         _IOR(PIPE_DRIVER_MAGIC, 2, size_t)
#define IOC_PIPE_SETBUFSIZE         _IO(PIPE_DRIVER_MAGIC, 3)
#define IOC_PIPE_PEEK               _IOWR(PIPE_DRIVER_MAGIC, 4, struct PIPE_PEEK)

struct PIPE_PEEK {
    size_t size;
    void *buf;
};

#endif

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>
#include <linux/slab.h>
#include "pipe-driver.h"

#define DEF_NDEVICES				10
#define DEF_PIPE_BUFFER_SIZE       	10
#define MAX_PIPE_BUFFER_SIZE		65535

#define MIN(a, b)	((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int ndevices = DEF_NDEVICES;
module_param(ndevices, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static dev_t g_dev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = pipe_driver_open,
	.read = pipe_driver_read,
	.write = pipe_driver_write,
	.release = pipe_driver_release,
	.unlocked_ioctl = pipe_driver_ioctl
};

struct PIPE_DEVICE {
	unsigned char *buf;
	size_t bufsize;
	size_t head;
	size_t tail;
	size_t count;
	struct semaphore sem;
	wait_queue_head_t wqwriteopen;
	wait_queue_head_t wqreadopen;
	wait_queue_head_t wqread;
	wait_queue_head_t wqwrite;
	int nreaders;
	int nwriters;
	struct cdev cdev;
};

static int set_bufsize(struct PIPE_DEVICE *pipedev, unsigned long size);
static int read_peek(struct PIPE_DEVICE *pdevice, unsigned long arg);

static struct PIPE_DEVICE **g_devices;

static int __init pipe_driver_init(void)
{
	int result;
	int i, k;
	dev_t dev;

	printk(KERN_INFO "pipe-driver init...\n");

	if ((result = alloc_chrdev_region(&g_dev, 0, ndevices, "pipe-driver")) < 0) {
		printk(KERN_ERR "cannot register device!...\n");
		goto EXIT1;
	}
	if ((g_devices = (struct PIPE_DEVICE **)kmalloc(sizeof(struct PIPE_DEVICE *) * ndevices, GFP_KERNEL)) == NULL) {
		result = -ENOMEM;
        goto EXIT2;
    }
	for (i = 0; i < ndevices; ++i) {
		if ((g_devices[i] = (struct PIPE_DEVICE *)kmalloc(sizeof(struct PIPE_DEVICE), GFP_KERNEL)) == NULL) {
			printk(KERN_ERR "cannot allocate pipe device!...\n");
			result = -ENOMEM;
			for (k = 0; k < i; ++k)	
				kfree(g_devices[k]);
			goto EXIT3;
		}
	}	
	for (i = 0; i < ndevices; ++i) {
		if ((g_devices[i]->buf = (unsigned char *)kmalloc(DEF_PIPE_BUFFER_SIZE, GFP_KERNEL)) == NULL) {
			printk(KERN_ERR "cannot allocate pipe buffer!...\n");
			result = -ENOMEM;
			for (k = 0; k < i; ++k)	
				kfree(g_devices[k]->buf);
			goto EXIT4;
		}
        g_devices[i]->head = g_devices[i]->tail = g_devices[i]->count = 0;
		g_devices[i]->bufsize = DEF_PIPE_BUFFER_SIZE;
        sema_init(&g_devices[i]->sem, 1);
	    init_waitqueue_head(&g_devices[i]->wqwriteopen);
        init_waitqueue_head(&g_devices[i]->wqreadopen);			
        init_waitqueue_head(&g_devices[i]->wqread);
        init_waitqueue_head(&g_devices[i]->wqwrite);
		g_devices[i]->nreaders = g_devices[i]->nwriters = 0;
	    cdev_init(&g_devices[i]->cdev, &g_fops);
        dev = MKDEV(MAJOR(g_dev), i);
        if ((result = cdev_add(&g_devices[i]->cdev, dev, 1)) < 0) {
            for (k = 0; k < i; ++k) 
                cdev_del(&g_devices[k]->cdev);
			printk(KERN_ERR "cannot add device!...\n");
        	goto EXIT5;
		}
    }	
	return 0;

EXIT5:
	for (i = 0; i < ndevices; ++i) 
		kfree(g_devices[i]->buf);
EXIT4:
	for (i = 0; i < ndevices; ++i) 
		kfree(g_devices[i]);
EXIT3:
	kfree(g_devices);
EXIT2:
	unregister_chrdev_region(g_dev, ndevices);
EXIT1:
	return result;
}

static void __exit pipe_driver_exit(void)
{
	int i;

    for (i = 0; i < ndevices; ++i)
		cdev_del(&g_devices[i]->cdev);
	for (i = 0; i < ndevices; ++i)
		kfree(g_devices[i]);
	kfree(g_devices);

	unregister_chrdev_region(g_dev, ndevices);
	
	printk(KERN_INFO "pipe-driver module exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
	struct PIPE_DEVICE *pipedev;
	int accmode = filp->f_flags & O_ACCMODE;

	pipedev = container_of(inodep->i_cdev, struct PIPE_DEVICE, cdev);
	filp->private_data = pipedev;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (accmode == O_RDONLY) {
		++pipedev->nreaders;
		wake_up_interruptible(&pipedev->wqwriteopen);
		while (pipedev->nwriters == 0) {
			up(&pipedev->sem);
			if (filp->f_flags & O_NONBLOCK)
				return 0;
			if (wait_event_interruptible(pipedev->wqreadopen, pipedev->nwriters > 0))
				return -ERESTARTSYS;
			if (down_interruptible(&pipedev->sem))
				return -ERESTARTSYS;
		}
	}
	else if (accmode == O_WRONLY) {
		++pipedev->nwriters;
		wake_up_interruptible(&pipedev->wqreadopen);
		while (pipedev->nreaders == 0) {
			if (filp->f_flags & O_NONBLOCK) {
				--pipedev->nwriters;
				up(&pipedev->sem);
				return -ENXIO;
			}
			up(&pipedev->sem);
			if (wait_event_interruptible(pipedev->wqwriteopen, pipedev->nreaders > 0))
				return -ERESTARTSYS;
			if (down_interruptible(&pipedev->sem))
				return -ERESTARTSYS;
		}
	}
	else if (accmode == O_RDWR) {
		++pipedev->nreaders;
		++pipedev->nwriters;
		wake_up_interruptible(&pipedev->wqreadopen);
		wake_up_interruptible(&pipedev->wqwriteopen);
	}
	up(&pipedev->sem);

	printk(KERN_INFO "pipe-driver opened...\n");
	
	return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
	struct PIPE_DEVICE *pipedev;
	int accmode = filp->f_flags & O_ACCMODE;

	pipedev = filp->private_data;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (accmode == O_RDONLY)
		--pipedev->nreaders;
	else if (accmode == O_WRONLY)
		--pipedev->nwriters;
	else if (accmode == O_RDWR) {
		--pipedev->nreaders;
		--pipedev->nwriters;
	}
	if (pipedev->nreaders == 0)
		wake_up_interruptible(&pipedev->wqwrite);
	if (pipedev->nwriters == 0)
		wake_up_interruptible(&pipedev->wqread);

	if (pipedev->nreaders + pipedev->nwriters == 0) 
		pipedev->count = pipedev->head = pipedev->tail = 0;

	up(&pipedev->sem);

	printk(KERN_INFO "pipe-driver closed...\n");

	return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
	size_t esize, size1, size2;
	ssize_t result = -EFAULT;
	struct PIPE_DEVICE *pipedev;

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	while (pipedev->count == 0) {
		if (pipedev->nwriters == 0) {
			result = 0;
			goto EXIT;
		}
		up(&pipedev->sem);
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		if (wait_event_interruptible(pipedev->wqread, pipedev->count > 0 || pipedev->nwriters == 0) != 0)
			return -ERESTARTSYS;
		if (down_interruptible(&pipedev->sem) != 0)
			return -ERESTARTSYS;
	}

	esize = MIN(size, pipedev->count);
	if (pipedev->head >= pipedev->tail)
		size1 = MIN(esize, pipedev->bufsize - pipedev->head);
	else
		size1 = esize;
	size2 = esize - size1;

	if (copy_to_user(buf, pipedev->buf + pipedev->head, size1) != 0)
		goto EXIT;

	if (size2 != 0)
		if (copy_to_user(buf + size1, pipedev->buf, size2) != 0)
			goto EXIT;

	pipedev->head = (pipedev->head + esize) % pipedev->bufsize;
	pipedev->count -= esize;

	result = esize;

	wake_up_interruptible(&pipedev->wqwrite);
EXIT:
	up(&pipedev->sem);

	return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
	size_t esize, size1, size2;
	ssize_t result = -EFAULT;
	struct PIPE_DEVICE *pipedev;

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (size > pipedev->bufsize)
		size = pipedev->bufsize;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (pipedev->nreaders == 0) {
		up(&pipedev->sem);
		send_sig(SIGPIPE, current, 0);
		return -EPIPE;
	}
	while (pipedev->bufsize - pipedev->count < size) {
		up(&pipedev->sem);
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		if (wait_event_interruptible(pipedev->wqwrite, pipedev->bufsize - pipedev->count >= size || pipedev->nreaders == 0) != 0)
			return -ERESTARTSYS;
		if (down_interruptible(&pipedev->sem) != 0)
			return -ERESTARTSYS;
		if (pipedev->nreaders == 0) {
			up(&pipedev->sem);
			send_sig(SIGPIPE, current, 0);
			return -EPIPE;
		}
	}

	esize = MIN(size, pipedev->bufsize - pipedev->count);

	if (pipedev->tail >= pipedev->head)
		size1 = MIN(esize, pipedev->bufsize - pipedev->tail);
	else
		size1 = esize;
	size2 = esize - size1;

	if (copy_from_user(pipedev->buf + pipedev->tail, buf, size1) != 0)
		goto EXIT;
	if (size2 != 0)
		if (copy_from_user(pipedev->buf, buf + size1, size2) != 0)
			goto EXIT;

	pipedev->tail = (pipedev->tail + esize ) % pipedev->bufsize;
	pipedev->count += esize;
	result = esize;

EXIT:
	wake_up_interruptible(&pipedev->wqread);
	up(&pipedev->sem);

	return result;
}

static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct PIPE_DEVICE *pipedev;
	int result;

	printk(KERN_INFO "ioctl\n");

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (down_interruptible(&pipedev->sem))
		return -ERESTARTSYS;

	switch (cmd) {
		case IOC_PIPE_GETNDEVICES:
			result =  put_user(ndevices, (size_t *)arg);
			break;
		case IOC_PIPE_GETCOUNT:
			result =  put_user(pipedev->count, (size_t *)arg);
			break;
		case IOC_PIPE_GETBUFSIZE:
			result = put_user(pipedev->bufsize, (size_t *)arg);
			break;
		case IOC_PIPE_SETBUFSIZE:
			result = set_bufsize(pipedev, arg);
			break;
		case IOC_PIPE_PEEK:
			result = read_peek(pipedev, arg);
			break;
		default:
			result = -ENOTTY;
	}

	up(&pipedev->sem);

	return result;
}

static int set_bufsize(struct PIPE_DEVICE *pipedev, unsigned long arg)
{
    char *newbuf;
    size_t size;
	
	if (arg > MAX_PIPE_BUFFER_SIZE)
        return -EINVAL;
   
	if (arg <= pipedev->count) 
		return -EINVAL;

    if ((newbuf = (char *)kmalloc(arg, GFP_KERNEL)) == NULL) 
		return -ENOMEM;
        
    if (pipedev->count != 0) {
        if (pipedev->tail <= pipedev->head) {
            size = pipedev->bufsize - pipedev->head;
            memcpy(newbuf, pipedev->buf + pipedev->head, size);
            memcpy(newbuf + size, pipedev->buf, pipedev->tail);
        }
        else
            memcpy(newbuf, pipedev->buf + pipedev->head, pipedev->count);
    }

    pipedev->head = 0;
    pipedev->tail = pipedev->count;
    kfree(pipedev->buf);
    pipedev->buf = newbuf;
    pipedev->bufsize = arg;

    return 0;
}

static int read_peek(struct PIPE_DEVICE *pipedev, unsigned long arg)
{
    size_t esize, size1, size2;
    struct PIPE_PEEK *userpp;
    struct PIPE_PEEK pp;
    
	userpp = (struct PIPE_PEEK *)arg;
	if (copy_from_user(&pp, userpp, sizeof(struct PIPE_PEEK)) != 0)
        return -EFAULT;

	if (pp.size == 0)
        return 0;

	esize = MIN(pipedev->count, pp.size);

	if (pipedev->tail >= pipedev->head)
		size1 = MIN(esize, pipedev->bufsize - pipedev->tail);
	else
		size1 = esize;
	size2 = esize - size1;

    if (copy_to_user(pp.buf, pipedev->buf + pipedev->head, size1) != 0) 
        return -EFAULT;
    if (size2 != 0)
        if (copy_to_user(pp.buf + size1, pipedev->buf, size2) != 0) 
            return -EFAULT;      
    
	if (put_user(esize, &userpp->size) != 0)
        return -EFAULT;

	return 0;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* loadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2
mode=666

/sbin/insmod ./${module}.ko ${@:3} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)

for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
    mknod -m $mode ${module}$i c $major $i
done

/* unloadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2

/sbin/rmmod ./$module.ko || exit 1
for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
done

/* pipe-ioctl-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "pipe-driver.h"

void exit_sys(const char *msg);
void disp_pipe_info(int fd);

int main(int argc, char *argv[])
{
	int fd;
	struct PIPE_PEEK pp;
	unsigned char pbuf[1024];

    if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

	if ((fd = open(argv[1], O_RDONLY)) == -1)
		exit_sys("open");

	printf("Press ENTER to continue...\n");
	getchar();

	disp_pipe_info(fd);

	if (ioctl(fd, IOC_PIPE_SETBUFSIZE, 20ul) != 0) 
		exit_sys("ioctl");

	disp_pipe_info(fd);

	printf("number opf bytes to peek?");
	scanf("%zu", &pp.size);
	pp.buf = pbuf;

	if (ioctl(fd, IOC_PIPE_PEEK, &pp) != 0) 
		exit_sys("ioctl");

	pbuf[pp.size] = '\0';
	printf("Peek bytes: %s\n", pbuf);

	close(fd);

	return 0;
}

void disp_pipe_info(int fd)
{
	size_t ndevices, count, bufsize;

	if (ioctl(fd, IOC_PIPE_GETNDEVICES, &ndevices) != 0) 
		exit_sys("ioctl");
	printf("number of pipe: %zu\n", ndevices);

	if (ioctl(fd, IOC_PIPE_GETCOUNT, &count) != 0) 
		exit_sys("ioctl");
	printf("number of bytes in pipe: %zu\n", count);

	if (ioctl(fd, IOC_PIPE_GETBUFSIZE, &bufsize) != 0) 
		exit_sys("ioctl");
	printf("pipe buffer size: %zu\n", bufsize);
	
	printf("---------------------------\n");
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

    if ((fd = open(argv[1], O_WRONLY)) == -1)
        exit_sys("open");
    
    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        
        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE		8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
	int fd;
	char buf[BUFFER_SIZE];
	int n;
	ssize_t result;

	if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

	if ((fd = open(argv[1], O_RDONLY)) == -1)
		exit_sys("open");

	for (;;) {
		printf("Number of bytes to read? ");
		scanf("%d", &n);
		if (n == 0)
			break;
		if ((result = read(fd, buf, n)) == -1) {
			if (errno != EAGAIN)
				exit_sys("read");
			printf("pipe is empty, let's do something else...\n");
			continue;
		}
		if (result == 0) {
			putchar('\n');
			break;
		}
		buf[result] = '\0';
		printf("%jd bytes read: %s\n", (intmax_t)result, buf);
	}

	close(fd);

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                150. Ders 28/06/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
   Anımsanacağı gibi proc dosya sistemi disk tabanlı bir dosya sistemi değildir. proc dosya sistemi çekirdek çalışması sırasında 
    çekirdeğin dış dünyaya bilgi vermesi için bazen de davranışını dış dünyadan gelen bilgilerle değiştirebilmesi için tasarlanmıştır 
    Daha sonraları benzer amaçlarla sys isimli bir dosya sistemi de Linux'a eklenmiştir.

    proc dosya sistemi yalnızca çekirdek tarafından değil aygıt sürücüler tarafından da kullanılabilmektedir. Ancak bu dosya 
    sisteminin içerisinde kullanıcı modundan dosyalar ya da dizinler yaratılamamaktadır. proc dosya sistemindeki tüm girişlerin 
    dosya uzunlukları 0 biçiminde rapor edilmektedir. proc dosya sisteminin bütün kontrolü çekirdek tarafından çekirdeğin
    içerisindeki fonksiyonlarla sağlanmaktadır. Yani proc dosya sistemi çekirdeğin bir parçasını oluşturmaktadır.

    proc dosya sisteminin kullanımına yönelik çekirdek fonksiyonları çekirdeğin versiyonları ile zaman içerisinde birkaç kez 
    değiştirilmiştir. Dolayısıyla eski çekirdeklerde çalışan kodlar yeni çekirdeklerde derlenmeyecektir. Biz kursumuzda bu 
    fonksiyonların son hallerini ele alıp açıklayacağız.

    Aygıt sürücümüz proc dosya sisteminde bir dosya yaratmış olsun. Kullanıcı modundan bu dosya üzerinde open, read, write, 
    lseek, close gibi işlemler yapıldığında aslında aygıt sürücümüzün belirlediği fonksiyonlar çağrılmaktadır. Yani örneğin 
    biz kullanıcı modundan proc dosya sistemi içerisindeki bir dosyadan okuma yapmak istediğimizde aslında onu oluşturan 
    aygıt sürücünün içerisindeki bir okuma fonksiyonu çağrılmaktadır. Bu fonksiyon bize okuma sonucunda elde edilecek bilgileri 
    vermektedir. Benzer biçimde proc dosya sistemindeki bir dosyaya kullanıcı modundan yazma yapılmak istendiğinde aslında 
    o dosyayı yaratan aygıt sürücünün bir yazma fonksiyonu çağrılmaktadır. Yani proc dosya sistemi aslında bilgileri statik 
    biçimde tutan dosyalardan oluşmamaktadır. Dosyada bulunduğu varsayılan bilgiler talep edildiğinde aygıt sürücüler 
    tarafından kullanıcıya verilmektedir. 

    Aslında proc dosya sistemi üzerinde işlemler yapmak için bir aygıt sürücüsü oluşturulması zorunlu değildir. Çekirdek 
    modlleri de proc dosya süstemi üzerinde aşağıda açıklayacağımız biçimde işlemler yapabilir. Ancak biz temel örneklerimizi 
    yine de bir karakter aygıt sürücüsü üzerinde vereceğiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    proc dosya sisteminde bir dosya yaratabilmek için proc_create isimli fonksiyon kullanılmaktadır. Fonksiyonun prototipi 
    şöyledir:

    #include <linux/proc_fs.h>

    struct proc_dir_entry *proc_create(const char *name, umode_t mode, 
        struct proc_dir_entry *parent, const struct proc_ops *proc_ops);

    Fonksiyonun birinci parametresi proc dosya sisteminde yaratılacak olan dosyanın ismini belirtir. İkinci parametresi ise 
    erişim haklarını belirtmektedir. Bu parametre 0 geçilirse default erişim hakları kullanılır. Üçüncü parametre dosyanın 
    hangi dizinde yaratılacağını belirtmektedir. Bu parametre NULL geçilirse dosya ana "/proc" dizini içerisinde yaratılır. 
    proc dosya sistemi içerisinde dizinlerin nasıl yaratıldığını izleyen paragraflarda açıklayacağız. Son parametre proc dosya 
    sistemindeki ilgi dosyaya yazma ve okuma gibi işlemler yapıldığında çağrılacak fonksiyonları belirtmektredir. Aslında 
    Linux'un 3.10 çekirdeklerine kadarki çekirdeklerde bu fonksiyonun son parametresi proc_ops yapısını değil, file_operations 
    yapısını kullanıyordu. Dolayısıyla çekirdeğinizdeki fonksiyonun son parametresinin ne olduğuna dikkat ediniz. proc_ops 
    yapısı şöyle bildirilmiştir:

    #include <linux/proc_fs.h>

    struct proc_ops {
        unsigned int proc_flags;
        int    (*proc_open)(struct inode *, struct file *);
        ssize_t    (*proc_read)(struct file *, char __user *, size_t, loff_t *);
        ssize_t (*proc_read_iter)(struct kiocb *, struct iov_iter *);
        ssize_t    (*proc_write)(struct file *, const char __user *, size_t, loff_t *);
        /* mandatory unless nonseekable_open() or equivalent is used */
        loff_t    (*proc_lseek)(struct file *, loff_t, int);
        int    (*proc_release)(struct inode *, struct file *);
        __poll_t (*proc_poll)(struct file *, struct poll_table_struct *);
        long    (*proc_ioctl)(struct file *, unsigned int, unsigned long);
    #ifdef CONFIG_COMPAT
        long    (*proc_compat_ioctl)(struct file *, unsigned int, unsigned long);
    #endif
        int    (*proc_mmap)(struct file *, struct vm_area_struct *);
        unsigned long (*proc_get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
    };

    proc_ops yapısının elemanlarına ilişkin fonksiyon göstericilerinin türlerinin file_operations yapısındaki elemanlara ilişkin
    fonksiyon göstericilerinin türleri ile aynı olduğuna dikkat ediniz. Bu fonksiyonların kullanımı tamamen aygıt sürücü 
    için oluşturduğumuz file_operations yapısı ile aynı biçimdedir.

    proc dosya sistemi genel olarak text tabanlı bir dosya sistemi biçiminde düşünülmüştür. Yani buradaki dosyalar genel olarak 
    text içeriğe sahiptir. Siz de aygıt sürücünüz için proc dosya sisteminde dosya oluşturacaksanız onların içeriğini text 
    olarak oluşturmalısınız. (proc dosya sisteminde binary bir dosya içeriği oluşturmak mümkündür. Ancak kullanıcıların beklentisi
    bu yönde değildir.)

    proc_create fonksitonu başarı durumunda yaratılan dosyanın bilgilerini içeren proc_dir_entry türünden bir yapı nesnesinin 
    adresiyle, başarısızlık durumunda NULL adresle geri dönmektedir. Bu durumda çağıran fonksiyonun -ENOMEM gibi bir hata 
    değeriyle geri döndürülmesi yaygındır.

    proc dosya sisteminde yaratılan dosya remove_proc_entry fonksiyonuyla silinebilmektedir. Fonksiyonun parametrik yapısı 
    şöyledir:

    #include <linux/proc_fs.h>

    void remove_proc_entry(const char *name, struct proc_dir_entry *parent);

    Fonksiyonun birinci parametresi silinecek dosyanın ismini, ikinci parametresi dosyanın içinde bulunduğu dizine ilişkin 
    proc_dir_entry nesnesinin adresini almaktadır. Yine bu parametre NULL adres girilirse dosyanın ana "/proc" dizininde
    olduğu kabul edilmektedir. 

    proc dosya sisteminde yarattığınız dosyaları aygıt sürücüyü kaldırırken silmeyi unutmayınız. Aksi takdirde bu dosyalar 
    kullanılırken tüm sistem çökebilir. 

    Aşağıdaki örnekte proc dosya sisteminde dosya yaratan iskelet bir aygıt sürücü programı verilmiştir. Bu aygıt sürücüde 
    "/proc"  dizininde "proc-driver" isminde bir dosya yaratılmaktadır. Aygıt sürücüyü install ettikten sonra "/proc" 
    dizininde bu dosyanın yaratılıp yaratılmadığını kontrol ediniz. Biz bu örnekte ilgili dosyaya yazma yapılmasını da 
    sağladık. Örneğimizde bu dosya okunduğunda aslında aygıt sürücümiz içerisindeki int türdne g_val değişkeninin içerisindeki 
    değer sanki bir yazıymış gibi okunmaktadır:

    static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        static char valbuf[32];
        size_t esize, left;

        sprintf(valbuf, "%d\n", g_val);
        left = strlen(valbuf) - *off;
        esize = size > left ? left : size;

        if (copy_to_user(buf, valbuf + *off, esize) != 0) 
            return -EFAULT; 
        *off += esize;

        return esize;
    } 
    
    Benzer biçimde bu dosyaya yazma yapıldığında yazılan karakterler önce bir diziye yazılmış sonra g_val global değişkenine
    akratılmıştır:

    static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        static char valbuf[32 + 1];
        size_t esize;
        int val;
        int result;

        if (*off > 0)
            return 0;

        esize = size > 32 ? 32 : size;

        if (copy_from_user(valbuf, buf, esize) != 0) 
            return -EFAULT; 
        valbuf[esize] = '\0'; 
        if ((result = kstrtoint(valbuf, 10, &val)) != 0)
            return result;
            
        g_val = val;

        *off += esize;

        return esize;
    }

    Buradaki örnekte write işleminde dosya göstericisinin konumunun hiç dikkate alınmadığına dikkat ediniz. Yani örneğimizde
    parçalı yazıma olanak verilmemiştir. Gerçekten de aygıt sürücüleri yazanlar bu tür durumlarda parçalı yazmaya hatta 
    parçalı okumaya izin vermemektedir. 

    Test sırasında yazma işlemini aşağıdaki örnekte olduğu gibi yapmayı unutmayınız:

    echo "1000" | sudo tee /proc/proc-driver
---------------------------------------------------------------------------------------------------------------------------*/

/* proc-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
 #include <linux/proc_fs.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("proc-driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static int proc_open(struct inode *inodep, struct file *filp);
static int proc_release(struct inode *inodep, struct file *filp);
static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static struct proc_ops g_procops = {
    .proc_open = proc_open,
    .proc_read = proc_read,
    .proc_write = proc_write,
    .proc_release = proc_release
};

static int g_val = 1234;

static int __init generic_init(void)
{
    int result;

    printk(KERN_INFO "proc module initialization...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "proc-driver")) < 0) {
        printk(KERN_INFO "cannot alloc char driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "cannot allocate cdev!...\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_fops;

    if ((result = cdev_add(g_cdev, g_dev, 1)) < 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "cannot add device!...\n");
        return result;
    }

    if (proc_create("proc-driver", S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, NULL, &g_procops) == NULL) {
        printk(KERN_ERR "cannot create proc-driver file!..\n");
        cdev_del(g_cdev);
        unregister_chrdev_region(g_dev, 1);
        return -ENOMEM;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    remove_proc_entry("proc-driver", NULL);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "proc-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{  
    return 0;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{ 
    return 0;
}

static int proc_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc_open\n");

    return 0;
}

static int proc_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc_release\n");

    return 0;
}

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    static char valbuf[32];
    size_t esize, left;

    sprintf(valbuf, "%d\n", g_val);
    left = strlen(valbuf) - *off;
    esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf + *off, esize) != 0) 
        return -EFAULT; 
    *off += esize;

    return esize;
}

static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    static char valbuf[32 + 1];
    size_t esize;
    int val;
    int result;

    if (*off > 0)
        return 0;

    esize = size > 32 ? 32 : size;

    if (copy_from_user(valbuf, buf, esize) != 0) 
        return -EFAULT; 
    valbuf[esize] = '\0'; 
    if ((result = kstrtoint(valbuf, 10, &val)) != 0)
        return result;
        
    g_val = val;

    *off += esize;

    return esize;
}

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/*--------------------------------------------------------------------------------------------------------------------------
                                                151. Ders 30/06/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıdaki örneklerde dosyayı proc dosya sisteminin kök dizininde yarattık. İstersek proc dizininde bir dizin yaratıp 
    dosyalarımızı o dizinin içerisinde de oluşturabilirdik. Eğer aygıt sürücü içerisinde proc dosya sisteminde çok fazla dosya 
    yaratılacaksa bunların proc dizinin kökünde değil ayrı bir dizinde yaratılması daha iyi bir tekniktir.
    
    proc dosya sisteminde bir dizin yaratmak için proc_mkdir fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <linux/proc_fs.h>

    struct proc_dir_entry *proc_mkdir(const char *name, struct proc_dir_entry *parent);

    Fonksiyonun birinci parametresi yaratılacak dizinin ismini, ikinci parametresi dizinin hangi dizin içerisinde yaratılacağını 
    belirtir. Bu parametre NULL geçilirse dizin proc dosya sisteminin kök dizininde yaratılır. Buradan aldığımız geri dönüş 
    değerini proc_create fonksiyonunun parent parametresinde kullanırsak ilgili dosyamızı bu dizinde yaratmış oluruz. Tabii 
    benzer biçimde dizin içerisinde dizin de yaratabiliriz. proc_mkdir fonksiyonu başarısızlık durumunda NULL adrese geri 
    dönmektedir. Başarısızlık durumunda çağıran fonksiyonun yine -ENOMEM değeriyle geri döndürülmesi uygundur. Örneğin:

    struct proc_dir_entry *pdir;
    ...

    if ((pdir = proc_mkdir("procfs-driver", NULL)) == NULL) 
        return -ENOMEM;

    if (proc_create("info", 0, pdir, &g_proc_ops) == NULL) {
        ...
        return -ENOMEM;
    }

    Dizinlerin silinmesi yine remove_proc_entry fonksiyonuyla yapılmaktadır. Tabii dizin içerisindeki dosyaları silerken 
    remove_proc_entry fonksiyonunda dosyanın hangi dizin içerisinde olduğu belirtilmelidir. Bu fonksiyon ile dizin silinirken 
    dizinin içi boş değilse bile o dizin ve onun içindeki girişlerin hepsi silinmektedir. (Halbuki disk tabanlı dosya sistemlerinde 
    ancak içi boş olan dizinler silinebilmektedir.) Ayrıca kök dizindeki girişleri silmek için proc_remove fonksiyonu da 
    bulundurulmuştur. Fonksiyonun prototipi şöyledir:

    #include <linux/proc_fs.h>

    void proc_remove(struct proc_dir_entry *de);

    Bu fonksiyon parametre olarak proc_create ya da proc_mkdir fonksiyonunun verdiği geri dönüş değerini alır. proc dosya 
    sisteminin kök dizininde silme yapılmak isteniyorsa aşağıdaki her iki çağrım eşdeğerdir:

    remove_proc_entry("file_name", NULL);
    proc_remove(pde);

    Aşağıdaki örnekte "proc-driver" isimli aygıt sürücüsünde önce proc dosya sisteminin kök dizininde "proc-driver" isimli 
    dizin yaratılmış onun da içerisinde "val" isimli bir dosya yaratmıştır. Sonra da bu dosyadan okuma yapıldığında aygıt 
    sürücü içerisindeki g_val değişkenindeki değer verilmiştir. Bu dosyaya yazma yapıldığında ise yazılan değer g_val 
    değişkenine yerleştirilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* proc-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/proc_fs.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("proc-driver");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static int proc_open(struct inode *inodep, struct file *filp);
static int proc_release(struct inode *inodep, struct file *filp);
static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_fops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .read = generic_read,
    .write = generic_write,
    .release = generic_release
};

static struct proc_ops g_procops = {
    .proc_open = proc_open,
    .proc_read = proc_read,
    .proc_write = proc_write,
    .proc_release = proc_release
};

static int g_val = 1234;

static int __init generic_init(void)
{
    int result;
    struct proc_dir_entry *dir;

    printk(KERN_INFO "proc module initialization...\n");

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "proc-driver")) < 0) {
        printk(KERN_INFO "cannot alloc char driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "cannot allocate cdev!...\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_fops;

    if ((result = cdev_add(g_cdev, g_dev, 1)) < 0) {    
        printk(KERN_ERR "cannot add device!...\n");
        goto EXIT1;
    }

    if ((dir = proc_mkdir("proc-driver", NULL)) == NULL) {
        printk(KERN_ERR "cannot create proc-driver directory!..\n");
        result = -ENOMEM;
        goto EXIT2;
    }

    if (proc_create("val", S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, dir, &g_procops) == NULL) {
        printk(KERN_ERR "cannot create val file!..\n");
        result = -ENOMEM;
        goto EXIT3;
    }

    return 0;

EXIT3:
    remove_proc_entry("proc-driver", NULL);
EXIT2:
    cdev_del(g_cdev);
EXIT1:
   unregister_chrdev_region(g_dev, 1);

    return result;
}

static void __exit generic_exit(void)
{
    remove_proc_entry("proc-driver", NULL);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "proc-driver module exit...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc-driver opened...\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc-driver closed...\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{  
    return 0;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{ 
    return 0;
}

static int proc_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc_open\n");

    return 0;
}

static int proc_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "proc_release\n");

    return 0;
}

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    static char valbuf[32];
    size_t esize, left;

    sprintf(valbuf, "%d\n", g_val);
    left = strlen(valbuf) - *off;
    esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf + *off, esize) != 0) 
        return -EFAULT; 
    *off += esize;

    return esize;
}

static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    static char valbuf[32 + 1];
    size_t esize;
    int val;
    int result;

    if (*off > 0)
        return 0;

    esize = size > 32 ? 32 : size;

    if (copy_from_user(valbuf, buf, esize) != 0) 
        return -EFAULT; 
    valbuf[esize] = '\0'; 
    if ((result = kstrtoint(valbuf, 10, &val)) != 0)
        return result;
    
    g_val = val;

    *off += esize;

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module


/*--------------------------------------------------------------------------------------------------------------------------
                                                152. Ders 06/07/2024 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                153. Ders 07/07/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de daha önce yazmış olduğumuz boru aygıt sürücüsüne proc dosya sistemi desteği verelim. Bunun için proc dosya 
    sisteminde    aşağıdaki gibi bir dizin ve dosya yapısı kullanacak olalım:

    /proc
        pipe-driver <DIR>
            pipe-0 <DIR>
                bufsize
                count
            pipe-1 <DIR>
                bufsize
                count
            pipe-2 <DIR>
                bufsize
                count
            pipe-3 <DIR>
                bufsize
                count
            ...
        
    Örneğimizde "/proc" dizinin kök dizininde "pipe-driver" isimli bir dizin, bu dizinin içerisinde de minör numara kadar 
    "pipe-N" dizinleri yaratılacaktır. Her "pipe-N" dizinin içerisinde "bufsize" ve "count" isminde iki dosya bulundurulacaktır.
    "bufsize" dosyası read/write, count dosyası ise read-only biçimde olacaktır. Böylece bir kişi hiç ioctl yapmadan boruların 
    uzunluklarını alıp değiştirebilecek ve bir borunun içerisinde kaç byte olduğunu anlayabilecektir. 

    Yukarıdaki gibi bir örnek için proc dosya sistemi desteğini sağlarken sorun oluşturabilecek iki önemli nokta vardır:

    1) Birden fazla proc dosyasıyla işlem yaparken her dosya için ayrı bir proc_read, proc_write fonksiyonu oluşturmak oldukça
    zahmetlidir. İdeal olan durum tek bir proc_read, proc_write fonksiyonu yazıp bu fonksiyonun birden fazla dosya üzerinde 
    işlem yapabilmesini sağlamaktır. 

    2) Boru aygıt sürücüsü örneğimizde birden fazla minör numaraya ilişkin birden fazla boru söz konusudur. Dolayısıyla bizim 
    kod içerisinde bir biçimde hangi boru üzerinde işlem yapıldığını bilmemiz gerekir. 

    İşte proc dosya sisteminde bir dosya yaratmak için kullandığımız proc_create fonksiyonunun proc_create_data isimli bir
    biçimi de vardır. proc_create_data fonksiyonunun prototipi şöyledir:

    struct proc_dir_entry *proc_create_data(const char *name, umode_t mode, struct proc_dir_entry *parent, 
        const struct proc_ops *proc_ops, void *data);

    Linux çekirdeğinin 5.17 versiyonundan öncesinde buradaki data adresi proc_dir_entry yapısı içerisindeki data elemanına 
    yerleştiriliyordu. Bu versiyonlarda inode nesnesi yoluyla proc dosyasına ilişkin proc_dir_entry yapısına ise PDE_DATA 
    isimli fonksiyonla erişiliyordu. Erişimde kullanılan fonksiyonları ver yapıları aşağıda veriyoruz:

    void *PDE_DATA(const struct inode *inode)
    {
        return __PDE_DATA(inode);
    }

    static inline void *__PDE_DATA(const struct inode *inode)
    {
        return PDE(inode)->data;
    }

    static inline struct proc_dir_entry *PDE(const struct inode *inode)
    {
        return PROC_I(inode)->pde;
    }

    static inline struct proc_inode *PROC_I(const struct inode *inode)
    {
        return container_of(inode, struct proc_inode, vfs_inode);
    }

    struct proc_inode {
        struct pid *pid;
        unsigned int fd;
        union proc_op op;
        struct proc_dir_entry *pde;
        struct ctl_table_header *sysctl;
        struct ctl_table *sysctl_entry;
        struct hlist_node sibling_inodes;
        const struct proc_ns_operations *ns_ops;
        struct inode vfs_inode;
    } __randomize_layout;

    file yapısından inode yapısına daha hızlı erişimi sağlamak için belli bir versiyondan sonra file yapısının içerisine
    f_inode elemanının eklendiğinden bahsetmiştik. Bu işlemin geçmişe ve geleceğe doğru uyumu koruyarak yapılmasını sağlamak 
    için ise file_inode fonksiyonu bulundurulmuştur. Bu fonksiyonunun mevcut çekirdeklerdeki tanımlması şöyle yapılmıştır:

    static inline struct inode *file_inode(const struct file *filp)
    {
        return filp->f_inode;
    }

    O halde 5.17 öncesi çekirdeklerde verilen bu adres filp göstericisi yoluyla şöyle elde edilmektedir:

    data = PDE_DATA(file_inode(filp));

    Ancak 5.17 çekirdeğinden itibaren artık proc_create_data fonksiyonuna verilen data adresi doğrudan i_node nesnesinin
    i_private elemanına yerleştirilmektedir. Dolayısıyla yeni çekirdeklerde artık proc_create_data fonksiyonuna geçirilen 
    data parametresine şöyle erişilmektedir:

    data = file_inode(filp)->i_private;

    Aslında yeni çekirdeklerde inode nesnesinin adresinden hareketle inonde nesnesinin i_private elemanını veren pde_data 
    isimli ayrı bir fonksiyon da bulunmaktadır:

    static inline void *pde_data(const struct inode *inode)
    {
        return inode->i_private;
    }

    O halde yeni çekirdeklerde proc_create_data fonksiyonuna girilen data adresi şöyle de elde edilebilmektedir:

    data = pde_data(file_inode(filp));

    Örneğimizde proc_create_data fonksiyonuna aşağıdaki yapı türünden nesnenin adresi geçirilmiştir:

    struct PROC_FILE_INFO {
        struct PIPE_DEVICE *pipedev;
        int procfile;	
    };

    Yapının procfile elemanı hangi proc dosyasının kullanıldığını belirtmektedir. Bu değerin 0 olması bufsize dosyasının 
    1 olması ise count dosyasının kullanıldığı anlamına gelmektedir:

    for (i = 0; i < ndevices; ++i) {
		sprintf(pname, "pipe-%d", i);
		if ((pdir2 = proc_mkdir(pname, pdir1)) == NULL) 
			goto EXIT2;;
	
		pfi = &g_proc_info[i * 2];
		pfi->pipedev = g_devices[i];	
		pfi->procfile = 0;

		if (proc_create_data("bufsize", S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, pdir2, &g_procops, pfi) == NULL)
			goto EXIT2;

		pfi = &g_proc_info[i * 2 + 1];
		pfi->pipedev = g_devices[i];
		pfi->procfile = 1;
		if (proc_create_data("count", S_IRUSR|S_IRGRP|S_IROTH, pdir2, &g_procops, pfi) == NULL)
			goto EXIT2;
	}

    Örneğimizdeki proc_read fonksiyonu şöyle yazılmıştır:

    static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        struct PROC_FILE_INFO *pfi;
        static char valbuf[32];
        ssize_t result;
        size_t esize, left;

        pfi = (struct PROC_FILE_INFO *)pde_data(file_inode(filp));

        if (*off > 0)
            return 0;

        if (down_interruptible(&pfi->pipedev->sem))
            return -ERESTARTSYS;

        if (pfi->procfile == 0) 								// bufsize
            sprintf(valbuf, "%zu\n", pfi->pipedev->bufsize);
        else if (pfi->procfile == 1) 
            sprintf(valbuf, "%zu\n", pfi->pipedev->count);		// count
        else {										
            result = 0;
            goto EXIT;
        }

        left = strlen(valbuf);
        esize = size > left ? left : size;

        if (copy_to_user(buf, valbuf, esize) != 0)  {
            result = -EFAULT; 
            goto EXIT;
        }
        *off += esize;
        result = esize;
    EXIT:
        up(&pfi->pipedev->sem);
        
        return result;
    }

    Bu fonksiyonda parçalı okumaya izin verilmemektedir. proc_write fonksiyonu da benzer biçimde yazılmıştır:

    static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        struct PROC_FILE_INFO *pfi;
        static char valbuf[32];
        size_t esize;
        ssize_t  result;
        int val;

        pfi = (struct PROC_FILE_INFO *)pde_data(file_inode(filp));

        if (*off > 0)
            return 0;

        if (down_interruptible(&pfi->pipedev->sem))
            return -ERESTARTSYS;

        if (pfi->procfile == 0) { 								// bufsize
            esize = size > 32 ? 32 : size;
            if (copy_from_user(valbuf, buf, esize) != 0) {
                result = -EFAULT; 
                goto EXIT;
            }
            valbuf[esize] = '\0'; 
            if ((result = kstrtoint(valbuf, 10, &val)) != 0) 
                goto EXIT;
            if ((result = set_bufsize(pfi->pipedev, val)) != 0)
                goto EXIT;
            *off += esize;
        }
        else 									
            result = 0;
        result = esize;
    EXIT:
        up(&pfi->pipedev->sem);
        
        return result;
    }

    Bu fonksiyonda da parçalı okumaya izin verilmediğine dikkat ediniz. Örneğin tüm kodlarını aşağıda veriyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.h */

#ifndef PIPE_DRIVER_H_
#define PIPE_DRIVER_H_

#include <linux/stddef.h>
#include <linux/ioctl.h>

#define PIPE_DRIVER_MAGIC           'p'

#define IOC_PIPE_GETNDEVICES        _IOR(PIPE_DRIVER_MAGIC, 0, size_t)
#define IOC_PIPE_GETCOUNT           _IOR(PIPE_DRIVER_MAGIC, 1, size_t)
#define IOC_PIPE_GETBUFSIZE         _IOR(PIPE_DRIVER_MAGIC, 2, size_t)
#define IOC_PIPE_SETBUFSIZE         _IO(PIPE_DRIVER_MAGIC, 3)
#define IOC_PIPE_PEEK               _IOWR(PIPE_DRIVER_MAGIC, 4, struct PIPE_PEEK)

struct PIPE_PEEK {
    size_t size;
    void *buf;
};

#endif

/* pipe-driver.c */

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/semaphore.h>
#include <linux/wait.h>
#include <linux/slab.h>
#include <linux/proc_fs.h>
#include "pipe-driver.h"

#define DEF_NDEVICES				10
#define DEF_PIPE_BUFFER_SIZE       	10
#define MAX_PIPE_BUFFER_SIZE		65535

#define MIN(a, b)	((a) < (b) ? (a) : (b))

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Pipe Device Driver");

static int ndevices = DEF_NDEVICES;
module_param(ndevices, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int create_proc_files(void);
static int pipe_driver_open(struct inode *inodep, struct file *filp);
static int pipe_driver_release(struct inode *inodep, struct file *filp);
static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static dev_t g_dev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = pipe_driver_open,
	.read = pipe_driver_read,
	.write = pipe_driver_write,
	.release = pipe_driver_release,
	.unlocked_ioctl = pipe_driver_ioctl
};

static int proc_open(struct inode *inodep, struct file *filp);
static int proc_release(struct inode *inodep, struct file *filp);
static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static struct proc_ops g_procops = {
    .proc_open = proc_open,
    .proc_read = proc_read,
    .proc_write = proc_write,
    .proc_release = proc_release
};

struct PIPE_DEVICE {
	unsigned char *buf;
	size_t bufsize;
	size_t head;
	size_t tail;
	size_t count;
	struct semaphore sem;
	wait_queue_head_t wqwriteopen;
	wait_queue_head_t wqreadopen;
	wait_queue_head_t wqread;
	wait_queue_head_t wqwrite;
	int nreaders;
	int nwriters;
	struct cdev cdev;
};

struct PROC_FILE_INFO {
	struct PIPE_DEVICE *pipedev;
	int procfile;	
};

static int set_bufsize(struct PIPE_DEVICE *pipedev, unsigned long size);
static int read_peek(struct PIPE_DEVICE *pdevice, unsigned long arg);

static struct PIPE_DEVICE **g_devices;
struct PROC_FILE_INFO *g_proc_info;

static int __init pipe_driver_init(void)
{
	int result;
	int i, k;
	dev_t dev;

	printk(KERN_INFO "pipe-driver init...\n");

	if ((result = alloc_chrdev_region(&g_dev, 0, ndevices, "pipe-driver")) < 0) {
		printk(KERN_ERR "cannot register device!...\n");
		goto EXIT1;
	}
	if ((g_devices = (struct PIPE_DEVICE **)kmalloc(sizeof(struct PIPE_DEVICE *) * ndevices, GFP_KERNEL)) == NULL) {
		result = -ENOMEM;
        goto EXIT2;
    }
	for (i = 0; i < ndevices; ++i) {
		if ((g_devices[i] = (struct PIPE_DEVICE *)kmalloc(sizeof(struct PIPE_DEVICE), GFP_KERNEL)) == NULL) {
			printk(KERN_ERR "cannot allocate pipe device!...\n");
			result = -ENOMEM;
			for (k = 0; k < i; ++k)	
				kfree(g_devices[k]);
			goto EXIT3;
		}
	}	
	for (i = 0; i < ndevices; ++i) {
		if ((g_devices[i]->buf = (unsigned char *)kmalloc(DEF_PIPE_BUFFER_SIZE, GFP_KERNEL)) == NULL) {
			printk(KERN_ERR "cannot allocate pipe buffer!...\n");
			result = -ENOMEM;
			for (k = 0; k < i; ++k)	
				kfree(g_devices[k]->buf);
			goto EXIT4;
		}
        g_devices[i]->head = g_devices[i]->tail = g_devices[i]->count = 0;
		g_devices[i]->bufsize = DEF_PIPE_BUFFER_SIZE;
        sema_init(&g_devices[i]->sem, 1);
	    init_waitqueue_head(&g_devices[i]->wqwriteopen);
        init_waitqueue_head(&g_devices[i]->wqreadopen);			
        init_waitqueue_head(&g_devices[i]->wqread);
        init_waitqueue_head(&g_devices[i]->wqwrite);
		g_devices[i]->nreaders = g_devices[i]->nwriters = 0;
	    cdev_init(&g_devices[i]->cdev, &g_fops);
        dev = MKDEV(MAJOR(g_dev), i);
        if ((result = cdev_add(&g_devices[i]->cdev, dev, 1)) < 0) {
            for (k = 0; k < i; ++k) 
                cdev_del(&g_devices[k]->cdev);
			printk(KERN_ERR "cannot add device!...\n");
        	goto EXIT5;
		}
    }	
	if (create_proc_files() != 0)
		goto EXIT6;

	return 0;

EXIT6:
	for (i = 0; i < ndevices; ++i)
		cdev_del(&g_devices[k]->cdev);
EXIT5:
	for (i = 0; i < ndevices; ++i) 
		kfree(g_devices[i]->buf);
EXIT4:
	for (i = 0; i < ndevices; ++i) 
		kfree(g_devices[i]);
EXIT3:
	kfree(g_devices);
EXIT2:
	unregister_chrdev_region(g_dev, ndevices);
EXIT1:
	return result;
}

static int create_proc_files(void)
{
	struct proc_dir_entry *pdir1, *pdir2;
	int i;
	char pname[16];
	struct PROC_FILE_INFO *pfi;

	if ((pdir1 = proc_mkdir("pipe-driver", NULL)) == NULL)
		return -1;

	if ((g_proc_info = (struct PROC_FILE_INFO *)kmalloc(sizeof(struct PROC_FILE_INFO) * ndevices * 2, GFP_KERNEL)) == NULL)
		goto EXIT1;

	for (i = 0; i < ndevices; ++i) {
		sprintf(pname, "pipe-%d", i);
		if ((pdir2 = proc_mkdir(pname, pdir1)) == NULL) 
			goto EXIT2;;
	
		pfi = &g_proc_info[i * 2];
		pfi->pipedev = g_devices[i];	
		pfi->procfile = 0;

		if (proc_create_data("bufsize", S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, pdir2, &g_procops, pfi) == NULL)
			goto EXIT2;

		pfi = &g_proc_info[i * 2 + 1];
		pfi->pipedev = g_devices[i];
		pfi->procfile = 1;
		if (proc_create_data("count", S_IRUSR|S_IRGRP|S_IROTH, pdir2, &g_procops, pfi) == NULL)
			goto EXIT2;
	}

	return 0;

EXIT2:
	kfree(g_proc_info);
EXIT1:
	remove_proc_entry("pipe-driver", NULL);

	return -1;
}

static void __exit pipe_driver_exit(void)
{
	int i;

	kfree(g_proc_info);
	remove_proc_entry("pipe-driver", NULL);
    for (i = 0; i < ndevices; ++i)
		cdev_del(&g_devices[i]->cdev);
	for (i = 0; i < ndevices; ++i)
		kfree(g_devices[i]);
	kfree(g_devices);

	unregister_chrdev_region(g_dev, ndevices);
	
	printk(KERN_INFO "pipe-driver module exit...\n");
}

static int pipe_driver_open(struct inode *inodep, struct file *filp)
{
	struct PIPE_DEVICE *pipedev;
	int accmode = filp->f_flags & O_ACCMODE;

	pipedev = container_of(inodep->i_cdev, struct PIPE_DEVICE, cdev);
	filp->private_data = pipedev;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (accmode == O_RDONLY) {
		++pipedev->nreaders;
		wake_up_interruptible(&pipedev->wqwriteopen);
		while (pipedev->nwriters == 0) {
			up(&pipedev->sem);
			if (filp->f_flags & O_NONBLOCK)
				return 0;
			if (wait_event_interruptible(pipedev->wqreadopen, pipedev->nwriters > 0))
				return -ERESTARTSYS;
			if (down_interruptible(&pipedev->sem))
				return -ERESTARTSYS;
		}
	}
	else if (accmode == O_WRONLY) {
		++pipedev->nwriters;
		wake_up_interruptible(&pipedev->wqreadopen);
		while (pipedev->nreaders == 0) {
			if (filp->f_flags & O_NONBLOCK) {
				--pipedev->nwriters;
				up(&pipedev->sem);
				return -ENXIO;
			}
			up(&pipedev->sem);
			if (wait_event_interruptible(pipedev->wqwriteopen, pipedev->nreaders > 0))
				return -ERESTARTSYS;
			if (down_interruptible(&pipedev->sem))
				return -ERESTARTSYS;
		}
	}
	else if (accmode == O_RDWR) {
		++pipedev->nreaders;
		++pipedev->nwriters;
		wake_up_interruptible(&pipedev->wqreadopen);
		wake_up_interruptible(&pipedev->wqwriteopen);
	}
	up(&pipedev->sem);

	printk(KERN_INFO "pipe-driver opened...\n");
	
	return 0;
}

static int pipe_driver_release(struct inode *inodep, struct file *filp)
{
	struct PIPE_DEVICE *pipedev;
	int accmode = filp->f_flags & O_ACCMODE;

	pipedev = filp->private_data;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (accmode == O_RDONLY)
		--pipedev->nreaders;
	else if (accmode == O_WRONLY)
		--pipedev->nwriters;
	else if (accmode == O_RDWR) {
		--pipedev->nreaders;
		--pipedev->nwriters;
	}
	if (pipedev->nreaders == 0)
		wake_up_interruptible(&pipedev->wqwrite);
	if (pipedev->nwriters == 0)
		wake_up_interruptible(&pipedev->wqread);

	if (pipedev->nreaders + pipedev->nwriters == 0) 
		pipedev->count = pipedev->head = pipedev->tail = 0;
		
	up(&pipedev->sem);

	printk(KERN_INFO "pipe-driver closed...\n");

	return 0;
}

static ssize_t pipe_driver_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
	size_t esize, size1, size2;
	ssize_t result = -EFAULT;
	struct PIPE_DEVICE *pipedev;

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	while (pipedev->count == 0) {
		if (pipedev->nwriters == 0) {
			result = 0;
			goto EXIT;
		}
		up(&pipedev->sem);
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		if (wait_event_interruptible(pipedev->wqread, pipedev->count > 0 || pipedev->nwriters == 0) != 0)
			return -ERESTARTSYS;
		if (down_interruptible(&pipedev->sem) != 0)
			return -ERESTARTSYS;
	}

	esize = MIN(size, pipedev->count);
	if (pipedev->head >= pipedev->tail)
		size1 = MIN(esize, pipedev->bufsize - pipedev->head);
	else
		size1 = esize;
	size2 = esize - size1;

	if (copy_to_user(buf, pipedev->buf + pipedev->head, size1) != 0)
		goto EXIT;

	if (size2 != 0)
		if (copy_to_user(buf + size1, pipedev->buf, size2) != 0)
			goto EXIT;

	pipedev->head = (pipedev->head + esize) % pipedev->bufsize;
	pipedev->count -= esize;

	result = esize;

	wake_up_interruptible(&pipedev->wqwrite);
EXIT:
	up(&pipedev->sem);

	return result;
}

static ssize_t pipe_driver_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
	size_t esize, size1, size2;
	ssize_t result = -EFAULT;
	struct PIPE_DEVICE *pipedev;

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (size > pipedev->bufsize)
		size = pipedev->bufsize;

	if (down_interruptible(&pipedev->sem) != 0)
		return -ERESTARTSYS;

	if (pipedev->nreaders == 0) {
		up(&pipedev->sem);
		send_sig(SIGPIPE, current, 0);
		return -EPIPE;
	}
	while (pipedev->bufsize - pipedev->count < size) {
		up(&pipedev->sem);
		if (filp->f_flags & O_NONBLOCK)
			return -EAGAIN;
		if (wait_event_interruptible(pipedev->wqwrite, pipedev->bufsize - pipedev->count >= size || pipedev->nreaders == 0) != 0)
			return -ERESTARTSYS;
		if (down_interruptible(&pipedev->sem) != 0)
			return -ERESTARTSYS;
		if (pipedev->nreaders == 0) {
			up(&pipedev->sem);
			send_sig(SIGPIPE, current, 0);
			return -EPIPE;
		}
	}

	esize = MIN(size, pipedev->bufsize - pipedev->count);

	if (pipedev->tail >= pipedev->head)
		size1 = MIN(esize, pipedev->bufsize - pipedev->tail);
	else
		size1 = esize;
	size2 = esize - size1;

	if (copy_from_user(pipedev->buf + pipedev->tail, buf, size1) != 0)
		goto EXIT;
	if (size2 != 0)
		if (copy_from_user(pipedev->buf, buf + size1, size2) != 0)
			goto EXIT;

	pipedev->tail = (pipedev->tail + esize ) % pipedev->bufsize;
	pipedev->count += esize;
	result = esize;

EXIT:
	wake_up_interruptible(&pipedev->wqread);
	up(&pipedev->sem);

	return result;
}

static long pipe_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	struct PIPE_DEVICE *pipedev;
	int result;

	printk(KERN_INFO "ioctl\n");

	pipedev = (struct PIPE_DEVICE *)filp->private_data;

	if (down_interruptible(&pipedev->sem))
		return -ERESTARTSYS;

	switch (cmd) {
		case IOC_PIPE_GETNDEVICES:
			result =  put_user(ndevices, (size_t *)arg);
			break;
		case IOC_PIPE_GETCOUNT:
			result =  put_user(pipedev->count, (size_t *)arg);
			break;
		case IOC_PIPE_GETBUFSIZE:
			result = put_user(pipedev->bufsize, (size_t *)arg);
			break;
		case IOC_PIPE_SETBUFSIZE:
			result = set_bufsize(pipedev, arg);
			break;
		case IOC_PIPE_PEEK:
			result = read_peek(pipedev, arg);
			break;
		default:
			result = -ENOTTY;
	}

	up(&pipedev->sem);

	return result;
}

static int set_bufsize(struct PIPE_DEVICE *pipedev, unsigned long arg)
{
    char *newbuf;
    size_t size;
	
	if (arg > MAX_PIPE_BUFFER_SIZE)
        return -EINVAL;
   
	if (arg <= pipedev->count) 
		return -EINVAL;

    if ((newbuf = (char *)kmalloc(arg, GFP_KERNEL)) == NULL) 
		return -ENOMEM;
        
    if (pipedev->count != 0) {
        if (pipedev->tail <= pipedev->head) {
            size = pipedev->bufsize - pipedev->head;
            memcpy(newbuf, pipedev->buf + pipedev->head, size);
            memcpy(newbuf + size, pipedev->buf, pipedev->tail);
        }
        else
            memcpy(newbuf, pipedev->buf + pipedev->head, pipedev->count);
    }

    pipedev->head = 0;
    pipedev->tail = pipedev->count;
    kfree(pipedev->buf);
    pipedev->buf = newbuf;
    pipedev->bufsize = arg;

    return 0;
}

static int read_peek(struct PIPE_DEVICE *pipedev, unsigned long arg)
{
    size_t esize, size1, size2;
    struct PIPE_PEEK *userpp;
    struct PIPE_PEEK pp;
    
	userpp = (struct PIPE_PEEK *)arg;
	if (copy_from_user(&pp, userpp, sizeof(struct PIPE_PEEK)) != 0)
        return -EFAULT;

	if (pp.size == 0)
        return 0;

	esize = MIN(pipedev->count, pp.size);

	if (pipedev->tail >= pipedev->head)
		size1 = MIN(esize, pipedev->bufsize - pipedev->tail);
	else
		size1 = esize;
	size2 = esize - size1;

    if (copy_to_user(pp.buf, pipedev->buf + pipedev->head, size1) != 0) 
        return -EFAULT;
    if (size2 != 0)
        if (copy_to_user(pp.buf + size1, pipedev->buf, size2) != 0) 
            return -EFAULT;      
    
	if (put_user(esize, &userpp->size) != 0)
        return -EFAULT;

	return 0;
}


static int proc_open(struct inode *inodep, struct file *filp)
{
    return 0;
}

static int proc_release(struct inode *inodep, struct file *filp)
{
    return 0;
}

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
	struct PROC_FILE_INFO *pfi;
	static char valbuf[32];
	ssize_t result;
	size_t esize, left;

	pfi = (struct PROC_FILE_INFO *)pde_data(file_inode(filp));

	if (*off > 0)
        return 0;

	if (down_interruptible(&pfi->pipedev->sem))
		return -ERESTARTSYS;

	if (pfi->procfile == 0) 								// bufsize
		sprintf(valbuf, "%zu\n", pfi->pipedev->bufsize);
	else if (pfi->procfile == 1) 
		sprintf(valbuf, "%zu\n", pfi->pipedev->count);		// count
	else {										
		result = 0;
		goto EXIT;
	}

	left = strlen(valbuf);
  	esize = size > left ? left : size;

	if (copy_to_user(buf, valbuf, esize) != 0)  {
		result = -EFAULT; 
		goto EXIT;
	}
	*off += esize;
	result = esize;
EXIT:
	up(&pfi->pipedev->sem);
    
	return result;
}

static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
	struct PROC_FILE_INFO *pfi;
	static char valbuf[32];
	size_t esize;
	ssize_t  result;
	int val;

	pfi = (struct PROC_FILE_INFO *)pde_data(file_inode(filp));

	if (*off > 0)
        return 0;

	if (down_interruptible(&pfi->pipedev->sem))
		return -ERESTARTSYS;

	if (pfi->procfile == 0) { 								// bufsize
		esize = size > 32 ? 32 : size;
		if (copy_from_user(valbuf, buf, esize) != 0) {
			result = -EFAULT; 
			goto EXIT;
		}
    	valbuf[esize] = '\0'; 
    	if ((result = kstrtoint(valbuf, 10, &val)) != 0) 
        	goto EXIT;
		if ((result = set_bufsize(pfi->pipedev, val)) != 0)
			goto EXIT;
		*off += esize;

	}
	else 									
		result = 0;
	result = esize;
EXIT:
	up(&pfi->pipedev->sem);
	
    return result;
}

module_init(pipe_driver_init);
module_exit(pipe_driver_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* loadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2
mode=666

/sbin/insmod ./${module}.ko ${@:3} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)

for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
    mknod -m $mode ${module}$i c $major $i
done

/* unloadmulti (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$2

/sbin/rmmod ./$module.ko || exit 1
for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
done

/* preader.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE		8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
	int fd;
	char buf[BUFFER_SIZE];
	int n;
	ssize_t result;

	if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

	if ((fd = open(argv[1], O_RDONLY)) == -1)
		exit_sys("open");

	for (;;) {
		printf("Number of bytes to read? ");
		scanf("%d", &n);
		if (n == 0)
			break;
		if ((result = read(fd, buf, n)) == -1) {
			if (errno != EAGAIN)
				exit_sys("read");
			printf("pipe is empty, let's do something else...\n");
			continue;
		}
		if (result == 0) {
			putchar('\n');
			break;
		}
		buf[result] = '\0';
		printf("%jd bytes read: %s\n", (intmax_t)result, buf);
	}

	close(fd);

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* pwriter.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

    if ((fd = open(argv[1], O_WRONLY)) == -1)
        exit_sys("open");
    
    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        if ((result = write(fd, buf, strlen(buf))) == -1)
            exit_sys("write");
        
        printf("%jd bytes written...\n", (intmax_t)result);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bu bölümde aygıt sürücülerde zamanlama işlemlerinin nasıl yapılacağı üzerinde duracağız. Aygıt sürücülerde zamanlama 
    işlemleri bazı uygulamalarda kritik önemde olabilmektedir. Örneğin programcının bir IO port'una bir bilgi gönderdikten 
    sonra diğerini göndermek için belli bir süre beklemesi gerekebilir. Bazen programcı belli bir süre sonra birtakım işlemlerin 
    yapılmasını isteyebilir. Masaüstü Linux sistemleri "katı gerçek zamanlı (hard real time)" işlemler için uygun olmasa da bazı 
    "gevşek gerçek zamanlı (soft real time)" işlemlere olanak sağlayabilmektedir. Gerçek zamanlı işlemlerde kritik zamanlamalar 
    söz konusu olabilmektedir. İşte Linux'ta bu tür bekleme işlemleri çekirdeğin sunduğu mekanizmalar yoluyla yapılmaktadır. 

    Linux çekirdeğinde zamanlama işlemleri iki yolla gerçekleştirilmektedir:

    1) Periyodik donanım kesmeleri yoluyla
    2) İşlemcilerin sunduğu TSC (time stamp counter) mekanizması yoluyla

    Uzun süreli zamanlama işlemlerinde periyodik donanım kesmelerinden kısa süreli zamanlama işlemlerinde ise işlemcilerin sunduğu 
    TSC mekanizmasından faydalanılmaktadır. 

    Zamanlama işlemleri için periyodik donanım kesmeleri oluşturan devrelerden faydalanılmaktadır. Örneğin klasik PC mimarisinde 
    CPU üzerinde periyodik kesme oluşturmak için Intel'in 8254 "Programmable Interval Timer (PIT)" denilen entegre devresi 
    kullanılıyordu. Bugün Intel tabanlı PC'lerde hala bu donanım birimi bulundurulmaktadır. Ancak belli bir zamandan sonra 
    PC board'larına daha yüksek çözünürlüklü periyodik donanım kesmesi oluşturmak için chipset'ler içerisine yeni donanım 
    birimleri de eklenmiştir. Periyodik donanım kesmesi oluşturmak için kullanılan bu yüksek çözünürlüklü birimlere "HPET (High 
    Precision Event Timer)" de denilmektedir. 
    
    Belli bir süreden sonra Intel ve ARM işlemcilerine CPU içerisine de periyodik kesme oluşturan zamanlayıcı devreler eklenmiştir. 
    Bunlara PC mimarisinde "APIC Timer (Advanced Progammable Interrupt Controller Timer)" ya da "yerel timer (local timer)" 
    denilmektedir. Çok çekirdekli işlemcilerde her çekirdeğin ayrı bir "yerel timer" devresi bulunmaktadır. Bugünkü çok çekirdekli 
    sistemlerde thread'ler arası geçiş (context switch) bu yerel timer devrelerinin oluşturduğu kesmeler yoluyla gerçekleştirilmektedir. 
    
    Gömülü sistemlerde CPU'nun dışındaki periyodik kesme oluşturan donanım birimleri genellikle SoC içerisinde bulunmaktadır.
    Tabii ARM tabanlı gömülü sistemlerde aynı zamanda tıpkı Intel işlemcilerinde olduğu gibi CPU içerisinde de periyodik donanım 
    kesmeleri oluşturacak ayrı yerel timer devreleri vardır. Bu yerel timer devrelerine "ARM Generic Timer" da denilmektedir. 

    Özetle bugünkü Linux sistemlerinin çalıştırıdığı masaüstü sistemlerinde ve ARM tabanlı gömülü sistemlerde genel olarak olarak 
    iki zamanlayıcı devre bulunmaktadır:

    1) Global Timer devresi
    2) Her CPU'nun ya da çekirdeğin içerisindeki yerel timer devresi

    Global timer devresi Linux tarafından genel zamanlama işlemleri için, yerel timer devreleri ise ilgili çekirdekteki 
    thread'ler arası geçiş (context switch) işlemlerini sağlamak için kullanılmaktadır.
    
    Bugünkü Linux sistemlerinde bu global ve yerel timer devrelerinin hepsi 1 milisaniye, 4 milisaniye ya da 10 milisaniyeye 
    kurulmaktadır. Eskiden ilk Linux çekirdeklerinde 10 milisaniyelik periyotlar kullanılıyordu. Sonra bilgisayarlar hızlanınca 
    1 milisaniye periyot yaygın olarak kullanılmaya başlandı. Ancak bugünlerde 4 milisaniye periyotları kullanan çekirdekler 
    de yaygın biçimde bulunmaktadır. Aslında timer frekansı çekirdek konfigüre edilirken kullanıcılar tarafından da değiştirilebilmektedir. 
    (Anımsanacağı gibi çekirdek derlenmeden önce çekirdeğin davranışları üzerinde etkili olan parametrelerin belirlenmesi sürecine 
    "çekirdeğin konfigüre" edilmesi denilmektedir.) Ancak bu timer frekansı çekirdek boot parametreleri yoluyla değiştirilememektedir. 

    proc dosya sistemine belli bir çekirdek verisyonundan sonra "timer_list" isimli bir giriş de eklenmiştir. Bu dizin girişi 
    okunduğunda o sistemdeki çekirdeğin kullandığı timer devrelerine ilişkin bilgiler elde edilmektedir. Yine Linux'un kullandığı 
    timer kaynakları hakkında bilgiler sys dosya sisteminin içerisinden "/sys/devices/system/clocksource" dizininden de elde 
    edilebilmektedir. Bu dosyaların ayrıntılı formatları için Linux dokümanlarına başvurabilirsiniz. (İçerik olarak çekirdek 
    versiyonları arasında farklılıklar da söz konusu olabilmektedir.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                154. Ders 12/07/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Global timer kesmelerine (PC mimarisinde IRQ0) ilişkin kesme kodları çekirdek içerisindeki jiffies isimli bir global değişkeni 
    artırmaktadır. Böylece eğer timer kesme periyodu biliniyorsa iki jiffies değeri arasındaki farka bakılarak bir zaman ölçümü 
    mümkün olabilmektedir. Tabii buradaki hesabın çözünürlüğü ancak global timer devresinin periyodu kadardır.

    Timer frekansı Linux çekirdeği içerisindeki HZ isimli sembolik sabitle belirtilmiştir. Timer frekansı çekirdek konfigüre 
    edilirken CONFIG_HZ konfigürasyon parametresi yoluyla değiştirilebilmektedir. Yukarıda da belirttiğimiz gibi genellikle 
    timer frekansı 1000 (1 ms) , 250 (4 ms) ya da 100 (10 ms) olmaktadır. (Ancak değişik mimarilerde farklı değerlerde olabilir.) 
    Örneğin kursun yapıldığı sanal makinede timer periyodu 1 milisaniyedir. Bu da saniyede 1000 kez timer kesmesinin oluşacağı 
    anlamına gelmektedir. Başka bir deyişle bu makinede HZ sembolik sabiti 1000 olarak define edilmiştir. Çekirdeğin CONFIG_HZ
    konfigürasyon parametresi değiştirildiğinde bu değişiklik HZ sembolik sabitine de yansıtılmaktadır. Çekirdek kodlarında 
    aşağıdaki gibi bir #define işlemi bulunmaktadır:

    #define HZ  CONFIG_H

    Ancak bazı özel ve uç durumlarda CONFIG_HZ değeri HZ değeri ile olmayabilmektedir. Ancak burda bu durum hakkında açıklama
    yapmayacağız.

    İşte global timer kesmesi her oluştuğunda işletim sisteminin kesme kodu (interrupt handler) devreye girip "jiffies" isimli 
    global değişkeni 1 artırmaktadır. Bu jiffies değişkeni unsigned long türdendir. Bilindiği gibi unsigned long türü 32 
    bit Linux sistemlerinde 4 byte, 64 bit Linux sistemlerinde 8 byte'tır. 32 bit Linux sistemlerinde ayrıca jiffies_64 isimli 
    bir değişken de bulunmaktadır. Bu değişken hem 32 bit sistemde hem de 64 bit sistemde 8 byte'tır. Aslında 32 bit sistemlerde 
    zaten jiffies değişkeni jiffies_64 değişkeninin düşük anlamlı 4 byte'ı durumundadır. 32 bit sistemde jiffies değişkeni 4 
    byte olduğu için bilgisayar çok uzun süre açık kalırsa taşma (overflow) oluşabilmektedir. Ancak 64 bit sistemlerde taşma 
    mümkün değildir. 32 bit sistemlerde jiffies_64 değeri çekirdek tarafından iki ayrı makine komutuyla güncellenmektedir. 
    Çünkü 32 bit sistemlerde 64 bit bir değeri belleğe tek hamlede yazmak mümkün değildir. Bu nedenle jiffies_64 değerinin 
    taşma durumunda yanlış okunabilme olasılığı vardır. Ayrıca bu jiffies_64 değeri okunurken de global timer kesmesi oluşabilir. 
    Overlow durumunda Hem 32 bit hem 64 bit sistemlerde 64 bitlik jiffies değerini düzgün bir biçimde okuyabilmek için get_jiffies_64 
    isimli fonksiyon bulundurulmuştur:

    #include <linux/jiffies.h>

    u64 get_jiffies_64(void);

    Biz 32 bit sistemde de olsak bu fonksiyonla 64 bitlik jiffies değerini düzgün bir biçimde okuyabiliriz. Bu fonksiyon düzgün
    okuma için gereken senkronizasyonu sağlamaktadır.

    Aşağıdaki örnekte çekirdek modülü içerisinde proc dosya sisteminde "jiffy-module" isimli bir dizin, bu dizinin içerisinde 
    de "jiffy" ve "hertz" isimli iki dosya yaratılmıştır. "jiffy" dosyası okunduğunda o anki jiffies değeri, "hertz" dosyası 
    okunduğunda ise timer frekansı elde edilmektedir. Çekirdek modülünü aşağıdaki gibi derleyip yükleyebilirsiniz:

    $ make file=jiffy-module
    $ sudo insmod jiffy-module.ko

    Boşaltımı da şöyle yapabilirsiniz:

    $ sudo rmmod jiffy-module.ko
---------------------------------------------------------------------------------------------------------------------------*/

/* jiffy-module.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/proc_fs.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("jiffy module");

static ssize_t proc_read_jiffy(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_read_hertz(struct file *filp, char *buf, size_t size, loff_t *off);

static struct proc_ops g_procops_jiffy = {
    .proc_read = proc_read_jiffy,
};

static struct proc_ops g_procops_hertz = {
    .proc_read = proc_read_hertz,
};

static int __init generic_init(void)
{
    struct proc_dir_entry *pde_dir;

    if ((pde_dir = proc_mkdir("jiffy-module", NULL)) == NULL)
        return -ENOMEM;

    if (proc_create("jiffies", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops_jiffy) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    if (proc_create("hertz", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops_hertz) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    remove_proc_entry("jiffy-module", NULL);

    printk(KERN_INFO "jiffy-module module exit...\n");
}

static ssize_t proc_read_jiffy(struct file *filp, char *buf, size_t size, loff_t *off)
{
    unsigned long long jf;
    static char valbuf[64 + 1];
    size_t left, esize;

    if (*off > 0)
        return 0;

    jf = get_jiffies_64();
    sprintf(valbuf, "%llu\n", jf);

    left = strlen(valbuf);
  	esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf, esize) != 0)  
        return -EFAULT;
    *off += esize;

    printk(KERN_INFO "jiffies file read...\n");

    return esize;
}

static ssize_t proc_read_hertz(struct file *filp, char *buf, size_t size, loff_t *off)
{
    static char valbuf[32 + 1];
    size_t left, esize;

    if (*off > 0)
        return 0;

    sprintf(valbuf, "%u\n", HZ);

    left = strlen(valbuf);
  	esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf, esize) != 0)  
        return -EFAULT;
    *off += esize;

    printk(KERN_INFO "hertz file read...\n");

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi eğer 64 bit sistemde çalışıyorsak jiffies değerinin taşması (overflow olması) mümkün değildir. 
    Ancak 32 bit sistemlerde HZ değeri 1000 ise 49 günde taşma meydana gelebilmektedir. Aygıt sürücü programcısı bazen geçen 
    zamanı hesaplamak için iki noktada jiffies değerini alıp aradaki farka bakmak isteyebilmektedir. Ancak bu durumda 32 bit 
    sistemlerde "overflow" olasılığının ele alınması gerekir. İşaretli sayıların ikili sistemdeki temsiline dayanarak iki jiffies 
    arasındaki fark aşağıdaki gibi tek bir ifadeyle de hesaplanabilmektedir:

    unsigned long int prev_jiffies, next_jiffies;
    ...
    net_jiffies = (long) next_jiffies - (long) prev_jiffies;

    Çekirdek içerisinde iki jiffy değerini alarak bunları öncelik sonralık ilişkisi altında karşılaştıran aşağıdaki makrolar 
    bulunmaktadır:

    #include <linux/jiffies.h>

    time_after(jiffy1, jiffy2)
    time_before(jiffy1, jiffy2)
    time_after_eq(jiffy1, jiffy2)
    time_before_eq(jiffy1, jiffy2)

    Bu fonksiyonların hepsi bool bir değere geri dönmektedir. Bu fonksiyonlar 32 bit sistemlerde taşma durumunu da dikkate 
    almaktadır. time_after fonksiyonu birinci parametresiyle belirtilen jiffy değerinin ikinci parametresiyle belirtilen jiffy 
    değerinden sonraki bir jiffy değeri olup olmadığını belirlemekte kullanılmaktadır. Diğer fonksiyonlar da bu biçimde birinci 
    parametredeki jiffy değeri ile ikinci parametredeki jiffy değerini karşılaştırmaktadır. Tabii aslında eğer jiffies değerini 
    get_jiffies_64 fonksiyonuyla elde ediyorsanız yukarıdaki fonksiyonları kullanmanıza hiç gerek kalmaz.

    Çekirdek içerisinde jiffies değerini çeşitli biçimlere dönüştüren aşağıdaki fonksiyonlar da bulunmaktadır:

    #include <linux/time.h>

    unsigned long msecs_to_jiffies(const unsigned int m);
    unsigned long usecs_to_jiffies(const unsigned int m);
    unsigned long usecs_to_jiffies(const unsigned int m);

    Bu işlemin tersini yapan da üç fonksiyon vardır:

    unsigned int jiffies_to_msecs(const unsigned long j);
    unsigned int jiffies_to_usecs(const unsigned long j);
    unsigned int jiffies_to_nsecs(const unsigned long j);

    Bu fonksiyonlar HZ sembolik sabitinin değerini dikkate almaktadır. HZ değerinin genel olarak CONFIG_HZ değeri ile aynı 
    olduğunu anımsayınız.

    Ayrıca jiffies değerini saniye ve nanosaniye biçiminde ayırıp bize struct timespec64 biçiminde bir yapı nesnesi olarak veren 
    jiffies_to_timespec64 isimli bir fonksiyon da vardır. Bunun tersi timespec64_to_jiffies fonksiyonuyla yapılmaktadır.

    timespec64 yapısı da şöyledir:

    struct timespec64 {
        time64_t    tv_sec;             /* seconds */
        long        tv_nsec;            /* nanoseconds */
    };

    Eski çekirdeklerde bu fonksiyonların yerine aşağıdaki fonksiyonlar bulunuyordu:

    #include <linux/time.h>

    unsigned long timespec_to_jiffies(struct timespec *value);
    void jiffies_to_timespec(unsigned long jiffies, struct timespec *value);
    unsigned long timeval_to_jiffies(struct timeval *value);
    void jiffies_to_timeval(unsigned long jiffies, struct timeval *value);

    Aşağıdaki örnekte proc dosya sisteminde "jiffy-module" dizini içerisinde ayrıca "difference" isimli bir dosya da yaratılmıştır. 
    Bu dosya her okunduğunda önceki okumayla aradaki jiffies farkı yazdırılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/* jiffy-module.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/proc_fs.h>
#include <linux/time.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("jiffy module");

static ssize_t proc_read_jiffy(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_read_hertz(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_read_difference(struct file *filp, char *buf, size_t size, loff_t *off);

static struct proc_ops g_procops_jiffy = {
    .proc_read = proc_read_jiffy,
};

static struct proc_ops g_procops_hertz = {
    .proc_read = proc_read_hertz,
};

static struct proc_ops g_procops_difference = {
    .proc_read = proc_read_difference,
};

static char g_jiffies_str[32];
static char g_hertz_str[32];
static char g_difference_str[512];

static int __init generic_init(void)
{
    struct proc_dir_entry *pde_dir;

    if ((pde_dir = proc_mkdir("jiffy-module", NULL)) == NULL)
        return -ENOMEM;

    if (proc_create("jiffy", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops_jiffy) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    if (proc_create("hertz", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops_hertz) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    if (proc_create("difference", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops_difference) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    remove_proc_entry("jiffy-module", NULL);

    printk(KERN_INFO "jiffy-module module exit...\n");
}

static ssize_t proc_read_jiffy(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize;
    size_t left;

    sprintf(g_jiffies_str, "%lu\n", jiffies);

    left = strlen(g_jiffies_str) - *off;
    esize = left < size ? left : size;

    if (esize != 0) {
        if (copy_to_user(buf, g_jiffies_str + *off, esize) != 0)
            return -EFAULT;
        *off += esize;
    }

    printk(KERN_INFO "jiffy file read...\n");

    return esize;
}

static ssize_t proc_read_hertz(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t esize;
    size_t left;

    sprintf(g_hertz_str, "%d\n", HZ);

    left = strlen(g_hertz_str) - *off;
    esize = left < size ? left : size;

    if (esize != 0) {
        if (copy_to_user(buf, g_hertz_str + *off, esize) != 0)
            return -EFAULT;
        *off += esize;
    }

    printk(KERN_INFO "hertz file read...\n");

    return esize;
}

static ssize_t proc_read_difference(struct file *filp, char *buf, size_t size, loff_t *off)
{
    static unsigned long prev_jiffies;
    loff_t left, esize;
    long int net_jiffies;
    struct timespec64 ts;

    net_jiffies = (long)jiffies - (long)prev_jiffies;

    jiffies_to_timespec64(net_jiffies, &ts);

    sprintf(g_difference_str, "Jiffy difference: %10ld (%ld seconds + %ld nanoseconds)\n", 
            net_jiffies, (long)ts.tv_sec, (long)ts.tv_nsec);

    left = (loff_t)strlen(g_difference_str) - *off;
    esize = left < size ? left : size;

    if (esize != 0) {
        if (copy_to_user(buf, g_difference_str + *off, esize) != 0)
            return -EFAULT;
        *off += esize;
    }

    prev_jiffies = jiffies;

    return (ssize_t)esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücü içerisinde bazen belli bir süre bekleme yapmak gerekebilmektedir. Biz kursumuzda daha önce user modda bekleme
    yapan fonksiyonları görmüştük. Ancak o fonksiyonlar kernel modda kullanılamamaktadır. Kernel modda çekirdek içerisindeki 
    olanaklarla bekleme yapılabilmektedir.

    Eğer bekleme süresi kısa ise bekleme işlemi meşgul bir döngü ile yapılabilir. Örneğin:

    while (time_before(jiffies, jiffies_target))
        schedule();

    Burada o anki jiffies değeri hedef jiffies değerinden küçükse schedule fonksiyonu çağrılmıştır. schedule fonksiyonu thread'i 
    uykuya yatırmamaktadır. Yalnızca thread'ler arası geçiş oluşmasına yol açmaktadır. Yani bu fonksiyon uykuya dalmadan CPU'yu 
    bırakmak için kullanılmaktadır. schedule fonksiyonunu çağıran thread çalışma kuyruğunda (run queue) kalmaya devam eder. Yine
    çalışma sırası ona geldiğinde kaldığı yerden çalışmaya devam eder. Ancak meşgul bir döngü içerisinde schedule işlemi yine
    önemli bir CPU zamanın harcanmasına yol açmaktadır. Bu nedenle uzun beklemelerin yukarıdaki gibi yapılması tavsiye edilmemektedir. 
    Uzun beklemelerin uykuya dalarak yapılması gerekir.

    Uzun beklemeler için bir wait kuyruğu oluşturulup wait_event_timeout ya da wait_event_interruptible_timeout fonksiyonlarıyla koşul 
    0 yapılarak gerçekleştirilebilir. Ancak bunun için bir wait kuyruğunun oluşturulması gerekir. Bu işlemi zaten kendi içerisinde 
    yapan özel fonksiyonlar vardır.

    schedule_timeout fonksiyonu belli bir jiffy zamanı geçene kadar thread'i çekirdek tarafından bu amaçla oluşturulmuş olan bir
    wait kuyruğunda bekletir.

    #include <linux/sched.h>

    signed long schedule_timeout(signed long timeout);

    Fonksiyon parametre olarak beklenecek jiffy değerini alır. Eğer sinyal dolayısıyla fonksiyon sonlanırsa kalan jiffy sayısına, 
    eğer zaman aşımının dolması nedeniyle fonksiyon sonlanırsa 0 değerine geri döner. Fonksiyon başarısız olmamaktadır. Fonksiyonu 
    kullanmadan önce prosesin durum bilgisini set_current_state isimli fonksiyonla değiştirmek gerekir. Değiştirilecek durum 
    TASK_UNINTERRUPTIBLE ya da TASK_INTERRUPTIBLE olabilir. Bu işlem yapılmazsa bekleme gerçekleşmemektedir. Örneğin:

    set_current_state(TASK_INTERRUPTIBLE);
    schedule_timeout(jiffies + 5 * HZ);

    Uzun beklemeyi kendi içerisinde schedule_timeout kullanarak yapan üç yardımcı fonksiyon da vardır:

    #include <linux/delay.h>

    void msleep(unsigned int msecs);
    unsigned long msleep_interruptible(unsigned int msecs);
    void ssleep(unsigned int secs);

    Aşağıdaki örnekte "jiffy-module" dizinindeki "sleep" dosyasından okuma yapıldığında (denemeyi cat komutuyla yapabilirsiniz) 
    10 saniye bekleme oluşacaktır.

    $ cat /proc/jiffy-module/sleep
---------------------------------------------------------------------------------------------------------------------------*/

/* jiffy-module.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/proc_fs.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("jiffy module");

static ssize_t proc_read_jiffy(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_read_hertz(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_read_difference(struct file *filp, char *buf, size_t size, loff_t *off);

static struct proc_ops g_procops_jiffy = {
    .proc_read = proc_read_jiffy,
};

static struct proc_ops g_procops_hertz = {
    .proc_read = proc_read_hertz,
};

static struct proc_ops g_procops_difference = {
    .proc_read = proc_read_difference,
};

static int __init generic_init(void)
{
    struct proc_dir_entry *pde_dir;

    if ((pde_dir = proc_mkdir("jiffy-module", NULL)) == NULL)
        return -ENOMEM;

    if (proc_create("jiffies", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops_jiffy) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    if (proc_create("hertz", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops_hertz) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    if (proc_create("difference", S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH, pde_dir, &g_procops_difference) == NULL) {
        remove_proc_entry("jiffy-module", NULL);
        return -ENOMEM;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    remove_proc_entry("jiffy-module", NULL);

    printk(KERN_INFO "jiffy-module module exit...\n");
}

static ssize_t proc_read_jiffy(struct file *filp, char *buf, size_t size, loff_t *off)
{
    unsigned long long jf;
    static char valbuf[64 + 1];
    size_t left, esize;

    if (*off > 0)
        return 0;

    jf = get_jiffies_64();
    sprintf(valbuf, "%llu\n", jf);

    left = strlen(valbuf);
  	esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf, esize) != 0)  
        return -EFAULT;
    *off += esize;

    printk(KERN_INFO "jiffies file read...\n");

    return esize;
}

static ssize_t proc_read_hertz(struct file *filp, char *buf, size_t size, loff_t *off)
{
    static char valbuf[32 + 1];
    size_t left, esize;

    if (*off > 0)
        return 0;

    sprintf(valbuf, "%u\n", HZ);

    left = strlen(valbuf);
  	esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf, esize) != 0)  
        return -EFAULT;
    *off += esize;

    printk(KERN_INFO "hertz file read...\n");

    return esize;
}

static ssize_t proc_read_difference(struct file *filp, char *buf, size_t size, loff_t *off)
{
    static char valbuf[64 + 1];
    static unsigned long long prev_jiffies;
    unsigned long long net_jiffies;
    struct timespec64 ts;
    size_t left, esize;

    if (*off > 0)
        return 0;

    if (prev_jiffies == 0)
        prev_jiffies = get_jiffies_64();

    net_jiffies = get_jiffies_64() - prev_jiffies;
    jiffies_to_timespec64(net_jiffies, &ts);

    sprintf(valbuf, "%llu seconds + %llu nanoseconds\n", 
        (unsigned long long)ts.tv_sec, (unsigned long long)ts.tv_nsec);

    left = strlen(valbuf);
  	esize = size > left ? left : size;

    if (copy_to_user(buf, valbuf, esize) != 0)  
        return -EFAULT;
    *off += esize;

    prev_jiffies = jiffies;

    return esize;
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
                                                155. Ders 14/07/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücü içerisinde kısa beklemeler gerekebilmektedir. Çünkü bazı donanım aygıtlarının programlanabilmesi için bazı 
    beklemelere gereksinim duyulabilmektedir. Kısa beklemeler meşgul döngü yoluyla yani hiç sleep yapılmadan sağlanmaktadır. 
    Ayrıca kısa bekleme yapan fonksiyonlar atomiktir. Atomiklikten kastedilen şey thread'ler arası geçiş işleminin kapatılmasıdır. 
    Yani kısa bekleme yapan fonksiyonlar thread'ler arası geçiş işlemini o işlemci için kapatırlar. Bu sırada thread'ler arası 
    geçiş söz konusu olmamaktadır. Ancak donanım kesmeleri bu süre içerisinde oluşabilmektedir.

    Kısa süreli döngü içerisinde bekleme yapan fonksiyonlar şunlardır:

    void ndelay(unsigned int nsecs);
    void udelay(unsigned int usecs);
    void mdelay(unsigned int msecs);

    Burada delay nanosaniye cinsinden bekleme yapmak için, udelay mikrosaniye cinsinden bekleme yapmak için, mdelay ise 
    milisaniye cinsinden bekleme yapmak için kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux çekirdeklerine belli versiyondan sonra bir timer mekanizması da eklenmiştir. Bu sayede aygıt sürücü programcısı 
    belli bir zaman sonra belirlediği bir fonksiyonun çağrılmasını saplayabilmektedir. Bu mekanizmaya "kernel timer" mekanizması 
    denilmektedir. Maalesef kernel timer mekanizması da birkaç kere arayüz olarak değiştirilmiştir. Bu mekanizma kullanılırken 
    dikkat edilmesi gereken bir nokta callback fonksiyonun bir proses bağlamında çağrılmadığıdır. Yani callback fonksiyon 
    çağrıldığında biz current makrosu ile o andaki prosese erişemeyiz. O anda çalışan prosesin user alanına kopyalamalar 
    yapamayız. Çünkü callback fonksiyon timer kesmeleri tarafından çağrılmaktadır. Dolayısıyla callback fonksiyon çağrıldığında
    o anda hangi prosesin çalışmakta olduğu belli değildir.

    Son Linux çekirdeklerindeki kernel timer kullanımı şöyledir:

    1) struct timer_list türünden bir yapı nesnesi statik düzeyde tanımlanır ve bu yapı nesnesine ilk değeri verilir. DEFINE_TIMER
    makrosu ile hem tanımlama hem de ilkdeğer verme işlemi birlikte yapılabilir. Makro şöyledir:

    #include <linux/time.h>

    #define DEFINE_TIMER(_name, _function)

    Örneğin:

    DEFINE_TIMER(g_mytimer, timer_proc);

    Ya da alternatif olarak struct timer_list nesnesi yaratılıp timer_setup makrosuyla da ilkdeğer verilebilir. Makronun parametrik 
    yapısı şöyledir:

    #include <linux/time.h>

    #define timer_setup(timer, callback, flags)

    Makronun birinci parametresi timer nesnesinin adresini almaktadır. İkinci parametresi çağrılacak fonksiyonu belirtir. 
    flags parametresi 0 geçilebilir.

    Örneğin:

    static struct timer_list g_mytimer;

    timer_setup(&g_mytimer, timer_proc, 0);

    Buradaki timer fonksiyonunun parametrik yapısı şöyle olmalıdır:

    void timer_proc(struct timer_list *tlisr);

    2) Tanımlanan struct timer_list nesnesi add_timer fonksiyonu ile bir bağlı listeye yerleştirilir. Bu bağlı liste çekirdeğin
    içerisinde çekirdek tarafından oluşturulmuş bir listedir. add_timer fonksiyonunun prototipi şöyledir:

    #include <linux/time.h>

    void add_timer(struct timer_list *timer);

    3) Daha sonra ne zaman fonksiyonun çağrılacağını anlatmak için mod_timer fonksiyonu kullanılır.

    #include <linux/time.h>

    int mod_timer(struct timer_list *timer, unsigned long expires);

    Buradaki expires parametresi jiffy türündendir. Bu parametre hedef jiffy değerini içermelidir. (Yani jiffies + gecikme 
    jiffy değeri)

    4) Timer nesnesinin silinmesi için del_timer ya da del_timer_sync fonksiyonu kullanılmaktadır:

    #include <linux/time.h>

    int del_timer(struct timer_list * timer);
    int del_timer_sync(struct timer_list * timer);

    del_timer fonksiyonu eğer timer fonksiyonu o anda başka bir işlemcide çalışıyorsa asenkron biçimde silme yapar. Yani 
    fonksiyon sonlandığında henüz silme gerçekleşmemiş göreli bir süre sonra gerçekleşecek olabilir. Halbuki del_timer_sync 
    fonksiyonu geri dönünce timer silinmesi gerçekleşmiş olur. Eğer timer silinmezse modül çekirdekten atıldığında tüm sistem 
    çökebilir.

    Normal olarak belirlenen fonksiyon yalnızca 1 kez çağrılmaktadır. Ancak bu fonksiyonun içerisinde yeniden mod_timer çağrılarak
    çağırma periyodik hale getirilebilir.

    Aşağıda kernel timer kullanımına basit bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* timer-module.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/time.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Timer Module");

static void timer_proc(struct timer_list *tlist);

DEFINE_TIMER(g_mytimer, timer_proc);

static int __init generic_init(void)
{
    add_timer(&g_mytimer);

    mod_timer(&g_mytimer, jiffies + msecs_to_jiffies(5000));

    printk(KERN_INFO "timer-module module init...\n");

    return 0;
}

static void timer_proc(struct timer_list *tlist)
{
    static int count = 0;

    if (count == 5) {
        del_timer(&g_mytimer);
        count = 0;
        return;
    }
    ++count;

    printk(KERN_INFO "timer callback (%d)\n", count);

    mod_timer(&g_mytimer, jiffies + msecs_to_jiffies(5000));
}

static void __exit generic_exit(void)
{
    printk(KERN_INFO "timer-module module exit...\n");
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
                                                156. Ders 19/07/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Önceki konularda da UNIX/Linux sistemlerinde kernel mode'da çalışan işletim sistemine ait thread'ler olduğundan bahsetmiştik. 
    Bu thread'ler çalışma kuyruğunda (run queue) bulunan ve uykuya dalabilen işletim sisteminin bir parçası durumundaki 
    thread'lerdir. İşletim sistemine ait bu thread'ler çeşitli işlemlerden sorumludurlar. Linux işletim sisteminde kernel thread'ler 
    genellikle "user mode daemon"lar gibi sonu 'd' ile bitecek biçimde isimlendirilmiştir. Ancak çekirdeğe ait olan bu thread'lerin 
    ismi 'k' (kernel'dan geliyor) ile başlatılmıştır. Örneğin "kupdated", "kswapd", "keventd" gibi.

    İşte aygıt sürücüler de isterlerse arka planda kernel mode'da bir proses gibi çalışan thread'ler yaratabilirler. Ancak bu 
    thread'ler bir proses ile ilişkisiz biçimde çalıştırılmaktadır. Bu nedenle bunlar içerisinde current makrosu, ve copy_to_user 
    ya da copy_from_user gibi fonksiyonlar kullanılamaz.

    Aygıt sürücü kodlarımız genellikle bir olay olduğunda (örneğin kesme gibi) ya da user mode'dan çağrıldığında (read, write, 
    ioctl gibi) çalıştırılmaktadır. Ancak kernel thread'ler aygıt sürücüye sanki bir programmış gibi kernel mode'da sürekli 
    çalışma imkanı vermektedir.

    Kernel thread'ler sırasıyla şu adımlarlardan geçilerek kullanılmaktadır:

    1) Önce kernel thread aygıt sürücü içerisinde yaratılır. Yaratılma modülün init fonksiyonunda yapılabileceği gibi aygıt sürücü 
    ilk kez açıldığında open fonksiyonunda ya da belli bir süre sonra belli bir fonksiyonda da yapılabilmektedir. Kernel thread'ler 
    kthread_create fonksiyonuyla yaratılmaktadır:

    #include <linux/kthread.h>

    struct task_struct *kthread_create(int (*threadfn)(void *data), void *data, const char *namefmt);

    Fonksiyonun birinci parametresi thread akışının başlatılacağı fonksiyonun adresini almaktadır. Bu fonksiyon void * türünden 
    parametreye ve int geri dönüş değerine sahip olmak zorundadır. Fonksiyonun ikinci parametresi thread fonksiyonuna geçirilecek 
    parametreyi belirtmektedir. Eğer bir kernel thread'e bir parametre geçirilmek istenmiyorsa bu parametre için NULL adres 
    girilebilir. Fonksiyonun üçüncü parametresi proc dosya sisteminde (dolayısıyla "ps" komutunda) görüntülenecek ismi belirtir. 
    Fonksiyon başarı durumunda yaratılan thread'in task_struct adresine, başarısızlık durumunda negatif errno değerine geri 
    dönmektedir. Adrese geri dönen diğer kernel fonksiyonlarında olduğu gibi fonksiyonun başarı durumu IS_ERR makrosuyla test 
    edilmelidir. Eğer fonksiyon başarısız olmuşsa negatif errno değeri PTR_ERR makrosuyla elde edilebilir. Örneğin:

    struct task_struct *ts;

    ts = kthread_create(...);
    if (IS_ERR(ts)) {
        printk(KERN_ERROR "cannot create kernel thread!..")
        return PTR_ERR(ts);
    }

    Anımsanacağı gibi Linux sistemlerinde prosesler ve thread'ler task_struct yapısıyla temsil edilmektedir. İşte bu fonksiyon 
    da başarı durumunda çekirdek tarafından yaratılan task_struct nesnesinin adresini bize vermektedir.

    Kernel thread bu fonksiyonla yaratıldıktan sonra hemen çalışmaz. Onu çalıştırmak için wake_up_process fonksiyonun çağrılması 
    gerekir:

    #include <linux/kthread.h>

    int wake_up_process(struct task_struct *tsk);

    Fonksiyon ilgili kernel thread'in task_struct adresini parametre olarak alır. Başarı durumunda 0 değerine, başarısızlık 
    durumunda negatif errno değerine geri döner.

    Aslında yukarıdaki işlemi tek hamlede yapan kthread_run isimli bir fonksiyon da vardır:

    #include <linux/kthread.h>

    struct task_struct *kthread_run(int (*threadfn)(void *data), void *data, const char *namefmt);

    2) Kernel thread kthread_stop fonksiyonuyla herhangi bir zaman ya da aygıt sürücü bellekten atılırken yok edilebilir:

    #include <linux/kthread.h>

    int kthread_stop(struct task_struct *ts);

    Fonksiyon thread sonlanana kadar blokeye yol açar. Fonksiyon thread fonksiyonunun exit koduyla (yani thread fonksiyonunun 
    geri dönüş değeri ile) geri dönmektedir. Genellikle programcılar thread fonksiyonlarını başarı durumunda sıfır, başarısızlık 
    durumunda sıfır dışı bir değerle geri döndürmektedir. Burada önemli nokta kthread_stop fonksiyonunun kernel thread'i zorla 
    sonlandırılmadığıdır. Kernel thread'in sonlanması zorla yapılmaz. kthread_stop fonksiyonu bir bayrağı set eder. Kernel thread 
    de tipik olarak bir döngü içerisinde "bu bayrak set edilmiş mi" diye bakar. Eğer bayrak set edilmişse kendini sonlandırır. 
    Kernel thread'in bu bayrağa bakması kthread_should_stop fonksiyonuyla yapılmaktadır.

    #include <linux/kthread.h>

    bool kthread_should_stop(void);

    Fonksiyon eğer bu flag set edilmişse sıfır dışı bir değere, set edilmediyse 0 değerine geri dönmektedir. Tipik olarak kernel 
    thread fonksiyonu aşağıdaki gibi bir döngüde yaşamını geçirir:

    while (!kthread_should_stop()) {
        ...
    }

    Tabii aslında biz kthread_create fonksiyonu ile bir kernel thread yaratmak istediğimizde asıl thread'in başlatıldığı 
    fonksiyon çekirdek içerisindeki bir fonksiyondur. Bizim kthread_create fonksiyonuna verdiğimiz fonksiyon bu fonksiyon 
    tarafından çağrılmaktadır. Dolayısıyla bizim fonksiyonumuz bittiğinde akış yine çekirdek içerisindeki asıl fonksiyona 
    döner. O fonksiyonda da yaratılmış thread kaynakları otomatik boşaltılır. Yani biz bir thread yarattığımız zaman 
    onun yok edilmesi thread fonksiyonu bittiğinde otomatik yapılmaktadır.

    Kernel thread'in kendisini sonlandırması do_exit fonksiyonuyla sağlanabilmektedir. Aslında do_exit fonksiyonu prosesleri
    sonlandıran sys_exit fonksiyonunun doğrudan çağırdığı taban fonksiyondur.

    #include <linux/kernel.h>

    void do_exit(long code);

    Fonksiyon thread'in exit kodunu parametre olarak almaktadır. Kernel thread normal biçimde ya da kthread_stop fonksiyonuyla 
    sonlanmışsa artık thread'in tüm kaynakları (task_struct yapısı da) serbest bırakılmaktadır. Dolayısıyla artık ona kthread_stop
    uygulamamak gerekir.

    Aşağıdaki örnekte modül initialize edilirken kernel thread yaratılmış, modül yok edilirken kthread_stop ile kernel-thread'in 
    sonlanması beklenmiştir. kernel-thread içerisinde msleep fonksiyonu ile 1 saniyelik beklemeler yapılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/* kernel-thread-module.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/kthread.h>
#include <linux/timer.h>
#include <linux/delay.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("Kernel Thread Module");

static int kernel_thread_proc(void *param);

struct task_struct *g_ts;

static int __init generic_init(void)
{
    printk(KERN_INFO "kernel-thread-module init...\n");

    g_ts = kthread_run(kernel_thread_proc, NULL, "kmythreadd");
    if (IS_ERR(g_ts)) {
        printk(KERN_ERR "cannot create kernel thread!...\n");
        return PTR_ERR(g_ts);
    }

    return 0;
}

static int kernel_thread_proc(void *param)
{
    static int count;

    printk(KERN_INFO "kernel-thread starts...\n");

    while (!kthread_should_stop()) {
        printk(KERN_INFO "kernel-thread is running: %d\n", count);
        msleep(1000);
        ++count;
    }

    return 0;
}

static void __exit generic_exit(void)
{
    int ecode;

    ecode = kthread_stop(g_ts);
    printk(KERN_INFO "kernel thread exits with code \"%d\"\n", ecode);
    printk(KERN_INFO "kernel-thread-module exit...\n");
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
                                                157. Ders 21/07/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşlemcinin çalıştırmakta olduğu koda ara vererek başka bir kodu çalıştırması ve çalıştırma bittikten sonra kaldığı yerden 
    devam etmesi sürecine "kesme (interrupt)" denilmektedir. Kesmeler oluşma biçiminde göre üçe ayrılmaktadır:

    1) Donanım Kesmeleri (Hardware Interrupts)
    2) İçsel Kesmeler (Internal Interrupts)
    3) Yazılım Kesmeleri (Software Interrupts)

    Kesme denildiğinde akla default olarak donanım kesmeleri gelmektedir. Donanım kesmeleri CPU'nun bir ucunun (genellikle bu 
    uca INT ucu denilmektedir) elektriksel olarak dışsal bir birim tarafından uyarılmasıyla oluşmaktadır. Yani donanım kesmeleri 
    o anda çalışmakta olan koddan bağımsız bir biçimde dış dünyadaki birimler tarafından oluşturulmaktadır. PC terminolojisinde 
    donanım kesmesi oluşturan kaynaklara IRQ da denilmektedir. İçsel kesmeler CPU'nun kendi çalışması sırasında kendisinin 
    oluşturduğu kesmelerdir. Intel bu tür kesmelerin önemli bir bölümünü "fault" olarak isimlendirmektedir. Örneğin fiziksel 
    RAM'de olmayan bir sayfaya erişildiğinde CPU "page fault" denilen içsel kesme oluşturmaktadır. Yazılım kesmeleri ise 
    programcının program koduyla oluşturduğu kesmelerdir. Her türlü CPU'da yazılım kesmesi oluşturulamamaktadır.

    Bir kesme oluştuğunda çalıştırılan koda "kesme kodu (interrupt handler)" denilmektedir.

    Donanım kesmesi oluşturan elektronik birimlerin hepsi doğrudan CPU'nun INT ucuna bağlanmamaktadır. Çünkü bunun pek çok 
    sakıncası vardır. Genellikle bu amaçla bu işe aracılık eden daha akıllı işlemciler kullanılmaktadır. Bu işlemcilere 
    genel olarak "kesme denetleyicileri (interrupt controllers)" denilmektedir. Bazı mimarilerde kesme denetleyicisi işlemcinin 
    içerisinde bulunmaktadır. Bazı mimarilerde ise dışarıda ayrı bir entegre devre olarak bulunmaktadır. Tabii artık
    pek çok entegre devre SoC (System on Chip) adı altında tek bir entegre devrenin içerisine yerleşirilmiş durumdadır. Kesme
    denetleyicilerinin temel işlevi şöyledir:

    1) Birden fazla donanım biriminin aynı anda kesme oluşturması durumunda kesme denetleyicisi bunları sıraya dizebilmektedir.
    2) Birden fazla donanım biriminin aynı anda kesme oluşturması durumunda kesme denetleyicisi bunlara öncelik verebilmektedir.
    3) Belli birimlerden gelen kesme isteklerini kesme denetleyicisi görmezden gelebilmektedir. Buna ilgili IRQ'nun disable edilmesi
    denilmektedir.
    4) Kesme denetleyicileri çok çekirdekli donanımlarda kesmenin belli bir çekirdekte çalıştırılabilmesini sağlayabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bugün kullandığımız PC'lerde (laptop ve notebook'lar da dahil olmak üzere) eskiden kesme denetleyicisi olarak bir tane 
    Intel'in 8259 (PIC) denilen entegre devresi kullanılıyordu. Bunun 8 girişi bulunuyordu. Yani bu kesme denetleyicisinin 
    uçları 8 ayrı donanım birimine bağlanabiliyordu.

    | (INT ucu CPU'ya bağlanır)
      <8259 (PIC)>
    | | | | | | | |
    0 1 2 3 4 5 6 7

    Bu uçlara IRQ uçları deniliyordu ve bu uçlar değişik donanım birimlerine bağlıydı. Böylece bir donanım birimi kesme oluşturmak
    isterse kesme denetleyicisinin ilgili ucunu uyarıyordu. Kesme denetleyicisi de CPU'nun INT ucunu uyarıyordu. İlk PC'lerde 
    toplam 8 IRQ vardı. Ancak 80'li yılların ortalarında PC mimarisinde değişiklikler yapılarak kesme denetleyicisinin sayısı ikiye 
    yükseltildi. Böylece IRQ uçlarının sayısı da 15'e yükseltilmiş oldu. Intel'in iki 8259 işlemcisini katkat bağlayabilmek için 
    birinci kesme denetleyicisinin (Master PIC) bir ucunun ikinci kesme denetleyicisinin INT ucuna bağlanması gerekmektedir. 
    İşte PC mimarisinde birinci kesme denetleyicisinin 2 numaralı ucu ikinci kesme denetleyicisine bağlanmıştır. Böylece toplam
    IRQ'ların sayısı 16 değil, 15 olmaktadır.

    | (INT ucu CPU'ya bağlanır)     |
      <8259 (PIC)>                     <8259 (PIC)>
    | | X | | | | |                 | | | | | | | |

    0 1 2 3 4 5 6 7                 8 9 10 11 12 13 14 15

    Ancak zamanla 15 IRQ ucu da yetersiz kalmaya başlamıştır. Çok çekirdekli sistemlerde her çekirdeğin (yani CPU'nun) ayrı bir
    INT ucu vardır. Yani bu çekirdekler diğerlerinden bağımsız kesme alabilmektedir. İşte zamanla Intel'in klasik 8259 kesme 
    denetleyicisi daha gelişmiş olan ve ismine IOAPIC denilen kesme denetleyicisi ile değiştirilmiştir. Bugün kullandığımız 
    Intel tabanlı bilgisayar mimarisinde artık IOAPIC kesme denetleyicileri bulunmaktadır. Bu yeni kesme denetleyicisinin 24 IRQ 
    ucu vardır. IOAPIC birden fazla çekirdeğin bulunduğu durumda tek bir çekirdeğe değil, tüm çekirdeklere bağlanmaktadır. Dolayısıyla
    istenilen bir çekirdekte kesme oluşturabilmektedir. IOAPIC devresinin bazı uçları bazı donanım birimlerine bağlı biçimdedir. Ancak 
    bazı uçları boştadır. Bugün kullanılan ve ismine PCI ya da PCI-X denilen genişleme yuvalarının bazı uçları bu IOAPIC ile 
    bağlantılıdır. Dolayısıyla genişleme yuvalarına takılan kartlar da IRQ oluşturabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bugün Pentium ve eşdeğer AMD işlemcilerinin içerisinde (her çekirdeğin içerisinde) aynı zamanda ismine "Local APIC" denilen 
    bir kesme denetleyicisi de vardır. Bu local APIC iki uca sahiptir. Local APIC içerisinde aynı zamanda bir timer devresi de 
    bulunmaktadır. Bu timer devresi periyodik donanım kesmesi oluşturmak için kullanılmaktadır. Intel ve AMD çekirdeklerinin 
    içerisinde bulunan APIC devresinin en önemli özelliği kesmeleri artık uçlarla değil, veri yoluyla (data bus) oluşturabilmesidir.
    Bu özellik sayesinde hiç işlemcinin INT uyarılmadan çok fazla sayıda kesme sanki belleğe bir değer yazıyormuş gibi 
    oluşturulabilmektedir. Bu tekniğe "Message Signaled Interrupt (MSI)" denilmektedir. Gerçekten de bugün PCI slotlara takılan 
    bazı kartlar kesmeleri doğrudan belli bir çekirdekte MSI kullanarak oluşturmaktadır.

    O halde kullandığımız Intel tabanlı PC mimarisindeki bugünkü durum şöyledir:

    - Bazı donanım birimleri built-in biçimde IOAPIC'in uçlarına bağlı durumdadır. Bu uçlar eskiye uyumu korumak için 8259'un 
    uçlarıyla aynı biçimde bağlıymış gibi IRQ oluşturmaktadır.

    - Bazı PCI kartlar slot üzerindeki 4 IRQ hattından (INTA, INTB, INTC, INTD) birini kullanarak kesme oluşturmaktadır. Bu hatlar 
    IOAPIC'in bazı uçlarına bağlıdır.

    - Bazı PCI kartlar ise doğrudan modern MSI sistemini kullanarak IOAPIC'i pass geçerek bellek işlemleriyle doğrudan ilgili 
    çekirdekte kesme oluşturabilmektedir.

    Bir aygıt sürücü programcısı mademki birtakım kartlar için onu işler hale getiren temel yazılımları da yazma iddiasındadır. 
    O halde o kartın kullanacağı kesme için kesme kodlarını (interrupt handlers) yazabilmelidir. Tabii işletim sisteminin aygıt sürücü 
    mimarisinde bu işlemler de özel kernel fonksiyonlarıyla yapılır. Yani kesme kodu yazmanın belli bir kuralı vardır.

    Pekiyi çok çekirdekli bilgisayar sistemlerinde oluşan bir kesme Intel tabanlı PC mimarisinde hangi çekirdek tarafından 
    işlenmektedir? İşte bugün kullanılan IOAPIC devreleri bu bakımdan şu özelliklere sahiptir:

    1) Kesme IOAPIC tarafından donanım biriminin istediği bir çekirdekte oluşturulabilir.
    2) Kesme IOAPIC tarafından en az yüklü çekirdeğe karar verilerek orada oluşturulabilmektedir.
    3) Kesme IOAPIC tarafından döngüsel bir biçimde (yani sırasıyla her bir çekirdekte) oluşturulabilmektedir.

    IOAPIC'in en az yüklü işlemciyi bilmesi mümkün değildir. Onu ancak işletim sistemi bilebilir. İşte işlemcilerin Local 
    APIC'leri içerisinde özel bazı yazmaçlar vardır. Aslında IOAPIC bu yazmaçtaki değerlere bakıp en düşüğünü seçmektedir. Bu 
    değerleri de işletim sistemi set eder. İşletim sisteminin yaptığı bu faaliyete "kesme dengeleme (IRQ balancing)" denilmektedir. 
    Linux sistemlerinde bir süredir kesme dengelemesi işletim sisteminin kernel thread'i (irqbalance) tarafından yapılmaktadır. 
    Böylece Linux sistemlerinde aslında donanım kesmeleri her defasında farklı çekirdeklerde çalıştırılıyor olabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pek çok CPU ailesinde donanım kesmelerinin teorik maksimum bir limiti vardır. Örneğin Intel mimarisinde toplam kesme sayısı 
    256'yı geçememektedir. Yani bu mimaride en fazla 256 farklı kesme oluşturulabilmektedir. Bu mimaride her kesmenin bir 
    numarası vardır. IRQ numarası ile kesme numarasının bir ilgisi yoktur. Biz örneğin PIC ya da IOAPIC'i programlayarak belli 
    bir kesmenin belli bir IRQ için belli numaralı bir kesmenin oluşmasını sağlayabiliriz. Örneğin timer (IRQ-0) için 8 numaralı 
    kesmenin çalışmasını sağlayabiliriz. Pekiyi bir IRQ oluşturulduğunda çekirdek kaç numaralı kesme kodunun çalıştırılacağını 
    nereden anlamaktadır? İşte PIC ya da IOAPIC CPU'nun INT ucunu uyararak kesme oluştururken veri yolunun ilk 8 ucundan kesme 
    numarasını da CPU'ya bildirmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                158. Ders 28/07/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de aygıt sürücüler içerisinde kesmelerin nasıl ele alınacağı üzerinde duralım. Bir donanım kesmesi oluştuğunda 
    aslında işletim sisteminin kesme kodu (interrupt handler) devreye girmektedir. Ancak işletim sisteminin kesme kodu istek 
    doğrultusunda aygıt sürücülerin içerisindeki fonksiyonları çağırabilmektedir. Farklı aygıt sürücüleri aynı IRQ için istekte
    bulunabilir. Bu durumda işletim sistemi IRQ oluştuğunda farklı aygıt sürücülerdeki fonksiyonları belli bir düzen içerisinde
    çağırmaktadır.

    Aygıt sürücü programcısı bir kesme oluştuğunda aygıt sürücüsünün içerisindeki bir fonksiyonunun çağrılmasını istiyorsa önce 
    onu request_irq isimli kernel fonksiyonuyla register ettirmelidir.

    #include <linux/interrupt.h>

    int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev_id);

    Fonksiyonun birinci parametresi IRQ numarasını, ikinci parametresi IRQ oluştuğunda çağrılacak fonksiyonu belirtmektedir. Bu 
    fonksiyonun geri dönüş değeri irqreturn_t türünden parametreleri de sırasıyla int ve void * türündendir. Örneğin:

    irqreturn_t my_irq_handler(int irq, void *dev_id)
    {
        ...
    }

    Buradaki irqreturn_t türü bir enum türü olarak typedef edilmiştir. Bu enum türünün elemanları şunlardır:

    enum irqreturn {
        IRQ_NONE        = (0 << 0),
        IRQ_HANDLED        = (1 << 0),
        IRQ_WAKE_THREAD        = (1 << 1),
    };

    typedef enum irqreturn irqreturn_t;

    request_irq fonksiyonunun üçüncü parametresi bazı bayraklardan oluşur. Bu bayrak 0 geçilebilir ya da örneğin IRQF_SHARED 
    geçilebilir. Diğer seçenekler için dokümanlara başvurabilirsiniz. IRQF_SHARED aynı kesmenin birden fazla aygıt sürücü tarafından 
    kullanılabileceği anlamına gelmektedir. (Tabii biz ilk register ettiren değilsek daha önce register ettirenlerin bu bayrağı 
    kullanmış olması gerekir. Aksi halde biz de bu bayrağı kullanamayız.) Fonksiyonun dördüncü parametresi "/proc/interrupts" 
    dosyasında görüntülenecek ismi belirtir. Son parametre ise sistem genelinde tek olan bir nesnenin adresi olarak girilmelidir. 
    Aygıt sürücü programcıları bu parametreye tipik olarak aygıt yapısını ya da çağrılacak fonksiyonu girerler. Bu parametre IRQ
    handler fonksiyonuna ikinci parametre olarak geçilmektedir. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda negatif 
    hata değerine geri dönmelidir. Örneğin:

    if ((result = request_irq(1, my_irq_handler, IRQF_SHARED, "my_irq1", NULL)) != 0) {
        ...
        return result;
    }

    Bir kesme kodu request_irq fonksiyonuyla register ettirilmişse bunun geri alınması free_irq fonksiyonuyla yapılmaktadır:

    #include <linux/interrupt.h>

    const void *free_irq(unsigned int irq, void *dev_id);

    Fonksiyonun birinci parametresi silinecek irq numarasını, ikinci parametresi irq_reuest fonksiyonuna girilen son parametreyi 
    belirtir. Fonksiyon başarı durumunda aygıt irq_request fonksiyonunda verilen isme, başarısızlık durumunda NULL adrese geri 
    dönmektedir. Geri dönüş değeri bir hata kodu içermemektedir. Normal olarak fonksiyonun ikinci parametresine request_irq 
    fonksiyonunun son parametresiyle aynı değer geçilir. Bu parametrenin neden bu fonksiyona geçirildiğinin bazı ayrıntıları vardır. 
    Örneğin:

    if (free_irq(1, NULL) == NULL)
        printk(KERN_INFO "cannot free IRQ\n");

    Pekiyi IRQ fonksiyonundan (IRQ handler) hangi değerle geri dönülmelidir. Aslında programcı bu fonksiyondan ya IRQ_NONE 
    değeri ile ya da IRQ_HANDLED değeri ile geri döner. Eğer programcı kesme kodu içerisinde yapmak istediği şeyi yapmışsa
    fonksiyondan IRQ_HANDLED, yapamamışsa ya da yapmak istememişse fonksiyondan IRQ_NONE değeri ile geri döner. Örneğin:

    static irqreturn_t my_irq_handler(int irq, void *dev_id)
    {
        ...

        return IRQ_HANDLED;
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bazen sistem programcısı belli bir IRQ'yu belli süre için disable etmek isteyebilir. Bunun için disable_irq ve enable_irq 
    isimli iki kernel fonksiyonu kullanılmaktadır. Bu fonksiyonlar belli numaralı bir IRQ'yu disable ve enable etmektedir. Ancak 
    bu fonksiyonlar bu işlemi doğrudan kesme denetleyicisini (PIC ya da IOAPIC) programlayarak yapmamaktadır.

    #include <linux/interrupt.h>

    void disable_irq(unsigned int irq);
    void enable_irq(unsigned int irq);

    Fonksiyonlar IRQ numarasını parametre olarak alır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Donanımsal kesme mekanizmasının tipik örneklerinden biri klavye kullanımıdır. PC klavyesinde bir tuşa basıldığında klavye 
    içerisindeki işlemci (keyboard encoder - Eskiden Intel 8048 ya da Holtek HT82K629B) basılan ya da çekilen tuşun klavyedeki 
    sıra numarasını (buna "scan code" denilmektedir) dış dünyaya seri bir biçimde kodlamaktadır. Bu bilgi bilgisayardaki klavye 
    denetleyicisine (Eskiden Intel 8042) gelir. Klavye denetleyicisi (keyboard controller) bu scan kodu kendi içerisinde bir 
    yazmaçta saklar. PIC ya da IOAPIC'in 1 numaralı ucu klavye denetleyicisine bağlıdır ve bu uçtan IRQ1 kesmesini oluşturulmaktadır. 
    Dolayısıyla biz bir tuşa bastığımızda otomatik olarak basılan tuşa ilişkin klavye scan kodu bilgisayar tarafına iletilir 
    ve IRQ1 kesmesi oluşturulur. IRQ1 kesme kodu birincil olarak işletim sistemi tarafından ele alınmaktadır. İşletim sistemi 
    de bu IRQ oluştuğunda aygıt sürücülerin belirlediği fonksiyonları çağırmaktadır. Klavyede yalnızca bir tuşa basılınca 
    değil, parmak tuştan çekildiğinde de yine klavye işlemcisi çekilen tuşun scan kodunu klavye denetleyicisine gönderip IRQ1 
    kesmesinin oluşmasına yol açmaktadır. Yani hem tuşa basınca hem de parmak tuştan çekildiğinde IRQ1 oluşmaktadır. Klavye 
    terminolojisinde parmağın tuşa basılmasıyla gönderilen scan koda "make code", parmağın tuştan çekilmesiyle gönderilen koda
    ise "break code" denilmektedir. Bugün PC'lerde kullandığımız klavyelerde parmak tuştan çekildiğinde önce PC tarafında bir 
    F0 byte'ı ve sonra da tuşun scan kodu gönderilmektedir. Örneğin parmağımızı "A" tuşuna basıp çekelim. Şu scan kodlar bilgisayar
    tarafına gönderilecektir:

    <A'nın scan kodu> <F0> <A'nın scan kodu>

    Ctrl, Shift, Alt, Caps-Lock gibi tuşların diğer tuşlardan bir farkı yoktur. Ctrl+C gibi bir tuşa basıldığı işletim sisteminin 
    tuttuğu flag değişkenlerle tespit edilmektedir. Örneğin biz Ctrl+C tuşlarına basıp çekmiş olalım. Klavye işlemcisi bilgisayar
    tarafında şu kodları gönderecektir:

    <Ctrl scan kodu> <A'nın scan kodu> <F0> <A'nın scan kodu> <F0> <Ctrl scan kodu>

    İşte Ctrl tuşuna basıldığını fark eden işletim sistemi bir flag'i set eder, parmak bu tuştan bırakıldığında flag'i reset 
    eder. Böylece diğer tuşlara basıldığında bu flag'e bakılarak Ctrl tuşu ile bu tuşa basılıp basılmadığı anlaşılmaktadır.

    Pekiyi biz Linux'ta stdin dosyasından (0 numaralı betimleyici) okuma yaptığımızda neler olmaktadır? İşte aslında işletim 
    sistemi bir tuşa basıldığında basılan tuşları klavye denetleyicisinden alır ve onları bir kuyruk sisteminde saklar. Terminal 
    aygıt sürücüsü de bu kuyruğa başvurur. Kuyrukta hiç tuş yoksa thread'i bu amaçla oluşturulmuş bir wait kuyruğunda bekletir. 
    Klavyeden tuşa basılınca wait kuyruğunda bekleyen thread'leri uyandırır. Yani okuma yapıldığında o anda klavyeden okuma 
    yapılmamaktadır. Kuyruklanmış tuşlar okunmaktadır.

    Klavyedeki tuşların üzerinde yazan harflerin hiçbir önemi yoktur. Yani İngilizce klavye ile Türkçe klavye aynı tuşlar için 
    aynı scan kodu göndermektedir. Basılan tuşun hangi tuş olduğu aslında dil ayarlarına bakılarak işletim sistemi tarafından 
    anlamlandırılmaktadır.

    Klavye ile bilgisayar arasındaki iletişim tek yönlü değil çift yönlüdür. Yani klavye denetleyicisi de (PC tarafındaki 
    denetleyici) isterse klavye içerisindeki işlemciye komutlar gönderebilmektedir. Aslında klavye üzerindeki ışıkların 
    yakılması da klavyenin içerisinde tuşa basılınca yapılmamaktadır. Işıklı tuşlara basıldığında gönderilen scan kod klavye 
    denetleyicisi tarafından alınır, eğer bu tuş ışıklı tuşlardan biri ise klavye denetleyicisi klavye işlemcisine "falanca 
    ışığı yak" komutunu göndermektedir. Özetle yeniden ifade edersek klavyedeki ışıklar klavye devresi tarafından ilgili 
    tuşlara basılınca yakılmamaktadır. Karşı taraftan emir geldiğinde yakılmaktadır. Tasarımın bu biçimde yapılmış olması
    çok daha esnek bir kullanım oluşturmaktadır.

     Aşağıdaki örnekte klavyeden tuşa basıldığında ve çekildiğinde oluşan 1 numaralı IRQ ele alınıp işlenmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* irq-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/interrupt.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
};

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id);

static int __init generic_init(void)
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "irq-driver")) < 0) {
        printk(KERN_INFO "cannot alloc char driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "cannot allocate cdev!...\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;

    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "cannot add character device driver!...\n");
        return result;
    }

    if ((result = request_irq(1, keyboard_irq_handler, IRQF_SHARED, "irq-driver", &g_cdev)) != 0) {
        cdev_del(g_cdev);
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "interrupt couldn't registered!...\n");
        return result;
    }

    printk(KERN_INFO "irq-driver init...\n");

    return 0;
}

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id)
{
    static int count = 0;

    ++count;

    if (count % 1000 == 0)
        printk(KERN_INFO "Keyboard IRQ occurred: %d\n", count);

    return IRQ_HANDLED;
}

static void __exit generic_exit(void)
{
    free_irq(1, &g_cdev);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);
    printk(KERN_INFO "irq-driver exit...\n");
}

module_init(generic_init);
module_exit(generic_exit);

/*--------------------------------------------------------------------------------------------------------------------------
                                                159. Ders 02/08/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    CPU ile RAM arasında veri transferi aslında tamamen elektriksel düzeyde 1'lerle 0'larla gerçekleşmektedir. CPU'nun adres 
    uçları (address bus) RAM'in adres uçlarına bağlanır. Bu adres uçları RAM'den transfer edilecek bilginin fiziksel adresini 
    belirtmek için kullanılmaktadır. CPU'nun veri uçları (data bus) ise bilginin alınıp gönderilmesinde kullanılmaktadır. 
    İşlemin okuma mı yazma mı olduğu genellikle R/W biçiminde isimlendirilen ayrı bir kontrol ucuyla yapılmaktadır. Örneğin 
    32 bit Intel işlemcilerinde MOV EAX, [XXXXXXXX] komutu RAM'deki XXXXXXXX adresinden başlayan 4 byte bilginin CPU içerisindeki 
    EAX yazmacına çekileceği anlamına gelmektedir. Bu makine komutu işletilirken CPU önce erişilecek adres olan XXXXXXXX adresini 
    adres uçlarına elektriksel işaret olarak kodlar. RAM bu adresi alır, bu adresten başlayan 4 byte'lık bilgiyi veri uçlarına 
    elektriksel olarak kodlar. CPU'da bu uçlardan bilgiyi yine elektriksel olarak alır ve EAX yazmacına yerleştirir. CPU'nun adres 
    uçları RAM'in adres uçlarına, CPU'nun veri uçları ise RAM'in veri uçlarına bağlıdır. Transfer yönü R/W ucuyla belirlenmektedir. 
    Tabii CPU'lar bugün DRAM belleklerden daha hızlıdır. Dolayısıyla CPU RAM'den yanıt gelene kadar beklemektedir (wait state).
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir bilgisayar sisteminde yalnızca Merkezi İşlemci (CPU) değil, aynı zamanda yerel birtakım olaylardan sorumlu yardımcı 
    işlemciler de vardır. Bu yardımcı işlemcilere genellikle "controller (denetleyici)" denilmektedir. Örneğin klasik PC 
    mimarisinde "Kesme Denetleyicisi (Intel 8250-PIC)", "Klavye Denetleyicisi (Intel 8042-KC)", "UART Denetleyicisi (Intel 
    8250/NS 16550-UART)" gibi pek çok işlemci vardır. Bu işlemcilere komutlar tıpkı CPU/RAM haberleşmesinde olduğu gibi elektriksel 
    düzeyde CPU'nun adres ve veri uçları yoluyla gönderilmekte ve bu işlemcilerden bilgiler yine tıpkı RAM'de olduğu gibi adres 
    ve veri uçları yoluyla alınmaktadır. Yani CPU'nun adres ve veri uçları yalnızca RAM'e değil, yardımcı işlemcilere de bağlıdır. 
    Pekiyi bu durumda CPU, RAM'e erişirken aynı zamanda yardımcı işlemcilere de erişmez mi? İşte CPU'ların genellikle IO/Mem 
    biçiminde isimlendirilen bir uçları daha vardır. Bu ucun 5V ya da 0V olması erişimin RAM'e mi yoksa yardımcı işlemciye mi 
    yapılacağını belirtir. Yardımcı işlemcileri tasarlayanlar bu uca bakarak bilginin RAM'e değil, kendilerine geldiğini 
    anlayabilirler. Normal RAM erişimlerine ilişkin MOV ya da LOAD/STORE makine komutlarında bu IO/Mem ucu "mem" biçiminde 
    aktive edilir. Ancak bazı IN, OUT gibi komutlarda bu uç "IO" biçiminde aktive edilmektedir. Bu durumda yardımcı işlemcilere
    erişmek için MOV, LOAD/STORE komutları değil, genellikle IN, OUT biçiminde isimlendirilen komutları kullanılmaktadır. Ancak 
    bazı yardımcı işlemciler bu "IO/Mem" ucu tam tersine "Mem" olarak aktive edildiğinde de işlevini yapacak biçimde konfigüre
    edilmiş olabilir. Bu durumda bu işlemcilere biz IN, OUT komutlarıyla değil, RAM'e erişiyormuş gibi MOV, LOAD/STORE komutlarıyla 
    erişiriz. İşte bu tekniğe "Memory Mapped IO" denilmektedir. "Memory Mapped IO" yardımcı işlemcilere sanki RAM'miş gibi erişme 
    anlamına gelir. Bunun da sistem programcısı için önemli avantajları vardır. Sistem programcısı bu sayede göstericileri kullanarak 
    bu işlemcilere erişebilmektedir. Normal "IO/Mem" ucu "IO" biçiminde aktive edilerek yapılan erişimlere "Port Mapped IO" da 
    denilmektedir. Bazı mimarilerde her iki teknik de yoğun kullanılmaktadır. Ancak bazı mimarilerde "Memory Mapped IO" tekniği daha 
    yoğun kullanılabilmektedir. "Memory Mapped IO" tekniği kullanılırken artık RAM'in ilgili adresteki kısmına erişilemez ya da bu 
    erişimin bir anlamı kalmaz. Yani adeta bu teknikte sanki RAM'in bir bölümü çıkartılmış onun yerine ilgili işlemci oraya takılmış 
    gibi bir etki oluşmaktadır. Örneğin "Memory Mapped IO" bilgisayar sistemlerinde grafik kartları tarafından yoğun olarak kullanılmaktadır. 
    Grafik kartlarını tasarlayanlar kartın üzerindeki RAM'in (bu ana RAM değil) içeriğini belli periyotlarla ekrana göndermektedir. 
    Programcı da C'de göstericileri kullanarak belli adrese yazma yapma yoluyla ekrana belirli şeylerin çıkmasını sağlayabilmektedir.

    Pekiyi yardımcı işlemcileri birbirinden ayıran şey nedir? İşte CPU'nun adres uçları bu yardımcı işlemciler tarafından özel 
    bazı değerlerde ise dikkate alınmaktadır. Yani nasıl RAM'deki byte'ların adresleri varsa yardımcı işlemcilerin de birer 
    donanımsal adresleri vardır. Bu adreslere genellikle "port numaraları" da denilmektedir. Yardımcı işlemcilerin port numaraları
    donanım mimarisini tasarlayanlar tarafından donanımsal olarak önceden belirlenmiştir. Ancak modern sistemlerde programlama 
    yoluyla değiştirilebilen port adresleri de söz konusu olmaktadır. PC mimarisinde programlanabilen port numarasına sahip 
    olan işlemcilere "Plug and Play (PnP)" işlemciler de denilmektedir.

    O halde bizim bir yardımcı işlemciyi programlayabilmemiz için şu bilgileri edinmiş olmamız gerekmektedir:

    1) Yardımcı işlemci "Port Mapped IO" mu yoksa "Memory Mapped IO" mu kullanmaktadır?
    2) Yardımcı işlemcinin port numaraları (ya da "Memory Mapped IO" söz konusu ise bellek adresleri) nedir?
    3) Bu yardımcı işlemcinin hangi portuna (ya da "Memory Mapped IO" söz konusu ise hangi adrese) hangi değerler gönderildiğinde 
    bu işlemci ne yapacaktır?
    4) İşlemci bize bilgi verecekse bunu hangi portu okuyarak (ya da "Memory Mapped IO" söz konusu ise hangi adresi okuyarak) vermektedir. 
    Verilen bilginin biçimi nedir?

    Yardımcı işlemciler yalnızca bilgisayar donanımın içerisinde donanımsal olarak çivilenmiş bir biçimde bulunmayabilirler. 
    Bazı bilgisayar sistemlerinde (örneğin masaüstü PC'lerde) genişleme yuvaları vardır. Bu genişleme yuvaları CPU'nun adres 
    ve veri yoluna erişebilmektedir. Bu genişleme yuvaları için kart tasarlayan tasarımcılar kartlarının üzerinde yardımcı
    işlemcileri bulundurabilirler. Böylece ilgili kart takıldığında sanki sisteme yeni bir yardımcı işlemci takılmış gibi 
    etki oluşmaktadır.

    CPU'ya neden "merkezi (central)" işlemci denildiğini artık anlayabilirsiniz. Bilgisayar sistemlerinde kendi yerel işlemlerinden
    sorumlu pek çok yardımcı işlemci olabilir. Ancak bunların hepsini elektriksel olarak CPU programlamaktadır. Bu nedenle CPU'ya
    merkezi işlemci denilmiştir. Tabii CPU aslında bizim yazdığımız programları çalıştırır. Yani yardımcı işlemcileri de sonuç 
    olarak biz programlamış oluruz.

    Pekiyi yardımcı işlemcileri programlarken onlara tek hamlede kaç byte bilgi gönderip onlardan kaç byte bilgi okuyabiliriz?
    İşte bazı işlemciler (özellikle eskiden tasarlanmış olanlar) byte düzeyinde programlanmaktadır. Bazıları ise WORD düzeyinde 
    bazıları ise DWORD düzeyinde programlanabilmektedir. O halde bizim bir haberleşme portuna 1 byte, 2 byte, 4 byte gönderip
    alabilmemiz gerekir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir yardımcı işlemci kernel modda programlanabiliyorsa user mode programlar bu yardımcı işlemciyi nasıl kullanmaktadır?
    İşte tipik olarak user mode programlar ioctl işlemleriyle aygıt sürücünün kodlarını çalıştırırlar. Aygıt sürücüler de 
    bu kodlarda ilgili yardımcı işlemciye komutlar yollayabilir. Bazen read/write işlemleri de bu amaçla kullanılabilmektedir.
    Tabii karmaşık yardımcı işlemciler için aygıt sürücüleri yazanlar faydalı işlemlerin daha kolay yapılabilmesi için 
    daha yüksek seviyeli fonksiyonları bir API kütüphanesi yoluyla sağlayabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşlemcilerin IN, OUT gibi makine komutları "özel (privileged)" komutlardır. Bunlar user mode'dan kullanılırsa işlemci 
    koruma mekanizması gereği bir içsel kesme oluşturur, işletim sistemi de bu kesme kodunda prosesi sonlandırır. Dolayısıyla 
    bu komutları kullanarak donanım aygıtlarıyla konuşabilmek için kernel mod aygıt sürücü yazmak gerekir.

    Aygıtlara erişmekte kullanılan komutlar CPU mimarisine göre değişebildiğinden Linux çekirdeğinde bunlar için ortak arayüze 
    sahip inline fonksiyonlar bulundurulmuştur. Bu fonksiyonlar şunlardır:

    #include <asm/io.h>

    unsigned char inb(int addr);
    unsigned short inw(int addr);
    unsigned int inl(int addr);

    void outb(unsigned char b, int addr);
    void outw(unsigned short b, int addr);
    void outl(unsigned int b, int addr);

    inb haberleşme portlarından 1 byte, inw 2 byte, inl 4 byte okumak için kullanılmaktadır. Benzer biçimde haberleşme portlarına 
    outb 1 byte, outw 2 byte ve outl 4 byte göndermek için kullanılmaktadır.

    Bazı mimarilerde bir bellek adresinden başlayarak belli bir sayıda byte'ı belli bir porta gönderen ve belli bir porttan 
    yapılan okumaları belli bir adresten itibaren belleğe yerleştiren özel makine komutları vardır. Bu komutlara string komutları 
    denilmektedir. (Intel'de string komutları yalnızca IO işlemleri ile ilgili değildir.) İşte bu komutlara sahip mimarilerde bu 
    string komutlarıyla IN, OUT yapan çekirdek fonksiyonları da bulundurulmuştur:

    #include <asm/io.h>

    void insb(unsigned long addr, void *buffer, unsigned int count);
    void insw(unsigned long addr, void *buffer, unsigned int count);
    void insl(unsigned long addr, void *buffer, unsigned int count);

    void outsb(unsigned long addr, const void *buffer, unsigned int count);
    void outsw(unsigned long addr, const void *buffer, unsigned int count);
    void outsl(unsigned long addr, const void *buffer, unsigned int count);

    insb, insw ve insl sırasıyla 1 byte 2 byte ve 4 byte'lık string fonksiyonlarıdır. Bu fonksiyonlar birinci parametresiyle 
    belirtilen port numarasından 1, 2 ya da 4 byte'lık bilgileri ikinci parametresinde belirtilen adresten itibaren belleğe 
    yerleştirirler. Bu işlemi de count kere tekrar ederler. Yani bu fonksiyonlar porttan count defa okuma yapıp okunanları buffer
    ile belirtilen adresten itibaren belleğe yerleştirmektedir. outsb, outsw ve outsl fonksiyonları ise bu işlemin tam tersini 
    yapmaktadır. Yani bellekte bir adresten başlayarak count tane byte'ı birinci parametresiyle belirtilen porta yerleştirmektedir.

    Bazı sistemlerde aygıtlar yavaş kalabilmektedir. Yani bus çok hızlı, aygıt yavaş ise o aygıt portlarına peşi sıra bilgiler 
    gönderilip alınırken sorunlar oluşabilmektedir. Bunun için bilgiyi porta gönderdikten ya da bilgiyi porttan aldıktan sonra 
    kısa bir süre bekleme yapmak gerekebilir. İşte bu nedenle yukarıdaki fonksiyonların bekleme yapan p'li (pause) versiyonları 
    da bulundurulmuştur.

    #include <asm/io.h>

    unsigned char inb_p(int addr);
    unsigned short inw_p(int addr);
    unsigned int inl_p(int addr);

    void outb_p(unsigned char b, int addr);
    void outw_p(unsigned short b, int addr);
    void outl_p(unsigned int b, int addr);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux'ta user mode'dan haberleşme portlarına IN ve OUT yapmak için basit bir aygıt sürücüsü de bulundurulmuştur. Bu aygıt 
    sürücüsüne "/dev/port" aygıt dosyasıyla erişilebilir. Tabii user mode programların bu biçimde her defasında kernel mode'a
    geçerek IN/OUT yapması verimsiz bir yöntemdir. Ancak yine de basit uygulamalar için faydalı kullanımlar söz konusu 
    olabilmektedir. Bu aygıt sürücü dosya gibi açıldıktan sonra sanki her dosya offset'i bir haberleşme portuymuş gibi işlem 
    görmektedir. Yine okuma yazma sırasında dosya göstericisi ilerletilmekte dolayısıyla başka porta konumlandırılmaktadır.

    Aşağıdaki örnekte 0x60 numaralı porttan "/dev/port" aygıt sürücüsü yoluyla 1 byte okunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/* app.c*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    int result;
    unsigned char ch;

    if ((fd = open("/dev/port", O_RDWR)) == -1)
        exit_sys("open");

    if (lseek(fd, 0x60, SEEK_SET) == -1)
        exit_sys("lseek");

    if ((result = read(fd, &ch, 1)) == -1)
        exit_sys("read");

    printf("%02X\n", ch);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                160. Ders 04/08/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir haberleşme portu ile çalışmadan önce o portun boşta olup olmadığını belirlemek gerekebilir. Çünkü başka aygıtların 
    kullandığı portlara erişmek sorunlara yol açabilmektedir. Tabii eğer biz ilgili portun kullanılmasının bir soruna yol 
    açmayacağından emin isek başkalarının kullandığı portları doğrudan kullanabiliriz. Çekirdek bu bakımdan bir kontrol 
    yapmamaktadır. Kullanmadan önce bir portun başkaları tarafından kullanılıp kullanılmadığının sorgulanması için 
    request_region isimli çekirdek fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <linux/ioport.h>

    struct resource *request_region(unsigned long first, unsigned long n, const char *name);

    Fonksiyonun birinci parametresi kullanılmak istenen port numarasının başlangıç numarasını, ikinci parametresi ilgili port 
    numarasından itibaren ardışıl kaç port numarasının kullanılacağını, üçüncü parametresi ise "/proc/ioports" dosyasında 
    görüntülenecek ismi belirtmektedir. Fonksiyon başarı durumunda portları betimleyen resource isimli yapının başlangıç 
    adresine, başarısızlık durumunda NULL adrese geri dönmektedir. request_region fonksiyonu ile tahsis edilen port numaraları 
    release_region fonksiyonu ile serbest bırakılmalıdır:

    #include <linux/ioport.h>

    void release_region(unsigned long start, unsigned long n);

    Yukarıda da belirttiğimiz gibi portların kullanılması için bu biçimde tahsisat yapma zorunluluğu yoktur. Ancak programcı 
    programlanabilir IO portları söz konusu olduğunda ilgili port numaralarını başkalarının kullanmadığından emin olmak için 
    bu yöntemi izlemelidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    PC'lerdeki klavye denetleyicisinin (klavye içerisindeki değil, PC tarafındaki denetleyicinin (orijinali Intel 8042)) 
    60H ve 64H numaralı iki portu vardır. 60H portu hem okunabilir hem de yazılabilir durumdadır. 60H portu 1 byte olarak 
    okunduğunda son basılan ya da çekilen tuşun klavye scan kodu elde edilmektedir. Yukarıda da belirttiğimiz gibi klavye 
    terminolojisinde tuşa basılırken oluşturulan scan koduna "make code", parmak tuştan çekildiğinde oluşturulan scan koduna 
    ise "break code" denilmektedir. Klavye içerisindeki işlemcinin (keyboard encoder) break code olarak önce bir F0 byte sonra 
    da make code byte'ını gönderdiğini belirtmiştik. İşte PC içerisindeki klavye denetleyicisi bu break kodu aldığında bunu iki
    byte olarak değil, yüksek anlamlı biti 1 olan byte olarak saklamaktadır. Böylece biz 60H portunu okuduğumuzda onun yüksek 
    anlamlı bitine bakarak okuduğumuz scan kodunun make code mu yoksa break code mu olduğunu anlayabiliriz.

    Klavye denetleyicisinin 60H portuna gönderilen 1 byte değere "keyboard encoder command" denilmektedir. Bu 1 byte'lık komut 
    klavye denetleyicisi tarafından klavye içerisindeki işlemciye gönderilir. Ancak bu 1 byte'tan sonra bazı komutlar parametre 
    almaktadır. Parametreler de komuttan sonra 1 byte olarak aynı port yoluyla iletilmektedir.

    Aşağıdaki örnekte klavyeden tuşlara basıldığında basılan ve çekilen tuşların make ve break code'ları yazdırılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/* irq-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/interrupt.h>
#include <asm/io.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
};

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id);

static unsigned char g_keymap[128] = {
    [30] = 'A',
    [31] = 'S',
    [32] = 'D',
    [33] = 'F',
};

static int __init generic_init(void)
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "irq-driver")) < 0) {
        printk(KERN_INFO "cannot alloc char driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "cannot allocate cdev!...\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;

    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "cannot add character device driver!...\n");
        return result;
    }

    if ((result = request_irq(1, keyboard_irq_handler, IRQF_SHARED, "irq-driver", &g_cdev)) != 0) {
        cdev_del(g_cdev);
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "interrupt couldn't registered!...\n");
        return result;
    }

    printk(KERN_INFO "irq-driver init...\n");

    return 0;
}

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id)
{
    unsigned char code;
    char *code_type;

    code = inb(0x60);

    code_type = code & 0x80 ? "Break code: " : "Make code: ";

    if (g_keymap[code & 0x7F])
        printk(KERN_INFO "%s %c (%02X)\n", code_type, g_keymap[code & 0x7F], code);
    else
        printk(KERN_INFO "%s %02X\n", code_type, code);

    return IRQ_HANDLED;
}

static void __exit generic_exit(void)
{
    free_irq(1, &g_cdev);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);
    printk(KERN_INFO "irq-driver exit...\n");
}

module_init(generic_init);
module_exit(generic_exit);

/*--------------------------------------------------------------------------------------------------------------------------
                                                161. Ders 09/08/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kesme kodları bazen bilgiyi bir kaynaktan alıp (örneğin network kartından, seri porttan, klavye denetleyicisinden) onu bir 
    yere (genellikle bir kuyruk sistemi) yerleştirip, uyuyan thread'leri uyandırmaktır. Örneğin bir thread'in klavyeden bir 
    tuşa basılana kadar bekleyeceğini düşünelim. Bu durumda thread işletim sistemi tarafından bir bekleme kuyruğuna alınır. 
    Klavyeden bir tuşa basıldığında oluşan IRQ içerisinde bu bekleme kuyruğunda bekleyen thread'ler uyandırılır.

    Aşağıda örnekte aygıt sürücüye aygıt sürücünün bir IOCTL komutunda thread bloke edilmiştir. Sonra klavyeden bir tuşa 
    basıldığında thread uykudan uyandırılıp basılmış olan tuşuna scan kodu IOCTL kodu tarafından thread'e verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* irq-driver.h */

#ifndef IRQDRIVER_H_
#define IRQDRIVER_H_

#include <linux/ioctl.h>

#define KEYBOARD_MAGIC        'k'
#define IOC_GETKEY            _IOR(KEYBOARD_MAGIC, 0, int)

#endif

/* irq-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/interrupt.h>
#include <asm/io.h>
#include "irq-driver.h"

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id);
static long keyboard_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .unlocked_ioctl = keyboard_ioctl,
};

static DECLARE_WAIT_QUEUE_HEAD(g_wq);
static int g_key;

static int __init generic_init(void)
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "irq-driver")) < 0) {
        printk(KERN_INFO "cannot alloc char driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "cannot allocate cdev!...\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;

    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "cannot add character device driver!...\n");
        return result;
    }

    if ((result = request_irq(1, keyboard_irq_handler, IRQF_SHARED, "irq-driver", &g_cdev)) != 0) {
        cdev_del(g_cdev);
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "interrupt couldn't registered!...\n");
        return result;
    }

    printk(KERN_INFO "irq-driver init...\n");

    return 0;
}

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id)
{
    int key;

    if (g_key != 0)
        return IRQ_NONE;

    key = inb(0x60);
    if (key & 0x80)
        return IRQ_NONE;

    g_key = key;
    wake_up_all(&g_wq);

    return IRQ_HANDLED;
}

static long keyboard_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    switch (cmd) {
        case IOC_GETKEY:
            g_key = 0;
            if (wait_event_interruptible(g_wq, g_key != 0))
                return -ERESTARTSYS;

            if (copy_to_user((void *)arg, &g_key, sizeof(int)) != 0)
                return -EFAULT;

            return g_key;
        default:
            return -ENOTTY;
    }
}

static void __exit generic_exit(void)
{
    free_irq(1, &g_cdev);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);
    printk(KERN_INFO "irq-driver exit...\n");
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "irq-driver.h"

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    int key;

    if ((fd = open("irq-driver", O_RDONLY)) == -1)
        exit_sys("open");

    if (ioctl(fd, IOC_GETKEY, &key) == -1)
        exit_sys("ioctl");

    printf("Scan code: %d (%02x)\n", key, key);

    close(fd);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte IOC_SETLIGHTS ioctl komutu ile 8042 klavye denetleyicisine komut gönderme yoluyla klavye ışıkları yakılıp 
    söndürülmektedir. Klavyede üç ışıklı tuş vardır: Caps-Lock, Num-Lock ve Scroll-Lock. Bu ışıkları yakıp söndürebilmek için 
    önce 60H portuna 0xED komutu gönderilir. Sonra yine 60H portuna ışıkların durumunu belirten 1 byte gönderilir. Bu byte'ın 
    düşük anlamlı 3 biti sırasıyla Scroll-Lock, Num-Lock ve Caps-Lock tuşlarının ışıklarını belirtmektedir:

    7 6 5 4 3 CL NL SL
    x x x x x x  x  x

    60H portuna komut göndermeden önce 64H portundan elde edilen değerin 2 numaralı bitinin 0 olması gerekmektedir. Ayrıntılı 
    bilgi için http://www.brokenthorn.com/Resources/OSDev19.html sayfasını inceleyebilirsiniz.

    Aşağıdaki aygıt sürücüde IOC_SETLIGHTS IOCTK komutunda klavye ışıklarının yakılıp söndürülmesi sağlanmıştır. Burada
    "app.c" isimli user mode program bir komut satırı argümanı almış ve o komut satırı argümanındaki sayıyı yukarıda 
    anlattığımız gibi klavye denetleyicisine göndermiştir. Artık pek çok klavyede Scroll-Lock ve Num-Lock tuşlarının ışıkları
    bulunmamaktadır. Programın Caps-Lock ışığını yakmasını istiyorsanız 4 argümanıyla (CL bitinin 2 numaralı bit olduğuna 
    dikkat ediniz) söndürmek istiyorsanız 0 argümanıyla çalıştırabilirsiniz. Örneğin:

    $ ./app 4
    $ ./app 0
---------------------------------------------------------------------------------------------------------------------------*/

/* irq-driver.h */

#ifndef IRQDRIVER_H_
#define IRQDRIVER_H_

#include <linux/ioctl.h>

#define KEYBOARD_MAGIC        'k'
#define IOC_GETKEY        _IOR(KEYBOARD_MAGIC, 0, int)

#endif

/* irq-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/interrupt.h>
#include <asm/io.h>
#include "irq-driver.h"

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id);
static long keyboard_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .unlocked_ioctl = keyboard_ioctl,
};

#ifndef IRQDRIVER_H_
#define IRQDRIVER_H_

#include <linux/ioctl.h>

#define KEYBOARD_MAGIC        'k'
#define IOC_GETKEY            _IOR(KEYBOARD_MAGIC, 0, int)

#endif

static DECLARE_WAIT_QUEUE_HEAD(g_wq);
static int g_key;

static int __init generic_init(void)
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "irq-driver")) < 0) {
        printk(KERN_INFO "cannot alloc char driver!...\n");
        return result;
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "cannot allocate cdev!...\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;

    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "cannot add character device driver!...\n");
        return result;
    }

    if ((result = request_irq(1, keyboard_irq_handler, IRQF_SHARED, "irq-driver", &g_cdev)) != 0) {
        cdev_del(g_cdev);
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_ERR "interrupt couldn't registered!...\n");
        return result;
    }

    printk(KERN_INFO "irq-driver init...\n");

    return 0;
}

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id)
{
    int key;

    if (g_key != 0)
        return IRQ_NONE;

    key = inb(0x60);
    if (key & 0x80)
        return IRQ_NONE;

    g_key = key;
    wake_up_all(&g_wq);

    return IRQ_HANDLED;
}

static long keyboard_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    switch (cmd) {
        case IOC_GETKEY:
            g_key = 0;
            if (wait_event_interruptible(g_wq, g_key != 0))
                return -ERESTARTSYS;

            if (copy_to_user((void *)arg, &g_key, sizeof(int)) != 0)
                return -EFAULT;

            return g_key;

        case IOC_SETLIGHTS:
            while ((inb(0x64) & 2) != 0)
                ;
            outb(0xED, 0x60);
            while ((inb(0x64) & 2) != 0)
                ;
            outb(arg, 0x60);
            break;
        default:
            return -ENOTTY;
    }
    return 0;
}

static void __exit generic_exit(void)
{
    free_irq(1, &g_cdev);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);
    printk(KERN_INFO "irq-driver exit...\n");
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "irq-driver.h"

#define CAPS_LOCK        0x04
#define NUM_LOCK        0x02
#define SCROLL_LOCK        0x04

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    int key;
    int keycode;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    keycode = atoi(argv[1]);

    if ((fd = open("irq-driver", O_RDONLY)) == -1)
        exit_sys("open");

    if (ioctl(fd, IOC_SETLIGHTS, keycode) == -1)
        exit_sys("ioctl");

    close(fd);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Derleyiciler ve işlemciler tarafından yapılan önemli bir optimizasyon temasına "komutların yer değiştirilmesi (instruction 
    reordering)" denilmektedir. Bu optimizasyon derleyici tarafından da bizzat işlemcinin kendisi tarafından da yapılabilmektedir. 
    Burada birbirlerini normal bir durumda etkilemeyecek iki ya da daha fazla ayrı makine komutunun yerleri daha hızlı çalışma 
    sağlamak için değiştirilmektedir. Bu tür yer değiştirmeler normal user mode programlarda hiçbir davranış değişikliğine yol 
    açmazlar. Ancak işletim sistemi ve aygıt sürücü kodlarında ve özellikle IO portlarına erişim söz konusu olduğunda bu 
    optimizasyon olumsuz yan etkilere yol açabilmektedir. Örneğin birbirleriyle alakasız iki adrese yazma yapılması durumunda 
    yazma komutlarının yer değiştirmesi işlemcinin bu işleri daha hızlı yapabilmesine yol açabilmektedir. Fakat IO portları ve 
    Memory Mapped IO söz konusu olduğunda bu sıralama değişikliği istenmeyen olumsuz sonuçlar doğurabilmektedir. İşte bu yer 
    değiştirmeyi ortadan kaldırmak için "bariyer (barrier)" koyma yöntemi uygulanmaktadır. Derleyici ve işlemci bariyerin yukarısıyla
    aşağısını yer değiştirmemektedir. Bariyer fonksiyonları şunlardır:

    #include <asm/system.h>

    void rmb(void);
    void wmb(void);
    void mb(oid);

    rmb fonksiyonunun aşağısındaki kodlar yukarısındaki okuma işlemleri yapıldıktan sonra yapılırlar. wmb fonksiyonunun ise 
    yukarısındaki yazma işlemleri yapıldıktan sonra aşağıdaki işlemler yapılırlar. mb fonksiyonu ise hem okuma hem yazma 
    için yukarıdaki ve aşağıdaki kodları birbirlerinden ayırmaktadır. Örneğin PORT1 portuna yazma yapıldıktan sonra PORT2 
    portuna yazma yapılacak olsun. Şöyle bir bariyer kullanmalıyız:

    outb(cmd1, port1);
    wmb();
    outb(cmd2, port2);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Memory Mapped IO işlemi pek çok mimaride normal göstericilerle yapılabilmektedir. Yani aslında bu mimarilerde Memory Mapped IO 
    için özel kernel fonksiyonlarının kullanılmasına gerek yoktur. Ancak bazı mimarilerde Memory Mapped IO işlemi için özel bazı 
    işlemlerin de yapılması gerekebilmektedir. Bu nedenle bu işlemlerin taşınabilir yapılabilmesi için özel kernel fonksiyonlarının 
    kullanılması tavsiye edilir.

    Tıpkı normal IO işlemlerinde olduğu gibi Memory Mapped IO için de iki farklı aygıt aynı adres bölgesini kullanmasın diye bir 
    registration işlemi söz konusudur. Bu işlemler request_mem_region ve release_mem_region fonksiyonlarıyla yapılmaktadır:

    #include <linux/ioport.h>

    struct resource *request_mem_region(unsigned long start, unsigned long len, const char *name);

    Fonksiyonun birinci parametresi başlangıç bellek adresini, ikinci parametresi alanın uzunluğunu belirtmektedir. Üçüncü parametre 
    ise "/proc/iomem" dosyasında görüntülenecek isimdir. Fonksiyon başarı durumunda resource isimli bir yapı nesnesinin adresine, 
    başarısızlık durumunda NULL adrese geri dönmektedir. Daha önce register ettirilmiş olan bellek bölgesini serbest bırakmak için 
    (yani register ettirilmemiş hale getirmek için) release_mem_region fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <linux/ioport.h>

    void release_mem_region(unsigned long start, unsigned long len);

    Fonksiyonun birinci parametresi başlangıç bellek adresini, ikinci parametresi ise uzunluğu belirtmektedir.

    Aşağıdaki fonksiyonlar addr ile belirtilen bellek adresinden 1 byte, 2 byte ve 4 byte okurlar.

    #include <asm/io.h>

    unsigned int ioread8(void *addr);
    unsigned int ioread16(void *addr);
    unsigned int ioread32(void *addr);

    Aşağıdaki fonksiyonlar ise addr ile belirtilen bellek adresine 1 byte, 2 byte ve 4 byte bilgi yazmaktadır:

    #include <asm/io.h>

    void iowrite8(u8 value, void *addr);
    void iowrite16(u16 value, void *addr);
    void iowrite32(u32 value, void *addr);

    Yukarıdaki fonksiyonların rep'li (repetition/tekrar) versiyonları da vardır:

    #include <asm/io.h>

    void ioread8_rep(void *addr, void *buf, unsigned long count);
    void ioread16_rep(void *addr, void *buf, unsigned long count);
    void ioread32_rep(void *addr, void *buf, unsigned long count);

    void iowrite8_rep(void *addr, const void *buf, unsigned long count);
    void iowrite16_rep(void *addr, const void *buf, unsigned long count);
    void iowrite32_rep(void *addr, const void *buf, unsigned long count);

    Bu fonksiyonlar Memory Mapped IO adresinden belli bir adrese belli miktarda (count parametresi) byte, word ya da dword transfer 
    etmektedir.

    Tıpkı memcpy fonksiyonunda olduğu gibi Memory Mapped IO adresi ile bellek arasında blok kopyalaması yapan iki fonksiyon 
    bulunmaktadır:

    #include <asm/io.h>

    void memcpy_fromio(void *dest, const void *source, unsigned int count);
    void memcpy_toio(void *dest, const void *source, unsigned int count);

    Belli bir Memory Mapped IO adresine belli bir byte'ı n defa dolduran fonksiyon da şöyledir:

    #include <asm/io.h>

    void memset_io(void *dest, u8 value, unsigned int count);

    Bu fonksiyonu memset fonksiyonuna benzetebilirsiniz.

    Aygıtın kullandığı bellek adresi genellikle fiziksel adrestir. Örneğin aygıt 0xFFFF8000 gibi bir adresi kullanıyorsa bu 
    genellikle fiziksel anlamına gelir. Halbuki aygıt sürücünün bu fiziksel adrese erişebilmesi için bu dönüşümü yapacak sayfa 
    tablosu girişlerinin olması gerekir. İşte bu girişleri elde edebilmek için şu fonksiyonlar bulundurulmuştur:

    #include <asm/io.h>

    void *ioremap(unsigned long physical_address, unsigned long size);

    Bu fonksiyon fiziksel adrese erişebilmek için gereken sayfa tablosu adresini bize verir. Gerçi genellikle fiziksel RAM 
    daha önceden de belirtildiği gibi Linux'ta sanal belleğin PAGE_OFFSET ile belirtilen kısmından başlanarak map edilmiştir.

    Bu işlemi geri almak için iounmap fonksiyonu kullanılmaktadır:

    #include <asm/io.h>

    void iounmap(void *addr);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                162. Ders 11/08/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Blok aygıt sürücüleri (block device drivers) disk benzeri birimlerden bloklu okuma ve yazma yapabilmek için kullanılan 
    özel aygıt sürücülerdir. Daha önceden de belirttiğimiz gibi disk benzeri birimlerden bir hamlede okunabilecek ya da 
    yazılabilecek bilgi miktarına "sektör" denilmektedir. İşte blok aygıt sürücüleri transferleri byte byte değil blok blok 
    (sektör sektör) yapmaktadır. Örneğin bir diskten 1 byte okuma diye bir şey yoktur. Ya da bir diske 1 yazma diye bir şey 
    yoktur. Diskteki 1 byte değiştirilecekse önce onun bulunduğu sektör RAM'e okunur, değişiklik RAM üzerinde yapılır. Sonra 
    o sektör yeniden diske yazılır. Tipik transfer bu adımlardan geçilerek gerçekleştirilmektedir. Bir sektör değişebilse de 
    hemen her zaman 512 byte'tır.

    Bir Linux sistemini kurduğumuzda "/dev" dizininin altında disklerle işlem yapan aygıt sürücülere yönelik aygıt dosyaları
    da oluşturulmuş durumdadır. Blok aygıt sürücülerine ilişkin aygıt dosyaları "ls -l" komutunda dosya türü olarak 'b' biçiminde 
    görüntülenmektedir. Örneğin:

    $ ls -l /dev
    ...
    brw-rw----  1 root disk      8,   0 Ağu  7 13:57 sda
    brw-rw----  1 root disk      8,   1 Ağu  7 13:57 sda1
    brw-rw----  1 root disk      8,   2 Ağu  7 13:57 sda2
    brw-rw----  1 root disk      8,   3 Ağu  7 13:57 sda3
    crw-rw----+ 1 root cdrom    21,   0 Ağu  7 13:57 sg0
    crw-rw----  1 root disk     21,   1 Ağu  7 13:57 sg1
    ...

    Burada "sda" aygıt dosyası diske bir bütün olarak erişmek için kullanılırken sda1, sda2, sda3 aygıt dosyaları ise diskteki disk 
    bölümlerine (partition) erişmek için kullanılmaktadır. Bu aygıt dosyalarının majör numaralarının aynı olduğuna ancak minör 
    numaralarının farklı olduğuna dikkat ediniz. Biz bir flash belleği USB soketine taktığımızda burada flash belleğe erişmek için 
    gerekli olan aygıt dosyaları otomatik biçimde oluşturulacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sistemleri bloklu çalışan aygıtlarda erişimi hızlandırmak için ismine "IO çizelgelemesi (IO Scheduling)" denilen 
    bir yöntem uygulamaktadır. Çeşitli prosesler diskten çeşitli sektörleri okumak istediğinde ya da yazmak istediğinde bunlar 
    işletim sistemi tarafından birleştirilerek disk erişimleri azaltılmaktadır. Yani bu tür transferlerde transfer talep edildiği
    anda değil, biraz bekletilerek (çok kısa bir zaman) gerçekleştirilebilmektedir. Bu tür durumlarda işletim sistemleri ilgili 
    thread'i bloke ederek transfer sonlanana kadar wait kuyruklarında bekletmektedir. Disk sistemi bilgisayar sistemlerinin 
    en yavaş kısmını oluşturmaktadır. SSD diskler bile yazma bakımından RAM'e göre binlerce kat yavaştır. İşte işletim sistemleri 
    aslında ayrık olan birtakım okuma yazma işlemlerini diskte mümkün olduğunca ardışıl hale getirerek disk erişiminden kaynaklanan 
    zaman kaybını minimize etmeye çalışır. Disk sistemlerinde ayrık işlemler yerine peşi sıra blokların tek hamlede okunup yazılması 
    ciddi hız kazancı sağlayabilmektedir. Farklı proseslerin sektör okuma istekleri aslında bazen birbirine yakın bölgelerde 
    gerçekleşir. İşte onların yeniden sıralanması gibi faaliyetler IO çizelgeleyicisinin önemli görevlerindendir.

    Blok aygıt sürücüleri bazı bakımlardan karakter aygıt aygıt sürücülerine benzese de bu IO çizelgelemesi yüzünden tasarımsal 
    farklılıklara sahiptir. Karakter aygıt sürücülerinde her read ve write işlemi için bir IO çizelgelemesi yapılmadan aygıt 
    sürücünün fonksiyonları çağrılmaktadır. Çünkü karakter aygıt sürücülerinde neticede disk gibi zaman alıcı birimler ile 
    uğraşılmamaktadır. Ancak blok aygıt sürücülerinde transfer isteği çizelgelenerek bazen gecikmelerle yerine getirilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir blok aygıt sürücüsü oluşturmak için ilk yapılacak işlem tıpkı karakter aygıt sürücülerinde olduğu gibi blok aygıt 
    sürücüsünün bir isim altında aygıt numarası belirtilerek register ettirilmesidir. Bu işlem register_blkdev fonksiyonuyla 
    yapılmaktadır:

    #include <linux/blkdev.h>

    int register_blkdev(unsigned int major, const char *name);

    Fonksiyonun birinci parametresi aygıtın majör numarasını belirtir. Eğer majör numara olarak 0 geçilirse fonksiyon boş bir 
    majör numarayı kendisi tahsis etmektedir. Fonksiyonun ikinci parametresi ise "/proc/devices" dosyasında görüntülenecek olan 
    ismi belirtmektedir. Fonksiyon başarı durumunda majör numaraya, başarısızlık durumunda negatif error koduna geri dönmektedir. 
    İkinci parametre aygıt sürücünün /proc/devices dosyasında görüntülenecek ismini belirtmektedir. Örneğin:

    if ((g_major = register_blkdev(0, "generic-blkdev")) < 0) {
        printk(KERN_INFO "cannot alloc block driver!...\n");
        return result;
    }

    Modül boşaltılırken bu işlemin geri alınması için unregister_blkdev fonksiyonu kullanılmaktadır:

    #include <linux/blkdev.h>

    void unregister_blkdev(unsigned int major, const char *name);

    Fonksiyonun parametrik yapısı register_blkdev fonksiyonuyla tamamen aynıdır. Örneğin:

    unregister_blkdev(g_major, "generic-blkdev");

    Bizim daha önce kullandığımız "load" script'i karakter aygıt dosyası yaratıyordu. Halbuki bizim artık blok aygıt dosyaları 
    yaratmamız gerekir. Bunun için "load" ve "unload" script'lerini "loadblk" ve "unloadblk" ismiyle yeniden yazacağız. Tabii 
    aslında "unload" script'inde değiştirilecek bir şey yoktur. Ancak isimsel uyumluluk bakımından biz her iki dosyayı da yeniden 
    yeni isimlerle oluşturacağız. Bu iki script'e de "executable" haklarının verilmesi gerektiğini anımsayınız.

    $ sudo chmod +x loadblk unloadblk

    /* loadblk (bu satırı dosyaya kopyalamayınız) */

    #!/bin/bash

    module=$1
    mode=666

    /sbin/insmod ./$module.ko ${@:2} || exit 1
    major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
    rm -f $module
    mknod -m $mode $module b $major 0

    /* unloadblk (bu satırı dosyaya kopyalamayınız) */

    #!/bin/bash

    module=$1
 
    /sbin/rmmod ./$module.ko || exit 1
    rm -f $module
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-blkdev-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/blkdev.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Block Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static int g_major;

static int __init generic_init(void)
{
    int result;

    if ((g_major = register_blkdev(0, "generic-blkdev")) < 0) {
        printk(KERN_INFO "cannot alloc block driver!...\n");
        return result;
    }

    printk(KERN_INFO "generic-block-driver init...\n");

    return 0;
}

static void __exit generic_exit(void)
{
    unregister_blkdev(g_major, "generic-blkdev");

    printk(KERN_INFO "generic-block-driver exit...\n");
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += $(file).o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

 /* loadblk (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module b $major 0

/* unloadblk (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/*--------------------------------------------------------------------------------------------------------------------------
                                                163. Ders 16/08/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Blok aygıt sürücüleri için en önemli nesne gendisk isimli nesnesidir. Blok aygıt sürücü çekirdekte bu nesne ile temsil 
    edilmektedir. gendisk nesnesi alloc_disk isimli fonksiyonla (aslında bir makro olarak yazılmıştır) tahsis edilmektedir.
    Ancak 5'li çekirdeklerle birlikte fonksiyonun ismi blk_alloc_disk biçiminde değiştirilmiştir. Ayrıca aşağıdaki fonksiyonların 
    bir bölümünün bulunduğu <linux/genhd.h> dosyası da çekirdeğin 5.18 versiyonunda kaldırılmış buradaki fonksiyonların 
    prototipleri <linux/blkkdev.h> dosyasına taşınmıştır.

    #include <linux/genhd.h>

    struct gendisk *alloc_disk(int minors);            /* eski çekirdek versiyonları bu fonksiyonu kullanıyor */
    struct gendisk *blk_alloc_disk(int minors);        /* yeni çekirdek versiyonları bu fonksiyonu kullanıyor */

    Fonksiyonlar parametre olarak aygıt sürücünün destekleyeceği minör numara sayısını almaktadır. Geri dönüş değeri de diski 
    temsil eden gendisk isimli yapı nesnesinin adresidir. (Birden fazla minör numaranın söz konusu olduğu durumda geri döndürülen 
    adres aslında bir dizi adresidir.) Fonksiyonlar başarısızlık durumunda NULL adrese geri dönmektedir. Başarısızlık durumunda 
    bu fonksiyonları çağıran aygıt sürücü fonksiyonlarını -ENOMEM değeri ile geri döndürebilirsiniz. Örneğin:

    static struct gendisk *g_gdisk;

    if ((g_gdisk = blk_alloc_disk(1)) == NULL) {
        ...
        return -ENOMEM;
    }

    alloc_disk ile elde edilen gendisk nesnesinin içinin doldurulması gerekmektedir. Bu yapının doldurulması gereken elemanları 
    şunlardır:

    - Yapının major isimli elemanına aygıt sürücünün majör numarası yerleştirilmelidir. Örneğin:
şöyledi
    g_gdisk->major = g_major;

    - Yapının first_minor elemanına aygıt sürücünün ilk minör numarası yerleştirilmelidir (Tipik olarak 0). Örneğin:

    g_gdisk->first_minor = 0;

    - Yapının flags elemanına duruma göre bazı bayraklar girilebilmektedir. Örneğin ramdisk için bu bayrak GENHD_FL_NO_PART_SCAN 
    biçiminde girilebilir. Örneğin:

    g_gdisk->flags = GENHD_FL_NO_PART_SCAN;

    - Yapının fops elemanına aygıt sürücü açıldığında, kapatıldığında, ioctl işlemi sırasında vs. çağrılacak fonksiyonların 
    bulunduğuğu block_device_operations isimli yapının adresi atanmalıdır. Bu yapı karakter aygıt sürücülerindeki file_operations 
    yapısına benzetilebilir. Yapının iki önemli elemanı open ve release elemanlarıdır. Burada belirtilen fonksiyonlar aygıt 
    sürücü açıldığında ve her kapatıldığında çağrılmaktadır. Örneğin:

    static struct block_device_operations g_bops = {
        /* ... */
    };

    g_gdisk->fops = &g_bops;

    - Yapının queue elemanına programcı tarafından yaratılacak olan request_queue nesnesinin adresi atanmalıdır. request_queue 
    aygıt sürücüden read/write işlemi yapıldığında çekirdeğin IO çizelgeleyici alt sistemi tarafından optimize edilen işlemlerin 
    yerleştirileceği kuyruk sistemidir. Programcı ileride görüleceği üzere bu kuyruk sisteminden istekleri alarak yerine getirir. 
    Maalesef bu kuyruğun yaratılması ve işleme sokulması için gerekli kernel fonksiyonları kernel'ın çeşitli versiyonlarında 
    değiştirilmiştir. Eskiden 4'lü çekirdeklerde request_queue nesnesi oluşturmak için blk_init_queue isimli bir fonksiyon 
    kullanılıyordu. Sonra 5'li çekirdeklerle birlikte request_queue işlemleri üzerinde değişiklikler yapıldı. Biz kursumuzda 
    5'li çekirdekler kullanıyoruz. Ancak önceki çekirdeklerde kullanılan fonksiyonlar üzerinde de durmak istiyoruz. Burada önce 
    eski çekirdeklerdeki request_queue işlemlerini ele alıp sonra ayrı paragrafta yeni çekirdeklere ilişkin değişiklikler üzerinde
    duracağız.

    Eski çekirdeklerde request_queue nesnesi oluşturmak için blk_init_queue isimli bir fonksiyon kullanılıyordu. Fonksiyonun 
    prototipi şöyledir:

    #include <linux/blkdev.h>

    typedef void (request_fn_proc) (struct request_queue *q);
    struct request_queue *blk_init_queue(request_fn_proc *rfn, spinlock_t *lock);

    Fonksiyonun birinci parametresi kuyruktan gelen istekleri almakta kullanılan request_fn_proc türünden bir nesnenin adresini 
    almaktadır. İkinci parametre kuyruğu korumak için kullanılan spinlock nesnesini belirtmektedir. Fonksiyonun birinci parametresine 
    geri dönüş değeri void olan parametresi struct gendisk * türünden olan bir fonksiyonun adresi girilmelidir. Bu fonksiyon kuyruk 
    işlemlerini yapmak için bulundurulur. blk_init_queue fonksiyonu başarı durumunda request_queue nesnesinin adresiyle, başarısızlık 
    durumunda NULL adresle geri dönmektedir. Bu durumda çağıran fonksiyonu -ENOMEM değeri geri döndürebilirsiniz. Örneğin:

    static struct request_queue *g_rq;
    static spinlock_t g_sl;

    static void request_proc(struct request_queue *rq)
    {
        /* ... */
    }
    ...
    if ((g_rq = blk_init_queue(request_proc, &g_sl)) == NULL) {
        ...
        return -ENOMEM;
    }

    Biz burada elde ettiğimiz request_queue nesnesinin adresini gendisk yapısının queue elemanına atamalıyız. Örneğin:

    g_gdisk->queue = g_rq;

    blk_init_queue fonksiyonuyla yaratılan kuyruk nesnesinin kullanım bittikten sonra cleanup_queue fonksiyonuyla boşaltılması 
    gerekmektedir:

    #include <linux/blkdev.h>

    void blk_cleanup_queue(struct request_queue *rq);

    Fonksiyon parametre olarak request_queue nesnesinin adresini almaktadır.

    Yeni kuyruk fonksiyonları izleyen paragraflarda ele alınacaktır.

    - gendisk yapısının içerisine diskin (blok aygıt sürücüsünün temsil ettiği medyanın) kapasitesi set edilmelidir. Bu işlem 
    set_capacity fonksiyonuyla yapılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <linux/genhd.h>

    void set_capacity(struct gendisk *disk, sector_t size);

    Fonksiyonun birinci parametresi gendisk yapısının adresini, ikinci parametresi aygıtın sektör uzunluğunu almaktadır. (Aslında 
    bu fonksiyon gendisk yapısının ilgili elemanını set etmektedir.) Fonksiyonun ikinci parametresi aygıt sürücünün temsil 
    ettiği aygıtın sektör uzunluğunu almaktadır. Bir sektör 512 byte'tır. Örneğin:

    set_capacity(g_gdisk, 1000);

    - gendisk yapısının disk_name isimli elemanı char türden bir dizi belirtmektedir. Bu diziye disk isminin bulunduğu 
    yazı kopyalanmalıdır. Disk ismi "/sys/block" dizininde görüntülenecek dosya ismini belirtmektedir. Örneğin:

    strcpy(g_gdisk->disk_name, "myblockdev");

    - Nihayet gendisk yapısının private_data elemanına programcı kendi yapı nesnesinin adresini yerleştirebilir. Örneğin 
    daha önce karakter aygıt sürücülerinde yaptığımız gibi bu private_data elemanına gendisk nesnesinin içinde bulunduğu 
    yapı nesnesinin adresini atayabiliriz.

    Aşağıdaki örnekte yukarıda anlatılan kısma kadar olan işlemleri içeren bir blok aygıt sürücü örneği verilmiştir. Örneğin:

    struct BLOCKDEV {
        spinlock_t sl;
        struct gendisk *gdisk;
        struct request_queue *rq;
        size_t capacity;
    };
    static struct BLOCKDEV g_bdev;
    ...
    g_gdisk->private_data = &g_bdev;

    Tabii buradaki örnekte g_bdev zaten bir nesne olduğu için ona private_data yoluyla erişmeye gerek kalmamaktadır. Ancak 
    aygıt sürücümüz birden fazla minör numarayı destekliyorsa her aygıtın ayrı bir BLOCKDEV yapısı olacağı için ilgili 
    aygıta bu private_data elemanı yoluyla erişebiliriz.

    blk_alloc_disk fonksiyonu ile elde edilen gendisk nesnesi add_disk fonksiyonu ile sisteme eklenmelidir:

    #include <linux/genhd.h>

    void add_disk(struct gendisk *disk);        /* eski çekirdek versiyonlarındaki prototip */

    Bu fonksiyonun geri dönüş değeri 5'li çekirdeklerle birlikte int yapılmıştır:

    int add_disk(struct gendisk *disk);            /* yeni çekirdek versiyonlarındaki prototip */

    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda negatif errno değerine geri dönmektedir. Örneğin:

    if ((result = add_disk(g_gdisk)) != 0) {
        ...
        return result;
    }

    alloc_disk ve add_disk fonksiyonuyla tahsis edilen ve sisteme yerleştirilen gendisk nesnesi del_gendisk fonksiyonuyla serbest 
    bırakılmaktadır:

    #include <linux/genhd.h>

    void del_gendisk(struct gendisk *gdisk);

    Örneğin:

    if ((g_gdisk = alloc_disk(1)) == NULL) {
        ...
        return -ENOMEM;
    }

    if ((result = add_disk(g_bdev->gdisk)) != 0) {
        ...
        return result;
    }
    ...
    del_gendisk(g_gdisk);

    Aşağıda şimdiye kadar gördüğümüz işlemleri yapan basit bir blok aygıt sürücüsü iskeleti verilmiştir. Burada iki ayrı 
    program veriyoruz. Birinci program global değişkenler kullanılarak yazılmıştır. İkincisi ise bu global değişkenlerin 
    BLOCKDEV isimli bir yapıya yerleştirilmiş biçimidir. Tabii yukarıda da belirttiğimiz gibi aşağıdaki aygıt sürücü kodlarında
    eski request_queue fonksiyonları kullanılmıştır. Dolayısıyla bu kodlar 5'li ve sonraki çekirdeklerde derlenmeyecektir.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-blkdev.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/blkdev.h>
#include <linux/genhd.h>

#define KERNEL_SECTOR_SIZE        512
#define CAPACITY                (KERNEL_SECTOR_SIZE * 1000)

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Block Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static int g_major;
static struct gendisk *g_gdisk;
static struct block_device_operations g_bops = {
    //...
};
static struct request_queue *g_rq;
static struct request_queue *g_rq;
static spinlock_t g_sl;

typedef void (request_fn_proc) (struct request_queue *q);
struct request_queue *blk_init_queue(request_fn_proc *rfn, spinlock_t *lock);

static void request_proc(struct request_queue *rq);

static int __init generic_init(void)
{
    int result;

    if ((g_major = register_blkdev(0, "generic-blkdev")) < 0) {
        printk(KERN_INFO "cannot block driver!...\n");
        return result;
    }

    if ((g_gdisk = blk_alloc_disk(1)) == NULL) {
        printk(KERN_ERR "cannot alloc disk!...\n");
        return -ENOMEM;
    }
    if ((result = add_disk(g_gdisk)) != 0) {
        del_gendisk(g_gdisk);
        printk(KERN_ERR "cannot add disk!...\n");
        return result;
    }
    g_gdisk->major = g_major;
    g_gdisk->first_minor = 0;
    g_gdisk->flags = GENHD_FL_NO_PART_SCAN;
    g_gdisk->fops = &g_bops;

    if ((g_rq = blk_init_queue(request_proc, &g_sl)) == NULL) {
        del_gendisk(g_gdisk);
        unregister_blkdev(g_major, "generic-blkdev");
        return -ENOMEM;
    }

    g_gdisk->queue = g_rq;
    set_capacity(g_gdisk, CAPACITY);
    strcpy(g_gdisk->disk_name, "myblockdev");

    printk(KERN_INFO "generic-block-driver init...\n");

    return 0;
}

static void request_proc(struct request_queue *rq)
{
    /* ... */
}

static void __exit generic_exit(void)
{
    cleanup_queue(g_rq);
    del_gendisk(g_gdisk);
    unregister_blkdev(g_major, "generic-blkdev");

    printk(KERN_INFO "generic-block-driver exit...\n");
}

module_init(generic_init);
module_exit(generic_exit);

/* generic-blkdev.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/slab.h>
#include <linux/blkdev.h>

#define KERNEL_SECTOR_SIZE        512
#define CAPACITY                (KERNEL_SECTOR_SIZE * 1000)

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Block Device Driver");
MODULE_AUTHOR("Kaan Aslan");

int g_major = 0;

struct BLOCKDEV {
    spinlock_t sl;
    struct gendisk *gdisk;
    struct request_queue *rq;
    size_t capacity;
};

static int generic_open(struct block_device *bdev, fmode_t mode);
static void generic_release(struct gendisk *gdisk, fmode_t mode);
static void request_proc(struct request_queue *rq);

static struct block_device_operations g_devops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release
};

static struct BLOCKDEV *g_bdev;

static int __init generic_init(void)
{
    int result = 0;

    if ((g_major = register_blkdev(g_major, "generic-bdriver")) < 0) {
        printk(KERN_ERR "cannot register block driver!...\n");
        return g_major;
    }

    if ((g_bdev = kmalloc(sizeof(struct BLOCKDEV), GFP_KERNEL)) == NULL) {
        printk(KERN_ERR "cannot allocate memory!...\n");
        result = -ENOMEM;
        goto EXIT1;
    }
    memset(g_bdev, 0, sizeof(struct BLOCKDEV));
    g_bdev->capacity = CAPACITY;

    spin_lock_init(&g_bdev->sl);
    if ((g_bdev->rq = blk_init_queue(request_proc, &g_bdev->sl)) == NULL) {
        printk(KERN_ERR "cannot allocate queue!...\n");
        result = -ENOMEM;
        goto EXIT2;
    }
    g_bdev->rq->queuedata = g_bdev;
    if ((g_bdev->gdisk = alloc_disk(1)) == NULL) {
        result = -ENOMEM;
        goto EXIT3;
    }
    g_bdev->gdisk->major = g_major;
    g_bdev->gdisk->first_minor = 0;
    g_bdev->gdisk->flags = GENHD_FL_NO_PART_SCAN;
    g_bdev->gdisk->fops = &g_devops;
    g_bdev->gdisk->queue = g_bdev->rq;
    set_capacity(g_bdev->gdisk, g_bdev->capacity >> 9);
    g_bdev->gdisk->private_data = g_bdev;
    strcpy(g_bdev->gdisk->disk_name, "blockdev");

    add_disk(g_bdev->gdisk);

    printk(KERN_INFO "Module initialized with major number %d...\n", g_major);

    return result;

EXIT3:
    blk_cleanup_queue(g_bdev->rq);
EXIT2:
    kfree(g_bdev);
EXIT1:
    unregister_blkdev(g_major, "generic-bdriver");

    return result;
}

static int generic_open(struct block_device *bdev, fmode_t mode)
{
    printk(KERN_INFO "device opened...\n");

    return 0;
}

static void generic_release(struct gendisk *gdisk, fmode_t mode)
{
    printk(KERN_INFO "device closed...\n");
}

static void request_proc(struct request_queue *rq)
{
    /* ... */
}

static void __exit generic_exit(void)
{
    del_gendisk(g_bdev->gdisk);
    blk_cleanup_queue(g_bdev->rq);
    kfree(g_bdev);
    unregister_blkdev(g_major, "generic-bdriver");

    printk(KERN_INFO "Goodbye...\n");
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += generic.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* loadblk (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module b $major 0

/* unloadblk (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "keyboard-ioctl.h"

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open("generic-bdriver", O_RDONLY)) == -1)
        exit_sys("open");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                164. Ders 18/08/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Blok aygıt sürücülerinde yukarıda belirtilen işlemlerden sonra artık transfer işleminin yapılması için bulundurulan fonksiyonun
    (örneğimizde request_proc) yazılması aşamasına geldik. User mode kodlar tarafından blok transferine yönelik bir istek oluştuğunda 
    (örneğin blok aygıt sürücüsünden bir sektör okunmak istediğinde) çekirdeğin IO çizelgeleyicisi bunları çizelgeleyerek uygun bir 
    zamanda transfer edilebilmesi için bizim belirttiğimiz ve yukarıdaki örnekte ismini request_proc olarak verdiğimiz fonksiyonu 
    çağırmaktadır. Yani örneğimizdeki request_proc bizim tarafımızdan değil, çekirdek tarafından callback fonksiyon olarak çağrılmaktadır. 
    Bizim de bu fonksiyon içerisinde kuyruğa bırakılmış blok transfer isteklerini kuyruktan alarak gerçekleştirmemiz gerekir.

    Örneğin bir blok aygıt sürücüsünü user mode'da open fonksiyonuyla açıp içerisinden 10 byte'ı read fonksiyonuyla okumak isteyelim. 
    Eğer bu aygıt sürücü karakter aygıt sürücüsü olsaydı çekirdek doğrudan aygıt sürücünün read fonksiyonunu çağıracaktı. Aygıt 
    sürücü de istenen 10 byte'ı user mode'daki adrese transfer edecekti. Halbuki blok aygıt sürücüsü durumunda çekirdek aygıt 
    sürücüden 10 byte transfer istemeyecektir. İlgili 10 byte'ın bulunduğu bloğun (blok ardışıl n sektördür) transferini isteyecektir. 
    User mode programa o bloğun içerisindeki 10 byte'ı vermek çekirdeğin görevidir. Blok aygıt sürücülerinden transferler byte 
    düzeyinde değil, blok düzeyinde yapılmaktadır. Yani blok aygıt sürücülerinden transfer edilecek en küçük birim 1 sektör 
    yani 512 byte'tır. Şüphesiz kernel 10 byte okuma isteğine konu olan yerin aygıttaki sektör numarasını hesap eder ve o sektörden 
    itibaren blok transferi ister.

    Kernel aygıt sürücünün transfer edeceği blokları bir kuyruk sistemine yerleştirir. Bu kuyruk sistemi request_queue denilen 
    bir yapı ile temsil edilmiştir. Bu kuyruğun içerisindeki kuyruk elemanları request isimli yapı nesnelerinden oluşmaktadır. 
    (Yani request_queue aslında request yapılarının oluşturduğu bir kuyruk sistemidir.)

    Her request nesnesi kendi içerisinde bio isimli yapı nesnelerinden oluşmaktadır. request nesnesinin içerisindeki bio nesneleri 
    bir bağlı liste biçiminde tutulmaktadır. Her bio yapısının sonunda ise değişken sayıda (yani n tane) bio_vec yapıları bulunmaktadır. 
    İşte transfer işini yapacak fonksiyon transfere ilişkin bilgileri bu bio_vec yapısından elde etmektedir.

    request_queue: request ---> request ---> request ---> request ...
    request: bio ---> bio ---> bio ---> bio ---> bio ---> ...
    bio: bio_vec[N]

    Buradan da görüldüğü gibi request_queue nesneleri request nesnelerinden, request nesneleri bio nesnelerinden, bio nesneleri de 
    bio_vec nesnelerinden oluşmaktadır.

    İşte transfer fonksiyonu kernel tarafından çağrıldığında "request_queue içerisindeki request nesnelerine elde edip, bu request 
    nesnelerinin içerisindeki bio nesnelerini elde edip, bio nesneleri içerisindeki bio_vec dizisinde belirtilen transfer bilgilerine 
    ilişkin transferleri" yapması gerekir. Şüphesiz bu işlem ancak açık ya da örtük iç içe 3 döngü ile yapılabilir. Yani bir döngü 
    request nesnelerini elde etmeli, onun içerisindeki bir döngü bio nesnelerini elde etmeli, onun içerisindeki bir döngü de bio_vec 
    nesnelerini elde etmelidir.

    request_queue içerisindeki request nesnelerinin elde edilmesi birkaç biçimde yapılabilmektedir. Yöntemlerden tipik olanı şöyledir:

    static void request_proc(struct request_queue *rq)
    {
        struct request *rqs;

        for (;;) {
            if ((rqs = blk_fetch_request(rq)) == NULL)
                break;

            if (blk_rq_is_passthrough(rqs)) {
                __blk_end_request_all(rqs, -EIO);
                continue;
            }

            ...

            __blk_end_request_all(rqs, 0);
        }
    }

    Burada blk_fetch_request fonksiyonu kuyruğun hemen başındaki request nesnesini alarak onu kuyruktan siler. Böylece döngü 
    içerisinde tek tek request nesneleri elde edilmiştir. blk_rq_is_passthrough fonksiyonu dosya sistemi ile alakalı olmayan request 
    nesnelerini geçmek için kullanılır. Bazı request nesneleri transferle ilgili değildir. Bunların geçilmesi gerekmektedir. Bir 
    request nesnesi kuyruktan alındıktan sonra akıbeti konusunda çekirdeğe bilgi verilmesi gerekmektedir. İşte bu işlem 
    __blk_end_request_all fonksiyonuyla yapılmaktadır. Bu fonksiyonun ikinci parametresi -EIO girilirse bu durum bu işlemin 
    yapılmadığını, 0 girilirse bu da bu işlemin başarılı bir biçimde yapıldığını belirtmektedir.

    Pekiyi çekirdek ne zaman kuyruğa request nesnesi yerleştirmektedir? Şüphesiz çekirdeğin böyle bir nesneyi kuyruğa yerleştirmesi 
    için aygıt üzerinde bir okuma ya da yazma olayının gerçekleşmiş olması gerekir. Bunun tipik yolu aygıt dosyasının open fonksiyonuyla 
    açılıp read ya da write yapılmasıdır. Tabii blok aygıt sürücüsü bir dosya sistemi yani bir disk bölümü haline getirilmiş olabilir. 
    Bu durumda formatlama gibi, mount etme gibi eylemlerde de gizli bir okuma yazma işlemleri söz konusu olmaktadır.

    Pekiyi çekirdek aygıt sürücü açılıp aşağıdaki gibi iki ayrı read işleminde iki ayrı request nesnesi mi oluşturmaktadır?

      if ((fd = open("generic-bdriver", O_RDONLY)) == -1)
        exit_sys("open");

      if ((result = read(fd, buf, 10)) == -1)
            exit_sys("read");

      if ((result = read(fd, buf, 10)) == -1)
            exit_sys("read");

    Aslında çekirdek burada iki okumanın aynı blok içerisinde kaldığını anladığı için aygıttan yalnızca tek blokluk okuma talep 
    edecektir. Çünkü okunan iki kısım da aynı blok içerisindedir. (Çekirdeğin bu biçimde düzenleme yapan kısmına "IO çizelgeleyicisi
    (IO scheduler)" denilmektedir.) Eğer bu iki okuma aşağıdaki gibi yapılmış olsaydı bu durumda çekirdek iki farklı blok için 
    iki farklı request nesnesi oluşturacaktı:

    if ((fd = open("generic-bdriver", O_RDONLY)) == -1)
        exit_sys("open");

    if ((result = read(fd, buf, 10)) == -1)
        exit_sys("read");

    lseek(fd, 5000, 0);

    if ((result = read(fd, buf, 10)) == -1)
        exit_sys("read");

    Pekiyi çekirdek aygıt sürücüden kaç byte'lık bir bloğun transferini istemektedir? Bunun bir sektör olması gerektiğini düşünebilirsiniz. 
    Ancak çekirdek sektör küçük olduğu için aygıt sürücüden bir "blok" transfer istemektedir. Bir blok ardışıl n tane sektörden 
    oluşmaktadır (örneğin bir blok 8 sektörden yani 4K'dan oluşabilir) ve bu durum çekirdek konfigürasyonuna bağlıdır. Ancak çekirdek 
    transfer isteklerinde istenen bloğu her zaman sektör olarak ifade etmektedir. Başka bir deyişle çekirdek aygıt sürücüden "şu 
    sektörden itibaren 4096 byte transfer et" gibi bir istekte bulunmaktadır.

    Şimdi biz request nesnesinin içerisinden bio nesnelerini, bio nesnelerinin içerisinden de bio_vec nesnelerini elde edelim. 
    Pekiyi çekirdek neden transfer bilgilerini doğrudan request nesnelerinin içerisine kodlamak yerine böylesi iç nesneler 
    oluşturmuştur? İşte aslında bir request nesnesi ardışıl sektör transferi ile ilgilidir. Ancak bu ardışıl sektörler read ya da 
    write biçiminde olabilir. İşte bu read ve write yönleri o request nesnesinin ayrı bio nesnelerinde kodlanmıştır. Read ve write 
    işlemleri ise aslında birden fazla tampon ile (yani aktarılacak hedef adres ile) ilgili olabilir. Bu bilgiler de bio_vec 
    içerisine kodlanmıştır. Dolayısıyla aslında programcı tüm bio'lar içerisindeki bio_vec'leri dolaşmalıdır.

    Bir süre önceye kadar request içerisindeki bio nesnelerinin dolaşılması normal kabul ediliyordu. Ancak belli bir çekirdekten
    sonra bu tavsiye edilmemeye başlanmıştır. Fakat yine de request içerisindeki bio nesneleri şöyle dolaşılabilir:

    struct bio *bio;
    ...
    bio = rqs->bio;
    for_each_bio(bio) {
        ...
    }

    for_each_bio makrosunun artık doğrudan yukarıdaki biçimde kullanılması önerilmemektedir. Artık bugünlerde bio nesnelerini 
    dolaşmak yerine zaten bio nesnelerini ve onların içerisindeki bio-vec'leri dolaşan (yani içteki iki döngünün işlevini tek 
    başına yapan) rq_for_each_segment isimli makronun kullanılması tavsiye edilmektedir. Bu makro şöyle yazılmıştır:

    #define rq_for_each_segment(bvl, _rq, _iter)            \
    __rq_for_each_bio(_iter.bio, _rq)                        \
        bio_for_each_segment(bvl, _iter.bio, _iter.iter)

    Görüldüğü gibi aslında bu makro request nesnesi içerisindeki bio nesnelerini, bio nesneleri içerisindeki bio_vec nesnelerini 
    dolaşmaktadır. rq_for_each_segment makrosunun birinci parametresi bio_vec türünden nesneyi almaktadır. Makronun ikinci parametresi 
    request nesnesinin adresini almaktadır. Üçüncü parametre ise dolaşım sırasında kullanılacak bir iteratör nesnesidir. Bu nesne 
    req_iterator isimli bir yapı türünden olmalıdır. Bu durumda transfer fonksiyonunun yeni durumu aşağıdaki gibi olacaktır:

    static void request_proc(struct request_queue *rq)
    {
        struct request *rqs;
        struct bio_vec biov;
        struct req_iterator iterator;
        struct BLOCKDEV *bdev = (struct BLOCKDEV *) rq->queuedata;

        for (;;) {
            if ((rqs = blk_fetch_request(rq)) == NULL)
                break;

            if (blk_rq_is_passthrough(rqs)) {
                __blk_end_request_all(rqs, -EIO);
                continue;
            }

            rq_for_each_segment(biov, rqs, iterator) {
                /* biov kullanılarak transfer yapılır */
            }

            __blk_end_request_all(rqs, 0);

            printk(KERN_INFO "new request object\n");
        }
    }

    Gerçek transfer bilgileri bio_vec yapılarının içerisinde olduğuna göre acaba bu yapı nasıldır? İşte bu yapı şöyle bildirilmiştir:

    #include <linux/bvec.h>

    struct bio_vec {
        struct page    *bv_page;
        unsigned int bv_len;
        unsigned int bv_offset;
    };

    Yapının bv_page elemanı transferin yapılacağı adresi belirtmektedir. Çekirdek ismine eskiden "buffer cache" denilen daha sonra 
    "page cache" denilen bir cache veri yapısı kullanmaktadır. İşletim sistemi read/write işlemlerinde önce bu "page cache"e 
    başvurmakta eğer ilgili blok cache'te varsa buradan almaktadır. Eğer ilgili blok cache'te yoksa blok aygıt sürücüsünden 
    transfer istemektedir. Blok aygıt sürücüleri karakter aygıt sürücülerinin yaptığı gibi transferleri user alanına kopyalamamaktadır. 
    Blok aygıt sürücüleri transferi çekirdek tarafından tahsis edilen cache'teki sayfalara yapar. Çekirdek o sayfalardaki bilgiyi
    user alanına transfer eder. Ancak bu sayfa adresinin özellikle 32 bit Linux sistemlerinde sayfa tablosunda girişi olmayabilir. 
    Programcının bu girişi oluşturması gerekmektedir. Bu girişi oluşturmak için kmap_atomic isimli fonksiyon ve girişi boşaltmak için 
    ise kunmap_atomic isimli fonksiyon kullanılmaktadır. Yapının ikinci elemanı olan bv_len transfer edilecek byte sayısını barındırmaktadır. 
    (Bu elemanda transfer edilecek sektör sayısı değil doğrudan byte sayısı bulunmaktadır.) Nihayet yapının üçüncü elemanı olan 
    bv_offset birinci elemanında belirtilen adresten uzaklığı tutmaktadır. Yani aslında gerçek transfer adresi bv_page değildir. 
    bv_page + bv_offset'tir. Bu yapıda en önemli bilgi olan transferin söz konusu olduğu sektör bilgisi yoktur. İşte aslında 
    transfere konu olan sektör numarası bio yapısının içerisindedir. Her ne kadar biz yukarıdaki makroda bio yapısına erişemiyor 
    olsak da buna dolaylı olarak iterator nesnesi yoluyla iterator.iter.bi_sect ifadesi ile erişilebilmektedir. Bu durumda 
    rq_for_each_segment fonksiyonu içerisinde transfer tipik olarak şöyle yapılmaktadır:

    rq_for_each_segment(biov, rqs, iterator) {
        sector_t sector = iterator.iter.bi_sector;
        char *buf = (char *)kmap_atomic(biov.bv_page);
        size_t len = biov.bv_len;
        int direction = bio_data_dir(iterator.bio);
        transfer_block(bdev, sector, buf + biov.bv_offset, len, direction);
        kunmap_atomic(buf);
    }

    Burada transferin yapılacağı sektörün numarası bio_vec içerisinde bulunmadığından bu bilgi iterator yolu ile iterator.iter.bi_sector 
    ifadesiyle alınmıştır. Transfer adresi olan buf adresi biov.bv_page adresinden biov.bv_offset kadar ileridedir. Yine transferin 
    yönü doğrudan bio_vec yapısının içerisinde değildir. Bu yön bilgisinin bio_data_dir makrosuyla iterator yoluyla alındığına 
    dikkat ediniz. (Aslında yön bilgisi bio yapısının içerisindedir. Bu makro onu buradan almaktadır.) Örneğimizde transferin 
    transfer_block isimli fonksiyonla yapıldığını görüyorsunuz. Bu fonksiyon bizim tarafımızdan yazılan gerçek transferin yapıldığı 
    fonksiyondur. Aygıt sürücünün en önemli bilgilerinin bizim tarafımızdan oluşturulan BLOCKDEV isimli yapıda tutulduğunu 
    anımsayınız. Her ne kadar bu yapı nesnesinin adresi global g_bdev göstericisinde tutuluyor olsa da örneğimizde request_queue 
    nesnesinin queuedata elemanından çekilerek alınıp transfer_block fonksiyonuna verilmiştir. Bu durum yukarıdaki örnek için 
    gereksiz olsa da birden fazla minör numarayla çalışıldığı durumda aygıt bilgilerinin yerinin belirlenebilmesi için genel bir 
    çözüm oluşturmak amacıyla transfer_block fonksiyonuna aktarılmıştır. Aygıt bilgilerinin request_queue yapısının queuedata 
    elemanına nesne tahsis edildikten sonra yerleştirildiğini anımsayınız. Buradaki bizim tarafımızdan yazılması gereken 
    transfer_block fonksiyonun parametrik yapısı şöyle olabilir:

    static void transfer_block(struct BLOCKDEV *bdev, sector_t sector, char *buf, size_t len, int direction);

    direction değeri READ (0) ve WRITE (1) sembolik sabitleriyle define edilmiştir.

    Aşağıda RAMDISK 5'li çekirdekler öncesinde kullanabileceğiniz blok aygıt sürücüsünün tüm kodlarını görüyorsunuz.
---------------------------------------------------------------------------------------------------------------------------*/

/* ramdisk-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/slab.h>
#include <linux/blkdev.h>

#define KERNEL_SECTOR_SIZE        512
#define CAPACITY                (KERNEL_SECTOR_SIZE * 1000)

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("Ramdisk Device Driver");
MODULE_AUTHOR("Kaan Aslan");

int g_major = 0;

struct BLOCKDEV {
    spinlock_t sl;
    struct gendisk *gdisk;
    struct request_queue *rq;
    size_t capacity;
    void *data;
};

static int generic_open(struct block_device *bdev, fmode_t mode);
static void generic_release(struct gendisk *gdisk, fmode_t mode);
static void request_proc(struct request_queue *rq);
static void transfer_block(struct BLOCKDEV *bdev, sector_t sector, char *buf, size_t len, int direction);

static struct block_device_operations g_devops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release
};

static struct BLOCKDEV *g_bdev;

static int __init generic_init(void)
{
    int result = 0;

    if ((g_major = register_blkdev(g_major, "generic-bdriver")) < 0) {
        printk(KERN_ERR "cannot register block driver!...\n");
        return g_major;
    }

    if ((g_bdev = kmalloc(sizeof(struct BLOCKDEV), GFP_KERNEL)) == NULL) {
        printk(KERN_ERR "cannot allocate memory!...\n");
        result = -ENOMEM;
        goto EXIT1;
    }
    memset(g_bdev, 0, sizeof(struct BLOCKDEV));
    g_bdev->capacity = CAPACITY;

    if ((g_bdev->data = vmalloc(CAPACITY)) == NULL) {
        printk(KERN_ERR "cannot allocate memory!...\n");
        result = -ENOMEM;
        goto EXIT2;
    }

    spin_lock_init(&g_bdev->sl);
    if ((g_bdev->rq = blk_init_queue(request_proc, &g_bdev->sl)) == NULL) {
        printk(KERN_ERR "cannot allocate queue!...\n");
        result = -ENOMEM;
        goto EXIT3;
    }
    g_bdev->rq->queuedata = g_bdev;
    if ((g_bdev->gdisk = alloc_disk(1)) == NULL) {
        result = -ENOMEM;
        goto EXIT4;
    }
    g_bdev->gdisk->major = g_major;
    g_bdev->gdisk->first_minor = 0;
    g_bdev->gdisk->flags = GENHD_FL_NO_PART_SCAN;
    g_bdev->gdisk->fops = &g_devops;
    g_bdev->gdisk->queue = g_bdev->rq;
    set_capacity(g_bdev->gdisk, g_bdev->capacity >> 9);
    g_bdev->gdisk->private_data = g_bdev;
    strcpy(g_bdev->gdisk->disk_name, "blockdev");

    add_disk(g_bdev->gdisk);

    printk(KERN_INFO "Module initialized with major number %d...\n", g_major);

    return result;

EXIT4:
    blk_cleanup_queue(g_bdev->rq);
EXIT3:
    vfree(g_bdev->data);
EXIT2:
    kfree(g_bdev);
EXIT1:
    unregister_blkdev(g_major, "generic-bdriver");

    return result;
}

static int generic_open(struct block_device *bdev, fmode_t mode)
{
    printk(KERN_INFO "device opened...\n");

    return 0;
}

static void generic_release(struct gendisk *gdisk, fmode_t mode)
{
    printk(KERN_INFO "device closed...\n");
}

static void request_proc(struct request_queue *rq)
{
    struct request *rqs;
    struct bio_vec biov;
    struct req_iterator iterator;
    struct BLOCKDEV *bdev = (struct BLOCKDEV *)rq->queuedata;

    for (;;) {
        if ((rqs = blk_fetch_request(rq)) == NULL)
            break;

        if (blk_rq_is_passthrough(rqs)) {
            __blk_end_request_all(rqs, -EIO);
            continue;
        }

        rq_for_each_segment(biov, rqs, iterator) {
            sector_t sector = iterator.iter.bi_sector;
            char *buf = (char *)kmap_atomic(biov.bv_page);
            size_t len = biov.bv_len;
            int direction = bio_data_dir(iterator.bio);

            transfer_block(bdev, sector, buf + biov.bv_offset, len, direction);

            kunmap_atomic(buf);
        }

        __blk_end_request_all(rqs, 0);
    }
}

 static void transfer_block(struct BLOCKDEV *bdev, sector_t sector, char *buf, size_t len, int direction)
 {
     if (direction == READ)
        memcpy(buf, (char *)bdev->data + sector * KERNEL_SECTOR_SIZE, len);
    else
        memcpy((char *)bdev->data + sector * KERNEL_SECTOR_SIZE, buf, len);
 }

static void __exit generic_exit(void)
{
    del_gendisk(g_bdev->gdisk);
    blk_cleanup_queue(g_bdev->rq);
    vfree(g_bdev->data);
    kfree(g_bdev);
    unregister_blkdev(g_major, "generic-bdriver");

    printk(KERN_INFO "Goodbye...\n");
}

module_init(generic_init);
module_exit(generic_exit);

# Makefile

obj-m += generic.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* loadblk (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module b $major 0

/* unloadblk (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./$module.ko || exit 1
rm -f $module

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örneklerdeki request kuyruk yapısı Linux'un 5'ten önceki çekirdeklerine özgüdür. Maalesef blok aygıt sürücülerinin
    içsel yapısı birkaç kere değiştirilmiştir. Burada yeni çekirdeklerdeki request kuyruk yapısı üzerinde duracağız. Yeni 
    çekirdeklerde bu kuyruk yapısı şöyle kullanılmaktadır:

    1) Programcı blk_mq_tag_set isimli yapı türünden bir yapı nesnesi oluşturur. Bu yapı nesnesi blok aygıt sürücüsünün 
    bilgilerinin tutulacağı yapının bir elemanı olarak alınabilir. Ya da global bir değişken olarak alınabilir.

    #include <linux/blk-mq.h>

    struct BLOCKDEV {
        spinlock_t sl;
        struct gendisk *gdisk;
        struct blk_mq_tag_set ts;
        struct request_queue *rq;
        size_t capacity;
        void *data;
    };
    static struct BLOCKDEV *g_bdev;

    2) Bu blk_mq_tag_set yapısının içi aşağıdaki gibi doldurulur:

    g_bdev->ts.ops = &g_mqops;
    g_bdev->ts.nr_hw_queues = 1;
    g_bdev->ts.queue_depth = 128;
    g_bdev->ts.numa_node = NUMA_NO_NODE;
    g_bdev->ts.cmd_size = 0;
    g_bdev->ts.flags = BLK_MQ_F_SHOULD_MERGE;
    g_bdev->ts.driver_data = &g_bdev;

    Buradaki elemanlar çekirdeğin blok aygıt sürücü mimarisiyle ilgilidir. Biz burada tipik değerler kullandık. blk_mq_tag_set
    yapısının ops elemanı transfer isteklerini yerine getiren ana fonksiyonun adresini almaktadır. Bu fonksiyonun parametrik 
    yapısı şöyle olmalıdır:

    static blk_status_t request_proc(struct blk_mq_hw_ctx *ctx, const struct blk_mq_queue_data *data);

    Yapının driver_data elemanına bu fonksiyon içerisinde erişilebilecek nesnenin adresi girilmelidir. Örneğimizde bu elemana 
    g_bdev nesnesinin adresini girdik. Tabii aslında bu nesne global olduğu için zaten bu nesneye her yerden erişilebilmektedir. 
    Ancak birden fazla minör numaranın desteklendiği durumda buraya ilgili minör numaraya ilişkin aygıt bilgisi girilebilir.

    3) İçi doldurulan blk_mq_tag_set nesnesi blk_mq_alloc_tag_set fonksiyonu ile tahsis edilip set edilmelidir. Fonksiyonun 
    prototipi şöyledir:

    #include <linux/blk-mq.h>

    int blk_mq_alloc_tag_set(struct blk_mq_tag_set *set);

    Fonksiyon blk_mq_tag_set yapı nesnesinin adresini alır. Başarı durumunda 0 değerine, başarısızlık durumunda negatif errno 
    değerine geri döner.
    <DEVAM EDECEK>
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki blok aygıt sürücüsü bir dosya sistemi ile formatlanarak sanki bir disk bölümüymüş gibi de kullanılabilir. Bunun 
    için önce aygıt sürücünün idare ettiği alanın formatlanması gerekir. Formatlama işlemi mkfs isimli utility programla yapılmaktadır:

    $ sudo mkfs -t ext2 generic-bdriver

    Burada -t seçeneği volümün hangi dosya sistemi ile formatlanacağını belirtmektedir. Formatlama aslında volümdeki bazı 
    sektörlerde özel meta alanlarının yaratılması anlamına gelmektedir. Dolayısıyla mkfs komutu aslında ilgili aygıt sürücüyü 
    açıp onun bazı sektörlerine bazı bilgileri yazmaktadır.

    Formatlama işleminden sonra artık blok aygıt sürücüsünün mount edilmesi gerekmektedir. mount işlemi bir dosya sisteminin dizin 
    ağacının belli bir dizinine monte edilmesi anlamına gelmektedir. Dolayısıyla mount komutunda kullanıcı blok aygıt sürücüsünü 
    ve mount edilecek dizini girmektedir. Örneğin:

    $ sudo mount generic-bdriver /mnt/myblock

    Burada mount noktası (mount point) /ment dizinin altında myblock isimli dizindir. Bu dizinin kullanıcı tarafından önceden 
    mkdir komutu ile yaratılması gerekir. Tabii mount noktalarının /mnt dizinin altında bulundurulması gibi zorunluluk yoktur. Mount 
    noktasına ilişkin dizinin içinin boş olması da gerekmez. Fakat mount işleminden sonra artık o dizinin altı görünmez. Dosya 
    sisteminin kök dizini o dizin olacak biçimde dosya sistemi ağaca monte edilmiş olur. mount komutu aslında mount isimli bir 
    sistem fonksiyonu çağrılarak gerçekleştirilmektedir. Yani aslında bu işlem programlama yoluyla da yapılabilmektedir.

    Aygıt sürücümüzü mount ettikten sonra artık onu unmount etmeden rmmod komutuyla boşaltamayız. mount edilen dosya sistemi umount 
    komutuyla eski haline getirilmektedir. Örneğin:

    $ sudo umount /mnt/myblock

    umount komutunun komutu argümanının mount noktasını belirten dizin olduğuna dikkat ediniz. Tabii aslında umount komutu 
    da işlemini umount isimli sistem fonksiyonuyla yapmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                165. Ders 20/09/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kursumuzun bu bölümünde dosya sistemlerini belli bir derinlikte inceleyeceğiz. Dosya sistemlerini ele almadan önce bilgisayar
    sistemlerindeki disk sistemleri hakkında bazı temel bilgilerin edinilmesi gerekmektedir. Eskiden diskler yerine teyp bantları
    kullanılıyordu. Teyp bantları sıralı erişim sağlıyordu. Sonra manyetik diskler kullanılmaya başlandı. Kişisel bilgisayarlardaki
    manyetik disklere "hard disk" de deniyordu. Bugünlerde artık hard diskler de teknoloji dışı kalmaya başlamıştır. Bugün disk 
    sistemleri için artık flash bellekler (EEPROM bellekler) kullanılmaktadır. Yani SSD (Solid State Disk) diye isimlendirilen 
    bu disk sistemlerinin artık mekanik bir parçası yoktur. Bunlar tamamen yarı iletken teknolojisiyle üretilmiş entegre 
    devrelerdir. Disk sisteminin türü ne olursa olsun bu disk sistemini yöneten ondan sorumlu bir denetleyici birim bulunmaktadır. 
    Buna "disk denetleyicisi (disk controller)" denilmektedir. Kernel mode aygıt sürücüler bu disk denetleyicisini programlayarak
    transferleri gerçekleştirmektedir. Bugünkü disk sistemlerini şekilsel olarak aşağıdaki gibi düşünebiliriz:

    +-------------+       +------------------+       +--------------+       +-----------+
    | Disk Birimi | <---> | Disk Denetleyici | <---> | Aygıt Sürücü | <---> | User Mode |
    +-------------+       +------------------+       +--------------+       +-----------+
                                                            |
                                                            |
                                                     +------------+
                                                     | Disk Cache |
                                                     +------------+

    Örneğin biz user mode'da bir diskten bir sektör okumak istediğimizde bu işlemi yapan blok aygıt sürücüsünden istekte 
    bulunuruz. Blok aygıt sürücüleri disk denetleyicilerini programlar, disk denetleyicileri disk birimine erişir ve transfer
    gerçekleşir. Disk transferleri CPU aracılığıyla değil, "DMA (Direct Memory Access)" denilen özel denetleyicilerle sağlanmaktadır. 
    Yani aygıt sürücü hem disk denetleyicisini hem de DMA'yı programlar ve transfer yapılana kadar bekler. Bu sırada işletim sistemi 
    zaman alacak bu işlemi meşgul bir döngüde beklemez. O anda istekte bulunan thread'i bekleme kuyruğuna yerleştirerek sıradaki
    thread'i çizelgeler.

    İşletim sistemlerinde diskten transfer işlemi yapan blok aygıt sürücüleri ismine "disk cache" ya da "buffer cache" ya da
    "page cache" denilen bir cache sistemi kullanmaktadır. Tabii cache sistemi aslında çekirdek tarafından organize edilmiştir. 
    Blok aygıt sürücüsünden bir sektörlük bilgi okunmak istediğinde aygıt sürücü önce bu cache sistemine bakar. Eğer istenen 
    sektör bu cache sisteminde varsa hiç bekleme yapmadan oradan alıp talep eden thread'e verir. Eğer sektör cache'te yoksa
    blok aygıt sürücüsü disk denetleyicisini ve DMA denetleyicisini programlayarak sektörü önce cache'e transfer eder. Oradan
    talep eden thread'e verir. Bu amaçla kullanılan cache'lerde cache algoritması (cache replacement algorithm) genel olarak 
    LRU (Least Recently Used) algoritmasıdır. Yani son zamanlarda erişilen yerler mümkün olduğunca cache'te tutulmaktadır. İşletim 
    sistemlerinin dosya sistemleri arka planda bu blok aygıt sürücülerini kullanmaktadır. Dolayısıyla tüm dosya işlemleri aslında 
    bu cache sistemi ile gerçekleşmektedir. Yani örneğin bugünkü modern işletim sistemlerinde ne zaman bir dosya işlemi yapılsa o 
    dosyanın okunan ya da yazılan kısmı disk cache içerisine çekilmektedir. Aynı dosya üzerinde bir işlem yapıldığında zaten o 
    dosyanın diskteki blokları cache'te olduğu için gerçek anlamda bir disk işlemi yapılmayacaktır.

    Pekiyi aygıt sürücü bir sektörü yazmak isterse ne olmaktadır? İşte yazma işlemleri de doğrudan değil cache yoluyla 
    yapılmaktadır. Yani sektör önce disk cache'e yazılır. Sonra çizelgelenir ve işletim sisteminin bir kernel thread'i 
    yoluyla belli periyotlarda diske transfer edilir. User mode'dan çeşitli thread'lerin diskten okumalar yaptığını düşünelim.
    Önce bu talepler işletim sistemi tarafından kuyruklanır, çizelgelenir sonra etkin bir biçimde transfer gerçekleştirilir. 
    İşletim sistemlerinin bu kısmına "IO çizelgeleyicisi (IO scheduler)" denilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bugün artık SSD (yani elektronik devre biçiminde) diskler yaygın olarak kullanılıyorsa da bir dönem öncesine kadar 
    manyetik tabanlı "hard diskler" yoğun kullanılıyordu. Burada bu hard disklerin genel yapısı üzerinde bazı açıklamalar da
    yapmak istiyoruz.

    Hard disklerde bir eksene monte edilmiş birden fazla yüzey vardır. Bu yüzeylere "platter" denilmektedir. Bir platter'da 
    iki yüz bulunur. Her yüz bir disk kafası ile okunmaktadır. Örneğin bir hard diskte 4 platter varsa toplam 8 tane yüz
    ve 8 tane kafa bulunur. Bilgiler tıpkı eski plaklarda olduğu gibi yuvarlak yollara yazılıp okunmaktadır. Bunlara "track"
    denilmektedir. Dolayısıyla bir track'e bilginin yazılıp okunması için öncelikle kafanın o track hizasına konumlandırılması 
    gerekmektedir. Tabii okuma yazma işlemi disk dönerken yapılmaktadır. Bu durumda manyetik tabanlı bu hard disklerde bir 
    sektörün transfer edilmesi için üç zaman unsuru vardır:

    1) Disk kafasının ilgili track hizasına konumlandırılması için gereken zaman (seek time).
    2) Diskin dönerek kafa hizasına gelmesi için gereken zaman (rotation delay).
    3) Transfer zamanı (transfer time)

    Buradaki en önemli zaman kaybı disk kafasının konumlandırılması sırasındaki kayıptır. Ortalama bir disk 6000 RPM hızında 
    dönmektedir. Yani bir dakikada 6000 tur atmaktadır. İkinci önemli zaman kaybı ilgi sektörün track kafa hizasına gelmesi 
    için harcanan zamandır. Nihayet en hızlı gerçekleşen işlem transfer işlemidir.

    İşletim sistemlerinin eski hard disklerde uyguladığı en önemli optimizasyon işlemi kafa hareketinin azaltılması üzerinedir. 
    Eğer dosyayı oluşturan sektörler birbirine yakınsa daha az kafa hareketi oluşur ve toplam transfer zamanı azaltılmış olur. 
    Tabii dosya sistemlerinde dosyanın parçaları zamanla birbirinden uzaklaşabilmektedir. Bunları birbirine yaklaştıran
    genellikle "defrag" biçiminde isimlendirilen yardımcı programlar vardır.

    Tabii artık şimdilerde kullandığımız SSD disklerde hiçbir mekanik unsur yoktur. Bunlar tamamen flash EPROM teknolojisi ile
    yani yarı iletken teknolojisiyle entegre devre biçiminde üretilmektedir. Bunlar rastgele erişimlidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir diskten transfer edilecek en küçük birime sektör denilmektedir. Bir sektör genel olarak 512 byte uzunluğundadır. 
    Örneğin biz bir diskteki 1 byte'ı değiştirmek istesek önce onun içinde bulunduğu sektörü belleğe okuyup değişikliği 
    bellekte yapıp o sektörü yeniden diske yazarız. Disklere byte düzeyinde değil, sektör düzeyinde erişilmektedir.

    Diskteki her sektöre ilk sektör 0 olmak üzere bir numara verilmiştir. Disk denetleyicileri bu numarayla çalışmaktadır. 
    Eskiden disklerdeki koordinat sistemi daha farklıydı. Daha sonra teknoloji geliştikçe sektörün yerini belirlemek için 
    tek bir sayı kullanılmaya başlandı. Bu geçiş sırasında kullanılan bu sisteme LBA (Logical Block Addressing) deniliyordu. 
    Artık ister hard diskler olsun isterse SSD'ler olsun tıpkı bellekte her byte'ın bir numarası olduğu gibi her sektörün de 
    bir sektör numarası vardır. Transferler bu sektör numarasıyla yapılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında "dosya (file)" kavramı mantıksal bir kavramdır. Diskteki fiziksel birimler sektör denilen birimlerdir. Yani diskler
    dosyalardan oluşmaz sektörlerden oluşur. Dosya bir isim altında bir grup sektörü organize etmek için uydurulmuş bir 
    kavramdır. Aslında dosyanın içindekiler diskte ardışıl sektörlerde olmak zorunda değildir. Kullanıcı için dosya sanki 
    ardışıl byte'lardan oluşan bir topluluk gibidir. Ancak bu bir aldatmacadır. Dosyadaki byte'lar herhangi bir biçimde ardışıl 
    olmak zorunda değildir. Örneğin elimizde 100K'lık bir dosya olsun. Aslında bu 100K'lık dosya diskte 200 sektör içerisindedir. 
    Peki bu dosyanın parçaları hangi 200 sektör içerisindedir? İşte bir biçimde bu bilgiler de disk üzerinde tutulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Disk sistemleriyle ilgili programcıların ilk bilmesi gereken işlemler bir sektörün okunmasının ve yazılmasının nasıl 
    yapılacağıdır. Yukarıda bu işlemleri yapan yazılımsal birimin blok aygıt sürücüleri olduğunu belirtmiştik. Aygıt sürücülerin 
    de birer dosya gibi açılıp kullanıldığını biliyoruz. O halde sektör transferi için bizim hangi aygıt sürücüyü kullanacağımızı
    bilmemiz gerekir. UNIX/Linux sistemlerinde bilindiği gibi tüm temel aygıt sürücülere ilişkin aygıt dosyaları "/dev" dizini 
    içerisindedir.

    Bir Linux sisteminde "lsblk" komutu ile disklere ilişkin blok aygıt sürücülerinin listesini elde edebilirsiniz. Örneğin:

    $ lsblk
    NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
    sda      8:0    0   60G  0 disk
    ├─sda1   8:1    0    1M  0 part
    ├─sda2   8:2    0  513M  0 part /boot/efi
    └─sda3   8:3    0 59,5G  0 part /
    sr0     11:0    1 1024M  0 rom

    Linux sistemlerinde disklere ilişkin blok aygıt sürücüleri diskin türüne göre farklı biçimlerde isimlendirilmektedir. 
    Örneğin hard diskler ve SSD diskler tipik olarak "sda", "sdb", "sdc" biçiminde isimlendirilmektedir. Micro SD kartlar
    ise genellikle "mmcblk0", mmcblk1", "mmcblk2" gibi isimlendirilmektedir. Örneğin burada "sda" (Solid Disk a) ismi hard
    diski bir bütün olarak ele alan aygıt dosyasının ismidir. Disk, disk bölümlerinden oluşmaktadır. Bu disk bölümlerini sanki 
    ayrı disklermiş gibi ele alan aygıt dosyaları da "sda1", "sda2", "sda3" biçimindedir. Burada "disk bölümü (disk partition)" 
    terimini biraz açmak istiyoruz.

    Bir diskin bağımsız birden fazla diskmiş gibi kullanılabilmesi için disk mantıksal bölümlere ayrılmaktadır. Bu bölümlere
    "disk bölümleri (disk partitions)" denilmektedir. Bir disk bölümü diskin belli bir sektöründen başlar belli bir sektör 
    uzunluğu kadar devam eder. Disk bölümlerinin hangi sektörden başladığı ve hangi uzunlukta olduğu diskin başındaki bir 
    tabloda tutulmaktadır. Bu tabloya "disk bölümleme tablosu (disk partition table)" denilmektedir. Disk bölümleme tablosu 
    eskiden diskin ilk sektöründe tutuluyordu. Sonra UEFI BIOS'larla birlikte eski sistemle uyumlu olacak biçimde yeni 
    disk bölümleme tablo formatı geliştirildi. Bunlara "GUID Disk Bölümleme Tablosu (GUID Partition Table)" denilmektedir. 
    Örneğin 3 disk bölümüne sahip bir diskin mantıksal organizasyonu şöyledir:

    Disk Bölümleme Tablosu
    Birinci Disk Bölümü
    İkinci Disk Bölümü
    Üçüncü Disk Bölümü

    İşte "lsblk" yaptığımız Linux sisteminde biz "/dev/sda" aygıt dosyasını açarsak tüm diski tek parça olarak ele alırız. 
    Eğer "/dev/sda1" aygıt dosyasını açarsak sanki Birinci Disk Bölümü ayrı diskmiş gibi yalnızca o bölümü ele alabiliriz. 
    Örneğin "/dev/sda2" aygıt dosyasından okuyacağımız 0 numaralı sektör aslında İkinci Disk Bölümünün ilk sektörüdür. 
    Tabii bu sektör "/dev/sda" aygıt dosyasındaki 0 numaralı sektör değildir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde bir diskten bir sektör okumak için yapılacak tek şey ilgili aygıt sürücüyü open fonksiyonuyla açmak 
    dosya göstericisini konumlandırıp read fonksiyonu ile okuma yapmaktır. Biz yukarıda bir diskten okunup yazılabilen en 
    küçük birimin bir sektör olduğunu (512 byte) söylemiştik. Her ne kadar donanımsal olarak bir diskten okunabilecek ya da 
    diske yazılabilecek en küçük birim bir sektör olsa da aslında işletim sistemleri transferleri sektör olarak değil blok 
    blok yapmaktadır. Bir blok ardışıl n tane sektöre denilmektedir. Örneğin Linux işletim sisteminin disk cache sistemi 
    aslında 4K büyüklüğünde bloklara sahiptir. 4K'nın aynı zamanda sayfa büyüklüğü olduğunu anımsayınız. Dolayısıyla biz 
    Linux'ta aslında disk ile bellek arasında en az 4K'lık transferler yapmaktayız. O halde işletim sisteminin dosya sistemi
    ve diske doğrudan erişen sistem programcıları, Linux sistemlerinde diskten birer sektör okuyup yazmak yerine 4K'lık blokları 
    okuyup yazarsa sistemle daha uyumlu çalışmış olur.

    Pekiyi biz ilgili disk aygıt sürücüsünü açıp read fonksiyonu ile yalnızca 10 byte okumak istersek ne olur? İşte bu durumda 
    blok aygıt sürücüsü gerçek anlamda o 10 byte'ın içinde bulunduğu 4K'lık bir kısmı diskten okur onu cache'e yerleştirir 
    ve bize onun yalnızca 10 byte'ını verir. Aynı byte'ları ikinci kez okumak istersek gerçek anlamda bir disk okuması 
    yapılmayacak RAM'de saklanmış olan cache'in içerisindeki bilgiler bize verilecektir. Aşağıda diski bir bütün olarak gören 
    "/dev/sda" aygıt sürücüsü açılıp onun ilk sektörü okunmuş ve içeriği HEX olarak ekrana (stdout dosyasına) yazdırılmıştır. 
    Burada bir noktaya dikkatinizi çekmek istiyoruz. Bu aygıt sürücüyü temsil eden aygıt dosyasına ancak root kullanıcısı 
    erişebilmektedir. Bu dosyaların erişim haklarına dikkat ediniz:

    $ ls /dev/sda* -l
    brw-rw---- 1 root disk 8, 0 Ağu 29 14:56 /dev/sda
    brw-rw---- 1 root disk 8, 1 Ağu 29 14:56 /dev/sda1
    brw-rw---- 1 root disk 8, 2 Ağu 29 14:56 /dev/sda2
    brw-rw---- 1 root disk 8, 3 Ağu 29 14:56 /dev/sda3

    Bu durumda programınızı sudo ile çalıştırmalısınız.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    unsigned char buf[512];

    if ((fd = open("/dev/sda", O_RDONLY)) == -1)
        exit_sys("open");

    if (read(fd, buf, 512) == -1)
        exit_sys("read");

    for (int i = 0; i < 512; ++i)
        printf("%02x%c", buf[i], i % 16 == 15 ? '\n' : ' ');

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Dosya sistemi (file system) denildiğinde ne anlaşılmaktadır? Bir dosya sisteminin iki yönü vardır: Bellek ve disk. 
    Dosya sisteminin bellek tarafı işletim sisteminin açık dosyalar için kernel alanında yaptığı organizasyonla (dosya betimleyici 
    tablosu, dosya nesnesi vs.) ilgilidir. Disk tarafı ise diskteki organizasyonla ilgilidir. Biz kursumuzda bellek tarafındaki
    organizasyonun temellerini gördük. Şimdi bu bölümde disk üzerindeki organizasyonu ele alacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dosya kavramını diskte oluşturmak için farklı dosya sistemleri tarafından farklı disk organizasyonları kullanılmaktadır. 
    Bugün kullanılan çok sayıda dosya sistemi vardır. Bu sistemlerin her birinin disk organizasyonu diğerinden az çok farklıdır. 
    Ancak bazı dosya sistemlerinin disk organizasyonları birbirine çok benzemektedir. Bunlar adeta bir aile oluşturmaktadır. 
    Örneğin Microsoft'un FAT dosya sistemleri, Linux'un ext dosya sistemleri kendi aralarında birbirine oldukça benzemektedir.

    Microsoft'un dünyanın ilk kişisel bilgisayarlarında kullandığı dosya sistemlerine aile olarak FAT (File Allocation Table) 
    denilmektedir. Bu FAT dosya sistemlerinin kendi içerisinde FAT12, FAT16 ve FAT32 biçiminde varyasyonları vardır. Microsoft 
    daha sonra yine FAT tabanlı ancak çok daha gelişmiş NTFS denilen bir dosya sistemi gerçekleştirmiştir. Bugün Windows 
    sistemlerinde genel olarak NTFS (New Technology File Systems) dosya sistemleri kullanılmaktadır. Ancak Microsoft hala 
    FAT tabanlı dosya sistemlerini de desteklemektedir. Linux sistemlerinde "EXT (Extended File System)" ismi verilen 
    "i-node tabanlı" dosya sistemleri kullanılmaktadır. Bu EXT dosya sistemlerinin EXT2, EXT3, EXT4 biçiminde varyasyonları 
    vardır. Bugünkü Linux sistemlerinde en çok EXT4 dosya sistemi kullanılmaktadır. Apple firması yine i-node tabanlı HFS 
    (Hierarchical File System), HFS+ (Hierarchical File System Plus) ve APFS (Apple File System) isimli dosya sistemlerini 
    kullanmaktadır. Bunlar da aile olarak birbirlerine çok benzemektedir. Bugünkü macOS sistemlerinde genellikle HFS+ 
    ya da APFS dosya sistemleri kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                166. Ders 22/09/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi UNIX/Linux sistemlerinde Windows sistemlerinde olduğu gibi "sürücü (drive)" kavramı yoktur. Dosya sisteminde
    tek bir "kök dizin (root directory)" vardır. Eğer biz bir dosya sistemine erişmek istiyorsak önce onu belli bir dizinin
    üzerine "mount" ederiz. Artık o dosya sisteminin kökü mount ettiğimiz dizin üzerinde bulunur. Örneğin bir flash belleği 
    USB yuvasına taktığımızda Windows'ta o flash bellek bir sürücü olarak gözükmektedir. Ancak Linux sistemlerinde o flash 
    bellek belli bir dizinin altında gözükür. Yani o dizine mount işlemi yapılmaktadır. Bir dosya sistemi bir dizine mount 
    edildiğinde artık o dizin ve onun altındaki dizin ağacı görünmez olur. Onun yerine mount ettiğimiz blok aygıtındaki dosya
    sisteminin kökü görünür.

    Mount işlemi Linux sistemlerinde aslında bir sistem fonksiyonuyla yapılmaktadır. Bu sistem fonksiyonu "libc" kütüphanesinde
    "mount" ismiyle bulunmaktadır. mount fonksiyonunun prototipi şöyledir:

    #include <sys/mount.h>

    int mount(const char *source, const char *target, const char *filesystemtype, 
        unsigned long mountflags, const void *data);

    Fonksiyonun birinci parametresi blok aygıt dosyasının yol ifadesini, ikinci parametre mount dizinini (mount point)
    belirtmektedir. Üçüncü parametre dosya sisteminin türünü almaktadır. Dördüncü parametre mount bayraklarını belirtmektedir. 
    Bu parametre 0 geçilebilir. Son parametre ise dosya sistemi için gerekebilecek ekstra verileri belirtmektedir. Bu parametre 
    de NULL adres geçilebilir. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Dosya
    sisteminin türünün otomatik tespit eden bazı özel fonksiyonlar bulunmaktadır. Örneğin "libmount" kütüphanesi içerisindeki 
    statfs fonksiyonuyla ya da "libblkid" kütüphanesi içerisindeki fonksiyonlarla bunu sağlayabilirsiniz.

    Tabii bu fonksiyonu çağırabilmek için prosesimizin etkin kullanıcı id'sinin 0 olması ya da prosesimizin uygun önceliğe 
    (appropriate privileges) sahip olması gerekir. mount fonksiyonu POSIX standartlarında yoktur. Çünkü işletim sisteminin
    gerçekleştirimine oldukça bağlı bir fonksiyondur. Tabii kullanıcılar mount işlemini bu sistem fonksiyonu yoluyla değil, 
    "mount" isimli kabuk komutuyla yapmaktadır. mount işlemi için elimizde bir blok aygıt sürücüsüne ilişkin aygıt dosyasının
    bulunuyor olması gerekir. Ancak blok aygıt sürücüleri mount edilebilmektedir. Tabii ilgili blok aygıt sürücüsünün sektörleri 
    içerisinde bir dosya sisteminin bulunuyor olması gerekir. mount isimli kabuk komutunun tipik kullanımı şöyledir:

    sudo mount <blok_aygıt_dosyası> <mount_edilecek_dizin>

    Mount edilecek dizine genel olarak İngilizce "mount point" de denilmektedir. Örneğin bilgisayarımıza bir SD kart okuyucu 
    bağlamış olalım. lsblk yaptığımızda şöyle bir görüntüyle karşılaştığımızı varsayalım:

    $ lsblk
    NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
    sda      8:0    0   60G  0 disk
    ├─sda1   8:1    0    1M  0 part
    ├─sda2   8:2    0  513M  0 part /boot/efi
    └─sda3   8:3    0 59,5G  0 part /
    sdb      8:16   1    0B  0 disk
    sdc      8:32   1 14,8G  0 disk
    ├─sdc1   8:33   1   60M  0 part /media/kaan/72FA-ACF3
    └─sdc2   8:34   1 14,8G  0 part /media/kaan/fa57bb30-99ca-4966-8249-6b0c6c4f4d8d
    sdd      8:48   1    0B  0 disk
    sr0     11:0    1 1024M  0 rom

    Burada taktığımız SD kart "sdc" ismiyle gözükmektedir. "/dev/sdc" aygıt dosyası SD kartı bir bütün olarak görmektedir. 
    Bu SD kartın içerisinde iki farklı disk bölümünün oluşturulduğu görülmektedir. Bu disk bölümlerine ilişkin aygıt dosyaları 
    da "/dev/sdc1" ve "/dev/sdc2" dosyalarıdır. Biz "/dev/sdc" aygıtını mount edemeyiz. Çünkü bu aygıt, diski bir bütün olarak 
    görmektedir. Oysa "/dev/sdc1" ve "/dev/sdc2" aygıtlarının içerisinde daha önceden oluşturulmuş olan dosya sistemleri vardır. 
    Biz bu aygıtları mount edebiliriz. Mount işlemi için sistem yöneticisinin bir dizin oluşturması gerekir. Mount işlemleri 
    için Linux sistemlerinde kök dizinin altında bir "mnt" dizini oluşturulmuş durumdadır. Yani mount edilecek dizini bu dizinin 
    altında yaratabilirsiniz. Tabii böyle bir zorunluluk yoktur. Biz bulunduğumuz dizinde boş bir dizin yaratıp bu dizini 
    mount point olarak kullanabiliriz. Örneğin:

    $ sudo mount /dev/sdc1 mydisk

    mount komutu ilgili blok aygıtındaki dosya sistemini otomatik olarak tespit etmeye çalışır. Genellikle bu tespit otomatik 
    yapılabilmektedir. Ancak bazı özel aygıtlar ve dosya sistemleri için bu belirlemenin açıkça yapılması gerekebilir. Bunun 
    için mount komutunda "-t <dosya_sisteminin_türü> seçeneği kullanılır. Örneğin:

    $ sudo mount -t vfat /dev/sdc1 mydisk

    Burada -t seçeneğine argümanı olarak aşağıdaki gibi dosya sistemleri kullanılabilir:

    ext2
    ext3
    ext4
    ntfs
    vfat
    tmpfs
    xfs
    ...

    Dosya sisteminin otomatik belirlenmesi mount sistem fonksiyonu tarafından yapılmaktadır. mount komutu birtakım işlemlerle
    bunu sağlamaktadır.

    Mount edilmiş olan bir blok aygıtının mount işlemi umount isimli sistem fonksiyonuyla kaldırılabilir. Fonksiyonun prototipi 
    şöyledir:

    #include <sys/mount.h>

    int umount(const char *target);

    Fonksiyon mount dizinini parametre olarak almaktadır. Başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri 
    döner. Artık umount yapıldıktan sonra mount point dizinin içeriğine yeniden erişilebilmektedir. Unmount işlemi de yine komut 
    satırından "umount" komutuyla yapılabilmektedir. Komutun genel biçimi şöyledir:

    $ sudo umount <mount_dizini ya da blok_aygıt_dosyası>

    Örneğin:

    $ sudo umount mydisk

    Pek çok UNIX türevi sistemde olduğu gibi Linux sistemlerinde de "otomatik mount" mekanizması bulunmaktadır. Sistem boot
    edildiğinde konfigürasyon dosyalarından hareketle otomatik mount işlemleri yapılabilmektedir. USB aygıtları genel olarak 
    zaten otomatik mount işlemi oluşturmaktadır. "systemd" init sisteminde "mount unit" dosyaları ile otomatik mount işlemleri
    yönetilebilmektedir. Klasik "system5" init sistemlerinde çekirdek yüklendikten sonra "/etc/fstab" dosyasında otomatik 
    mount edilecek blok aygıtları belirtilebilmektedir. "/etc/fstab" dosyasına "systemd" tarafından da açılış sırasında 
    bakılmaktadır.

    Aşağıda mount sistem fonksiyonu çağrılarak mount işlemi yapan bir örnek verilmiştir. Programı aşağıdakine benzer biçimde 
    çalıştırabilirsiniz:

    $ sudo ./mymount /dev/sdc1 mydisk vfat
---------------------------------------------------------------------------------------------------------------------------*/

/* mymount.c */

#include <stdio.h>
#include <stdlib.h>
#include <sys/mount.h>

void exit_sys(const char *msg);

/* mymount <device> <mount_point> <filesystem_type> */

int main(int argc, char *argv[])
{
    if (argc != 4) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (mount(argv[1], argv[2], argv[3], 0, NULL) == -1)
        exit_sys("mount");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde bir dosyayı sanki blok aygıtı gibi gösteren hazır aygıt sürücüler bulunmaktadır. Bunlara "loop" aygıt 
    sürücüleri denilmektedir. Bu aygıt sürücülere ilişkin aygıt dosyaları "/dev" dizini içerisinde "loopN" ismiyle (burada N bir 
    sayı belirtiyor) bulunmaktadır. Örneğin:

    $ ls -l /dev/loop*
    brw-rw---- 1 root disk  7,   0 Haz  4 22:31 /dev/loop0
    brw-rw---- 1 root disk  7,   1 Haz  4 22:31 /dev/loop1
    brw-rw---- 1 root disk  7,   2 Haz  4 22:31 /dev/loop2
    brw-rw---- 1 root disk  7,   3 Haz  4 22:31 /dev/loop3
    brw-rw---- 1 root disk  7,   4 Haz  4 22:31 /dev/loop4
    brw-rw---- 1 root disk  7,   5 Haz  4 22:31 /dev/loop5
    brw-rw---- 1 root disk  7,   6 Haz  4 22:31 /dev/loop6
    brw-rw---- 1 root disk  7,   7 Haz  4 22:31 /dev/loop7
    crw-rw---- 1 root disk 10, 237 Haz  4 22:31 /dev/loop-control

    Bir dosyayı blok aygıt sürücüsü biçiminde kullanabilmek için önce "losetup" programı ile bir hazırlık işleminin yapılması 
    gerekir. Hazırlık işleminde "loop" aygıt sürücüsüne ilişkin aygıt dosyası ve blok aygıt sürücüsü olarak gösterilecek dosya 
    belirtilir. Bu işlemin sudo ile yapılması gerekmektedir. Örneğin:

    $ sudo losetup /dev/loop0 mydisk.dat

    Tabii bizim burada "mydisk.dat" isimli bir dosyaya sahip olmamız gerekir. İçi 0'larla dolu 100 MB'lik böyle bir dosyayı
    dd komutuyla aşağıdaki gibi oluşturabiliriz:

    $ dd if=/dev/zero of=mydisk.dat bs=512 count=100000

    Burada artık "/dev/loop0" aygıt dosyası adeta bir disk gibi kullanılabilir hale gelmiştir. Biz bu "/dev/loop0" dosyasını 
    kullandığımızda bu işlemlerden aslında "mydisk.dat" dosyası etkilenecektir.

    Sıfırdan bir diske ya da bir disk bölümüne bir dosya sistemi yerleştirebilmek için onun formatlanması gerekir. UNIX/Linux
    sistemlerinde formatlama için "mkfs.xxx" isimli programlar bulundurulmuştur. Örneğin aygıtta FAT dosya sistemi oluşturmak 
    için "mkfs.fat" programı, ext4 dosya sistemi oluşturmak için "mkfs.ext4" programı kullanılmaktadır. Örneğin biz yukarıda
    oluşturmuş olduğumuz "/dev/loop" aygıtını ext2 dosya sistemi ile aşağıdaki gibi formatlayabiliriz:

    $ sudo mkfs.ext2 /dev/loop0

    Burada işlemden aslında "mydisk.dat" dosyası etkilenmektedir. Artık formatladığımız aygıta ilişkin dosya sistemini aşağıdaki 
    gibi mount edebiliriz:

    $ mkdir mydisk
    $ sudo mount /dev/loop0 mydisk

    Loop aygıtının dosya ile bağlantısını kesmek için "losetup" programı "-d" seçeneği ile çalıştırılır. Tabii önce aygıtın 
    kullanımdan düşürülmesi gerekir:

    $ sudo umount mydisk
    $ sudo losetup -d /dev/loop0

    Eğer loop aygıt sürücüsünün bir dosyayı onun belli bir offset'inden itibaren kullanmasını istiyorsak losetup programında
    "-o (ya da "--offset") seçeneğini kullanmalıyız. Örneğin bir disk imajının içerisindeki Linux dosya sisteminin disk imajının 
    8192'nci sektöründen başladığını varsayalım. "dev/loop0" aygıt sürücüsünün bu imaj dosyasını bu offset'ten itibaren 
    kullanmasını şöyle sağlayabiliriz:

    $ sudo losetup -o 4194304 /dev/loop0 am335x-debian-11.7-iot-armhf-2023-09-02-4gb.img

    512 * 8192 = 4194304 olduğuna dikkat ediniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                167. Ders 27/09/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz kursumuzda önce FAT dosya sisteminden bahsedeceğiz sonra UNIX/Linux sistemlerindeki i-node tabanlı EXT dosya sistemleri
    üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT dosya sistemi Microsoft tarafından DOS işletim sistemi için geliştirilmiştir. Ancak bu dosya sistemi hala kullanılmaktadır. 
    FAT dosya sistemi o zamanlar teknolojisiyle tasarlanmıştır. Dolayısıyla modern dosya sistemlerinde bulunan bazı özellikler 
    bu dosya sisteminde bulunmamaktadır. FAT dosya sistemi kendi aralarında FAT12, FAT16 ve FAT32 olmak üzere üç gruba ayrılmaktadır.
    Bu sistemlerin arasındaki en önemli fark dosya sistemi içerisindeki FAT (File Allocation Table) denilen tablodaki elemanların
    uzunluklarıdır. FAT12'de FAT elemanları 12 bit, FAT16'da 16 bit ve ve FAT32'de 32 bittir. Microsoft, Windows sistemlerine
    geçtiğinde bu FAT sistemini biraz revize etmiştir. Buna da VFAT denilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir disk ya da disk bölümü (Disk Partition) FAT dosya sistemiyle formatlandığında disk bölümünde dört mantıksal bölüm 
    oluşturulmaktadır:

    1) Boot Sektör
    2) FAT Bölümü
    3) Root Dir Bölümü
    4) Data Bölümü

    Bir dosya sisteminin içi boş bir biçimde kullanıma hazır hale getirilmesi sürecine formatlama denilmektedir. Formatlama 
    sırasında ilgili disk ya da disk bölümünde ilgili dosya sistemi için metadata alanlar oluşturulmaktadır.

    Windows'ta ilgili disk ya da disk bölümünü FAT dosya sistemiyle formatlamak için "Bilgisayar Yönetimi / Disk Yönetimi" 
    kısmından ilgili disk bölümü seçilir ve farenin sağ tuşuna basılarak formatlama yapılır. Benzer biçimde formatlama 
    "Bilgisayarım (My Computer)" açılarak orada ilgili disk bölümünün üzerine sağa tıklanarak da yapılabilmektedir.

    Linux sistemlerinde bir blok aygıt sürücüsü ya da doğrudan bir dosya "mkfs.fat" programıyla formatlanabilir. Biz yukarıda 
    da belirttiğimiz gibi bir dosyayı sanki disk gibi kullanacağız. Örneğin "dd" programıyla 50MB'lik içi sıfırlarla dolu 
    bir dosya oluşturalım:

    $ dd if=/dev/zero of=mydisk.dat bs=512 count=100000

    Burada 512 * 100000 byte'lık (yaklaşık 50 MB) içi sıfırlarla dolu bir dosya oluşturulmuştur. Bu dosyayı "/dev/loop0" 
    blok aygıt sürücüsü biçiminde kullanılabilmesi şöyle sağlanabilir:

    $ sudo losetup /dev/loop0 mydisk.dat

    Şimdi artık "mkfs.fat" programı ile formatlamayı yapabiliriz. Yukarıda FAT'in FAT12, FAT16 ve FAT32 olmak üzere üç 
    türünün olduğunu belirtmiştik. FAT türü "mkfs.fat" programında -F12, -F16 ya da -F32 seçenekleriyle belirtilmektedir. 
    Örneğin biz blok aygıtımızı FAT16 biçiminde şöyle formatlayabiliriz:

    $ sudo mkfs.fat -F16 /dev/loop0

    Aslında "mkfs.xxx" programları blok aygıt dosyası yerine normal bir dosya üzerinde de formatlama yapabilmektedir. Tabii 
    biz kursumuzda bir blok aygıtı oluşturup onu mount edeceğiz. Şimdi biz FAT16 olarak formatladığımız "/dev/loop0" blok 
    aygıtını mount edebiliriz. Tabii bunun için önce bir "mount dizininin (mount point)" oluşturulması gerekmektedir:

    $ mkdir fat16
    $ sudo mount /dev/loop0 fat16

    Artık fat16 dizini oluşturduğumuz FAT dosya sisteminin kök dizinidir. Ancak bu dosya sisteminin tüm bilgileri "mydisk.dat"
    dosyasında bulundurulacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT dosya sistemiyle formatlanmış olan bir diskin ya da disk bölümünün ilk sektörüne "Boot Sector" denilmektedir. Dolayısıyla 
    boot sektör ilgili diskin ya da disk bölümünün mantıksal 0 numaralı sektöründedir. Boot sektör isminden de anlaşılacağı 
    gibi 512 byte uzunluğundadır. Bu sektörün iç organizasyonu şöyledir:

    Jmp Kodu | BPB (BIOS Parameter Block) | DOS Yükleyici Programı | 55 AA

    Boot sektörün hemen başında Intel Mimarisinde BPB bölümünü atlayarak DOS işletim sistemini yükleyen yükleyici program 
    için bir jmp komutu bulunmaktadır. Bugün artık DOS işletim sistemi kullanılmadığı için buradaki jmp kodun ve yükleyici 
    programın bir işlevi kalmamıştır. Ancak BPB alanı eskiden olduğu yerdedir ve dosya sistemi hakkında kritik bilgiler bu 
    bölümde tutulmaktadır. Sektörün başındaki Jmp Code tipik olarak "EB 3C 90" makine komutundan oluşmaktadır. Bazı kaynaklar 
    bu jmp kodu da BPB alanına dahil etmektedir. Eğer dosya sisteminde yüklenecek bir DOS işletim sistemi yoksa buradaki 
    yükleyici program yerine format programı buraya ekrana mesaj çıkartan küçük program kodu yerleştirmektedir. Aşağıda 
    "mkfs.fat" programı ile FAT16 biçiminde formatlanan FAT dosya sisteminin boot sektör içeriği görülmektedir:

    $ hexdump -C mydisk.dat -n 512 -v

    00000000  eb 3c 90 6d 6b 66 73 2e  66 61 74 00 02 04 04 00  |.<.mkfs.fat.....|
    00000010  02 00 02 00 00 f8 64 00  20 00 08 00 00 00 00 00  |......d. .......|
    00000020  a0 86 01 00 80 01 29 fa  0b 93 c5 4e 4f 20 4e 41  |......)....NO NA|
    00000030  4d 45 20 20 20 20 46 41  54 31 36 20 20 20 0e 1f  |ME    FAT16   ..|
    00000040  be 5b 7c ac 22 c0 74 0b  56 b4 0e bb 07 00 cd 10  |.[|.".t.V.......|
    00000050  5e eb f0 32 e4 cd 16 cd  19 eb fe 54 68 69 73 20  |^..2.......This |
    00000060  69 73 20 6e 6f 74 20 61  20 62 6f 6f 74 61 62 6c  |is not a bootabl|
    00000070  65 20 64 69 73 6b 2e 20  20 50 6c 65 61 73 65 20  |e disk.  Please |
    00000080  69 6e 73 65 72 74 20 61  20 62 6f 6f 74 61 62 6c  |insert a bootabl|
    00000090  65 20 66 6c 6f 70 70 79  20 61 6e 64 0d 0a 70 72  |e floppy and..pr|
    000000a0  65 73 73 20 61 6e 79 20  6b 65 79 20 74 6f 20 74  |ess any key to t|
    000000b0  72 79 20 61 67 61 69 6e  20 2e 2e 2e 20 0d 0a 00  |ry again ... ...|
    000000c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000100  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000110  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000120  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000130  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000140  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000150  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000160  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000170  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000180  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000190  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|

    Burada yükleyici programın DOS olmaması durumunda ekrana yazdırdığı mesaj görülmektedir. Tabii bu mesajın çıkması için
    bu diskin ya da disk bölümünün aktif disk ya da aktif disk bölümü olması gerekir. Yani bu diskten ya da disk bölümünde 
    boot etme girişimi olmadıktan sonra bu mesaj görülmeyecektir.

    FAT dosya sisteminin en önemli metadata bilgileri boot sektörün hemen başındaki BPB (Bios Parameter Block) alanında 
    tutulmaktadır. Bu bölümün bozulması durumunda dosya sistemine erişim mümkün olamamaktadır. Başka bir deyişle bu dosya 
    sisteminin bozulmasını sağlamak için tek yapılacak şey bu BPB alanındaki byte'ları sıfırlamaktır. Tabii zamanla FAT dosya
    sistemindeki diğer bölümleri inceleyerek bozulmuş olan BPB alanını onaran yardımcı araçlar da çeşitli kişiler ve kurumlar 
    tarafından geliştirilmiştir.

    Boot sektörün sonunda "55 AA" değeri bulunmaktadır. Bu bir sihirli sayı (magic number) olarak bulundurulmaktadır. Bazı 
    programlar ve bazı boot loader'lar kontrolü boot sektöre bırakmadan önce bu sihirli sayıyı kontrol edebilmektedir. Böylece
    rastgele bozulmalarda bu sihirli sayı da bozulacağı için yetersiz olsa da basit bir kontrol mekanizması oluşturulabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                168. Ders 29/09/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                169. Ders 06/10/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT dosya sisteminde en önemli kısım şüphesiz "BPB (BIOS Parameter Block)" denilen kısımdır. BPB hemen boot sektörün 
    başındadır ve FAT dosya sisteminin diğer bölümleri hakkında kritik bilgiler içermektedir. Tabii BPB bölümü 1980'lerin 
    anlayışıyla tasarlanmıştır. Bu tasarımda hatalar DOS'un çeşitli versiyonlarında geçmişe doğru uyumu koruyarak giderilmeye
    çalışılmıştır. Biz burada önce FAT12 ve FAT16 sistemlerinde kullanılan BPB bloğunun içeriğini tek tek ele alacağız. FAT32
    ile birlikte BPB bloğuna eklemeler de yapılmıştır. FAT32 BPB formatını daha sonra ele alacağız.

    Aşağıda FAT12 ve FAT16 sistemlerindeki BPB bloğunun formatı açıklanmaktadır. Tablodaki Offset sütunu Hex olarak ilgili alanın
    Boot sektörün başından itibaren kaçıncı byte'tan başladığını belirtmektedir.

    Offset (Hex)        Uzunluk             Anlamı
    00                  3 Byte              Jmp Kodu
    03                  8 Byte              OEM Yorum Alanı
    0B                  WORD                Sektördeki Byte Sayısı
    0C                  BYTE                Cluster'daki Sektör Sayısı
    0E                  WORD                Ayrılmış Sektörlerin Sayısı
    10                  BYTE                FAT Kopyalarının Sayısı
    11                  WORD                Kök Dizinlerindeki Girişlerin Sayısı
    13                  WORD                Toplam Sektör Sayısı (Eski)
    15                  BYTE                Ortam Belirleyicisi (Media Descriptor)
    16                  WORD                FAT'in Bir Kopyasındaki Sektör Sayısı
    18                  WORD                Bir Yüzdeki Sektör Dilimlerinin Sayısı (Artık Kullanılmıyor)
    1A                  WORD                Disk Yüzeylerinin (Kafalarının) Sayısı (Artık Kullanılmıyor)
    1C                  DWORD               Saklı Sektörlerin Sayısı
    20                  DWORD               Yeni Toplam Sektör Sayısı
    24                  3 Byte              Reserved
    27                  DWORD               Volüm Seri Numarası
    2B                  11 Byte             Volüm İsmi

    - Jump Kodu: Yukarıda da belirttiğimiz gibi BPB bloğunu geçerek yükleyici programa atlayan makine komutlarından oluşmaktadır. 
    Boot loader programlar akışı buradan boot sektöre devretmektedir. Dolayısıyla BPB alanının atlanması gerekmektedir. Burada
    bazen Intel short jump bazen de near jump komutları bulunur. Tipik içerik "EB 3C 90" biçimindedir.

    - OEM Yorum Alanı: Formatlama programının kendine özgü yazdığı 8 byte'lık küçük yazıdır. Buraya eskiden DOS işletim sisteminin 
    versiyon numarası yazılıyordu. Örneğin Windows bu BPB alanın yeni biçiminin tanındığı en eski sistem olan "MSDOS5.0" 
    yazısını buraya yerleştirmektedir. Ancak buraya yerleştirilen yazı herhangi bir biçimde kullanılmamaktadır.

    - Sektördeki Byte Sayısı: Bir sektörde kaç byte olduğu bilgisi burada tutulmaktadır. Tabii bu değer hemen her zaman 512'dir.
    Yani Little Endian formatta hex olarak burada "00 02" değerlerini görmemiz gerekir.

    - Cluster'daki Sektör Sayısı: Dosyaların parçaları disk üzerinde ardışıl bir biçimde konumlandırılmak zorunda değildir. 
    FAT dosya sisteminde bir dosyanın hangi parçasının diskte nerede konumlandırıldığı FAT (File Allocation Table) denilen 
    bir bölümde saklanmaktadır. Eğer bir dosya çok fazla parçaya ayrılırsa hem disk üzerinde daha çok yayılmış olur hem de FAT
    bölümünde bu dosyanın parçalarının yerini tutmak için gereken alan büyür. Bu nedenle dosyaların parçaları sektörlere değil,
    cluster denilen birimlere bölünmüştür. Bir cluster ardışıl n tane sektörün oluşturduğu topluluktur. Örneğin bir cluster'ın
    4 sektör olması demek 4 sektörden oluşması (yani 2K) demektir. Şimdi elimizde 10,000 byte uzunluğunda bir dosya olsun. Bir 
    cluster'ın 1 sektör olduğunu düşünelim. Bu durumda bu 10,000 byte'lık dosya toplamda 10000 / 512 = 19.53125 yani 20 cluster
    yer kaplayacaktır. FAT bölümünde bu 20 cluster 20 elemanlık yer kaplayacaktır. Şimdi bir cluster'ın 4 sektörden oluştuğunu 
    düşünelim. Bu durumda 10,000 byte'lık dosya 10000 / 2048 = 4.8828125 yani 5 cluster yer kaplayacaktır. Bu dosyanın yerini 
    tutmak için FAT bölümünde 5 eleman yeterli olacaktır. Görüldüğü gibi cluster bir dosyanın bir parçasını tutabilen en düşük
    tahsisat birimidir. Halbuki sektör diskten transfer edilecek en küçük birimdir. Sektör yerine dosya sisteminin cluster kavramını
    kullanmasının iki nedeni vardır. Birincisi cluster ardışıl sektörlerden oluştuğu için dosyanın parçaları diskte daha az
    yayılmış olur. İkincisi de dosyanın parçalarının yerlerini tutmak için daha az alan gerekmektedir.

    Pekiyi bir cluster kaç sektörden oluşmalıdır? Eğer bir cluster çok fazla sayıda sektörden oluşursa dosyanın son parçasında 
    kullanılmayan alan (buna "içsel bölünme (internal fragmentation)" da denilmektedir) fazlalaşır diskin kullanım kapasitesi 
    azalmaya başlar. Örneğin bir cluster'ın 32 sektörden (16K) oluştuğunu varsayalım. Bu durumda 1 byte'lık bir dosya bile 
    16K yer kaplayacaktır. Çünkü dosya sisteminin minimum tahsisat birimi 16K'dır. Örneğin bir sistemde 100 tane 1 byte'lık 
    dosyanın diskte kapladığı alanla 1 tane 100 byte'lık dosyanın diskte kapladığı alan kıyaslandığında 100 tane 1 byte'lık 
    dosyanın diskte çok daha fazla yer kapladığı görülecektir. İşte UNIX/Linux sistemlerinde dosyaları tek bir dosyada peşi 
    sıra birleştiren ve bunların yerlerini dosyanın başındaki bir başlık kısmında tutan "tar" isimli bir yardımcı program 
    bulunmaktadır. "tar" programının bir sıkıştırma yapmadığına diskteki kaplanan alanı azaltmak için yalnızca dosyaları 
    uç uca eklediğine dikkat ediniz. Tabii genellikle dosyalar tar'landıktan sonra ayrıca sıkıştırılabilir. Bu sistemlerdeki 
    "tar.gz" gibi dosya uzantıları tar'landıktan sonra zip'lenmiş olan dosyaları belirtmektedir. Pekiyi o halde bir cluster'ın
    kaç sektör olacağına nasıl karar verilmektedir? İşte sezgisel olarak disk hacmi büyüdükçe kaybedilen alanların önemi 
    azalacağı için cluster'ın çok sektörden oluşturulması, disk hacmi azaldıkça az sektörden oluşturulması yoluna gidilmektedir. 
    Format programları bu değerin kullanıcı tarafından belirlenmesine olanak sağlamakla birlikte default değer de önermektedir. 
    Linux'taki "mkfs.fat" programında ise cluster boyutu "-s" seçeneği ile belirlenmektedir. Örneğin:

    $ sudo mkfs.fat -F16 -s 2 /dev/loop0

    Burada bir cluster 2 sektörden oluşturulmuştur.

    İşte BPB bloğunun "0C" offset'inde bir cluster'ın kaç sektörden oluştuğu bilgisi yer almaktadır. İşletim sistemi dosyaların 
    parçalarına erişirken hep bu bilgiyi kullanmaktadır. (Burada değeri disk editörü ile değiştirsek dosya sistemi tamamen 
    saçmalayacaktır.) Yukarıdaki örnek boot sektörde bir cluster 4 sektörden (yani 4K = 2048 byte'tan) oluşmaktadır.

    Ayrılmış Sektörlerin Sayısı: Burada boot sektörü izleyen FAT bölümünün kaçıncı sektörden başladığı bilgisi yer almaktadır. 
    Tabii buradaki orijin FAT disk bölümünün başıdır. Yani boot sektör 0'ıncı sektörde olmak üzere FAT bölümünün kaçıncı sektörden
    başladığını belirtmektedir. Pekiyi neden boot sektör ile FAT arasında boşluk bırakmak gerekebilir? İşte hard disklerde 
    işletim sistemi FAT bölümünü ilk silindire hizalamak isteyebilir. Eğer özel uygulamalarda boot sektör yükleyici programı
    uzunsa yükleyicinin diğer parçaları da burada bulunabilmektedir. Yukarıdaki örnek FAT bölümünün boot sektöründe bu byte'lar
    "04 00" biçimindedir. Little Endian formatta bu değer 4'tür. O halde bu dosya sisteminde FAT bölümü 4'üncü sektörden 
    başlamaktadır.

    FAT Kopyalarının Sayısı: FAT bölümü izleyen paragraflarda da görüleceği gibi FAT dosya sisteminin önemli bir meta-data 
    alanıdır. Bu nedenle bu bölümün backup amaçlı birden fazla kopyasının bulundurulması uygun görülmüştür. Tipik olarak bu 
    alanda 2 değeri bulunur. Yani FAT bölümünün toplamda iki kopyası vardır. FAT bölümünün kopyaları hemen birbirinin peşi 
    sıra dizilmiştir. Yani bir kopyanın bittiği yerde diğeri başlamaktadır.

    Kök Dizinlerindeki Girişlerin Sayısı: FAT dosya sistemindeki bölümlerin dizilimin şöyle olduğunu belirtmiştik:

    Boot Sektör
    FAT ve Kopyaları
    Root Dir Bölümü
    Data Bölümü

    İşletim sisteminin tüm bölümlerin hangi sektörden başladığını ve kaç sektör uzunlukta olduğunu bilmesi gerekir. İşte 
    "Root Dir" bölümü dizin girişlerinden oluşmaktadır. Bir dizin girişi 32 byte uzunluğundadır. Burada toplam kaç giriş 
    olduğu belirtilmektedir. Dolayısıyla "Root Dir" bölümünün sektör uzunluğu buradaki sayının 32'ye bölümü ile hesaplanır. 
    Bizim oluşturduğumuz örnek FAT16 disk bölümünde burada "0x0200" (512) değeri bulunmaktadır. Bu durumda Root Dir bölümünün
    sektör uzunluğu 512 / 32 = 16'dır.

    Toplam Sektör Sayısı (Eski): Bu alanda disk bölümündeki toplam sektör sayısı bulundurulmaktadır. Ancak BPB formatının 
    tasarlandığı 1980'lerin başında henüz hard diskler çok yeniydi ve teknolojinin bu kadar hızlı gelişeceği düşünülmemişti.
    Dolayısıyla toplam sektör sayısı için 2 byte'lık yer o zamanlar için yeterli gibiydi. Toplam sektör sayısı için ayrılan 
    2 byte'lık yerde yazılabilecek maksimum değer 65535'tir. Bu değeri 512 ile çarparsak 33MB'lık bir alan söz konusu olur. 
    Gerçekten de o devirlerde diskler 33MB'den daha yukarıda formatlanamıyordu. DOS 4.01'e kadar 33MB bir üst sınırdı. Ancak 
    DOS 4.01 ile birlikte bu toplam sektör sayısı geçmişe doğru uyum korunarak 4 byte yükseltildi. Dolayısıyla DOS 4.01 ve 
    sonrasında artık disk bölümünün toplam kapasitesi 2^32 * 2^9 = 2TB'ye yükselmiş oldu. 4 byte'tan oluşan yeni toplam sektör
    sayısı alanı boot sektörün "0x20" offset'inde bulunmaktadır. Dosya sistemleri toplam sektör sayısı için önce "0x13" offset'inde 
    bulunan bu alana başvurmaktadır. Eğer bu alanda 0 yoksa bu alandaki bilgiyi, eğer bu alanda 0 varsa "0x20" offset'inden çekilen 
    DWORD bilgiyi dikkate almaktadır.

    - Ortam Belirleyicisi (Media Descriptor): Bu alanda dosya sisteminin konuşlandığı medyanın türünün ne olduğu bilgisi bulunmaktadır. 
    Aslında artık böyle bir bilgi işletim sistemleri tarafından kullanılmamaktadır. Buradaki 1 byte'ın yaygın değerleri şunlardır:

    0xF0: 1.44 Floppy Disk
    0xF8: Hard disk

    Bu alanda artık hep F8 byte'ı bulunmaktadır.

    FAT'in Bir Kopyasındaki Sektör Sayısı: Bu alanda FAT'in bir kopyasının kaç sektör uzunluğunda olduğu bilgisi bulunmaktadır.
    FAT'in default olarak 2 kopyasının olduğunu anımsayınız.

    Bir Yüzdeki Sektör Dilimlerinin Sayısı (Artık Kullanılmıyor): Bu alanda diskin bir yüzeyinde kaç sektör dilimi olduğu 
    bilgisi yer almaktadır. Eskiden sektörlerin koordinatları "yüzey numarası, track numarası ve sektör dilimi numarası"
    ile belirtiliyordu. Uzunca bir süredir artık bu sistem terk edilmiştir. Dolayısıyla bu alana başvurulmamaktadır.

    Disk Yüzeylerinin (Kafalarının) Sayısı (Artık Kullanılmıyor): Burada diskte toplam kaç yüzey (kafa) olduğu bilgisi yer 
    alıyordu. Ancak yine koordinat sistemi uzunca bir süre önce değiştirildiği için bu alan artık kullanılmamaktadır.

    Saklı Sektörlerin Sayısı: Bu alanda FAT dosya sisteminin diskin toplamda kaçıncı sektöründen başladığı bilgisi yer 
    almaktadır. Bu bilgi aynı zamanda Disk Bölümleme Tablosu (Disk Partition Table) içerisinde de yer almaktadır. İşletim 
    sistemleri bu iki değeri karşılaştırıp BPB bloğunun bozuk olup olmadığı konusunda bir karar da verebilmektedir.

    Yeni Toplam Sektör Sayısı: "0x13" offset'indeki WORD olarak bulundurulan eski "toplam sektör sayısı" bilgisinin DWORD olarak
    yenilenmiş biçimi bu alanda tutulmaktadır.

    Volüm Seri Numarası: Bir disk bölümü FAT dosya sistemi ile formatlandığında oraya rastgele üretilmiş olan bir "volüm seri 
    numarası" atanmaktadır. Bu volüm seri numarası eskiden floppy disket zamanlarında disketin değişip değişmediğini anlamak 
    için kullanılıyordu. Bugünlerde artık bu alan herhangi bir amaçla kullanılmamaktadır. Ancak sistem programcısı bu seri 
    numarasından başka amaçlar için faydalanabilir.

    Volüm İsmi: Her volüm formatlanırken ona bir isim verilmektedir. Bu isim o zamanki dosya isimlendirme kuralı gereği 
    8 + 3 = 11 karakterden oluşmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                170. Ders 11/10/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT dosya sistemine ilişkin bir uygulama yazabilmek için yapılacak ilk şey boot sektörü okuyup buradaki BPB bilgilerini 
    bir yapı nesnesinin içerisine yerleştirmektir. Bu bilgilerden hareketle bizim FAT dosya sistemine ilişkin metadata 
    alanlarının ilgili disk bölümünün kaçıncı sektöründen başlayıp kaç sektör uzunluğunda olduğunu elde etmemiz gerekir. Çünkü
    dosya sistemi ile ilgili işlemlerin hepsinde bu bilgilere gereksinim duyulacaktır. Bu bilgilerin yerleştirileceği yapı 
    şöyle olabilir:

    typedef struct tagBPB {
        uint16_t fatlen;        /* Number of sectors in FAT (A) */
        uint16_t rootlen;        /* Number of sectors in ROOT (NA) */
        uint16_t nfats;            /* Number of copies of FAT (A) */
        uint32_t tsects;        /* Total sector (A) */
        uint16_t bps;            /* Byte per sector(A) */
        uint16_t spc;            /* Sector per cluster(A) */
        uint16_t rsects;        /* Reserved sectors(A) */
        uint8_t mdes;            /* Media descriptor byte(A) */
        uint16_t spt;            /* Sector per track(A) */
        uint16_t rootents;        /* Root entry (A) */
        uint16_t nheads;        /* Number of heads (A) */
        uint16_t hsects;        /* Number of hidden sector( A) */
        uint16_t tph;            /* Track per head (NA) */
        uint16_t fatloc;        /* FAT directory location (NA) */
        uint16_t rootloc;        /* Root directory location (NA) */
        uint16_t dataloc;        /* First data sector location (NA) */
        uint32_t datalen;        /* Number of sectors in Data (NA) */
        uint32_t serial;        /* Volume Serial Number (A) */
        char vname[12];            /* Volume Name (A) */
    } BPB;

    Burada "A" (available) ile belirtilen elemanlar zaten BPB içerisinde olan elemanlardır. "NA" (not available) ile belirtilen 
    elemanlar BPB içerisinde yoktur. Dört işlemle hesaplanarak değeri oluşturulacaktır. Linux'ta boot sektör'ü okuyarak oradaki
    BPB bilgilerini yukarıdaki gibi bir yapıya yerleştiren örnek bir program aşağıda verilmiştir. Derlemeyi şöyle yapabilirsiniz:

    $ gcc -o app fatsys.c app.c

    Programı FAT dosya sistemine ilişkin blok aygıt dosyasının yol ifadesini vererek sudo ile çalıştırabilirsiniz. Örneğin:

    $ sudo ./app /dev/loop0

    Aşağıdakine benzer bir çıktı elde edilecektir:

    Byte per sector: 512
    Sector per cluster: 4
    Number of reserved sectors: 4
    Number of FAT copies: 100
    Number of sectors in Root Dir: 32
    Number of FAT copies: 2
    Number of sectors in volume: 100000
    Media Descriptor: F8
    Number of Root Dir entries: 200
    Number of hidden sectors: 0
    FAT location: 4
    Root Dir location: 204
    Data location: 236
    Volume Serial Number: BC7B-4578
    Volume Name: FAT16
---------------------------------------------------------------------------------------------------------------------------*/

/* fatsys.h */

#ifndef FATSYS_H_
#define FATSYS_H_

#include <stdint.h>

#define FILE_INFO_LENGTH        32

/* Type Declarations */

typedef struct tagBPB {
    uint16_t fatlen;        /* Number of sectors in FAT (A) */
    uint16_t rootlen;        /* Number of sectors in ROOT (NA) */
    uint16_t nfats;            /* Number of copies of FAT (A) */
    uint32_t tsects;        /* Total sector (A) */
    uint16_t bps;            /* Byte per sector(A) */
    uint16_t spc;            /* Sector per cluster(A) */
    uint16_t rsects;        /* Reserved sectors(A) */
    uint8_t mdes;            /* Media descriptor byte(A) */
    uint16_t spt;            /* Sector per track(A) */
    uint16_t rootents;        /* Root entry (A) */
    uint16_t nheads;        /* Number of heads (A) */
    uint16_t hsects;        /* Number of hidden sector( A) */
    uint16_t tph;            /* Track per head (NA) */
    uint16_t fatloc;        /* FAT directory location (NA) */
    uint16_t rootloc;        /* Root directory location (NA) */
    uint16_t dataloc;        /* First data sector location (NA) */
    uint32_t datalen;        /* Number of sectors in Data (NA) */
    uint32_t serial;        /* Volume Serial Number (A) */
    char vname[12];            /* Volume Name (A) */
} BPB;

/* Function prototypes */

int read_bpb(int fd, BPB *bpb);

#endif

/* fatsys.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include "fatsys.h"

int read_bpb(int fd, BPB *bpb)
{
    uint8_t bsec[512];

    if (read(fd, bsec, 512) == -1)
        return -1;

    bpb->bps = *(uint16_t *)(bsec + 0x0B);
    bpb->spc = *(uint8_t *)(bsec + 0x0D);
    bpb->rsects = *(uint16_t *)(bsec + 0x0E);
    bpb->fatlen = *(uint16_t *)(bsec + 0x16);
    bpb->rootlen = *(uint16_t *)(bsec + 0x11) * FILE_INFO_LENGTH / bpb->bps;
    bpb->nfats = *(uint8_t *)(bsec + 0x10);
    if (*(uint16_t *)(bsec + 0x13))
        bpb->tsects = *(uint16_t *)(bsec + 0x13);
    else
        bpb->tsects = *(uint32_t *)(bsec + 0x20);
    bpb->mdes = *(bsec + 0x15);
    bpb->spt = *(uint16_t *)(bsec + 0x18);
    bpb->rootents = *(uint16_t *)(bsec + 0x11);
    bpb->nheads = *(uint16_t *)(bsec + 0x1A);
    bpb->hsects = *(uint16_t *)(bsec + 0x1C);
    bpb->tph = (uint16_t)(bpb->tsects / bpb->spt / bpb->nheads);
    bpb->fatloc = bpb->rsects;
    bpb->rootloc = bpb->rsects + bpb->fatlen *bpb->nfats;
    bpb->dataloc = bpb->rootloc + bpb->rootlen;
    bpb->datalen = bpb->tsects - bpb->dataloc;
    bpb->serial = *(uint32_t *)(bsec + 0x27);
    memcpy(bpb->vname, bsec + 0x2B, 11);
    bpb->vname[11] = '\0';

    return 0;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include "fatsys.h"

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    BPB bpb;
    int fd;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

     if ((fd = open(argv[1], O_RDWR)) == -1)
        return -1;

    if (read_bpb(fd, &bpb) == -1)
        exit_sys("read_bpb");

    printf("Byte per sector: %d\n", bpb.bps);
    printf("Sector per cluster: %d\n", bpb.spc);
    printf("Number of reserved sectors: %d\n", bpb.rsects);
    printf("Number of FAT copies: %d\n", bpb.fatlen);
    printf("Number of sectors in Root Dir: %d\n", bpb.rootlen);
    printf("Number of FAT copies: %d\n", bpb.nfats);
    printf("Number of sectors in volume: %u\n", bpb.tsects);
    printf("Media Descriptor: %02X\n", bpb.mdes);
    printf("Number of Root Dir entries: %02X\n", bpb.rootents);
    printf("Number of hidden sectors: %d\n", bpb.hsects);
    printf("FAT location: %d\n", bpb.fatloc);
    printf("Root Dir location: %d\n", bpb.rootloc);
    printf("Data location: %d\n", bpb.dataloc);
    printf("Number of sectors in Data: %d\n", bpb.datalen);
    printf("Volume Serial Number: %04X-%04X\n", bpb.serial >> 16, 0xFFFF & bpb.serial);
    printf("Volume Name: %s\n", bpb.vname);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıdaki örnekte FAT dosya sistemine ilişkin tüm önemli alanların yerlerine ve uzunluklarına ilişkin bilgileri 
    elde ederek bir yapıya yerleştirdik. Artık şu bilgilere sahibiz:

    - FAT bölümünün yeri ve uzunluğu (yapının fatloc ve fatlen elemanları)
    - Root DIR bölümünün yeri ve uzunluğu (yapının rootloc ve rootlen elemanları)
    - Data bölümünün yeri ve uzunluğu (yapının dataloc ve datalen elemanları)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                171. Ders 13/10/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi yukarıdaki yapıyı biraz daha geliştirelim. Bunun için dosya sistemini temsil eden aşağıdaki gibi bir yapı oluşturabiliriz:

    typedef struct tagFATSYS {
        int fd;             /* Volume file descriptor */
        BPB bpb;            /* BPB info */
        uint32_t fatoff;    /* Offset of FAT */
        uint32_t rootoff;   /* Offset of root directory */
        uint32_t dataoff;   /* Offset of DATA */
        uint32_t clulen;    /* Cluster length as bytes */
        /* ... */
    } FATSYS;

    Dosya işlemi yaparken dosya sisteminin belirli bölümlerine konumlandırma yapacağımız için onların offset'lerini de FATSYS 
    yapısının içerisine yerleştireceğiz.

    Dosya sistemini açan ve kapatan aşağıdaki fonksiyonlar oluşturabiliriz:

    FATSYS *open_fatsys(const char *path)
    {
        FATSYS *fatsys;
        int fd;

        if ((fd = open(path, O_RDWR)) == -1)
            return NULL;

        if ((fatsys = (FATSYS *)malloc(sizeof(FATSYS))) == NULL)
            return NULL;

        if (read_bpb(fd, &fatsys->bpb) == -1) {
            free(fatsys);
            return NULL;
        }

        fatsys->fd = fd;
        fatsys->fatoff = fatsys->bpb.fatloc * fatsys->bpb.bps;
        fatsys->rootoff = fatsys->bpb.rootloc * fatsys->bpb.bps;
        fatsys->dataoff = fatsys->bpb.dataloc * fatsys->bpb.bps;
        fatsys->clulen = fatsys->bpb.bps * fatsys->bpb.spc;

        return fatsys;
    }

    int close_fatsys(FATSYS *fatsys)
    {
        if (close(fatsys->fd) == -1)
            return -1;

        free(fatsys);

        return 0;
    }

    Kullanım şöyle olabilir:

    FATSYS *fatsys;

    if ((fatsys = open_fatsys("/dev/loop0")) == NULL)
        exit_sys("open_fatsys");

    close_fatsys(fatsys);

    Aşağıda bu değişikliklerin yapıldığı kodlar verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* fatsys.h */

#ifndef FATSYS_H_
#define FATSYS_H_

#include <stdint.h>

#define FILE_INFO_LENGTH        32

/* Type Declarations */

typedef struct tagBPB {
    uint16_t fatlen;        /* Number of sectors in FAT (A) */
    uint16_t rootlen;        /* Number of sectors in ROOT (NA) */
    uint16_t nfats;            /* Number of copies of FAT (A) */
    uint32_t tsects;        /* Total sector (A) */
    uint16_t bps;            /* Byte per sector(A) */
    uint16_t spc;            /* Sector per cluster(A) */
    uint16_t rsects;        /* Reserved sectors(A) */
    uint8_t mdes;            /* Media descriptor byte(A) */
    uint16_t spt;            /* Sector per track(A) */
    uint16_t rootents;        /* Root entry (A) */
    uint16_t nheads;        /* Number of heads (A) */
    uint16_t hsects;        /* Number of hidden sector( A) */
    uint16_t tph;            /* Track per head (NA) */
    uint16_t fatloc;        /* FAT directory location (NA) */
    uint16_t rootloc;        /* Root directory location (NA) */
    uint16_t dataloc;        /* First data sector location (NA) */
    uint32_t datalen;        /* Number of sectors in Data (NA) */
    uint32_t serial;        /* Volume Serial Number (A) */
    char vname[12];            /* Volume Name (A) */
} BPB;

typedef struct tagFATSYS {
    int fd;                    /* Volume file descriptor */
    BPB bpb;                /* BPB info */
    uint32_t fatoff;        /* Offset of FAT */
    uint32_t rootoff;        /* Offset of root directory */
    uint32_t dataoff;        /* Offset of DATA */
    uint32_t clulen;        /* Cluster length as bytes */
    /* ... */
} FATSYS;

/* Function prototypes */

int read_bpb(int fd, BPB *bpb);
FATSYS *open_fatsys(const char *path);
int close_fatsys(FATSYS *fatsys);
int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf);
int wite_cluster(FATSYS *fatsys, uint32_t clu, const void *buf);

#endif

/* fatsys.c */

FATSYS *open_fatsys(const char *path)
{
    FATSYS *fatsys;
    int fd;

    if ((fd = open(path, O_RDWR)) == -1)
        return NULL;

    if ((fatsys = (FATSYS *)malloc(sizeof(FATSYS))) == NULL)
        return NULL;

    if (read_bpb(fd, &fatsys->bpb) == -1) {
        free(fatsys);
        return NULL;
    }

    fatsys->fd = fd;
    fatsys->fatoff = fatsys->bpb.fatloc * fatsys->bpb.bps;
    fatsys->rootoff = fatsys->bpb.rootloc * fatsys->bpb.bps;
    fatsys->dataoff = fatsys->bpb.dataloc * fatsys->bpb.bps;
    fatsys->clulen = fatsys->bpb.bps * fatsys->bpb.spc;

    return fatsys;
}

int close_fatsys(FATSYS *fatsys)
{
    if (close(fatsys->fd) == -1)
        return -1;

    free(fatsys);

    return 0;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include "fatsys.h"

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    FATSYS *fatsys;

    if ((fatsys = open_fatsys("/dev/loop0")) == NULL)
        exit_sys("open_fatsys");

    close_fatsys(fatsys);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    FAT dosya sisteminde dosya sistemindeki "Data Bölümü" dosya içeriklerinin tutulduğu bölümdür. İşletim sistemi bu bölümün
    sektörlerden değil cluster'lardan oluştuğunu varsaymaktadır. Anımsanacağı gibi "cluster" bir dosyanın parçası olabilecek 
    en küçük tahsisat birimidir ve ardışıl n sektörden oluşmaktadır. Buradaki n değeri 2'nin bir kuvvetidir (yani 1, 2, 4, 
    8, ... biçiminde). İşte volümün Data bölümündeki her cluster'a 2'den başlanarak (0 ve 1 reserved bırakılmıştır) bir 
    cluster numarası karşı getirilmiştir. Örneğin bir cluster'ın 4 sektörden oluştuğunu düşünelim. Bu durumda Data bölümünün 
    ilk 4 sektörü 2 numaralı cluster, sonraki 4 sektörü 3 numaralı cluster, sonraki 4 sektörü 4 numaralı cluster biçiminde 
    numaralanmaktadır.

    Bizim FAT dosya sistemi üzerinde ilk yapmaya çalışacağımız alt seviye işlemlerden biri belli bir numaralı cluster'ı okuyup 
    yazan fonksiyonları gerçekleştirmektir. Bu fonksiyonların prototipleri şöyle olabilir:

    int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf);
    int wite_cluster(FATSYS *fatsys, uint32_t clu, const void *buf);

    Data bölümünün ilk cluster'ının 2 numaralı cluster olduğunu 0 ve 1 cluster'larının kullanılmadığını anımsayınız. Bu 
    fonksiyonlar basit biçimde şöyle yazılabilir:

    int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf)
    {
        if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
            return -1;

        return read(fatsys->fd, buf, fatsys->clulen);
    }

    int write_cluster(FATSYS *fatsys, uint32_t clu, const void *buf)
    {
        if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
            return -1;

        return write(fatsys->fd, buf, fatsys->clulen);
    }

    Aşağıda fonksiyonun kullanımına ilişkin bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* fatsys.h */

#ifndef FATSYS_H_
#define FATSYS_H_

#include <stdint.h>

#define FILE_INFO_LENGTH        32

/* Type Declarations */

typedef struct tagBPB {
    uint16_t fatlen;        /* Number of sectors in FAT (A) */
    uint16_t rootlen;        /* Number of sectors in ROOT (NA) */
    uint16_t nfats;            /* Number of copies of FAT (A) */
    uint32_t tsects;        /* Total sector (A) */
    uint16_t bps;            /* Byte per sector(A) */
    uint16_t spc;            /* Sector per cluster(A) */
    uint16_t rsects;        /* Reserved sectors(A) */
    uint8_t mdes;            /* Media descriptor byte(A) */
    uint16_t spt;            /* Sector per track(A) */
    uint16_t rootents;        /* Root entry (A) */
    uint16_t nheads;        /* Number of heads (A) */
    uint16_t hsects;        /* Number of hidden sector( A) */
    uint16_t tph;            /* Track per head (NA) */
    uint16_t fatloc;        /* FAT directory location (NA) */
    uint16_t rootloc;        /* Root directory location (NA) */
    uint16_t dataloc;        /* First data sector location (NA) */
    uint32_t datalen;        /* Number of sectors in Data (NA) */
    uint32_t serial;        /* Volume Serial Number (A) */
    char vname[12];            /* Volume Name (A) */
} BPB;

typedef struct tagFATSYS {
    int fd;                    /* Volume file descriptor */
    BPB bpb;                /* BPB info */
    uint32_t fatoff;        /* Offset of FAT */
    uint32_t rootoff;        /* Offset of root directory */
    uint32_t dataoff;        /* Offset of DATA */
    uint32_t clulen;        /* Cluster length as bytes */
    /* ... */
} FATSYS;

/* Function prototypes */

int read_bpb(int fd, BPB *bpb);
FATSYS *open_fatsys(const char *path);
int close_fatsys(FATSYS *fatsys);
int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf);
int wite_cluster(FATSYS *fatsys, uint32_t clu, const void *buf);

#endif

/* fatsys.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include "fatsys.h"

int read_bpb(int fd, BPB *bpb)
{
    uint8_t bsec[512];

    if (read(fd, bsec, 512) == -1)
        return -1;

    bpb->bps = *(uint16_t *)(bsec + 0x0B);
    bpb->spc = *(uint8_t *)(bsec + 0x0D);
    bpb->rsects = *(uint16_t *)(bsec + 0x0E);
    bpb->fatlen = *(uint16_t *)(bsec + 0x16);
    bpb->rootlen = *(uint16_t *)(bsec + 0x11) * FILE_INFO_LENGTH / bpb->bps;
    bpb->nfats = *(uint8_t *)(bsec + 0x10);
    if (*(uint16_t *)(bsec + 0x13))
        bpb->tsects = *(uint16_t *)(bsec + 0x13);
    else
        bpb->tsects = *(uint32_t *)(bsec + 0x20);
    bpb->mdes = *(bsec + 0x15);
    bpb->spt = *(uint16_t *)(bsec + 0x18);
    bpb->rootents = *(uint16_t *)(bsec + 0x11);
    bpb->nheads = *(uint16_t *)(bsec + 0x1A);
    bpb->hsects = *(uint16_t *)(bsec + 0x1C);
    bpb->tph = (uint16_t)(bpb->tsects / bpb->spt / bpb->nheads);
    bpb->fatloc = bpb->rsects;
    bpb->rootloc = bpb->rsects + bpb->fatlen *bpb->nfats;
    bpb->dataloc = bpb->rootloc + bpb->rootlen;
    bpb->datalen = bpb->tsects - bpb->dataloc;
    bpb->serial = *(uint32_t *)(bsec + 0x27);
    memcpy(bpb->vname, bsec + 0x2B, 11);
    bpb->vname[11] = '\0';

    return 0;
}

FATSYS *open_fatsys(const char *path)
{
    FATSYS *fatsys;
    int fd;

    if ((fatsys = (FATSYS *)malloc(sizeof(FATSYS))) == NULL)
        return NULL;

    if ((fd = open(path, O_RDWR)) == -1)
        return NULL;

    if (read_bpb(fd, &fatsys->bpb) == -1) {
        close(fd);
        free(fatsys);
        return NULL;
    }

    fatsys->fd = fd;
    fatsys->fatoff = fatsys->bpb.fatloc * fatsys->bpb.bps;
    fatsys->rootoff = fatsys->bpb.rootloc * fatsys->bpb.bps;
    fatsys->dataoff = fatsys->bpb.dataloc * fatsys->bpb.bps;
    fatsys->clulen = fatsys->bpb.bps * fatsys->bpb.spc;

    return fatsys;
}

int close_fatsys(FATSYS *fatsys)
{
    if (close(fatsys->fd) == -1)
        return -1;

    free(fatsys);

    return 0;
}

int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf)
{
    if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
        return -1;

    return read(fatsys->fd, buf, fatsys->clulen);
}

int write_cluster(FATSYS *fatsys, uint32_t clu, const void *buf)
{
    if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
        return -1;

    return write(fatsys->fd, buf, fatsys->clulen);
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include "fatsys.h"

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    FATSYS *fatsys;
    unsigned char buf[8192];

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fatsys = open_fatsys(argv[1])) == NULL)
        exit_sys("open_fatsys");

    if (read_cluster(fatsys, 2, buf) == -1)
        exit_sys("read_cluster");

    for (int i = 0; i < fatsys->clulen; ++i)
        printf("%02X%c", buf[i], i % 16 == 15 ? '\n' : ' ');

    close_fatsys(fatsys);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                172. Ders 18/10/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT dosya sisteminde her dosya cluster'lara bölünerek Data bölümündeki cluster'larda tutulmaktadır. Dosyanın parçaları
    ardışıl cluster'larda olmak zorunda değildir. Örneğin bir cluster'ın 4 sektör olduğu bir volümde 10000 byte uzunluğunda 
    bir dosya söz konusu olsun. Bir cluster'ın boyutu 4 * 512 = 2048 byte'tır. O halde bu dosya 5 cluster yer kaplayacaktır. 
    Ancak son cluster'da kullanılmayan bir miktar boş alan da kalacaktır. İşte örneğin bu dosyanın cluster numaraları aşağıdaki
    gibi olabilir:

    2 8 14 15 21

    Görüldüğü gibi dosyanın parçaları ardışıl cluster'larda olmak zorunda değildir. Tabi işletim sistemi genellikle dosyanın 
    parçalarını mümkün olduğu kadar ardışıl cluster'larda saklamaya çalışır. Ancak bu durum mümkün olmayabilir. Belli bir süre 
    sonra artık dosyaların parçaları birbirinden uzaklaşmaya başlayabilir. İşte FAT dosya sisteminde hangi dosyanın hangi 
    parçalarının Data bölümünün hangi cluster'larında olduğunun saklandığı metadata alana FAT (File Allocation Table) denilmektedir.

    FAT bölümü FAT elemanlarından oluşur. FAT'ler 12 bit, 16 bit ve 32 bit olmak üzere üçe ayrılmaktadır. 12 bit FAT'lerde 
    FAT elemanları 12 bit, 16 bit FAT'lerde FAT elemanları 16 bit ve 32 bit FAT'lerde FAT elemanları 32 bit uzunluğundadır. 
    İlk iki cluster kullanılmadığı için FAT'in ilk iki elemanı da kullanılmamaktadır.

    FAT bağlı listelerden oluşan bir metadata alanıdır. Her dosyanın ilk cluster'ının nerede olduğu dizin girişinde tutulmaktadır. 
    Sonra her FAT elemanı dosyanın parçasının hangi cluster'da olduğu bilgisini tutar. Volümde toplan N tane cluster varsa
    FAT bölümünde de toplam N tane FAT elemanı vardır. FAT bölümünde her bir dosya için ayrı bir bağlı liste bulunmaktadır. 
    Bir dosyanın ilk cluster'ı biliniyorsa sonraki tüm cluster'ları bu bağlı liste izlenerek elde edilebilmektedir. Bağlı 
    listenin organizasyonu şu biçimdedir: Dosyanın ilk cluster'ının yerinin 8 olduğunu varsayalım. Şimdi FAT'in 8'inci 
    elemanına gidildiğinde orada 14 yazıyor olsun. 14 numaralı elemanına gittiğimizde orada 18 yazdığını düşünelim. 18 elemana 
    gittiğimizde orada 22 yazdığını düşünelim. Nihayet 22 numaralı elemana gittiğimizde orada FFFF biçiminde özel bir değerin 
    yazdığını varsayalım. Bu durumu şekilsel olarak şöyle gösterebiliriz:

    8 ---> 14 ---> 18 ---> 22 (FFFF)

    Bu durumda bu dosyanın cluster'ları sırasıyla 8 14 18 22 numaralı cluster'lardır. Burada FFFF değeri EOF anlamına özel bir 
    cluster numarasıdır. Yani FAT'teki her FAT elemanı dosyanın sonraki parçasının hangi cluster'da olduğunu belirtmektedir. 
    Böylece işletim sistemi dosyanın ilk cluster numarasını biliyorsa bu zinciri takip ederek onun bütün cluster'larını elde 
    edebilir.

    Örneğin 1 cluster'ın 4 sektör olduğu bir FAT16 sisteminde 19459 byte'lık bir dosya toplam 10 cluster yer kaplamaktadır. 
    Biz bu dosyanın ilk cluster numarasının 4 olduğunu biliyoruz. Aşağıdaki örnek FAT bölümünde bu dosyanın tüm cluster'larının 
    numaraları bağlı liste izlenerek elde edilebilecektir:

    00000800  f8 ff ff ff 00 00 ff ff  05 00 06 00 07 00 08 00  |................|
    00000810  09 00 0a 00 0b 00 0c 00  0d 00 ff ff 00 00 00 00  |................|
    00000820  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000830  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000840  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000850  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    ...

    Bu byte'lar bir FAT16 sisteminin FAT bölümüne ilişkin olduğuna göre her bir FAT elemanı 2 byte yer kaplayacaktır. Burada 
    FAT elemanlarının hex karşılıkları şöyledir (Little Endian notasyon kullanıldığına dikkat ediniz):

    0        1      2      3      4      5      6      7      8      9      10     11     12     13
    <FFF8> <FFFF> <0000> <FFFF> <0005> <0006> <0007> <0008> <0009> <000A> <000B> <000C> <000D> <FFFF>

    Burada FAT elemanlarının numaralarını desimal sistemde elemanların yukarısına yazdık. Söz konusu dosyanın ilk cluster 
    numarasının 4 olduğunu bildiğimizi varsayıyoruz. 4 numaralı FAT elemanında 5 (0005) yazmaktadır. O halde dosyanın sonraki 
    cluster numarası 5'tir. 5 numaralı FAT elemanında 6 (0006) yazmaktadır. 6 numaralı FAT elemanında 7 (0007), 7 numaralı FAT 
    elemanında 8 (0008), 8 numaralı FAT elemanında 9 (0009), 9 numaralı FAT elemanında 10 (000A), 10 numaralı FAT elemanında 11 
    (000B), 11 numaralı FAT elemanında 12 (000C), 12 numaralı FAT elemanında 13 (000D), 13 FAT elemanında da özel değer olan 
    65535 (FFFF) bulunmaktadır. Bu özel değer zincirin sonuna gelindiğini belirtmektedir. Bu durumda bu dosyanın tüm parçaları 
    sırasıyla şu cluster'lardadır:

    4 5 6 7 8 9 10 11 12 13

    Burada işletim sisteminin dosyanın parçalarını diskte ardışıl cluster'lara yerleştirdiğini görüyorsunuz. Ancak bu durum 
    her zaman böyle olma zorunda değildir.

    16 bir FAT'te bir FAT elemanında bulunacak değerler şunlar olabilmektedir (değerler Little Endian olarak WORD'e dönüştürülmüştür):

    0000            Boş cluster
    0001            Kullanılmıyor
    0002 -  FFEF    Geçerli, sonraki cluster
    FFF0H - FFF6    Reserved cluster
    FFF7            Bozuk cluster, işletim sistemi bu cluster'a dosya parçası yerleştirmez
    FFF8 - FFFF     Son cluster
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi işletim sistemleri FAT bölümünü nasıl ele alıp işlemektedir? Aslında FAT bölümündeki sektörler zaten çok kullanıldığı 
    için işletim sisteminin aşağı seviyeli disk cache sisteminde bulunuyor durumda olurlar. Ancak işletim sistemleri genellikle 
    FAT elemanları temelinde de bir cache sistemi de oluşturmaktadır. Böylece bir cluster değeri verildiğinde eğer daha önce o 
    cluster ile işlemler yapılmışsa o cluster'ın sonraki cluster'ı hızlı bir biçimde elde edilebilmektedir.

    Biz burada volümü açtığımızda tüm FAT bölümünü okuyup FATSYS yapısının içerisine yerleştireceğiz. Sonra da ilk cluster 
    numarası bilinen dosyaların cluster zincirini elde eden bir fonksiyon yazacağız. open_fatsys fonksiyonunun yeni versiyonu 
    aşağıdaki gibi olabilir:

    FATSYS *open_fatsys(const char *path)
    {
        FATSYS *fatsys;
        int fd;

        if ((fatsys = (FATSYS *)malloc(sizeof(FATSYS))) == NULL)
            return NULL;

        if ((fd = open(path, O_RDWR)) == -1)
            goto EXIT1;

        if (read_bpb(fd, &fatsys->bpb) == -1)
            goto EXIT2;

        fatsys->fd = fd;
        fatsys->fatoff = fatsys->bpb.fatloc * fatsys->bpb.bps;
        fatsys->rootoff = fatsys->bpb.rootloc * fatsys->bpb.bps;
        fatsys->dataoff = fatsys->bpb.dataloc * fatsys->bpb.bps;
        fatsys->clulen = fatsys->bpb.bps * fatsys->bpb.spc;

        if ((fatsys->fat = (uint8_t *)malloc(fatsys->bpb.fatlen * fatsys->bpb.bps)) == NULL)
            goto EXIT2;

        if (lseek(fatsys->fd, fatsys->fatoff, SEEK_SET) == -1)
            goto EXIT3;

        if (read(fd, fatsys->fat, fatsys->bpb.fatlen * fatsys->bpb.bps) == -1)
            goto EXIT3;

        return fatsys;
    EXIT3:
        free(fatsys->fat);
    EXIT2:
        close(fd);
    EXIT1:
        free(fatsys);

        return NULL;
    }

    İlk cluster numarası bilinen dosyanın cluster zincirini elde eden fonksiyon da aşağıdaki gibi yazılabilir:

    uint16_t *getclu_chain16(FATSYS *fatsys, uint32_t firstclu, uint16_t *count)
    {
        uint16_t clu, n;
        uint16_t *chain, *temp;
        uint32_t capacity;

        clu = firstclu;
        capacity = CHAIN_DEF_CAPACITY;
        n = 0;

        if ((chain = (uint16_t *)malloc(sizeof(uint16_t) * CHAIN_DEF_CAPACITY)) == NULL)
            return NULL;
        do {
            chain[n++] = clu;
            if (n == capacity) {
                capacity *= 2;
                if ((temp = realloc(chain, sizeof(uint16_t) * capacity )) == NULL) {
                    free(chain);
                    return NULL;
                }
                chain = temp;
            }
            clu = *(uint16_t *)(fatsys->fat + clu * 2);
        } while (clu < 0xFFF8);
        *count = n;

        return chain;
    }

    Bu fonksiyonda dosyanın cluster zinciri için uint16_t türünden dinamik büyütülen bir dizi oluşturulmuştur. Dizi eski 
    uzunluğunun iki katı olacak biçimde büyütülmektedir. Fonksiyon bize hem cluster zincirini vermekte hem de bu zincirin 
    uzunluğunu vermektedir.

    Aşağıda tüm kodlar bütün olarak verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* fatsys.h */

#ifndef FATSYS_H_
#define FATSYS_H_

#include <stdint.h>

#define FILE_INFO_LENGTH        32
#define CHAIN_DEF_CAPACITY        8

/* Type Declarations */

typedef struct tagBPB {
    uint16_t fatlen;        /* Number of sectors in FAT (A) */
    uint16_t rootlen;        /* Number of sectors in ROOT (NA) */
    uint16_t nfats;            /* Number of copies of FAT (A) */
    uint32_t tsects;        /* Total sector (A) */
    uint16_t bps;            /* Byte per sector(A) */
    uint16_t spc;            /* Sector per cluster(A) */
    uint16_t rsects;        /* Reserved sectors(A) */
    uint8_t mdes;            /* Media descriptor byte(A) */
    uint16_t spt;            /* Sector per track(A) */
    uint16_t rootents;        /* Root entry (A) */
    uint16_t nheads;        /* Number of heads (A) */
    uint16_t hsects;        /* Number of hidden sector( A) */
    uint16_t tph;            /* Track per head (NA) */
    uint16_t fatloc;        /* FAT directory location (NA) */
    uint16_t rootloc;        /* Root directory location (NA) */
    uint16_t dataloc;        /* First data sector location (NA) */
    uint32_t datalen;        /* Number of sectors in Data (NA) */
    uint32_t serial;        /* Volume Serial Number (A) */
    char vname[12];            /* Volume Name (A) */
} BPB;

typedef struct tagFATSYS {
    int fd;                    /* Volume file descriptor */
    BPB bpb;                /* BPB info */
    uint32_t fatoff;        /* Offset of FAT */
    uint32_t rootoff;        /* Offset of root directory */
    uint32_t dataoff;        /* Offset of DATA */
    uint32_t clulen;        /* Cluster length as bytes */
    uint8_t *fat;            /* FAT sectors */
    /* ... */
} FATSYS;

/* Function prototypes */

int read_bpb(int fd, BPB *bpb);
FATSYS *open_fatsys(const char *path);
int close_fatsys(FATSYS *fatsys);
int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf);
int wite_cluster(FATSYS *fatsys, uint32_t clu, const void *buf);
uint16_t *getclu_chain16(FATSYS *fatsys, uint32_t firstclu, uint16_t *count);
void freeclu_chain(uint16_t *chain);

#endif

/* fatsys.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include "fatsys.h"

int read_bpb(int fd, BPB *bpb)
{
    uint8_t bsec[512];

    if (read(fd, bsec, 512) == -1)
        return -1;

    bpb->bps = *(uint16_t *)(bsec + 0x0B);
    bpb->spc = *(uint8_t *)(bsec + 0x0D);
    bpb->rsects = *(uint16_t *)(bsec + 0x0E);
    bpb->fatlen = *(uint16_t *)(bsec + 0x16);
    bpb->rootlen = *(uint16_t *)(bsec + 0x11) * FILE_INFO_LENGTH / bpb->bps;
    bpb->nfats = *(uint8_t *)(bsec + 0x10);
    if (*(uint16_t *)(bsec + 0x13))
        bpb->tsects = *(uint16_t *)(bsec + 0x13);
    else
        bpb->tsects = *(uint32_t *)(bsec + 0x20);
    bpb->mdes = *(bsec + 0x15);
    bpb->spt = *(uint16_t *)(bsec + 0x18);
    bpb->rootents = *(uint16_t *)(bsec + 0x11);
    bpb->nheads = *(uint16_t *)(bsec + 0x1A);
    bpb->hsects = *(uint16_t *)(bsec + 0x1C);
    bpb->tph = (uint16_t)(bpb->tsects / bpb->spt / bpb->nheads);
    bpb->fatloc = bpb->rsects;
    bpb->rootloc = bpb->rsects + bpb->fatlen *bpb->nfats;
    bpb->dataloc = bpb->rootloc + bpb->rootlen;
    bpb->datalen = bpb->tsects - bpb->dataloc;
    bpb->serial = *(uint32_t *)(bsec + 0x27);
    memcpy(bpb->vname, bsec + 0x2B, 11);
    bpb->vname[11] = '\0';

    return 0;
}

FATSYS *open_fatsys(const char *path)
{
    FATSYS *fatsys;
    int fd;

    if ((fatsys = (FATSYS *)malloc(sizeof(FATSYS))) == NULL)
        return NULL;

    if ((fd = open(path, O_RDWR)) == -1)
        goto EXIT1;

    if (read_bpb(fd, &fatsys->bpb) == -1)
        goto EXIT2;

    fatsys->fd = fd;
    fatsys->fatoff = fatsys->bpb.fatloc * fatsys->bpb.bps;
    fatsys->rootoff = fatsys->bpb.rootloc * fatsys->bpb.bps;
    fatsys->dataoff = fatsys->bpb.dataloc * fatsys->bpb.bps;
    fatsys->clulen = fatsys->bpb.bps * fatsys->bpb.spc;

    if ((fatsys->fat = (uint8_t *)malloc(fatsys->bpb.fatlen * fatsys->bpb.bps)) == NULL)
        goto EXIT2;

    if (lseek(fatsys->fd, fatsys->fatoff, SEEK_SET) == -1)
        goto EXIT3;

    if (read(fd, fatsys->fat, fatsys->bpb.fatlen * fatsys->bpb.bps) == -1)
        goto EXIT3;

    return fatsys;

EXIT3:
    free(fatsys->fat);
EXIT2:
    close(fd);
EXIT1:
    free(fatsys);

    return NULL;
}

int close_fatsys(FATSYS *fatsys)
{
    free(fatsys->fat);
    if (close(fatsys->fd) == -1)
        return -1;
    free(fatsys);

    return 0;
}

int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf)
{
    if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
        return -1;

    return read(fatsys->fd, buf, fatsys->clulen);
}

int write_cluster(FATSYS *fatsys, uint32_t clu, const void *buf)
{
    if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
        return -1;

    return write(fatsys->fd, buf, fatsys->clulen);
}

uint16_t *getclu_chain16(FATSYS *fatsys, uint32_t firstclu, uint16_t *count)
{
    uint16_t clu, n;
    uint16_t *chain, *temp;
    uint32_t capacity;

    clu = firstclu;
    capacity = CHAIN_DEF_CAPACITY;
    n = 0;

    if ((chain = (uint16_t *)malloc(sizeof(uint16_t) * CHAIN_DEF_CAPACITY)) == NULL)
        return NULL;
    do {
        chain[n++] = clu;
        if (n == capacity) {
            capacity *= 2;
            if ((temp = realloc(chain, sizeof(uint16_t) * capacity )) == NULL) {
                free(chain);
                return NULL;
            }
            chain = temp;
        }
        clu = *(uint16_t *)(fatsys->fat + clu * 2);
    } while (clu < 0xFFF8);
    *count = n;

    return chain;
}

void freeclu_chain(uint16_t *chain)
{
    free(chain);
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include "fatsys.h"

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    FATSYS *fatsys;
    uint16_t count;
    uint16_t *chain;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fatsys = open_fatsys(argv[1])) == NULL)
        exit_sys("open_fatsys");

    if ((chain = getclu_chain16(fatsys, 4, &count)) == NULL) {
        fprintf(stderr, "cannot get cluster chain!...\n");
        exit(EXIT_FAILURE);
    }

    printf("Number of clusters in file: %u\n", count);
    for (uint16_t i = 0; i < count; ++i)
        printf("%u  ", chain[i]);
    printf("\n");

    freeclu_chain(chain);

    close_fatsys(fatsys);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                173. Ders 20/10/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdi ilk cluster'ını bildiğimiz bir text dosyanın içeriğini yazdırmak isteyelim. Bunun için önce getclu_chain16 
    fonksiyonunu çağırırız. Sonra read_cluster fonksiyonu ile cluster'ları okuyup içini yazdırabiliriz. Ancak burada şöyle 
    bir sorun vardır: Dosyanın son cluster'ı tıka basa dolu değildir. Orada dosyaya dahil olmayan byte'lar da vardır. İşletim 
    sistemi dosyanın uzunluğunu elde edip son cluster'daki dosyaya dahil olmayan kısmı belirleyebilmektedir.

    Aşağıda ilk cluster'ı bilinen bir text dosyanın yazdırılmasına yönelik bir örnek verilmiştir. Burada dosyanın son cluster'ındaki
    dosyaya ait olmayan kısım da yazdırılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include "fatsys.h"

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    FATSYS *fatsys;
    unsigned char buf[8192];
    uint16_t count;
    uint16_t *chain;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fatsys = open_fatsys(argv[1])) == NULL)
        exit_sys("open_fatsys");

    if ((chain = getclu_chain16(fatsys, 4, &count)) == NULL) {
        fprintf(stderr, "cannot get cluster chain!...\n");
        exit(EXIT_FAILURE);
    }

    for (uint16_t i = 0; i < count; ++i) {
        if (read_cluster(fatsys, chain[i], buf) == -1)
            exit_sys("read_cluster");
        for (int i = 0; i < fatsys->clulen; ++i)
            putchar(buf[i]);
    }

    freeclu_chain(chain);
    close_fatsys(fatsys);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                174. Ders 25/10/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sisteminin dosya sistemi bize aslında cluster'larda olan dosya parçalarını "dosya" adı altında ardışıl byte 
    topluluğu gibi göstermektedir. Biz işletim sisteminin sistem fonksiyonu ile dosyayı açarız ve read fonksiyonu ile okumayı
    yaparız. Bütün diğer işlemler işletim sisteminin çekirdek kodları tarafından yapılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda 16 bit FAT için işlemler yaptık. Pekiyi 12 bit ve 32 bit FAT bölümü nasıldır? 32 bit FAT önemli bir farklılığa 
    sahip değildir. Her FAT elemanı 32 bit yani 4 byte uzunluktadır. Dolayısıyla daha büyük bir volüm için kullanılabilir. 
    16 bit FAT'te toplam 65536 FAT elemanı elemanı olabilir (Bazılarının kullanılmadığını da anımsayınız.) Bir cluster en fazla
    64 sektör uzunluğunda olabilmektedir. Bu durumda FAT16 sistemlerinde volümün maksimum uzunluğu 2^16 * 2^6 * 2^9 = 2GB.

    12 bit FAT'ler biraz daha karmaşık görünümdedir. 12 bit 8'in katı değildir ve 3 hex digitle temsil edilmektedir. Bu nedenle
    12 bit FAT'te FAT zinciri izlenirken dikkat edilmelidir. Eğer volüm küçükse (eskiden floppy diskler vardı ve onlar çok 
    küçüktü) FAT12 sistemi FAT tablosunun daha az yer kaplamasını sağlamaktadır.

    FAT12 sisteminde bir FAT elemanı 12 bit olduğu için FAT bölümünde en fazla 2^12 = 4096 FAT elemanı olabilir. Microsoft
    kendi format programında FAT12 volümlerinde bir cluster'ı maksimum 8 sektör olarak almaktadır. Bu durumda FAT12 volümü 
    maksimum 2^12 * 2^3 * 2^9 = 2^24 = 16MB olabilmektedir. Başka bir deyişle Microsoft 16MB'nin yukarısındaki volümleri FAT12
    olarak formatlamamaktadır.

    Aşağıda 12 bit FAT tablosunun baş kısmı görülmektedir:

    00000200  f8 ff ff 00 40 00 05 60  00 07 80 00 09 a0 00 0b  |....@..`........|
    00000210  c0 00 ff 0f 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000220  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000230  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000240  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000250  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000260  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000270  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    12 bit'in 3 hex digit yani 1.5 byte olduğuna dikkat ediniz. Buradaki 12 bit şöyle elde edilmektedir. Cluster numarası önce 1.5 
    ile çarpılır ve noktalı kısım atılır. (Bu işlem 3 ile çarpılıp 2'ye bölünme biçiminde yapılabilir.) Elde edilen offset'ten WORD 
    bilgi çekilir. Eğer cluster numarası çiftse yüksek anlamlı 4 bit atılır, eğer cluster numarası tek ise düşük anlamlı 4 bit atılır. 
    Yüksek anlamlı 4 bit'in atılması 0x0FFF ile "bit and" işlemi uygulanarak, düşük anlamlı 4 bit'in elde edilmesi sayının 4 kez sağa 
    ötelenerek yapılabilir. Örneğin yukarıdaki FAT bölümünde biz 4 numaralı cluster'ın değerini elde edecek olalım. 4 * 1.5 = 6'dır. 
    6'ıncı offset'ten WORD çekilirse 0x6005 değeri elde edilir. Yüksek anlamı 4 bit atıldığında ise 0x005 değeri elde edilecektir. 
    Şimdi 5 numaralı cluster'ın değerini elde etmek isteyelim. Bu durumda 5 * 1.5 = 7.5 olur. Noktadan sonraki kısım atılırsa 7 elde 
    edilir. 7'nci offset'ten WORD çekildiğinde 0x0060 değeri elde edilecektir. Bu değerin de düşük anlamlı 4 biti atıldığında 0x006 
    değeri elde edilir.

    12 bit FAT sisteminde bir FAT elemanın alabileceği değerler de şöyledir:

    000             Boş cluster
    001             Kullanılmıyor
    002 - FEF       Geçerli, sonraki cluster
    F0H - FF6       Reserved cluster
    FF7             Bozuk cluster, işletim sistemi bu cluster'a dosya parçası yerleştirmez
    FF8 - FFF       Son cluster

    12 bit FAT tablosunda ilk cluster değeri bilinen dosyanın cluster zincirlerini elde etmek için aşağıdaki gibi bir fonksiyon 
    yazılabilir.

    uint16_t *getclu_chain12(FATSYS *fatsys, uint32_t firstclu, uint16_t *count)
    {
        uint16_t clu, word, n;
        uint16_t *chain, *temp;
        uint32_t capacity;

        clu = firstclu;
        capacity = CHAIN_DEF_CAPACITY;
        n = 0;

        if ((chain = (uint16_t *)malloc(sizeof(uint16_t) * CHAIN_DEF_CAPACITY)) == NULL)
            return NULL;
        do {
            chain[n++] = clu;
            if (n == capacity) {
                capacity *= 2;
                if ((temp = realloc(chain, sizeof(uint16_t) * capacity )) == NULL) {
                    free(chain);
                    return NULL;
                }
                chain = temp;
            }
            word = *(uint16_t *)(fatsys->fat + clu * 3 / 2);
            clu = clu % 2 == 0 ? word & 0x0FFF : word >> 4;
        } while (clu < 0xFF8);
        *count = n;

        return chain;
    }

    Fonksiyonda 12 bit FAT değerinin elde edilmesi şöyle yapılmıştır:

    clu = clu % 2 == 0 ? word & 0x0FFF : word >> 4;
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                175. Ders 27/10/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT32 sisteminde her FAT elemanı 32 bittir. Ancak bu sistemde boot sektördeki BPB alanında da farklılıklar vardır. Bu nedenle
    32 bit FAT sistemi FAT12 ve FAT16 ile tam uyumlu değildir. FAT32 için bazı fonksiyonların yeniden yazılması gerekir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz FAT dosya sisteminin boot sektörünü, FAT ve Data bölümlerini ele aldık. Ele almadığımız tek bölüm "Root Dir" bölümüdür. 
    Şimdi "Root Dir" bölümü ve dosya bilgilerinin nasıl saklandığı konusu üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Microsoft'un FAT dosya sisteminde ve UNIX/Linux sistemlerinde kullanılan i-node tabanlı dosya sistemlerinde dizinler de 
    tamamen bir dosya gibi organize edilmektedir. Yani dizinler de aslında birer dosyadır. Bir dosyanın içerisinde o dosyanın 
    bilgileri bulunurken bir dizin dosyasının içerisinde o dizindeki dosyalara ilişkin bilgiler bulunmaktadır. Yani dizinler 
    aslında "o dizindeki dosyaların bilgilerini içeren dosyalar" gibidir. Bir dizin dosyası "dizin girişlerinden (directory 
    entry) oluşmaktadır. FAT12 ve FAT16 dosya sistemlerinde bir dizin dosyasındaki dizin girişleri 32 byte uzunluğundaydı. 
    Yani dizin dosyaları 32 byte'lık kayıtların peşi sıra gelmesiyle oluşuyordu. O zamanlarda DOS sistemlerinde bir dosyanın 
    ismi için en fazla 8 karakter, uzantısı için de en fazla 3 karakter kullanılabiliyordu. Dolayısıyla 32 byte'lık dizin 
    girişlerinin 1 byte'ı dosyanın ismi için ayrılmıştı. Sonra Microsoft dosya isimlerini 8+3 formatından çıkartarak onların 
    255'e kadar uzatılmasını sağladı. Ancak bunu yaparken de geçmişe doğru uyumu korumak için birden fazla 32 byte'lık dizin
    girişleri kullandı. Biz önce burada klasik 8+3'lük dizin girişlerinin formatını göreceğiz.

    32 byte'lık klasik dizin girişi formatı şöyledir:

    Offset (Hex)                    Uzunluk                     Anlamı

    00                              8 Byte                      Dosya İsmi (File Name)
    08                              3 Byte                      Dosya Uzantısı (Extension)
    0B                              BYTE                        Dosya Özelliği (Attribute)
    0C                              BYTE                        Kullanılmıyor (Reserved)
    0D                              BYTE                        Yaratılma Zamanının Milisaniyesi
    0E                              WORD                        Dosyanın Yaratılma Zamanı (Creation Time)
    10                              WORD                        Dosyanın Yaratılma Tarihi (Creation Date)
    12                              WORD                        Son Okunma Zamanı (Last Access Time)
    14                              WORD                        Kullanılmıyor (Reserved)
    16                              WORD                        Son Yazma Zamanı (Last Write Time)
    18                              WORD                        Son Yazma Tarihi (Last Write Date)
    1A                              WORD                        İlk Cluster Numarası (First Cluster)
    1C                              DWORD                       Dosyanın Uzunluğu (File Length)

    Aşağıda "x.txt" dosyasının ve "mydir" dizininin 32 byte'lık dizin girişleri görülmektedir.

    58 20 20 20 20 20 20 20  54 58 54 20 00 0b 5d 92  |X       TXT ..].|
    59 59 59 59 00 00 5d 92  59 59 0e 00 0f 00 00 00  |YYYY..].YY......|

    4d 59 44 49 52 20 20 20  20 20 20 10 00 7a f0 96  |MYDIR      ..z..|
    59 59 59 59 00 00 f0 96  59 59 10 00 00 00 00 00  |YYYY....YY......|

    - Dosya İsmi: 32'lik dizin girişlerinin ilk 8 byte'ı dosya isminden oluşmaktadır. Eğer dosya ismi 8 karakterden kısa 
    ise SPACE karakterleriyle (0x20) padding yapılmaktadır. Klasik FAT16 ve FAT12 sistemlerinde dosya isimlerinin ve uzantılarının
    büyük harf - küçük harf duyarlılığı yoktur. Tüm dosyalar bu sistemlerde "büyük harfe dönüştürülerek" dizin girişlerinde 
    tutulmaktadır.

    - Dosya Uzantısı: Dosya uzantısı en fazla 3 karakterden oluşmaktadır. Eğer 3 karakterden kısa ise SPACE karakterleriyle (0x20)
    padding yapılmaktadır.

    - Dosya Özelliği: Bu alanda dosyanın özelliklerine ilişkin bir bit alanı bulundurulmaktadır. Buradaki her bit'in bir 
    anlamı vardır. Özellik byte'ı aşağıdaki bitlerden oluşmaktadır:

    +------------+------------+------------+------------+------------+------------+------------+------------+
    |     7      |     6      |     5      |     4      |     3      |     2      |     1      |     0      |
    +------------+------------+------------+------------+------------+------------+------------+------------+
    |  Reserved  |  Reserved  |  Archive   |    Dir     |   VLabel   |   System   |   Hidden   |  ReadOnly  |
    +------------+------------+------------+------------+------------+------------+------------+------------+

    Eğer ReadOnly biti 1 ise dosya "read-only" biçimdedir. Böyle dosyalara işletim sistemi yazma yapmaz. Hidden biti 1 ise 
    dosya "dir" komutu uygulandığında görüntülenmez. DOS işletim sisteminin kendi dosyalarını System özelliği ile vurgulamaktadır. 
    Yani eğer bir dosya işletim sistemine ilişkin bir dosya ise System biti 1 olur.

    Volüm isimleri boot sektörün yanı sıra kök dizinde bir dosya ismi gibi de tutulmaktadır. Böyle girişlerin VLabel biti 
    1 olur. Eğer bir dizin söz konusu ise Dir biti 1 olmaktadır. FAT dosya sisteminde normal dosyalara "Archive" dosyaları 
    denilmektedir. Bu nedenle bu bit hemen her zaman 1 olarak görülür. Aşağıda "x.txt" ve "mydir" dizin girişlerine ilişkin 
    özellik byte'ının bitleri görülmektedir:

    x.txt (0x20)        0 0 1 0 0 0 0 0
    mydir (0x10)        0 0 0 1 0 0 0 0

    "x.txt" dosyasının özellik bitlerinden yalnızca Archive biti set edilmiştir. "mydir" dizinin de yalnızca "Dir" biti set 
    edilmiştir. İşletim sistemi bir dizin girişinin normal bir dosyaya mı yoksa bir dizin dosyasına mı ilişkin olduğunu özellik
    byte'ının 4 numaralı bitine bakarak tespit etmektedir.

    - Tarih ve Zaman Bilgileri FAT12 ve FAT16 dosya sistemlerinde 2 byte ile kodlanmaktadır. Eskiden DOS sistemlerinde dosyanın 
    yaratılma tarihi, zamanı ve son okunma tarihi tutulmazdı. Bu alanlar "reserved" durumdaydı. Sonra Microsoft bu alanları bu 
    amaçla kullanmaya başladı. Tarih bilgisi byte içerisinde bitsel düzeyde tutulmaktadır. Tarih bilgisinin tutuluş formatı
    şöyledir:

    15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
    y  y  y  y  y  y  y m m m m d d d d d 

    Burada WORD değerin düşük anlamlı 5 biti gün için, sonraki 4 biti ay için ve geri kalan 7 biti yıl için bulundurulmuştur. 
    Tarih bilgisinin yıl alanı için 7 bit ayrıldığına göre buraya nasıl 2024 gibi bir tarih yerleştirilebilmektedir. İşte DOS
    işletim sisteminin ilk versiyonu 1980 yılında oluşturulduğu için buradaki tarih bilgisi her zaman 1980 yılından itibaren 
    bir offset belirtmektedir. Yani örneğin 2024 yılı için buradaki yıl bitlerine 44 kodlanmaktadır. Örneğin bir dosyanın 32'lik
    dizin girişi şöyledir:

    58 20 20 20 20 20 20 20 54 58 54 20 18 AB 03 B3
    59 59 59 59 00 00 09 B3 59 59 06 00 1B 00 00 00

    Buradaki 0x18'inci offset'ten little endian formatta WORD çekersek 0x5959 değerini elde ederiz. Şimdi bu WORD değeri 2'lik
    sistemde ifade edelim:

    5         9       5       9
    0101    1001    0101    1001

    Şimdi de yukarıda belirttiğimiz gibi sayıyı bit'lerine ayrıştıralım:

    0101100 => 44    1010 => 10     11001 => 25
      yıl             ay             gün

    O halde buradaki tarih 25/10/2024'tür.

    16 bitle (WORD ile) zaman bilgisi de şöyle kodlanmıştır:

    15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
     h  h  h  h  h  m m m m m m s s s s s

    Burada bir noktaya dikkat ediniz: 0 ile 24 arasındaki saatler 5 bit ile tutulabilir. 0 ile 60 arasındaki dakikalar ise 
    ancak 6 bit ile tutulabilir. Burada geriye 5 bit almıştır. Dolayısıyla saniyeleri tutmak için bu 5 bit yeterli değildir. 
    İşte FAT dosya sistemini tasarlayanlar saniyedeki duyarlılığı azaltarak saniye değerinin yarısını buraya yazılması yoluna
    gitmişlerdir. Yani zaman bilgisinin saniye kısmı eski FAT12 ve FAT16 sistemlerinde tam duyarlılıkla tutulamamaktadır. 
    Örneğin yukarıdaki dizin girişinde dosyanın son değiştirilme zamanı için 0x16'ıncı offset'ten WORD çektiğimizde 0xB309
    değerini elde ederiz. Şimdi bu değeri 2'lik sisteme dönüştürelim:

     B       3       0       9
    1011    0011    0000    1001

    Şimdi de bit alanlarını ayrıştıralım:

    10110 => 22     011000 => 24    01001 => 9
      saat            dakika          saniye

    Burada işletim sistemi saniye alanına mevcut saniyenin yarısını yazdığına göre bu dosyanın değiştirilme zamanı 22:24:18
    olacaktır.

    Burada küçük bir noktaya dikkatinizi çekmek istiyoruz: Eskiden dizin girişinin 0x0D numaralı BYTE'ı da "reserved" durumdaydı
    sonra bu byte'a dosyanın yaratılma zamanına ilişkin milisaniye değeri yerleştirildi. Dolayısıyla artık dosyanın yaratılma 
    zamanı saniye duyarlılığında ifade edilebilmektedir. Bu durumda yaratılma zamanındaki saniye 2 ile çarpılıp buradaki 
    milisaniye ile toplanmaktadır. Tabii genel olarak Microsoft'un arayüzü dosyaların zaman bilgilerinin saniyelerini default
    durumda zaten göstermemektedir. Örneğin:

    D:\>dir
    Volume in drive D is YENI BIRIM
    Volume Serial Number is 2C68-EBFD

    Directory of D:\

    25.10.2024  22:24                27 x.txt
    25.10.2024  22:26                 8 con
    25.10.2024  22:26                59 y.txt
    25.10.2024  22:28    <DIR>          mydir
                   3 File(s)             94 bytes
                1 Dir(s)      52.194.304 bytes free

    - İlk Cluster Numarası: Biz daha önce FAT bölümünü incelerken bir dosyanın cluster zincirini elde edebilmek için onun 
    ilk cluster numarasının bilinmesi gerektiğini belirtmiştik. (Bir bağlı listeyi dolaşabilmek için onun ilk düğümünün yerinin
    bilinmesi gerektiğini anımsayınız.) İşte bir dosyanın ilk cluster numarası dizin girişinde saklanmaktadır. Yani işletim 
    sistemi önce dosyanın dizin girişini bulmakta sonra FAT'ten onun cluster zincirini elde etmektedir. Yukarıdaki dosyanın 
    dizin girişini yeniden veriyoruz:

    58 20 20 20 20 20 20 20 54 58 54 20 18 AB 03 B3
    59 59 59 59 00 00 09 B3 59 59 06 00 1B 00 00 00

    Burada söz konusu dosyanın ilk cluster numarası dizin girişinin 0x1A offsetinden başlayan WORD bilgidir. Bu bilgiyi örnek
    dizin girişinden çektiğimizde 0x006 değerini elde ederiz. Bu durumda bu dosyanın ilk cluster numarası 6'dır.

    - Dosyanın Uzunluğu: Dosyanın uzunluğu dizin girişindeki son 4 byte'lık (DWORD alan) alanda tutulmaktadır. İşletim sistemi
    dosyanın son cluster'ındaki geçerli byte sayısını bu uzunluktan yararlanarak elde etmektedir. Örneğin yukarıdaki dizin 
    girişine ilişkin dosya uzunluğu 0x0000001B = 27'dir. Dizin dosyalarına ilişkin uzunluklar için işletim sistemi hep 0 
    değerini yazmaktadır.

    Dizinler de bir dosya gibi ele alınmaktadır. Dolayısıyla dizinlerin de bir cluster zinciri vardır. Ancak FAT12 ve FAT16
    sistemlerinde kök dizinin yeri ve uzunluğu baştan bellidir. Kök dizin için bir cluster zinciri yoktur. FAT32 dosya sisteminde
    kök dizin de normal bir dizin gibi büyüyebilmektedir. Yani kök dizinin de bir cluster zinciri vardır.

    32'lik bir dizin girişini aşağıdaki gibi bir yapıyla temsil edebiliriz:

    #pragma pack(1)

    typedef struct tagDIR_ENTRY {
        unsigned char name[8];
        unsigned char ext[3];
        uint8_t attr;
        char reserved1[1];
        uint8_t crtime_ms;
        uint16_t crdate;
        uint16_t crtime;
        uint16_t rdtime;
        char reserved2[2];
        uint16_t wrtime;
        uint16_t wrdate;
        uint16_t fclu;
        uint32_t size;
    } DIR_ENTRY;

    #pragma pack()
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir dosya silindiğinde ne olur? İşletim sistemi FAT dosya sisteminde bir dosya silindiğinde iki işlem yapar:

    1) Dosyanın silindiğinin anlaşılması için dizin girişindeki dosya isminin ilk karakteri 0xE5 olarak değiştirir. Böylece 
    dizin girişlerini tararken 32'lik girişin ilk karakteri 0xE5 ise o dizin girişini silindiği gerekçesiyle atlamaktadır. 
    Ancak işletim sistemi bu 32'lik dizin girişinin diğer byte'larına dokunmamaktadır.

    2) İşletim sistemi dosyanın cluster zincirini de sıfırlamaktadır. Böylece bu dosyanın FAT'te kapladığı alan artık "boş" 
    gözükecektir. Ancak işletim sistemi dosyanın Data bölümündeki cluster'ları üzerinde herhangi bir işlem yapmaz.

    Pekiyi FAT dosya sisteminde "undelete" yapan programlar nasıl çalışmaktadır? İşte bu programlar dosyanın dizin girişine 
    bakıp onun ilk cluster'ının numarasını elde edip FAT bölümünde tersine bir algoritmayla onun cluster zincirini yeniden 
    oluşturmaya çalışmaktadır. Ancak böyle bir kurtarmanın garantisi yoktur. Çünkü işletim sistemi boşaltılmış cluster'ları 
    başka bir dosya için tahsis etmiş olabilir. Ya da FAT'teki cluster zincirini tahmin eden programlar bu konuda yanılabilmektedir. 
    Ancak ne olursa olsun dosyanın ilk karakteri silindiği için bu karakter kurtarma sırasında kullanıcıya sorulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                176. Ders 01/11/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    FAT12 ve FAT16 sistemlerinin orijinali yalnızca 8+3'lük dosya isimlerini destekliyordu. Yani bir dosyanın ismi en fazla 
    8 karakterden, uzantısı da en fazla 3 karakterden oluşabiliyordu. 90'lı yılların ortalarına doğru Microsoft FAT dosya 
    sisteminde uzun dosya isimlerinin de kullanılmasına olanak sağlamıştır. Microsoft bunu yaparken geçmişe doğru uyumu 
    mümkün olduğunca korumaya da çalışmıştır. Microsoft'un bu yeni düzenlemesinde 8+3'ten daha uzun dosya isimleri birden fazla
    32'lik girişle temsil edilmektedir. Ancak Microsoft geçmişe doğru uyumu korumak için her uzun dosya isminin bir de 8+3'lük
    kısa ismini oluşturmak istemiştir. Bu durumda uzun dosya isimlerinin kullanıldığı FAT sistemlerinde 8+3'lük alana sığmayan 
    dosya isimleri aşağıdaki formata göre dizin girişlerinde bulundurulmaktadır:

    <32'lik giriş>
    <32'lik giriş>
    ...
    <32'lik giriş>
    <dosyanın 8+3'lük kısa ismi>

    Tabii eğer istenirse (örneğin Linux böyle yapmaktadır) 8+3'lük sınıfı aşmayana dosyalar da sanki uzun isimli dosyalarmış gibi 
    saklanabilmektedir. Burada dosyanın 8+3'lük kısa isminin dışındaki uzun ismi de 32'lik girişlerde ASCII olarak değil, UNICODE
    olarak tutulmaktadır.

    Uzun dosya isimlerine ilişkin girişlerin sonunda 8+3'lük kısa bir girişin de bulundurulduğunu belirtmiştik. Peki bu uzun dosya 
    isminden kısa giriş nasıl elde edilmektedir?

    Uzun dosya isimlerinin tutulduğu 32'lik girişlerin ilk byte'ında önemli bilgiler vardır. Bu byte'a "sıra numarası (sequence 
    number)" denilmektedir. Bu byte bit bit anlamlandırılmaktadır. Byte'ın bitlerinin anlamları şöyledir:

    D L X X X X X X

    Burada en yüksek anlamlı bit olan D biti 32'lik girişin silinip silinmediğini anlatmaktadır. Eğer bu giriş silinmişse bu
    bit 1, silinmemişse 0 olacaktır. 7 numaralı bit (L biti) 32'lik girişlerin aşağıdan yukarıya doğru son giriş olup olmadığını 
    belirtmektedir. Geri kalan 6 bit 32'lik girişlerin sıra numarasını belirtir. Yani her 32'lik girişin bir sıra numarası vardır. 
    Her 32'lik giriş uzun dosya isminin 13 UNICODE karakterini tutmaktadır. Pekiyi biz 32'lik bir girişin eski kısa ismine ilişkin 
    32'lik bir giriş mi yoksa uzun ismin 32'lik girişlerinden biri mi olduğunu nasıl anlayabiliriz? İşte bunun için 32'lik 
    girişin 0x0B offset'inde bulunan özellik byte'ının düşük anlamlı 4 bitine bakmak gerekir. Eğer bu 4 bitin hepsi 1 ise 
    bu 32'lik giriş uzun dosya isminin 32'lik girişlerinden biridir.

    Aşağıda uzun dosya isimlerine ilişkin 32'lik girişlerin genel formatı verilmiştir. Ayrıntılı format için Microsoft'un 
    "FAT File System Specification" dokümanına başvurabilirsiniz.

    Field name        Offset    Size    Description
    LDIR_Ord        0        1        Sequence number (1-20) to identify where this entry is in the sequence of LFN entries to 
                                    compose an LFN. One indicates the top part of the LFN and any value with LAST_LONG_ENTRY 
                                    flag (0x40) indicates the last part of the LFN.
    LDIR_Name1        1        10        Part of LFN from 1st character to 5th character.
    LDIR_Attr        11        1        LFN attribute. Always ATTR_LONG_NAME and it indicates this is an LFN entry.
    LDIR_Type        12        1        Must be zero.
    LDIR_Chksum        13        1        Checksum of the SFN entry associated with this entry.
    LDIR_Name2        14        12        Part of LFN from 6th character to 11th character.
    LDIR_FstClusLO    26        2        Must be zero to avoid any wrong repair by old disk utility.
    LDIR_Name3        28        4        Part of LFN from 12th character to 13th character.

    Biz sonraki örneklerde uzun dosya isimlerini dikkate almayacağız. Onları geçeceğiz. Aşağıda kök uzun dosya isimlerinin 
    ve silinmiş dosya isimlerinin geçilerek kök dosya sistemindeki dosyaların listesini elde eden bir fonksiyon verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* fatsys.h */

#ifndef FATSYS_H_
#define FATSYS_H_

#include <stdint.h>

#define FILE_INFO_LENGTH        32
#define CHAIN_DEF_CAPACITY        8
#define ROOT_DEF_CAPACITY        8
#define DIR_ENTRY_SIZE            32

/* Type Declarations */

typedef struct tagBPB {
    uint16_t fatlen;        /* Number of sectors in FAT (A) */
    uint16_t rootlen;        /* Number of sectors in ROOT (NA) */
    uint16_t nfats;            /* Number of copies of FAT (A) */
    uint32_t tsects;        /* Total sector (A) */
    uint16_t bps;            /* Byte per sector(A) */
    uint16_t spc;            /* Sector per cluster(A) */
    uint16_t rsects;        /* Reserved sectors(A) */
    uint8_t mdes;            /* Media descriptor byte(A) */
    uint16_t spt;            /* Sector per track(A) */
    uint16_t rootents;        /* Root entry (A) */
    uint16_t nheads;        /* Number of heads (A) */
    uint16_t hsects;        /* Number of hidden sector( A) */
    uint16_t tph;            /* Track per head (NA) */
    uint16_t fatloc;        /* FAT directory location (NA) */
    uint16_t rootloc;        /* Root directory location (NA) */
    uint16_t dataloc;        /* First data sector location (NA) */
    uint32_t datalen;        /* Number of sectors in Data (NA) */
    uint32_t serial;        /* Volume Serial Number (A) */
    char vname[12];            /* Volume Name (A) */
} BPB;

typedef struct tagFATSYS {
    int fd;                    /* Volume file descriptor */
    BPB bpb;                /* BPB info */
    uint32_t fatoff;        /* Offset of FAT */
    uint32_t rootoff;        /* Offset of root directory */
    uint32_t dataoff;        /* Offset of DATA */
    uint32_t clulen;        /* Cluster length as bytes */
    uint8_t *fat;            /* FAT sectors */
    uint8_t *rootdir;        /* Root sectors */
    /* ... */
} FATSYS;

#pragma pack(1)

typedef struct tagDIR_ENTRY {
    unsigned char name[8];
    unsigned char ext[3];
    uint8_t attr;
    char reserved1[1];
    uint8_t crtime_ms;
    uint16_t crdate;
    uint16_t crtime;
    uint16_t rdtime;
    char reserved2[2];
    uint16_t wrtime;
    uint16_t wrdate;
    uint16_t fclu;
    uint32_t size;
} DIR_ENTRY;

#pragma pack()

/* Function prototypes */

int read_bpb(int fd, BPB *bpb);
FATSYS *open_fatsys(const char *path);
int close_fatsys(FATSYS *fatsys);
int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf);
int wite_cluster(FATSYS *fatsys, uint32_t clu, const void *buf);
uint16_t *getclu_chain16(FATSYS *fatsys, uint32_t firstclu, uint16_t *count);
uint16_t *getclu_chain12(FATSYS *fatsys, uint32_t firstclu, uint16_t *count);
void freeclu_chain(uint16_t *chain);
DIR_ENTRY *get_rootents(FATSYS *fatsys, uint16_t *count);

#endif

/* fatsys.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include "fatsys.h"

int read_bpb(int fd, BPB *bpb)
{
    uint8_t bsec[512];

    if (read(fd, bsec, 512) == -1)
        return -1;

    bpb->bps = *(uint16_t *)(bsec + 0x0B);
    bpb->spc = *(uint8_t *)(bsec + 0x0D);
    bpb->rsects = *(uint16_t *)(bsec + 0x0E);
    bpb->fatlen = *(uint16_t *)(bsec + 0x16);
    bpb->rootlen = *(uint16_t *)(bsec + 0x11) * FILE_INFO_LENGTH / bpb->bps;
    bpb->nfats = *(uint8_t *)(bsec + 0x10);
    if (*(uint16_t *)(bsec + 0x13))
        bpb->tsects = *(uint16_t *)(bsec + 0x13);
    else
        bpb->tsects = *(uint32_t *)(bsec + 0x20);
    bpb->mdes = *(bsec + 0x15);
    bpb->spt = *(uint16_t *)(bsec + 0x18);
    bpb->rootents = *(uint16_t *)(bsec + 0x11);
    bpb->nheads = *(uint16_t *)(bsec + 0x1A);
    bpb->hsects = *(uint16_t *)(bsec + 0x1C);
    bpb->tph = (uint16_t)(bpb->tsects / bpb->spt / bpb->nheads);
    bpb->fatloc = bpb->rsects;
    bpb->rootloc = bpb->rsects + bpb->fatlen *bpb->nfats;
    bpb->dataloc = bpb->rootloc + bpb->rootlen;
    bpb->datalen = bpb->tsects - bpb->dataloc;
    bpb->serial = *(uint32_t *)(bsec + 0x27);
    memcpy(bpb->vname, bsec + 0x2B, 11);
    bpb->vname[11] = '\0';

    return 0;
}

FATSYS *open_fatsys(const char *path)
{
    FATSYS *fatsys;
    int fd;

    if ((fatsys = (FATSYS *)malloc(sizeof(FATSYS))) == NULL)
        return NULL;

    if ((fd = open(path, O_RDWR)) == -1)
        goto EXIT1;

    if (read_bpb(fd, &fatsys->bpb) == -1)
        goto EXIT2;

    fatsys->fd = fd;
    fatsys->fatoff = fatsys->bpb.fatloc * fatsys->bpb.bps;
    fatsys->rootoff = fatsys->bpb.rootloc * fatsys->bpb.bps;
    fatsys->dataoff = fatsys->bpb.dataloc * fatsys->bpb.bps;
    fatsys->clulen = fatsys->bpb.bps * fatsys->bpb.spc;

    if ((fatsys->fat = (uint8_t *)malloc(fatsys->bpb.fatlen * fatsys->bpb.bps)) == NULL)
        goto EXIT2;

    if ((fatsys->rootdir = (uint8_t *)malloc(fatsys->bpb.rootlen * fatsys->bpb.bps)) == NULL)
        goto EXIT3;

    if (lseek(fatsys->fd, fatsys->fatoff, SEEK_SET) == -1)
        goto EXIT4;

    if (read(fd, fatsys->fat, fatsys->bpb.fatlen * fatsys->bpb.bps) == -1)
        goto EXIT4;

    if (lseek(fatsys->fd, fatsys->rootoff, SEEK_SET) == -1)
        goto EXIT4;

    if (read(fd, fatsys->rootdir, fatsys->bpb.rootlen * fatsys->bpb.bps) == -1)
        goto EXIT4;

    return fatsys;

EXIT4:
    free(fatsys->rootdir);
EXIT3:
    free(fatsys->fat);
EXIT2:
    close(fd);
EXIT1:
    free(fatsys);

    return NULL;
}

int close_fatsys(FATSYS *fatsys)
{
    free(fatsys->fat);
    if (close(fatsys->fd) == -1)
        return -1;
    free(fatsys);

    return 0;
}

int read_cluster(FATSYS *fatsys, uint32_t clu, void *buf)
{
    if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
        return -1;

    return read(fatsys->fd, buf, fatsys->clulen);
}

int write_cluster(FATSYS *fatsys, uint32_t clu, const void *buf)
{
    if (lseek(fatsys->fd, fatsys->dataoff + (clu - 2) * fatsys->clulen, SEEK_SET) == -1)
        return -1;

    return write(fatsys->fd, buf, fatsys->clulen);
}

uint16_t *getclu_chain16(FATSYS *fatsys, uint32_t firstclu, uint16_t *count)
{
    uint16_t clu, n;
    uint16_t *chain, *temp;
    uint32_t capacity;

    clu = firstclu;
    capacity = CHAIN_DEF_CAPACITY;
    n = 0;

    if ((chain = (uint16_t *)malloc(sizeof(uint16_t) * CHAIN_DEF_CAPACITY)) == NULL)
        return NULL;
    do {
        chain[n++] = clu;
        if (n == capacity) {
            capacity *= 2;
            if ((temp = realloc(chain, sizeof(uint16_t) * capacity )) == NULL) {
                free(chain);
                return NULL;
            }
            chain = temp;
        }
        clu = *(uint16_t *)(fatsys->fat + clu * 2);
    } while (clu < 0xFFF8);
    *count = n;

    return chain;
}

uint16_t *getclu_chain12(FATSYS *fatsys, uint32_t firstclu, uint16_t *count)
{
    uint16_t clu, word, n;
    uint16_t *chain, *temp;
    uint32_t capacity;

    clu = firstclu;
    capacity = CHAIN_DEF_CAPACITY;
    n = 0;

    if ((chain = (uint16_t *)malloc(sizeof(uint16_t) * CHAIN_DEF_CAPACITY)) == NULL)
        return NULL;
    do {
        chain[n++] = clu;
        if (n == capacity) {
            capacity *= 2;
            if ((temp = realloc(chain, sizeof(uint16_t) * capacity )) == NULL) {
                free(chain);
                return NULL;
            }
            chain = temp;
        }
        word = *(uint16_t *)(fatsys->fat + clu * 3 / 2);
        clu = clu % 2 == 0 ? word & 0x0FFF : word >> 4;
    } while (clu < 0xFF8);
    *count = n;

    return chain;
}

void freeclu_chain(uint16_t *chain)
{
    free(chain);
}

DIR_ENTRY *get_rootents(FATSYS *fatsys, uint16_t *count)
{
    DIR_ENTRY *dent, *temp;
    DIR_ENTRY *dents;
    uint32_t capacity;
    uint16_t n;

    if ((dents = (DIR_ENTRY *)malloc(DIR_ENTRY_SIZE * ROOT_DEF_CAPACITY)) == NULL)
        return NULL;

    n = 0;
    capacity = ROOT_DEF_CAPACITY;
    dent = (DIR_ENTRY *)fatsys->rootdir;
    for (uint16_t i = 0; i < fatsys->bpb.rootents; ++i) {
        if (dent[i].name[0] == 0)
            break;
        if (dent[i].name[0] == 0xE5 || (dent[i].attr & 0XF) == 0x0F)
            continue;

        if (n == capacity) {
            capacity *= 2;
            if ((temp = realloc(dents, DIR_ENTRY_SIZE * capacity )) == NULL) {
                free(dents);
                return NULL;
            }
            dents = temp;
        }
        dents[n++] = dent[i];
    }
    *count = n;

    return dents;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <unistd.h>
#include <fcntl.h>
#include "fatsys.h"

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    FATSYS *fatsys;
    uint16_t count;
    uint16_t *chain;
    DIR_ENTRY *dents;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fatsys = open_fatsys(argv[1])) == NULL)
        exit_sys("open_fatsys");

    if ((dents = get_rootents(fatsys, &count)) == NULL) {
        fprintf(stderr, "cannot get root entries!...\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < count; ++i) {
        for (int k = 0; k < 8; ++k)
            if (dents[i].name[k] != ' ')
                putchar(dents[i].name[k]);

        if (dents[i].ext[0] != ' ')
                putchar('.');
        for (int k = 0; k < 3; ++k)
            if (dents[i].ext[k] != ' ')
                putchar(dents[i].ext[k]);

        putchar('\n');
    }

    close_fatsys(fatsys);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                177. Ders 03/11/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sistemi bir dizin dosyası içerisindeki 32'lik girişlerini gözden geçirirken dosya isminin ilk karakterini '\0' 
    karakter olarak gördüğünde (yani sayısal 0 değeri) işlemini sonlandırmaktadır. Yani dizin dosyası içerisindeki bütün 
    girişlerin gözden geçirilmesine gerek yoktur. Yukarıda da belirttiğimiz gibi dosya isminin ilk karakteri 0xE5 ise işletim 
    sistemi bu 32'lik girişi de silinmiş dosya olduğu gerekçesiyle geçmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sistemlerinde bir yol ifadesi verildiğinde o yol ifadesinin hedefindeki dosya ya da dizine ilişkin dizin girişinin 
    elde edilmesine "yol ifadelerinin çözümlenmesi (pathname resolution)" denilmektedir. Yol ifadelerinin çözümlenmesi eğer 
    yol ifadesi mutlaksa kök dizinden itibaren, göreli ise prosesin çalışma dizininden itibaren yapılmaktadır. Örneğin FAT 
    dosya sistemine ilişkin "\a\b\c\d.dat" biçiminde bir yol ifadesi verilmiş olsun. Burada hedeflenen "d.dat" dosyasına ilişkin 
    dizin girişi bilgileridir. Ancak bunun için önce kök dizinde "a" girişi, sonra "a" dizininde "b" girişi, sonra "b" dizininde 
    "c" girişi sonra da "c" girişinde "d.dat" girişi bulunmalıdır. Tabii biz burada Windows'taki bir yol ifadesini temel aldık. 
    UNIX/Linux sistemlerinde dosya sistemleri mount edildiği için bu yol ifadesi aslında mount noktasına görelidir.

    İşletim sistemleri bir yol ifadesini çözümlerken yol ifadesindeki tüm yol bileşenlerine ilişkin dizin giriş bilgilerini de 
    bir cache sisteminde saklamaktadır. İşletim sistemlerinin oluşturduğu bu cache sistemine "directory entry cache" ya da kısaca 
    "dentry cache" denilmektedir. Örneğin programcı aşağıdaki gibi bir yol ifadesi kullanmış olsun:

    "\a\b\c\d.dat"

    İşletim sistemi buradaki "a", "b", "c" ve "d.dat" dosyalarına ilişkin dizin giriş bilgilerini bir cache sisteminde saklamaktadır. 
    Böylece benzer yol ifadeleri için hiç disk okuması yapılmadan bu cache sisteminden bu bilgiler elde edilebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi FAT dosya sistemi için yol ifadelerini çözen basit yalın bir kodu nasıl yazabiliriz? Bizim bir yol ifadesi verildiğinde 
    o yol ifadesini parse edip oradaki yol bileşenlerini elde edebilmemiz gerekir. Sonra dizinler bir dosya olduğuna göre dizinlere 
    ilişkin cluster zincirinde diğer bileşenin aranması gerekir. İşlemler böyle devam ettirilir. FAT dosya sistemi için yol 
    ifadesini çözümleyen bir fonksiyonun parametrik yapısı şöyle olabilir:

    int resolve_path(FATSYS *fatsys, const char *path, DIRECTORY_ENTRY *de);

    Biz mutlak yol ifadelerini çözümleyecek olalım. Her dizinin bir cluster zinciri vardır. Ancak FAT12 ve FAT16 sistemlerinde 
    kök dizinin bir cluster zinciri yoktur. Kök dizinin yeri ve uzunluğu baştan bellidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                178. Ders 08/11/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde i-node tabanlı dosya sistemleri kullanılmaktadır. i-node tabanlı dosya sistemlerinin temel 
    organizasyonu FAT dosya sistemlerinden oldukça farklıdır. i-node tabanlı dosya sistemlerinin çeşitli varyasyonu vardır. 
    Linux sistemleri ve BSD sistemleri ağırlıklı olarak "ext (extended file system)" denilen dosya sistemini kullanmaktadır.
    "ext" dosya sistemi ilk kez 1992 yılında tasarlanmıştır. Sonra zaman içerisinde bu dosya sisteminin ext2, ext3 ve ext4 biçiminde 
    çeşitli varyasyonları oluşturulmuştur. Bugün artık genellikle bu ailenin son üyesi olan ext4 dosya sistemi kullanılmaktadır. 
    Ancak yukarıda da belirttiğimiz gibi i-node tabanlı dosya sistemleri bir aile belirtmektedir. Bu ailenin FAT sistemlerinde 
    olduğu gibi genel tasarımı birbirine benzerdir. Biz burada ext dosya sisteminin en uzun süre kullanılan versiyonu olan 
    ext konusunda temel bilgiler vereceğiz. ext2 dosya sisteminin resmi dokümantasyonuna aşağıdaki bağlantıdan erişebilirsiniz:

    https://cscie28.dce.harvard.edu/lectures/lect04/6_Extras/ext2-struct.html
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    ext2 dosya sistemi üzerinde incelemeler ve denemeler yapmak için yine loop aygıtlarından faydalanabilirsiniz. Bunun için 
    yine önce içi sıfırlarla dolu bir dosya oluşturulur:

    $ dd if=/dev/zero of=ext2.dat bs=512 count=400000

    Sonra loop aygıt sürücüsü bu dosya için hazırlanır:

    $ sudo losetup /dev/loop0 ext2.dat

    Artık aygıt formatlanabilir:

    $ mkfs.ext2 /dev/loop0

    Mount işlemi aşağıdaki gibi yapılabilir:

    $ mkdir ext2
    $ sudo /dev/loop0 ext2
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    i-node tabanlı dosya sistemlerinde volüm kabaca aşağıdaki bölümlere ayrılmaktadır:

    <boot block>>
    <super block>
    <i-node block>
    <data block>

    Boot blok (boot block) işletim sistemini boot eden kodların bulunduğu bloktur. Süper blok (super block) FAT dosya sistemlerindeki 
    boot sektör BPB alanına benzemektedir. Yani burada dosya sistemine ilişkin metadata bilgiler bulunmaktadır. i-node blok 
    i-node elemanlarından oluşmaktadır. Data blok (data block= FAT dosya sistemindeki Data bölümü gibidir. FAT dosya sistemindeki 
    "cluster" yerine i-node tabanlı dosya sistemlerinde "blok (block)" terimi kullanılmaktadır. Bir blok bir dosyanın parçası olabilecek 
    en küçük birimdir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Süper blok hemen volümün 1024 byte offset'inde bulunmaktadır. (Yani volümün başında boot sektör programları için 1024 
    byte yer ayrılmıştır.) Süper blok süper blokta belirtilen blok uzunluğu kadar uzunluğa sahiptir. (Ayrıca izleyen paragraflarda 
    da görüleceği gibi ext2 dosya sisteminde her blok grupta süper bloğun bir kopyası da bulunmaktadır.) Yukarıda da belirttiğimiz 
    gibi burada volüm hakkında metadata bilgileri bulunmaktadır. Buradaki alanlar ext2 dokümantasyonunda ayrıntılarıyla açıklanmıştır. 
    Süper blok içerisindeki alanlar aşağıdaki gibidir:

    +-----------------------+-----+-------------------------------------------------------------------------------------------+
    |          Alan         |Boyut|                                         Açıklama                                          |
    |                       |Byte |                                                                                           |
    +-----------------------+-----+-------------------------------------------------------------------------------------------+
    | s_inodes_count        |  4  | Dosya sistemindeki toplam inode sayısı.                                                   |
    | s_blocks_count        |  4  | Dosya sistemindeki toplam blok sayısı.                                                    |
    | s_r_blocks_count      |  4  | Rezerve edilmiş blok sayısı.                                                              |
    | s_free_blocks_count   |  4  | Boş blok sayısı.                                                                          |
    | s_free_inodes_count   |  4  | Boş inode sayısı.                                                                         |
    | s_first_data_block    |  4  | İlk veri bloğunun numarası (bu, kök dizinin bulunduğu blok).                              |
    | s_log_block_size      |  4  | Blok boyutunun logaritmasının değeri (örneğin, 1 KB için 10, 4 KB için 12, vs.).          |
    | s_log_frag_size       |  4  | Parçacık boyutunun logaritması.                                                           |
    | s_blocks_per_group    |  4  | Her blok grubundaki blok sayısı.                                                          |
    | s_frags_per_group     |  4  | Her blok grubundaki fragman sayısı.                                                       |
    | s_inodes_per_group    |  4  | Her blok grubundaki inode sayısı.                                                         |
    | s_mtime               |  4  | Dosya sisteminin son değiştirilme zamanı (Unix zaman damgası).                            |
    | s_wtime               |  4  | Dosya sisteminin son yazılma zamanı (Unix zaman damgası).                                 |
    | s_mnt_count           |  2  | Dosya sisteminin kaç kez bağlandığı (mount) sayısı.                                       |
    | s_max_mnt_count       |  2  | Dosya sisteminin kaç kez daha bağlanabileceği (yani, montaj sayısı aşımı).                |
    | s_magic               |  2  | Süper blok sihirli sayısı (bu, EXT2 dosya sistemini tanımlar ve genellikle `0xEF53`'tür). |
    | s_state               |  2  | Dosya sisteminin durumu (örneğin, temiz mi, hata mı).                                     |
    | s_errors              |  2  | Hata durumunda yapılacak işlem (örneğin, “ignore”, “panic”, vb.).                         |
    | s_minor_rev_level     |  2  | Küçük revizyon seviyesi (EXT2’yi güncelleyen küçük değişiklikler için).                   |
    | s_lastcheck           |  4  | Dosya sisteminin son kontrol tarihi (Unix zaman damgası).                                 |
    | s_checkinterval       |  4  | Dosya sisteminin kontrol edilmesi gereken süre (saniye cinsinden).                        |
    | s_creator_os          |  4  | Dosya sistemini oluşturan işletim sistemi türü (örneğin, Linux, Solaris, vb.).            |
    | s_rev_level           |  4  | EXT2 dosya sistemi revizyon seviyesi.                                                     |
    | s_def_resuid          |  2  | Varsayılan rezerv kullanıcı ID'si (uid).                                                  |
    | s_def_resgid          |  2  | Varsayılan rezerv grup ID'si (gid).                                                       |
    | s_first_ino           |  4  | İlk inode numarası (genellikle kök dizini için).                                          |
    | s_inode_size          |  2  | Inode boyutu (genellikle 128 veya 256 byte).                                              |
    | s_block_group_nr      |  2  | Bu süper blok ile ilişkili blok grubu numarası.                                           |
    | s_feature_compat      |  4  | Uyumluluk özelliklerinin bit maskesi.                                                     |
    | s_feature_incompat    |  4  | Uyumsuz özelliklerin bit maskesi.                                                         |
    | s_feature_ro_compat   |  4  | Okuma-yazma uyumsuz özelliklerinin bit maskesi.                                           |
    | s_uuid                |  16 | Dosya sisteminin benzersiz tanımlayıcısı (UUID).                                          |
    | s_volume_name         |  16 | Dosya sistemi adının (etiketinin) olduğu alan.                                            |
    | s_last_mounted        |  64 | Dosya sisteminin son bağlandığı dizin yolu.                                               |
    | s_algorithm_usage_bmp |  4  | Bloklar ve inode'lar için kullanılan algoritmaların bit maskesi.                          |
    | s_prealloc_blocks     |  1  | Önceden tahsis edilecek blok sayısı.                                                      |
    | s_prealloc_dir_blocks |  1  | Önceden tahsis edilecek dizin blokları sayısı.                                            |
    | s_padding             | 118 | Alanın sonundaki boşluk (süper bloğun uzunluğunu tamamlar).                               |
    +-----------------------+-----+-------------------------------------------------------------------------------------------+

    Buradaki önemli alanlar hakkında kısa bazı açıklamalar yapmak istiyoruz:

    s_inodes_count: Bu alanda dosya sistemindeki toplam i-node elemanlarının sayısı bulunmaktadır. Bir ext2 disk bölümünde en 
    fazla buradaki i-node elemanlarının sayısı kadar farklı dosya bulunabilir.

    s_blocks_count: Burada Data bölümündeki toplam blokların sayısı bulunmaktadır.

    s_r_blocks_count: Burada ayrılmış (reserve edilmiş) blokların sayısı bulunmaktadır.

    s_free_blocks_count: Burada Data bölümünde kullanılmayan boş blokların sayısı tutulmaktadır.

    s_log_block_size: Burada 1024 değerinin 2 üzeri kaçla çarpılacağını belirten değer tutulmaktadır. Yani blok uzunluğu 
    1024 << s_log_block_siz biçiminde hesaplanmaktadır. Örneğin burada 2 değeri yazılıyorsa blok uzunluğu 2^2 * 1024 = 4096 byte'tır.

    s_inode_size: Burada bir i-node elemanının kaç byte olduğu bilgisi yer almaktadır. Örnek dosya sistemimizde i-node elemanları 
    256 byte uzunluğundadır.

    ext2 dosya sisteminin süper blok bilgisi ve bazı önemli alanlarına ilişkin bilgiler "dumpe2fs" isimli utility programla 
    elde edilebilir. Örneğin:

    $ dumpe2fs /dev/loop0

    Aşağıda bir ext2 süper bloğunun örnek bir içeriği verilmektedir:

    00004000  60 c3 00 00 50 c3 00 00  c4 09 00 00 f4 b6 00 00  |`...P...........|
    00000410  55 c3 00 00 00 00 00 00  02 00 00 00 02 00 00 00  |U...............|
    00000420  00 80 00 00 00 80 00 00  b0 61 00 00 51 5c 2e 67  |.........a..Q\.g|
    00000430  51 5c 2e 67 01 00 ff ff  53 ef 00 00 01 00 00 00  |Q\.g....S.......|
    00000440  42 5c 2e 67 00 00 00 00  00 00 00 00 01 00 00 00  |B\.g............|
    00000450  00 00 00 00 0b 00 00 00  00 01 00 00 38 00 00 00  |............8...|
    00000460  02 00 00 00 03 00 00 00  ec 89 02 3e a8 11 4c 01  |...........>..L.|
    00000470  b0 b5 f5 48 1e 30 79 d6  00 00 00 00 00 00 00 00  |...H.0y.........|
    00000480  00 00 00 00 00 00 00 00  2f 68 6f 6d 65 2f 6b 61  |......../home/ka|
    00000490  61 6e 2f 53 74 75 64 79  2f 55 6e 69 78 4c 69 6e  |an/Study/UnixLin|
    000004a0  75 78 2d 53 79 73 50 72  6f 67 2f 44 69 73 6b 49  |ux-SysProg/DiskI|
    000004b0  4f 2d 46 69 6c 65 53 79  73 74 65 6d 73 2f 65 78  |O-FileSystems/ex|
    000004c0  74 32 00 00 00 00 00 00  00 00 00 00 00 00 0c 00  |t2..............|
    000004d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000004e0  00 00 00 00 00 00 00 00  00 00 00 00 6e 47 e8 bc  |............nG..|
    000004f0  81 50 45 f3 bb 96 6c 7c  51 bc e3 8a 01 00 00 00  |.PE...l|Q.......|
    00000500  0c 00 00 00 00 00 00 00  42 5c 2e 67 00 00 00 00  |........B\.g....|

    Burada toplam i-node elemanlarının sayısı 0xC360 (50016) tanedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Disk bölümünün i-node bloğu i-node elemanlarından oluşmaktadır. Her i-node elemanının ilki 0 olmak üzere bir indeks numarası 
    vardır. Örneğin:

    0       i-node elemanı
    1       i-node elemanı
    2       i-node elemanı
    3       i-node elemanı
    4       i-node elemanı
    ...
    300     i-node elemanı
    301     i-node elemanı
    302     i-node elemanı
    303     i-node elemanı
    304     i-node elemanı
    ...

    Bir dosyanın ismi haricindeki bütün bilgileri dosyaya ilişkin i-node elemanında tutulmaktadır. Zaten stat fonksiyonları 
    da aslında bilgileri bu i-node elemanından almaktadır. Her dosyanın diğerlerinden farklı bir i-node numarası olduğuna 
    dikkat ediniz. Dolayısıyla dosyanın i-node numarası o dosyayı karakterize etmektedir. ("ls" komutunda dosyanın i-node 
    numaralarının -i seçeneği ile elde edildiğini anımsayınız.) Burada hatırlatma yapmak amacıyla stat yapısını yeniden vermek 
    istiyoruz:

    struct stat {
        dev_t     st_dev;     /* ID of device containing file */
        ino_t     st_ino;     /* inode number */
        mode_t    st_mode;    /* protection */
        nlink_t   st_nlink;   /* number of hard links */
        uid_t     st_uid;     /* user ID of owner */
        gid_t     st_gid;     /* group ID of owner */
        dev_t     st_rdev;    /* device ID (if special file) */
        off_t     st_size;    /* total size, in bytes */
        blksize_t st_blksize; /* blocksize for file system I/O */
        blkcnt_t  st_blocks;  /* number of 512B blocks allocated */
        time_t    st_atime;   /* time of last access */
        time_t    st_mtime;   /* time of last modification */
        time_t    st_ctime;   /* time of last status change */
    };

    ext2 dosya sisteminde bir i-node elemanının alanları aşağıdaki gibidir:

    +-------------+------------+----------------------------------------------------------------------------------------------+
    |    Alan     |Boyut (Byte)|                                           Açıklama                                           |
    +-------------+------------+----------------------------------------------------------------------------------------------+
    |i_mode       |     2      | Dosya türü ve izinler (örneğin, `S_IFREG` (normal dosya), `S_IFDIR` (dizin), vs.).           |
    |i_uid        |     2      | Dosya sahibinin kullanıcı kimliği (UID).                                                     |
    |i_size_lo    |     4      | Dosyanın boyutunun alt 32 biti (byte cinsinden).                                             |
    |i_atime      |     4      | Son erişim zamanı (Unix zaman damgası).                                                      |
    |i_ctime      |     4      | Son inode değişiklik zamanı (Unix zaman damgası).                                            |
    |i_mtime      |     4      | Son değişiklik (modifikasyon) zamanı (Unix zaman damgası).                                   |
    |i_dtime      |     4      | Dosyanın silinme zamanı (Unix zaman damgası), eğer geçerliyse.                               |
    |i_gid        |     2      | Dosya sahibinin grup kimliği (GID).                                                          |
    |i_links_count|     2      | Dosyaya bağlı olan hard link (bağlantı) sayısı.                                              |
    |i_blocks     |     4      | Dosyanın disk üzerinde kullandığı blok sayısı (block, 512 byte'lık bloklar).                 |
    |i_flags      |     4      | Dosya bayrakları (örneğin, `i_dirty`, `i_reserved` gibi).                                    |
    |i_osd1       |     4      | Linux spesifik alan (genellikle genişletilmiş özellikler için kullanılır).                   |
    |i_block[15]  | 4 × 15 = 60| Dosyanın bloklarına işaretçi                                                                 |
    |i_generation |     4      | Dosyanın versiyon numarası (özellikle NFS gibi ağ dosya sistemlerinde kullanılır).           |
    |i_file_acl   |     4      | Dosya için ACL (Access Control List) blok numarası.                                          |
    |i_dir_acl    |     4      | Dizin için ACL blok numarası.                                                                |
    |i_faddr      |     4      | Dosyanın "fragman adresi" (bu, çoğu zaman sıfırdır ve eski EXT2 uygulamalarında kullanılır). |
    +-------------+------------+----------------------------------------------------------------------------------------------+

    Biz bu alanların büyük çoğunluğunu aslında stat fonksiyonunda görmüştük. Ancak stat yapısında olmayan bazı elemanlar da 
    burada bulunmaktadır. Biz stat yapısında olmayan bazı önemli elemanlar üzerinde durmak istiyoruz:

    i_dtime: Bu alanda eğer dosya silinmişse dosyanın ne zaman silindiğine yönelik tarih zaman bilgisi tutulmaktadır. Buradaki
    değer 01/01/1970'ten itibaren geçen saniye sayısı cinsindendir.

    i_block ve i_blocks: Bu elemanlar izleyen paragraflarda daha ayrıntılı bir biçimde ele alınacaktır.

    i_flags: Bu alanda ilgili dosyaya ilişkin bazı bayraklar tutulmaktadır.

    i_file_acl: Dosyaya ilişkin "erişim kontrol listesi (access control list)" ile ilgili bilgiler tutulmaktadır.

    i-node elemanında dosyanın isminin tutulmadığına dikkat ediniz. ext2 dosya sisteminde bir i-node elemanının uzunluğu süper
    bloğun s_inode_size elemanında yazmaktadır. Örnek sistemimizde i-node elemanları 256 byte uzunluktadır.

    Pekiyi dosyanın ismi nerededir ve dosyanın i-node numarası nereden elde edilmektedir? Bunu izleyen paragraflarda göreceğiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                179. Ders 10/11/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda i-node tabanlı bir disk bölümünün kaba organizasyonunun aşağıdaki gibi olduğunu belirtmiştik:

    <boot block>                    (1024 byte)
    <super block>
    <i-node block>
    <data block>

    Burada sanki süper bloktan hemen sonra i-node blok geliyormuş gibi biz organizasyon resmedilmiştir. Halbuki süper bloktan
    hemen sonra i-node blok gelmemektedir. ext2 dosya sisteminin gerçek yerleşimi aşağıdaki gibidir:

    <boot block>                      (1024 byte)
    <block group>
    <block group>
    <block group>

    Bir disk bölümü aslında blok gruplarından (block groups) oluşmaktadır. Her blok grubu disk bölümüne ilişkin bir bölümü belirtir. 
    Bir blok grubu aşağıdaki gibi bir yapıya sahiptir:

    <super block>
    <block group descriptor table>
    <block bitmap>
    <i-node bitmap>
    <i-node table>
    <data block>

    İşte "blok grup betimleyici tablosu (block group descriptor table)" blok grupları hakkında bilgi veren bir bölümdür. Bir 
    kaç blok bilginin yer aldığı süper bloğun "s_blocks_per_group" elemanında saklanmaktadır. Her blok grupta belli sayıda 
    i-node elemanı vardır. Bir blok gruptaki i-node elemanlarının sayısı süper bloktaki s_inodes_per_group elemanıyla 
    belirtilmektedir. Yani aslında ext2 dosya sisteminde aşağıdaki gibi bir organizasyon söz konusudur:

    <boot block>

    <super block>
    <block group desciptor table>     (1024 byte)
    <block bitmap>                    (1024 byte)
    <i-node bitmap>                   (1024 byte)
    <i-node table>
    <data block>

    <super block>
    <block group desciptor table>     (1024 byte)
    <block bitmap>                    (1024 byte)
    <i-node bitmap >                  (1024 byte)
    <i-node table>
    <data block>

    <super block>
    <block group desciptor table>     (1024 byte)
    <block bitmap>                    (1024 byte)
    <i-node bitmap >                  (1024 byte)
    <i-node table>
    <data block>
    ...

    Görüldüğü gibi ext2 dosya sisteminde süper bloğun tek bir kopyası yoktur. Her blok grupta süper blok yeniden yer 
    almaktadır. Bir blok grupta ayrı bir i-node tablosunun ve data bölümünün olduğuna dikkat ediniz.

    Pekiyi neden ext2 dosya sisteminde disk bölümü birden fazla blok gruplara ayrılmıştır? İşte bunun nedenlerinden biri 
    güvenliktir. Yani i-node bloklardan biri bozulduğunda diğeri bozulmamış biçimde kalabilir.

    Blok gruplarındaki "blok grup betimleyici tablosu (block group descriptor table)" blok grupları hakkında bazı metadata 
    bilgileri tutmaktadır. Ancak blok grup betimleyicilerinde yalnızca o blok grubuna ilişkin bilgiler değil, tüm blok gruplarına 
    ilişkin bilgiler tutulmaktadır. Yani her blok grubunda yeniden tüm blok gruplarına ilişkin bilgiler tutulmaktadır. 
    Blok grup betimleyici tablosu blok grup betimleyicilerinden oluşan bir dizi gibidir:

    Blok Grup Betimleyici Tablosu

    <block group descriptor>
    <block group descriptor>
    <block group descriptor>
    ...
    <block group descriptor>
    <block group descriptor>

    Bir blok grup betimleyicisinin alanları şöyledir:

    +----------------------+-------------+-----------------------------------------+
    |     Yapı Elemanı     | Boyut (Byte)|                Açıklama                 |
    +----------------------+-------------+-----------------------------------------+
    | bg_block_bitmap      |      4      | Blok haritasının başlangıç adresi       |
    | bg_inode_bitmap      |      4      | Inode haritasının başlangıç adresi      |
    | bg_inode_table       |      4      | Inode tablosunun başlangıç adresi       |
    | bg_free_blocks_count |      2      | Blok grubunda serbest blok sayısı       |
    | bg_free_inodes_count |      2      | Blok grubunda serbest inode sayısı      |
    | bg_used_dirs_count   |      2      | Blok grubundaki kullanılan dizin sayısı |
    | bg_flags             |      2      | Blok grubunun bayrakları (flags)        |
    | bg_reserved          |     12      | Rezerv alan (genellikle sıfırdır)       |
    +----------------------+-------------+-----------------------------------------+

    Blok grup betimleyicisi toplamda 32 byte yer kaplamaktadır. Her blok grubunda blok bitmap'in, i-node bitmap'in ve i-node 
    tablosunun yerinin blok numarası tutulmaktadır. Buradaki blok uzunlukları disk bölümünün başından itibaren yer belirtir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Disk bölümü içerisindeki blokların numaralandırılması ile ilgili ince bir nokta vardır. Eğer disk bölümündeki blok uzunluğu
    1K yani 1024 byte ise boot blok 0'ıncı bloktadır. Dolayısıyla ilk blok grubundaki süper blok 1'inci bloktadır. Ancak 
    blok büyüklüğü 1024'ten (yani 1K'dan) fazla ise bu durumda boot blok ile süper blok tek blok kabul edilmektedir. Boot blok 
    ile süper bloğun bulunduğu ilk bloğun numarası 0'dır.

    İlk blok grup betimleyici tablosunun yeri de blok grubundaki süper bloktan hemen sonradır. Örneğin dosya sistemindeki 
    blok uzunluğu 4K (4096 byte) ise ilk blok betimleyici tablosunun yeri 4096'ıncı = 0x1000 offset'indedir. (Bu durumda boot blok
    ile süper bloğun 0 numaralı blok biçiminde tek blok olarak ele alındığını anımsayınız.) Bir blok grubunun toplam kapladığı 
    blok sayısı süper blok içerisindeki s_blocks_per_group elemanında tutulmaktadır. Örneğin biz k numaralı blok grubun blok 
    numarasını k * s_blocks_per_group işlemiyle elde edebiliriz.

    Aşağıda örnek bir blok grup betimleyici tablosu verilmiştir:

    00001000  0e 00 00 00 0f 00 00 00  10 00 00 00 c7 79 a4 61  |.............y.a|
    00001010  02 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00001020  0e 80 00 00 0f 80 00 00  10 80 00 00 25 3d b0 61  |............%=.a|
    00001030  00 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00001040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    ...

    Bir blok grup betimleyicisi 32 byte uzunluktadır. Burada toplam iki blok grup betimleyicisi yani disk bölümünde toplam 
    iki blok grubu bulunmaktadır. Bu iki blok grup betimleyicisini ayrı ayrı aşağıda veriyoruz:

    00001000  0e 00 00 00 0f 00 00 00  10 00 00 00 c7 79 a4 61  |.............y.a|
    00001010  02 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    00001020  0e 80 00 00 0f 80 00 00  10 80 00 00 25 3d b0 61  |............%=.a|
    00001030  00 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Disk bölümünde toplam kaç blok grubu olduğu süper bloktaki s_blocks_count elemanında yazmaktadır.

    Bir blok grubundaki blok grup betimleyici tablosunun uzunluğu 1 blok kadardır. Blok bitmap'in ve i-node bitmap'in 
    uzunlukları doğrudan süper blokta yazmamaktadır. Bu uzunluklar dolaylı bir biçimde hesaplanmaktadır. Dolayısıyla bir 
    blok gruptaki data alanının başlangıç bloğu da dolaylı bir biçimde hesaplanmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                180. Ders 17/11/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                181. Ders 22/11/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir dosyanın i-node numarası biliniyorsa onun disk bölümündeki yerini nasıl hesaplarız? Burada bizim bu i-node 
    elemanının hangi blok grubunda ve o blok grubunun i-node tablosunda nerede olduğunu belirlememiz gerekir. i-node tablosundaki
    i-node elemanları 1'den başlatılmıştır. Yani bizim elimizde i-node numarası n olan bir dosya varsa aslında bu dosya i-node
    tablosunun n - 1'inci i-node elemanındadır. Çünkü i-node tablosunun ilk i-node elemanının numarası 0 değil, 1'dir.

    Her blok grupta eşit sayıda i-node elemanı bulunmaktadır. Bir blok gruptaki i-node elemanlarının sayısı doğrudan süper 
    bloktaki s_inodes_per_group elemanında belirtilmektedir. Bu durumda ilgili i-node numarasına ilişkin i-node elemanı i-node
    numarası n olmak üzere (n - 1) / s_inodes_per_group işlemiyle elde edilebilir. Tabii bu durumda (n - 1) % s_inodes_per_group 
    ifadesi de i-node elemanının o blok gruptaki i-node tablosunun kaçıncı elemanında olduğunu verecektir. Anımsanacağı gibi her 
    blok grubunun i-node tablosunun yeri blok grup betimleyicisinin bg_inode_table elemanında belirtiliyordu.

    Bir blok grubunun toplam kaç tane bloktan oluştuğu süper bloktaki s_blocks_per_group elemanında tutulmaktadır. Dolayısıyla 
    k'ıncı blok grubunun yeri k * s_blocks_per_group değeri ile tespit edilir. Blok numaralarına boot blok dahil değildir. Yani
    ilk blok grubunun süper bloğunun blok numarası 0'dır.

    Bu durumda manuel olarak n numaralı i-node numarasına sahip bir dosyanın i-node elemanına şöyle erişilebilir:

    1) Önce n / s_inodes_per_group ile ilgili i-node elemanının hangi blok grubununda olduğu tespit edilir. Bu değer k olsun.

    2) Bu blok grubunun yeri k * s_blocks_per_group değeri ile elde edilir ve bu bloğa gidilir. Her bloğun başında 1 blokluk 
    süper blok vardır. Süper bloğu blok grup betimleyici tablosu izler. Blok grup betimleyici tablosu blok grup betimleyicilerinden 
    oluşmaktadır. Her blok grup betimleyicisi 32 byte yer kaplamaktadır. Dolayısıyla biz k numaralı blok grubuna ilişkin blok 
    betimleyicisinin yerini k * 32 ile tespit edebiliriz. (Aslında tüm blok gruplarındaki blok grup betimleyici tablolarının 
    birbirinin aynısı olduğunu anımsayınız.)

    3) İlgili blok grubunun i-node tablosunun yeri blok grup betimleyicisinin bg_inode_table elemanında belirtilmektedir. 
    Artık biz i-node elemanını burada belirtilen bloktan itibaren n % s_inodes_per_group kadar ilerideki i-node elemanı olarak 
    elde edebiliriz. Bir i-node elemanının uzunluğunun 256 byte olduğunu belirtmiştik.

    Şimdi 12'nci i-node elemanın yerini bu adımlardan geçerek bulmaya çalışalım. Elimizdeki disk bölümünde bir blok grupta 
    toplam 25008 tane i-node elemanı vardır. O halde 12 numaralı i-node elemanı 0'ıncı blok grubunun 11'inci i-node elemanındadır. 
    0'ıncı blok grubu eğer blok uzunluğu 1K'dan fazla ise diskin 0'ıncı bloğundan başlamaktadır. (Tabii 0'ıncı bloğun hemen 
    başında boot blok, ondan 1024 byte sonra da 0'ın blok grubunun süper bloğu bulunmaktadır.) O halde elimizdeki disk bölümünün 
    0'ıncı blok grubunun blok betimleyici tablosu 1'inci bloktadır. Bunun yeri de bir blok 4096 byte olduğuna göre 0x1000 
    offset'indedir. Buradan elde edilen blok grup betimleyici tablosu şöyledir:

    00001000  0e 00 00 00 0f 00 00 00  10 00 00 00 c7 79 a4 61  |.............y.a|
    00001010  02 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00001020  0e 80 00 00 0f 80 00 00  10 80 00 00 25 3d b0 61  |............%=.a|
    00001030  00 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00001040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00001050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    ...

    Her blok grup betimleyicisinin 32 byte olduğunu anımsayınız. Bu durumda 0'ıncı blok grup betimleyicisi şöyledir:

    00001000  0e 00 00 00 0f 00 00 00  10 00 00 00 c7 79 a4 61  |.............y.a|
    00001010  02 00 04 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Bu blok grubundaki i-node tablosunun blok numarası blok grup betimleyicisinin 8'inci offset'inde bulunan bg_inode_table
    elemanındadır. Bu elemandaki değer 0x00000010 (16)'dır. O halde bizim 16 numaralı bloğa gitmemiz gerekir. 16 numaralı 
    blok disk bölümünün 16 * 4096 = 65536 (0x10000) offset'indedir. Artık bu offset'te ilgili blok grubundaki i-node elemanları 
    bulunmaktadır. Bir i-node elemanı 256 byte olduğuna göre 11'inci elemanının yeri 11 * 256 = 2816 (0xB00) byte ileridedir. 
    O halde bu tablonun disk bölümünün başından itibarenki yeri 65536 + 2816 = 68352 (0x10B00) offset'indedir. Aşağıda ilgili
    i-node elemanının 256 byte'lık içeriği görülmektedir:

    00010b00  a4 81 00 00 c8 79 00 00  87 5c 2e 67 87 5c 2e 67  |.....y...\.g.\.g|
    00010b10  87 5c 2e 67 00 00 00 00  00 00 01 00 40 00 00 00  |.\.g........@...|
    00010b20  00 00 00 00 01 00 00 00  00 08 00 00 01 08 00 00  |................|
    00010b30  02 08 00 00 03 08 00 00  04 08 00 00 05 08 00 00  |................|
    00010b40  06 08 00 00 07 08 00 00  00 00 00 00 00 00 00 00  |................|
    00010b50  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010b60  00 00 00 00 2e db 09 7c  00 00 00 00 00 00 00 00  |.......|........|
    00010b70  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010b80  20 00 00 00 c8 76 3d ba  c8 76 3d ba c8 76 3d ba  | ....v=..v=..v=.|
    00010b90  87 5c 2e 67 c8 76 3d ba  00 00 00 00 00 00 00 00  |.\.g.v=.........|
    00010ba0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bb0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bc0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bd0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010be0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bf0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Buradaki ilk WORD bilgi (0x81A4) dosyanın erişim haklarını sonraki WORD bilgi (0x0000) kullanıcı id'sini belirtmektedir. 
    Sonraki DWORD bilgi (0x000079C8) de dosyanın uzunluğunu belirtmektedir. Diğer elemanların anlamlarına i-node yapısından 
    erişebilirsiniz.

    i-node tablosundaki ilk n tane i-node elemanı reserved biçimde tutulmaktadır. Bunların sayısı süper bloktaki s_first_ino 
    elemanında belirtilmektedir. Üzerinde çalıştığımız dosya sisteminde s_first_ino değeri 11'dir. Yani ilk 10 i-node elemanı 
    reserve edilmiştir. İlk i-node elemanının numarası 11'dir. Örnek dosya sistemimizdeki durum şöyledir:

    0. Blok Grubunun i-node Tablosu

    <1 numaralı i-node elemanı>
    <2 numaralı i-node elemanı>
    <3 numaralı i-node elemanı>
    ...
    <10 numaralı i-node elemanı>
    <11 numaralı i-node elemanı (ilk reserved olmayan eleman)>
    ...

    Reserve edilmiş ilk i-node elemanlarının anlamları şöyledir:

    +----------------------+-------+-------------------------------+
    |         İsim         | Değer |             Anlamı            |
    +----------------------+-------+-------------------------------+
    | EXT2_BAD_INO         |   1   | Bad blocks i-node             |
    | EXT2_ROOT_INO        |   2   | Root directory i-node         |
    | EXT2_ACL_IDX_INO     |   3   | ACL index inode (deprecated?) |
    | EXT2_ACL_DATA_INO    |   4   | ACL data i-node (deprecated?) |
    | EXT2_BOOT_LOADER_INO |   5   | Boot loader i-node            |
    | EXT2_UNDEL_DIR_INO   |   6   | Undelete directory i-node     |
    +----------------------+-------+-------------------------------+

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                182. Ders 24/11/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                183. Ders 01/12/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi ext2 dosya sisteminde bir dosyanın parçalarının (yani bloklarının) nerelerde olduğu bilgisi nerede tutulmaktadır?
    Anımsanacağı gibi FAT dosya sisteminde dosyanın parçalarının (orada block yerine cluster teriminin kullanıldığını anımsayınız)
    diskin hangi cluster'larında olduğu FAT bölümünde saklanıyordu. İşte yalnızca ext2 dosya sisteminde değil, i-node tabanlı 
    dosya sistemlerinde bir dosyanın diskte hangi bloklarda bulunduğu i-node elemanının içerisinde tutulmaktadır. i-node elemanlarının
    genel olarak 128 byte ya da 256 byte uzunlukta olduğunu anımsayınız. Büyük bir dosyanın blok numaralarının bu kadar alana 
    sığmayacağı açıktır. Pekiyi o zaman dosyanın blok numaraları i-node elemanında nasıl tutulmaktadır?

    İşte i-node elemanında dosyanın hangi bloklarda olduğu "doğrudan (direct)", "dolaylı (indirect)", "çift dolaylı (double 
    indirect)" ve "üç dolaylı (triple indirect)"" bloklarda tutulmaktadır. i-node elemanının decimal 40'ıncı offset'inde (i-node 
    elemanının 0x28 offset'indeki "i_blocks" isimli elemanında) 15 elemanlık her biri DWORD değerlerden oluşan bir dizi vardır. 
    Bu diziyi şöyle gösterebiliriz:

    0 <dosyanın 0'ıncı bloğunun numarası>
    1 <dosyanın 1'inci bloğunun numarası>
    2 <dosyanın 2'nci bloğunun numarası>
    3 <dosyanın 3'üncü bloğunun numarası>
    4 <dosyanın 4'üncü bloğunun numarası>
    5 <dosyanın 5'inci bloğunun numarası>
    6 <dosyanın 6'ncı bloğunun numarası>
    7 <dosyanın 7'nci bloğunun numarası>
    8 <dosyanın 8'inci bloğunun numarası>
    9 <dosyanın 9'uncu bloğunun numarası>
    10 <dosyanın 10'uncu bloğunun numarası>
    11 <dosyanın 11'inci bloğunun numarası>
    12 <dolaylı blok numarası>
    13 <çift dolaylı blok numarası>
    14 <üç dolaylı blok numarası>

    Bu durumda eğer dosya 12 blok ya da ondan daha küçükse zaten dosyanın parçalarının blok numaraları bu dizinin ilk 12 
    elemanından doğrudan elde edilmektedir. Eğer dosya 12 bloktan büyükse bu durumda bu dizinin 12'nci indeksindeki elemanda 
    yazan blok numarası dosyanın diğer bloklarının blok numaralarını tutan bloğun numarasıdır. Yani dizinin 12'nci elemanında 
    belirtilen bloğa gidildiğinde bu bloğun içerisinde blok numaraları vardır. Bu blok numaraları da dosyanın 12'nci bloğundan 
    itibaren bloklarının numaralarını belirtmektedir. Örneğin bir blok 4096 byte olsun. Bu durumda bir blokta 1024 tane blok 
    numarası olabilir. 12 blok numarası doğrudan olduğuna göre dolaylı blokla toplam dosyanın 1024 + 12 = 1036 tane bloğunun 
    yeri tutulmuş olacaktır. Pekiyi ya bu sistemde dosya 1036 bloktan daha büyükse? İşte bu durumda çift dolaylı blok numarasına 
    başvurulmaktadır. Çift dolaylı blok numarasına ilişkin bloğa gidildiğinde oradaki blok numaraları dosyanın blok numaraları 
    değil, dosyanın blok numaralarının tutulduğu blok numaralarıdır. Eğer dosya çift dolaylı bloklara da sığmıyorsa üç dolaylı 
    bloğa başvurulmaktadır. Üç dolaylı blokta belirtilen blok numarasında çift dolaylı blokların numaraları vardır. Çift dolaylı
    blokların içerisinde dolaylı blokların numaraları vardır. Nihayet dolaylı blokların içerisinde de asıl blokların numaraları 
    vardır.

    Pekiyi her bloğun 4K uzunluğunda olduğu bir sistemde bir dosyanın i-node elemanında belirtilen maksimum uzunluğu ne olabilir? 
    İşte bu uzunluk aşağıdaki değerlerin toplamıyla elde edilebilir:

    12 tane doğrudan blok = 12 * 4096
    1 tane dolaylı blok = 1024 * 4096
    1 tane çift dolaylı blok = 1024 * 1024 * 4096
    1 tane üç dolaylı blok = 1024 * 1024 * 1024 * 4096

    Toplam = 12 * 4096 + 1024 * 4096 + 1024 * 12024 * 4096 + 1024 * 1024 * 1024 * 4096 = 4448483065856 = 4 TB civarı.

    Şimdi aşağıdaki i-node elemanına bakıp dosya bloklarının yerlerini tespit edelim:

    00010b00  a4 81 00 00 c8 79 00 00  87 5c 2e 67 87 5c 2e 67  |.....y...\.g.\.g|
    00010b10  87 5c 2e 67 00 00 00 00  00 00 01 00 40 00 00 00  |.\.g........@...|
    00010b20  00 00 00 00 01 00 00 00  00 08 00 00 01 08 00 00  |................|
    00010b30  02 08 00 00 03 08 00 00  04 08 00 00 05 08 00 00  |................|
    00010b40  06 08 00 00 07 08 00 00  00 00 00 00 00 00 00 00  |................|
    00010b50  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010b60  00 00 00 00 2e db 09 7c  00 00 00 00 00 00 00 00  |.......|........|
    00010b70  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010b80  20 00 00 00 c8 76 3d ba  c8 76 3d ba c8 76 3d ba  | ....v=..v=..v=.|
    00010b90  87 5c 2e 67 c8 76 3d ba  00 00 00 00 00 00 00 00  |.\.g.v=.........|
    00010ba0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bb0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bc0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bd0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010be0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010bf0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Burada dosyanın tüm blokları 0x28'inci offset'teki doğrudan bloklarda belirtilmektedir:

    00 08 00 00  => 0x800
    01 08 00 00  => 0x801
    02 08 00 00  => 0x802
    03 08 00 00  => 0x803
    04 08 00 00  => 0x804
    05 08 00 00  => 0x805
    06 08 00 00  => 0x806
    07 08 00 00  => 0x807

    Dosya 0x4 offset'inde belirtilen 0x79C8 = 31176 byte uzunluğundadır. Bu sistemde bir blok 4K olduğuna göre toplam dosyanın
    parçalarının 8 blok olması gerekmektedir. İşte burada söz konusu dosyanın blokları disk bölümünün başından itibaren 
    0x800, 0x801, 0x802, 0x803, 0x804, 0x805, 0x806 ve 0x807'nci bloklardadır. Söz konusu sistemde bir blok 4096 byte 
    olduğuna göre dosyanın ilk bloğunun offset numarası 0x800 * 0x1000 = 0x800000 biçimindedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de ext2 dosya sisteminde dizin organizasyonu üzerinde duralım. Tıpkı FAT dosya sistemlerinde olduğu gibi ext2 
    dosya sisteminde de dizinler birer dosya gibi organize edilmiştir. (Anımsanacağı gibi dizin dosyalarından biz opendir, 
    readdir, closedir fonksiyonlarıyla okuma yapabiliyorduk.) Yani dizinler aslında birer dosya gibidir. Dizin dosyaları 
    "dizin girişleri (directory entries)" denilen girişlerden oluşmaktadır.

    <dizin_girişi>
    <dizin_girişi>
    <dizin_girişi>
    <dizin_girişi>
    <dizin_girişi>
    ...

    Bir dizin girişin format şöyledir:

    +----------------+--------------+-------------------------+
    | Offset (bytes) | Size (bytes) |        Açıklama         |
    +----------------+--------------+-------------------------+
    |       0        |     DWORD    | i-node numarası         |
    |       4        |     WORD     | Girişin toplam uzunluğu |
    |       6        |     BYTE     | Dosya isminin uzunluğu  |
    |       7        |     BYTE     | Dosyanın türü           |
    |       8        | 0-255 Bytes  | Dosya ismi              |
    +----------------+--------------+-------------------------+

    Aslında buradaki bilgiler Linux'taki readdir POSIX fonksiyonu ile de alınabilmektedir. readdir fonksiyonu POSIX standartlarına
    göre en az iki elemana sahip olmak zorundadır. Bunlar d_ino ve d_name elemanlarıdır. Ancak Linux'taki read bize daha fazla
    bilgi vermektedir. Linux'taki dirent yapısı şöyledir:

    struct dirent {
        ino_t          d_ino;       /* Inode number */
        off_t          d_off;       /* Not an offset; see below */
        unsigned short d_reclen;    /* Length of this record */
        unsigned char  d_type;      /* Type of file; not supported by all filesystem types */
        char           d_name[256]; /* Null-terminated filename */
    };

    Dizin girişleri FAT dosya sistemindeki gibi eşit uzunlukta girişlerden oluşmamaktadır. Bunun nedeni dosya isimlerinin 
    0 ile 255 karakter arasında değişebilmesidir. Dizin girişlerinin hemen başında DWORD bir alanda dosyanın i-node numarası
    belirtilmektedir. Dizinler değişken uzunlukta olduğu için ilgili girişin toplam kaç byte uzunlukta olduğu sonraki WORD 
    elemanda tutulmaktadır. Girişteki dosya isminin uzunluğu ise sonraki BYTE elemanında tutulmaktadır. Dosyanın türü 
    hiç i-node elemanına erişmeden elde edilebilsin diye dizin girişlerinde de tutulmaktadır. Dosya türlerini belirten değerler
    şöyledir:

    +------------------+-------+-------------------+
    |       İsim       | Değer |       Anlamı      |
    +------------------+-------+-------------------+
    | EXT2_FT_UNKNOWN  |   0   | Unknown File Type |
    | EXT2_FT_REG_FILE |   1   | Regular File      |
    | EXT2_FT_DIR      |   2   | Directory File    |
    | EXT2_FT_CHRDEV   |   3   | Character Device  |
    | EXT2_FT_BLKDEV   |   4   | Block Device      |
    | EXT2_FT_FIFO     |   5   | Buffer File       |
    | EXT2_FT_SOCK     |   6   | Socket File       |
    | EXT2_FT_SYMLINK  |   7   | Symbolic Link     |
    +------------------+-------+-------------------+

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                184. Ders 06/12/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi ext2 dosya sisteminde işletim sistemi bir yol ifadesini nasıl çözümlemektedir? Örneğin "/a/b/c.txt" gibi bir yol
    ifadesinde "c.txt" dosyasının i-node elemanına nasıl erişmektedir? İşte kök dizin dosyasının bilgileri 2 numaralı i-node 
    elemanındadır. İşletim sistemi önce kök dizinin i-node elemanını elde eder. Oradan kök dizinin bloklarına erişir. O bloklar 
    içerisinde ilgili girişi arar. İşlemlerini bu biçimde devam ettirir. Örneğin "/a/b/c.txt" dosyasının i-node elemanına 
    erişmek için önce kök dizinde "a" girişini arar. Sonra "a" girişinin dizin olduğunu doğrular. Sonra "a" dizininde "b" 
    girişini arar. "b" girişinin de dosya olduğunu doğrular. Sonra "b" girişinin içerisinde "c.txt" arar ve hedef dosyanın 
    i-node bilgilerine erişir.

    Şimdi adım adım elimizdeki disk bölümünde "/a/b/c.txt" dosyasının yerini bulmaya çalışalım. Tabii buradaki kök dizin 
    aslında mount edilmiş dosya sisteminin köküdür. Biz bu dosya sistemini kursumuzda aşağıdaki noktaya mount ettik:

    "/home/kaan/Study/UnixLinux-SysProg/DiskIO-FileSystems"

    Kök dizinin i-node elemanı (2 numaralı i-node elemanı) aşağıda verilmiştir:

    00010100  ed 41 00 00 00 10 00 00  a8 69 4c 67 a7 69 4c 67  |.A.......iLg.iLg|
    00010110  a7 69 4c 67 00 00 00 00  00 00 04 00 08 00 00 00  |.iLg............|
    00010120  00 00 00 00 04 00 00 00  2b 06 00 00 00 00 00 00  |........+.......|
    00010130  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010140  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010150  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010160  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010170  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00010180  20 00 00 00 a0 15 ed 2d  a0 15 ed 2d 1c 7e f4 e6  | ......-...-.~..|
    00010190  42 5c 2e 67 00 00 00 00  00 00 00 00 00 00 00 00  |B\.g............|
    000101a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000101b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000101c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000101d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000101e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000101f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Burada 0x28'inci offset'teki i_blocks elemanının yalnızca ilkinin dolu olduğunu görüyoruz. Demek ki kök dizin tek bir 
    bloktan oluşmaktadır. Kök dizinin blok numarası 0x62B'dir. Şimdi 0x62b bloğunun offset'ini hesaplayalım. Bunun için 
    bu değeri 0x1000 (4096) ile çarpmamız gerekir:

    0x62B * 0x1000 = 0x62B000 (6467584)

    Diskin bu offset'indeki değerler şöyledir:

    0062b000  02 00 00 00 0c 00 01 02  2e 00 00 00 02 00 00 00  |................|
    0062b010  0c 00 02 02 2e 2e 00 00  0b 00 00 00 14 00 0a 02  |................|
    0062b020  6c 6f 73 74 2b 66 6f 75  6e 64 00 00 0c 00 00 00  |lost+found......|
    0062b030  10 00 07 01 73 74 64 69  6f 2e 68 00 b2 61 00 00  |....stdio.h..a..|
    0062b040  c4 0f 01 02 61 00 00 00  00 00 00 00 00 00 00 00  |....a...........|
    0062b050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0062b060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0062b070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0062b080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0062b090  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0062b0a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0062b0b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Buradaki dizin girişlerini çözelim. Dizin giriş formatını aşağıda yeniden veriyoruz:

    +----------------+--------------+-------------------------+
    | Offset (bytes) | Size (bytes) |        Açıklama         |
    +----------------+--------------+-------------------------+
    |       0        |     DWORD    | i-node numarası         |
    |       4        |     WORD     | Girişin toplam uzunluğu |
    |       6        |     BYTE     | Dosya isminin uzunluğu  |
    |       7        |     BYTE     | Dosyanın türü           |
    |       8        | 0-255 Bytes  | Dosya ismi              |
    +----------------+--------------+-------------------------+

    İlk dizin girişinin i-node numarası 2'dir. Bu girişin uzunluğu 0x0C = 12'dir. O halde bu dizin girişi şöyledir:

    0062b000  02 00 00 00 0c 00 01 02  2e 00 00 00 02

    Burada dosya ismi 1 karakter uzunluktadır. Dosya ismi yalnızca 0x2E karakterinde oluşmaktadır. Bu karakter de "." karakteridir.
    Sonraki dizin girişinin i-node numarası yine 2'dir. Girişin uzunluğu yine 0xC = 12'dir. O halde giriş şöyledir:

    0062b000                                       02 00 00 00  |................|
    0062b010  0c 00 02 02 2e 2e 00 00                           |................|

    Buradaki dosya uzunluğunun 2 olduğu görülmektedir. Dosya ismi de 0x2E 0x2E karakterinden oluşmaktadır. Bu da ".." ismidir. 
    Her dizinin ilk iki elemanının bu biçimde olduğunu anımsayınız. Sonraki giriş ise şöyledir:

    0062b010                           0b 00 00 00 14 00 0a 02  |................|
    0062b020  6c 6f 73 74 2b 66 6f 75  6e 64 00 00              |lost+found......|

    Burada dosya i-node numarası 0x0b = 11'dir. Dizin girişinin uzunluğu 0x14 = 20'dir. Dosya isminin uzunluğu 0xA = 10'dur. 
    Dosya ismi "lost+found" biçimindedir. Sonraki giriş ise şöyledir:

    0062b020                                       0c 00 00 00  |lost+found......|
    0062b030  10 00 07 01 73 74 64 69  6f 2e 68 00              |....stdio.h..a..|

    Buradaki girişin i-node numarası 0xC = 12'dir. Girişin toplam uzunluğu 0x10 = 16'dır. Dosyanın isminin uzunluğu 7'dir. 
    Dosya ismi "stdio.h" biçimindedir. Sonraki giriş ise şöyledir:

    0062b030                                       b2 61 00 00  |....stdio.h..a..|
    0062b040  c4 0f 01 02 61 00 00 00  00 00 00 00 00 00 00 00  |....a...........|

    Burada dosyanın i-node numarası 0x61B2 = 25010'dur. Girişin uzunluğu 0xC4 = 196'dır. (Bu değerin çok uzun olması önemli değildir. 
    Çünkü bu dizindeki son dosyadır.) Dosya isminin uzunluğu 1'dir. Dosya türü 0x02'dir. Yani bu giriş bir dizin belirtmektedir. 
    Dosya ismi "a" biçimindedir.

    İşte işletim sistemi 0x61B2 = 25010'ıncı i-node elemanında bu dizinin bilgilerinin olduğunu tespit eder ve o i-node elemanını
    okur. Bu i-node elemanı aşağıdaki gibidir:

    08010100  ed 41 00 00 00 10 00 00  f8 2b 53 67 a7 69 4c 67  |.A.......+Sg.iLg|
    08010110  a7 69 4c 67 00 00 00 00  00 00 03 00 08 00 00 00  |.iLg............|
    08010120  00 00 00 00 02 00 00 00  2b 86 00 00 00 00 00 00  |........+.......|
    08010130  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    08010140  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    08010150  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    08010160  00 00 00 00 f9 65 fb 3c  00 00 00 00 00 00 00 00  |.....e.<........|
    08010170  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    08010180  20 00 00 00 a0 15 ed 2d  a0 15 ed 2d 04 7d e1 7b  | ......-...-.}.{|
    08010190  a7 69 4c 67 a0 15 ed 2d  00 00 00 00 00 00 00 00  |.iLg...-........|
    080101a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    080101b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    080101c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    080101d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    080101e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    080101f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    "a" dizinine ilişkin i-node elemanının 0x28'inci offset'teki blokları bir tanedir ve blok numarası 0x862B = 34547'dir. 
    Bu bloğun offset'i de 34547 * 4096 = 140685312'dir. Dizine ilişkin dizin bloğunun içeriği şöyledir:

    0862b000  b2 61 00 00 0c 00 01 02  2e 00 00 00 02 00 00 00  |.a..............|
    0862b010  0c 00 02 02 2e 2e 00 00  b3 61 00 00 e8 0f 01 02  |.........a......|
    0862b020  62 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |b...............|
    0862b030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b090  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0862b0a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Bu dizin girişlerine bakıldığında "b" isimli girişin bulunduğu görülmektedir. İşte yol ifadesi bu aşamalardan geçilerek 
    çözümlenmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir dosya oluşturulurken boş bloklar nasıl tespit edilmektedir? İşte her blok grup betimleyicisi kendi blok grubundaki 
    boş blokları "block bitmap" denilen tabloda bit düzeyinde tutmaktadır. Blok bitmap tablosu her biti bir bloğun boş mu dolu 
    mu olduğunu tutmaktadır. Blok grup betimleyicisinde yalnızca blok grubunun yeri tutulur. Bunun blok uzunluğu ilgili blok
    gruplarındaki blok sayısına bakılarak tespit edilmelidir. Her blok grubunda eşit sayıda blok bulunur. Bu sayı süper blok
    içerisindeki s_blocks_per_group elemanında saklanmaktadır. Aşağıda bir grup betimleyicisinin blok bitmap tablosunun bir 
    bölümünü görüyorsunuz:

    0000e000  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e010  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e020  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e030  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e040  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e050  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e060  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e070  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e080  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e090  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e0a0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e0b0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
    0000e0c0  ff ff ff ff ff ff 01 00  00 00 00 00 00 00 00 00  |................|
    0000e0d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000e0e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000e0f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000e100  ff 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Buradaki FF byte'larına dikkat ediniz. FF byte'ı aslında ikilik sistemde 1111 1111 bitlerine karşılık gelmektedir. Yani
    bu bloklar tamamen tahsis edilmiştir. 00 olan byte'lara ilişkin bloklar tahsis edilmemiş durumdadır.

    i-node elemanlarının tahsis edilip edilmediğine yönelik de benzer bir tablo tutulmaktadır. Buna "i-node bitmap" tablosu 
    denilmektedir. Her blok grubunda bir i-node bitmap tablosu bulunur. Bu tablo da bitlerden oluşmaktadır. Her bit ilgili 
    i-node elemanının boş mu dolu mu olduğunu belirtir. i-node bitmap tablosunun yeri de yine blok grup betimleyicisinde 
    tutulmaktadır. Bu tablonun uzunluğu da yine süper bloktaki "bir grup bloğundaki i-node elemanlarının sayısı" dikkate 
    alınarak tespit edilmektedir. Aşağıda örnek bir i-node bitmap tablosunun bir kısmını görüyorsunuz:

    0000f000  ff 0f 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    0000f080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

    Bu blok grubunda toplam 12 i-node elemanı tahsis edilmiş durumdadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıdaki örneklerde dosya sistemini tanıyabilmek için manuel işlemler yaptık. Pekiyi bu işlemleri programlama yoluyla 
    nasıl yapabiliriz? Yukarıda açıkladığımız dosya sistemi alanlarına ilişkin yapılar çeşitli kütüphanelerin içerisinde hazır
    bir biçimde bulunmaktadır. Örneğin "libext2fs" kütüphanesi kurulduğunda <extfs/ext2_fs.h> dosyasında tüm yapı bildirimleri
    bulunacaktır. Kütüphanenin kurulumunu şöyle yapabilirsiniz:

    $ sudo apt-get install libext2fs-dev

    Aslında bu kütüphane ve <extfs/ext2_fs.h> başlık dosyası yalnızca ext2 dosya sistemine ilişkin değil, ext2 ve ext4 dosya 
    sistemine ilişkin de yapıları ve fonksiyonları bulundurmaktadır.

    Örneğin <extfs/ext2_fs.h> başlık dosyası içerisindeki süper blok yapısı aşağıdaki gibi bildirilmiştir:

    struct ext2_super_block {
        /*000*/    __u32    s_inodes_count;        /* Inodes count */
            __u32    s_blocks_count;        /* Blocks count */
            __u32    s_r_blocks_count;    /* Reserved blocks count */
            __u32    s_free_blocks_count;    /* Free blocks count */
        /*010*/    __u32    s_free_inodes_count;    /* Free inodes count */
            __u32    s_first_data_block;    /* First Data Block */
            __u32    s_log_block_size;    /* Block size */
            __u32    s_log_cluster_size;    /* Allocation cluster size */
        /*020*/    __u32    s_blocks_per_group;    /* # Blocks per group */
            __u32    s_clusters_per_group;    /* # Fragments per group */
            __u32    s_inodes_per_group;    /* # Inodes per group */
            __u32    s_mtime;        /* Mount time */
        /*030*/    __u32    s_wtime;        /* Write time */
            __u16    s_mnt_count;        /* Mount count */
            __s16    s_max_mnt_count;    /* Maximal mount count */
            __u16    s_magic;        /* Magic signature */
            __u16    s_state;        /* File system state */
            __u16    s_errors;        /* Behaviour when detecting errors */
            __u16    s_minor_rev_level;    /* minor revision level */
        /*040*/    __u32    s_lastcheck;        /* time of last check */
            __u32    s_checkinterval;    /* max. time between checks */
            __u32    s_creator_os;        /* OS */
            __u32    s_rev_level;        /* Revision level */
        /*050*/    __u16    s_def_resuid;        /* Default uid for reserved blocks */
            __u16    s_def_resgid;        /* Default gid for reserved blocks */
            /*
            * These fields are for EXT2_DYNAMIC_REV superblocks only.
            *
            * Note: the difference between the compatible feature set and
            * the incompatible feature set is that if there is a bit set
            * in the incompatible feature set that the kernel doesn't
            * know about, it should refuse to mount the filesystem.
            *
            * e2fsck's requirements are more strict; if it doesn't know
            * about a feature in either the compatible or incompatible
            * feature set, it must abort and not try to meddle with
            * things it doesn't understand...
            */
            __u32    s_first_ino;        /* First non-reserved inode */
            __u16   s_inode_size;        /* size of inode structure */
            __u16    s_block_group_nr;    /* block group # of this superblock */
            __u32    s_feature_compat;    /* compatible feature set */
        /*060*/    __u32    s_feature_incompat;    /* incompatible feature set */
            __u32    s_feature_ro_compat;    /* readonly-compatible feature set */
        /*068*/    __u8    s_uuid[16] __nonstring;        /* 128-bit uuid for volume */
        /*078*/    __u8    s_volume_name[EXT2_LABEL_LEN] __nonstring;    /* volume name, no NUL? */
        /*088*/    __u8    s_last_mounted[64] __nonstring;    /* directory last mounted on, no NUL? */
        /*0c8*/    __u32    s_algorithm_usage_bitmap; /* For compression */
            /*
            * Performance hints. Directory preallocation should only
            * happen if the EXT2_FEATURE_COMPAT_DIR_PREALLOC flag is on.
            */
            __u8    s_prealloc_blocks;    /* Nr of blocks to try to preallocate*/
            __u8    s_prealloc_dir_blocks;    /* Nr to preallocate for dirs */
            __u16    s_reserved_gdt_blocks;    /* Per group table for online growth */
            /*
            * Journaling support valid if EXT2_FEATURE_COMPAT_HAS_JOURNAL set.
            */
        /*0d0*/    __u8    s_journal_uuid[16] __nonstring;    /* uuid of journal superblock */
        /*0e0*/    __u32    s_journal_inum;        /* inode number of journal file */
            __u32    s_journal_dev;        /* device number of journal file */
            __u32    s_last_orphan;        /* start of list of inodes to delete */
        /*0ec*/    __u32    s_hash_seed[4];        /* HTREE hash seed */
        /*0fc*/    __u8    s_def_hash_version;    /* Default hash version to use */
            __u8    s_jnl_backup_type;    /* Default type of journal backup */
            __u16    s_desc_size;        /* Group desc. size: INCOMPAT_64BIT */
        /*100*/    __u32    s_default_mount_opts;    /* default EXT2_MOUNT_* flags used */
            __u32    s_first_meta_bg;    /* First metablock group */
            __u32    s_mkfs_time;        /* When the filesystem was created */
        /*10c*/    __u32    s_jnl_blocks[17];    /* Backup of the journal inode */
        /*150*/    __u32    s_blocks_count_hi;    /* Blocks count high 32bits */
            __u32    s_r_blocks_count_hi;    /* Reserved blocks count high 32 bits*/
            __u32    s_free_blocks_hi;    /* Free blocks count */
            __u16    s_min_extra_isize;    /* All inodes have at least # bytes */
            __u16    s_want_extra_isize;    /* New inodes should reserve # bytes */
        /*160*/    __u32    s_flags;        /* Miscellaneous flags */
            __u16    s_raid_stride;        /* RAID stride in blocks */
            __u16    s_mmp_update_interval;  /* # seconds to wait in MMP checking */
            __u64    s_mmp_block;        /* Block for multi-mount protection */
        /*170*/    __u32    s_raid_stripe_width;    /* blocks on all data disks (N*stride)*/
            __u8    s_log_groups_per_flex;    /* FLEX_BG group size */
            __u8    s_checksum_type;    /* metadata checksum algorithm */
            __u8    s_encryption_level;    /* versioning level for encryption */
            __u8    s_reserved_pad;        /* Padding to next 32bits */
            __u64    s_kbytes_written;    /* nr of lifetime kilobytes written */
        /*180*/    __u32    s_snapshot_inum;    /* Inode number of active snapshot */
            __u32    s_snapshot_id;        /* sequential ID of active snapshot */
            __u64    s_snapshot_r_blocks_count; /* active snapshot reserved blocks */
        /*190*/    __u32    s_snapshot_list;    /* inode number of disk snapshot list */
        #define EXT4_S_ERR_START ext4_offsetof(struct ext2_super_block, s_error_count)
            __u32    s_error_count;        /* number of fs errors */
            __u32    s_first_error_time;    /* first time an error happened */
            __u32    s_first_error_ino;    /* inode involved in first error */
        /*1a0*/    __u64    s_first_error_block;    /* block involved in first error */
            __u8    s_first_error_func[32] __nonstring;    /* function where error hit, no NUL? */
        /*1c8*/    __u32    s_first_error_line;    /* line number where error happened */
            __u32    s_last_error_time;    /* most recent time of an error */
        /*1d0*/    __u32    s_last_error_ino;    /* inode involved in last error */
            __u32    s_last_error_line;    /* line number where error happened */
            __u64    s_last_error_block;    /* block involved of last error */
        /*1e0*/    __u8    s_last_error_func[32] __nonstring;    /* function where error hit, no NUL? */
        #define EXT4_S_ERR_END ext4_offsetof(struct ext2_super_block, s_mount_opts)
        /*200*/    __u8    s_mount_opts[64] __nonstring;    /* default mount options, no NUL? */
        /*240*/    __u32    s_usr_quota_inum;    /* inode number of user quota file */
            __u32    s_grp_quota_inum;    /* inode number of group quota file */
            __u32    s_overhead_clusters;    /* overhead blocks/clusters in fs */
        /*24c*/    __u32    s_backup_bgs[2];    /* If sparse_super2 enabled */
        /*254*/    __u8    s_encrypt_algos[4];    /* Encryption algorithms in use */
        /*258*/    __u8    s_encrypt_pw_salt[16];    /* Salt used for string2key algorithm */
        /*268*/    __le32    s_lpf_ino;        /* Location of the lost+found inode */
            __le32  s_prj_quota_inum;    /* inode for tracking project quota */
        /*270*/    __le32    s_checksum_seed;    /* crc32c(orig_uuid) if csum_seed set */
        /*274*/    __u8    s_wtime_hi;
            __u8    s_mtime_hi;
            __u8    s_mkfs_time_hi;
            __u8    s_lastcheck_hi;
            __u8    s_first_error_time_hi;
            __u8    s_last_error_time_hi;
            __u8    s_first_error_errcode;
            __u8    s_last_error_errcode;
        /*27c*/ __le16    s_encoding;        /* Filename charset encoding */
            __le16    s_encoding_flags;    /* Filename charset encoding flags */
            __le32    s_reserved[95];        /* Padding to the end of the block */
        /*3fc*/    __u32    s_checksum;        /* crc32c(superblock) */
    };

    Kütüphane aşağıdaki bağlantıdan indirebileceğiniz pdf dosyasında dokümante edilmiştir:

    https://www.dubeyko.com/development/FileSystems/ext2fs/libext2fs.pdf

    Ayrıca "e2fsprogs" isimli pakette de ext2, ext3 ve ext4 dosya sistemlerine ilişkin pek çok yardımcı program bulunmaktadır.
    Örneğin bizim daha önce kullandığımız "dumpe2fs" programı bu paketin bir parçasıdır. Buradaki programlar "libext2fs" 
    kütüphanesi kullanılarak yazılmıştır. Paket pek çok Linux dağıtımında default biçimde kurulu durumdadır. Eğer dağıtımınızda 
    kurulu değilse bu paketi aşağıdaki gibi kurabilirsiniz:

    $ sudo apt-get install e2fsprogs
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                185. Ders 08/12/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi "libext2fs" kütüphanesinin basit bir kullanımı üzerinde duracağız. Kütüphanenin temel başlık dosyası <extefs/extfs.h> 
    isimli dosyadır. Bu dosyanın include edilmesi gerekir.

    #include <ext2fs/ext2fs.h>

    Kütüphaneyi kullanan programlar derlenirken link aşamasında "-lext2fs" seçeneğinin bulundurulması gerekir. Örneğin:

    $ gcc -o sample sample.c -lext2fs

    Kütüphane içerisindeki fonksiyonların çoğunun geri dönüş değerleri errcode_t türündendir. errcode_t türü long biçimde 
    typedef edilmiştir. Fonksiyonlar başarı durumunda 0 değerine, başarısızlık durumunda hata ile ilgili bir değere geri 
    dönmektedir. Hatayı yazdırmak için error_message isimli fonksiyon bulunmaktadır. Bu fonksiyona errcode_t değeri parametre
    olarak verilir, fonksiyon da hata yazısına ilişkin static bir dizinin başlangıç adresine geri döner. Örneğin:

    ext2_filsys fs;
    errcode_t err;

    if ((err = ext2fs_open("/dev/loop0", 0 /* EXT2_FLAG_RW */, 0, 0, unix_io_manager, &fs)) != 0) {
        fprintf(stderr, "%s\n", error_message(err));
        exit(EXIT_FAILURE);
    }

    Bu kütüphane kullanılarak yazılmış programlar genel olarak aygıtlara eriştiği için "sudo" ile çalıştırılması gerekir. 
    Aksi takdirde "Permission denied (EACCESS)" hatası ortaya çıkacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kütüphanenin kullanılması için ilk yapılacak işlem dosya sisteminin ext2fs_open fonksiyonu ile açılmasıdır. Fonksiyonun 
    prototipi şöyledir:

    errcode_t ext2fs open (const char *name, int args, int superblock, int block size, io_manager manager, ext2_filsys *ret fs);

    Fonksiyonun birinci parametresi dosya sisteminin bulunduğu dosyanın ya da aygıt dosyasının yol ifadesini almaktadır. 
    Parametrelerin çoğu default 0 geçilebilir. Ancak io_manager parametresi için unix_io_manager argümanının girilmesi 
    gerekmektedir. Fonksiyon ext2fil_sys türünden handle belirten bir nesne vermektedir. Bu tür şöyle typedef edilmiştir:

    typedef struct struct_ext2_filsys *ext2_filsys;

    Dosya sistemine ilişkin tüm bilgiler bu struct_ext2_filsys yapısının içerisindedir. Bu yapı şöyle bildirilmiştir:

    struct struct_ext2_filsys {
        errcode_t            magic;
        io_channel            io;
        int                flags;
        char *                device_name;
        struct ext2_super_block    *     super;
        unsigned int            blocksize;
        int                fragsize;
        dgrp_t                group_desc_count;
        unsigned long            desc_blocks;
        struct opaque_ext2_group_desc *    group_desc;
        unsigned int            inode_blocks_per_group;
        ext2fs_inode_bitmap        inode_map;
        ext2fs_block_bitmap        block_map;
        ...
    };

    Örneğin bu yapının super elemanı süper blok bilgilerinin bulunduğu ext2_super_block isimli yapı nesnesinin adresini 
    vermektedir.

    Örneğin:

    ext2_filsys fs;
    errcode_t err;

    if ((err = ext2fs_open("/dev/loop0", 0 /* EXT2_FLAG_RW */, 0, 0, unix_io_manager, &fs)) != 0) {
        fprintf(stderr, "cannot open file system!...\n");
        exit(EXIT_FAILURE);
    }

    Açılan dosya sisteminin işlem bitince ext2fs_close fonksiyonu ile kapatılması gerekir. Fonksiyonun prototipi şöyledir:

    errcode_t ext2fs close (ext2_filsys fs);

    Örneğin:

    ext2_filsys fs;
    errcode_t err;

    if ((err = ext2fs_open("/dev/loop0", 0 /* EXT2_FLAG_RW */, 0, 0, unix_io_manager, &fs)) != 0) {
        fprintf(stderr, "cannot open file system!...\n");
        exit(EXIT_FAILURE);
    }

    /* ... */

    ext2fs_close(fs);
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <ext2fs/ext2fs.h>

int main(void)
{
    ext2_filsys fs;
    errcode_t err;

    if ((err = ext2fs_open("/dev/loop0", 0 /* EXT2_FLAG_RW */, 0, 0, unix_io_manager, &fs)) != 0) {
        fprintf(stderr, "cannot open file system!...\n");
        exit(EXIT_FAILURE);
    }

    printf("Number of i-node: %lu\n", (unsigned long)fs->super->s_inodes_count);
    printf("Total Block: %lu\n", (unsigned long)fs->super->s_blocks_count);
    /* ... */

    ext2fs_close(fs);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Belli bir numaraya sahip i-node elemanını elde edebilmek için ext2fs_read_inode fonksiyonu kullanılmaktadır. Fonksiyonun 
    prototipi şöyledir:

    errcode_t ext2fs_read_inode(ext2_filsys fs, ext2_ino_t ino, struct ext2_inode *inode);

    Fonksiyonun birinci parametresi dosya sistemini temsil eden handle değeridir. İkinci parametre bilgileri elde edilecek 
    i-node elemanın numarasını belirtir. Üçüncü parametre de i-node bilgilerinin yerleştirileceği yapının adresini almaktadır. 
    Örneğin:

    if ((err = ext2fs_read_inode(fs, 13, &inode)) != 0) {
        fprintf(stderr, "cannot read inode!...\n");
        exit(EXIT_FAILURE);
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                186. Ders 15/12/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir diske birden fazla bağımsız dosya sisteminin (ve belki de işletim sisteminin) yüklenebilmesi için diskin mantıksal 
    bakımdan parçalara ayrılması gerekmektedir. Diskin mantıksal bakımdan parçalara ayrılmasına ise "disk bölümlemesi" 
    denilmektedir. Disk bölümlemesi aslında disk bölümlerinin hangi sektörden başlayıp kaç sektör uzunluğunda olduğunun 
    belirlenmesi anlamına gelmektedir. Böylece her dosya sistemi başkasının alanına müdahale etmeden yalnızca o disk bölümünü 
    kullanmaktadır.

    Diskteki disk bölümleri hakkında bilgileri barındıran tabloya "disk bölümleme tablosu (disk partition table)" denilmektedir. 
    Bugün için iki disk bölümleme tablo formatı kullanılmaktadır:

    1) Klasik (legacy) MBR Disk Bölümleme Tablo Formatı
    2) Modern UEFI BIOS Sistemlerinin Kullandığı GPT (Guid Partition Table) Formatı

    UEFI BIOS'lar GPT disk bölümleme tablosu kullanırken eski sistemler ve gömülü sistemler genel olarak klasik MBR disk 
    bölümleme tablosunu kullanmaktadır. Gömülü sistemler için oluşturduğumuz SD kartlar'daki disk bölümleme tablosu klasik 
    (legacy) disk bölümleme tablosudur. Ancak bugünkü büyük çaplı UEFI BIOS'lar önce GPT disk bölümleme tablosuna bakmakta 
    eğer onu bulamazsa klasik disk bölümleme tablosunu aramaktadır. Yani geçmişe doğru uyum korunmaya çalışılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi disk sistemlerine okuma ve yazma işlemleri blok aygıt sürücüleri tarafından yapılmaktadır. 
    Dolayısıyla bir UNIX türevi sistemde her disk için "/dev" dizininin altında bir blok aygıt dosyası bulunmaktadır. Aynı zamanda 
    her disk bölümü için de bir blok aygıt dosyası bulunur. Böylece bir diskin bütünü üzerinde de yalnızca onun belli bir bölümü 
    üzerinde de çalışılabilir. Daha önceden de kullanmış olduğumuz "lsblk" komutu bize sistemimizdeki diskler ve onların bölümleri 
    hakkında bilgiler vermektedir. Örneğin çalıştığımız sistemde "lsblk" komutunu uyguladığımızda şöyle bir çıktı ile karşılaşmaktayız:

    $ lsblk
    NAME MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
    loop0
        7:0    0 195,3M  0 loop /home/kaan/Study/UnixLinux-SysProg/DiskIO-FileSystems/ext2
    sda    8:0    0    60G  0 disk
    ├─sda1
    │      8:1    0     1M  0 part
    ├─sda2
    │      8:2    0   513M  0 part /boot/efi
    └─sda3
        8:3    0  59,5G  0 part /
    sr0   11:0    1  1024M  0 rom

    Buradaki "sda" aygıtı bir diski bütün olarak ele almak için kullanılmaktadır. Bu diskin 3 tane disk bölüme vardır. Bu 
    disk bölümleri de "sda1", "sda2" ve "sda3" aygıtlarıdır. Bu aygıtlara ilişkin "/dev" dizini altında aygıt dosyaları 
    bulunmaktadır. Örneğin:

    $ ls -l /dev/sda*
    brw-rw---- 1 root disk 8, 0 Ara  6 15:08 /dev/sda
    brw-rw---- 1 root disk 8, 1 Ara  6 15:08 /dev/sda1
    brw-rw---- 1 root disk 8, 2 Ara  6 15:08 /dev/sda2
    brw-rw---- 1 root disk 8, 3 Ara  6 15:08 /dev/sda3

    Diskleri temsil eden isimler o diskin türüne göre değişebilmektedir. Normal hard diskler için isimlendirme "sda", "sdb", 
    "sdc" biçiminde yapılmaktadır. Bunların bölümleri de "sda1", "sda2", "sdb1, "sdb2" biçiminde yapılır. MicroSD kartlar 
    "mmcblk0", "mmcblk1", "mmcblk2" biçiminde isimlendirilmektedir. Bunların bölümleri de "mmcblk0p1", "mmcblk0p2", "mmcblk1p1", 
    "mmcblk1p2" biçiminde yapılmaktadır. Eğer disk bir loop aygıtı biçiminde oluşturulmuşsa disk bölümleri "loop0p1", "loop0p2", 
    "loop1p1", "loop1p2" biçiminde isimlendirilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Klasik MBR (legacy) disk bölümlendirmesinde diskin ilk sektörüne (0 numaralı sektörüne) MBR (Master Boot Record) sektörü 
    denilmektedir. MBR sektörünün sonundaki 2 byte MBR'nin bilinçli olarak oluşturulduğunu belirten sihirli bir sayıdan (magic 
    number) oluşmaktadır. Bu sihirli sayı hex olarak 55 AA biçimindedir. Aşağıda "loop0" aygıtı üzerinde oluşturulmuş bir MBR
    sektörü görülmektedir:

    $ sudo hexdump /dev/loop0 -C -v -n 512
    00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000050  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000060  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000090  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000000f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000100  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000110  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000120  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000130  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000140  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000150  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000160  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000170  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000180  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    00000190  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001b0  00 00 00 00 00 00 00 00  03 74 de d6 00 00 80 01  |.........t......|
    000001c0  01 00 83 20 0d 13 3f 00  00 00 01 b0 04 00 00 20  |... ..?........ |
    000001d0  0e 13 83 3e 18 26 40 b0  04 00 c0 af 04 00 00 00  |...>.&@.........|
    000001e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|

    Sektörün sonunun 55 AA ile bittiğine dikkat ediniz.

    Klasik MBR Disk Bölümlemesi'nde MBR sektörünün sonundaki 64 byte'a "Disk Bölümleme Tablosu (Disk Partition Table)" denilmektedir. 
    Tabii sektörün sonunda hex olarak 55 AA bulunduğu için disk bölümleme tablosu da bu 55 AA byte'larının hemen gerisindeki 
    64 byte'tadır. O halde MBR sektörünün sonu aşağıdaki gibidir:

    ... <64 byte (Disk Bölümleme Tablosu)> 55 AA

    Yukarıdaki MBR sektörünün son 64 byte'ı ve 55 AA değerleri aşağıda verilmiştir:

                                                         80 01  |.........t......|
    000001c0  01 00 83 20 0d 13 3f 00  00 00 01 b0 04 00 00 20  |... ..?........ |
    000001d0  0e 13 83 3e 18 26 40 b0  04 00 c0 af 04 00 00 00  |...>.&@.........|
    000001e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|

    Başka bir deyişle Disk Bölümleme Tablosu MBR sektörünün 0x1BE (446) offset'inden başlayıp 64 byte sürmektedir. Disk Bölümleme 
    Tablosu'ndaki her disk bölümü 16 byte ile betimlenmektedir. Dolayısıyla klasik Disk Bölümleme Tablosu 4 disk bölümünü barındırmaktadır. 
    Pekiyi bu durumda 4'ten fazla disk bölümü oluşturulamaz mı? İşte "Genişletilmiş Disk Bölümü (Extended Disk Partition)" kavramı 
    ile bu durum mümkün hale getirilmiştir. Yukarıdaki Disk Bölümleme Tablosu'nun 16 byte'lık disk bölümleri aşağıda verilmiştir:

    80 01 01 00 83 20 0d 13  3f 00 00 00 01 b0 04 00
    00 20 0e 13 83 3e 18 26  40 b0 04 00 c0 af 04 00
    00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00

    Disk Bölümleme Tablosu'ndaki 16 byte'lık disk bölümünün içeriği şöyledir:

    +--------------+----------------+---------------------------------------------------------------------+
    | Offset (Hex) |     Uzunluk    |                               Anlamı                                |
    +--------------+----------------+---------------------------------------------------------------------+
    |       0      |     1 BYTE     | Disk Bölümünün Aktif Olup Olmadığı Bilgisi                          |
    |       1      |     3 BYTE     | Disk Bölümünün Eski Sistemdeki (CHS Sistemindeki) Başlangıç Sektörü |
    |       4      |     1 BYTE     | Sistem ID Değeri                                                    |
    |       5      |     3 BYTE     | Disk Bölümünün Eski Sistemdeki (CHS Sistemindeki) Bitiş Sektörü     |
    |       8      | 4 BYTE (DWORD) | Disk Bölümünün LBA Sistemindeki Başlangıç Sektörü                   |
    |       C      | 4 BYTE (DWORD) | Disk Bölümündeki Sektör Sayısı (Disk Bölümünün Uzunluğu)            |
    +--------------+----------------+---------------------------------------------------------------------+

    - 4 disk bölümünden yalnızca bir tanesi aktif olabilmektedir. Sistem aktif disk bölümünden boot edilmektedir. Aktif disk 
    bölümü için 0x80 değeri, aktif olmayan disk bölümü için 0x00 değeri kullanılmaktadır.

    - Eskiden diskteki bir sektörün yeri "hangi yüzde (her yüzü bir kafa okuduğu için, hangi kafada), hangi track'te (track'e 
    silindir (cylinder) de denilmektedir) ve hangi sektör diliminde olduğu bilgisiyle ifade ediliyordu. Bu koordinat sistemine
    CHS (Cylinder-Head-Sector) koordinat sistemi deniyordu. Sonra bu koordinat sisteminden vazgeçildi. Sektörün yeri ilk sektör 
    0 olmak üzere tek bir sayıyla temsil edilmeye başlandı.

    - Her disk bölümünde farklı bir işletim sisteminin kullandığı dosya sistemi bulunuyor olabilir. "Sistem ID Değeri" o disk 
    bölümünde hangi işletim sistemine ilişkin bir dosya sisteminin bulunduğunu belirtmektedir. Böylece Disk Bölümleme Tablosu'nu 
    inceleyen kişiler disk bölümlerinin hangi işletim sistemi için oluşturulduğunu anlayabilmektedir. Tüm Sistem ID Değerleri 
    için bunların listelendiği dokümanlara başvurabilirsiniz. Biz burada birkaç System ID değerini verelim:

    0C: Windows FAT32 Sistemi
    0E: Windows FAT Sistemi
    0F: Genişletilmiş Disk Bölümü
    83: Linux Dosya Sistemlerinden Birisi
    82: Linux İçin Swap Alanı Olarak Kullanılacak Disk Bölümü

    - Bir disk bölümü için en önemli iki bilgi onun diskin hangi sektöründen başlayıp kaç sektör uzunlukta olduğudur. Yani disk 
    bölümünün başlangıç sektör numarası ve toplam sektör sayısıdır. İşletim sistemleri böylece kendileri için belirlenmiş olan 
    disk bölümlerinin dışına erişmezler. Yani disk bölümleri adeta disk içerisindeki disklerin yerlerini belirtmektedir.

    - 90'lı yıllarla birlikte diskteki sektörlerin adreslenmesi için CHS sistemi yavaş yavaş bırakılmaya başlanmış LBA (Logical 
    Block Address) denilen sisteme geçilmiştir. Bu sistemde diskin ilk sektörü 0 olmak üzere her sektöre artan sırada bir tamsayı 
    karşılık düşürülmüştür. İşte bu koordinat sistemine LBA denilmektedir. Artık MBR Disk Bölümleri'nde disk bölümünün başlangıç 
    sektörü LBA sistemine göre belirtilmektedir.

    - LBA sisteminde bir disk bölümünde en fazla 2^32 tane sektör bulunabilir. Bir sektör 2^9 (512) byte olduğuna göre MBR
    Disk Bölümleme Tablosu en fazla 2^41 = 2TB diskleri destekleyebilmektedir. Gömülü sistemlerde henüz bu büyüklükte diskler 
    kullanılmadığı için klasik MBR Disk Bölümleme Tablosu iş görmektedir. Ancak masaüstü sistemlerde artık bu sınır aşılmaktadır. 
    İşte UEFI BIOS'lar tarafından kullanılan "GUID Disk Bölümlemesi (GPT)" bu sınırı çok daha ötelere taşımaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Disk Bölümleme Tablosu manuel bir biçimde oluşturulabilir. Ancak Disk Bölümleme Tablosu üzerinde işlem yapan çeşitli 
    araçlar da vardır. Linux sistemlerinde en yaygın kullanılan iki araç "fdisk" ve "gparted" isimli araçlardır. fdisk komut 
    satırından kullanılabilen basit bir programdır. "gparted" ise GUI arayüzü ile görsel bir biçimde aynı işlemleri yapmaktadır. 
    "fdisk" temel bir araçtır. Dolayısıyla Linux sistemleri kurulduğunda büyük olasılıkla zaten kurulmuş olarak sisteminizde 
    bulunuyor olacaktır. Ancak "gparted" programını Debian tabanlı sistemlerde aşağıdaki gibi siz kurmalısınız:

    $ sudo apt-get install gparted
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                187. Ders 22/12/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bu noktada Linux sistemlerindeki fdisk programının kullanımı üzerinde duracağız. Bu tür denemeleri loop aygıtları üzerinde 
    yapmalısınız. fdisk kullanımını maddeler halinde açıklayalım:

    1) Hangi disk üzerinde işlem yapılacaksa o diske ilişkin aygıt dosyası fdisk programına komut satırı argümanı olarak 
    verilmelidir. Tabii disk aygıt dosyaları "root" kullanıcısına ilişkin olduğu için fdisk programı da genellikle "sudo" 
    ile çalıştırılır. Örneğin önce blok aygıt sürücülerimize bakalım:

    ******************************************************
    $ lsblk
    NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
    sda      8:0    0   80G  0 disk
    ├─sda1   8:1    0  512M  0 part /boot/efi
    ├─sda2   8:2    0    1K  0 part
    └─sda5   8:5    0 79,5G  0 part /
    sr0     11:0    1 1024M  0 rom
    ******************************************************

    Burada "sda" diski bir bütün olarak gösteren aygıt sürücüsüdür. Bu aygıt sürücüye ilişkin aygıt dosyası "/dev/sda" biçimindedir. 
    "sda1", "sda2" ve "sda5" disk üzerindeki disk bölümleridir. Bizim bölümlendirme için diski bir bütün olarak ele almamız gerekir. 
    Bu nedenle "sda" diski için fdisk programı şöyle çalıştırılmalıdır:

    $ sudo fdisk /dev/sda

    Tabi biz örneğimizde loop aygıtı kullanacağız. Bu durumda loop aygıtını şöyle kullanıma hazır hale getirebiliriz:

    ******************************************************
    $ dd if=/dev/zero of=disk.img bs=300M count=1
    1+0 kayıt girdi
    1+0 kayıt çıktı
    314572800 bytes (315 MB, 300 MiB) copied, 1,23241 s, 255 MB/s
    ******************************************************

    Buradan diski temsil eden içi sıfırlarla dolu 300MB'lik bir dosya oluşturduk. Şimdi bu dosyayı "/dev/loop0" aygıt dosyası 
    ile bir blok aygıtı gibi gösterelim:

    $ sudo losetup /dev/loop0 disk.img

    Artık "/dev/loop0" aygıt dosyası sanki bir disk gibi kullanılabilecektir. Bu aygıt üzerinde işlem yaptığımızda işlemden 
    "disk.img" dosyası etkilenecektir.

    Artık blok aygıt sürücülerine baktığımızda "loop0" aygıtını göreceğiz:

    ******************************************************
    $ lsblk
    NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
    loop0    7:0    0  300M  0 loop
    sda      8:0    0   80G  0 disk
    ├─sda1   8:1    0  512M  0 part /boot/efi
    ├─sda2   8:2    0    1K  0 part
    └─sda5   8:5    0 79,5G  0 part /
    sr0     11:0    1 1024M  0 rom
    *****************************************************

    Artık fdisk programını bu aygıt üzerinde kullanabiliriz:

    $ sudo fdisk /dev/loop0

    2) Artık interaktif bir biçimde disk bölümlendirme işlemleri yapılabilir. Burada tek harfli çeşitli komutlar girildiğinde
    interaktif bir biçimde işlemler yapılmaktadır. Bu komutlardan önemli olanlarını açıklamak istiyoruz:

    - "n" (new) komutu yeni bir disk bölümü oluşturmak için kullanılmaktadır. Bu komut verildiğinde yaratılacak disk bölümünün 
    "primary" bölüm mü "extended" bölüm mü olduğu sorulmaktadır. Primary disk bölümü ana 4'lük girişteki bölümlerdir. Dolayısıyla
    burada genellikle "p" komutu ile "primary" disk bölümü oluşturulur. Sonra bize 4 girişten hangisinin disk bölümü olarak 
    oluşturulacağı sorulmaktadır. Bu durumda sıradaki numarayı vermek (disk tamamen ilk kez bölümlendiriliyorsa 1) uygun olur. 
    Sonra da bize ilgili disk bölümünün hangi sektörden başlatılacağı ve ne uzunlukta olacağı sorulmaktadır. Aşağıda bir örnek 
    görüyorsunuz:

    **************************************************************************************
    Komut (yardım için m): n
    Disk bölümü tipi
    p   birincil (0 birincil, 0 genişletilmiş, 4 boş)
    e   genişletilmiş (mantıksal disk bölümleri için konteyner)
    Seç (varsayılan p): p
    Disk bölümü numarası (1-4, varsayılan 1): 1
    İlk sektör (2048-614399, varsayılan 2048):
    Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-614399, varsayılan 614399): +50M

    Yeni bir disk bölümü 1, 'Linux' tipinde ve 50 MiB boyutunda oluşturuldu.
    ***************************************************************************************

    - "p" (print) komutu oluşturulmuş olan disk bölümlerini görüntülemektedir. Örneğin:

    **************************************************************************************
    Komut (yardım için m): p
    Disk /dev/loop0: 300 MiB, 314572800 bayt, 614400 sektör
    Birimler: sektör'i 1 * 512 = 512 baytın
    Sektör boyutu (mantıksal/fiziksel): 512 bayt / 512 bayt
    G/Ç boyutu (en düşük/en uygun): 512 bayt / 512 bayt
    Disketikeri tipi: dos
    Disk belirleyicisi: 0x267a62e0

    Aygıt        Açılış Başlangıç    Son Sektör Boyut ld Türü
    /dev/loop0p1             2048 104447 102400   50M 83 Linux
    **************************************************************************************

    - fdisk yaratılan disk bölümlerinin ID'sini default olarak 0x83 (Linux) yapmaktadır. Eğer disk bölümüne FAT dosya sistemi 
    yerleştirilecekse "t" (type) komutu ile bölüm ID'si değiştirilmelidir. Örneğin:

    **************************************************************************************
    Komut (yardım için m): t
    Seçilen disk bölümü 1
    Hex kod (bütün kodlar için L tuşlayın): c
    'Linux' disk bölümünün tipini 'W95 FAT32 (LBA)' olarak değiştirin.

    Komut (yardım için m): p
    Disk /dev/loop0: 300 MiB, 314572800 bayt, 614400 sektör
    Birimler: sektör'i 1 * 512 = 512 baytın
    Sektör boyutu (mantıksal/fiziksel): 512 bayt / 512 bayt
    G/Ç boyutu (en düşük/en uygun): 512 bayt / 512 bayt
    Disketikeri tipi: dos
    Disk belirleyicisi: 0x267a62e0

    Aygıt        Açılış Başlangıç    Son Sektör Boyut ld Türü
    /dev/loop0p1             2048 104447 102400   50M  c W95 FAT32 (LBA)
    **************************************************************************************

    Şu anda biz bir FAT disk bölümü yaratmış olduk. Şimdi ikinci Linux dosya sistemleri için ikinci bölümünü de yaratalım:

    **************************************************************************************
    Komut (yardım için m): n
    Disk bölümü tipi
    p   birincil (1 birincil, 0 genişletilmiş, 3 boş)
    e   genişletilmiş (mantıksal disk bölümleri için konteyner)
    Seç (varsayılan p): p
    Disk bölümü numarası (2-4, varsayılan 2):
    İlk sektör (104448-614399, varsayılan 104448):
    Last sector, +/-sectors or +/-size{K,M,G,T,P} (104448-614399, varsayılan 614399):

    Yeni bir disk bölümü 2, 'Linux' tipinde ve 249 MiB boyutunda oluşturuldu.

    Komut (yardım için m): p
    Disk /dev/loop0: 300 MiB, 314572800 bayt, 614400 sektör
    Birimler: sektör'i 1 * 512 = 512 baytın
    Sektör boyutu (mantıksal/fiziksel): 512 bayt / 512 bayt
    G/Ç boyutu (en düşük/en uygun): 512 bayt / 512 bayt
    Disketikeri tipi: dos
    Disk belirleyicisi: 0x267a62e0

    Aygıt        Açılış Başlangıç    Son Sektör Boyut ld Türü
    /dev/loop0p1             2048 104447 102400   50M  c W95 FAT32 (LBA)
    /dev/loop0p2           104448 614399 509952  249M 83 Linux
    **************************************************************************************

    Artık diskimizde iki disk bölümü vardır.

    - Bir disk bölümünü aktive etmek için "a" komutu (activate) kullanılmaktadır. Örneğin biz FAT32 disk bölümünü aktif disk 
    bölümü haline getirelim:

    **************************************************************************************
    Komut (yardım için m): a
    Disk bölümü numarası (1,2, varsayılan 2): 1

    Disk bölümü 1'de önyüklenebilir bayrağı artık etkin.

    Komut (yardım için m): p
    Disk /dev/loop0: 300 MiB, 314572800 bayt, 614400 sektör
    Birimler: sektör'i 1 * 512 = 512 baytın
    Sektör boyutu (mantıksal/fiziksel): 512 bayt / 512 bayt
    G/Ç boyutu (en düşük/en uygun): 512 bayt / 512 bayt
    Disketikeri tipi: dos
    Disk belirleyicisi: 0x267a62e0

    Aygıt        Açılış Başlangıç    Son Sektör Boyut ld Türü
    /dev/loop0p1 *           2048 104447 102400   50M  c W95 FAT32 (LBA)
    /dev/loop0p2           104448 614399 509952  249M 83 Linux
    **************************************************************************************

    - fdisk önce yazılacakları kendi içerisinde biriktirmekte sonra bunları diske yazmaktadır. Biriktirilenlerin diske yazılması 
    için "w" (write) komutu kullanılmaktadır. Örneğin:

    **************************************************************************************
    Komut (yardım için m): w
    Disk bölümleme tablosu değiştirildi.
    Disk bölüm tablosunu yeniden okumak için ioctl() çağrılıyor.
    Disk bölümü tablosu yeniden okunamadı.: Geçersiz bağımsız değişken

    Çekirdek hala eski tabloyu kullanıyor. Yeni tablo bir sonraki yeniden başlatma işleminden sonra ya da partprobe(8) veya 
    kpartx(8)'i çalıştırdığınızda kullanılacak.
    **************************************************************************************

    - Bir disk bölümünü silmek için "d" komutu kullanılmaktadır. Disk bölümlerini silerken dikkat ediniz.

    3) Disk bölümlerini oluşturduktan sonra çekirdeğin onları o anda görmesi için "partprobe" komutu kullanılmalıdır. Örneğin:

    **************************************************************************************
    $ sudo partprobe /dev/loop0
    [sudo] kaan için parola:
    $ lsblk
    NAME      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
    loop0       7:0    0  300M  0 loop
    ├─loop0p1 259:0    0   50M  0 part
    └─loop0p2 259:1    0  249M  0 part
    sda         8:0    0   80G  0 disk
    ├─sda1      8:1    0  512M  0 part /boot/efi
    ├─sda2      8:2    0    1K  0 part
    └─sda5      8:5    0 79,5G  0 part /
    sr0        11:0    1 1024M  0 rom
    **************************************************************************************

    Aslında yukarıda yapılan işlemlerin sonucu olarak Disk Bölümleme Tablosu'ndaki iki giriş (32 byte) güncellenmiştir.

    5) fdisk programının başka komutları da vardır. Örneğin disk bölümlendirmesi yapıldıktan sonra bu bölümlendirme bilgileri 
    "O" komutu ile bir dosyaya aktarılabilir. Sonra "I" komutu ile bu dosyadan yükleme yapılabilir. Böylece farklı diskler 
    için aynı işlemlerin daha kolay yapılması sağlanabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz modern Linux sistemlerinde yetki gerektiren programları "sudo" komutuyla ("sudo" bir programdır) çalıştırmaktayız. 
    Bir programı "sudo" ile çalıştırdığımızda yaratılan prosesin etkin kullanıcı id'si 0 ve etkin grup id'si, gerçek kullanıcı 
    id'si ve gerçek grup id'si 0 olur. Kullanıcı id'si sıfır olan kullanıcı genellikle "root" ismiyle bulundurulmaktadır. Pek 
    çok UNIX türevi sistemde aynı zamanda 0 numaralı bir grup da bulunmaktadır. Bu da genellikle "root" biçiminde isimlendirilmektedir. 
    Yani "root" isminde hem bir kullanıcı hem de bir grup bulunmaktadır. Anımsanacağı gibi prosesin etkin grup id'sinin 0 olması 
    hiçbir erişim ayrıcalığı oluşturmamaktadır. Asıl olan "etkin kullanıcı id'sinin" 0 olmasıdır. Anımsanacağı gibi Linux sistemleri 
    install edilirken kurulum sırasında kullanıcının girdiği isimle aynı olan bir kullanıcı ismi ve grup ismi oluşturulmaktadır. 
    Kullanıcı ve grup id'lerinin farklı isim alanlarında olduğunu anımsayınız. Örneğin 1000 numaralı bir kullanıcı id'si de olabilir, 
    bir grup id'si de olabilir. Ancak aynı id'ye sahip birden fazla kullanıcı ya da grup olmamalıdır. (Tabii bu durum aslında 
    yasak değildir. Yani biz örneğin etkin kullanıcı id'si 0 olan başka bir kullanıcı da yaratabiliriz. Çekirdek, isimleri 
    değil numaraları işleme sokmaktadır.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir programı "sudo" ile çalıştırdığımızda çalıştırılan programa ilişkin prosesin etkin ve gerçek kullanıcı id'sinin ve grup
    id'sinin 0 olduğunu belirtmiştik. Yani "sudo" ile bir programı çalıştırdığımızda adeta program "root" kullanıcısı tarafından 
    çalıştırılıyormuş gibi bir etki oluşmaktadır. Linux dağıtımlarının bir bölümünde "root" kullanıcısı ile "login" olma güvenlik
    gerekçesiyle engellenmiştir. Ancak bu dağıtımlarda "root" olarak "bash" komut satırına düşmek istiyorsanız "sudo" ile "bash" 
    programını çalıştırabilirsiniz. Örneğin:

    $ sudo bash

    Bir programı "sudo" ile çalıştırmak istediğimizde bizden önce kendi kullanıcımıza ilişkin parola istenmektedir. Ancak bir 
    süre içerisinde artık "sudo" yapıldığında parola istenmeyecektir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Her kullanıcı "sudo" yapamamaktadır. "sudo" yapabilen kullanıcılara "sudoer" denilmektedir. Sistem kurulurken kurulum
    programı tarafından yaratılan kullanıcı "sudoer" durumundadır. Bir kullanıcıyı "sudoer" yapabilmek için en basit yol o 
    kullanıcıyı "/etc/group" dosyasında "sudo" grubuna eklemektir. Örneğin kursun yapıldığı makinedeki "/etc/group" dosyasının 
    "sudo" grup satırı şöyledir:

    sudo:x:27:kaan

    Buradan "sudo" grubunun grup id'sinin 27 olduğu ve "kaan" kullanıcısının bu gruba ek grup (supplementary group) biçiminde 
    dahil olduğu görülmektedir. Şimdi biz "ali" kullanıcısının da "sudo" yapabilmesini istiyorsak "ali" kullanıcı ismini de 
    aşağıdaki gibi satıra eklemeliyiz:

    sudo:x:27:kaan,ali

    Aslında bu işlem komut satırında "usermod" komutu ile "-a" ve "-G" seçenekleri kullanılarak da yapılabilmektedir. Örneğin:

    $ sudo usermod -a -G sudo student

    Tabii bu komutu şöyle de uygulayabilirdik:

    $ sudo usermod -aG sudo student

    Kullanıcıya "sudo" yeteneği verebilmenin diğer bir yolu da "/etc/sudoers" dosyasına yeni bir giriş eklemektir. Biz burada 
    bu yöntem üzerinde durmayacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir programı "sudo" ile çalıştırdığımızda üst prosesin çevre değişkenleri default durumda çalıştırılan programa aktarılmamaktadır.
    Örneğin biz kabukta bazı çevre değişkenleri tanımlamış olalım. "sudo" ile bir program çalıştırdığımızda bu çevre değişkenleri 
    default durumda yaratılan prosese aktarılmayacaktır. Bunu basit bir biçimde deneyimleyebiliriz. Bunun için önce komut 
    satırında aşağıdaki gibi çevre değişkenleri oluşturabiliriz:

    $ export XXX=100
    $ export YYY=100

    Şimdi "env" komutunu uygularsak bu çevre değişkenlerinin yaratılmış olduğunu görürüz. Ancak "sudo env" komutunu uyguladığımızda
    bu çevre değişkenleri alt prosese aktarılmayacağı için onları göremeyeceğiz. Ancak kabuğun çevre değişkenleri çalıştırılan 
    programa ilişkin prosese "-E" seçeneği kullanılarak aktarılabilmektedir. Örneğin:

    $ sudo -E env

    Ancak "-E" seçeneği de güvenlik gerekçesiyle PATH çevre değişkenini yaratılan prosese geçirmemektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                188. Ders 27/12/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    sudo işlemi konusunda "/etc/sudoers" dosya da etkilidir. Bu dosyaya girişler eklenerek belli bir proses sudoer yapılabilmektedir. 
    Bu dosyanın başındaki aşağıdaki satırlar önemlidir:

    Defaults        env_reset
    Defaults        mail_badpass
    Defaults        secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin"
    Defaults        use_pty

    Buradaki "env_reset" satırında "env_reset" yerine "env_keep" getirilirse default olarak burada belirtilen çevre değişkenleri 
    sudo ile çalıştırılan proseslere aktarılmaktadır. Örneğin:

    Defaults    env_keep += "XX YY"

    Burada sudo ile bir program çalıştırıldığında alt prosese XX ve YY çevre değişkenleri aktarılacaktır. env_keep += "*"
    tüm çevre değişkenlerinin aktarılacağı anlamına gelir. Ancak yine PATH çevre değişkeni bunun dışındadır. Örneğin:

    Defaults    env_keep += "*"

    Eğer PATH çevre değişkeninin de yaratılan prosese aktarılması isteniyorsa secure_path satırı kaldırılmalı ya da # ile 
    yorum satırı içerisine alınmalıdır. Örneğin:

    Defaults        env_reset
    Defaults        mail_badpass
    # Defaults      secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin"
    Defaults        use_pty
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Klasik UNIX tasarımında erişim bakımından "ya hep ya hiç" sistemi uygulanmaktadır. Yani sıradan kullanıcılar sistemle 
    ilgili önemli dosyalara erişemezler ve sistemde davranış değişikliklerine yol açabilecek sistem fonksiyonlarını çağıramazlar. 
    Ancak prosesin kullanıcı id'si 0 ise (yani proses "root" hakkına sahipse) her şeyi yapabilirler. Bazı UNIX türevi sistemlerde 
    bu "ya hep ya hiç" sistemi "yeteneklilik (capability)" denilen kavramla yumuşatılmıştır. Bu sistemlerde çeşitli yetenekler 
    vardır. Bir proses root hakkına sahip olmasa bile bu yeteneklerden bazılarına sahip olabilir. Bu durumda bu yetenekleri 
    gerektiren bazı işlemleri yapabilir.

    Yeteneklilik (capability) konusu POSIX standartlarına sokulmamıştır. POSIX standartları genel olarak "uygun öncelik 
    (appropriate privileges)" terimini kullanmaktadır. Burada uygun öncelik prosesin root önceliğinde olması ya da ilgili 
    işlemi yapacak yeteneğe sahip olması anlamına gelmektedir.

    Yeteneklilik konusu POSIX tarafından standardize edilmiş bir konu olmadığı için farklı UNIX türevi sistemlerde farklı 
    biçimlerde gerçekleştirilmiştir. Ancak bunlar arasında en geniş tasarıma sahip olan Linux sistemleridir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir thread'in sahip olabileceği yetenekler proses kontrol bloğunda bitsel bir biçimde tutulmaktadır. Linux'taki yetenekler
    şunlardır:

    CAP_CHOWN: Dosya sahibi ve grup değiştirme yeteneği.
    CAP_DAC_OVERRIDE: Dosya erişim kontrollerini geçme yeteneği (okuma/yazma/çalıştırma).
    CAP_DAC_READ_SEARCH: Dosya okuma ve dizin arama izinlerini geçme yeteneği.
    CAP_FOWNER: Dosya üzerinde, sahibi tarafından yapılan işlemleri yapma yeteneği (örneğin dosyanın erişim özelliklerinin 
    değiştirilmesi gibi)
    CAP_FSETID: Dosyanın UID veya GID’sini değiştirme yeteneği.
    CAP_KILL: Diğer proseslere sinyal gönderme yeteneği.
    CAP_SETGID: Kullanıcı grubunu değiştirme yeteneği.
    CAP_SETUID: Kullanıcı kimliğini değiştirme yeteneği.
    CAP_SETPCAP: Process yetenekliliğini değiştirme yeteneği.
    CAP_SETFCAP: Bir dosyanın yeteneklerini değiştirme yeteneği
    CAP_LINUX_IMMUTABLE: Bir dosyanın değiştirilemez (immutable) hale getirilmesini sağlama yeteneği.
    CAP_NET_BIND_SERVICE: Düşük numaralı portlara (1024'ten küçük) bağlanma yeteneği.
    CAP_NET_BROADCAST: Ağda broadcast (yayın) yapma yeteneği.
    CAP_NET_ADMIN: Ağ ayarlarını yönetme, ağ arayüzlerini yapılandırma yeteneği.
    CAP_NET_RAW: Düşük seviyeli ağ işlemleri yapabilme yeteneği.
    CAP_IPC_LOCK: Bellek üzerinde kilit (lock) işlemleri yapma yeteneği.
    CAP_IPC_OWNER: IPC (Inter-process communication) kaynaklarının sahipliğini değiştirme yeteneği.
    CAP_SYS_MODULE: Linux modüllerini yükleme ve kaldırma yeteneği.
    CAP_SYS_RAWIO: Donanımsal I/O portlarına erişme yeteneği
    CAP_SYS_CHROOT: chroot (root dosya sistemi değiştirme) işlemi yapma yeteneği.
    CAP_SYS_PTRACE: Diğer süreçleri izleme ve kontrol etme yeteneği (örneğin, hata ayıklama).
    CAP_SYS_PACCT: Process accounting verilerini okuma veya yazma yeteneği.
    CAP_SYS_ADMIN: Sistem yöneticisi yetkileri (modül yükleme, dosya sistemi değiştirme vb.).
    CAP_SYS_BOOT: Sistemi yeniden başlatma veya açma yeteneği.
    CAP_SYS_NICE: Diğer proseslerin nice değerini değiştirme yeteneği.
    CAP_SYS_RESOURCE: Sistem kaynaklarını yönetme ve limitlerini ayarlama yeteneği.
    CAP_SYS_TIME: Sistemin saatini değiştirme yeteneği.
    CAP_SYS_TTY_CONFIG: TTY (terminal) ayarlarını değiştirme yeteneği.
    CAP_MKNOD: Aygıt dosyaları oluşturma yeteneği.
    CAP_LEASE: Dosya kiralama (lease) mekanizmasını kullanma yeteneği.
    CAP_AUDIT_WRITE: Audit (denetim) sistemine yazma yeteneği.
    CAP_AUDIT_CONTROL: Audit sistemi yapılandırmalarını değiştirme yeteneği.
    CAP_SETFCAP: Dosya yetenekliliğini (capabilities) ayarlama yeteneği.
    CAP_MAC_OVERRIDE: MAC (Mandatory Access Control) politikalarını geçme yeteneği.
    CAP_MAC_ADMIN: MAC politikalarını yönetme yeteneği.
    CAP_SYSLOG: Sistem günlüklerini (log) okuma veya yazma yeteneği.
    CAP_WAKE_ALARM: Sistemi uyanma alarmıyla uyandırma yeteneği.
    CAP_BLOCK_SUSPEND: Sistemin uykuya geçmesini engelleme yeteneği.
    CAP_AUDIT_READ: Audit verilerini okuma yeteneği.
    CAP_PERFMON: Performans izleme (profiling) yeteneği.
    CAP_BPF: BPF (Berkeley Packet Filter) programlarını yükleme ve çalıştırma yeteneği.
    CAP_CHECKPOINT_RESTORE: Bir süreç için checkpoint alma ve geri yükleme yeteneği.

    Örneğin biz kill fonksiyonuyla kabaca yalnızca kendimizin oluşturduğu proseslere sinyal gönderebiliriz. Ancak eğer prosesimizin
    CAP_KILL yetenekliliği varsa bu durumda tıpkı root prosesi gibi başka proseslere de sinyal gönderebiliriz.

    Linux sistemlerindeki yeteneklilik (capability) konusu maalesef biraz karmaşık bir konudur. İzleyen paragraflarda konunun
    ayrıntılarına gireceğiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında Linux sistemlerinde yeteneklilik proses temelinde değil thread temelinde uygulanmaktadır. Yani prosesin farklı 
    thread'leri farklı yeteneklere sahip olabilmektedir. Ancak pratikte prosesin tüm thread'leri genellikle aynı yeteneklere 
    sahip olur. Yetenekler proses kontrol bloğunda bitsel düzeyde tutulmaktadır. Yani yukarıdaki listedeki CAP_XXX sembolik 
    sabitleri aslında tüm bitleri 0 olan yalnızca tek biti 1 olan sembolik sabitlerdir. Eskiden proses kontrol bloğunda yetenekleri 
    tutan nesneler 32 bitlik nesnelerdi. Sonra çeşitli yetenekler de sisteme eklenince bunlar 64 bite yükseltildiler. Bugünkü
    Linux çekirdeklerinde thread'e ilişkin yetenekler task_struct yapısının cred isimli elemanının gösterdiği struct cred
    yapısında tutulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir thread'in dört grup yetenekleri vardır: Etkin yetenekler (effective capabilities), izin verilen yetenekler (permitted 
    capabilities), aktarılan yetenekler (inheritable capabilities) ve sarmalayan yetenekler (bounding capabilities). Test 
    işlemlerine etkin yetenekler sokulmaktadır. Örneğin thread'imizin başka bir prosese sinyal gönderebilmesi için thread'imizin 
    etkin yetenekleri arasında CAP_KILL bulunuyor olması gerekir. İzin verilen yetenekler (permitted capabilities) etkin yetenekler 
    için bir üst küme oluşturmaktadır. Yani bir thread'in kendisinin etkin yetenekleri ancak izin verilen yetenekleri kadar olabilir. 
    Thread'in bir etkin yetenek kümesinde bir yetenek yoksa ancak izin verilen kümesinde varsa proses izin verilen kümesi içerisindeki 
    o yeteneği etkin kümesine taşıyabilir. Ancak izin verilen kümesini genişletemez. Başka bir deyişle thread'in etkin yetenek 
    kümesi izin verilen yetenek kümesinin bir alt kümesi biçimindedir. Aktarılabilen yetenek kümesi, thread bir programı çalıştırdığında 
    onun izin verilen kümesine dahil edilebilecek yetenekleri belirtmektedir. Benzer biçimde thread'in sarmalayan yetenekleri 
    de izin verilen yeteneklerin belirlenmesi sırasında etki göstermektedir. Bu konu izleyen paragraflarda ele alınacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda Linux çekirdeğinin yetenekleri thread temelinde işleme soktuğunu belirttik. Yetenekler fork işlemi sırasında
    ya da pthread_create işlemi sırasında (bu da bir çeşit fork işlemi gibidir) üst thread'ten alt thread'e aktarılmaktadır. 
    Yani aslında default durumda bir prosesin tüm thread'leri aynı yeteneklere sahiptir. Fakat biz istersek prosesin belli bir 
    thread'inin yeteneklerini diğer thread'lere dokunmadan değiştirebiliriz. Üst proses fork uyguladığında onun "etkin", "izin 
    verilen" ve "aktarılan" yeteneklerinin hepsi alt prosese aktarılmaktadır.

    Herhangi bir önceliğe sahip olmayan sıradan proseslerin etkin, izin verilen ve aktarılan yetenek kümesinde hiçbir yetenek 
    yoktur. Örneğin biz bir terminal açıp orada çalışan kabuk programının (bash) yetenek kümelerine baksak bu üç yetenek kümesinin
    de boş küme olduğunu görürüz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde thread'in yeteneklerini elde etmek ve set etmek için sys_getcap ve sys_setcap isimli iki sistem fonksiyonu 
    bulundurulmuştur. Ancak libc kütüphanesinde bu sistem fonksiyonlarını çağıran fonksiyonlar bulunmamaktadır. Eğer bu sistem 
    fonksiyonlarını çağıracaksanız bunların numaralarını belirterek syscall isimli fonksiyonla çağırabilirsiniz. Ancak bu sistem 
    fonksiyonlarının kullanımı biraz zahmetlidir. Bu fonksiyonlar yerine bu sistem fonksiyonları çağrılarak yazılmış olan "libcap" 
    isimli bir kütüphane de bulunmaktadır. Sistem programcıları genellikle sys_getcap ve sys_setcap fonksiyonlarını kullanmak yerine 
    zaten bunları kullanan "libcap" kütüphanesini kullanmayı tercih etmektedir. Ancak bu "libcap" kütüphanesi default durumda 
    genellikle yüklü olmaz. Bu kütüphaneyi Debian türevi sistemlerde aşağıdaki gibi yükleyebilirsiniz.

    $ sudo apt install libcap2 libcap-dev
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosesin yetenek kümeleri "/proc/<pid>/status" dosyasından elde edilebilir. Buradaki yeteneklere ilişkin bilgiler 
    aşağıdaki gibi gözükecektir:

    CapInh:    0000000000000000
    CapPrm:    0000000000000000
    CapEff:    0000000000000000
    CapBnd:    000001ffffffffff

    Bu örnekte prosesin bütün yetenek kümesi boştur. Yani proses hiçbir yeteneğe sahip değildir. Anımsanacağı gibi aslında 
    "proc" dosya sisteminde her thread için bir dizin yaratılmaktadır. Yani "/proc/<pid>/status" yol ifadesindeki pid aslında 
    ilgili thread'in gettid fonksiyonu ile elde edilen pid numarasıdır. (POSIX standartlarında thread'lerin pid değerinin 
    olmadığını ancak Linux sistemlerinde Linux çekirdeğinin thread'leri prosesler gibi oluşturduğu için thread'lerin de pid 
    değerlerinin olduğunu anımsayınız. Yine anımsanacağı gibi proc dosya sisteminde ana thread'e ilişkin "task" dizininde 
    prosesin thread'lerinin pid numaraları bulunmaktadır.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir thread'in yetenekleri programlama yoluyla "libcap" kütüphanesindeki cap_get_proc fonksiyonu ile elde edilebilir. Fonksiyon 
    kendisini çağıran thread'in yetenek bilgilerini temsil eden cap_t türünden bir handle değeri ile geri döner.

    #include <sys/capability.h>

    cap_t cap_get_proc(void);

    cap_t türü aşağıdaki gibi bildirilmiştir:

    typedef struct __user_cap_header_struct {
        unsigned int version;        // Yapı versiyonu
        pid_t pid;                    // İlgili işlem ID'si
    } __user_cap_header_t;

    typedef struct __user_cap_data_struct {
        unsigned int effective;        // Etkin yetenekler
        unsigned int permitted;        // İzin verilen yetenekler
        unsigned int inheritable;    // Miras alınan yetenekler
    } __user_cap_data_t;

    typedef struct __user_cap_struct {
        __user_cap_header_t header;    // Başlık bilgisi
        __user_cap_data_t data[2];    // Yetenek verisi (genellikle iki set)
    } *cap_t;

    Örneğin:

    cap_t caps;

    if ((caps = cap_get_proc()) == NULL)
        exit_sys("get_cap_proc");

    cap_get_pid fonksiyonu ise pid değeri verilen prosesin (ya da thread'in) yeteneklerini elde etmektedir. Fonksiyonun prototipi
    şöyledir:

    cap_t cap_get_pid(pid_t pid);

    cap_t türünün bir yapı adresini belirttiğine dikkat ediniz. Bu fonksiyonlar kendi içerisinde cap_t türünden bir yapı nesnesini 
    dinamik olarak tahsis edip onun adresiyle geri dönmektedir. Bu dinamik alanın boşaltımı cap_free fonksiyonu ile yapılmalıdır:

    #include <sys/capability.h>

    int cap_free(void *obj_d);

    Aslında cap_free fonksiyonu yalnızca free fonksiyonunu çağırmaktadır.

    Örneğin:

    if ((caps = cap_get_proc()) == NULL)
        exit_sys("get_cap_proc");

    /* ... */

    cap_free(caps);

    Her ne kadar cap_get_pid fonksiyonu sanki proses id alıyor gibiyse de yukarıda da belirttiğimiz gibi yetenekler aslında
    prosese değil thread'e özgüdür. Biz bu fonksiyona bir prosesin pid değerini geçirdiğimizde o prosesin ana thread'ine ilişkin
    yetenekleri elde etmiş oluruz. Belli bir thread'in bilgileri elde edilecekse doğrudan gettid fonksiyonu ile thread'in 
    pid değeri elde edilebilir. cap_get_proc fonksiyonu ise o anda çalışmakta olan thread'in yeteneklerini elde etmekte 
    kullanılmaktadır.

    Thread'in yetenekleri elde edildiğinde onların yazdırılması da bir sorundur. Bu nedenle "libcap" kütüphanesinde cap_to_text
    isimli bir fonksiyon bulundurulmuştur. Fonksiyonun prototipi şöyledir:

    #include <sys/capability.h>

    char *cap_to_text(cap_t caps, ssize_t *length_p);

    Fonksiyonun birinci parametresi cap_t türünden handle değerini, ikinci parametresi verilen yazının uzunluğunun yerleştirileceği
    nesnenin adresini belirtir. İkinci parametre NULL adres geçilebilir. Bu durumda fonksiyon böyle bir yerleştirme yapmaz. 
    Fonksiyon oluşturulan yazının adresine geri dönmektedir. Yine bu adresin de kullanımdan sonra cap_free ile boşaltılması gerekir. 
    Eğer cap_to_text fonksiyonunda yalnızca "=" biçiminde bir yazı elde ediliyorsa bu durum thread'in herhangi bir yeteneğe 
    sahip olmadığı anlamına gelmektedir.

    Aşağıda o anda çalışmakta olan thread'in yetenekleri ekrana yazdırılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/capability.h>

void exit_sys(const char *msg);

int main(void)
{
    cap_t caps;
    char *captext;

    if ((caps = cap_get_proc()) == NULL)
        exit_sys("cap_get_proc");

    if ((captext = cap_to_text(caps, NULL)) == NULL) {
        cap_free(caps);
        exit_sys("cap_to_text");
    }

    printf("%s\n", captext);

    cap_free(captext);
    cap_free(caps);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                189. Ders 05/01/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir thread'in yetenekleri onu yaratan thread'ten aktarılmaktadır. Yani genel olarak bir proses bir thread yarattığında 
    ya da fork işlemi yaptığında yaratılan thread ya da proses bu işlemi uygulayan thread ile aynı yeteneklere sahip olur. 
    Sıradan bir prosesin ya da onun thread'lerinin yeteneklerine baktığımızda tipik olarak şöyle olduğunu görürüz:

    CapInh:    0000000000000000
    CapPrm:    0000000000000000
    CapEff:    0000000000000000
    CapBnd:    000001ffffffffff

    Buradan çıkan sonuç şudur: Sıradan bir prosesin ya da thread'in aktarılan, izin verilen ve etkin yetenek kümesi boş 
    kümedir. Yani bu küme hiçbir yeteneği kapsamamaktadır. Ancak sarmalayan yeteneklerin (bounding capabilities) bütün bitlerinin
    1 olduğunu görüyorsunuz. (Her ne kadar burada yüksek anlamlı bitlerin bazılarını 0 görüyor olsanız da zaten Linux o bitleri 
    kullanmamaktadır.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Etkin kullanıcı id'si 0 olan proseslerin hiçbir engele takılmadığını anımsayınız. Linux çekirdeği önce prosesin etkin 
    kullanıcı id'sini kontrol etmektedir. Eğer prosesin etkin kullanıcı id'si 0 ise zaten herhangi bir yetenek kontrolü 
    yapmasına gerek kalmamaktadır. Yani yetenekler ancak etkin kullanıcı id'si 0 olmayan prosesler için anlamlı bir özelliktir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi sıradan bir prosesin tüm thread'lerinin yetenekleri boş küme olduğuna göre bu prosesler ve thread'ler nasıl yetenek 
    kazanmaktadır? İşte bunun iki yolu olabilir:

    1) Yetenek kazandırabilecek yeteneğe sahip ya da etkin kullanıcı id'si 0 olan bir proses bir alt proses yaratıp onun 
    yeteneklerini oluşturup sonra kullanıcı id'sini 0 olmaktan çıkartabilir.

    2) Aslında Linux sistemlerinde çalıştırılabilen dosyalara da yetenekler atanabilmektedir. Bir çalıştırılabilen dosya exec
    fonksiyonlarıyla çalıştırıldığında izleyen paragraflarda açıklanacağı gibi otomatik olarak proses bazı yeteneklere sahip
    olabilmektedir. Bu durum aslında daha önce gördüğümüz çalıştırılabilen dosyaların "set-user-id" ve "set-grup-id" bayraklarına
    benzemektedir. Örneğin thread'imizin yetenek kümeleri boş küme olsun. Ama biz "xxx" isimli programı exec fonksiyonlarıyla
    çalıştırmak isteyelim. Bir kez fork yapıp alt proseste exec yaptığımızda artık alt prosesimizin yetenekleri bu "xxx" 
    dosyasında belirtilen yeteneklere sahip olabilmektedir. Yani proseslerin ve thread'lerin yetenekleri aslında genellikle 
    exec işlemi sırasında boş küme olmaktan çıkmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi thread'imize belli bir yeteneği nasıl kazandırabiliriz? Bir thread etkin yeteneklerini ancak izin verilen yetenekler 
    kadar artırabilir. O halde önce thread'imizin izin verilen yeteneklerini artırması gerekir. Bunun için sırasıyla şu işlemler
    yapılmalıdır:

    1) Önce içi boş bir yetenek nesnesi cap_init fonksiyonuyla oluşturulur. cap_init fonksiyonunun prototipi şöyledir:

    #include <sys/capability.h>

    cap_t cap_init(void);

    cap_init fonksiyonu başarısızlık durumunda NULL adrese geri dönmektedir.

    Örneğin:

    cap_t newcaps;

    if ((newcaps = cap_init()) == NULL)
        exit_sys("cap_init");

    2) Bu yetenek nesnesine cap_set_flag fonksiyonu ile çeşitli bayraklar eklenir. Fonksiyonun prototipi şöyledir:

    #include <sys/capability.h>

    int cap_set_flag(cap_t cap_p, cap_flag_t flag, int ncap, const cap_value_t *caps, cap_flag_value_t value);

    Fonksiyonun birinci parametresi yeteneklerin set edileceği nesneyi belirtmektedir. İkinci parametre hangi yetenekler 
    üzerinde işlem yapılacağını belirtir. Bu parametre aşağıdaki sembolik sabitlerden yalnızca birini içerebilir:

    CAP_EFFECTIVE
    CAP_INHERITABLE
    CAP_PERMITTED

    Fonksiyon tarafından set edilecek yetenekler dördüncü parametresi ile belirtilen dizinden elde edilmektedir. Yani programcı 
    cap_value_t türünden bir dizi oluşturup bu dizinin içerisine yetenekleri yerleştirir. Fonksiyonun üçüncü parametresine de
    bu dizinin uzunluğunu geçirir. Fonksiyonun son parametresi aşağıdaki iki değerden biri olarak girilir:

    CAP_CLEAR
    CAP_SET

    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Örneğin:

    cap_value_t caparray[] = {CAP_CHOWN, CAP_KILL};
    ...

    if (cap_set_flag(newcaps, CAP_PERMITTED, 2, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_flag(newcaps, CAP_EFFECTIVE, 2, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    3) Oluşturulan yetenekler cap_set_proc fonksiyonu ile o anda çalışan thread'e aktarılır. cap_set_proc fonksiyonunun 
    prototipi şöyledir:

    #include <sys/capability.h>

    int cap_set_proc(cap_t cap_p);

    Fonksiyon hazırlanan capt_t nesnesini parametre olarak alır. Thread'in yeteneklerini set eder. Başarı durumunda 0 değerine,
    başarısızlık durumunda -1 değerine geri döner. Örneğin:

    if (cap_set_proc(newcaps) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_proc");
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                190. Ders 10/01/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda bir thread'in yeteneklerini değiştiren örnek bir program verilmiştir. Tabii cap_set_proc fonksiyonunun da kullanılması
    için prosesin uygun önceliğe sahip olması gerekir. (Yani prosesin etkin kullanıcı id'si 0 olmalı ya da ilgili thread yetenek
    değiştirme yeteneği olan CAP_SYS_ADMIN yeteneğine sahip olmalıdır.)
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/capability.h>

void exit_sys(const char *msg);

int main(void)
{
    cap_t newcaps;
    cap_value_t caparray[] = {CAP_CHOWN, CAP_KILL};

    if ((newcaps = cap_init()) == NULL)
        exit_sys("cap_init");


    if (cap_set_flag(newcaps, CAP_PERMITTED, 2, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_flag(newcaps, CAP_EFFECTIVE, 2, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_proc(newcaps) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_proc");
    }

    cap_free(newcaps);

    printf("Ok\n");

    getchar();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda önce thread'in izin verilen ve etkin yetenekleri değiştirilmiş sonra da bu yetenekler elde edilip yazdırılmıştır. 
    Programın çalıştırılması sonucunda aşağıdaki gibi bir çıktı elde edilecektir:

    cap_chown,cap_kill=ep
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/capability.h>

void exit_sys(const char *msg);

int main(void)
{
    cap_t newcaps, caps;
    cap_value_t caparray[] = {CAP_CHOWN, CAP_KILL};
    char *captext;

    if ((newcaps = cap_init()) == NULL)
        exit_sys("cap_init");

    if (cap_set_flag(newcaps, CAP_PERMITTED, 2, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_flag(newcaps, CAP_EFFECTIVE, 2, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_proc(newcaps) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_proc");
    }

    cap_free(newcaps);

    if ((caps = cap_get_proc()) == NULL)
        exit_sys("cap_get_proc");

    if ((captext = cap_to_text(caps, NULL)) == NULL) {
        cap_free(caps);
        exit_sys("cap_to_text");
    }

    printf("%s\n", captext);

    cap_free(captext);
    cap_free(caps);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Proses root olarak (etkin kullanıcı id'si 0 olarak) çalışıyor olsun. Prosesin etkin kullanıcı id'si seteuid fonksiyonuyla 
    değiştirildiğinde prosesin tüm thread'lerinin etkin yetenekleri sıfırlanmaktadır. Ancak izin verilen yeteneklerine dokunulmamaktadır. 
    Ancak prosesin gerçek kullanıcı id'si ile etkin kullanıcı id'si setuid fonksiyonu ile değiştirildiğinde prosesin tüm 
    thread'lerinin hem izin verilen hem de etkin yetenekleri sıfırlanmaktadır. Bu konudaki ayrıntılar için "capabilities(7)"
    man sayfasına başvurabilirsiniz.

    Aşağıdaki örnekte seteuid fonksiyonundan sonra thread'in etkin yeteneklerinin düşürüldüğüne ilişkin bir örnek verilmiştir.

    Program çalıştırıldığında ekranda şunlar görünecektir:

    cap_chown,cap_kill,cap_setuid=ep
    cap_chown,cap_kill,cap_setuid=p
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/capability.h>

void exit_sys(const char *msg);

void disp_capability(void)
{
    cap_t caps;
    char *captext;

    if ((caps = cap_get_proc()) == NULL)
        exit_sys("cap_get_proc");

    if ((captext = cap_to_text(caps, NULL)) == NULL) {
        cap_free(caps);
        exit_sys("cap_to_text");
    }

    printf("%s\n", captext);

    cap_free(captext);
    cap_free(caps);
}


int main(void)
{
    cap_t newcaps;
    cap_value_t caparray[] = {CAP_CHOWN, CAP_KILL, CAP_SETUID};

    if ((newcaps = cap_init()) == NULL)
        exit_sys("cap_init");

    if (cap_set_flag(newcaps, CAP_PERMITTED, 3, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_flag(newcaps, CAP_EFFECTIVE, 3, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_proc(newcaps) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_proc");
    }

    cap_free(newcaps);

    disp_capability();

    if (seteuid(1000) == -1)
        exit_sys("seteuid");

    disp_capability();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Linux çekirdeği kendi içerisinde aslında hep yetenek kontrolü yapmaktadır. Yani bir prosesin root önceliğinde olması 
    (yani etkin kullanıcı id'sinin 0 olması) aslında izin verilen ve etkin yeteneklerin hepsinin set edildiği anlamına 
    gelmektedir. Dolayısıyla biz bir programı sudo ile çalıştırdıktan sonra onun etkin yeteneklerini değiştirirsek artık 
    proses'in etkin kullanıcı id'si 0 olsa bile proses yetenek kaybedecektir.

    open fonksiyonu tarafından uygulanan erişim kontrollerinin thread yetenekleriyle bir ilgisi yoktur. Yani etkin user id'si 
    0 olan bir root proses yetenek kümesi düşürülse bile yine open fonksiyonunda başarısız olmaz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde yalnızca thread'lerin değil, çalıştırılabilen dosyaların da yetenekleri vardır. Biz daha önce çalıştırılabilen
    bir dosyanın "set-user-id" ve "set-group-id" biçiminde isimlendirilen bayraklarının işlevlerini incelemiştik. Çalıştırılabilen
    bir dosyanın "set-user-id" bayrağı set edilmişse o programı exec yapan prosesin etkin kullanıcı id'si dosyanın kullanıcı
    id'si haline getiriliyordu. Aynı durum "set-group-id" bayrağı için de benzer biçimde işletiliyordu. Çalıştırılabilen bir 
    dosyanın "set-group-id" bayrağı set edilmişse bu dosya exec yapıldığında prosesin etkin grup id'si dosyanın grup id'si 
    oluyordu. İşte bu mekanizmanın benzeri yetenek temelinde de oluşturulmuştur. Çalıştırılabilen dosyaların da yetenekleri 
    set edilmiş olabilir. Bu durumda bu dosyalar exec yapıldığında proses otomatik olarak o yeteneğe sahip hale gelmektedir. 
    Örneğin bir program dosyasının CAP_KILL yeteneğinin set edilmiş olduğunu varsayalım. Ancak bu dosyanın etkin kullanıcı id'si 
    root olmasın. Bu dosya çalıştırıldığında ilgili thread CAP_KILL yeteneğine sahip olacaktır. (Program birden fazla thread'e
    sahipse exec işlemiyle yalnızca exec yapan thread'in yaşamına devam ettiğini anımsayınız.) Ancak dosya yetenekleri konusunun 
    da bazı ayrıntıları vardır. Dosya yetenekleri i-node elemanlarının içerisinde tutulmaktadır. Bu nedenle dosya sisteminin 
    de dosya yeteneklerini tutma özelliğine sahip olması gerekir. Örneğin FAT dosya sistemlerinde böyle bir alan bulunmamaktadır.

    Yalnızca çalıştırılabilen dosyalar için yetenek kavramı söz konusudur. Tabii bir text dosyanın içerisinde bir script kodu 
    da bulunabilir. Bu durumda bu dosyalar da çalıştırılabilen dosya olarak ele alınabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dosyaların yeteneklerini görüntülemek için "libcap" paketinde "getcap" isimli bir yardımcı program da bulunmaktadır. 
    Örneğin "ping" programının CAP_NET_RAW yeteneği vardır. "getcap" ile bu dosyanın yeteneklerini aşağıdaki gibi görüntüleyebiliriz:

    $ /usr/bin/ping cap_net_raw=ep
    /usr/bin/ping cap_net_raw=ep

    Tıpkı thread'ler gibi dosyaların da izin verilen (permitted), etkin (effective) ve aktarılan (inheritable) yetenekleri 
    vardır. Dosyaların yetenekleri "setcap" isimli programla değiştirilebilmektedir. Programın örnek kullanımı şöyledir:

    $ sudo setcap "cap_net_bind_service=pei cap_net_raw=ep" sample

    Burada sample programına çeşitli yetenekler set edilmiştir. Bu yeteneklerin tek bir komut satırı argümanı biçiminde verildiğine
    dolayısıyla da tırnak içerisine alındığına dikkat ediniz. Eğer dosyadan tüm yetenekler silinecekse komut aşağıdaki gibi 
    kullanılabilir:

    $ sudo setcap = sample

    setcap programının kullanımına ilişkin ayrıntılar için man sayfalarına başvurabilirsiniz.

    Örneğin "sample" isimli programımıza izin verilen ve etkin olarak CAP_KILL yeteneğini eklemek isteyelim. Bu işlemi şöyle
    yapabiliriz:

    $ sudo setcap "cap_kill=ep" sample

    Şimdi dosyanın yeteneğini "getcap" komutu ile görüntüleyelim:

    $ getcap sample
    sample cap_kill=ep

    Tabii bir dosyanın yeteneğini değiştirebilmek için ilgili thread'in de CAP_SETPCAP yeteneğine sahip olması gerekir. root 
    prosesleri tüm yeteneklere sahipmiş gibi düşünmeliyiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                191. Ders 12/01/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Tabii aslında dosyaların yeteneklerini elde etmek ve onlara yetenek iliştirmek için Linux çekirdeğinde sistem fonksiyonları 
    bulunmaktadır. "getcap" ve "setcap" programları libcap kütüphanesindeki cap_set_file ve cap_get_file fonksiyonları kullanılarak 
    yazılmıştır. Bu fonksiyonlar da sys_setxattr, sys_fsetxattr, sys_lsetxattr ve sys_getxattr, sys_fgetxattr, sys_lgetxattr sistem 
    fonksiyonları çağrılarak yazılmıştır. Bu sistem fonksiyonları için "libc" kütüphanesinde sarma fonksiyonlar bulunmaktadır. Ancak 
    biz burada bu işlemleri "libcap" kütüphanesindeki cap_set_file ve cap_get_file fonksiyonlarını kullanarak yapacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    cap_get_file fonksiyonunun prototipi şöyledir:

    #include <sys/capability.h>

    cap_t cap_get_file(const char *path_p);

    Fonksiyon dosyanın yol ifadesini alır ve başarı durumunda dosyanın yetenek bilgilerine ilişkin cap_t nesnesine geri döner. 
    Bu nesnenin kullanımı bittikten sonra cap_free fonksiyonu ile boşaltılması gerekmektedir. Fonksiyon başarısızlık durumunda 
    NULL adrese geri dönmektedir. Örneğin:

    cap_t caps;

    if ((caps = cap_get_file("/usr/bin/ping")) == NULL)
        exit_sys("cap_get_file");

    Aşağıda fonksiyonun kullanımına ilişkin örnek bir program verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/capability.h>

void exit_sys(const char *msg);

void disp_cap(cap_t caps)
{
    char *captext;

    if ((captext = cap_to_text(caps, NULL)) == NULL) {
        cap_free(caps);
        exit_sys("cap_to_text");
    }

    printf("%s\n", captext);

    cap_free(captext);
}

int main(int argc, char *argv[])
{
    cap_t caps;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((caps = cap_get_file(argv[1])) == NULL)
        exit_sys("cap_get_file");

    disp_cap(caps);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    cap_set_file fonksiyonunun prototipi de şöyledir:

    #include <sys/capability.h>

    int cap_set_file(const char *path_p, cap_t cap_p);

    Fonksiyonun birinci parametresi dosyanın yol ifadesini, ikinci parametresi dosyaya iliştirilecek yetenekleri belirtmektedir. 
    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Tabii bir dosyaya yetenek set
    edebilmek için ya prosesin root olması (etkin kullanıcı id'sinin 0 olması) ya da prosesin CAP_SETFCAP yeteneğine sahip olması
    gerekmektedir. Örneğin:

    cap_t caps, newcaps;
    cap_value_t caparray[] = {CAP_CHOWN, CAP_KILL, CAP_SETUID};

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((newcaps = cap_init()) == NULL)
        exit_sys("cap_init");

    if (cap_set_flag(newcaps, CAP_PERMITTED, 3, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_flag(newcaps, CAP_EFFECTIVE, 3, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_file(argv[1], newcaps) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_file");
    }

    cap_free(newcaps);

    Burada CAP_CHOWN, CAP_KILL, CAP_SETUID yetenekleri "izin verilen" ve "etkin" yetenekler olarak dosyaya iliştirilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/capability.h>

void exit_sys(const char *msg);

void disp_cap(cap_t caps)
{
    char *captext;

    if ((captext = cap_to_text(caps, NULL)) == NULL) {
        cap_free(caps);
        exit_sys("cap_to_text");
    }

    printf("%s\n", captext);

    cap_free(captext);
}

int main(int argc, char *argv[])
{
    cap_t caps, newcaps;
    cap_value_t caparray[] = {CAP_CHOWN, CAP_KILL, CAP_SETUID};

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((newcaps = cap_init()) == NULL)
        exit_sys("cap_init");

    if (cap_set_flag(newcaps, CAP_PERMITTED, 3, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_flag(newcaps, CAP_EFFECTIVE, 3, caparray, CAP_SET) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_flag");
    }

    if (cap_set_file(argv[1], newcaps) == -1) {
        cap_free(newcaps);
        exit_sys("cap_set_file");
    }

    cap_free(newcaps);

    if ((caps = cap_get_file(argv[1])) == NULL) {
        cap_free(newcaps);
        exit_sys("cap_get_file");
    }

    disp_cap(caps);

    cap_free(caps);
    cap_free(newcaps);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Ayrıca açık bir dosya için yetenekleri alan ve set eden aşağıdaki fonksiyonlar da bulunmaktadır:

    #include <sys/capability.h>

    cap_t cap_get_fd(int fd);
    int cap_set_fd(int fd, cap_t caps);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                192. Ders 19/01/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi çeşitli yeteneklere sahip bir program dosyası exec yapıldığında ne olur? Bu süreç biraz karışıktır. Normal olarak 
    set-user-id ve set-group-id bayraklarında olduğu gibi prosesin dosyada belirtilen yeteneklere sahip olması gerekir. Ancak 
    sürecin açıklayacağımız bazı ayrıntıları vardır.

    Öncelikle aşağıdaki gibi bir deneme yapalım. Sistem zamanını öğrenmek ve ayarlamak için kullanılan "date" programını 
    kendi dizinimize kopyalayalım:

    $ whereis date
    date: /usr/bin/date /usr/share/man/man1/date.1.gz /usr/share/man/man1/date.1posix.gz

    $ cp /usr/bin/date date

    Sistem tarihini değiştirmeye çalışalım:

    $ ./date -s "2025-01-12"
    ./date: tarih ayarlanamadı: İşleme izin verilmedi
    Paz 12 Oca 2025 00:00:00 +03

    Görüldüğü gibi bu işlem için "sudo" gerekmektedir. Şimdi de dosyaya sistem tarihini değiştirmek için gereken cap_sys_time 
    yeteneğini iliştirelim:

    $ sudo setcap cap_sys_time=pe date

    İşlemimizi doğrulayalım:

    $ sudo getcap date
    date cap_sys_time=ep

    Şimdi sistem tarihini değiştirmeye çalışalım:

    $ ./date -s "2025-01-12"
    Paz 12 Oca 2025 00:00:00 +03

    Görüldüğü gibi biz programı çalıştırdığımızda artık prosesimiz dosyada belirtilen CAP_SYS_TIME yeteneğini kazanmıştır.
    Ancak konunun bazı ayrıntıları vardır. İzleyen paragraflarda bu ayrıntılar üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir thread (proses de diyebiliriz) çalıştırılabilen bir dosyayı exec fonksiyonlarıyla çalıştırdığında thread'in yetenekleri 
    aşağıdaki biçimde değişime uğramaktadır (The Linux Programming Interface kitabından alınma):

    P'(permitted) = (P(inheritable) & F(inheritable)) | (F(permitted) & cap_bset)
    P'(effective) = F(effective) & P'(permitted)
    P'(inheritable) = P(inheritable)

    Burada P prosesin exec öncesindeki yeteneklerini, P' exec sonrasındaki yeteneklerini, F dosyanın yeteneklerini, cap_bset 
    ise prosesin çevreleyen yeteneklerini (process bounding capabilities) belirtmektedir.

    Dosyanın etkin yetenekleri eskiden her yetenek için farklı değildi. Bütün yetenekler için tek bir bayrak kullanılıyordu. 
    Ancak bir süredir bu durum değiştirilmiştir. Artık her yetenek için ayrı bir etkinlik bayrağı tutulmaktadır. Prosesin 
    çevreleyen yetenekleri (bounding capabilities) her yetenek için 0/1 biçiminde bitlerden oluşmaktadır. Genellikle prosesin 
    çevreleyen yeteneklerinin bütün bitleri 1 durumundadır. Örneğin sıradan bir programın yeteneklerine "proc" dosya sisteminden 
    baktığımızda şunları görmekteyiz:

    CapInh:    0000000000000000
    CapPrm:    0000000000000000
    CapEff:    0000000000000000
    CapBnd:    000001ffffffffff

    Görüldüğü gibi çevreleyen yeteneklerin tüm bitleri 1 durumundadır. (Yüksek anlamlı 0 olan hex digitlere ilişkin bitlerin
    zaten kullanılmadığına dikkat ediniz.)

    Buradaki durumu madde madde şöyle açıklayabiliriz:

    1) exec yapıldıktan sonra prosesin yeni izin verilen yetenekleri şu biçimde oluşturulmaktadır:

    P'(permitted) = (P(inheritable) & F(inheritable)) | (F(permitted) & cap_bset)

    Burada bit OR operatörünün solundaki ifade şu anlama gelmektedir: "Prosesin exec öncesindeki aktarılan yetenekleri eğer
    aynı zamanda dosyanın aktarılan yetenekleri içerisinde varsa bu yetenekler alınmaktadır". Bit OR operatörünün sağ tarafındaki
    ifade ise şu anlama gelmektedir: "Dosyanın izin verilen yetenekleri eğer prosesin çevreleyen yeteneklerinde varsa bu 
    yetenekler alınmaktadır. Biz yukarıda prosesin çevreleyen yeteneklerinin genellikle tüm bitlerinin 1 olduğunu belirtmiştik.
    Bu durumda dosyanın izin verilen yeteneklerinin hepsi alınacaktır. Örneğin bizim dizine kopyaladığımız "date" programının 
    yetenekleri şöyledir:

    $ getcap date
    date cap_sys_time=ep

    Yani dosyanın etkin ve izin verilen yetenekleri "cap_sys_time" yeteneğine sahiptir. O halde yukarıdaki satır dikkat alındığında
    exec sonrasında prosesin izin verilen yetenekleri "cap_sys_time" yeteneğini içerecektir.

    2) exec sonrasında prosesin etkin yetenekleri exec sonrasındaki izin verilen yeteneklerinin dosyanın etkin yetenekleriyle
    maskelenmesi sonucunda elde edilmektedir:

    P'(effective) = F(effective) & P'(permitted)

    Dosyanın etkin yeteneklerinin bir şalter görevi gördüğüne dikkat ediniz. Eğer dosyanın etkin yeteneklerindeki bir yetenek
    0 ise bu durumda bu yetenek exec sonrasındaki prosesin etkin yeteneklerine yansıtılmayacaktır.

    Prosesin exec öncesindeki aktarılan yetenekleri ile exec sonrasındaki aktarılan yetenekleri arasında bir farklılık yoktur:

    P'(inheritable) = P(inheritable)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi Linux'taki yetenek konusu neden bu kadar karışık hale getirilmiştir? Tasarımın bu biçimi aslında fazlaca esnek 
    duruma izin vermektedir. Ancak bu esneklikten faydalanma durumu pratikte çokça karşımıza çıkmamaktadır. Burada aslında temel
    kullanım için şunlar söylenebilir:

    1) Bir programı sudo ile çalıştırdığımızda ya da programımızın etkin kullanıcı id'si 0 ise bu durum adeta "tüm etkin 
    yetenekleri set edilmiş" bir proses anlamına gelmektedir.

    2) Çekirdek içerisinde özel bazı durumlarda genel olarak etkin kullanıcı id'sinin 0 olup olmadığı biçiminde değil, thread'in
    ilgili yeteneğe sahip olup olmadığı biçiminde kontroller yapılmaktadır.

    3) Biz çalıştırılabilen bir dosyanın belli bir etkin yeteneğini ve izin verilen yeteneğini set edersek o programı exec ile 
    çalıştırdığımızda o yetenek exec sonrasında prosesimizin izin verilen yeteneklerine ve etkin yeteneklerine otomatik bir 
    biçimde geçer. Tersten gidersek biz bir programın çalıştırılması ile ilgili prosesin bir yetenek kazanmasını istiyorsak
    program dosyası için ilgili yeteneği etkin ve izin verilen biçimde set etmeliyiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Linux'taki sistem fonksiyonlarının nasıl çağrılacağı üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux'ta her sistem fonksiyonunun bir numarası vardır. Linux çekirdeği sistem fonksiyonlarının başlangıç adreslerini 
    bir gösterici dizisinde tutar. Bir sistem fonksiyonu çağrıldığında bu dizinin ilgili numaralı indeksindeki fonksiyonu 
    çağırır. Tabii akış sistem fonksiyonuna geçirilmeden thread'in akışı da user moddan kernel moda geçirilmektedir. Intel 
    sisteminde user moddan kernel moda geçiş 80H kesmesi yoluyla yapılmaktadır. Değişik sistemlerde bu işlemler değişik makine
    komutlarıyla yapıldığı için "libc" kütüphanesi syscall isimli bir sarma fonksiyon bulundurmuştur. Bu fonksiyona programcı 
    sistem fonksiyonunun numarasını ve parametrelerini girer. Fonksiyon sembolik makine dilinde yazılmış makine komutlarından 
    oluşmaktadır. Böylece ilgili sistemde çağrım için gereken işlemler taşınabilir bir biçimde yapılabilmektedir. syscall
    fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    long syscall(long number, ...);

    Fonksiyonun birinci parametresi sistem fonksiyonunun numarasını almaktadır. Diğer parametreler ilgili sistem fonksiyonuna 
    geçirilecek argümanları almaktadır. Fonksiyonun geri dönüş değeri sistem fonksiyonuna bağlı olarak değişebilmektedir. 
    Pek çok sistem fonksiyonunda 0 başarı için kullanılmaktadır. Sistem fonksiyonlarının numaralarını Internet'te pek çok 
    yerde bulabilirsiniz. Aynı zamanda bu numaralar <sys/syscall.h> başlık dosyasında SYS_xxx biçiminde define edilmiştir. 
    Örneğin prosesi sonlandıran sys_exit isimli sistem fonksiyonunun numarası 60'tır. Ancak biz bu numarayı kullanmak yerine 
    SYS_exit ismini de kullanabiliriz. SYS_exit aşağıdaki gibi define edilmiştir:

    #define SYS_exit    60

    Aşağıda sys_exit sistem fonksiyonunun syscall fonksiyonuyla çağrılmasına bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <sys/syscall.h>
#include <unistd.h>

int main(void)
{
    printf("running...\n");

    syscall(SYS_exit, 0);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi bazı POSIX fonksiyonları Linux'ta doğrudan belli bir sistem fonksiyonunu çağırmaktadır.
    Örneğin open POSIX fonksiyonu Linux'ta doğrudan sys_open isimli sistem fonksiyonunu; read, write ve close POSIX fonksiyonları 
    doğrudan sys_read, sys_write ve sys_close sistem fonksiyonlarını; exit POSIX fonksiyonu sys_exit sistem fonksiyonunu çağırmaktadır. 
    GNU "libc" kütüphanesinde bazı sistem fonksiyonları için POSIX standartlarında olmayan sarma fonksiyonlar da bulundurulmuştur. 
    Ancak bazı sistem fonksiyonlarını çağıran POSIX fonksiyonları da sarma fonksiyonlar da yoktur. Bu tür durumlarda ilgili 
    sistem fonksiyonu numara belirtilerek syscall fonksiyonuyla çağrılabilir.

    Aşağıdaki örnekte open, read ve close POSIX fonksiyonları yerine doğrudan Linux'taki sistem fonksiyonları çağrılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <unistd.h>

int main(void)
{
    int fd;
    char buf[10];
    long result;

    if ((fd = syscall(SYS_open, "sample.c", O_RDONLY)) == -1) {
        perror("SYS_open");
        exit(EXIT_FAILURE);
    }

    if ((result = syscall(SYS_read, fd, buf, 10)) == -1) {
        perror("SYS_read");
        exit(EXIT_FAILURE);
    }
    buf[result] = '\0';
    puts(buf);

    if ((result = syscall(SYS_close, fd)) == -1) {
        perror("SYS_close");
        exit(EXIT_FAILURE);
    }

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                193. Ders 26/01/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Linux kaynak kodlarının derlenmesi ve sistemin yeni çekirdekle açılması üzerinde duracağız. Çekirdek kodlarının
    derlenmesi tüm Linux sistemleri için aynı biçimde yapılmaktadır. Ancak sistemin yeni çekirdekle açılması kullanılan "boot 
    loader" programın ayarlarıyla ilgilidir. Bugün masaüstü bilgisayarlarında ağırlıklı olarak GRUB isimli bootloader 
    kullanılmaktadır. Biz burada bu nedenle sürecin GRUB'ta nasıl yürütüleceğini ele alacağız. Gömülü sistemlerde ise ağırlıklı 
    olarak U-Boot denilen boot loader kullanılmaktadır. Biz kursumuzda U-Boot hakkında bir açıklama yapmayacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sistemlerinin çekirdeklerini belleğe yükleyip kontrolün çekirdek kodlarına bırakılmasını sağlayan araçlara 
    "önyükleyici (boot loader)" denilmektedir. Microsoft Windows sistemlerinde kendi önyükleyici programını kullanmaktadır. 
    Buna "Windows Boot Manager" ya da kısaca "bootmgr" de denilmektedir. UNIX/Linux dünyasında çeşitli önyükleyici programlar
    kullanılmıştır. Halen en yaygın kullanılan önyükleyici program "grub" isimli programdır. Tabii "grub" aynı zamanda Windows 
    işletim sistemini de yükleyebilmektedir. GRUB önyükleyicisinden önce Linux sistemlerinde uzun bir süre "lilo" isimli 
    önyükleyici kullanılmıştır. Gömülü sistemlerde de çeşitli önyükleyiciler kullanılabilmektedir. Bazı gömülü sistemlerde 
    o gömülü sistemi üreten kurum tarafından oluşturulmuş olan önyükleyiciler kullanılmaktadır. Ancak gömülü sistemlerde en 
    çok kullanılan önyükleyici "U-Boot" isimli önyükleyicidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Nasıl C'deki main fonksiyonuna komut satırı argümanları geçiriliyorsa işletim sistem sistemi çekirdeklerine de çeşitli 
    biçimlerde parametreler geçirilebilmektedir. Böylece çekirdek belli bir konfigürasyonla işlev görecek biçimde başlatılabilmektedir.
    Linux çekirdeğini önyükleyici yüklediğine göre çekirdek parametreleri de önyükleyici tarafından çekirdeğe aktarılmaktadır. 
    Linux'ta bu parametreler "grub" önyükleyicisinin başvurduğu dosyalarda belirtilmektedir. GRUB önyükleyicisinin kullanımı
    biraz ayrıntılıdır. Ancak biz burada grub işlemlerini daha basit ve görsel biçimde yapabilmek için "grub-customizer" 
    isimli bir programdan faydalanacağız. Bu programı Debian türevi sistemlerde aşağıdaki gibi yükleyebilirsiniz:

    $ sudo add-apt-repository ppa:danielrichter2007/grub-customizer
    $ sudo apt-get update
    $ sudo apt-get install grub-customizer

    Pekiyi neden işletim sistemini yüklemek için ayrı bir programa gereksinim duyulmuştur? Eskiden işletim sistemleri doğrudan
    BIOS kodları tarafından yüklenebiliyordu. Ancak zamanla işletim sistemleri parametreler alacak biçimde geliştirildi. 
    Önyükleyiciler birden fazla çekirdeğin bulunduğu durumlarda basit ayarlarla sistem yöneticisinin istediği çekirdekle 
    boot işlemini yapabilmektedir. Diskte birden fazla işletim sisteminin bulunduğu durumlarda sistemin istenilen bir işletim 
    sistemi tarafından boot edilmesini sağlayabilmektedir. Örneğin makinemizde hem Windows hem de Linux aynı anda bulunuyor 
    olabilir. Önyükleyicimiz bize bir menü çıkartıp hangi işletim sistemi ile boot işlemini yapmak istediğimizi sorabilir. 
    Eskiden nispeten basit olan boot prosedürleri zamanla daha karmaşık hale gelmiştir. Önyükleyici programlara gereksinim 
    duyulmaya başlanmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi neden biz Linux çekirdeğini kaynak kodlardan yeniden derlemek isteyebiliriz? İşte bunun tipik nedenleri şunlar olabilir:

    - Bazı çekirdek modüllerinin ve aygıt sürücülerinin çekirdek imajından çıkartılması ve dolayısıyla çekirdeğin küçültülmesi için.
    - Yeni birtakım modüllerin ve aygıt sürücülerin çekirdek imajına eklenmesi için.
    - Çekirdeğe tamamen başka özelliklerin eklenmesi için.
    - Çekirdek üzerinde çekirdek parametreleriyle sağlanamayacak bazı konfigürasyon değişikliklerinin yapılabilmesi için.
    - Çekirdek kodlarında yapılan değişikliklerin etkin hale getirilmesi için.
    - Çekirdeğe yama (patch) yapılması için.
    - Yeni çıkan çekirdek kodlarının kullanılabilir hale getirilmesi için.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdeğin derlenmesi için öncelikle çekirdek kaynak kodlarının derlemenin yapılacağı bilgisayara indirilmesi gerekir. Pek 
    çok dağıtım default durumda çekirdeğin kaynak kodlarını kurulum sırasında makineye çekmemektedir. Çekirdek kodları "kernel.org"
    sitesinde bulundurulmaktadır. Tarayıcdan "kernel.org" sitesine girerek "pub/linux/kernel" dizinine geçtiğinizde tüm yayınlanmış
    çekirdek kodlarını göreceksiniz. İndirmeyi tarayıcıdan doğrudan yapabilirsiniz. Eğer indirmeyi komut satırından "wget" 
    programıyla yapmak istiyorsanız aşağıdaki URL'yi kullanabilirsiniz:

    https://cdn.kernel.org/pub/linux/kernel/v[MAJOR_VERSION].x/linux-[VERSION].tar.xz

    Buradaki MAJOR_VERSION "3", "4", "5" gibi tek bir sayıyı belirtmektedir. VERSION ise çekirdeğin büyük ve küçük numaralarını 
    belirtmektedir. Örneğin biz çekirdeğin 5.15.12 versiyonunu şöyle indirebiliriz:

    $ wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.15.12.tar.xz

    Örneğin çekirdeğin 6.8.1 versiyonunu da şöyle indirebiliriz:

    $ wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.8.1.tar.xz

    Çekirdek kodları indirildikten sonra onun açılması gerekir. Açma işlemi "tar" komutuyla aşağıdaki gibi yapılabilir:

    $ tar -xvJf linux-5.15.12.tar.xz

    Debian tabanlı sistemlerde o anda makinede yüklü olan mevcut çekirdeğin kaynak kodlarını indirmek için aşağıdaki komutu 
    kullanabilirsiniz:

    $ sudo apt-get install linux-source

    Burada yükleme "/usr/src" dizinine yapılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux kaynak kodlarının versiyonlanması eskiden daha farklıydı. Cekirdeğin 2.6 versiyonundan sonra versiyon numaralandırma 
    sistemi değiştirilmiştir. Eskiden (2.6 ve öncesinde) versiyon numaraları çok yavaş ilerletiliyordu. 2.6 sonrasındaki yeni 
    versiyonlamada versiyon numaraları daha hızlı ilerletilmeye başlanmıştır. Bugün kullanılan Linux versiyonları nokta ile 
    ayrılmış üç sayıdan oluşmaktadır:

    Majör.Minör.Patch-Extra (-rcX, -stable, -custom, -generic)

    Buradaki "majör numara" büyük ilerlemeleri "minör numara" ise küçük ilerlemeleri belirtmektedir. Eskiden (2.6 ve öncesinde) 
    tek sayı olan minör numaralar "geliştirme versiyonlarını (ya da beta versiyonlarını)", çift olanlar ise stabil hale getirilmiş 
    dağıtılan versiyonları belirtiyordu. Ancak 2.6 sonrasında artık tek ve çift minör numaralar arasında böyle bir farklılık 
    kalmamıştır. Patch numarası birtakım böceklerin ya da çok küçük yeniliklerin çekirdeğe dahil edildiği versiyonları belirtmektedir. 
    Bu bağlamda minör numaralardan daha küçük bir ilerlemenin söz konusu olduğunu anlatmaktadır. Burada Extra ile temsil edilen 
    alanda "rcX (X burada bir sayı belirtir) "stable", "custom", "generic", "realtime" gibi sözcükler de bulunmaktadır. "rc" 
    harfleri "release candidate" sözcüklerin kısaltmadır. Stabil sürümün öncesindeki son geliştirme sürümlerini belirtmektedir. 
    "stable" sözcüğü dağıtılan kararlı sürümü belirtir. Eğer sistem programcısı çekirdekte kendisi birtakım değişiklikler yapmışsa 
    genellikle bunun sonuna "custom" sözcüğünü getirir. Tabii bu "custom" sözcüğünü ayrıca "-<custom_version_number>" biçiminde 
    numaralar da izleyebilir. Buradaki numaralar sistem programcısının kendi özelleştirmesine ilişkin numaralardır. "generic" 
    sözcüğü ise genel kullanım için yapılandırılmış bir çekirdek olduğunu belirtmektedir. "realtime" yapılandırmanın gerçek 
    zamanlı sistem özelliği kazandırmak için yapıldığını belirtmektedir. "generic" ve "realtime" sözcüklerinin öncesinde "-N-" 
    biçiminde bir sayı da bulunabilmektedir. Bu sayı "dağıtıma özgü yama ya da derleme numarasını belirtmektedir.

    Çalışmakta olan Linux sistemi hakkında bilgiler "uname -a" komutu ile elde edilebilir. Örneğin:

    $ uname -a
    Linux kaan-virtual-machine 5.15.0-91-generic #101-Ubuntu SMP Tue Nov 14 13:30:08 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux

    Bu bilgi içerisindeki çekirdek versiyonu "uname -r" ile elde edilebilir:

    $ uname -r
    5.15.0-91-generic

    Buradan biz çekirdeğin "5.15.0" sürümünün kullanıldığını anlıyoruz. Burada genel yapılandırılmış bir çekirdek söz konusudur. 
    91 sayısı dağıtıma özgü yama ya da derleme numarasını belirtir.

    Aslında "uname" komutu bu bilgileri "/proc" dosya sisteminin içerisinde almaktadır. Örneğin:

    $ cat /proc/version
    Linux version 5.15.0-91-generic (buildd@lcy02-amd64-045) (gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld 
    (GNU Binutils for Ubuntu) 2.38) #101-Ubuntu SMP Tue Nov 14 13:30:08 UTC 2023
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çekirdeğin derlenmesi için zaten çekirdek kodlarında bir "build sistemi" oluşturulmuştur. Buna "KConfig sistemi" ya da 
    "KBuild sistemi" denilmektedir. Biz önce çekirdek derleme işleminin hangi adımlardan geçilerek yapılacağını göreceğiz. 
    Sonra çekirdeğin önemli konfigürasyon parametreleri üzerinde biraz duracağız. Sonra da çekirdekte bazı değişiklikler yapıp
    değiştirilmiş çekirdeği kullanacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux'ta çekirdeğin davranışını değiştirmek için farklı olanaklara sahip 5 yöntem kullanılabilmektedir:

    1) Çekirdeğin boot parametreleri yoluyla davranışının değiştirilmesi. Bunun için çekirdeğin yeniden derlenmesi gerekmez.

    2) Kernel mode aygıt sürücüsü yazmak yoluyla çekirdeğin davranışının değiştirilmesi. Bunun çekirdek kodlarının yeniden 
    derlenmesi gerekmez.

    3) Çekirdeğin konfigürasyon parametrelerinin değiştirilmesiyle davranışının değiştirilmesi. Bunun için çekirdeğin yeniden 
    derlenmesi gerekir.

    4) Çekirdeğin kodlarının değiştirilmesiyle davranışının değiştirilmesi. Bunun için de çekirdeğin yeniden derlenmesi gerekir.

    5) Çekirdeğin bazı özellikleri "proc" dosya sistemindeki bazı dosyalara birtakım değerler yazarak da değiştirilebilmektedir.
    Aslında bu tür değişiklikler "systemd" init sisteminde "systemctl" komutuyla da yapılabilmektedir. Örneğin sistem çalışırken 
    bir prosesin açabileceği dosya sayısını "proc" dosya sistemi yoluyla şöyle değiştirebiliriz:

    $ echo 2048 | sudo tee /proc/sys/fs/file-max
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux'ta çekirdek derlemesi tipik olarak aşağıdaki aşamalardan geçilerek gerçekleştirilmektedir:

    1) Derleme öncesinde derlemenin yapılacağı makinede bazı programların yüklenmiş olması gerekmektedir. Gerekebilecek tipik 
    programlar aşağıda verilmiştir:

    $ sudo apt update

    $ sudo apt install build-essential libncurses-dev bison flex libssl-dev wget gcc-arm-linux-gnueabihf \
    binutils-arm-linux-gnueabihf libelf-dev dwarves

    2) Çekirdek kodları indirilerek açılır. Biz bu konuyu yukarıda ele almıştık. İndirmeyi şöyle yapabiliriz:

    $ wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.9.2.tar.xz

    Bu işlemden sonra "linux-6.9.2.tar.xz" isimli dosya indirilmiş durumdadır. Onu aşağıdaki gibi açabiliriz:

    $ tar -xvJf linux-6.9.2.tar.xz

    Bu işlemden sonra "linux-6.9.2" isminde bir dizin oluşturulacaktır.

    Ayrıca ek bir bilgi olarak eğer Ubuntu türevi bir dağıtımda çalışıyorsanız istediğiniz bir çekirdeği aşağıdaki gibi indirip 
    kurabilirsiniz:

    sudo apt install linux-image-<çekirdek_sürümü>

    Örneğin:

    $ sudo apt install linux-image-5.15.0-91-generic
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                194. Ders 31/01/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    3) Çekirdek derlenmeden önce konfigüre edilmelidir. Çekirdeğin konfigüre edilmesi birtakım çekirdek özelliklerin belirlenmesi 
    anlamına gelmektedir. Konfigürasyon bilgileri çekirdek kaynak kod ağacının kök dizininde (örneğimizde "linux-6.9.2" dizini) 
    ".config" ismiyle bulunmalıdır. Bu ".config" dosyası default durumda kaynak dosyaların kök dizininde bulunmamaktadır. Bunun 
    çekirdeği derleyen kişi tarafından oluşturulması gerekmektedir. Çekirdek konfigürasyon parametreleri oldukça fazladır. Biz 
    izleyen paragraflarda önemli çekirdek konfigürasyon parametrelerini göreceğiz. Çekirdek konfigürasyon parametreleri çok 
    fazla olduğu için bunlar bazı genel amaçları karşılayacak biçimde default değerlerle önceden oluşturulmuş durumdadır. Bu 
    önceden oluşturulmuş default konfigürasyon dosyaları "arch/<mimari>/configs" dizininin içerisinde bulunmaktadır. Örneğin 
    Intel X86 mimarisi için bu default konfigürasyon dosyaları şöyledir:

    $ ls arch/x86/configs
    hardening.config  i386_defconfig  tiny.config  x86_64_defconfig  xen.config

    Burada biz 64 bit Linux sistemleri için "x86_64_defconfig" dosyasını kullanabiliriz. O halde bu dosyayı kaynak dosyaların 
    bulunduğu dizinin kök dizinine ".config" ismiyle kopyalayabiliriz:

    $ cp arch/x86/configs/x86_64_defconfig .config

    Biz bütün işlemlerde çekirdek kaynak kodlarının kök dizininde bulunduğumuzu (current working directory) varsayacağız. Ancak 
    burada bir noktaya dikkatinizi çekmek istiyoruz. Linux kaynak kodlarındaki default konfigürasyon dosyaları minimal biçimde
    konfigüre edilmiştir. Bu nedenle pek çok modül bu default konfigürasyon dosyalarında işaretlenmiş değildir. Bu default 
    konfigürasyon dosyalarını kullanarak derleme yaptığınızda bazı çekirdek modüllerinin seçilmemiş olması nedeniyle sisteminiz 
    açılmayabilir. Bu tür denemeleri zaten var olan konfigürasyon dosyalarını kullanarak yaparsanız daha fazla modül dosyası 
    oluşturulabilir, ancak daha az zahmet çekebilirsiniz. Linux sistemlerinde genel olarak "/boot" dizini içerisinde 
    "configs-<çekirdek_sürümü>" ismi altında mevcut çekirdeğe ilişkin konfigürasyon dosyası bulundurulmaktadır.

    Burada bir noktaya dikkatinizi çekmek istiyoruz. Çekirdek kaynak kodlarındaki "arch/<paltform>/configs/x86_64_defconfig" 
    dizinindeki konfigürasyon dosyası ".config" ismiyle kopyalandıktan sonra ayrıca "make menuconfig" gibi bir işlemle onun 
    satırlarına bazı default değerlerin de eklenmesi gerekir. Bu default değerler "arch/<platform>" dizinindeki "Kconfig" dosyasından 
    gelmektedir. Bu nedenle bu default konfigürasyon dosyalarını kaynak kök dizine ".config" ismiyle kopyaladıktan sonra 
    aşağıda belirtildiği gibi "make menuconfig" yapmalısınız.

    Aslında ".config" dosyasını oluşturmanın başka alternatif yolları da vardır:

    make defconfig: Bu komut çalıştığımız sisteme uygun olan konfigürasyon dosyasını temel alarak mevcut donanım bileşenlerini 
    de gözden geçirerek sistemin açılması için gerekli minimal bir konfigürasyon dosyasını ".config" ismiyle oluşturmaktadır. Örneğin 
    biz 64 bit Intel sistemine ilişkin bir bilgisayarda çalışıyorsak "make defconfig" dediğimizde "arch/x86/configs/x86_64_defconfig" 
    dosyası temel alınarak o anda çalışılmakta olan çekirdek donanımları da dikkate alınarak nispeten minimal olan bir konfigürasyon
    dosyası oluşturmaktadır.

    make oldconfig: Bu seçeneği kullanmak için kaynak kök dizinde bir ".config" dosyasının bulunuyor olması gerekir. Ancak bu 
    seçenek KConfig dosyasındaki ve kaynak dosya ağacındaki diğer değişiklikleri de göz önüne alarak bu eski ".config" dosyasını 
    eğer söz konusu mimaride birtakım değişiklikler söz konusu ise o değişikliklere uyumlandırmaktadır. Yani örneğin biz eski
    bir ".config" dosyasını kullanıyor olabiliriz. Ancak çekirdeğin yeni versiyonlarında ek birtakım başka konfigürasyon parametreleri 
    de eklenmiş olabilir. Bu durumda "make oldconfig" bize bu eklenenler hakkında da bazı sorular sorup bunların dikkate alınmasını 
    sağlayacaktır.

    make <platform>_defconfig: Bu seçenek belli bir platformun default konfigürasyon dosyasını ".config" dosyası olarak save etmektedir. 
    Örneğin biz Intel makinelerinde çalışıyor olabiliriz ancak BBB (BeagleBone Black) için default konfigürasyon dosyası oluşturmak 
    isteyebiliriz. Eğer biz "make defconfig" yaparsak Intel tabanlı bulunduğumuz platform dikkate alınarak ".config" dosyası oluşturulur. 
    Ancak biz burada örneğin "make bb.org_defconfig" komutunu uygularsak bu durumda Intel mimarisinde çalışıyor olsak da "bb.org_defconfig"
    konfigürasyon dosyası ".config" olarak save edilir. Tabii bu durumda biz aslında yine ilgili platformun konfigürasyon dosyasını 
    manuel olarak ".config" biçiminde de kopyalayabiliriz.

    make modules: Bu seçenek ile yalnızca modüller derlenir. Yani bu seçenek ".config" dosyasında belirtilen aygıt sürücü dosyalarını 
    derler ancak çekirdek derlemesi yapmaz. Yalnızca "make" işlemi zaten aynı zamanda bu işlemi de yapmaktadır.

    Aşağıdaki ilave konfigürasyon seçenekleri ise seyrek kullanılmaktadır:

    make allnoconfig: Tüm seçenekleri hayır (no) olarak ayarlar (minimal yapılandırma).
    make allyesconfig: Tüm seçenekleri evet (yes) olarak ayarlar (maksimum özellikler).
    make allmodconfig: Tüm aygıt sürücülerin çekirdeğin dışında modül (module) biçiminde derleneceğini belirtir.
    make localmodconfig: Sistemde o anda yüklü modüllere dayalı bir yapılandırma dosyası (".config" dosyası) oluşturur.
    make silentoldconfig: Yeni seçenekler için onları görmezden gelir ve o yeni özellikler ".config" dosyasına yansıtılmaz.
    make dtbs: Kaynak kod ağacında "/arch/platform/boot/dts" dizinindeki aygıt ağacı kaynak dosyalarını derler ve "dtb" 
    dosyalarını elde eder. Gömülü sistemlerde bu işlemin yapılması ve her çekirdek versiyonuyla o versiyonun "dtb" dosyasının 
    kullanılması tavsiye edilir.
    make headers_install: Aygıt sürücüler için gereken başlık dosyalarının kurulumu sağlanır. Default kurulum yeri "/usr/include/linux"
    dizinidir. Ancak INSTALL_HDR_PATH çevre değişkeni ile değiştirilebilir.

    Yukarıda da belirttiğimiz gibi aslında pek çok dağıtım o anda yüklü olan çekirdeğe ilişkin konfigürasyon dosyasını "/boot" 
    dizini içerisinde "config-$(uname -r)" ismiyle bulundurmaktadır. Örneğin kursun yapılmakta olduğu Mint dağıtımında "/boot" 
    dizininin içeriği şöyledir:

    $ ls /boot
    config-5.15.0-91-generic  grub        initrd.img-5.15.0-91-generic  vmlinuz
    efi                       initrd.img  System.map-5.15.0-91-generic  vmlinuz-5.15.0-91-generic

    Buradaki "config-5.15.0-91-generic" dosyası çalışmakta olduğumuz çekirdekte kullanılan konfigürasyon dosyasıdır. Benzer biçimde 
    BBB'deki built-in eMMC içerisinde bulunan çekirdekteki "/boot" dizininin içeriği de şöyledir:

    SOC.sh                      dtbs                System.map-5.10.168-ti-r71
    initrd.img-5.10.168-ti-r71  uboot               config-5.10.168-ti-r71
    vmlinuz-5.10.168-ti-r71

    Buradaki konfigürasyon dosyası da "config-5.10.168-ti-r71" biçimindedir.

    Eğer çalışılan sistemdeki konfigürasyon dosyasını temel alacaksanız bu dosyayı Linux kaynak kodlarının bulunduğu kök dizine 
    ".config" ismiyle kopyalayabilirsiniz. Örneğin:

    $ cp /boot/config-$(uname -r) .config

    Fakat eski bir konfigürasyon dosyasını yeni bir çekirdekle kullanmak için ayrıca "make oldconfig" işleminin de yapılması 
    gerekmektedir.

    4) Şimdi elimizde pek çok değerin set edilmiş olduğu ".config" isimli bir konfigürasyon dosyası vardır. Artık bu konfigürasyon 
    dosyasından hareketle yalnızca istediğimiz bazı özellikleri değiştirebiliriz. Bunun için "make menuconfig" komutunu kullanabiliriz:

    $ make menuconfig

    Bu komut ile birlikte grafik ekranda konfigürasyon seçenekleri listelenecektir. Tabii buradaki seçenekler default değerler 
    almış durumdadır. Bunların üzerinde değişiklikler yaparak ".config" dosyasını save edebiliriz. Aslında "make menuconfig" 
    işlemi hiç ".config" dosyası oluşturulmadan doğrudan da yapılabilmektedir. Bu durumda hangi sistemde çalışılıyorsa o sisteme 
    özgü default config dosyası temel alınmaktadır. Biz en azından "General stup/Local version - append to kernel release" 
    seçeneğine "-custom" gibi bir sonek girmenizi böylece yeni çekirdeğe "-custom" soneki iliştirmenizi tavsiye ederiz.

    ".config" dosyası elde edildiğinde çekirdek imzalamasını ortadan kaldırmak için dosyayı açıp aşağıdaki özellikleri belirtildiği 
    gibi değiştirebilirsiniz (bunların bazıları zaten default durumda aşağıdaki gibi de olabilir):

    CONFIG_SYSTEM_TRUSTED_KEYS=""
    CONFIG_SYSTEM_REVOCATION_KEYS=""
    CONFIG_SYSTEM_TRUSTED_KEYRING=n
    CONFIG_SECONDARY_TRUSTED_KEYRING=n

    CONFIG_MODULE_SIG=n
    CONFIG_MODULE_SIG_ALL=n
    CONFIG_MODULE_SIG_KEY=""

    Çekirdek imzalaması konusu daha ileride ele alınacaktır.

    Yukarıda da belirttiğimiz gibi derlenecek çekirdeklere yerel bir versiyon numarası da atanabilmektedir. Bu işlem "make menuconfig" 
    menüsünde "General Setup/Local version - append custom release" seçeneği kullanılarak ya da ".config" dosyasında "CONFIG_LOCALVERSION" 
    kullanılarak yapılabilir. Örneğin:

    CONFIG_LOCALVERSION="-custom"

    Artık çekirdek sürümüne "-custom" sonekini eklemiş olduk.

    5) Derleme işlemi için "make" komutu kullanılmaktadır. Örneğin:

    $ make

    Eğer derleme işleminin birden fazla CPU ile yapılmasını istiyorsanız "-j<cpu_sayısı>" seçeneğini komuta dahil edebilirsiniz. 
    Çalışılan sistemdeki CPU sayısının "nproc" komutuyla elde edildiğini anımsayınız:

    $ make -j$(nproc)

    Derleme işlemi bittiğinde ürün olarak biz "çekirdek imajını", "çekirdek tarafından yüklenecek olan modül dosyalarını (aygıt 
    sürücü dosyalarını)" ve diğer bazı dosyaları elde etmiş oluruz. Derleme işleminden sonra elde oluşturulan dosyalar ve
    onların yerleri şöyledir (buradaki <çekirdek_sürümü> "uname -r" ile elde edilecek değeri belirtiyor):

    - Sıkıştırılmış Çekirdek İmajı: "arch/<platform>/boot" dizininde "bzImage" ismiyle oluşturulmaktadır. Denemeyi yaptığımız Intel makinede 
    dosyanın yol ifadesi "arch/x86_64/boot/bzImage" biçimindedir.

    - Çekirdeğin Sıkıştırılmamış ELF İmajı: Kaynak kök dizininde "vmlinux" isminde dosya biçiminde oluşturulur.

    - Çekirdek Modülleri (Aygıt Sürücü Dosyaları): "drivers" dizininin altındaki dizinlerde ve "fs" dizininin altındaki dizinlerde 
    ve "net" dizininin altındaki dizinlerde. Ancak "make modules_install" ile bunların hepsi belirli bir dizine çekilebilir.

    - Çekirdek Sembol Tablosu: Kaynak kök dizininde "System.map" ismiyle bulunuyor.

    Çekirdeğin derlemesi ne kadar zaman almaktadır? Şüphesiz bu derlemenin yapıldığı makineye göre değişebilir. Ancak derleme sürecinin
    uzamasına yol açan en önemli etken çekirdek konfigüre edilirken çok fazla modülün seçilmesidir. Pek çok dağıtım "belki lazım
    olur" gerekçesiyle konfigürasyon dosyalarında pek çok modülü dahil etmektedir. Bir dağıtımın konfigürasyon dosyasını kullandığınız 
    zaman çekirdek derlemesi uzayacaktır. Ayrıca çekirdek konfigüre edilirken çok fazla modülün dahil edilmesi modüllerin çok fazla 
    yer kaplamasına da yol açabilmektedir. Çekirdek kodlarındaki platforma özgü default konfigürasyon dosyaları daha minimalist 
    bir biçimde oluşturulmuş durumdadır.

    6) Derleme sonrasında farklı dizinlerde oluşturulmuş olan aygıt sürücü dosyalarını (modülleri) belli bir dizine kopyalamak 
    için "make modules_install" komutu kullanılmaktadır. Bu komut seçeneksiz kullanılırsa default olarak "/lib/modules/<çekirdek_sürümü>"
    dizinine kopyalama yapar. Her ne kadar bu komut pek çok ".ko" uzantılı aygıt sürücü dosyasını hedef dizine kopyalıyorsa 
    da bunların hepsi çekirdek tarafından belleğe yüklenmemektedir. Çekirdek gerektiği zaman gereken aygıt sürücüleri bu dizinden 
    alarak yüklemektedir. Örneğin:

    $ sudo make modules_install

    Aslında "make modules_install" komutunun modül dosyalarını (aygıt sürücü dosyalarını) istediğimiz bir dizine kopyalamasını 
    da sağlayabiliriz. Bunun için INSTALL_MOD_PATH komut satırı argümanı kullanılmaktadır. Örneğin:

    $ sudo INSTALL_MOD_PATH=modules make modules_install

    Burada aygıt sürücü dosyaları "/lib/modules/<çekirdek_sürümü>" dizinine değil bulunulan yerdeki "modules" dizinine kopyalanacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi "make modules_install" komutu yalnızca modül dosyalarını mı hedef dizine kopyalıyor? Hayır aslında bu komut modül 
    dosyalarının kopyalanması dışında bazı dosyaları da oluşturup onları da hedef dizine kopyalamaktadır. Bu komut sırasıyla 
    şunları yapmaktadır:

    - Modül dosyalarını "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.
    - "modules.dep" isimli dosyayı oluşturur ve bunu "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.
    - "modules.alias" isimli dosyayı oluşturur ve bunu "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.
    - "modules.order" isimli dosyayı oluşturur ve "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.
    - "modules.builtin" isimli dosyayı "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.

    Aslında burada oluşturulan dosyaların bazıları mutlak anlamda bulunmak zorunda değildir. Ancak sistemin öngörüldüğü gibi 
    işlev göstermesi için bu dosyaların ilgili dizinde bulunması uygundur.

    Bir aygıt sürücü başka bir aygıt sürücüleri de kullanıyor olabilir. Bu durumda bu aygıt sürücü yüklenirken onun kullandığı
    tüm sürücülerin özyinelemeli olarak yüklenmesi gerekir. İşte "modules.dep" dosyası bir aygıt sürücünün yüklenmesi için 
    başka hangi sürücülerin yüklenmesi gerektiği bilgisini tutmaktadır. Aslında "modules.dep" bir text dosyadır. Bu text dosya
    satırlardan oluşmaktadır. Satırların içeriği şöyledir:

    <modül_yolu>: <bağımlılık> <bağımlılık2> ...

    Dosyanın içeriğine şöyle örnek verebiliriz:

    ...
    kernel/arch/x86/crypto/nhpoly1305-sse2.ko.zst: kernel/crypto/nhpoly1305.ko.zst kernel/lib/crypto/libpoly1305.ko.zst
    kernel/arch/x86/crypto/nhpoly1305-avx2.ko.zst: kernel/crypto/nhpoly1305.ko.zst kernel/lib/crypto/libpoly1305.ko.zst
    kernel/arch/x86/crypto/curve25519-x86_64.ko.zst: kernel/lib/crypto/libcurve25519-generic.ko.zst
    ...

    Eğer bu "modules.dep" dosyası olmazsa bu durumda "modeprob" komutu çalışmaz ve çekirdek modülleri yüklenirken eksik 
    yükleme yapılabilir. Dolayısıyla sistem düzgün bir biçimde açılmayabilir. Eğer bu dosya elimizde yoksa ya da bir biçimde
    silinmişse bu dosyayı yeniden oluşturabiliriz. Bunun için "depmod -a" komutu kullanılmaktadır. Komut doğrudan kullanıldığında 
    o anda çekirdek sürümü için "modules.dep" dosyasını oluşturmaktadır. Örneğin:

    $ sudo depmod -a

    Ancak siz yüklü olan başka bir çekirdek sürümü için "modules.dep" dosyasını oluşturmak istiyorsanız bu durumda çekirdek 
    sürümünü de komut satırı argümanı olarak aşağıdaki gibi komuta vermelisiniz:

    $ sudo depmod -a <çekirdek sürümü>

    Tabii depmod komutunun çalışabilmesi için "/lib/modules/<çekirdek_sürümü> dizininde modül dosyalarının bulunuyor olması gerekir. 
    Çünkü bu komut bu dizindeki modül dosyalarını tek tek bulup ELF formatının ilgili bölümlerine bakarak modülün hangi modülleri 
    kullandığını tespit ederek "modules.dep" dosyasını oluşturur.

    "modules.alias" dosyası belli bir isim ya da id ile aygıt sürücü dosyasını eşleştiren bir text dosyadır. Bu dosyanın 
    bulunmaması bazı durumlarda sorunlara yol açmayabilir. Ancak örneğin USB porta bir aygıt takıldığında bu aygıta ilişkin 
    aygıt sürücünün hangisi olduğu bilgisi bu dosyada tutulmaktadır. Bu durumda bu dosyanın olmayışı aygıt sürücünün yüklenememesine
    neden olabilir. Dosyanın içeriği aşağıdaki formata uygun satırlardan oluşmaktadır:

    alias <tanımlayıcı> <modül_adı>

    Örnek bir içerik şöyle olabilir:

    ...
    alias usb:v05ACp*d*dc*dsc*dp*ic*isc*ip*in* apple_mfi_fastcharge
    alias usb:v8086p0B63d*dc*dsc*dp*ic*isc*ip*in* usb_ljca
    alias usb:v0681p0010d*dc*dsc*dp*ic*isc*ip*in* idmouse
    alias usb:v0681p0005d*dc*dsc*dp*ic*isc*ip*in* idmouse
    alias usb:v07C0p1506d*dc*dsc*dp*ic*isc*ip*in* iowarrior
    alias usb:v07C0p1505d*dc*dsc*dp*ic*isc*ip*in* iowarrior
    ...

    Bu dosya bir biçimde silinirse yine "depmod" komutu ile oluşturulabilir. (Yani depmod komutu yalnızca "modules.dep" dosyasını
    değil, bu dosyayı da oluşturmaktadır.)

    "modules.order" dosyası aygıt sürücü dosyalarının yüklenme sırasını barındıran bir text dosyadır. Bu dosyanın her satırında 
    bir çekirdek aygıt sürücüsünün dosya yol ifadesi bulunur. Daha önce yazılmış aygıt sürücüler daha sonra yazılanlardan 
    daha önce yüklenir. Bu dosyanın olmaması genellikle bir soruna yol açmaz. Ancak modüllerin belli sırada yüklenmemesi 
    bozukluklara da neden olabilmektedir. Bu dosyanın da silinmesi durumunda yine bu dosya da "depmod" komutuyla oluşturulabilmektedir.

    7) Eğer gömülü sistemler için derleme yapıyorsanız kaynak kod ağacındaki "arch/<platform>/boot/dts" dizini içerisindeki aygıt
    ağacı kaynak dosyalarını da derlemelisiniz. Tabii elinizde zaten o versiyona özgü aygıt dosyası bulunuyor olabilir. Bu durumda 
    bu işlemi hiç yapmayabilirsiniz. Aygıt ağacı kaynak dosyalarını derlemek için "make dtbs" komutunu kullanabilirsiniz:

    $ make dtbs

    Derlenmiş aygıt ağacı dosyaları "arch/<platform>/boot/dts" dizininde oluşturulacaktır.

    8) Bizim çekirdek imajını, geçici kök dosya sistemine ilişkin dosyayı ve aygıt ağacı dosyasını uygun yere yerleştirmemiz 
    gerekir. Bu dosyalar "/boot" dizini içerisinde bulunmalıdır. Ancak aslında bu işlem de "make install" komutuyla otomatik 
    olarak yapılabilmektedir. "make install" komutu aynı zamanda "grub" isimli bootloder programın konfigürasyon dosyalarında da 
    güncelleme yapıp yeni çekirdeğin "grub" menüsü içerisinde görünmesini de sağlamaktadır. Komut şöyle kullanılabilir:

    $ sudo make install

    Bu komut ile sırasıyla yapılanlar şunlardır:

    - Çekirdek imaj dosyası "arch/<platform>/boot/bzImage" hedef "/boot" dizinine "vmlinuz-<çekirdek_sürümü>" ismiyle kopyalanır.
    - "System.map" dosyası hedef "/boot" dizinine "System.map-<çekirdek_sürümü>" ismiyle kopyalanır.
    - ".config" dosyası "/boot" dizinine "config-<çekirdek_sürümü>" ismiyle kopyalanır.
    - "Geçici kök dosya sistemi dosyası oluşturulur ve hedef "/boot" dizinine "initrd.img-<çekirdek_sürümü>" ismiyle kopyalanır.
    - Eğer "grub" boot loader kullanılıyorsa "grub" konfigürasyonu güncellenir ve "grub"" menüsüne yeni girişler eklenir. Böylece
    sistemin otomatik olarak yeni çekirdekle açılması sağlanır.

    Yukarıda da belirttiğimiz gibi derleme işlemi sonucunda elde edilmiş olan dosyaların hedef sistemde bazı dizinlerde bulunuyor 
    olması gerekir. Bu yerleri bir kez daha belirtmek istiyoruz:

    - Çekirdek İmajı ---> "/boot" dizinine
    - Çekirdek Sembol Tablosu ---> "/boot" dizinine
    - Modül Dosyaları ---> "/lib/modules/<çekirdek_sürümü>/kernel" dizininin altında

    Ancak yukarıdaki dosyalar dışında isteğe bağlı olarak aşağıdaki dosyalar da hedef sisteme konuşlandırılabilir:

    - Konfigürasyon Dosyası ---> "/boot" dizini
    - Geçici Kök Dosya Sistemi Dosyası ---> "/boot" dizinine
    - Modüllere İlişkin Bazı Dosyalar ---> "/lib/modules/<çekirdek_sürümü>" dizinine

    Pekiyi yukarıda belirttiğimiz dosyalar hedef sistemdeki ilgili dizinlere hangi isimlerle kopyalanmalıdır? İşte tipik 
    isimlendirme şöyle olmalıdır (buradaki <çekirdek_sürümü> "uname -r" komutuyla elde edilecek olan yazıdır):

    - Çekirdek İmajı: "/boot/vmlinuz-<çekirdek_sürümü>". Örneğin "vmlinuz-6.9.2-custom" gibi.
    - Çekirdek Sembol Tablosu: "/boot/System.map-<çekirdek_sürümü>". Örneğin "System.map-6.9.2-custom" gibi.
    - Modüllere İlişkin Dosyalar: Bunlar yukarıda da belirttiğimiz gibi "/lib/modules/<çekirdek_sürümü>" dizininin içerisine
    kopyalanmalıdır.
    - Konfigürasyon Dosyası: "/boot/config-<çekirdek_sürümü>". Örneğin "config-6.9.2-custom" gibi.
    - Geçici Kök Dosya Sistemine İlişkin Dosya: "/boot/initrd.img-<çekirdek_sürümü>". Örneğin "initrd.img-6.9.2-custom" gibi.

    Ayrıca bazı dağıtımlarda "/boot" dizini içerisindeki "vmlinuz" dosyası default olan "vmlinuz-<çekirdek_sürümü>" dosyasına, 
    "inird.img" dosyası da "/boot/initrd.img-<çekirdek_sürümü>" dosyasına sembolik link yapılmış durumda olabilir. Ancak bu sembolik 
    bağlantıları "grub" kullanmamaktadır. Aşağıda Intel sistemindeki "/boot" dizininin default içeriğini görüyorsunuz:

    $ ls -l
    total 141168
    -rw-r--r-- 1 root root    261963 Kas 14  2023 config-5.15.0-91-generic
    drwx------ 3 root root      4096 Oca  1  1970 efi
    drwxr-xr-x 7 root root      4096 Ara  5 19:02 grub
    lrwxrwxrwx 1 root root        28 Ara  5 20:28 initrd.img -> initrd.img-5.15.0-91-generic
    -rw-r--r-- 1 root root 126391088 Tem 11 20:19 initrd.img-5.15.0-91-generic
    -rw------- 1 root root   6273869 Kas 14  2023 System.map-5.15.0-91-generic
    lrwxrwxrwx 1 root root        25 Ara  5 20:28 vmlinuz -> vmlinuz-5.15.0-91-generic
    -rw-r--r-- 1 root root  11615272 Kas 14  2023 vmlinuz-5.15.0-91-generic

    Pekiyi derleme sonucunda elde ettiğimiz dosyaları manuel isimlendirirken çekirdek sürüm yazısını nasıl bileceğiz? Bunun için 
    "uname -r" komutunu kullanamayız. Çünkü bu komut bize o anda çalışmakta olan çekirdeğin sürüm yazısını verir. Biz yukarıdaki 
    denemede Linux'un "6.9.2" sürümünü derledik. Bunun sonuna da "-custom" getirirsek sürüm yazısının "6.9.2-custom" olmasını bekleriz. 
    Ancak bu sürüm yazısı aslında manuel olarak isim değiştirmekle oluşturulamamaktadır. Bu sürüm yazısı çekirdek imajının içerisine 
    yazılmaktadır ve bizim bazı dosyalara verdiğimiz isimlerin çekirdek içerisindeki bu yazıyla uyumlu olması gerekir. Default olarak 
    "kernel.org" sitesinden indirilen kaynak kodlar derlendiğinde çekirdek sürümü "6.9.2" gibi üç haneli bir sayı olmaktadır. Yani yazının 
    sonunda "-generic" gibi "-custom" gibi bir sonek yoktur. İşte çekirdeği derlemeden önce daha önceden de belirttiğimiz gibi ".config" 
    dosyasında "CONFIG_LOCALVERSION" özelliğine bu sürüm numarasından sonra eklenecek bilgiyi girebilirsiniz. Örneğin:

    CONFIG_LOCALVERSION="-custom"

    Anımsayacağınız gibi bu işlem "make menuconfig" menüsünde "General Setup/Local version - append custom release" seçeneği kullanılarak 
    da yapılabilmektedir. Biz buradaki örneğimizde bu işlemi yaparak çekirdeği derledik. Dolayısıyla bizim derlediğimiz çekirdekte 
    çekirdek imajı içerisinde yazan sürüm ismi "6.9.2-custom" biçimindedir. Pekiyi biz bu ismi unutsaydık nasıl öğrenebilirdik. Bunun 
    basit bir yolu sıkıştırılmamış çekirdek dosyası içerisindeki (kaynak kök dizindeki "vmlinux" dosyası) string tablosunda "Linux version"
    yazısını aramaktır. Örneğin:

    $ strings vmlinux | grep "Linux version"
    Linux version 6.9.2-custom (kaan@kaan-virtual-machine) (gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld (GNU Binutils for 
    Ubuntu) 2.38) # SMP PREEMPT_DYNAMIC

    Buradan sürüm yazısının "6.9.2-custom" olduğu görülmektedir. O halde bizim derleme sonucunda elde ettiğimiz dosyaları manuel biçimde 
    kopyalarken sürüm bilgisi olarak "6.9.2-custom" yazısını kullanmalıyız. Çekirdek imajının "/boot" dizinine manuel kopyalanması işlemi 
    şöyle yapılabilir (kaynak kök dizinde bulunduğumuzu varsayıyoruz):

    $ sudo cp arch/x86_64/boot/bzImage /boot/vmlinuz-6.9.2-custom

    Konfigürasyon dosyasını da şöyle kopyalayabiliriz:

    $ sudo cp .config /boot/config-6.9.2-custom

    Tabii bizim çekirdek modüllerini de "/lib/modules/6.9.2-custom/kernel" dizinine kopyalamamız gerekir. Ayrıca bir de geçici kök dosya 
    sistemine ilişkin dosyayı da kopyalamamız gerekir. Çekirdek modüllerinin kopyalanması biraz zahmetli bir işlemdir. Çünkü bunlar 
    derlediğimiz çekirdekte farklı dizinlerde bulunmaktadır. Bu kopyalamanın en etkin yolu "make modules_install" komutunu kullanmaktır. 
    Benzer biçimde çekirdek dosyalarının ve gerekli diğer dosyaların uygun yerlere kopyalanması için en etkin yöntem "make install" komutudur.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Normal olarak biz "make install" yaptığımızda eğer sistemimizde "grub" önyükleyicisi varsa komut "grub" konfigürasyon 
    dosyalarında güncellemeler yaparak sistemin yeni çekirdekle açılmasını sağlamaktadır. Ancak kullanıcı bir menü yoluyla 
    sistemin kendi istediği çekirdekle açılmasını sağlayabilir. GRUB menüsü otomatik olarak görüntülenmemektedir. Boot işlemi 
    sırasında ESC tuşuna basılırsa menü görüntülenir. Eğer "grub" menüsünün her zaman görüntülenmesi isteniyorsa "/etc/default/grub" 
    dosyasındaki iki satır aşağıdaki gibi değiştirilmelidir:

    GRUB_TIMEOUT_STYLE=menu
    GRUB_TIMEOUT=5

    Buradaki GRUB_TIMEOUT satırı eğer menünün müdahale yapılmamışsa en fazla 5 saniye görüntüleneceğini belirtmektedir.

    Bu işlemden sonra "update-grub" programı da çalıştırılmalıdır:

    $ sudo update-grub

    Bu tür denemeler yapılırken "grub" menüleri bozulabilmektedir. Düzeltme işlemleri bazı konfigürasyon dosyalarının edit 
    edilmesiyle manuel biçimde yapılabilir. Konfigürasyon dosyaları güncellendikten sonra "update-grub" programı mutlaka 
    çalıştırılmalıdır. Ancak eğer "grub" konfigürasyon dosyaları konusunda yeterli bilgiye sahip değilseniz "grub" işlemlerini 
    görsel bir biçimde "grub-customizer" isimli programla da yapabilirsiniz. Bu program "debian depolarında" olmadığı için 
    önce aşağıdaki gibi programın bulunduğu yerin "apt" kayıtlarına eklenmesi gerekmektedir:

    $ sudo add-apt-repository ppa:danielrichter2007/grub-customizer
    $ sudo apt-get update

    Bu işlemden sonra kurulum yapılabilir:

    $ sudo apt-get install grub-customizer
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda çekirdek derleme ve yeni çekirdeği kurma sürecini maddeler halinde açıkladık. Şimdi yukarıdaki adımları özet 
    hale getirelim:

    1) Çekirdek derlemesi için gerekli olan araçlar indirilir.

    2) Çekirdek kodları indirilir ve açılır.

    3) Zaten hazır olan konfigürasyon dosyası ".config" biçiminde kaynak kök dizine save edilir.

    4) Konfigürasyon dosyası üzerinde "make menuconfig" komutu ile değişiklikler yapılır.

    5) Çekirdek derlemesi "make -j$(nproc)" komutu ile gerçekleştirilir.

    6) Modüller ve ilgili dosyalar hedefe "sudo make modules_install" komutu ile konuşlandırılır.

    7) Çekirdek imajı ve ilgili dosyalar "sudo make install" komutu ile hedefe konuşlandırılır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi yeni çekirdeği derleyip sisteme dahil ettikten sonra nasıl onu sistemden tamamen çıkartabiliriz? Tabii yapılan 
    işlemlerin tersini yapmak gerekir. Bu işlem manuel biçimde şöyle yapılabilir:

    - "/lib/modules/<çekirdek_sürümü>" dizini tamamen silinebilir.
    - "/boot" dizinindeki çekirdek sürümüne ilişkin dosyalar silinmelidir.
    - "/boot" dizinindeki çekirdek sürümüne ilişkin dosyalar silindikten sonra "update-grub" programı sudo ile çalıştırılmalıdır. 
    Bu program "/boot" dizinini inceleyip otomatik olarak ilgili girişleri "grub" menüsünden siler. Yani aslında "grub" 
    konfigürasyon dosyaları üzerinde manuel değişiklik yapmaya gerek yoktur. "grub" işlemleri için diğer bir alternatif ise 
    "grub-customizer" programı ile görsel silme yapmaktır. Ancak bu program "/boot" dizini içerisindeki dosyaları ve modül 
    dosyalarını silmez. Yalnızca ilgili girişleri "grub" menüsünden çıkartmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                195. Ders 02/02/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz Intel sisteminde çalışırken ARM için çekirdek derlemesini nasıl yapabiliriz? Bir platformda çalışırken başka
    bir platform için derleme yapılabilir. Ancak hedef platforma ilişkin ismine "araç zinciri (toolchain)" denilen bir paketin 
    yüklenmiş olması gerekir. Araç zincirleri derleyicilerle birlikte sistem programlama için gerekli olan çeşitli programları 
    barındıran paketlerdir. Örneğin ARM platformu için çeşitli araç zincirleri bulunmaktadır. ARM platformu için en yaygın 
    kullanılan araç zincirleri aşağıdaki bağlantıdan indirilebilir:

    https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads

    Örneğin Beaglebone Black (BBB) için Windows'ta çalışan araç zinciri bu sitede aşağıdaki bağlantıya tıklanarak indirilebilir:

    arm-gnu-toolchain-14.2.rel1-mingw-w64-i686-arm-none-linux-gnueabihf.zip

    Genel olarak araç zincirleri kullanılmadan önce birkaç çevre değişkeninin set edilmesi gerekmektedir:

    - CROSS_COMPILE isimli çevre değişkeni araç zincirinin öneki ile set edilmelidir. Örneğin:

    $ export CROSS_COMPILE=arm-none-linux-gnueabihf-

    - PATH çevre değişkenine araç zincirine ilişkin "bin" dizininin eklenmesi gerekir:

    $ PATH=$PATH:/home/kaan/Study/UnixLinux-SysProg/arm-gnu-toolchain-13.3.rel1-x86_64-arm-none-linux-gnueabihf/bin

    - ARCH çevre değişkeninin hedef platformu belirten bir yazı ile set edilmesi gerekir. ARM platformu için bu yazı "arm"
    biçimindedir:

    $ export ARCH=arm

    Bundan sonra çekirdeğin kaynak kodları yukarıda belirtildiği gibi derlenebilir. Burada bu işlemin ayrıntısı üzerinde 
    durmayacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de çekirdek kodlarının değiştirilip derlenmesine bir örnek verelim. Çekirdek kodlarında değişiklik yapmanın birkaç 
    yolu olabilir:

    1) Çekirdek kodlarındaki bir dosya içerisinde bulunan fonksiyon kodlarında değişiklik yapılması.
    2) Çekirdek kodlarındaki bir dosya içerisine yeni bir fonksiyon eklenmesi.
    3) Çekirdek kodlarındaki bir dizin içerisine yeni bir C kaynak dosyası eklenmesi.
    4) Çekirdek kodlarındaki bir dizin içerisine yeni bir dizin ve bu dizinin içerisinde çok sayıda C kaynak dosyalarının 
    eklenmesi.

    Eğer biz birinci maddedeki ve ikinci maddedeki gibi çekirdek kodlarına yeni bir dosya eklemiyorsak çekirdeğin derlenmesini
    sağlayan make dosyalarında bir değişiklik yapmamıza gerek yoktur. Ancak çekirdeğe yeni bir kaynak dosya ya da dizin ekleyeceksek
    bu eklemeyi yaptığımız dizindeki make dosyasında bu ekleme izleyen paragraflarda açıklayacağımız biçimde belirtilmelidir. 
    Böylece çekirdek yeniden derlendiğinde bu dosyalar da çekirdek imajının içerisine eklenmiş olacaktır. Eğer kaynak kod 
    ağacında bir dizinin altına yeni bir dizin eklemek istersek bu durumda o dizini yine ana dizine ilişkin make dosyasında 
    belirtmemiz ve o dizinde ayrı bir Makefile oluşturmamız gerekmektedir.

    Pekiyi çekirdek kodlarındaki bir dosya içerisindeki bir fonksiyonda değişiklik yaptığımızda çekirdek modüllerini yeniden 
    hedef makineye aktarmamız gerekir mi? İşte genel olarak bu tür basit değişikliklerde çekirdek modüllerinin güncellenmesi 
    gerekmemektedir. Ancak ne olursa olsun bu durum yapılan değişikliklere de bağlıdır. Bu nedenle çekirdek modüllerinin de 
    yeniden "make modules_install" komutu hedef makineye çekilmesi önerilir.

    Örneğin biz çekirdek kaynak kod ağacında "fs/open.c" içerisinde "chdir" sistem fonksiyonuna aşağıdaki gibi bir satır ekleyelim:

    SYSCALL_DEFINE1(chdir, const char __user *, filename)
    {
        struct path path;
        int error;
        unsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;

        printk(KERN_INFO "directory is changing...\n");

    retry:
        error = user_path_at(AT_FDCWD, filename, lookup_flags, &path);
        if (error)
            goto out;

        error = path_permission(&path, MAY_EXEC | MAY_CHDIR);
        if (error)
            goto dput_and_out;

        set_fs_pwd(current->fs, &path);

    dput_and_out:
        path_put(&path);
        if (retry_estale(error, lookup_flags)) {
            lookup_flags |= LOOKUP_REVAL;
            goto retry;
        }
    out:
        return error;
    }

    Bu işlemden sonra sırasıyla aşağıdakileri yapıp sistemi yeni çekirdekle açabiliriz:

    make -j$(nproc)
    make modules_install
    make install

    Bu yeni çekirdekte ne zaman bir dizin değiştirilse bir log yazısı oluşturulmaktadır. Bu yazıları "dmesg" komutuyla 
    görebilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz çekirdeğin kaynak kod ağacına yeni bir ".c" dosyası eklemek istersek ne yapacağız? İşte bu durumda çekirdeğin
    make dosyalarında bu eklemenin belirtilmesi gerekmektedir. Çekirdek kodlarında her kaynak kod dizininde ayrı bir Makefile
    dosyası bulunmaktadır. Programcı yeni kaynak dosyayı hangi dizine ekliyorsa o dizine ilişkin Makefile içerisine aşağıdaki
    gibi bir satır eklemesi gerekir:

    obj-y += dosya_ismi.o

    Böylece artık make işlem yapıldığında bu dosya da derlenip çekirdek imajına dahil edilecektir. Buradaki += operatörü obj-y 
    isimli hedefe ekleme yapma anlamına gelmektedir. "obj" sözcüğünün yanındaki "-y" harfi ilgili dosyanın çekirdeğin bir 
    parçası biçiminde çekirdek imajının içerisine gömüleceğini belirtmektedir. Make dosyalarının bazı satırlarında "obj-y" 
    yerine "obj-m" de görebilirsiniz. Bu da ilgili dosyanın ayrı bir modül biçiminde derleneceği anlamına gelmektedir. 
    Eklemeler genellikle çekirdek imajının içine yapıldığı için biz de "obj-y" kullanırız. Eğer bir dosyayı biz çekirdek 
    imajının içine gömmek yerine ayrı bir çekirdek modülü olarak derlemek istiyorsak bu durumda dosyayı yerleştirdiğimiz 
    dizinin "Makefile" dosyasına aşağıdaki gibi bir ekleme yaparız:

    obj-m += dosya_ismi.o

    Eğer çekirdek kaynak kodlarına tümden bir dizin eklemek istiyorsak bu durumda o dizini oluşturduğumuz dizindeki "Makefile"
    dosyasına aşağıdaki gibi bir ekleme yaparız:

    obj-y += dizin_ismi/

    Burada dizin isminden sonra '/' karakterini unutmayınız. Tabii bu ekleme bir modül biçiminde de olabilirdi:

    obj-m += dizin_ismi/

    Fakat bu ekleme yapıldıktan sonra bizim ayrıca yarattığımız dizinde "Makefile" isimli bir dosya oluşturmamız ve o dosyanın 
    içerisinde o dizinde çekirdek kodlarına ekleyeceğimiz dosyaları belirtmemiz gerekir. Örneğin biz "drivers" dizininin altına
    "mydriver" isimli bir dizin oluşturup onun da içerisine "a.c" "b.c" ve "c.c" dosyalarını eklemiş olalım. Bu durumda önce 
    "drivers" dizini içerisindeki Makefile dosyasına aşağıdaki gibi bir satır ekleriz:

    obj-y += mydriver/

    Sonra da "mydriver" dizini içerisinde "Makefile" isimli bir dosya oluşturup bu dosyanın içerisinde de bu dizin içerisindeki 
    dosyaları belirtiriz. Örneğin:

    obj-y += a.o
    obj-y += b.o
    obj-y += c.o
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Örneğin biz kaynak kod ağacında "drivers" dizininin altında "mydriver" isimli dizin yaratıp onun içerisine "mydrive.c" 
    dosyasını yerleştirmek isteyelim. Sırasıyla şunları yapmamız gerekir:

    1) "drivers" dizini altında "mydriver" dizini yaratırız.

    2) "drivers" dizini içerisindeki Makefile dosyasına aşağıdaki satır ekleriz:

    obj-y += mydriver/

    3) "drivers/mydriver" dizini içerisinde "mydriver.c" dosyasını oluştururuz. Dosyanın içeriği şöyle olabilir:

    #include <linux/module.h>
    #include <linux/kernel.h>

    static int __init helloworld_init(void)
    {
        printk(KERN_INFO "Hello World...\n");

        return 0;
    }

    static void __exit helloworld_exit(void)
    {
        printk(KERN_INFO "Goodbye World...\n");
    }

    module_init(helloworld_init);
    module_exit(helloworld_exit);

    4) "drivers/mydriver" dizini içerisinde "Makefile" isimli dosya oluştururuz ve içine aşağıdaki satırı ekleriz:

    obj-y += mydriver.o

    5) Çekirdek kod dizininin kök dizinine gelip ve sırasıyla aşağıdaki komutları uygularız:

    make -j$(nproc)
    make modules_install
    make install

    Böylece sistem yeni çekirdekle açılabilir. Aygıt sürücünün çekirdeğe dahil edildiğini geçmiş dmesg mesajlarına bakarak
    aşağıdaki gibi anlayabilirsiniz:

    $ dmesg | grep -i "Hello World..."
    [    0.949515] Hello World...
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                196. Ders 07/02/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de yeni bir sistem fonksiyonunu çekirdeğe eklemek isteyelim. Linux çekirdeğinde sistem fonksiyonlarının adresleri 
    bir fonksiyon gösterici dizisinde tutulmaktadır. Bu gösterici dizisinin her elemanı bir sistem fonksiyonunun adresini içerir. 
    O halde çekirdeğe bir sistem fonksiyonu ekleyebilmek için sistem fonksiyonunu bir dosya içerisine yazmak ve bu tabloya 
    o fonksiyonu gösteren bir giriş eklemek gerekir. Bunun yapılış biçimi Linux'un çeşitli versiyonlarında değiştirilmiştir. 
    Aşağıda güncel bir versiyonda bu işlemin nasıl yapıldığına ilişkin bir örnek vereceğiz:

    1) Sistem fonksiyonumuzu "mysyscall" biçiminde isimlendirmiş olalım. Önce yine çekirdek kaynak kod ağacında uygun bir dizine
    yeni bir dosya eklemek gerekir. Bunun için en uygun dizin "kernel" dizinidir. Bu durumda sistem fonksiyonumuzu "kernel" 
    dizini içerisinde "mysyscall.c" ismiyle yazabiliriz:

    /* mysyscall.c */

    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>

    SYSCALL_DEFINE0(mysyscall)
    {
        printk(KERN_INFO "My system call\n");

        return 0;
    }

    Bundan sonra kernel dizini içerisindeki "Makefile" dosyasına aşağıdaki satırı ekleriz:

    obj-y += mysyscall.o

    2) Sistem fonksiyon tablosuna ilgili sistem fonksiyonu bir eleman olarak girilir. Sistem fonksiyon tablosu 
    "arch/<platform>/syscalls/xxx.tbl" dosyasında belirtilmektedir. 64 bit Linux sistemleri için bu dosya 
    "arch/x86/entry/syscalls/syscall_64.tbl" biçimindedir. Ekleme bu dosyanın sonuna aşağıdaki gibi yapılabilir:

    ...
    544    x32    io_submit        compat_sys_io_submit
    545    x32    execveat        compat_sys_execveat
    546    x32    preadv2            compat_sys_preadv64v2
    547    x32    pwritev2        compat_sys_pwritev64v2
    # This is the end of the legacy x32 range. Numbers 548 and above are
    # not special and are not to be used for x32-specific syscalls.
    548    common   mysyscall    sys_mysyscall

    3) Artık çekirdek aşağıdaki gibi derlenebilir:

    $ sudo make -j$(nproc)

    4) Çekirdek modüllerini aşağıdaki gibi install edebiliriz:

    $ sudo make modules_install

    5) Çekirdeğin kendisini de şöyle install edebiliriz:

    $ sudo make install
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sistem fonksiyonunu çekirdeğe yerleştirip yeni çekirdekle makinemizi açtıktan sonra fonksiyonun testini aşağıdaki gibi 
    yapabiliriz:

    #include <stdio.h>
    #include <sys/syscall.h>
    #include <unistd.h>

    #define SYS_mysyscall        548

    int main(void)
    {
        printf("running...\n");

        syscall(SYS_mysyscall);

        return 0;
    }

    Bu programı derleyip çalıştırdıktan sonra "dmesg" yaptığımızda aşağıdaki gibi bir çıktı elde etmeliyiz:

    ...
    file uses a different sequence number ID, rotating.
    [  144.816248] warning: `ThreadPoolForeg' uses wireless extensions which will stop working for Wi-Fi 7 hardware; use nl80211
    [  487.365691] My system call
---------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Her ne kadar sistem programlamanın doğrudan veritabanlarıyla bir ilgisi yoksa da sistem programcıların bazı durumlarda 
    veritabanları oluşturup onları kullanması gerekebilmektedir. Bu bölümde C'den SQL kullanarak veritabanlarıyla nasıl işlem 
    yapılacağı üzerinde duracağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Eskiden veritabanı işlemleri kütüphanelerle yapılıyordu. Daha sonra veritabanı işlemleri için özel programlar geliştirildi. 
    Veritabanı işlemlerini ayrıntılı ve etkin bir biçimde gerçekleştiren yazılımlara "Veritabanı Yönetim Sistemleri (VTYS/DBMS)"
    denilmektedir. Günümüzde çeşitli firmalar ve kurumlar tarafından geliştirilmiş pek çok VTYS vardır. Bunların bazıları 
    kapalı ve ücretli yazılımlardır. Bazıları ise açık kaynak kodlu ve ücretsiz yazılımlardır. En çok kullanılan VTYS yazılımları 
    şunlardır:

    - IBM DB2 (Dünyanın ilk VTYS'sidir.)
    - Oracle (Oracle firmasının en önemli ürünü.)
    - SQL Server (Microsoft firmasının VTYS'si.)
    - MySQL (Açık kaynak kodlu, ancak Oracle firması satın aldı ve gelecekteki durumu tartışmalı.)
    - MariaDB (Açık kaynak kodlu, MySQL Oracle tarafından satın alınınca kapatılma tehlikesine karşı MySQL varyantı olarak 
    devam ettirilmektedir.)
    - PostgreSQL (Açık kaynak kodlu, son yıllarda geniş kesim tarafından kullanılan VTYS.)
    - SQLite (Gerçek anlamda bir VTYS değil, VTYS'yi taklit eden mini bir kütüphane gibi. Bu tür yazılımlara "gömülü VTYS" de
    denilmektedir.)
    - Microsoft Access Jet Motoru (Bu da Microsoft'un gömülü bir VTYS sistemidir. Microsoft Access tarafından da kullanılmaktadır.)

    Bir yazılımın VTYS olabilmesi için onun bazı gelişmiş özelliklere sahip olması gerekir:

    1) VTYS'ler kullanıcılarına yüksek seviyeli bir çalışma modeli sunmaktadır.

    2) VTYS'ler genellikle dış dünyadan istekleri "SQL (Structured Query Language)" denilen dekleratif bir dille almaktadır. 
    Yani programcı VTYS'ye iş yaptırmak için SQL denilen bir yüksek seviyeli dekleratif bir dil kullanmaktadır. VTYS SQL 
    komutlarını alıp onları parse eder ve C ve C++ gibi dillerde yazılmış olan motor kısmı (engine) tarafından işlemler yapılır. 
    SQL, veritabanı işlemlerini yapan bir dil değildir. Programcı ile VTYS arasında yüksek seviyeli iletişim için kullanılan 
    bir dildir. VTYS'lerin motor kısımları genellikle C ve C++ gibi sistem programlama dilleriyle yazılmaktadır.

    3) VTYS'ler pek çok yüksek seviyeli araçlara da sahiptir. Örneğin backup ve restore işlemlerini yapan araçlar her VTYS'de 
    bulunmaktadır.

    4) VTYS'ler genellikle birden fazla kullanıcıya aynı anda hizmet verecek biçimde client-server mimarisine uygun biçimde
    yazılmaktadır. Bunlara uzaktan erişilebilmekte ve aynı anda pek çok kullanıcı bunlara iş yaptırabilmektedir.

    5) VTYS'ler ileri derece güvenlik sunmaktadır. Bir kullanıcı başka bir kullanıcının bilgilerine erişememektedir.

    6) VTYS'ler yüksek miktarda kayıtlardan oluşan veritabanları üzerinde etkin bir biçimde işlemler yapabilmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sistem programlama uygulamalarında bazen küçük veritabanlarının oluşturulması gerekebilmektedir. Bu tür durumlarda kapasiteli
    VTYS'ler yerine tek bir dosyadan oluşan adeta bir kütüphane biçiminde yazılmış olan gömülü VTYS'lerden (embedded DBMS)
    faydalanılmaktadır. Bunların en çok kullanılanı SQLite denilen gömülü VTYS'dir. Örneğin bir tarayıcı yazdığımızı düşünelim. 
    Son ziyaret edilen Web sayfalarının bir biçimde tarayıcıdan çıkıldıktan sonra saklanması gerekir. İşte bu tür durumlarda 
    SQLite gibi basit yapıda VTYS'ler tercih edilebilmektedir. Internet bağlantısı olmayan mobil cihazlarda da SQLite gibi 
    gömülü VTYS'ler çokça kullanılmaktadır. Örneğin biz bir soket uygulaması yazmış olalım. Bu uygulama bir log tutacak olsun. 
    Burada SQLServer, MySQL gibi büyük çaplı VTYS'ler yerine SQLite gibi bir gömülü VTYS'yi tercih edebiliriz. Gömülü VTYS'ler
    büyük çaplı veritabanlarında iyi bir performans gösterememektedir. Bunlar daha çok küçük ve orta çaplı veritabanlarında 
    kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Veritabanı işlemleri için C'den ziyade yüksek seviyeli diller tercih edilmektedir. Örneğin Java, C#, Python gibi diller 
    veritabanı işlemlerinde oldukça yaygın kullanılmaktadır. Benzer biçimde JavaScript de Web uygulamalarında veritabanları
    üzerinde işlem yapmak için kullanılan dillerdendir. Günümüzde veritabanlarının en çok kullanıldığı uygulamalar Web 
    uygulamalarıdır. Bir Web mağazasına girdiğinizde oradaki bütün ürünler veritabanlarında tutulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    VTYS'lerin client-server mimarisine uygun bir biçimde yazıldığını belirtmiştik. VTYS'lerle tipik çalışma şu biçimdedir:

    1) Programcı "kullanıcı ismi" ve "parola" ile VTYS'ye bağlanır. Bu durumda programcı client durumunda, VTYS ise server 
    durumundadır.

    2) Programcı VTYS'ye yaptırmak istediği şeyleri SQL dilinde oluşturur ve VTYS'ye SQL komutlarını gönderir.

    3) VTYS bu SQL komutlarını parse eder ve istenilen işlemleri yapar, programcıya işlemin sonuçlarını iletir.

    4) Programcı işi bittiğinde bağlantıyı kapatır.

    Her ne kadar SQLite ve Microsoft Access Jet Motoru gibi VTYS'ler aslında client-server çalışmıyor olsa da bunlar çalışma 
    biçimi olarak geniş kapasiteli VTYS'leri taklit etmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Veritabanları tasarım bakımından birkaç gruba ayrılmaktadır. Günümüzde en çok kullanılan veritabanı mimarisine "İlişkisel
    Veritabanı (Relational Database) Mimarisi" denilmektedir. İlişkisel veritabanları "tablolardan (tables)", tablolar da 
    sütun ve satırlardan oluşmaktadır. Örneğin biz öğrencilerin bilgilerini tutmak için bir veritabanı tablosu oluşturalım. 
    Bu tablo aşağıdaki görünümde olsun:

    Adı Soyadı      Numarası        Sınıfı
    ---------------------------------------
    Ali Serçe       1234            3B
    Güray Sönmez    6745            2C
    Ayşe Er         6234            2B
    ...

    Tablolardaki sütunlara "alan (field)", satırlara ise "satır (row)" ya da "kayıt (record)" denilmektedir. MySQL, SQLServer, 
    Oracle, SQLite gibi VTYS'ler ilişkisel veritabanı mimarisini kullanmaktadır.

    Hiyerarşik bilgileri (örneğin bir ağaç yapısını) tutmak için hiyerarşik veritabanı mimarileri kullanılabilmektedir. Son 15
    senedir ismine "nosql" denilen ilişkisel olmayan ve özellikle metin tabanlı bilgiler üzerinde işlem yapan veritabanı 
    mimarileri sıkça kullanılır hale gelmiştir. Ancak en yaygın kullanılan mimari ilişkisel veritabanı mimarisidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                197. Ders 09/02/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    MySQL'i kurmak için tek yapılacak şey server programı http://dev.mysql.com/downloads/ sitesinden indirip yüklemektir. Kurulum 
    oldukça basittir. Birtakım sorular default değerlerle geçilebilir. Ancak kurulum sırasında MySQL kurulum programı bizden 
    “root” isimli yetkili kullanıcının parolasını istenecektir. Bu parola yetkili olarak VTYS'ye bağlanmak için gerekir. Server 
    programın yanı sıra bir yönetim ekranı elde etmek için ayrıca "MySql Workbench" programı da kurulabilir.

    MySQL Linux sistemlerinde Debian paket yöneticisi ile aşağıdaki gibi basit bir biçimde kurulabilir:

    $ sudo apt-get install mysql-server

    Kütüphane dosyaları da şöyle indirilebilir:

    $ sudo apt-get install libmysqlclient21

    MySQL Workbench ise komut satırı yerine Web Sayfasından indirilerek kurulabilir.

    Yukarıda da belirttiğimiz gibi MySQL kısmen paralı hale getirilince bunun MariaDB isimli bir klonu oluşturuldu. MariaDB'nin
    uzun vadede açık kaynak kod güvencesi olduğu için tercih edebilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    SQL paralı bir üründür. Fakat bunun da "Express Edition" isminde bedava bir sürümü vardır. Bu sürüm Microsoft'un sayfasından 
    indirilip kurulabilir. Tıpkı MySQL'de olduğu gibi SQL Server'da da yönetim konsol programı vardır. Buna "SQL Server Management 
    Studio" denilmektedir. Bunun da indirilip kurulması tavsiye edilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    SQLite zaten tek bir DLL'den oluşmaktadır. Dolayısıyla aslında kurulumu diye bir durum söz konusu değildir. Fakat biz 
    burada C için örnekler yaparken SQLite başlık dosyalarına ve SQLite DLL’inin import kütüphanesine sahip olmak zorundayız. 
    Bunların nasıl elde edileceği sonraki konularda ele alınacaktır. SQLite yönetim konsolu olarak pek çok alternatif vardır. 
    Bunlardan biri "FireFox Add On" olarak çalışmaktadır. Diğer seçenekler ise “SQLite Studio” ve "SQLite Browser" programlarıdır. 
    Cross Platform olan bu araç ilgili web sayfasından indirilerek kurulabilir. Ya da daha genel "DBeaver" da tercih edilebilir.

    SQLite'ı Windows için aşağıdaki bağlantıdan indirebilirsiniz:

    https://www.sqlite.org/download.html

    Buradan indirilen zip dosyasının içerisinde bir tane ".DLL" dosyası bir ".DEF" dosyası bulunacaktır. Bu DLL'i PATH dizinlerinin
    içerisine ya da uygulama dizininin içerisine çekebilirsiniz. Linux'ta SQLite şöyle indirilebilir:

    $ sudo apt-get install sqlite
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İlişkisel veritabanları tablolardan, tablolar da sütunlardan (fields) oluşmaktadır. Tabii sütunların da veri türleri vardır. 
    SQL Standartları'nda standart bazı veri türleri belirtilmiştir. Ancak SQL VTYS'den VTYS'ye değişiklik gösterebilmektedir. 
    Dolayısıyla her VTYS'nin SQL komutlarında bazı farklılıklar bulunabilmektedir. Biz burada bazı standart sütun türleri
    üzerinde duracağız. Çalıştığınız VTYS'nin dokümanlarından onlara özgü ayrıntıları elde edebilirsiniz.

    INTEGER: Tamsayısal bilgileri tutan bir türdür. İstenirse kaç digitlik sayıların tutulacağı da belirtilebilir.

    INT: Tipik olarak 4 byte uzunluğunda işaretli tamsayı türüdür. (Örneğin bu tür C’deki int türü ile temsil edilebilir.)

    SMALLINT: Tipik olarak 2 byte'lık işaretli tamsayı türüdür. (Örneğin bu tür C’deki short türü ile temsil edilebilir.)

    BIGINT: Tipik olarak 8 byte uzunluğunda işaretli tamsayı türüdür. (Örneğin bu tür C’deki long long türü ile temsil 
    edilebilir.)

    FLOAT: Tipik olarak 4 byte'lık gerçek sayı türüdür. (Örneğin bu tür C’deki float türü ile temsil edilebilir.)

    DOUBLE: Tipik olarak 8 byte'lık gerçek sayı türüdür. (Örneğin bu tür C’deki double türü ile temsil edilebilir.)

    TIME: Zaman bilgisini saklamak için kullanılan türdür.

    DATE: Tarih bilgisini saklamak için kullanılan türdür.

    CHAR(n): n karakterli yazıyı tutmak için kullanılan türdür.

    VARCHAR(n): En fazla n karakterli bir yazıyı tutmak için kullanılan türdür.

    TINYTEXT: Yazısal bilgileri tutmak için kullanılan türdür. (Tipik olarak 256 byte'a kadar)

    TEXT: Yazısal bilgileri tutmak için kullanılan türdür. (Tipik olarak 64K'ya kadar)

    LONGTEXT: (Tipik olarak 4GB'ye byte'a kadar)

    TINYBLOB: Binary bilgileri tutmak için kullanılan türdür. (Tipik olarak 256 byte'a kadar)

    BLOB: Binary bilgileri tutmak için kullanılan türdür. (Tipik olarak 64K'ya kadar)

    LONGBLOB: Binary bilgileri tutmak için kullanılan türdür. (Tipik olarak 4GB'ye byte'a kadar)

    Tablo sütunlarının türleri tablo yaratılırken belirlenmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                198. Ders 16/02/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de temel SQL komutlarını görelim. SQL bazı ayrıntıları olan dekleratif bir programlama dilidir. Komutlardan oluşmaktadır.
    Biz burada temel SQL komutlarını ayrıntılarına girmeden ele alacağız.

    SQL büyük harf küçük harf duyarlılığı olmayan (case insensitive) bir dildir. Ancak geleneksel olarak anahtar sözcüklerin
    büyük harflerle yazılması tercih edilmektedir. SQL komutlarının sonunda sonlandırıcı olarak ';' karakteri bulundurulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    CREATE DATABASE Komutu: İlişkisel veritabanlarında “veritabanı” tablolardan oluşmaktadır. Bu nedenle önce bir veritabanının 
    yaratılması, sonra da onun içerisinde tabloların yaratılması gerekir. Veritabanlarını yaratmak için CREATE DATABASE komutu 
    kullanılır. Komutun genel biçimi şöyledir:

    CREATE DATABASE <isim>;

    Örneğin:

    CREATE DATABASE student;

    USE Komutu: Belli bir veritabanı üzerinde işlemler yapmak için öncelikle onun seçilmesi gerekir. Bu işlem USE komutuyla 
    yapılır. Komutun genel biçimi şöyledir:

    USE <isim>;

    SHOW DATABASES Komutu: Bu komut VTYS'de yaratılmış olarak bulunan veritabanlarını gösterir. Komutun genel biçimi şöyledir:

    SHOW DATABASES;

    CREATE TABLE Komutu: Bu komut veritabanı için bir tablo yaratmak amacıyla kullanılır. Komutun genel biçimi şöyledir:

    CREATE TABLE <isim> (<isim> <tür>, <isim> <tür>, <isim> <tür>... );

    Aslında bu komutun bazı ayrıntıları vardır. Bu ayrıntılar ilgili dokümanlardan öğrenilebilir.

    Örneğin:

    CREATE TABLE student_info(student_id PRIMARY KEY AUTO_INCREMENT, student_name VARCHAR(45), student_no INTEGER);

    Bir tabloda tekrarlanması yasaklanmış olan sütunlara “birincil anahtar (primary key)” denilmektedir. Tablodaki kayıtların 
    hepsinin birincil anahtar sütunları farklı olmak zorundadır. Başka bir deyişle biz bir tabloya orada zaten var olan birincil 
    anahtar değerine ilişkin bir kayıt ekleyemeyiz. Her tabloda bir tane birincil anahtarın olması tavsiye edilmektedir. 
    Birincil anahtarın tablo yaratılırken CREATE TABLE komutunda belirtilme biçimi çeşitli VTYS’lerde farklı olabilmektedir.

    DROP TABLE Komutu: Bu komut tabloyu silmek için kullanılır. Komutun genel biçimi şöyledir:

    DROP TABLE <isim>;

    Örneğin:

    DROP TABLE person;

    INSERT INTO Komutu: Bu komut bir tabloya bir satır eklemek için kullanılır. Komutun genel biçimi şöyledir:

    INSERT INTO <tablo ismi> (sütun1, sütun2, sütun3,...) VALUES (değer1, değer2, değer3,...);

    Tabloya satır eklerken aslında her sütun bilgisinin belirtilmesi gerekmez. Bu durumda o sütun için tablo yaratılırken 
    (CREATE TABLE komutunda) belirlenmiş olan default değerler kullanılır. Komutun ayrıntılı genel biçimi için ilgili 
    dokümanlara başvurabilirsiniz. Örneğin:

    INSERT INTO student_info(student_name, student_no) VALUES('Güray Sönmez', 754);

    Değerler girilirken yazılar ve tarihler tek tırnak içerisinde belirtilmelidir.

    WHERE Cümleciği: Pek çok komut bir WHERE kısmı içermektedir. Where cümleciği koşul belirtmek için kullanılır. Koşullar 
    karşılaştırma operatörleriyle oluşturulur. Mantıksal operatörlerle birleştirilebilir. Örneğin:

    WHERE age > 20 AND birth_place = 'Eskişehir'

    LIKE operatörü joker karakterleri kullanılarak belli bir kalıba uyan yazı koşulu oluşturur. Örneğin:

    WHERE student_name LIKE 'A%'

    Burada student_name için 'a' ile başlayanlar koşulu verilmiştir. % karakteri "geri kalanı herhangi biçimde olabilir" 
    anlamına gelir. Örneğin:

    WHERE student_name LIKE '%an'

    Burada sonu 'an' ile bitenler koşulu verilmiştir.

    WHERE cümleciğinin bazı detayları vardır. Bu detaylar ilgili dokümanlardan öğrenilebilir.

    DELETE FROM Komutu: Bu komut bir tablodan satır silmek için kullanılır. Komutun genel biçimi şöyledir:

    DELETE FROM <tablo ismi> <WHERE cümleciği>;

    UPDATE Komutu: Update komutu belli kayıtların alan bilgilerini değiştirmek amacıyla kullanılır. Örneğin ismi "Kağan" 
    olan bir kaydı "Kaan" olarak değiştirmek isteyebiliriz. Ya da bir müşterinin bakiyesini değiştirmek isteyebiliriz. Komutun 
    genel biçimi şöyledir:

    UPDATE <tablo ismi> SET alan1 = değer1, alan2 = değer2, ... WHERE <koşul>;

    Örneğin:

    UPDATE student_info SET student_name = 'Kaan Kaplan' WHERE student_name = 'Kaan Aslan'

    DELETE ve UPDATE komutlarını kullanırken dikkat ediniz. Çünkü eğer koşul belirtmezseniz ya da koşulu yanlış belirtirseniz
    yaptığınız işlemden birden fazla kayıt etkilenir. Örneğin:

    UPDATE student_info SET student_name = 'Ali Ballı' WHERE student_name = 'Veli Ballı';

    Burada koşul zayıf oluşturulmuştur. Bu durumda bütün "Veli Ballı" isimleri "Ali Ballı" olarak değiştirilir. Örneğin:

    UPDATE student_info SET student_name = 'Ali Ballı' WHERE student_name = 'Veli Ballı' AND student_no = 754;

    Artık burada ismi "Veli Ballı" olan ve numarası 754 olan satırın ismi "Ali Ballı" olarak değiştirilecektir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                199. Ders 21/02/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    SELECT Komutu: Koşulu sağlayan kayıtların elde edilmesi SELECT komutuyla yapılmaktadır. SELECT komutunun genel biçimi 
    oldukça ayrıntılıdır. Çünkü komuta çeşitli cümlecikler monte edilebilmektedir. Komutun genel biçimi şöyledir:

    SELECT <sütun_listesi> FROM <tablo_ismi> [WHERE <koşul];

    Eğer WHERE cümleciği kullanılmazsa tablodaki tüm kayıtlar elde edilir. Sütun listesi sütunların isimlerinden oluşmaktadır. 
    Uygulamacı yalnızca bazı sütun bilgilerini elde edebilir. Sütun istesi yerine "*" kullanılırsa "tüm sütunlar" anlamına gelmektedir. 
    Örneğin:

    SELECT * FROM student WHERE student_no > 600;

    Burada öğrenci numarası 600'den büyük olan öğrencilerin tüm sütun bilgileri elde edilmiştir.

    Eğer SELECT edilen kayıtlar belli bir sütuna göre sıralı biçimde elde edilmek istenirse ORDER BY cümleciği komuta eklenir. 
    Örneğin:

    SELECT * FROM student WHERE student_id > 600 ORDER BY student_name;

    Burada öğrenci numarası 600'den büyük olan öğrencilerin tüm sütun bilgileri elde edilmiştir.

    Eğer SELECT edilen kayıtlar belli bir sütuna göre sıralı biçimde elde edilmek istenirse ORDER BY cümleciği komuta eklenir. 
    Örneğin:

    SELECT * FROM student WHERE student_id > 600 ORDER BY student_name;

    ORDER BY default olarak kayıtları küçükten büyüğe (ASC) vermektedir. Ancak DESC ile büyükten küçüğe de sıralama yapılabilir. 
    Örneğin:

    SELECT * FROM student WHERE student_no > 600 ORDER BY student_name DESC;

    ORDER BY cümleciğinde birden fazla sütun belirtilebilir. Bu durumda ilk sütun değerleri aynıysa diğer sütunlar dikkate alınır. 
    Örneğin:

    SELECT * FROM student WHERE student_no > 600 ORDER BY student_name DESC, student_no ASC;

    Burada ismi aynı olanlar numaralarına göre küçükten büyüğe elde edilecektir.

    LIMIT cümleceği de SELECT cümlesiyle kullanılabilir. LIMIT anahtar sözcüğünün yanında bir sayı bulunur. Koşulu sağlayan 
    belli sayıdaki kayıtları elde etmek için kullanılır. Örneğin:

    SELECT * FROM student WHERE student_no > 600 ORDER BY student_name DESC, student_no ASC LIMIT 10;

    WHERE cümleciğinde built-in fonksiyonlar kullanılabilir. Örneğin:

    SELECT * FROM city WHERE char_length(city) = 6;
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İlişkisel veritabanlarında tablolarda veri tekrarı istenmez. Örneğin bir öğrenci veritabanı oluşturacak olalım. Bir öğrencinin 
    çeşitli bilgilerinin yanı sıra onun okulu hakkında da bilgileri tutmak isteyelim. Aşağıdaki gibi bir tablo tasarımı uygun 
    değildir:

    Adı Soyadı  No      Okul Adı                Okulun Bulunduğu Şehir      Okulun Türü
   --------------------------------------------------------------------------------------
    Ali Serçe   123     Tarsus Amerikan Lisesi      Mersin                  Devlet Lisesi
    Kaan Aslan  745     Eskişehir Atatürk Lisesi    Eskişehir               Devlet Lisesi
    Hasan Bulur 734     Tarsus Amerikan Lisesi      Mersin                  Devlet Lisesi
    ...                 ...                         ...                     ...

    Burada Okul Adı bilgileri gereksiz bir biçimde tekrarlanmaktadır. Bu tekrarı engellemek için iki tablo oluşturabiliriz.

    Öğrenci Tablosu

    Adı Soyadı     No      Okul ID'si
    ----------------------------------
    Ali Serçe      123     100
    Kaan Aslan     745     235
    Hasan Bulur    734     100
    ...            ...     ...

    Okul Tablosu

    Okul Id'si       Okul Adı                   Okulun Bulunduğu Şehir      Okulun Türü
    ------------------------------------------------------------------------------------
    ...              ...                        ...                         ...
    100              Tarsus Amerikan Lisesi     Mersin                      Devlet Lisesi
    150              Eskişehir Atatürk Lisesi   Eskişehir                   Devlet Lisesi
    ...              ...                        ...                         ...

    Burada veri tekrarı ortadan kaldırılmıştır. Tabii bu tablolarda da Okul ID'si ortak bir sütundur. Bu ortak sütun tablolar 
    arasında ilişki kurmak için gerekmektedir. Bu tür sütunlara "foreign key" de denilmektedir. Ancak yukarıdaki gibi tekrarlar 
    engellendiğinde gerekli bilgiler artık tek bir tablodan değil, çeşitli tablolardan çekilip alınacaktır. İşte çeşitli tablolardan 
    bilgilerin çekilip alınması işlemine "JOIN" işlemi denilmektedir. JOIN işleminin birkaç biçimi vardır (INNER JOIN, OUTER JOIN, 
    LEFT JOIN, RIGHT JOIN gibi). Ancak en fazla kullanılan JOIN işlemi "INNER JOIN" denilen işlemdir. JOIN denildiğinde zaten 
    default olarak INNER JOIN anlaşılır. INNER JOIN işleminde eğer iki tablo söz konusu ise önce iki tablonun kartezyen çarpımları 
    elde edilir. Her kartezyen çarpım iki tablonun birleştirilmesi biçiminde ("join" ismi oradan geliyor) elde edilmektedir. 
    Sonra kartezyen çarpımlarda yalnızca belli koşulu sağlayan satırlar elde edilir. Böylece tablolar "ilişkisel (relational)" 
    biçimde birleştirilmiş olur.

    INNER JOIN sentaksı iki biçimde oluşturulabilmektedir. Birinci sentaks klasik eski tip sentakstır. İkinci sentaks daha modern 
    biçimdir. Klasik eski tip sentaks şöyledir:

    SELECT <iki tablodaki istenen sütunların listesi> FROM <birinci tablo ismi> INNER JOIN <ikinci tablo ismi> ON <koşul>;

    Örneğin:

    SELECT student.student_name, student.student_no, school.school_name FROM student INNER JOIN school ON 
    student.school_id = school.school_id WHERE stduent.student_no > 600;

    Sütun isimleri belirtilirken eğer çakışma yoksa yalnızca isimler yazılabilir. Ancak çakışma varsa tablo ismi ve nokta 
    operatörü ile sütunun hangi tabloya ilişkin olduğu belirtilmelidir. Bazı uygulamacılar çakışma olsa da olmasa da 
    niteliklendirme yaparlar. Bazı uygulamacılar yalnızca çakışan sütunlarda niteliklendirme yaparlar. Yukarıdaki örnekte 
    tüm sütunlar niteliklendirilerek belirtilmiştir. Bu örnek şöyle de yapılabilirdi:

    SELECT student_name, student_no, school_name FROM student INNER JOIN school ON student.school_id = school.school_id 
    WHERE student_no > 600;

    Modern INNER JOIN sentaksında SELECT komutunun FROM kısmında birden fazla tablo ismi belirtilir. Koşul da yine WHERE 
    cümleciğine taşınır. Örneğin:

    SELECT student_name, student_no, school_name FROM student, school WHERE student.school_id = school.school_id AND 
    student_no > 600;

    Daha çok bu modern biçim tercih edilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşlemlere başlamadan önce SQLite’ın programlama kurulumunu yapmamız gerekir. SQLite yukarıda da belirttiğimiz gibi 
    çok küçük (tek bir dinamik kütüphaneden oluşan) bir VTYS’dir. Dolayısıyla onun kurulması Windows’ta bildiğimiz anlamda 
    bir setup işlemi ile yapılmaz. Tabii bizim C’den SQLite kütüphanesini kullanabilmemiz için ona ilişkin başlık ve kütüphane 
    dosyalarını elde etmemiz gerekir. Windows'ta SQLite'ın resmi indirme sitesi şöyledir:

    https://sqlite.org/download.html

    Buradan aşağıdaki iki indirme yapılır:

    1) Precompiled Binaries for Windows (32 bit ya da 64 bit)
    2) SQLite Amalgamation

    Birinci indirmede tek bir DLL elde edilecektir. İkinci indirmede de "sqlite3.h" başlık dosyası ve kaynak dosyası elde 
    edilecektir.

    Ayrıca SQlite için "sqlite3" isminde komut satırından kullanılan bir program da bulundurulmuştur. Bu programın kullanımına 
    ilişkin bilgileri aşağıdaki bağlantıdan edinebilirsiniz:

    https://www.sqlite.org/cli.html

    Birinci indirmede Windows için gereken sqlite3.dll ve sqlite3.def dosyaları elde edilir. Buradaki “.def” dosyasına 
    “module definition file” denilmektedir. Bu dosya “DLL’in import kütüphanesi” gibi link aşamasına dahil edilebilir. 
    Ya da istenirse aşağıdaki komutla bu “.def” dosyasından “.lib” uzantılı “import kütüphanesi de oluşturulabilmektedir:

    LIB /DEF:sqlite3.def /machine:x86

    Buradaki "machine" argümanı hedef sistemi belirtmektedir. Burada 32 bit Windows sistemleri için x86, 64 bit Windows 
    sistemleri için "x64" kullanılmalıdır. Örneğin:

    LIB /DEF:sqlite3.def /machine:x64

    İkinci indirmeden biz SQLite’ın kaynak dosyalarını elde ederiz. Buradaki “sqlite3.h” dosyası SQLite fonksiyonları için 
    başlık dosyası niteliğindedir.

    Debian kökenli (Debian, Ubuntu, Mint vs.) apt-get kullanan sistemlerde bu işlem şöyle yapılabilir:

    $ sudo apt-get install sqlite3 libsqlite3-dev

    Mac OS X için kurulum Windows’takine benzemektedir. Yine ilgili “.zip” dosyaları indirilip kurulum yapılabilir. Bu 
    sistemlerde derleme yaparken link aşamasında "-lsqlite3" ile kütüphane dosyasını belirtmeyi unutmayınız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                200. Ders 23/02/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kurulum sonrası her şeyin hazır olduğunu anlamak için SQLite kütüphanesinin versiyon numarasını yazdıran aşağıdaki 
    gibi bir programla test işlemi yapabilirsiniz:

    #include <stdio.h>
    #include "sqlite3.h"

    int main(void)
    {
        printf("%s\n", sqlite3_libversion());

        return 0;
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    C’de SQLite veritabanı ile işlem yapmak için önce o veritabanının sqlite3_open fonksiyonuyla açılması gerekir. Bu işlemden 
    sqlite3 türünden bir handle elde edilir. sqlite3_open fonksiyonunun prototipi şöyledir:

    int sqlite3_open(
        const char *filename,   /* Database filename (UTF-8) */
        sqlite3 **ppDb          /* OUT: SQLite db handle */
    );

    Fonksiyonun birinci parametresi bizden sqlite dosyasının yol ifadesini alır. İkinci parametresi sqlite3 isimli yapı türünden 
    bir göstericinin adresini almaktadır. Fonksiyon handle alanını (yani sqlite yapı nesnesini) oluşturur. Onun adresini bu 
    göstericinin içerisine yerleştirir. Fonksiyonun geri dönüş değeri işlemin başarısını belirtmektedir. Fonksiyon başarılıysa 
    SQLITE_OK değerine geri döner. Fonksiyon başarısız olduğunda yine dosyanın sqlite3_close fonksiyonuyla kapatılması gerekir. 
    Hata nedeni de sqlite3_errmsg fonksiyonuyla yazdırılabilir. Bu durumda sqlite dosyasının açılması tipik olarak şöyle 
    yapılabilir:

    if (sqlite3_open("student.db", &db) != SQLITE_OK) {
        fprintf(stderr, "sqlite3_open failed: %s\n", sqlite3_errmsg(db));
        sqlite3_close(db);
        exit(EXIT_FAILURE);
    }

    sqlite3_open fonksiyonu dosya varsa olanı açar, yoksa yeni bir SQLite DB dosyası yaratır.

    sqlite3_errmsg fonksiyonunun parametrik yapısı şöyledir:

    const char *sqlite3_errmsg(sqlite3 *db);

    sqlite3_close fonksiyonunun prototipi ise şöyledir:

    int sqlite3_close(sqlite3*);

    Dosya kapatılırken başarı kontrolü yapmaya gerek yoktur. Başarısızlık durumlarında hata mesajını stderr dosyasına yazdırıp
    programı sonlandıran bir sarma fonksiyon şöyle yazılabilir:

    void sqlite3_exit(const char *msg, sqlite3 *db)
    {
        fprintf(stderr, "%s failed => %s\n", msg, sqlite3_errmsg(db));
        sqlite3_close(db);

        exit(EXIT_FAILURE);
    }

    Böylece biz hata durumlarını aşağıdaki gibi ele alabiliriz:

    if (sqlite3_open("studentxxx.db", &db) != SQLITE_OK)
        sqlite3_exit("sqlite3_open", db);
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include "sqlite3.h"

void sqlite3_exit(const char *msg, sqlite3 *db);

int main(void)
{
    sqlite3 *db;

    if (sqlite3_open("student.db", &db) != SQLITE_OK)
        sqlite3_exit("sqlite3_open", db);

    printf("success...\n");

    sqlite3_close(db);

    return 0;
}

void sqlite3_exit(const char *msg, sqlite3 *db)
{
    fprintf(stderr, "%s failed => %s\n", msg, sqlite3_errmsg(db));
    sqlite3_close(db);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    SQLite'a bir SQL cümlesi göndermek için sqlite3_exec fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    int sqlite3_exec(
        sqlite3 *db,                               /* An open database */
        const char *sql,                           /* SQL to be evaluated */
        int (*callback)(void*,int,char**,char**),  /* Callback function */
        void *param,                               /* 1st argument to callback */
        char **errmsg                              /* Error msg written here */
    );

    Fonksiyonun birinci parametresi sqlite3_open fonksiyonundan elde edilen handle değeridir. İkinci parametre sql cümlesinin 
    yazısını alır. Üçüncü parametre işlemden sonra çağrılacak “callback” fonksiyonun adresini almaktadır. Bu parametre NULL 
    geçilebilir. Dördüncü parametre bu “callback” fonksiyona geçirilecek argümanı belirtir. Bu parametre de NULL geçilebilir. 
    Son parametre ise char * türünden bir göstericinin adresini almaktadır. Hata durumunda hata mesajının adresi bu göstericiye 
    yerleştirilir. Bu parametre NULL olarak da geçilebilir. Fonksiyonun geri dönüş değeri işlemin başarısını belirtir. Fonksiyon 
    başarılıysa SQLITE_OK değerine geri dönmektedir. Bu durumda biz hata mesajını yazdırdıktan sonra sqlite3_free fonksiyonu 
    ile tahsis edilen alanı serbest bırakabiliriz. Örneğin:

    if (sqlite3_exec(db, "INSERT INTO student_info(student_name, student_no) VALUES('Rasim Öztekin', 367)", 
                NULL, NULL, NULL) != SQLITE_OK)
        sqlite3_exit("sqlite3_exec", db);

    Aşağıdaki örnekte student_info veritabanına sqlite3_exec fonksiyonu ile bir kayıt eklenmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include "sqlite3.h"

void sqlite3_exit(const char *msg, sqlite3 *db);

int main(void)
{
    sqlite3 *db;

    if (sqlite3_open("student.db", &db) != SQLITE_OK)
        sqlite3_exit("sqlite3_open", db);

    if (sqlite3_exec(db, "INSERT INTO student_info(student_name, student_no) VALUES('Rasim Öztekin', 367)", NULL, NULL, NULL) != SQLITE_OK) 
        sqlite3_exit("sqlite3_exec", db);

    printf("Success...\n");

    sqlite3_close(db);

    return 0;
}

void sqlite3_exit(const char *msg, sqlite3 *db)
{
    fprintf(stderr, "%s failed => %s\n", msg, sqlite3_errmsg(db));
    sqlite3_close(db);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                201. Ders 07/03/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Veritabanından kayıtların elde edilmesi biraz daha ayrıntılı bir konudur. İstenilen kayıtların elde edilmesi için iki 
    yol vardır. Birincisinde önce sqlite3_prepare fonksiyonu ile SQL SELECT cümlesi VTYS’ye gönderilir. Sonra her bir kayıt 
    tek tek sqlite3_step fonksiyonu çağrılarak elde edilir. sqlite3_prepare fonksiyonundan elde edilen kayıtların bir liste 
    oluşturduğunu sqlite3_step fonksiyonunun da listede sonraki kayda geçtiğini düşünebilirsiniz. Yani adeta sqlite3_step 
    fonksiyonu imleci bir sonraki kayda konumlandırıyormuş gibidir. O andaki kayıtın sütun elemanları sqlite3_column_xxx 
    fonksiyonlarıyla elde edilebilir. Burada xxx o sütunun türünü belirtmektedir. sqlite3_prepare fonksiyonunun prototipi 
    şöyledir:

    int sqlite3_prepare(
        sqlite3 *db,            /* Database handle */
        const char *zSql,       /* SQL statement, UTF-8 encoded */
        int nByte,              /* Maximum length of zSql in bytes. */
        sqlite3_stmt **ppStmt,  /* OUT: Statement handle */
        const char **pzTail     /* OUT: Pointer to unused portion of zSql */
    );

    Fonksiyonun birinci parametresi sqlite3_open fonksiyonundan elde edilen handle değeridir. İkinci parametre SELECT 
    cümlesini belirtir. Üçüncü parametre ikinci parametredeki SELECT cümlesine ilişkin yazının uzunluğunu belirtir. Bu 
    parametre negatif değer geçilirse (örneğin -1) bu yazı null karaktere kadar ele alınır. Fonksiyonun dördüncü parametresi 
    sqlite3_stmt türünden bir yapı göstericisinin adresini almaktadır. Bu da bir handle değeri gibidir. Kayıtlar elde edilirken 
    bu handle değeri kullanılmaktadır. Son parametre NULL geçilebilir. Fonksiyon başarı durumunda SQLITE_OK değerine geri 
    dönmektedir. Fonksiyon başarılı olduğunda imleç ilk kaydın bir gerisini göstermektedir. Yani işleme önce bir kez 
    sqlite3_step çağrısı yaparak başlamak gerekir. Her sqlite3_step çağrısı select edilen kayıtlardan bir sonrasına konumlanma 
    sağlar. sqlite3_step fonksiyonunun prototipi şöyledir:

    int sqlite3_step(sqlite3_stmt*);

    Fonksiyonun parametresi sqlite3_prepare fonksiyonundan alınan handle değeridir. Son kayda erişildikten sonra sqlite3_step 
    fonksiyonu SQLITE_DONE değerine geri dönmektedir. O halde bu yöntemde önce bir kez sqlite3_prepare fonksiyonu çağrılır. 
    Sonra bir döngü içerisinde sqlite3_step çağrıları yapılır. İmleç konumlandırıldıktan sonra sütun değerleri sqlite3_column_xxx 
    fonksiyonlarıyla elde edilmektedir. Her sütun türü için ayrı bir fonksiyon vardır. Bu fonksiyonlardan bazılarının 
    prototipleri aşağıda verilmiştir:

    const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);
    int sqlite3_column_bytes(sqlite3_stmt*, int iCol);
    int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
    double sqlite3_column_double(sqlite3_stmt*, int iCol);
    int sqlite3_column_int(sqlite3_stmt*, int iCol);
    sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);
    const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);
    const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);
    int sqlite3_column_type(sqlite3_stmt*, int iCol);
    sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);

    Bu işlemler bittikten sonra sqlite3_finalize fonksiyonu çağrılmalıdır. Fonksiyonun prototipi şöyledir:

    int sqlite3_finalize(sqlite3_stmt *pStmt);

    Fonksiyon başarı durumunda SQLITE_OK değeri ile geri dönmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte komut satırında bir menü çıkartılmış ve seçilen seçeneğe göre uygun işlemler yapılmıştır. Menü 
    aşağıdaki gibidir:

    1) Kayıt Ekle
    2) Kayıt Sil
    3) Kayıt Bul
    4) Çıkış
    Seçiminiz:

    Örnekteki "student.db" veritabanı yoksa yaratılmaktadır, varsa olan veritabanı açılmaktadır. Eğer veritabanı yoksa aşağıdaki
    SQL komutuyla tablo yaratılmıştır:

    "CREATE TABLE IF NOT EXISTS student_info(student_id INTEGER PRIMARY KEY AUTOINCREMENT, 
        student_name VARCHAR(64), 
        student_no INTEGER
    );"

    Görüldüğü gibi student_info tablosunda üç sütun vardır. Sütunlardan biri otomatik artırımlı PRIMARY KEY sütunudur.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include "sqlite3.h"

int disp_menu(void);
void clear_stdin(void);
void add_record(sqlite3 *db);
void del_record(sqlite3 *db);
void find_record(sqlite3 *db);
void sqlite3_exit(const char *msg, sqlite3 *db);

int main(void)
{
    sqlite3 *db;
    int option;

    setlocale(LC_ALL, "tr_TR.UTF-8");

    if (sqlite3_open("student.db", &db) != SQLITE_OK)
        sqlite3_exit("sqlite3_open", db);

    if (sqlite3_exec(db,
            "CREATE TABLE IF NOT EXISTS student_info("
            "student_id INTEGER PRIMARY KEY AUTOINCREMENT, "
            "student_name VARCHAR(64), "
            "student_no INTEGER);", NULL, NULL, NULL != SQLITE_OK))
        sqlite3_exit("sqlite3_exec", db);

    for (;;) {
        if ((option = disp_menu()) == -1) {
            printf("Geçersiz seçenek!...\n");
            clear_stdin();
            continue;
        }
        switch (option) {
            case 1:
                add_record(db);
                break;
            case 2:
                del_record(db);
                break;
            case 3:
                find_record(db);
                break;
            case 4:
                goto EXIT;
            default:
                printf("Geçersiz seçenek!...\n");
        }
    }

EXIT:
    sqlite3_close(db);

    return 0;
}

int disp_menu(void)
{
    int option;

    printf("1) Kayıt Ekle\n");
    printf("2) Kayıt Sil\n");
    printf("3) Kayıt Bul\n");
    printf("4) Çıkış\n");

    printf("Seçiminiz: ");
    fflush(stdout);
    if (scanf("%d", &option) != 1)
        return -1;
    clear_stdin();

    return option;
}

void clear_stdin(void)
{
    while (getchar() != '\n')
        ;
}

void add_record(sqlite3 *db)
{
    char name[64];
    char sql[1024];
    char *str;
    int no;

    printf("Adı Soyadı:");
    fflush(stdout);
    fgets(name, 64, stdin);
    if ((str = strchr(name, '\n')) != NULL)
        *str = '\0';
    printf("No:");
    fflush(stdout);
    scanf("%d", &no);
    clear_stdin();

    sprintf(sql, "INSERT INTO student_info(student_name, student_no) VALUES('%s', %d);", name, no);

    if (sqlite3_exec(db, sql, NULL, NULL, NULL) != SQLITE_OK)
        fprintf(stderr, "cannot add record!...\n");
}

void del_record(sqlite3 *db)
{
    char condition[1024];
    char sql[4096];
    char *str;
    int no;

    printf("Koşul:");
    fflush(stdout);
    fgets(condition, 1024, stdin);
    if ((str = strchr(condition, '\n')) != NULL)
        *str = '\0';
    sprintf(sql, "DELETE FROM student_info WHERE %s;", condition);
    if (sqlite3_exec(db, sql, NULL, NULL, NULL) != SQLITE_OK)
        fprintf(stderr, "cannot delete record!...\n");
}

void find_record(sqlite3 *db)
{
    char condition[1024];
    char sql[4096];
    char *str;
    int no;
    sqlite3_stmt *stmt;
    unsigned char *name;

    printf("Koşul:");
    fflush(stdout);
    fgets(condition, 1024, stdin);
    if ((str = strchr(condition, '\n')) != NULL)
        *str = '\0';

    printf("\n");
    if (*str == '\0')
        strcpy(sql, "SELECT student_name, student_no FROM student_info");
    else
        sprintf(sql, "SELECT student_name, student_no FROM student_info WHERE %s;", condition);

    if (sqlite3_prepare(db, sql, -1, &stmt, NULL) != SQLITE_OK) {
        fprintf(stderr, "Cannot open database: %s\n", sqlite3_errmsg(db));
        return;
    }

    while (sqlite3_step(stmt) != SQLITE_DONE) {
        name = sqlite3_column_text(stmt, 0);
        no = sqlite3_column_int(stmt, 1);
        printf("%s, %d\n", name, no);
    }

    sqlite3_finalize(stmt);

    printf("\n");
}

void sqlite3_exit(const char *msg, sqlite3 *db)
{
    fprintf(stderr, "%s failed => %s\n", msg, sqlite3_errmsg(db));
    sqlite3_close(db);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                202. Ders 09/03/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                203. Ders 16/03/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de yukarıdaki işlemlerin benzerlerinin MySQL'de nasıl yapılacağını görelim. MySQL'in de C için API'leri vardır. 
    MySQL VTYS’si ile işlemler MySQL’in gerekli kütüphanelerinin client tarafta kurulması gerekir. Bunun için Windows’ta, 
    macOS sistemlerinde ve Linux’ta “MySQL C++ Connector” denilen kurulum yapılabilir. Bu paket aşağıdaki bağlantıdan
    indirilebilir:

    https://downloads.mysql.com/archives/c-c/

    Bu kurulum yapıldığında tipik olarak gerekli olan kütüphaneler ve include dosyaları "C:\Program Files\MySQL\MySQL Connector C 6.1"
    gibi bir dizine kurulacaktır.

    Debian türevi (Ubuntu, Mint vs.) sistemlerde aşağıdaki apt-get komutu bu paketin indirilerek kurulmasını sağlamaktadır:

    $ sudo apt-get install libmysqlclient-dev
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Windows ortamında VisualStudio IDE'sinde çalışıyorsanız projenizde "Additional Include Directories" elemanında MySQL 
    Connector'ü kurduğunuz dizindeki include dizinini burada belirtmelisiniz. Ayrıca Windows'ta link işlemi için "libmysql.lib"
    import kütüphanesinin de projede belirtilmesi gerekmektedir. Ancak programın çalışabilmesi için "libmysql.dll" dosyasının 
    ya sistem tarafından bakılan dizinlerin birinde olması ya da PATH çevre değişkeni ile belirtilen dizinlerden birinde olması 
    gerekmektedir.

    Linux'ta MySQL include dosyaları "/usr/include/mysql" dizini içerisindedir. Dolayısıyla include işlemi <mysql/mysql.h>
    biçiminde yapılmalıdır. Linux'ta ayrıca "libmysqlclient" kütüphanesinin de bağlama işlemine dahil edilmesi gerekmektedir. 
    Derleme işlemini şöyle yapmalısınız:

    $ gcc -o sample sample.c -lmysqlclient
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir MYSQL C programda ilk yapılacak şey mysql_init fonksiyonu çağırarak bir handle elde etmektir:

    MYSQL *MySQL_init(MYSQL *MySQL);

    Bu fonksiyon parametre olarak bizden MYSQL türünden bir nesnenin adresini ister onun içini doldurur. Eğer parametre NULL 
    girilirse fonksiyon bu nesneyi kendisi tahsis edip bize adresini verecektir. Fonksiyon başarısız olabilir. Başarısızlık 
    durumunda NULL adrese geri döner. Örneğin:

    MYSQL *db;

    if ((db = mysql_init(NULL)) == NULL) {
        fprintf(stderr, "MySQL_init failed\n");
        exit(EXIT_FAILURE);
    }
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <mysql.h>

int main(void)
{
    MYSQL *db;

    if ((db = mysql_init(NULL)) == NULL) {
        fprintf(stderr, "mysqlL_init failed\n");
        exit(EXIT_FAILURE);
    }

    printf("Ok\n");

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    MYSQL * türünden handle elde edildikten sonra artık "IP adresi", "port numarası", "kullanıcı adı", "parola" ve bağlanılacak
    veritabanını belirtilerek bağlantı mysql_real_connect fonksiyonuyla sağlanır. Fonksiyonun prototipi şöyledir:

    MYSQL *mysql_real_connect(MYSQL *MySQL, const char *host, const char *user, const char *passwd, const char *db, 
            unsigned int port, const char *unix_socket, unsigned long client_flag);

    Fonksiyonun birinci parametresi mysql_init fonksiyonundan elde edilmiş olan handle değeridir. İkinci parametre host'un
    IP adresini, üçüncü parametre MySQL'deki kullanıcı ismini almaktadır. MySQL'i ilk kurduğunuzda tüm yetkilere sahip bir 
    "root" kullanıcısı bulunmaktadır. Bu kullanıcı tüm veritabanlarına erişebilmektedir. Tabii siz isterseniz kısıtlı 
    kullanıcılarda yaratabilirsiniz. Fonksiyonun dördüncü parametresi kullanıcıya ilişkin parolayı belirtmektedir. "root" 
    kullanıcısının parolası kurulum sırasında belirlenmektedir. Beşinci parametre kullanılacak veritabanının ismini almaktadır. 
    Altıncı parametre port numarasını belirtmektedir. MySQL Server programlarının kullandığı default port numarası 3306'dır. 
    Son iki parametre NULL ve 0 biçiminde geçilebilir. Örneğin:

    MYSQL *db;

    if ((db = mysql_init(NULL)) == NULL) {
        fprintf(stderr, "mysql_init failed!...\n");
        exit(EXIT_FAILURE);
    }

    if (mysql_real_connect(db, "localhost", "root", "maviay", "student_info", 3306, NULL, 0) == NULL)
        exit_err("mysql_real_connect failed", NULL);

    MySQL ile çalışırken hata durumlarında bağlantıyı kapatıp prosesi sonlandırmak için aşağıdaki gibi bir fonksiyondan 
    faydalanabiliriz:

    void exit_err(const char *msg, MYSQL *db)
    {
        fprintf(stderr, "%s: %s\n", msg, mysql_error(db));
        mysql_close(db);
        exit(EXIT_FAILURE);
    }

    mysql_close fonksiyonuna NULL adres geçilirse close işlemi yapılmaz ama mysql_init fonksiyonuyla tahsis edilmiş olan handle 
    alanı boşaltılır.

    Server'a bağlanırken birkaç problem ortaya çıkabilir. Server default SSL kullanıyor olabilir. Bu durumda SSL konfigürasyonunu
    yapmadıysanız bağlantı sırasında sorun oluşabilir. Bağlanırken SSL'i pasif hale getirmek için (disable etmek için) iki yöntem 
    kullanılabilir. Birincisi "mysql.ini" ya da "my.cnf" dosyasına aşağıdaki satırlar girilerek SSL kullanımı devre dışı bırakılabilir:

    [mysqld]
    ssl=0
    skip_ssl

    Windows sistemlerinde "mysql.ini" dosyası "C:\ProgramData\MySQL\MySQL Server 8.0" dizin içerisinde bulunmaktadır. Linux 
    sistemlerinde "my.cnf" dosyası "/etc/mysql" dizini içerisindedir. Bu dosyaları edit etmek için editörünüzü "Administrator" 
    ya da "sudo" hakkıyla açmalısınız. İkinci yöntem programa özgü bir biçimde SSL'i mysql_options fonksiyonu ile devre dışı 
    bırakmaktır. Bu işlem şöyle yapılabilir:

    int ssl_mode = SSL_MODE_DISABLED;

    if (mysql_options(db, MYSQL_OPT_SSL_MODE, &ssl_mode))
        exit_err("mysql_options failed", db);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Eskiden MySQL server programı default olarak uzak bağlantıları kabul ediyordu. Sonra default durumda uzak bağlantılara
    izin verilmemeye başlandı. Yani siz yerel ağınızda bile olsa başka bir makinedeki MySQL Server programına IP adresi ve 
    port numarası belirterek bağlanamayabilirsiniz. Uzak bağlantılara izin vermek için konfigürasyonda bazı ayarlamaların 
    yapılması gerekmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                204. Ders 21/03/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    SQL cümlesini server’a gönderip işletmek için MySQL_query fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    int mysql_query(MYSQL *MySQL, const char *stmt_str);

    Fonksiyonun birinci parametresi handle değerini, ikinci parametresi SQL komut yazısını alır. Fonksiyon başarı durumunda 
    sıfır, başarısızlık durumunda sıfır dışı bir değere geri döner. Örneğin:

    if (mysql_query(db, u8"INSERT INTO student_info(student_name, student_no) VALUES('Ali Eker', 345)") != 0)
        exit_err("mysql_query", db);

    Aşağıda program bir bütün olarak verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <mysql.h>

void exit_err(const char *msg, MYSQL *db);

int main(void)
{
    MYSQL *db;
    int ssl_mode;

    if ((db = mysql_init(NULL)) == NULL)
        exit_err("mysql_init failed", NULL);

    ssl_mode = SSL_MODE_DISABLED;
    if (mysql_options(db, MYSQL_OPT_SSL_MODE, &ssl_mode))
        exit_err("mysql_options failed", db);

    if (mysql_real_connect(db, "localhost", "root", "kaanaslan1966", "student", 3306, NULL, 0) == NULL)
        exit_err("mysql_real_connect failed", db);

    if (mysql_query(db, u8"INSERT INTO student_info(student_name, student_no, student_school_id) VALUES('Ali Eker', 122, 1)") != 0)
        exit_err("mysql_query", db);

    printf("Ok\n");

    mysql_close(db);

    return 0;
}

void exit_err(const char *msg, MYSQL *db)
{
    fprintf(stderr, "%s: %s\n", msg, mysql_error(db));
    if (db != NULL)
        mysql_close(db);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    MySQL server'ı Linux'ta kullanıyorsanız tüm ayarlar default durumda Unicode UTF-8 enconding'ine ilişkindir. Linux ortamında 
    uzun süredir default encoding zaten Unicode UTF-8 olduğu için bu ortamda çalışırken bir encoding sorunu ortaya çıkmayacaktır. 
    Ancak Windows sistemlerinde MySQL server kurulduğunda default encoding Unicode UTF-8 yerine Microsoft'un 1254 Code Page'i
    olabilir. MySQL'de encoding çeşitli düzeylerde değiştirilebilmektedir. Örneğin:

    - Server Düzeyinde
    - Veritabanı Düzeyinde
    - Tablo Düzeyinde
    - Tablonun Sütunu Düzeyinde

    Aşağıdaki belirleme yukarıda yapılan belirlemeyi devre dışı bırakmaktadır. Ayrıca MySQL'de client programlar da server
    ile bağlandığında server'dan belli bir encoding kullanmasını isteyebilmektedir. Yani server ayarları yapılmış olsa bile 
    client programların da encoding isteklerinin uygun olması gerekebilmektedir. Client'ın default encoding davranışı da aslında
    server ayarlarından belirlenebilmektedir. Client için bu ayar uygun değilse client program bağlantıdan sonra mysql_options
    fonksiyonu ile bunu aşağıdaki gibi değiştirebilir:

    if (mysql_options(db, MYSQL_SET_CHARSET_NAME, "utf8") != 0)
        exit_err("mysql_options_failed", db);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Belli koşulu sağlayan kayıtların ele geçirilmesi için başka bir deyişle SELECT cümlesi ile seçilen kayıtların elde 
    edilmesi için birkaç yol vardır. Bunun için önce SELECT cümlesi yine sql_query fonksiyonuyla uygulanır. Sonra select 
    edilen kayıtların elde edilmesi için şu işlemler yapılır:

    1) mysql_store_result fonksiyonu çağrılarak bir “result handle değeri” elde edilir:

    MYSQL_RES *mysql_store_result(MYSQL *MySQL);

    Fonksiyon parametre olarak bizden mysql_init ile elde edilen handle değerini alır ve bize kayıtları elde etmemiz için 
    gereken MYSQL_RES * türünden bir handle değeri verir. Fonksiyon başarısız olursa NULL adrese geri dönmektedir.

    2) Kayıtların tek tek ele geçirilmesi için mysql_fetch_row fonksiyonu bir döngü içerisinde çağrılır. Bu fonksiyonun 
    prototipi şöyledir:

    MYSQL_ROW mysql_fetch_row(MYSQL_RES *result);

    Fonksiyon mysql_store_result fonksiyonundan elde edilen handle değerini alır ve MYSQL_ROW türüyle geri döner. Bu tür 
    aslında char ** biçiminde typedef edilmiştir. Yani char türünden göstericileri tutan dizinin adresini belirtir. İşte 
    bu fonksiyon NULL adres döndürene kadar döngü içerisinde ilerlenir. Artık kayıtlara ilişkin sütun bilgilerine MYSQL_ROW 
    türünden göstericiye sütun numarası indeks yapılarak erişilir. Ancak bu türden erişim bize tüm sütunları yazı gibi 
    vermektedir. Kayıtlar elde edildikten sonra mysql_store_result ile elde edilen alan mysql_free_result fonksiyonu ile 
    boşaltılmalıdır. Fonksiyonun parametrik yapısı şöyledir:

    void mysql_free_result(MYSQL_RES *result);

    Örneğin:

    if (mysql_query(db, "SELECT student_name, student_no FROM student_info") != 0)
        exit_err("mysql_query", db);

    if ((res = mysql_store_result(db)) == NULL)
        exit_err("mysql_store_result", db);

    while ((row = mysql_fetch_row(res)) != NULL)
        printf("%s, %s\n", row[0], row[1]);

    mysql_free_result(res);

    Burada önce SELECT cümlesi server'a gönderilmiş, sonra mysql_store_result fonksiyonu ile sonuçlar alınıp satırlar da 
    mysql_fetch_row çağrıları ile tek tek elde edilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <mysql.h>

void exit_err(const char *msg, MYSQL *db);

int main(void)
{
    MYSQL *db;
    int ssl_mode;
    MYSQL_RES *res;
    MYSQL_ROW row;

    if ((db = mysql_init(NULL)) == NULL)
        exit_err("mysql_init failed", NULL);

    if (mysql_options(db, MYSQL_SET_CHARSET_NAME, "utf8") != 0)
        exit_err("mysql_options_failed", db);

    ssl_mode = SSL_MODE_DISABLED;
    if (mysql_options(db, MYSQL_OPT_SSL_MODE, &ssl_mode) != 0)
        exit_err("mysql_options failed", db);

    if (mysql_real_connect(db, "localhost", "root", "kaanaslan1966", "student", 3306, NULL, 0) == NULL)
        exit_err("mysql_real_connect failed", db);

    if (mysql_query(db, "SELECT student_name, student_no FROM student_info") != 0)
        exit_err("mysql_query", db);

    if ((res = mysql_store_result(db)) == NULL)
        exit_err("mysql_store_result", db);

    while ((row = mysql_fetch_row(res)) != NULL)
        printf("%s, %s\n", row[0], row[1]);

    mysql_free_result(res);
    mysql_close(db);

    return 0;
}

void exit_err(const char *msg, MYSQL *db)
{
    fprintf(stderr, "%s: %s\n", msg, mysql_error(db));
    if (db != NULL)
        mysql_close(db);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                205. Ders 23/03/2025 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bu son bölümde işletim sistemlerindeki GUI (Graphical User Interface) çalışma modeli hakkında temel bilgiler vereceğiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bilgisayar ekranları temel olarak iki modda çalışmaktadır:

    1) Text Mod
    2) Grafik Mod

    Eskiden text mod çalışma çok yaygındı. Çünkü grafik kartları henüz gelişkin değildi. Ancak son 20 senedir grafik mod çalışma 
    baskın hale gelmiştir.

    Text modda ekrana basılabilecek en küçük birim bir karakterdir. Bu karakterler kalıp olarak ekrana basılmaktadır. Dolayısıyla 
    text modda çalışma çok hızlıdır. Ancak text modda resimler görüntülenemez, filmler izlenemez.

    Grafik modda ekranda görüntülenebilen en küçük görsel öğeye "pixel" denilmektedir. Pixel bir noktadır. İşte grafik modda 
    ekrandaki tüm görsel öğeler bu pixel'lerin bir araya getirilmesiyle oluşmaktadır. Her pixel'in rengi diğerlerinden bağımsız 
    bir biçimde ayarlanabilmektedir. Bugünkü grafik kartlarında ve monitörlerde her pixel "kırmızı (red)", "yeşil (green)" ve 
    "mavinin (blue)" birer byte'lık tonal bileşimleriyle oluşturulmaktadır. Bir byte 8 bit olduğu için bir pixel 2^8 * 2^8 * 2^8 
    = 2^24 ≃ 16 milyon renkten herhangi biriyle renklendirilebilmektedir. Aslında grafik modda tüm resimler ve yazılar bu 
    pixel'lerin bir araya getirilmesiyle oluşturulmaktadır. Ekranı bir pixel matrisi olarak düşünebilirsiniz. Örneğin 1920x1080 
    HD çözünürlükte matriste 1920 sütun 1080 tane de satır bulunmaktadır. Yani ekranda toplam 2 milyon civarı pixel bulunur.

    Aynı monitörde çözünürlüğü yükseltirsek pixel'ler küçülür, resimler ve yazılar ekranda daha küçük görünür hale gelir, ancak 
    ekrana daha fazla içerik sığar. Eğer çözünürlük düşürülürse bu kez pixel'ler büyür, yazılar ve resimler büyük gözükür. 
    Pekiyi çözünürlük sabit bırakılıp ekran büyütülürse ne olur? Yine pixel'ler büyüyecektir. Bu durumda çözünürlük yükseltildikçe 
    her şey küçüleceği için monitörün büyütülmesi uygun olur. Monitör büyüklüğü ile pixel yoğunluğu arasındaki ilişki "DPI (Dot 
    Per Inch)" bir terimle ifade edilmektedir. DPI bir inch'teki pixel sayısıdır. Çözünürlük aynı kalıp monitör büyütülürse DPI 
    düşer, çözünürlük aynı kalıp monitör küçültülürse DPI yükselir. Benzer biçimde monitör aynı kalıp çözünürlüğü düşürürsek 
    DPI düşecek, monitör aynı kalıp çözünürlüğü yükseltirsek DPI artacaktır. Belli bir DPI değerinden sonra artık çözünürlüğü 
    artırmanın da bir anlamı kalmamaktadır. Çünkü insan gözündeki algılayıcı kısım olan retinanın da bir çözünürlüğü vardır.

    Ekrandaki görüntü aslında grafik kartları (GPU) tarafından oluşturulmaktadır. Görüntüyü ekran kartları oluşturur, onu belli 
    periyotta monitöre yollar, monitör de pixel'leri görüntüler. Yani monitör pasif bir aygıttır. Asıl işi yapan kısım grafik 
    kartlarıdır.

    Ekranın bir bölümü text modda bir bölümü grafik modda olmaz. Bugün GUI arayüzlü işletim sistemlerinde konsol pencerelerini 
    açtığımızda o pencereler text modda çalışmamaktadır. Konsol pencereleri grafik modda text modu pixel'lerle simüle etmektedir. 
    Text mod çalışma çok yaygın ve pratik olduğu için bugün yine yoğun bir biçimde kullanılmaktadır.

    Ekran koordinat sisteminde genellikle ekranın sol üst köşesi orijin noktasıdır. X ekseni sağa doğru, Y ekseni aşağıda 
    doğru ilerlemektedir. Ekran koordinat sisteminde her pixel'in bir koordinatı vardır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                206. Ders 11/04/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi mademki GUI çalışma çok zengin olanaklar sunuyor, pekiyi neden o zaman hala konsol uygulamaları kullanılıyor? 
    İşte GUI programların yazılması oldukça zordur. GUI programların yazılmasını kolaylaştırmak için pek çok yüksek seviyeli 
    kütüphaneler oluşturulmuştur. Oysa text modda klasik konsol çalışma modeli oldukça basittir. Bazı sistemler ise hiç GUI 
    arayüzüne sahip olmayabilmektedir. Örneğin UNIX/Linux sistemlerinde hala klasik konsol çalışma modeli çok yaygın biçimde 
    kullanılmaktadır. (UNIX/Linux sistemleri özellikle sunucularda kullanıldığı için ve sunucuların grafik arayüze sahip olması 
    onların hızını ve kaynak kullanımını yavaşlatacağı için bu sistemlerde klasik konsol çalışma modeli hala en yaygın modeldir.)

    GUI çalışma modeli ile klasik konsol çalışma modelini karşılaştırırsak şunları söyleyebiliriz:

    - GUI çalışma modelinin uygulanması için bilgisayar sisteminin bazı gelişmiş özelliklere sahip olması gerekir. Halbuki 
    konsol çalışma modeli DOS gibi basit işletim sistemlerinde ve onların çalıştığı eski donanımlarda bile oldukça verimli
    bir biçimde uygulanabiliyordu.

    - GUI çalışma modelini kullanarak program yazmak oldukça zordur. Programcılar işlerini kolaylaştırmak için yüksek seviyeli
    GUI kütüphanelere gereksinim duyarlar. Bu da ek bir çalışma ve eğitim gerektirmektedir.

    - GUI çalışma modeli konsol çalışma modeline göre yavaştır ve çok daha fazla sistem kaynağına gereksinim duymaktadır.

    - GUI çalışma modeli modern grafiksel bir girdi ve çıktı ortamı sunmaktadır. Halbuki konsol çalışma ortamında her şey
    karakterlerin kalıp olarak konsol ekranına basılmasıyla oluşturulmaktadır. Yani GUI çalışma modeli albenili ve zengin 
    bir arayüz sunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Windows’un çekirdek (kernel) ile entegre edilmiş bir GUI alt sistemi vardır. Başka bir deyişle Windows’ta pencereli 
    çalışma başka bir katman tarafından değil, doğrudan işletim sisteminin çekirdeği tarafından sağlanmaktadır. Windows’u 
    GUI alt sistemi olmadan kullanmak mümkün olsa da uygulamada çok zordur. Windows'ta GUI arayüz olmadan çalışmak anlamlı 
    değildir.

    UNIX/Linux sistemlerinde grafik arayüz çekirdeğin üzerine oturtulan ve ismine X11 (ya da XWindow) denilen bir alt sistem 
    tarafından sağlanmaktadır. Yani örneğin Linux’un çekirdeğinin kaynak kodlarında pencere kavramına ilişkin hiçbir şey yoktur. 
    Ancak Windows’ta vardır. Zaten Linux sistemlerinde doğal çalışma grafik arayüz ile değil, text ekrandaki konsol arayüzü 
    ile sağlanmaktadır. Server olarak kullanılan Linux sistemlerinde de genellikle sistemi yavaşlattığı gerekçesiyle grafik 
    arayüz kullanılmamaktadır. Son yıllarda UNIX/Linux dünyasında klasik X11 GUI alt sistemine bir alternatif olarak "Wayland" 
    isimli yeni bir alt sistem de tasarlanmıştır. Wayland alt sistemi X11'e göre daha modern ve hızlı bir tasarıma sahip olmakla 
    birlikte henüz yaygınlaşmamıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    X11 grafik sistemi client-server tarzda çalışmaktadır. Yani sanki X11 bir server program gibidir, pencere açmak ve pencereler 
    üzerinde işlemler yapmak isteyen programlar da client programlar gibidir. X11 sisteminde işlem yapabilmek için oluşturulmuş 
    temel kütüphaneye Xlib denilmektedir. Xlib'i X11’in API kütüphanesi olarak düşünebiliriz. Son yıllarda Xlib’in XCB isimli 
    daha modern bir versiyonu da oluşturulmuştur. Xlib ve XCB temelde C Programlama Dili'nden kullanılmak için tasarlanmıştır. 
    Ancak bu kütüphaneler başka dillerden de kullanılabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Grafik arayüze sahip pencereli sistemlerde genel olarak "mesaj tabanlı (message driven)" ya da "olay tabanlı (event driven)" 
    denilen çalışma modeli kullanılmaktadır. Mesaj tabanlı çalışma modelinin ayrıntıları sistemden sisteme değişebilmekle birlikte 
    burada biz her sistemde geçerli olan bazı temel bilgileri vermekle yetineceğiz.

    Mesaj tabanlı programlama modelinde klavye ve fare gibi aygıtlarda oluşan girdileri programcı kendisi almaya çalışmaz. 
    klavye gibi, fare gibi girdi aygıtlarını işletim sisteminin (ya da GUI alt sisteminin) kendisi izler. Oluşan girdi olayı 
    hangi pencereye ilişkinse işletim sistemi ya da GUI alt sistem, bu girdi olayını “mesaj” adı altında bir yapıya dönüştürerek 
    o pencerenin ilişkin olduğu (yani o pencereyi yaratan) programın “mesaj kuyruğu (message queue)” denilen bir kuyruk sistemine 
    yerleştirir. Mesaj kuyruğu içerisinde mesajların bulunduğu FIFO prensibiyle çalışan bir kuyruk veri yapısıdır. Sistemin daha 
    iyi anlaşılması için süreci maddeler halinde özetlemek istiyoruz:

    1) Her programın (thread'li sistemlerde her thread’in) “mesaj kuyruğu” denilen bir kuyruk veri yapısı vardır. Mesaj kuyruğu 
    mesajlardan oluşmaktadır.

    2) İşletim sistemi ya da GUI alt sistem gerçekleşen girdi olaylarını “mesaj (message)” adı altında bir yapı biçimine dönüşürmekte 
    ve bunu pencerenin ilişkin olduğu programın (ya da thread’in) mesaj kuyruğuna eklemektedir.

    3) Mesajlar ilgili olayı betimleyen ve ona ilişkin bazı bilgileri barındıran yapı (structure) nesneleridir. Örneğin Windows’ta 
    mesajlar MSG isimli bir yapıyla temsil edilmişleridir. Bu yapının elemanlarında mesajın ne mesajı olduğu (yani neden gönderildiği) 
    ve mesajın gönderilmesine neden olan olaya ilişkin bazı parametrik bilgiler bulunur.

    Görüldüğü gibi GUI programlama modelinde girdileri programcı elde etmeye çalışmamaktadır. Girdileri bizzat işletim sisteminin 
    kendisi ya da GUI alt sistemi elde edip programcıya mesaj adı altında iletmektedir.

    GUI programlama modelinde işletim sisteminin (ya da GUI alt sisteminin) oluşan mesajı ilgili programın (ya da thread’in) mesaj 
    kuyruğuna eklemenin dışında başka bir sorumluluğu yoktur. Mesajların kuyruktan alınarak işlenmesi ilgili programın sorumluluğundadır. 
    Böylece GUI programcısının mesaj kuyruğuna bakarak sıradaki mesajı alması ve ne olmuşsa ona uygun işlemleri yapması gerekir. Bu 
    modelde programcı kodunu şöyle düzenler: "Bir döngü içerisinde sıradaki mesajı kuyruktan al, onun neden gönderildiğini belirle, 
    uygun işlemleri yap, kuyrukta mesaj yoksa da blokede bekle”. İşte GUI programlarındaki mesaj kuyruğundan mesajı alıp işleyen döngüye 
    mesaj döngüsü (message loop) denilmektedir.

    Bir GUI programının işleyişini tipik akışı aşağıdaki gibi bir kodla temsil edebiliriz:

    int main(void)
    {
        <programın ana penceresini yarat>

        for (;;) {
            <mesaj kuyruğundan sıradaki mesajı al>
            <mesajın ne mesajı olduğunu anla ve gerekeni yap>
            if (mesaj pencerenin x tuşuna basma mesajı mı)
                break;
        }

        return 0;
    }

    Bu temsili koddan da görüldüğü gibi tipik bir GUI programında programcı bir döngü içerisinde mesaj kuyruğundan sıradaki 
    mesajı alır ve onu işler. Mesajın işlenmesi ise “ne olmuş ve ben buna karşı ne yapmalıyım?” biçiminde oluşturulmuş olan 
    kodlarla yapılmaktadır.

    Pekiyi bir GUI programı nasıl sonlanmaktadır? İşte pencerenin sağındaki (bazı sistemlerde solundaki) X simgesine kullanıcı 
    tıkladığında işletim sistemi ya da GUI alt sistem bunu da bir mesaj olarak o pencerenin ilişkin olduğu prosesin (ya da 
    thread’in) mesaj kuyruğuna bırakır. Programcı da kuyruktan bu mesajı alarak mesaj döngüsünden çıkar ve program sonlanır.

    GUI ortamımız (framework) ister .NET, ister Java, ister MFC, isterse Qt olsun, işletim sisteminin ya da GUI alt sisteminin 
    çalışması hep burada ele açıklandığı gibidir. Yani örneğin biz .NET'te ya da Java'da işlemlerin sanki başka biçimlerde 
    yapıldığını sanabiliriz. Aslında işlemler bu ortamlar tarafından aşağı seviyede yine burada anlatıldığı gibi yapılmaktadır. 
    Bu ortamlar (frameworks) ya da kütüphaneler çeşitli yükleri üzerimizden alarak bize daha rahat bir çalışma modeli sunarlar. 
    Ayrıca şunu da belirtmek istiyoruz: GUI programlama modeli özellikle nesne yönelimli programlama modeline çok uygun düşmektedir. 
    Bu nedenle bu konuda kullanılan kütüphanelerin büyük bölümü sınıflar biçiminde nesne yönelimli diller için oluşturulmuş 
    durumdadır. Örneğin Qt Framework C++ ile, .NET Forms ve WPF Framework'leri C# ile (ya da diğer nesne yönelimli .NET dilleri 
    ile) kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi GUI programlama modelindeki mesaj kavramını biraz daha açalım. Yukarıda da belirttiğimiz gibi bu modelde programcıyı 
    ilgilendiren çeşitli olaylara “mesaj” denilmektedir. Örneğin klavyeden bir tuşa basılması, pencere üzerinde fare ile 
    tıklanması, pencere içerisinde farenin hareket ettirilmesi gibi olaylar hep birer mesaj oluşturmaktadır. İşletim sistemleri 
    ya da GUI alt sistemleri mesajları birbirinden ayırmak için onlara birer numara karşılık getirirler. Örneğin Windows’ta 
    mesaj numaraları WM_XXX biçiminde sembolik sabitlerle kodlanmıştır. Programcılar da konuşurken ya da kod yazarken mesaj 
    numaralarını değil, bu sembolik sabitleri kullanırlar. (Örneğin WM_LBUTTONDOWN, WM_MOUSEMOVE, WM_KEYDOWN gibi) Mesajların 
    numaraları yalnızca gerçekleşen olayın türünü belirtmektedir. Oysa bazı olaylarda gerçekleşen olaya ilişkin bazı bilgiler 
    de söz konusudur. İşte bir mesaja ilişkin o mesaja özgü bazı parametrik bilgiler de işletim sistemi ya da GUI alt sistemi 
    tarafından mesajın bir parçası olarak mesajın içerisine kodlanmaktadır. Örneğin Windows’ta biz klavyeden bir tuşa bastığımızda 
    Windows WM_KEYDOWN isimli mesajı programın mesaj kuyruğuna bırakır. Bu mesajı kuyruktan alan programcı mesaj numarasına 
    bakarak klavyenin bir tuşuna basılmış olduğunu anlar. Fakat hangi tuşa basılmıştır? İşte Windows basılan tuşun bilgisini 
    de ayrıca bu mesajın içerisine kodlamaktadır. Örneğin WM_LBUTTONDOWN mesajını Windows farenin sol tuşuna tıklandığında 
    kuyruğa bırakır. Ancak ayrıca basım koordinatını da mesaja ekler. Yani bir mesaj oluştuğunda yalnızca o mesajın hangi tür 
    bir olay yüzünden oluştuğu bilgisini değil, aynı zamanda o olayla ilgili bazı bilgileri de kuyruktaki mesajın içerisinden 
    alabilmekteyiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                207. Ders 18/04/2025 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Windows'ta GUI programları en aşağı seviyede Windows API fonksiyonları kullanılarak yazılmaktadır. Ekrana boş bir pencere
    çıkartan iskelet bir GUI programı aşağıdaki gibi yazılabilir:

    #include <windows.h>

    LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

    int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdParam, int nCmdShow)
    {
        WNDCLASS wndClass;
        HWND hWnd;
        MSG message;

        if (!hPrevInstance) {
            wndClass.style = CS_HREDRAW | CS_VREDRAW;
            wndClass.cbClsExtra = 0;
            wndClass.cbWndExtra = 0;
            wndClass.hInstance = hInstance;
            wndClass.hIcon = LoadIcon(NULL, IDI_QUESTION);
            wndClass.hbrBackground = GetStockObject(WHITE_BRUSH);
            wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);
            wndClass.lpszMenuName = NULL;
            wndClass.lpszClassName = "Generic";
            wndClass.lpfnWndProc = (WNDPROC)WndProc;
            if (!RegisterClass(&wndClass))
                return -1;
        }
        hWnd = CreateWindow("Generic", "Sample Windows", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0,
            CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);
        if (!hWnd)
            return -1;
        ShowWindow(hWnd, SW_RESTORE);
        UpdateWindow(hWnd);
        while (GetMessage(&message, 0, 0, 0)) {
            TranslateMessage(&message);
            DispatchMessage(&message);
        }
        return message.wParam;
    }

    LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
    {
        switch (message) {
        case WM_DESTROY:
            PostQuitMessage(0);
            break;
        default:
            return DefWindowProc(hWnd, message, wParam, lParam);
        }
        return 0;
    }

    Windows sistemlerinde iskelet GUI programında şunların sırasıyla yapılması gerekmektedir:

    1) Önce WNDCLASS türünden bir yapı nesnesi tanımlanıp bunun içi doldurulur ve bu yapı RegisterClass APIO fonksiyonu ile
    sisteme register ettirilir. Bu WNDCKASS belirlemelerine "pencere sınıfı" denilmektedir. Örneğin:

    WNDCLASS wndClass;

    if (!hPrevInstance) {
        wndClass.style = CS_HREDRAW | CS_VREDRAW;
        wndClass.cbClsExtra = 0;
        wndClass.cbWndExtra = 0;
        wndClass.hInstance = hInstance;
        wndClass.hIcon = LoadIcon(NULL, IDI_QUESTION);
        wndClass.hbrBackground = GetStockObject(WHITE_BRUSH);
        wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);
        wndClass.lpszMenuName = NULL;
        wndClass.lpszClassName = "Generic";
        wndClass.lpfnWndProc = (WNDPROC)WndProc;
        if (!RegisterClass(&wndClass))
            return -1;
    }

    2) Programın ana penceresi pencere sınıfı kullanılarak yaratılır:

    hWnd = CreateWindow("Generic", "Sample Windows", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, 
                CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);
    if (!hWnd)
        return -1;

    Ana pencere yaratıldıktan sonra pencerenin görünür hale getirilmesi gerekmektedir:

    ShowWindow(hWnd, SW_RESTORE);
    UpdateWindow(hWnd);

    3) Artık program mesaj döngüsüne girmelidir. Mesaj döngüsü kuyruktan sıradaki mesajı alıp bunu işleyen döngüdür. Mesaj
    döngüsü şöyle oluşturulmaktadır:

    while (GetMessage(&message, 0, 0, 0)) {
        TranslateMessage(&message);
        DispatchMessage(&message);
    }

    Burada GetMessage API fonksiyonu mesaj kuyruğundan mesajı alır. TranslateMessage klavye mesajları için bazı dönüştürmeleri 
    yapmaktadır. Mesajın işlenmesine yol açan fonksiyon DispatchMessage isimli API fonksiyonudur. Ancak DispatchMessage aslında
    pencere sınıfında belirtilen fonksiyonun çağrılmasına yol açmaktadır. Örneğimizde bu fonksiyon WndProc ismindedir. Yani
    DispatchMessage yapıldığında aslında WndProc fonksiyonu çağrılmaktadır. Buna "pencere fonksiyonu" denir. Programcı mesajı
    bu fonksiyon içerisinde işler. WndProc fonksiyonu şöyle yazılmıştır:

    LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
    {
        switch (message) {
            case WM_DESTROY:
                PostQuitMessage(0);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
        }
        return 0;
    }

    Windows'ta kuyruğa bırakılan bazı mesajların mutlaka işlenmesi gerekir. Bu işlem de çok sıkıcı olduğu için DefWindowProc
    isimli bir fonksiyon bulundurulmuştur. Programcı tarafından işlenmeyen mesajlar DefWindowProc fonksiyonuna verilir. Bu 
    fonksiyon mesaj için gereken bazı default işlemler varsa onu yapar. Programın sonlanması pencerenin X simgesine tıklanarak 
    yapılır. Bu durumda Windows kuyruğa WM_CLOSE isimli mesajı bırakır. DefWindowProc bu mesaj için DestroyWindow fonksiyonunu
    çağırır. Bu fonksiyon da WM_DESTROY mesajını oluşturur. Bu mesajda programcı PostQuitMessage API fonksiyonunu çağırır. 
    Bu API fonksiyonu da kuyruğa WM_QUIT mesajını bırakır. WM_QUIT mesajını alan GetMessage fonksiyonu 0 ile geri döner. 
    Böylece döngü sonlanır ve program da biter.
---------------------------------------------------------------------------------------------------------------------------*/

#include <windows.h>

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdParam, int nCmdShow)
{
    WNDCLASS wndClass;
    HWND hWnd;
    MSG message;

    if (!hPrevInstance) {
        wndClass.style = CS_HREDRAW | CS_VREDRAW;
        wndClass.cbClsExtra = 0;
        wndClass.cbWndExtra = 0;
        wndClass.hInstance = hInstance;
        wndClass.hIcon = LoadIcon(NULL, IDI_QUESTION);
        wndClass.hbrBackground = GetStockObject(WHITE_BRUSH);
        wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);
        wndClass.lpszMenuName = NULL;
        wndClass.lpszClassName = "Generic";
        wndClass.lpfnWndProc = (WNDPROC)WndProc;
        if (!RegisterClass(&wndClass))
            return -1;
    }
    hWnd = CreateWindow("Generic", "Sample Windows", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0,
        CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);
    if (!hWnd)
        return -1;
    ShowWindow(hWnd, SW_RESTORE);
    UpdateWindow(hWnd);
    while (GetMessage(&message, 0, 0, 0)) {
        TranslateMessage(&message);
        DispatchMessage(&message);
    }
    return message.wParam;
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    case WM_LBUTTONDOWN:
        MessageBox(hWnd, u8"Farenin sol tuşuna basıldı", "Mesaj", MB_OK);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi UNIX/Linux sistemlerinde XWindow ya da X11 denilen bir katman kullanılmaktadır. Bu 
    katmanın API fonksiyonlarına Xlib ya da bunun modern biçimine XCB denilmektedir. Xlib ya da XCB çok aşağı seviyeli bir 
    kütüphanedir. Bu kütüphane kullanılarak GUI elemanlarını oluşturan X-Toolkit ya da kısaca Xt isimli ayrı bir kütüphane 
    vardır. Bu Xt üzerine kurulan Motif gibi başka kütüphaneler de vardır. Ayrıca Xlib ya da XCB üzerine kurulmuş olan iki 
    önemli kütüphane de Qt ve GTK (GTK+ da denilmektedir) kütüphanelerdir. Qt kütüphanesi C++ ile yazılmıştır, dolayısıyla 
    Qt için kodlar da C++ ile yazılmaktadır. GTK ise C'de yazılmıştır.

                          +----------------------------+
                          |      GUI Uygulamaları      |
                          +----------------------------+
                           /            |          \
                          /             |           \
                         /              |            \
                   +-------+        +--------+     +---------+
                   |  GTK  |        |   Qt   |     |  Motif  |
                   +-------+        +--------+     +---------+
                       |                |               |
            +----------+-----+      +--+--+--+      +---+--+
            | Xlib / Wayland |      |Xlib/XCB|      |  Xt  |
            +----------+-----+      +--+--+--+      +---+--+
                       |                |               |
                       |                |           +--+--+--+
                       |                |           |Xlib/XCB|
                       |                |           +--+--+--+
                       |                |               |
         +-------------+----------------+---+-----------+-----------------+
         |      X Window System (X11)       |     Wayland (alternatif)    |
         +----------------------------------+-----------------------------+
         |                  Donanım / OS (Çekirdek, GPU)                  |
         +----------------------------------------------------------------+

    Şimdi de bu kütüphanelerin hiyerarşisini tek tek gösterelim. GTK kütüphanesini şöyle gösterebiliriz:

    +--------------------+
    |        GTK         |
    +--------------------+
    |   Xlib / Wayland   |
    +--------------------+
    | X Window / Wayland |
    +--------------------+

    Xt kütüphanesini şöyle gösterebiliriz:

    +--------------------+
    |         Xt         |
    +--------------------+
    |        Xlib        |
    +--------------------+
    |      X Window      |
    +--------------------+

    Motif kütüphanesini şöyle gösterebiliriz:

    +--------------------+
    |       Motif        |
    +--------------------+
    |         Xt         |
    +--------------------+
    |        Xlib        |
    +--------------------+
    |      X Window      |
    +--------------------+

    Qt kütüphanesini de şöyle gösterebiliriz:

    +--------------------+
    |         Qt         |
    +--------------------+
    |   Xlib / Wayland   |
    +--------------------+
    | X Window / Wayland |
    +--------------------+

    Bugün artık Xt ve Motif yeni uygulamalar tarafından pek kullanılmamaktadır. Bu nedenle yüksek seviyeli kütüphaneler için
    önemli iki alternatif GTK ve Qt kütüphaneleridir. GTK kütüphanesi C ile kullanılabilir. Ancak Qt için C++ bilmek gerekir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Xlib ya da XCB kütüphaneleri oldukça düşük seviyeli kütüphanelerdir. Bunlar aslında X Window sistemlerinin aşağı seviyeli
    API kütüphanesi gibi düşünülebilir. Xlib ile GUI uygulamaları yazmak çok zordur. Çünkü Xlib içerisinde pencere yaratan 
    öğeler olsa da GUI uygulamalarında kullanılan düğmeler (push buttons), listeleme kutuları (listbox), checkbox gibi 
    grafik elemanlar bulunmamaktadır. Eğer C kullanılarak bu GUI elemanlar ile gelişmiş GUI programlar oluşturmak istiyorsanız
    GTK kütüphanesini kullanabilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de UNIX/Linux sistemlerinde en düşük seviyede Xlib kullanan iskelet bir GUI programını yazmaya çalışalım. Bu program 
    ekrana boş bir pencere çıkartacaktır. Bunun öncelikle Xlib kütüphanesinin kurulması gerekmektedir. Bu işlem Debian tabanlı
    sistemlerde şöyle yapılabilir:

    $ sudo apt-get install libx11-dev

    Derleme işlemi sırasında X11 kütüphanesinin "-lX11" seçeneği ile belirtilmesi gerekmektedir. Örneğin:

    $ gcc -o generic-xlib generic-xlib.c -lX11

    Ekrana boş bir pencere çıkartan iskelet GUI programı şöyle yazılabilir:

    /* generic-xlib.c */

    #include <X11/Xlib.h>
    #include <stdio.h>
    #include <stdlib.h>

    int main(void)
    {
        Display *disp;
        Window w;
        XEvent e;
        int scr;

        disp = XOpenDisplay(NULL);
        if (disp == NULL) {
            fprintf(stderr, "Cannot open display\n");
            exit(1);
        }

        scr = DefaultScreen(disp);
        w = XCreateSimpleWindow(disp, RootWindow(disp, scr), 10, 10, 100, 100, 1,
                BlackPixel(disp, scr), WhitePixel(disp, scr));
        XSelectInput(disp, w, ExposureMask | KeyPressMask);
        XMapWindow(disp, w);

        for (;;) {
            XNextEvent(disp, &e);
            if (e.type == KeyPress)
                break;
        }

        XCloseDisplay(disp);

        return 0;
    }

    Burada sırasıyla şu işlemler yapılmıştır:

    1) XOpenDisplay fonksiyonu XWindow sunucusu ile bağlantı kurmak için kullanılmaktadır. Bu fonksiyon başarı durumunda bize 
    Display türünden bir handle verir.

    2) Daha sonra biz bu handle’ı vererek bir ekran (screen) nesnesi yaratmamız gerekir. Bu işlem de DefaultScreen fonksiyonuyla 
    yapılmaktadır. Bu fonksiyon bize ilgili ekranı betimleyen int türden bir değer vermektedir.

    3) Örnek programımızda daha sonra uygulamanın ana penceresi XCreateSimpleWindow fonksiyonuyla yaratılmıştır. Bu fonksiyon 
    bize Window * türünden yaratılan pencereye ilişkin bir handle değeri vermektedir.

    4) Programda daha sonra mesaj döngüsüne girmeden önce hangi girdi olaylarının izleneceğini belirlemek için XSelectInput 
    fonksiyonu çağrılmıştır.

    5) Mesaj döngüsünden sıradaki mesaj XNextEvent fonksiyonuyla elde edilmektedir. (Bu fonksiyonu Windows'ta GetMessage API 
    fonksiyonuna benzetebilirsiniz. Bu fonksiyon bize kuyruktaki mesajı XEvent isimli bir yapı olarak verir. Örnek programımızda 
    bir tuşa basıldığında mesaj döngüsünden çıkılmaktadır.

    6) Mesaj döngüsünden çıkıldığında XCloseDisplay fonksiyonu ile daha önce alınmış olan ekran geri bırakılmıştır. Tabii 
    ekran yok edildiğinde tüm pencereler de yok edilecektir. Ayrıca program sonlandığında X11 sistemi ile bağlantı da otomatik 
    koparılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    GTK pek çok ayrıntıya sahip olan C tabanlı bir GUI kütüphanesidir. GTK kütüphanesinin son versiyonu GTK 4'tür. Bu versiyon 
    2020'de oluşturulmuştur. Ancak önceki versiyon olan GTK 3 halen daha yoğun olarak kullanılmaktadır. GTK 3 Debian tabanlı 
    sistemlerde şöyle kurulabilir:

    $ sudo apt-get install libgtk-3-dev

    GTK 4 ise şöyle kurulabilir:

    $ sudo apt-get install libgtk-4-dev

    GTK 3 ile GTK 4 birbirine çok benzemekle birlikte tam uyumlu değildir.

    Biz burada GTK 4 için bazı küçük örnekler vereceğiz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Ekrana boş bir pencere çıkartan iskelet GTK 4 programı şöyle oluşturulabilir:

    #include <gtk/gtk.h>

    void activate(GtkApplication *app, gpointer user_data)
    {
        GtkWidget *window;

        // Yeni pencere oluştur
        window = gtk_application_window_new(app);
        gtk_window_set_title(GTK_WINDOW(window), "Sample Window");
        gtk_window_set_default_size(GTK_WINDOW(window), 400, 300);

        gtk_window_present(GTK_WINDOW(window));
    }

    int main(int argc, char **argv)
    {
        GtkApplication *app;
        int status;

        // Uygulama nesnesini oluştur
        app = gtk_application_new("com.generic.application", G_APPLICATION_FLAGS_NONE);
        g_signal_connect(app, "activate", G_CALLBACK(activate), NULL);

        // Uygulamayı çalıştır
        status = g_application_run(G_APPLICATION(app), argc, argv);

        // Hafızayı temizle
        g_object_unref(app);

        return status;
    }

    Bu program şöyle derlenebilir:

    $ gcc -o generic-gtk generic-gtk.c $(pkg-config --cflags --libs gtk4)

    Burada $(pkg-config --cflags --libs gtk4) ifadesi pkg-config programının çıktısının komut satırına yerleştirilmesini 
    sağlamaktadır. GTK 4 programlarının derlenmesi için komut satırında çeşitli include dizinlerine ilişkin seçeneklerin ve 
    birden fazla dinamik kütüphanenin devreye sokulması gerekmektedir. Bu $(pkg-config --cflags --libs gtk4) ifadesi aslında
    gereken komut satırı argümanlarını oluşturmaktadır.

    Yukarıdaki iskelet programın açıklamasını şöyle yapabiliriz:

    1) Bir GTK 4 uygulamasında önce bir GtkApplication nesnesinin oluşturulması gerekir. GtkApplication yapısı uygulama ile
    ilgili çeşitli bilgileri tutmaktadır. Bu işlem iskelet programda şöyle yapılmıştır:

    app = gtk_application_new("com.generic.application", G_APPLICATION_FLAGS_NONE);

    2) İskelet programda daha sonra uygulama çalıştırıldığında oluşan "activate" mesajı için activate isimli fonksiyonun 
    çağrılması sağlanmıştır. GTK'da mesaj yerine "sinyal (signal)" sözcüğü kullanılmaktadır:

    g_signal_connect(app, "activate", G_CALLBACK(activate), NULL);

    Bu sinyal bağlantısından sonra artık activate isimli fonksiyon çağrılacaktır. Bizim bu fonksiyon içerisinde programın 
    ana penceresini yaratmamız gerekir.

    3) activate fonksiyonu şöyle yazılmıştır:

    void activate(GtkApplication *app, gpointer user_data)
    {
        GtkWidget *window;

        window = gtk_application_window_new(app);
        gtk_window_set_title(GTK_WINDOW(window), "Sample Window");
        gtk_window_set_default_size(GTK_WINDOW(window), 400, 300);

        gtk_window_present(GTK_WINDOW(window));
    }

    Uygulamanın ana penceresi gtk_application_window_new fonksiyonu ile yaratılmaktadır. Ana pencere diğer pencereler gibi 
    GtkWidget yapısı ile temsil edilmektedir. gtk_window_set_title fonksiyonu yaratılan pencerenin başlık kısmına (caption)
    çıkacak yazının set edilmesini sağlamaktadır. Ana pencerenin default genişlik ve yüksekliği gtk_window_set_default_size
    fonksiyonuyla oluşturulmaktadır. Bu işlemlerden sonra iskelet programda gtk_window_present fonksiyonu ile ana pencere 
    görünür hale getirilmiştir.

    4) Ana pencere yaratıldıktan sonra artık mesaj döngüsü oluşturulmalıdır. GTK 4'te mesaj döngüsü manuel oluşturulmaz. 
    Mesaj döngüsü g_application_run fonksiyonu ile oluşturulmaktadır:

    status = g_application_run(G_APPLICATION(app), argc, argv);

    Program hayatını bu fonksiyon içerisinde oluşturulan mesaj döngüsünde geçirmektedir.

    5) Mesaj döngüsünden yine pencerenin X tuşuna basıldığında çıkılır. İskelet programımızda mesaj döngüsünden çıkıldığında 
    heap'te tahsis edilen çeşitli nesnelerin yok edilmesi için g_object_unref fonksiyonu çağrılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                208. Ders 20/04/2025 - Pazar -Son-
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    GTK içerisinde pek çok GUI eleman hazır biçimde bulunmaktadır. Bu GUI elemanların yaratılması için fonksiyonlar vardır. 
    Sinyal mekanizması yoluyla bu GUI elemanlarda birtakım olaylar gerçekleştiğinde bizim belirlediğimiz fonksiyonun çağrılması 
    sağlanabilmektedir. Örneğin:

    button_ok = gtk_button_new_with_label("Ok");
    gtk_window_set_child(GTK_WINDOW(window), button_ok);
    g_signal_connect(button_ok, "clicked", G_CALLBACK(on_button_clicked), window);

    Burada bir düğme yaratılmıştır. Bu düğmeye tıklandığında on_button_clicked isimli fonksiyon çağrılacaktır. Aşağıdaki örnekte
    biz fonksiyon çağrıldığında bir diyalog penceresinin çıkmasını sağladık:

    void on_button_clicked(GtkButton *button, gpointer user_data)
    {
        GtkWindow *parent_window = GTK_WINDOW(user_data);

        GtkWidget *dialog = gtk_message_dialog_new(
            parent_window,
            GTK_DIALOG_MODAL,
            GTK_MESSAGE_INFO,
            GTK_BUTTONS_OK,
            "Düğmeye tıkladınız!"
        );

        g_signal_connect(dialog, "response", G_CALLBACK(gtk_window_destroy), NULL);
        gtk_window_present(GTK_WINDOW(dialog));
    }
---------------------------------------------------------------------------------------------------------------------------*/

#include <gtk/gtk.h>

void on_button_clicked(GtkButton *button, gpointer user_data)
{
    GtkWindow *parent_window = GTK_WINDOW(user_data);

    GtkWidget *dialog = gtk_message_dialog_new(
        parent_window,
        GTK_DIALOG_MODAL,
        GTK_MESSAGE_INFO,
        GTK_BUTTONS_OK,
        "Düğmeye tıkladınız!"
    );

    g_signal_connect(dialog, "response", G_CALLBACK(gtk_window_destroy), NULL);
    gtk_window_present(GTK_WINDOW(dialog));
}

void activate(GtkApplication *app, gpointer user_data)
{
    GtkWidget *window;
    GtkWidget *button_ok;
    GtkWidget *box;

    window = gtk_application_window_new(app);
    gtk_window_set_title(GTK_WINDOW(window), "Sample Window");
    gtk_window_set_default_size(GTK_WINDOW(window), 320, 200);

    button_ok = gtk_button_new_with_label("Ok");
    gtk_window_set_child(GTK_WINDOW(window), button_ok);
    g_signal_connect(button_ok, "clicked", G_CALLBACK(on_button_clicked), window);

    gtk_window_present(GTK_WINDOW(window));
}

int main(int argc, char **argv)
{
    GtkApplication *app;
    int status;

    app = gtk_application_new("com.generic.application", G_APPLICATION_FLAGS_NONE);
    g_signal_connect(app, "activate", G_CALLBACK(activate), NULL);

    status = g_application_run(G_APPLICATION(app), argc, argv);

    g_object_unref(app);

    return status;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bugün çeşitli programalama dillerinden kullanılabilen pek çok GUI kütüphanesi ve GUI ortamları (GUI Frameworks) bulunmaktadır. 
    GUI kütüphaneleri ve GUI ortamları zamanla evrim geçirerek bugünkü durumlarına gelmiştir. Günümüzde GUI ortamlarında 
    iki önemli tasarım seçeneği belirginleşmiştir:

    1) GUI elemanları için otomatik yerleştirme yapan nesnelerin kullanılması.
    2) GUI arayüzünü mümkün olduğunca koddan ayırma girişimleri.

    Eskiden kullanıcı arayüzlerindeki düğme, edit alanları, listeleme kutuları gibi GUI elemanları tek tek pixel temelinde 
    programcı tarafından konumlandırılıyordu. Bu da ekran çözünürlüğü değiştiğinde görünümün bozulmasına yol açıyordu. Ancak 
    son yıllarda artık GUI ortamlarında otomatik yerleştirme yapan nesneler bulundurulmaya başlanmıştır. Bu otomatik "yerleştirme 
    nesneleri (layout objects)" çözünürlük değişse bile yerleştirmeyi makul olarak kendisi yapmaktadır.

    Bir uygulamada GUI arayüzünün diğer kodlardan ayrılması uygulamanın "önyüz (front-end)" ve "arkayüz (back-end)" kodlamasının 
    farklı ekipler tarafından yapılabilmesine olanak sağlamaktadır. Son yıllarda artık GUI ortamları görsel arayüzle diğer 
    kodları birbirinden ayırabilmek için mekanizmalar sunmaktadır. Böylece görsel arayüz XML ya da ona benzer bir dille 
    bir text editörle oluşturulabilmekte ve uygulamaya kolayca dahil edilebilmektedir. Örneğin GTK 3'te bu olanak daha sınırlıydı. 
    GTK 4'te bu olanak güçlendirilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda GTK 4 ile oluşturulmuş bir grid yerleştirme (layout) nesnesinin kullanımı verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <gtk/gtk.h>

// Düğmeye basıldığında çalışacak fonksiyon
static void on_button_clicked(GtkButton *button, gpointer user_data) {
    GtkEntry *entry = GTK_ENTRY(user_data);
    const char *text = gtk_entry_buffer_get_text(gtk_entry_get_buffer(entry));

    // Ana pencereyi entry'den al (up-cast)
    GtkWindow *parent_window = GTK_WINDOW(gtk_widget_get_root(GTK_WIDGET(entry)));

    GtkWidget *dialog = gtk_message_dialog_new(
        parent_window,
        GTK_DIALOG_MODAL,
        GTK_MESSAGE_INFO,
        GTK_BUTTONS_OK,
        "Editbox içeriği:\n%s",
        text
    );

    gtk_window_set_transient_for(GTK_WINDOW(dialog), parent_window);
    g_signal_connect(dialog, "response", G_CALLBACK(gtk_window_destroy), NULL);
    gtk_window_present(GTK_WINDOW(dialog));
}

// Uygulama başlatıldığında çağrılır
static void activate(GtkApplication *app, gpointer user_data) {
    GtkWidget *window;
    GtkWidget *grid;
    GtkWidget *entry;
    GtkWidget *button;

    // Pencere oluştur
    window = gtk_application_window_new(app);
    gtk_window_set_title(GTK_WINDOW(window), "Editbox + Düğme");
    gtk_window_set_default_size(GTK_WINDOW(window), 400, 100);

    // Grid oluştur
    grid = gtk_grid_new();
    gtk_grid_set_column_spacing(GTK_GRID(grid), 10);
    gtk_grid_set_row_spacing(GTK_GRID(grid), 10);
    gtk_window_set_child(GTK_WINDOW(window), grid);

    // Editbox
    entry = gtk_entry_new();
    gtk_widget_set_margin_start(entry, 20);
    gtk_widget_set_margin_top(entry, 20);
    gtk_grid_attach(GTK_GRID(grid), entry, 0, 0, 1, 1);    // (widget, col, row, width, height)

    // Düğme
    button = gtk_button_new_with_label("Göster");
    gtk_widget_set_margin_start(button, 20);
    gtk_widget_set_margin_top(button, 20);

    gtk_grid_attach(GTK_GRID(grid), button, 1, 0, 1, 1);

    // Sinyal bağla
    g_signal_connect(button, "clicked", G_CALLBACK(on_button_clicked), entry);

    gtk_window_present(GTK_WINDOW(window));
}

int main(int argc, char **argv) {
    GtkApplication *app;
    int status;

    app = gtk_application_new("com.ornek.editdugme", G_APPLICATION_FLAGS_NONE);
    g_signal_connect(app, "activate", G_CALLBACK(activate), NULL);
    status = g_application_run(G_APPLICATION(app), argc, argv);
    g_object_unref(app);

    return status;
}
