/*--------------------------------------------------------------------------------------------------------------------------

                                            C ve Sistem Programcıları Derneği

                                UNIX/Linux Sistem Programlama Kursunda Yapılan Örnekler ve Özet Notlar
                                                      2. Bölüm

                                                Eğitmen: Kaan ASLAN

            Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.
            Kaynak belirtmek için aşağıdaki referansı kullanabilirsiniz:           

            Aslan, K. (2025), "UNIX/Linux Sistem Programlama Kursu", Sınıfta Yapılan Örnekler ve Özet Notlar, 
                C ve Sistem Programcıları Derneği, İstanbul.

                        (Notları sabit genişlikli font kullanan programlama editörleri ile açınız.)
                            (Editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz.)

                                          Son Güncelleme: 02/07/2025 - Çarşamba

---------------------------------------------------------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------------------------------------------------------
    Sinyal (signal) işlemleri UNIX/Linux sistemlerinde, sistem programlama etkinliklerinde yoğun bir biçimde kullanılmaktadır. 
    Bu nedenle bu sistemlerde programlama yapan programcıların sinyal işlemleri konusunda bilgi sahibi olması gerekmektedir. 
    Sinyal işlemleri kapsamlı bir konudur. Biz kursumuzun bu bölümünde bu işlemlerin temelleri ve ayrıntıları üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sinyal mekanizması kesme (interrupt) mekanizmasına benzetilebilir. Sinyaller UNIX/Linux sistemlerinde asenkron işlem 
    yapılmasına olanak sağlayan bir mekanizmadır. Sinyaller normal olarak proseslere gönderilmektedir. Ancak thread konusunun 
    işletim sistemlerine eklenmesiyle thread'lere de sinyal gönderilmesi mümkün hale getirilmiştir. (Ancak thread'lerin yalnızca 
    ilgili proses içerisinde erişilebilen bir kaynak olduğunu anımsayınız. Thread'lerin id değerleri ilgili proseste anlamlı 
    değerlerdir.) Bir sinyal prosese gönderildiğinde prosesin akışı kesilir, ismine sinyal fonksiyonu (signal handler) denilen 
    bir fonksiyon çalıştırılır. Sinyal fonksiyonu bitince akış kalınan yerden devam eder. Bu mekanizma kod çalışırken araya 
    asenkron biçimde başka işlemlerin girebilmesine olanak sağlamaktadır.

    Sinyalin oluşmasına yol açan çeşitli durumlar söz konusu olabilmektedir. Örneğin sinyal işletim sistemi tarafından prosese
    belli koşullar altında gönderiliyor olabilir. Programcının yaptığı çeşitli ihlallerde de işletim sistemi tarafından prosese
    sinyaller gönderilebilmektedir. Bazı sinyaller bazı aygıt sürücüleri tarafından prosese gönderilebilmektedir. Örneğin terminal 
    aygıt sürücüsü, prosesin ilişkin olduğu terminalde kullanıcı Ctrl+C gibi Ctrl+Backspace gibi tuşlara bastığında oturumun ön 
    plan proses grubuna bazı sinyalleri gönderebilmektedir. Sinyaller programlama yoluyla da bir prosesten diğerine gönderilebilmektedir. 
    Bazı POSIX fonksiyonları da kendi içlerinde bazı koşullarda ilgili proseslere sinyaller gönderebilmektedir.

    Bir sinyal bir prosese gönderildiğinde prosesin hangi thread'inin çalışmasına ara verilip sinyal fonksiyonunu çalıştıracağı 
    POSIX standartlarında işletim sisteminin isteğine bırakılmıştır. Yani örneğin bizim toplamda beş thread'imiz varsa prosese 
    bir sinyal gönderildiğinde bu beş thread'ten herhangi biri çalışmasına ara verip sinyal fonksiyonunu çalıştırabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Her sinyalin bir numarası vardır. Sinyallere ilişkin numaralar POSIX sistemlerinde işletim sistemini yazanların isteğine 
    bırakılmıştır. Ancak taşınabilirlik sağlamak için sinyal numaraları <signal.h> dosyası içerisinde SIGXXX biçiminde sembolik 
    sabitlerle define edilmiştir. Konuşurken ve program yazarken sinyallerin numaraları değil (çünkü taşınabilir değiller) bu 
    sembolik sabit isimleri kullanılmaktadır. UNIX/Linux sistemlerinde kullanılan tipik sinyaller şunlardır:

    SIGABRT
    SIGALRM
    SIGBUS
    SIGCANCEL
    SIGCHLD
    SIGCONT
    SIGEMT
    SIGFPE
    SIGFREEZE
    SIGHUP
    SIGILL
    SIGINFO
    SIGINT
    SIGIO
    SIGIOT
    SIGJVM1
    SIGJVM2
    SIGKILL
    SIGLOST
    SIGLWP
    SIGPIPE
    SIGPOLL
    SIGPROF
    SIGPWR
    SIGQUIT
    SIGSEGV
    SIGSTKFLT
    SIGSTOP
    SIGSYS
    SIGTERM
    SIGTHAW
    SIGTHR
    SIGTRAP
    SIGTSTP
    SIGTTIN
    SIGTTOU
    SIGURG
    SIGUSR1
    SIGUSR2
    SIGVTALRM
    SIGWAITING
    SIGWINCH
    SIGXCPU
    SIGXFSZ
    SIGXRES
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir sinyal oluştuğunda eğer programcı o sinyal için bir "sinyal fonksiyonu (signal handler)" set etmişse bu sinyal fonksiyonu 
    çağrılmaktadır. Eğer programcı sinyal için bir sinyal fonksiyonu set etmemişse bu durumda "default eylem (default action)" 
    uygulanmaktadır. Default eylem sinyalden sinyale değişebilmektedir. Bazı sinyallerde default eylem "sinyalin görmezlikten 
    gelinmesi (ignore)" iken, bazı sinyallerde "prosesin sonlandırılması (terminate)" biçimindedir. Bazı sinyallerde default 
    eylem "prosesin sonlandırılması ve bir core dosyasının oluşturulması" biçimindedir. Core dosyaları "teşhis amacıyla" oluşturulan 
    ve debugger altında incelenebilen özel dosyalardır. Tabii programcı bu default eylemleri sinyal temelinde öğrenmelidir. 
    Aşağıda sinyallerin default eylemlerinin ne olduğuna ilişkin bir liste verilmiştir:

    Sinyal                      Default Eylem
    -------                     ---------------
    SIGABRT                     terminate+core
    SIGALRM                     terminate
    SIGBUS                      terminate+core
    SIGCANCEL                   ignore
    SIGCHLD                     ignore
    SIGCONT                     continue/ignore
    SIGEMT                      terminate+core
    SIGFPE                      terminate+core
    SIGFREEZE                   ignore
    SIGHUP                      terminate
    SIGILL                      terminate+core
    SIGINFO                     ignore
    SIGINT                      terminate
    SIGIO                       terminate/ignore
    SIGIOT                      terminate+core
    SIGJVM1                     ignore
    SIGJVM2                     ignore
    SIGKILL                     terminate
    SIGLOST                     terminate
    SIGLWP                      terminate/ignore
    SIGPIPE                     terminate
    SIGPOLL                     terminate
    SIGPROF                     terminate
    SIGPWR                      terminate/ignore
    SIGQUIT                     terminate+core
    SIGSEGV                     terminate+core
    SIGSTKFLT                   terminate
    SIGSTOP                     stop process
    SIGSYS                      terminate+core
    SIGTERM                     terminate
    SIGTHAW                     ignore
    SIGTHR                      terminate
    SIGTRAP                     terminate+core
    SIGTSTP                     stop process
    SIGTTIN                     stop process
    SIGTTOU                     stop process
    SIGURG                      ignore
    SIGUSR1                     terminate
    SIGUSR2                     terminate
    SIGVTALRM                   terminate
    SIGWAITING                  ignore
    SIGWINCH                    ignore
    SIGXCPU                     terminate or terminate+core
    SIGXFSZ                     terminate or terminate+core
    SIGXRES                     ignore
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir sinyal oluşturulduğunda önce sinyal prosese teslim edilir ("deliver" işlemi). Proses kendine gelen sinyali mümkün olduğu
    kadar çabuk işlemek ister. Eğer ilgili sinyal için bir sinyal fonksiyonu set edilmişse proses çok gecikmeden bu sinyal 
    fonksiyonunu çağırmak isteyecektir. Sinyalin oluşmasıyla prosese teslim edilmesi arasındaki ara duruma "sinyalin askıda 
    (pending durumda olması)" denilmektedir. Eğer akış o anda bir sistem fonksiyonunun içerisindeyse ve o sistem fonksiyonu 
    uzun sürecek bir eylem başlatmışsa ya da açıkça bloke olmuşsa bu durumda işletim sistemi ilgili sistem fonksiyonunu başarısızlıkla
    sonuçlandırır ve bir an evvel sinyal fonksiyonunu çalıştırır. Tabii biz sistem fonksiyonlarını doğrudan değil POSIX fonksiyonları
    yoluyla kullanmaktayız. Böylece bu tür durumlarda çağırdığımız POSIX fonksiyonları sinyal dolayısıyla başarısız olabilmektedir. 
    Eğer bir POSIX fonksiyonu sinyal dolayısıyla başarısız olursa bu durumda errno değişkeni EINTR özel değeriyle set edilmektedir. 
    Örneğin biz bir borudan read fonksiyonuyla okuma yapmak isteyelim. Ancak boruda okunacak hiç byte olmasın. Bu durumda read 
    fonksiyonu blokeye yol açacaktır. İşte bu sırada prosese bir sinyal gelirse read fonksiyonu başarısızlıkla (yani -1 değeriyle)
    geri döner ve errno değişkeni EINTR değeriyle set edilir. Bu tür durumlarda biz fonksiyonun sinyal dolayısıyla başarısız 
    olduğunu anlayıp onu yeniden çağırmamız gerekir. Örneğin:

    while ((result = read(...)) == -1 && errno == EINTR)
        ;
    if (result == -1)
        exit_sys("read");

    Ancak programcı isterse bu tür POSIX fonksiyonlarının "otomatik biçimde yeniden çağrılmasını (automatic restart)" da 
    sağlayabilmektedir. Eğer programcı bunu sağlamışsa bu durumda fonksiyon hiç geri dönmez, ancak sinyal fonksiyonu çalıştırılır. 
    Bu otomatik çalıştırma işlemi kütüphane tarafından değil çekirdek tarafından sağlanmaktadır.

    Tabii bir sistem fonksiyonunun ya da onu çağıran POSIX fonksiyonunun sinyal nedeniyle başarısız olması için o fonksiyonun 
    "yavaş bir fonksiyon" olması gerekir. Programcı, çağırdığı sistem fonksiyonlarının ya da onu çağıran POSIX fonksiyonlarının 
    sinyal karşısındaki davranışını bilmek zorundadır. Tabii bir sinyal için sinyal fonksiyonu set edilmemişse ve default eylem 
    prosesin sonlanmasıysa zaten bu durumda ilgili sistem fonksiyonunun ya da onu çağıran POSIX fonksiyonunun başarısızlığının
    bir önemi de kalmamaktadır. Yavaş fonksiyon "sistem fonksiyonunun içerisinde göreli biçimde uzun zaman beklenebilmesi" 
    anlamına gelmektedir. Örneğin read fonksiyonu ile biz bir disk dosyasından (regular file) okuma yaparken sinyal oluştuğunda
    bu yavaş bir işlem değildir. Genellikle işletim sistemlerinin çekirdekleri okuma bitip, fonksiyon başarıyla sonlandıktan
    sonra set edilmiş olan sinyal fonksiyonunu çağırmaktadır. Ancak örneğin read fonksiyonu ile bir borudan okuma yapıyorsak 
    ve boruda hiç bilgi yoksa bu durumda read fonksiyonu yavaş bir sistem fonksiyonu durumundadır. Çünkü read fonksiyonu
    bu durumda blokeye yol açıp uzun süre bekleme oluşturabilmektedir. Yani sistem fonksiyonunun yavaş olması demekle genellikle
    blokeye yol açabilmesi kastedilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                73. Ders 13/08/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir sinyal oluştuğunda programcının kendi belirlediği fonksiyonun çağrılması (yani sinyal fonksiyonunun set edilmesi) iki
    POSIX fonksiyonu ile sağlanmaktadır: signal fonksiyonu ve sigaction fonksiyonu. Maalesef POSIX standartları oluşturulduğunda
    signal fonksiyonunun davranışı konusunda UNIX türevi sistemler arasında (özellikle AT&T ve Berkeley sistemleri arasında)
    farklılıklar söz konusuydu. POSIX standartları oluşturulurken bu farklılıklar bilindiği için signal fonksiyonu "öyle de 
    davranabilir böyle de davranabilir" biçiminde standartlara sokuldu. Bu durum da tabii sistemler arasında taşınabilirlik 
    sorunları oluşturmaktaydı. İşte signal fonksiyonunun bu taşınabilirlik sorunu sigaction fonksiyonuyla çözülmüştür. sigaction
    fonksiyonu POSIX standartlarına sokulduğunda fonksiyonun semantiği sistemler arasında farklılık oluşturmayacak biçimde 
    tanımlanmıştır. Biz kursumuzda önce signal fonksiyonunu sonra sigaction fonksiyonunu göreceğiz. Yukarıda da belirttiğimiz 
    gibi signal fonksiyonundaki semantik taşınabilir değildir. Bu nedenle programcıların sigaction fonksiyonunu kullanması 
    iyi bir tekniktir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    signal fonksiyonunun prototipi şöyledir:

    #include <signal.h>

    void (*signal(int sig, void (*func)(int)))(int);

    signal fonksiyonunun birinci parametresi set edilecek sinyale ilişkin sinyal numarasını belirtmektedir. İkinci parametre 
    ise sinyal oluştuğunda çağrılacak sinyal fonksiyonunun adresini almaktadır. Sinyal fonksiyonlarının geri dönüş değeri void
    parametreleri int türden olmak zorundadır. signal fonksiyonunun geri dönüş değeri de "parametresi int, geri dönüş değeri 
    void olan" bir fonksiyon adresidir. Fonksiyon başarı durumunda önceki sinyal fonksiyonunun adresi ile geri döner. Başarısızlık
    durumunda SIG_ERR özel değeri ile geri dönmektedir. SIG_ERR <signal.h> içerisinde başarısızlığı anlatan bir değer olarak 
    define edilmiştir. Örneğin:

    ...
    if (signal(SIGINT, sigint_handler) == SIG_ERR)
        exit_sys("signal");
    ...

    void sigint_handler(int sno)
    {
        ...
    }

    Sinyal fonksiyonunun parametresi ne anlam ifade etmektedir? İşletim sistemi oluşan sinyalin numarasını sinyal fonksiyonuna
    parametre olarak aktarmaktadır. Bu sayede programcı farklı sinyaller için aynı sinyal fonksiyonunu set edebilir. Fonksiyonun
    içerisinde bu parametre yardımıyla hangi sinyal nedeniyle fonksiyonun çağrılmış olduğunu belirlenebilir.

    signal fonksiyonunun ikinci parametresi için SIG_DFL ve SIG_IGN özel değeri girilebilir. SIG_DFL sinyali "default duruma"
    çekmek için kullanılmaktadır. Yani bu değer "sanki hiç sinyal fonksiyonu set edilmemiş gibi" bir etki oluşturmaktadır. 
    SIG_IGN ise "sinyali görmezden gelme yani ignore etme" için kullanılmaktadır. Bir sinyal SIG_IGN ile ignore edilirse bu 
    sinyal oluştuğunda sanki sinyal oluşmamış gibi bir davranış gösterilir. İleride de açıklayacağımız gibi her sinyal 
    ignore edilememektedir. Tabii signal fonksiyonunun geri dönüş değeri sinyale göre SIG_DFL ve SIG_IGN biçiminde de olabilmektedir. 
    Örneğin biz bir sinyali ilk kez set ediyorsak önceki sinyal fonksiyonu muhtemelen SIG_DFL ya da SIG_IGN biçiminde olacaktır.

    void (*old_handler)(int);

    if ((old_handler = signal(SIGINT, sigint_handler)) == SIG_ERR)
        exit_sys("signal");

    if (old_handler == SIG_DFL)
        printf("yes, old handler is SIG_DFL\n");

    Aşağıdaki örnekte SIGINT sinyali için bir sinyal fonksiyonu set edilmiştir. Daha önceden de belirttiğimiz gibi SIGINT sinyali
    terminal aygıt sürücüsü tarafından Ctrl+C tuşlarına basıldığında prosese gönderilmektedir. Bu sinyalin default davranışı 
    (default action) prosesin sonlandırılmasıdır. Tabii biz SIGINT için bir sinyal fonksiyonu set edersek proses sonlandırılmaz
    ve bizim set ettiğimiz fonksiyon çağrılır. Aşağıdaki programı çalıştırınca artık Ctrl+C tuşu ile programı sonlandıramayacağız. 
    Bunun için terminali kapatabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

void sigint_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    if (signal(SIGINT, sigint_handler) == SIG_ERR)
        exit_sys("signal");

    for (;;)
        ;

    return 0;
}

void sigint_handler(int sno)
{
    printf("signal occurred...\n");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    alarm isimli POSIX fonksiyonu belli bir süre dolduğunda onu çağıran prosese (yani kendi prosesine) SIGALRM isimli sinyali
    göndermektedir. Bu sinyalin default davranışı (default action) prosesin sonlandırılması biçimindedir. alarm fonksiyonunu 
    birden fazla çağırdığımızda bunlar biriktirilmez. Her yeni çağrı, eski çağrıyı devre dışı bırakarak yeniden alarmı set 
    etmektedir. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    unsigned alarm(unsigned seconds);

    Fonksiyon saniye sayısını parametre olarak almaktadır. Yani bu saniye dolduğunda fonksiyon SIGALRM sinyalini oluşturacaktır. 
    Fonksiyon eğer daha önce alarm fonksiyonu çağrılıp set işlemi yapıldıysa o set işlemi için kalan saniye sayısını vermektedir. 
    Eğer daha önce alarm fonksiyonu çağrılmamışsa ya da çağrıldığı halde zaten süre dolmuşsa fonksiyon 0 değeri ile geri dönmektedir. 
    Fonksiyon başarısız olamaz.

    alarm fonksiyonuna argüman olarak 0 değeri geçilirse bu durum önceki alarm işleminin devre dışı bırakılacağı anlamına gelmektedir. 
    Yani bu durum sanki alarm fonksiyonu daha önce hiç çağrılmamış gibi bir durum oluşturmaktadır.

    Aşağıdaki örnekte alarm fonksiyonu 5 saniyeye kurulmuştur. 5 saniye dolduktan sonra SIGALRM sinyali prosese gönderilecektir. 
    Program bu sinyal oluştuğunda bir sinyal fonksiyonu set ederek ekrana "ALARM" yazısının çıkartılmasını sağlamıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sigalrm_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    if (signal(SIGALRM, sigalrm_handler) == SIG_ERR)
        exit_sys("signal");

    alarm(5);

    for (int i = 0; i < 10; ++i) {
        printf("%d\n", i);
        sleep(1);
    }

    return 0;
}

void sigalrm_handler(int sno)
{
    printf("ALARM\n");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi signal fonksiyonun semantiği maalesef taşınabilir değildir. Bu fonksiyonunun davranışı 
    çeşitli sistemlerde aşağıda açıklayacağımız gibi farklılıklar gösterebilmektedir. signal fonksiyonundaki problemler
    ve semantik farklılıklar şunlardır:

    1) Eski AT&T UNIX sistemlerinde ve o kökten gelen sistemlerde signal fonksiyonu ile bir sinyal set edilip sinyal oluştuğu 
    zaman sinyal yeniden default duruma çekiliyordu. Böylece sanki sinyal set edilmemiş gibi bir etki oluşuyordu. Bu sistemlerde 
    eskiden bu etkiyi ortadan kaldırmak için programcılar sinyal fonksiyonunun (signal handler) hemen başında sinyal default'a 
    çekildiği için yeniden set işlemi yapıyorlardı. Örneğin:

    void signal_handler(int sno)
    {
        if (signal(SIGXXX, signal_handler) == SIG_ERR)
            exit_sys("signal");
        ...
    }

    Böylece sinyal default'a çekildiğinde yeniden sinyal set ediliyordu. Ancak üst üste aynı sinyalin oluştuğu durumlarda 
    prosesin sonlandırılmasına yönelik bir durum her zaman mümkün olabilmekteydi:

    void signal_handler(int sno)
    {
        ----> BU NOKTADA AYNI SİNYALDEN OLUŞSA SİNYAL DEFAULT'A ÇEKİLDİĞİ İÇİN PROSES SONLANDIRILACAKTIR!

        if (signal(SIGXXX, signal_handler) == SIG_ERR)
            exit_sys("signal");
        ...
    }

    AT&T ve türevlerinde yukarıdaki duruma ilişkin bir önlem alınamıyordu. Ancak daha sonra BSD UNIX sistemleri bu problemi
    "sinyalin default'a çekilmemesi" biçiminde değiştirerek çözmeye çalışmıştır. BSD ve türevlerinde sinyal default'a 
    çekilmemektedir. Linux sistemlerinde, signal sistem fonksiyonu AT&T semantiğini uygulamakta ve sinyali default'a çekmektedir. 
    Ancak signal fonksiyonu glibc kütüphanesinin belli versiyonundan sonra signal sistem fonksiyonu yerine sigaction sistem 
    fonksiyonu kullanılarak yazıldığı için sinyali default'a çekmemektedir. Yani Linux'ta signal POSIX fonksiyonu AT&T değil, 
    BSD semantiğini uygulamaktadır. POSIX standartları, AT&T ve BSD sistemlerindeki farklılıkların geçerli olabilmesi için 
    sinyal oluştuğunda oluşan sinyalin default'a çekilip çekilmeyeceğini işletim sistemlerini yazanların isteğine bırakmıştır.

    2) AT&T ve bu kökten gelen UNIX türevi sistemlerde bir sinyal oluştuğunda o sinyal, sinyal fonksiyonu çalıştığı sürece
    bloke edilmiyordu. Yani aynı sinyalden üst üste gelebiliyordu. Bu durum sinyal fonksiyonun iç içe birden fazla kez 
    çalıştırılmasına yol açabilmektedir. Bunun da "stack taşması (stack overflow)" gibi bazı sakıncaları söz konusu olabilmektedir. 
    BSD UNIX sistemleri bu problemi çözmüştür. BSD sistemlerinde bir sinyal oluştuğunda sinyal fonksiyonundan çıkılana kadar aynı
    sinyal bir daha oluşamamaktadır. Bu duruma ileride de göreceğimiz gibi "sinyalin bloke edilmesi" denilmektedir. Yani BSD 
    sistemleri sinyal fonksiyonu çalıştığı sürece aynı sinyali bloke etmekte ve böylece iç içe sinyalin oluşmasını engellemektedir. 
    Linux'un signal sistem fonksiyonu bu konuda da AT&T semantiğini uygulamaktadır. Ancak signal fonksiyonu glibc kütüphanesinin 
    belli bir versiyonundan sonra sigaction sistem fonksiyonunu çağırmaktadır ve BSD semantiğini uygulamaktadır. Yani Linux sistemlerinde
    signal fonksiyonu ile sinyal set edildiğinde sinyal fonksiyonu çalıştığı sürece proses ilgili sinyale bloke edilmektedir. POSIX 
    standartları sinyal fonksiyonu çalıştığı sürece aynı sinyalin bloke edilip edilmeyeceğini işletim sistemini yazanların 
    isteğine bırakmıştır.

    3) signal fonksiyonunun diğer bir problemi de yavaş sistem fonksiyonlarında "otomatik restart" yapılıp yapılmayacağının 
    sistemler arasında değişebilmesidir. AT&T ve bu kökten gelen UNIX türevi sistemlerde yavaş sistem fonksiyonları başarısız olmakta
    ve errno değeri EINTR olarak set edilmektedir. Halbuki BSD sistemlerinde signal fonksiyonu ile sinyal fonksiyonu set edildiğinde
    otomatik restart işlemi yapılmaktadır. Linux sistemlerinde signal sistem fonksiyonu AT&T semantiğini kullandığı için otomatik 
    restart yapmamaktadır. Ancak yukarıda da belirttiğimiz gibi signal fonksiyonu glibc kütüphanesinin belli bir versiyonundan 
    sonra sigaction sistem fonksiyonu çağrılarak yazılmıştır ve otomatik restart işlemi yapılmaktadır. POSIX standartlarında 
    signal fonksiyonu ile bir sinyal set edildiğinde otomatik restart işleminin yapılıp yapılmayacağı işletim sistemlerini 
    yazanların isteğine bırakılmıştır.

    Bu durumda Linux sistemlerindeki glibc kütüphanesinde bulunan signal fonksiyonu "sinyali default'a çekmemekte, sinyali sinyal
    fonksiyonu çalıştığı sürece bloke etmekte ve otomatik restart işlemini uygulamaktadır."
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                74. Ders 13/08/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    sigaction fonksiyonu signal fonksiyonunun oldukça iyileştirilmiş bir biçimidir. sigaction fonksiyonunda signal fonksiyonundaki
    semantik belirsizlikler kaldırılmıştır. Dolayısıyla programcıların sinyal fonksiyonlarını signal fonksiyonu yerine sigaction
    fonksiyonu ile set etmesi iyi bir tekniktir. Ancak sigaction fonksiyonunun kullanımı signal fonksiyonundan daha zordur. 
    sigaction fonksiyonunun prototipi şöyledir:

    #include <signal.h>

    int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);

    Fonksiyonun birinci parametresi yine set edilecek sinyalin numarasını belirtmektedir. Fonksiyonun ikinci parametresi 
    sigaction isimli bir yapı nesnesinin adresini almaktadır. Programcı sinyal set işlemi ile ilgili bazı bilgileri sigaction
    türünden yapı nesnesinin içerisine yerleştirir. Sonra bu nesnenin adresini fonksiyona verir. Fonksiyonun üçüncü parametresi
    NULL geçilebilir. Ancak NULL geçilmezse daha önceki sinyal set özellikleri bu parametreye adresi geçirilen sigaction türünden 
    nesneye yerleştirilecektir. Fonksiyonun ikinci parametresi de NULL adres geçilebilmektedir. Bu durumda programcı eski 
    sinyal set bilgilerini alır, ancak onu değiştirmez. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine 
    geri döner. errno değişkeni uygun biçimde set edilmektedir.

    sigaction fonksiyonun kullanımındaki en önemli nokta şüphesiz sigaction yapı nesnesinin içinin doldurulmasıdır. sigaction 
    yapısı <signal.h> başlık dosyasında şöyle bildirilmiştir:

    struct sigaction {
        void (*sa_handler)(int);
        void (*sa_sigaction)(int, siginfo_t *, void *);
        sigset_t sa_mask;
        int sa_flags;
    };

    Yapının sa_handler elemanı sinyal oluştuğunda çağrılacak fonksiyonun (signal handler) adresini almaktadır. Bu elemana
    geri dönüş değeri void, parametresi int olan bir fonksiyonun adresi geçirilmelidir. UNIX/Linux sistemlerine daha sonraları 
    "güvenilir sinyaller (reliable signals)" adı altında bazı semantik eklemeler yapılmıştır. Bu eklemelerden biri de sinyal 
    fonksiyonunun (signal handler) detaylandırılmasıdır. Yapının sa_sigaction elemanı da sinyal oluştuğunda çağrılacak fonksiyonu
    belirtmektedir. Ancak bu fonksiyonun parametrik yapısı daha değişiktir. Tabii programcı yapının iki elemanına da fonksiyon 
    girmez. Bunlardan birine fonksiyon girer. sigaction fonksiyonun sinyal oluştuğunda yapının hangi elemanındaki sinyal fonksiyonunu
    çağıracağı yapının sa_flags elemanında belirtilmektedir. Default durum yapının sa_handler elemanında belirtilen klasik tarzda 
    sinyal fonksiyonunun çağrılmasıdır. Yapının sa_handler ya da sa_sigaction elemanlarına yine signal fonksiyonunda olduğu gibi 
    SIG_DFL ve SIG_IGB özel değerleri girilebilmektedir.

    sigaction yapısının sa_mask elemanı sinyal bloke (mask) kümesini belirtmektedir. Default durumda bir sinyal oluştuğu 
    zaman sinyal fonksiyonu çağrıldığında zaten artık aynı numaralı sinyal, sinyal fonksiyonu çalıştığı sürece bloke olmaktadır. 
    Bir sinyalin bloke olması, o sinyal oluştuğunda işletim sisteminin sinyali prosese teslim etmemesi ve askıda (pending durumda) 
    bekletmesi anlamına gelmektedir. Ancak sinyaller biriktirilmez. Yani örneğin bir sinyal oluşup sinyal fonksiyonu çağrıldığında 
    o sinyalden beş kez daha oluşsa bloke açıldığında sinyal fonksiyonu yalnızca bir kez çalıştırılmaktadır. Ancak programcı 
    isterse "sinyal fonksiyonu çalıştığı sürece" oluşan sinyalin yanı sıra başka sinyallerin de bloke edilmesini sağlayabilmektedir. 
    Bunun için yapının sa_mask elemanı kullanılmaktadır. sa_mask elemanının sigset_t türünden olduğuna dikkat ediniz. Bu sigset_t 
    türü bir bit dizisi gibi düşünülmelidir. Yani bu türün çeşitli bitleri çeşitli sinyallerin bloke edilip edilmeyeceğini 
    belirtmektedir. İşte bu türün çeşitli bitlerini set etmek ve reset etmek için bazı fonksiyonlar bulundurulmuştur. Bu fonksiyonlar 
    makro biçiminde de yazılabilmektedir. Bu fonksiyonların (ya da makroların) listesi şöyledir:

    #include <signal.h>

    int sigemptyset(sigset_t *set);
    int sigfillset(sigset_t *set);
    int sigaddset(sigset_t *set, int signum);
    int sigdelset(sigset_t *set, int signum);
    int sigismember(const sigset_t *set, int signum);

    sigemptyset fonksiyonu bit dizisi içerisindeki tüm bitleri reset etmektedir. sigfillset fonksiyonu ise tüm bitleri set 
    etmektedir. sigaddset fonksiyonu bit dizisi içerisindeki ilgili sinyale ilişkin biti set etmektedir. sigdelset fonksiyonu 
    ise bit dizisi içerisindeki ilgili sinyale ilişkin biti reset etmektedir. sigismember fonksiyonu belli bir sinyale ilişkin 
    bitin bit dizisi içerisindeki değerini yani (yani set ya da reset olduğunu) bize vermektedir. Fonksiyonlar başarı durumunda 0, 
    başarısızlık durumunda -1 değerine geri dönmektedir. Ancak sigismember başarı durumunda 0 ya da 1 değerine, başarısızlık 
    durumunda -1 değerine geri döner. Tabii bu fonksiyonların başarısının kontrol edilmesine gerek yoktur. Örneğin biz sigset_t 
    bit dizisinde yalnızca SIGINT ve SIGTERM sinyali için ilgili bitleri set etmek isteyelim. Bu işlemi aşağıdaki gibi yapabiliriz:

    sigset_t sset;

    sigemptyset(&sset);
    sigaddset(&sset, SIGINT);
    sigaddset(&sset, SIGTERM);

    Biz burada herhangi bir bloke işlemi yapmadık. Yalnızca bir belirleme yaptık.

    İşte sigaction yapısının sa_mask elemanında sinyallere ilişkin set edilen bitler sinyal fonksiyonu çalıştığı sürece bloke 
    edilecektir. Örneğin:

    struct sigaction sa;

    sa.sa_handler = signal_handler;

    sigemptyset(&sa.sa_mask);
    sigaddset(&sa.sa_mask, SIGINT);
    sigaddset(&sa.sa_mask, SIGTERM);
    ...

    if (sigaction(SIGALRM, &sa, NULL) == -1)
        exit_sys("sigaction");

    Burada SIGALRM sinyali için set edilmiş olan sinyal fonksiyonu çalıştığı sürece SIGINT ve SIGTERM sinyalleri bloke edilecektir. 
    Zaten default durumda ilgili sinyalin kendisinin de sinyal fonksiyonu çalıştığı sürece bloke edildiğini belirtmiştik. Burada 
    bloke sürekli değil yalnızca sinyal fonksiyonu çalıştığı sürece söz konusu olmaktadır. Sinyal fonksiyonun çalışması bittiğinde
    sinyal işleme sokulacaktır.

    Programcı, yapının sa_mask elemanına değer atamalıdır. Bildiğiniz gibi yerel nesnelerin içerisinde rastgele değerler vardır. 
    Yapı nesnesi global olsa bile içi sıfırlanan nesnelerin bu bağlamda içi boş bir bit dizisi belirtmesi garanti değildir. 
    Örneğin biz yapının bu elemanına şöyle değer atayabiliriz:

    sigemptyset(&sa.sa_mask);

    Bu durumda sinyal fonksiyonu çalışırken ilgili sinyal dışındaki hiçbir sinyal bloke edilmeyecektir.

    sigaction yapısının sa_flags elemanı bazı sembolik sabitlerin bit OR işlemine sokulmasıyla oluşturulmaktadır. Bu bayrakların 
    her birinin bir anlamı vardır:

    SA_RESETHAND: Bu bayrak set edilirse sinyal fonksiyonu çalıştırıldığında sinyal otomatik olarak default'a çekilir. 
    Default durumda bu bayrağın set edilmediğine dikkat ediniz. Bu bayrak AT&T semantiğinin uygulanabilmesi için bulundurulmuştur.

    SA_RESTART: Bu bayrak set edilirse yavaş POSIX fonksiyonlarında (yani onların çağırdığı sistem fonksiyonlarında) sinyal 
    oluştuğunda sinyal fonksiyonu çağrılır ancak fonksiyon başarısızlıkla sonuçlanmaz. Çünkü sistem fonksiyonunun restart 
    edilmesi çekirdek tarafından otomatik yapılmaktadır. Bu biçimde set edilmiş bir sinyal fonksiyonu söz konusu olduğunda 
    ilgili sistem fonksiyonları sinyal dolayısıyla başarısız olmayacaktır. Anımsanacağı gibi AT&T'nin signal fonksiyonu 
    otomatik restart işlemi yapmamaktadır. Ancak BSD'lerin ve Linux'un signal fonksiyonu zaten otomatik restart işlemi yapmaktadır.

    SA_SIGINFO: Bu bayrak belirtilirse sinyal fonksiyonu için sigaction yapısının sa_handler elemanı değil, sa_sigaction elemanı 
    dikkate alınmaktadır. Tabi bu durumda sinyal fonksiyonun da (signal handler) parametrik yapısı değişmektedir. Bu konu 
    "gerçek zamanlı sinyalleri (realtime signals)" ele alacağımız paragraflarda açıklanacaktır.

    SA_NODEFER: Anımsanacağı gibi default durumda her zaman bir sinyal oluştuğunda sinyal fonksiyonu çalıştığı sürece o sinyal
    bloke edilmektedir. Yani iç içe aynı sinyalden oluşamamaktadır. Ancak bu bayrak kullanılırsa sinyal fonksiyonu çalıştığı sürece
    o sinyal bloke edilmeyecek ve sinyal fonksiyonu iç içe çağrılabilecektir. Anımsanacağı gibi signal fonksiyonundaki AT&T semantiği
    zaten böyleydi. Ancak BSD ve Linux sistemlerindeki semantik, aynı sinyalin sinyal fonksiyonu çalıştığı sürece bloke edilmesi 
    biçimindeydi.

    SA_NOCLDWAIT: Bu bayrak SIGCHLD sinyali için anlamlıdır. Otomatik olarak zombie proses oluşmasını engellemek için kullanılmaktadır. 
    Bu bayrak set edilip proses sonlandığında artık kaynaklarını wait fonksiyonlarını beklemeden serbest bırakır. Tabii programcı da
    böyle prosesler için artık wait işlemi yapmaz. Bu konu ayrı bir paragrafta açıklanacaktır.

    SA_NOCLDSTOP: Bu bayrak belirtildiğinde alt proses durdurulduğu zaman ya da yeniden çalışmaya devam ettirildiği zaman üst 
    prosese SIGCHLD sinyalini göndermemektedir. Bu konu da ileride ele alınacaktır.

    SA_ONSTACK: İç içe sinyaller oluştuğunda mevcut stack için taşma problemleri çok seyrek de olsa teorik olarak söz konusu 
    olabilmektedir. Bunun için alternatif stack kullanımı da mümkündür. İşte bu bayrak ilgili sinyal fonksiyonu çalışırken 
    alternatif stack kullanılacağını belirtmektedir. Alternatif stack'in ayrıca setaltstack fonksiyonu ile set edilmesi gerekmektedir.

    Aşağıda sigaction fonksiyonunun kullanımına bir örnek verilmiştir. Bu örnekte yapının sa_mask elemanı sigemptyset fonksiyonu 
    ile tamamen reset edilmiştir. Yani ilgili sinyal oluştuğunda, sinyal fonksiyonu çalıştığı sürece başka bir sinyal bloke edilmeyecektir. 
    Yapının sa_flags elemanına da 0 atanmıştır. Yani bu eleman için herhangi bir bayrak belirtilmemiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sigalrm_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;

    sa.sa_handler = sigalrm_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    if (sigaction(SIGALRM, &sa, NULL) == -1)
        exit_sys("sigaction");

    alarm(5);

    for (int i = 0; i < 10; ++i) {
        printf("%d\n", i);
        sleep(1);
    }

    return 0;
}

void sigalrm_handler(int sno)
{
    printf("ALARM\n");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi glibc kütüphanesindeki signal POSIX fonksiyonu belli bir versiyondan sonra signal sistem fonksiyonunu 
    çağırarak değil, sigaction fonksiyonunu çağırarak yazılmıştı. signal fonksiyonu "sinyali default'a çekmiyordu", "sinyal 
    fonksiyonu çalıştığı sürece aynı sinyali bloke ediyordu" ve "otomatik restart işlemi yapıyordu". O halde glibc kütüphanesindeki
    signal POSIX fonksiyonu sigaction fonksiyonu kullanılarak aşağıdaki gibi yazılabilir:

    void (*mysignal(int sig, void (*handler)(int)))(int)
    {
        struct sigaction sa, sa_old;

        sa.sa_handler = sigalrm_handler;
        sigemptyset(&sa.sa_mask);
        sa.sa_flags = SA_RESTART;

        if (sigaction(SIGALRM, &sa, &sa_old) == -1)
            return SIG_ERR;

        return sa_old.sa_handler;
    }

    Aşağıda yazdığımız fonksiyonun kullanımına örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sigalrm_handler(int sno);
void exit_sys(const char *msg);

void (*mysignal(int sig, void (*handler)(int)))(int)
{
    struct sigaction sa, sa_old;

    sa.sa_handler = sigalrm_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGALRM, &sa, &sa_old) == -1)
        return SIG_ERR;

    return sa_old.sa_handler;
}

int main(void)
{
    if (mysignal(SIGALRM, sigalrm_handler) == SIG_ERR)
        exit_sys("mysignal");

    alarm(5);

    for (int i = 0; i < 10; ++i) {
        printf("%d\n", i);
        sleep(1);
    }

    return 0;
}

void sigalrm_handler(int sno)
{
    printf("ALARM\n");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Sinyallerin proseslere gönderildiğini ve prosesin herhangi bir thread'i tarafından işletildiğini anımsayınız. İşte biz de 
    istersek bir prosese sinyal gönderebiliriz. Bunun için kill isimli POSIX fonksiyonu kullanılmaktadır. Maalesef bu fonksiyon
    yanlış isimlendirilmiştir. Kill sözcüğü İngilizce "öldürmek" ya da bu bağlamda "sonlandırmak" anlamına gelmektedir. Oysa kill 
    fonksiyonunun böyle bir amacı yoktur. Proseste ilgili sinyal için sinyal fonksiyonu set edilmemişse pek çok sinyalde zaten 
    default davranış (default action) prosesin sonlandırılması biçimindedir.

    kill fonksiyonunun prototipi şöyledir:

    #include <signal.h>

    int kill(pid_t pid, int sig);

    Fonksiyonun birinci parametresi sinyalin gönderileceği prosesin id değerini, ikinci parametresi gönderilecek sinyalin 
    numarasını almaktadır. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. 
    Fonksiyonun birinci parametresi aslında daha geniş bir kullanım alanına sahiptir. Fonksiyonun birinci parametresinin
    ayrıntılı açıklaması şöyledir:

    - Eğer bu parametre sıfırdan büyük bir değer olarak girilmişse (en çok kullanılan durum), sinyal yalnızca belirtilen id'ye
    sahip prosese gönderilmektedir.

    - Eğer bu parametre 0 girilirse sinyal, sinyali gönderen prosesin proses grup id'si ile aynı proses grup id'ye sahip olan 
    sinyal gönderme hakkının olabildiği tüm proseslere gönderilmektedir. Yani biz kendi proses grubumuzun tüm proseslerine bu 
    biçimde sinyal gönderebiliriz.

    - Eğer bu parametre -1 geçilirse sinyal, "sinyal gönderme hakkı" olan sistemdeki tüm proseslere gönderilmektedir.

    - Eğer bu parametre negatif bir değer olarak girilirse bu değerin mutlak değeri (yani pozitif hali) bir proses grup id
    kabul edilerek sinyal o proses grubunun "sinyal gönderme hakkına sahip olunan" tüm proseslerine gönderilmektedir.

    Burada sözünü ettiğimiz proses grubu kavramı izleyen bölümlerde ele alınacaktır.

    Genellikle kill ile sinyaller, bir prosesin sonlandırılması için gönderilmektedir. Ancak başka amaçlarla da sinyallerin 
    gönderilmesi söz konusu olabilmektedir.

    kill fonksiyonuyla bir prosese sinyal gönderebilmek için sinyali gönderen prosesin "gerçek ya da etkin kullanıcı id'sinin
    sinyalin gönderildiği prosesin gerçek ya da saklanmış kullanıcı id'si (saved-set-user id)" ile aynı olması gerekmektedir. 
    Saklanmış kullanıcı id'si (saved-set-user id) izleyen bölümlerde ele alınacaktır. Tabii eğer proses uygun önceliğe 
    (appropriate privileges) sahipse (yani Linux'ta root ya da uygun yeteneğe sahipse) proses herhangi bir prosese sinyal 
    gönderebilmektedir. Buradan çıkan özet şudur: Biz ancak kendi proseslerimize sinyal gönderebiliriz. Herhangi bir prosese 
    sinyal gönderebilmemiz için etkin kullanıcı id'mizin 0 olması (yani root proses olmamız) gerekir.

    Aşağıdaki örnekte "ssender.c" programı komut satırı argümanıyla aldığı sinyali, yine komut satırı argümanıyla aldığı id'ye 
    sahip prosese kill POSIX fonksiyonuyla göndermektedir. Sinyal numaralarının UNIX türevi sistemlerde aynı olmayabileceğine
    dikkat ediniz. Örneğin 12 numaralı sinyal farklı sistemlerde farklı olabilmektedir. Bu nedenle daha önce de belirttiğimiz 
    gibi sinyallerin numaraları yerine <signal.h> dosyası içerisindeki sembolik sabitler kullanılmalıdır. Tabii komut satırı 
    argümanları birer yazıdır. Sinyal isimlerini taşınabilir bir biçimde sinyal numaralarına dönüştüren standart bir POSIX
    fonksiyonu yoktur. (Ancak glibc kütüphanesinde bu amaçla kullanılabilecek standart olmayan bir fonksiyon bulunmaktadır.)
    Bu nedenle biz örnek programda, bir yapı dizisi oluşturup sinyal isimlerini manuel bir biçimde sinyal numaralarına 
    dönüştürdük. Örnek için iki terminal açınız. Terminalin birinde "sample" programını diğerinde "ssender" programını 
    çalıştırınız. "ssender" programından diğer programa sinyal gönderiniz. Tabii bunu yapabilmeniz için öncelikle "sample" 
    programının proses id'sini bilmeniz gerekir. Bunun için terminalde "ps -u" komutunu kullanabilirsiniz. Programın örnek 
    bir kullanımı şöyle olabilir:

    $ ./ssender TERM 12404

    Örneğimizde sinyal isimlerinde "SIG" önekinin kullanılmadığına dikkat ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* ssender.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

void exit_sys(const char *msg);

typedef struct tagSIGNAL_INFO {
    const char *name;
    int sig;
} SIGNAL_INFO;

SIGNAL_INFO g_signal_info[] = {
    {"INT", SIGINT},
    {"TERM", SIGTERM},
    {"KILL", SIGKILL},
    {"USR1", SIGUSR1},
    {NULL, 0},
    /* ... */
};

int main(int argc, char *argv[])
{
    pid_t pid;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }
    pid = (pid_t)atol(argv[2]);

    for (int i = 0; g_signal_info[i].name != NULL; ++i)
        if (!strcmp(argv[1], g_signal_info[i].name))
            if (kill(pid, g_signal_info[i].sig) == -1)
                exit_sys("kill");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sigusr1_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa, sa_old;

    sa.sa_handler = sigusr1_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGUSR1, &sa, &sa_old) == -1)
        exit_sys("sigaction");

    for (int i = 0; i < 60; ++i) {
        printf("%d\n", i);
        sleep(1);
    }

    return 0;
}

void sigusr1_handler(int sno)
{
    printf("SIGUSR1 handler running...\n");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Sinyal numaralarını alarak hata mesajları için sinyali betimleyen bir yazı veren strsignal isimli bir POSIX fonksiyonu 
    bulunmaktadır:

    #include <string.h>

    char *strsignal(int signum);

    Ayrıca glibc kütüphanesinde standart olmayan iki fonksiyon da vardır:

    #include <string.h>

    const char *sigdescr_np(int sig);
    const char *sigabbrev_np(int sig);

    sigdescr_np fonksiyonu strsignal fonksiyonuna benzerdir. sigabbrev_np fonksiyonu ise sinyal numarasından hareketle sinyal 
    ismini başında "SIG" öneki olmadan vermektedir. Bu fonksiyonları kullanmadan önce _GNU_SOURCE sembolik sabiti <string.h> 
    dosyasının yukarısında define edilmelidir. Ayrıca glibc kütüphanesinde eskiden bütün sinyal isimleri sys_siglist isimli 
    bir dizide toplanmıştı. (Bu dizinin uzunluğu NSIG sembolik sabiti kadardır.) Ancak bu dizi daha sonra deprecated yapılıp 
    kaldırılmıştır.

    Aşağıda bu fonksiyonlarının kullanımına yönelik bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

void exit_sys(const char *msg);

int main(void)
{
    printf("%s\n", strsignal(SIGTERM));
    printf("%s\n", sigabbrev_np(SIGTERM));
    printf("%s\n", sigdescr_np(SIGTERM));

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosese komut satırından sinyal göndermek için kill isimli bir kabuk komutu da bulunmaktadır. Bu kill kabuk komutu 
    zaten kill fonksiyonu kullanılarak yukarıda bizim yaptığımıza benzer biçimde kullanılmaktadır. kill komutu ile prosese 
    sinyal gönderirken sinyal ismi -TERM, -INT, _USR1 gibi başında "SIG" öneki olmadan belirtilmelidir. Örneğin:

    $ kill -TERM 12767        (SIGTERM sinyali gönderiliyor)
    $ kill -USR1 12767        (SIGUSR1 sinyali gönderiliyor)

    kill komutunda sinyalin ismi değil numarası da belirtilebilmektedir. Ancak sinyal numaralarının UNIX sistemleri genelinde 
    taşınabilir olmadığına dikkat ediniz. Örneğin:

    $ kill -15 12801        (Linux sistemlerinde SIGTERM sinyali gönderiliyor)
    $ kill -10 12801        (Linux sistemlerinde SIGUSR1 sinyali gönderiliyor)

    kill komutu hiç sinyal ismi ya da numarası belirtilmeden kullanılırsa default olarak SIGTERM sinyalini göndermektedir. 
    Örneğin:

    $ kill 12801

    Bu durumda prosese SIGTERM sinyali gönderilmektedir. Ancak örneğin:

    $ kill -KILL 12801

    Bu durumda prosese SIGKILL sinyali gönderilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                75. Ders 26/08/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosesi sonlandırmak için (kill etmek için) iki sinyal bulundurulmuştur: SIGTERM sinyali ve SIGKILL sinyali. Bu iki 
    sinyal birbirine benzerdir. Bu iki sinyalin de amacı prosesi sonlandırmaktır. Ancak bu iki sinyal arasında şöyle bir farklılık 
    vardır: SIGTERM sinyali proses tarafından bloke edilebilir, ignore edilebilir ya da bu sinyal için sinyal fonksiyonu set 
    edilebilir. Ancak SIGKILL sinyali ignore edilemez, bloke edilemez ve bu sinyal için sinyal fonksiyonu da set edilemez. 
    (Eğer signal ya da sigaction fonksiyonu ile SIGKILL sinyali için bir set işlemi yapılmaya çalışılırsa bu fonksiyonlar 
    başarısız olur ve errno değeri EINVAL ile set edilir.) Bu durumda bir prosesi garantili sonlandırmak için SIGTERM sinyali 
    değil, SIGKILL sinyali gönderilmelidir. Örneğin:

    $ kill -KILL 12801

    SIGTERM sinyalinin Linux sistemlerindeki numarası 15, SIGKILL sinyalinin ise 9'dur. Örneğin:

    $ kill -9 12801
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir proses id'ye ilişkin prosesin hala bulunuyor olduğunu, yani sonlanmamış olduğunu test etmenin çeşitli yöntemleri söz
    konusu olabilmektedir. Çok kullanılan yöntemlerden biri, kill fonksiyonu ile prosese 0 numaralı sinyali göndermektir. 
    0 numaralı sinyal aslında yoktur. 0 numara, sinyaller için bu amaçla kullanılmaktadır. Yani aslında 0 numaralı sinyal, 
    prosese hiç gönderilmemekte yalnızca bu tür test işlemleri için kullanılmaktadır. Biz kill fonksiyonu ile prosese 0 numaralı 
    sinyali gönderdiğimizde kill fonksiyonu başarılı olursa o prosesin sistemde bulunduğunu anlarız. Tabii proses sistemde 
    bulunduğu halde uygun önceliğe sahip olmadığından dolayı da başarısız olabilir. Bu durumda errno değişkeni EPERM değeri 
    ile set edilmektedir. Eğer prosesin var olmadığından dolayı kill fonksiyonu başarısız olmuşsa, bu durumda errno değişkeni 
    ESRCH değeri ile set edilmektedir. Bu durumda prosesin hala yaşadığının testi şöyle yapılabilir:

    if (kill(pid, 0) == -1) {
        if (errno == ESRCH) {
            /* proses sonlanmış */
        }
        exit_sys("kill);
    }

    /* proses sonlanmamış */
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sistemleri dünyasında bir fonksiyonun "senkron işlem" yapması demekle "fonksiyon geri döndüğünde o işin bitmiş 
    olmasının garanti edilmesi" anlaşılmaktadır. Örneğin read, write gibi fonksiyonlar senkron işlem yapmaktadır. read fonksiyonu
    geri döndüğünde okuma da bitmiş durumdadır. Bir fonksiyonun "asenkron işlem" yapması "fonksiyon geri döndüğünde o işlemin 
    bitmek zorunda olmadığı" anlamına gelmektedir. Örneğin kill fonksiyonu geri döndüğünde sinyalin ilgili proses tarafından 
    işlenmiş olduğunun bir garantisi yoktur. Bu durumda kill fonksiyonu "asenkron" bir işlem yapmaktadır. Örneğin "asenkron IO"
    işleminde biz bir fonksiyonla IO işlemini başlatırız ancak fonksiyon geri döndüğünde bu IO işlemi bitmiş olmak zorunda 
    değildir. Hala devam ediyor olabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    raise fonksiyonu bir prosesin kendisine sinyal göndermesi için kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <signal.h>

    int raise(int sig);

    Bu fonksiyonun eşdeğeri aşağıdaki gibi kill fonksiyonu kullanılarak da elde edilebilir. Fakat kill fonksiyonu asenkron 
    işlem sağlarken, raise fonksiyonu senkron bir işlem sağlamaktadır.

    kill(getpid(), sig);

    Fonksiyon gönderilecek sinyalin numarasını parametre olarak almaktadır. Başarı durumunda 0 değerine, başarısızlık durumunda 
    sıfır dışı herhangi bir değere (yani -1 olmak zorunda değil) geri dönmektedir. Tabii fonksiyon her zaman kendine sinyal 
    gönderebilir. Bu durumda başarısızlığın kontrol edilmesi gerekmez. (Tabii fonksiyona biz yanlış bir sinyal numarası geçersek 
    fonksiyon başarısız olabilmektedir.)

    POSIX standartlarına göre çok thread'li bir ortamda raise fonksiyonu hangi thread tarafından kullanılmışsa senkronluğu 
    sağlamak için sinyal fonksiyonu o thread tarafından çalıştırılmaktadır. Yani fonksiyon senkron işlem yapmasının dışında 
    aşağıdaki ile eşdeğerdir:

    pthread_kill(pthread_self(), sig);

    pthread_kill fonksiyonu izleyen paragraflarda ele alınacaktır. raise fonksiyonu aynı zamanda standart bir C fonksiyonudur. 
    Ancak C standartlarında sinyal konusu ayrıntılarıyla ele alınmış bir konu değildir. Yani C standartlarında bir sinyal 
    olgusundan bahsedilmiş ancak hiçbir ayrıntıya girilmemiştir.

    Anımsanacağı gibi Linux sistemlerinde aslında her thread'in bir "task struct" yapısı vardı ve proses id aslında task struct 
    yapısından elde ediliyordu. Yani aslında Linux sistemlerinde her thread'in bir pid değeri vardır. Bu değeri biz daha önce 
    gettid fonksiyonu ile elde etmiştik. O halde biz aslında kill fonksiyonunda thread'e ilişkin pid değerini kullanırsak zaten 
    sinyal adeta o thread'e gönderilmiş gibi bir etki oluşacaktır. Böylece biz Linux sistemlerinde başka bir prosesten, başka 
    bir prosesin thread'ine bu yolla sinyal gönderebilmekteyiz.

    Aşağıdaki örnekte proses kendine raise fonksiyonu ile SIGUSR1 sinyalini göndermektedir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sigusr1_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa, sa_old;

    sa.sa_handler = sigusr1_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGUSR1, &sa, &sa_old) == -1)
        exit_sys("sigaction");

    for (int i = 0; i < 10; ++i) {
        printf("%d\n", i);
        if (i == 5)
            raise(SIGUSR1);
        sleep(1);
    }

    return 0;
}

void sigusr1_handler(int sno)
{
    printf("SIGUSR1 handler running...\n");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Proses kendini bazı sinyallere bloke edebilir. Eğer proses kendini bir sinyale bloke ederse o sinyal oluştuğunda işletim 
    sistemi, sinyali prosese teslim etmez (deliver etmez). Onu "askıda (pending durumda)" bekletir. Eğer proses o sinyalin 
    blokesini kaldırırsa işletim sistemi sinyali prosese teslim eder. Ancak sinyaller biriktirilmemektedir. Yani bir proses
    kendini bir sinyale bloke etmiş ise o sırada o sinyal birden fazla kez prosese gönderilirse, proses sinyal blokesini 
    kaldırdığında yalnızca tek bir sinyal prosese teslim edilmektedir. Yani işletim sistemi askıda bekletilen sinyaller için bir 
    sayaç tutmamaktadır. Daha önceden de belirttiğimiz gibi default durumda zaten bir sinyal oluştuğunda, sinyal fonksiyonu 
    çalıştığı sürece aynı numaralı sinyal otomatik bloke edilmekte sinyal fonksiyonu sonlandığında blokesi açılmaktaydı.

    Thread'ler öncesinde UNIX türevi işletim sistemleri her proses için bir "signal mask" kümesi tutuluyordu. Prosesin 
    "signal mask" kümesi prosesin o anda hangi sinyallere bloke edilmiş olduğunu belirtmekteydi. Thread'ler konusu UNIX sistemlerine 
    sokulduğunda ayrıca her thread için de bir "signal mask" kümesi söz konusu olmuştur. Maalesef sigprocmask fonksiyonunun 
    çok thread'li uygulamalardaki davranışı tanımlanmamıştır. POSIX standartları fonksiyonun çok thread'li uygulamalardaki davranışını 
    "unspecified" olarak belirtmektedir. Linux sistemlerinde sigprocmask yalnızca fonksiyonun çağrıldığı thread'in signal mask kümesini 
    değiştirmektedir.

    Prosesin "signal mask" kümesini değiştirmek için yani onu belli sinyallere bloke etmek ya da blokesini açmak için sigprocmask
    isimli POSIX fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <signal.h>

    int sigprocmask(int how, const sigset_t *set, sigset_t *oset);

    Fonksiyonun birinci parametresi "signal mask kümesi" üzerinde hangi işlemin yapılacağını belirtmektedir. Bu parametre şunlardan 
    biri olabilir:

    SIG_BLOCK
    SIG_UNBLOCK
    SIG_SETMASK

    Fonksiyonun ikinci parametresi daha önce görmüş olduğumuz sigset_t türündendir. Anımsanacağı gibi bu tür aslında bitsel olarak 
    sinyalleri ifade etmek için kullanılmaktadır. İşte eğer fonksiyonun birinci parametresi SIG_BLOCK biçiminde girilirse ikinci 
    parametrede belirtilen sinyal kümesi prosesin "signal mask" kümesine dahil edilir. Yani artık bu sinyaller de bloke edilmiş 
    olur. Eğer birinci parametre SIG_UNBLOCK biçiminde girilirse bu durumda ikinci parametrede belirtilen sinyal kümesindeki 
    sinyaller prosesin signal mask kümesinden çıkartılmaktadır. Eğer birinci parametre SIG_SETMASK biçiminde girilirse bu durumda
    ikinci parametredeki sinyal kümesi prosesin "signal mask" kümesi haline getirilmektedir. Üçüncü parametre prosesin daha önceki 
    signal mask kümesinin yerleştirileceği nesneyi belirtmektedir. Aslında ikinci ve üçüncü parametreler NULL adres olarak da 
    geçirilebilir. Bu durumda bu parametreler fonksiyon tarafından kullanılmamaktadır. Fonksiyon başarı durumunda 0 değerine, 
    başarısızlık durumunda -1 değerine geri dönmektedir.

    Örneğin biz prosesimizi SIGTERM sinyaline bloke etmek isteyelim:

    sigset_t sset, osset;
    ...

    sigemptyset(&sset);
    sigaddset(&sset, SIGTERM);

    if (sigprocmask(SIG_BLOCK, &sset, &osset) == -1)
        exit_sys("sigprocmask");

    Burada sigprocmask fonksiyonunun birinci parametresi SIG_BLOCK biçiminde geçilmiştir. Bu durumda ikinci parametrede belirtilen
    sinyal kümesindeki sinyaller prosesin sinyal bloke kümesine (yani signal mask kümesine) dahil edilecektir. Böylece proses
    bu sinyale bloke edilmiş olacaktır. Pekiyi bu blokeyi nasıl kaldırabiliriz? Bunun için iki yöntem kullanabiliriz. Örneğin:

    if (sigprocmask(SIG_UNBLOCK, &sset, NULL) == -1)
        exit_sys("sigprocmask");

    Bunun diğer bir yolu eski sinyal mask kümesini yeniden set etmektir:

    if (sigprocmask(SIG_SETMASK, &osset, NULL) == -1)
        exit_sys("sigprocmask");

    Burada biz eski signal mask kümesini yeniden set ettik. Böylece daha önce yapmış olduğumuz SIG_BLOCK işlemi de devre dışı 
    kalmış oldu.

    sigprocmask fonksiyonunda prosesin signal mask kümesinde SIGKILL ya da SIGSTOP sinyalleri bulunsa bile bu durumda başarısız 
    olmaz. Yalnızca bu sinyaller için bloke işlemi yapılmaz.

    Aşağıdaki örnekte proses 30 saniye kadar SIGTERM sinyaline bloke edilmiş sonra da blokesi açılmıştır. Bu süre içerisinde
    başka bir terminalden kill komutuyla prosese SIGTERM sinyali göndermeyi deneyiniz. Bu süre zarfında sinyalin "askıda (pending)" 
    kaldığını prosese teslim edilmediğini göreceksiniz. Ancak 30 saniye geçtikten sonra örneğimizde prosesin blokesi açılmıştır. 
    Bu durumda işletim sistemi SIGTERM sinyalini prosese gönderecek ve proses bu sinyal için sinyal fonksiyonu set etmediğinden 
    dolayı sonlandırılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    sigset_t sset;

    sigemptyset(&sset);
    sigaddset(&sset, SIGTERM);

    if (sigprocmask(SIG_BLOCK, &sset, NULL) == -1)
        exit_sys("sigprocmask");

    printf("sleep for 30 seconds by blocikng SIGTERM...\n");
    for (int i = 0; i < 30; ++i) {
        printf("%d\n", i);
        sleep(1);
    }

    if (sigprocmask(SIG_UNBLOCK, &sset, NULL) == -1)
        exit_sys("sigprocmask");

    printf("program continues running...\n");

    for (int i = 0; i < 30; ++i) {
        printf("%d\n", i);
        sleep(1);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pek gereksinim duyulmasa da programcı o anda "askıda (pending)" olan sinyallerin kümesini de elde etmek isteyebilir. Bunun 
    için sigpending isimli POSIX fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <signal.h>

    int sigpending(sigset_t *set);

    Fonksiyon askıdaki sinyalleri argüman olarak girilen sigset_t nesnesi içerisine yerleştirmektedir. Programcı belli bir sinyalin
    bu kümede olup olmadığını sigismember fonksiyonu ile öğrenebilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    pause isimli POSIX fonksiyonu bir sinyal oluşana kadar ilgili thread'i blokede bekletmektedir. Biz de aslında bu fonksiyonu 
    daha önce kullanmıştık. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int pause(void);

    Fonksiyon her zaman -1 değerine geri döner. errno değişkeni de her zaman EINTR olarak set edilmektedir. Fonksiyonun başarısının 
    kontrol edilmesine gerek yoktur. Sinyal oluştuğunda eğer sinyal fonksiyonu set edilmemişse pause fonksiyonu zaten geri 
    dönmemektedir. Ancak sinyal fonksiyonu set edilmişse önce sinyal fonksiyonu çalıştırılmakta, sinyal fonksiyonunun çalışması 
    bittikten sonra pause fonksiyonu geri dönmektedir. Örneğin:

    for (;;)
        pause();

    Burada aslında programcının arzu ettiği sinyal oluştukça iş yapan, diğer durumlarda uykuda bekleyen bir akış söz konusudur. 
    Tabii böylesi bir programı sonlandırmanın bir yolu sinyal fonksiyonu set edilmemiş bir sinyali prosese göndermek olabilir.

    Aşağıdaki örnekte proses SIGUSR1 sinyalini işlemiş ve sonsuz döngüde pause ile beklemiştir. Burada başka bir terminalden 
    prosese aşağıdaki gibi SIGUSR1 sinyallerini gönderebilirsiniz:

    $ kill -USR1 26969
    $ kill -USR1 26969
    $ kill -USR1 26969
    $ kill -USR1 26969
    $ kill -USR1 26969
    $ kill -USR1 26969
    $ kill -USR1 26969
    $ kill -USR1 26969
    $ kill -USR1 26969
    $ kill 26969

    Tabii buradaki proses id programın her çalıştırılmasında farklı olabilecektir. Bunun için ps -u komutundan faydalanabilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sigusr1_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;

    sa.sa_handler = sigusr1_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGUSR1, &sa, NULL) == -1)
        exit_sys("sigaction");

    for(;;)
        pause();

    return 0;
}

void sigusr1_handler(int sno)
{
    printf("SIGUSR1 handler running...\n");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Sinyaller ilk UNIX sistemlerinden beri var olan bir kavramdır. Ancak thread'ler 90'ların ortalarında işletim sistemlerinde
    yaygınlaşmaya başlamıştır. Dolayısıyla sinyaller eskiden yalnızca proseslerle ilgili bir kavramdı. Yani sinyaller proseslere
    gönderiliyordu. Zaten eskiden proseslerin tek bir akışı (yani thread'i) vardı. Ancak 90'lı yılların ortalarına doğru thread'ler 
    işletim sistemlerine eklenince sinyaller konusu üzerinde thread'lere yönelik bazı revizyonlar yapılmıştır.

    Daha önceden de belirttiğimiz gibi sinyaller kill fonksiyonu ile ya da diğer kaynaklar yolu ile proseslere gönderilmektedir. 
    Prosesin hangi thread'inin, sinyal fonksiyonunu çalıştıracağı POSIX standartlarında işletim sisteminin isteğine bırakılmıştır.

    Prosesin bir thread'i kendi prosesinin başka bir thread'ine sinyal gönderebilir. (Tabii bir proses başka bir prosesin 
    spesifik bir thread'ine sinyal gönderememektedir.) Bir thread'e sinyal göndermek demek aslında sinyal fonksiyonunun o 
    thread tarafından çalıştırılmasını sağlamak demektir. Bunun için pthread_kill fonksiyonu kullanılmaktadır.

    #include <signal.h>

    int pthread_kill(pthread_t thread, int sig);

    Fonksiyonun birinci parametresi thread'in id değerini, ikinci parametresi ise gönderilecek sinyalin numarasını almaktadır. 
    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda ise errno değerine geri dönmektedir. Tabii ilgili sinyal 
    için sinyal fonksiyonu set edilmemişse yalnızca ilgili thread değil, tüm proses sonlandırılmaktadır.

    Aşağıdaki örnekte prosesin ana thread'i, diğer thread'e pthread_kill fonksiyonu ile SIGUSR1 sinyalini göndermektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <pthread.h>

void sigusr1_handler(int sig);
void *thread_proc(void *param);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    struct sigaction sa;
    int result;

    sa.sa_handler = sigusr1_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGUSR1, &sa, NULL) == -1)
        exit_sys("sigaction");

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        printf("Main thread running: %d\n", i);
        if (i == 5)
            if ((result = pthread_kill(tid, SIGUSR1)) != 0)
                exit_sys_errno("pthread_kill", result);

        sleep(1);
    }

    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;
}

void sigusr1_handler(int sig)
{
    printf("SIGUSR1 handler\n");
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("Other thread running: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Belli bir thread de sinyallere bloke edilebilir. UNIX türevi sistemlerde her thread'in de ayrıca bir signal mask kümesi 
    vardır. Belli bir thread'i belli sinyallere bloke etmek için tamamen sigprocmask fonksiyonunun benzeri olan pthread_sigmask 
    fonksiyonu kullanılmaktadır:

    #include <signal.h>

    int pthread_sigmask(int how, const sigset_t *set, sigset_t *oset);

    Fonksiyonun parametrik yapısı tamamen sigprocmask fonksiyonundaki gibidir. Fonksiyon hangi thread tarafından çağrılmışsa
    o thread'in signal mask kümesi bu işlemden etkilenir. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda errno
    değerine geri dönmektedir.

    Belli bir thread'in belli sinyallere bloke edilmesinin bazı gerekçeleri söz konusu olabilmektedir. Örneğin thread kesilmemesi
    gereken işlemler yapıyor olabilir. Bu durumda thread sinyallere bloke edilebilir. Tabii bir thread bir sinyale bloke edildiğinde 
    artık o sinyal oluştuğunda, sinyal fonksiyonu prosesin diğer thread'lerinden biri tarafından çalıştırılacaktır. Bazen 
    programcılar ilgili sinyalin prosesin belli bir thread'i tarafından işlenmesini sağlamak için diğer thread'leri ilgili 
    sinyale bloke edip yalnızca tek bir thread'de bu bloke işlemini yapmazlar. Sinyal oluştuğunda işletim sistemi de mecburen 
    sinyal fonksiyonunu o thread ile çağırır. Tabii prosesin tüm thread'leri ilgili sinyale bloke edilirse bu durum sanki prosesin 
    o sinyale bloke edilmesi gibi bir etki oluşturacaktır.

    UNIX/Linux sistemlerinde bir thread yaratıldığında thread'in signal mask kümesi onu yaratan thread'ten (üst thread'ten) 
    aktarılmaktadır. Yani örneğin bu sistemlerde biz prosesin ana thread'inde bir sinyali bloke edersek bu durumda bu sinyal
    ana thread tarafından yaratılan tüm thread'lerde bloke edilmiş olacaktır. Benzer biçimde fork işlemi sırasında da yaratılan 
    alt prosesin thread'inin signal mask kümesi onu yaratan üst prosesten aktarılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                76. Ders 27/08/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Seyrek olarak programcı kritik birtakım işlemler yaparken sinyalleri pthread_sigmask fonksiyonuyla bloke edip sonra açarak 
    pause ile bekleyebilmektedir. Örneğin:

    siprocmask(<sinyalleri bloke et>);
    <birtakım işlemler>
    siprocmask(<sinyalleri aç>);
    ---> Problem var!
    pause();
    <bu kısma sinyal geldiğinde geçilmek istenmektedir>

    Programcı sinyalleri açıp pause beklemesini yapmak istediği sırada sinyal prosese gönderilirse henüz akış pause fonksiyona 
    girmeden sinyal teslim edilebilir. Daha sonra akış pause fonksiyonuna girdiğinde buradan çıkılamayacaktır. Çünkü sinyali 
    gönderen kişi pause ile bekleyenin yoluna devam edebilmesi için sinyali göndermiştir. Bu problem atomik bir biçimde sinyalleri 
    açarak pause yapan bir fonksiyonla çözülebilir. İşte sigsuspend fonksiyonu bunu yapmaktadır. sigsuspend fonksiyonunun prototipi 
    şöyledir:

    #include <signal.h>

    int sigsuspend(const sigset_t *sigmask);

    Fonksiyon yeni uygulanacak signal mask kümesini parametre olarak alır. Bu kümeyi fonksiyonu çağıran thread'in (prosesin değil) 
    signal mask kümesi yapar ve atomik bir biçimde pause işleminde bekler. Böylece yukarıda bahsetmiş olduğumuz blokeyi açarak pause
    fonksiyonunda bekleme atomik hale getirilmiş olmaktadır. Tabii sinyal gelip fonksiyondan çıkıldığında, thread'in eski sinyal kümesi 
    yeniden set edilmektedir. POSIX standartları sigsuspend fonksiyonunun yalnızca ilgili thread'in signal mask kümesini etkilediğini 
    belirtmektedir. Eskiden thread'ler yokken bu fonksiyon prosesin signal mask kümesini etkiliyordu. Tabii thread'lerin olmadığı 
    devir ile tek thread'li uygulamalar aynı anlama gelmektedir. Yani başka bir deyişle fonksiyonu biz thread'siz bir programda
    çağırdığımızda fonksiyon eski zamanlardaki gibi prosese özgü işlem yapıyor gibi olacaktır. Ancak mevcut standartlarda sigsuspend
    fonksiyonu yalnızca fonksiyonun çağrıldığı thread'in signal mask kümesi üzerinde etkili olmaktadır. sigsuspend fonksiyonu
    eğer proses ilgili sinyal için bir sinyal fonksiyonu set etmemişse proses sonlanacağı için hiç geri dönmeyebilir. Eğer proses
    bir sinyal fonksiyonu set etmişse bu durumda fonksiyon -1 ile geri döner ve errno değişkeni EINTR değeri ile set edilir. Fonksiyonun
    geri dönüş değerinin kontrol edilmesine gerek yoktur.

    O halde sigsuspend fonksiyonunun eşdeğeri aşağıdaki gibidir:

    pthread_sigmask(SIG_SETMASK, &sset, &oldsset);
    pause();
    pthread_sigmask(SIG_SETMASK, &oldsset, NULL);

    Tabii sigsuspend fonksiyonu bütün bunları kendi içerisinde atomik bir biçimde yapmaktadır.

    sigsuspend fonksiyonunun kullanımının neden gerektiği programcılar tarafından zor anlaşılmaktadır. Çünkü bu fonksiyona oldukça 
    seyrek ihtiyaç duyulur. Konu ile ilgili soru ve cevaplar genellikle şunlardır:

    SORU: sigsuspend fonksiyonuna gereksinim duyulan bir senaryo nasıldır?

    YANIT: Tipik bir senaryo şöyledir: Programcı başka bir prosesten bir sinyal beklemektedir. Ancak o sinyal geldiğinde koduna 
    devam etmek istemektedir. Ancak bu sinyali beklemeden önce sinyalleri bloke ederek bazı işlemler yapmak isteyebilir. Dolayısıyla 
    bu süre zarfında o sinyal oluşursa pending durumda kalacaktır. Programcı sonra sinyalleri açarak pause işleminde diğer prosesin
    sinyalini beklemek ister. Ancak daha önce sinyal oluşmuş da olabilir. Bu durumda sinyali açarak pause işlemi uygularken sinyali 
    açtığı noktada akış henüz pause fonksiyonuna gelmeden sinyal prosese teslim edilirse akış pause fonksiyonuna geldiğinde sonsuz
    bir bekleme oluşmaktadır. İşte sinyallerin açılarak pause beklenmesinin atomik bir biçimde yapılması gerekmektedir.

    SORU: sigsuspend öncesinde sinyallerin bloke edilmesinin nedeni nedir? Çünkü sigsuspend sinyalleri açarak pause uygulamak 
    için kullanılmaktadır.

    YANIT: Bunun çeşitli nedenleri olabilir. Ancak başka bir prosesten sinyal beklerken birtakım başka şeylerin yapılması 
    gerekebilmektedir. Bu durumda diğer proses sinyal gönderirse sinyalin boşa gitmemesi için programcı en azından ilgili sinyali 
    bloke ederek sinyal gelmişse bile onun pending durumda kalmasını sağlayabilir.

    SORU: Zaten bir prosesin, bir işi yapmasını beklemek için senkronizasyon nesneleri kullanılmıyor mu? Neden ayrıca bir sinyal 
    yoluyla böyle bir bekleme yapılmak istensin? Yani örneğin prosesler arasında kullanılan bir durum değişkeni nesnesi ile de aynı 
    şeyler yapılamaz mı?

    YANIT: Evet yapılabilir. Ancak bu tür durumlarda sinyal kullanımı oldukça pratiktir. Yani sinyaller bir anlamda prosesler arası 
    haberleşme yöntemlerinden biri gibi düşünülebilir.

    Aşağıda sigsuspend fonksiyonunun kullanımına bir örnek verilmiştir. Örnekte proses SIGSUR1 sinyalini bloke ederek birtakım 
    işlemler yapmaktadır. (Örneğimizde bu işlemler 30 kere, saniyede bir ekrana bir şeyler yazdırılmasıdır.) Bu sırada prosese 
    sinyal gelse bile sinyal prosese iletilmeyecek ve askıda (pending) kalacaktır. Sonra program bu sinyalleri açarak pause 
    işleminde beklemek istemiştir. Bunun nedeni başka bir prosesin bir işi yapmasını beklemek olabilir. Yani başka bir proses 
    bir işi bitirince bizim programımız yoluna devam edecektir. Burada diğer proses ilgili sinyali (SIGUSR1) 30 saniyelik işlemler 
    sırasında göndermiş olabileceği gibi daha sonra da gönderecek olabilir. Program sinyalleri açarak pause işleminde beklemek 
    istediğinde sinyalleri açar açmaz askıda olan sinyal prosese iletilebilir ve henüz akış pause fonksiyonuna gelmeden sinyal 
    boşa gidebilir. Bu durumda akış pause fonksiyonuna geldiğinde zaten sinyal oluştuğu için ve bir daha da bu sinyal gönderilmeyeceği 
    için sonsuz bir bekleme durumu oluşabilir. Buradaki sigsuspend çağrısının amacı sinyallerin blokesinin çözülmesi ile pause 
    arasında açık bir pencerenin kapatılmasını sağlamaktır. Aşağıdaki örneği çalıştırdıktan sonra başka bir terminalden prosese 
    kill komutu ile SIGUSR1 sinyalini gönderip durumu inceleyiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sigusr1_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;
    sigset_t sset, oldsset;

    sa.sa_handler = sigusr1_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGUSR1, &sa, NULL) == -1)
        exit_sys("sigaction");

    sigfillset(&sset);
    if (sigprocmask(SIG_BLOCK, &sset, &oldsset) == -1)
        exit_sys("sigprocmask");

    for (int i = 0; i < 30; ++i) {
        printf("%d\n", i);
        sleep(1);
    }
    sigsuspend(&oldsset);

    printf("Ok\n");

    return 0;
}

void sigusr1_handler(int sno)
{
    printf("SIGUSR1 handler running...\n");        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz bir fonksiyonun içerisindeyken bir sinyal oluşsa ve sinyal fonksiyonumuz çalıştırılsa ve sinyal fonksiyonumuz da 
    aynı fonksiyonu çağırsa ne olur? Bu tür durumlarda iç içe çağırma söz konusu olacaktır. Bu durum thread güvenlilik durumuna 
    benzemektedir. POSIX standartları bu biçimde sinyal dolayısıyla iç içe çağrılabilecek fonksiyonları "asenkron sinyal güvenli 
    fonksiyonlar (async-signal-safe functions)" ismiyle belirtmektedir. POSIX standartlarında tüm asenkron sinyal güvenli 
    fonksiyonların listesi "System Interfaces/General Information/Signal Concepts" başlığında listelenmektedir. Bu listede 
    belirtilen asenkron sinyal güvenli fonksiyonlar gönül rahatlığı ile sinyal fonksiyonlarında ve dışarıda aynı anda kullanılabilirler. 
    Pekiyi daha önce görmüş olduğumuz thread güvenli sonu _r ile biten fonksiyonlar da sinyal güvenli midir? Genel olarak asenkron 
    sinyal güvenli fonksiyonlar, thread güvenli fonksiyonlardan biraz daha katı bir güvenliliğe sahiptir. Çünkü asenkron sinyal 
    güvenli fonksiyonlar aynı thread akışı tarafından iç içe çağrılabilecek fonksiyonlardır. Bu nedenle genel olarak asenkron 
    sinyal güvenli fonksiyonlar thread güvenli olma eğilimindeyken; asenkron thread güvenli fonksiyonlar, asenkron sinyal güvenli 
    olmayabilmektedir.

    Aslında bir fonksiyon thread güvenli olduğu halde sinyal güvenli olmayabilir, sinyal güvenli olduğu halde thread güvenli 
    olmayabilir. Örneğin bir fonksiyon TSD (Thread Specific Data) kullanılarak thread güvenli hale getirilmiş olabilir. Ancak
    sinyaller iç içe aynı thread tarafından işletilebileceği için bu fonksiyon sinyal güvenli olmayabilir. Yukarıda da belirttiğimiz 
    gibi her zaman olmasa da çoğu zaman sinyal güvenli fonksiyonlar aynı zamanda thread güvenli olma eğilimindedir.

    Fonksiyonun asenkron sinyal güvenli (async-signal-safe) olması genel olarak "reentrant" olması anlamına gelmektedir. Reentrant
    terimi sinyal yoluyla ya da başka yolla (örneğin kesme yoluyla) bir fonksiyonunun iç içe çalışabilirliği anlamına gelmektedir. 
    Dolayısıyla reentrant fonksiyonlar aynı zamanda asenkron sinyal güvenli fonksiyonlardır. Ancak POSIX standartlarında "reentrant" 
    terimi kullanılmamıştır. Reentrant ve thread safe kavramları arasındaki benzerlikler ve farklılıklar için Wikipedia'daki 
    aşağıdaki sayfayı gözden geçirebilirsiniz:

    https://en.wikipedia.org/wiki/Reentrancy_(computing)

    Biz örneklerimizde sinyal fonksiyonu içerisinde printf fonksiyonunu kullanmıştık. POSIX standartlarına göre C'nin tüm dosya 
    fonksiyonları thread güvenli olduğu halde sinyal güvenli değildir. Biz örneklerimizde kullanmış olsak da printf gibi <stdio.h>
    fonksiyonlarını sinyal fonksiyonlarından kullanmayınız. printf fonksiyonunun thread güvenli (thread safe) olduğu halde 
    asenkron sinyal güvenli olmadığına dikkat ediniz. Yani printf fonksiyonunu yazanlar onun farklı thread'lerden çağrılmasına karşı
    önlemler almışlardır ancak onun aynı thread tarafından çağrılmasına karşı herhangi bir önlem almamışlardır. Başka bir deyişle
    örneğin printf fonksiyonu thread güvenli olduğu halde "reentrant" değildir. Tabii bu yalnızca printf fonksiyonu için değil,
    C'nin tampon kullanan tüm <stdio.h> fonksiyonları için geçerlidir. Pekiyi biz sinyal fonksiyonları içerisinde ekrana bir
    şeyler yazdırmak istesek bunu nasıl sağlayabiliriz? Burada ilk akla gelecek yöntem yazdırılacak şeyleri sprintf ile bir tampona 
    yazdırıp, onu write fonksiyonu ile 1 numaralı betimleyiciyi kullanarak ekrana yazdırmaktır. Biz sonraki örneklerde printf
    fonksiyonunun aslında sinyal güvenli olmadığını yalnızca örneklerimizde pratiklik sağladığı için kullandığımızı belirtmek amacıyla
    onun yanına bir UNSAFE notu da ekleyeceğiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sinyal fonksiyonlarını yazarken dikkat edilmesi gereken diğer bir nokta da "errno" sorunudur. Sinyal fonksiyonu içerisinde
    errno değişkeninin değerini değiştirebilecek bir fonksiyon çağrısı varsa bu durum sorunlara yol açabilmektedir. (Anımsanacağı
    gibi bir POSIX fonksiyonu başarılı olduğu halde errno değişkenini yine de set edebilmektedir.) Buradaki sorunun kaynağını
    şöyle bir örnekle açıklayabiliriz:

    if (some_posix_func() == -1) {        // Bizim exit_sys fonksiyonumuz zaten bunu yapıyor
    ---> Bu sırada sinyal gelirse ne olur?
        perror("some_posix_func");
        exit(EXIT_FAILURE);
    }

    Burada ok ile belirtilen noktada bir sinyal gelirse, sinyal fonksiyonu errno değişkenini değiştirebileceği için perror ile 
    rapor edilen mesaj da yanlış bir mesaj olabilecektir. Pekiyi bu sorunu nasıl giderebiliriz? İşte tipik olarak yapılması gereken 
    şey sinyal fonksiyonunun başında errno değişkenini geçici olarak saklayıp sinyal fonksiyonunun sonunda yeniden set etmektir. 
    Örneğin:

    void signal_handler(int sig)
    {
        int errno_temp = errno;

        // birtakım işlemler

        errno = errno_temp;
    }

    Aşağıdaki örnekte yukarıda açıkladığımız problem simüle edilmiştir. Programda önce SIGUSR1 sinyali sigaction fonksiyonu 
    ile set edilmiştir. Sonra olmayan bir dosya açılmak istenmiştir. Olmayan bir dosya open ile açılmak istendiğinde errno 
    değişkeninin ENOENT değeri ile ("No such file or directory") set edilmesi gerekir. Ancak o arada bir sinyal oluşup da
    sinyal fonksiyonu çalıştırıldığında sinyal fonksiyonu da errno değişkenini değiştirirse sorun ortaya çıkacaktır. Biz örneğimizde
    raise fonksiyonu ile bu durumu yapay bir biçimde sağlamaya çalıştık:

    if ((fd = open("file_not_found", O_RDONLY)) == -1) {
        raise(SIGUSR1);        // only for example
        exit_sys("open");
    }

    Sinyal fonksiyonun aşağıdaki gibi olduğunu varsayalım:

    void sigusr1_handler(int sno)
    {
        printf("SIGUSR1 handler running...\n");        // UNSAFE

        kill(1, SIGKILL);        // kill will fail
    }

    Burada kill başarısız olacak ve errno değişkenini EPERM ("Operation not permitted") değeri ile set edecektir. Bu durumda 
    exit_sys fonksiyonu yanlış mesajı rapor edecektir. Bu durumu düzeltmek için sinyal fonksiyonu şöyle düzeltilmelidir:

    void sigusr1_handler(int sno)
    {
        int errno_temp = errno;

        printf("SIGUSR1 handler running...\n");        // UNSAFE

        kill(1, SIGKILL);        // kill will fail

        errno = errno_temp;
    }

    Sinyal fonksiyonunun düzeltilmiş biçimine ilişkin örnek program aşağıda verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>

void sigusr1_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;
    int fd;

    sa.sa_handler = sigusr1_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGUSR1, &sa, NULL) == -1)
        exit_sys("sigaction");

    if ((fd = open("file_not_found", O_RDONLY)) == -1) {
        raise(SIGUSR1);        /* only for example */
        exit_sys("open");
    }

    return 0;
}

void sigusr1_handler(int sno)
{
    int errno_temp = errno;

    printf("SIGUSR1 handler running...\n");        /* UNSAFE */

    kill(1, SIGKILL);        /* kill will fail */

    errno = errno_temp;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir sinyal fonksiyonu yazılırken global bir değişkenin kullanılması gerekebilmektedir. Bu durumda tıpkı çok thread'li 
    uygulamalarda olduğu gibi bu global değişkenin kararsız durumda kalması engellenmelidir. Tabii bu tür durumlarda nesneyi
    mutex gibi mekanizmalarla korumak uygun değildir. Çünkü bu mekanizmalar farklı thread'ler tarafından erişimde koruma 
    amaçlı oluşturulmuştur. Eğer bir sinyal fonksiyonu global bir değişkeni kullanacaksa onu atomik bir biçimde kullanmalıdır.
    Örneğin:

    int g_count;
    ...

    void signal_handler(int sig)
    {
        ...
        ++g_count;        ---> Bu artırma tek bir makine komutu ile yapılmak zorunda değil
        ...
    }

    Bu örnekte akış ++g_count işleminde kesilip, yeniden aynı fonksiyon çalıştırılırsa g_count değeri uygun biçimde artırılamayabilecektir.
    İşte bu tür durumlarda mutex gibi nesneler bize bir koruma sağlamamaktadır. Burada yapılması gereken bu artırımın atomik bir 
    biçimde yani tek bir makine komutuyla yapılmasıdır. İşte C99 ile birlikte C'ye sig_atomic_t türü de eklenmiştir. Bu türden 
    global bir nesne tanımlandığında, bu nesne üzerinde atama işlemleri atomik bir biçimde yapılmaktadır. Ancak ++, -- gibi 
    operatör işlemlerinin atomik yapılmasının bir garantisi yoktur.

    Thread'ler konusunda gördüğümüz gcc ve clang derleyicilerinin built-in fonksiyonlarını bu amaçla kullanabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosese SIGSTOP isimli gönderilirse proses durdurulur ve SIGCONT sinyali gönderilene kadar suspend biçimde kalır. 
    SIGSTOP sinyali tıpkı SIGKILL sinyalinde olduğu gibi bloke edilememekte ve ignore edilememektedir. Ayrıca SIGSTOP sinyali
    için sinyal fonksiyonu da set edilememektedir. SIGCONT sinyali için ise sinyal fonksiyonu set edilebilir ve bu sinyal bloke 
    edilebilir. SIGCONT sinyali bloke edilmiş olsa bile ya da SIGCONT sinyali için sinyal fonksiyonu set edilmiş olsa bile 
    durdurulmuş proses yine çalışmaya devam ettirilmektedir.

    Aslında prosesi durduran tek sinyal SIGSTOP sinyali değildir. Terminal ile ilgili SIGTTIN ve SIGTTOU sinyalleri de prosesin 
    durdurulmasına yol açabilmektedir. Biz bunlara "stop sinyalleri (stop signals)" diyeceğiz.

    Stop sinyalleriyle durdurulmuş bir prosese başka bir sinyal gönderilse bile proses bunu işlemez. Bu durumda sinyal askıda 
    (pending durumda) kalır. Askıdaki sinyaller prosese SIGCONT sinyali gönderilip proses yeniden çalıştırıldıktan sonra (resume 
    edildikten sonra) prosese teslim edilmektedir. Ancak SIGCONT sinyali sonrasında askında stop sinyalleri prosese teslim
    edilmez, doğrudan atılır. Benzer biçimde prosese bir stop sinyali teslim edildiğinde eğer o anda askıda olan SIGCONT sinyali 
    varsa bu sinyal doğrudan atılmaktadır. Durdurulmuş bir proses her zaman SIGKILL sinyali ile sonlandırılabilmektedir. SIGKILL 
    sinyali ile sonlandırma için prosesin SIGCONT sinyali ile çalışmaya devam ettirilmesine gerek yoktur.

    Aşağıdaki programı bir terminalden çalıştırıp diğer bir terminalden ona kill komutuyla SIGSTOP ve SIGCONT sinyallerini 
    göndererek durumu gözlemleyiniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(void)
{
    for (int i = 0; i < 60; ++i) {
        printf("%d\n", i);
        sleep(1);
    }

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Stop edilmiş prosesler ps komutunda Status bilgisi T ile gösterilmektedir. Örneğin:

    $ ps -u
    USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    kaan       24891  0.0  0.1  14176  5628 pts/1    Ss+  01:01   0:00 /usr/bin/bash --init-file /us
    kaan       25747  0.0  0.1  14292  5680 pts/2    Ss+  01:05   0:00 bash
    kaan       31684  0.0  0.1  14292  5776 pts/0    Ss   10:45   0:00 bash
    kaan       32827  0.0  0.0   2772   944 pts/2    T    12:57   0:00 ./mample
    kaan       32831  0.0  0.0  15428  1568 pts/0    R+   12:58   0:00 ps -u
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Klavyeden Ctrl+Z tuşuna basıldığında terminal aygıt sürücüsü oturumun (session) ön plan (foreground) proses grubuna SIGSTOP
    sinyali göndermektedir. Yani biz klavyeden Ctrl+Z tuşlarına basarak da o anda çalışmakta olan programa SIGSTOP sinyalini 
    göndertebilmekteyiz. Bu biçimde kabuk üzerinden durdurulan prosesler "fg (foreground)" kabuk komutuyla kaldığı yerden çalışmaya 
    devam ettirilebilmektedir. Tabii "fg" kabuk komutu aslında ilgili prosese (ya da proseslere) SIGCONT sinyalini göndermektedir. 
    Biz kabuk üzerinden Ctrl+Z tuşuna basarak bir prosesi durdurduğumuzda ona bir numara verilmektedir. fg komutunda o numara 
    kullanılmalıdır. Örneğin:

    $ ./mample
    0
    1
    2
    3
    4
    ^Z
    [3]+  Durdu                   ./mample
    $ fg 3
    $ ./mample
    5
    6
    7
    8
    9
    10
    11
    12
    ...

    Eğer "fg" komutu argümansız kullanılırsa en son stop ettirilen proses çalıştırılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz komut satırında klavyeden Ctrl+C ya da Ctrl+Z tuşlarına bastığımızda SIGINT sinyali ve SIGSTOP sinyali tek bir prosese 
    değil ön plan proses grubundaki proseslerin hepsine gönderilmektedir. Proses grupları ve oturum (session) kavramı sonraki 
    paragraflarda ele alınacaktır. Ancak burada temel bir açıklamayı da yapmak istiyoruz. Biz programımızda fork işlemi 
    yaptığımızda bizim üst prosesimiz ve alt prosesimiz aynı proses grubu içerisinde bulunur. Bu durumda Ctrl+C tuşlarına 
    bastığımızda SIGINT sinyali bu üst prosese de alt prosese de gönderilecek ve iki proses de sonlandırılacaktır (Tabii bu 
    prosesler SIGINT sinyalini set etmemişlerse). Aynı durum Ctrl+Z tuşlarına basıldığında da söz konusu olmaktadır. Ctrl+Z
    tuşlarına basıldığında SIGSTOP sinyali hem üst prosese hem de alt prosese gönderilecektir. Benzer biçimde "fg" komutunu 
    uyguladığımızda SIGCONT sinyali de hem üst prosese hem de alt prosese gönderilmektedir.

    Aşağıdaki programı çalıştırınız ve sonra Ctrl+C tuşlarına basınız. Hem üst prosesin hem de alt prosesin sonlandığını 
    göreceksiniz. Sonra programı yeniden çalıştırıp bu kez de Ctrl+Z tuşlarına basınız. Hem üst prosesin hem de alt prosesin 
    durdurulduğunu göreceksiniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {
        for (int i = 0; i < 60; ++i) {
            printf("Parent: %d\n", i);
            sleep(1);
        }
        if (waitpid(pid, NULL, 0) == -1)
            exit_sys("waitpid");
    }
    else {
        for (int i = 0; i < 60; ++i) {
            printf("Child: %d\n", i);
            sleep(1);
        }
        _exit(0);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    wait fonksiyonu ile alt proses beklenirken, wait fonksiyonu bu beklemeden ancak alt proses sonlandığında çıkabilmektedir. 
    Alt prosesin sonlanması da iki biçimde olabilmektedir: Normal olarak exit ya da _exit fonksiyonlarının çağrılmasıyla ve 
    bir sinyal dolayısıyla. Anımsanacağı gibi biz wait fonksiyonunun status parametresini WIFEXITED ve WIFSIGNALED makrolarına 
    sokarak bu durumu anlayabiliyorduk. Zaten anımsanacağı gibi prosesin exit kodunun oluşabilmesi için onun normal biçimde
    sonlanmış olması gerekiyordu. Fakat ayrıca bir de waitpid fonksiyonu vardı. İşte bu fonksiyonun üçüncü parametresine 
    WUNTRACED ve/veya WCONTINUED bayrakları geçilirse bu durumda waitpid fonksiyonu alt proses durdurulduğunda ve yeniden 
    çalıştırıldığında sonlanacaktır. Bu durumda status parametresindeki değer WIFSTOPPED ve WIFCONTINUED makrolarına sokularak 
    bu durum anlaşılabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosesi terminal yoluyla sonlandırmanın Ctrl+C tuşlarının dışında diğer bir yolu da Ctrl+\ tuşlarını (ya da bazı sistemlerde
    bunun yerine Ctrl+Backspace tuşları da kullanılabilmektedir) kullanmaktır. Bu durumda terminal aygıt sürücüsü oturumun ön plan 
    proses grubuna SIGQUIT isimli bir sinyal göndermektedir. SIGQUIT sinyali prosese gönderildiğinde eğer proses bu sinyali ele 
    almamışsa, proses sonlandırılır ve bir core dosyası oluşturulur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                77. Ders 02/09/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    abort aynı zamanda bir standart C fonksiyonudur. abort fonksiyonu "abnormal" bir sonlandırma için kullanılmaktadır. Pekiyi 
    programcı exit yerine neden programını abort fonksiyonuyla sonlandırmak istesin? İşte bazen içinde bulunulan duruma bağlı
    olarak normal sonlandırma bile yapılamayabilir. Yani exit fonksiyonunun başarılı bir biçimde işlem yapması bile içinde 
    bulunulan duruma göre mümkün olmayabilir. abort fonksiyonu UNIX/Linux sistemlerinde aslında kendi prosesi üzerinde SIGABRT 
    sinyalinin oluşmasına yol açmaktadır. SIGABRT sinyalinin default eylemi de prosesin sonlandırılması ve core dosyasının 
    oluşturulmasıdır. Yani abort fonksiyonu bir core dosyasının oluşumuna yol açtığı için abnormal sonlanmanın debugger altında 
    incelenmesine de olanak sağlamaktadır. SIGABRT sinyali için sinyal fonksiyonu set edilmiş olsa bile sinyal fonksiyonunun 
    çalışması bittikten sonra yine de proses sonlandırılmaktadır. Ayrıca SIGABRT sinyali bloke edilmişse ve ignore edilmişse 
    bile proses yine de sonlandırılmaktadır. SIGABRT sinyali ile prosesin sonlandırılmasının engellenmesinin tek yolu sinyal 
    fonksiyonu içerisinde "long jump" işlemi uygulamaktır. "long jump" konusu izleyen paragraflarda ele alınacaktır. abort 
    fonksiyonunun prototipi şöyledir:

    #include <stdlib.h>

    void abort(void);

    Aşağıdaki örnekte SIGABRT sinyali için bir sinyal fonksiyonu set edilmiştir. Ancak proses yine de sonlanacak ve core dosyası 
    oluşturulacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sigabrt_handler(int sig);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;

    sa.sa_handler = sigabrt_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGABRT, &sa, NULL) == -1)
        exit_sys("sigaction");

    for (int i = 0; i < 60; ++i) {
        printf("%d\n", i);
        sleep(1);
        if (i == 5)
            abort();
    }

    return 0;
}

void sigabrt_handler(int sig)
{
    printf("SIGABRT handler\n");        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde birkaç sinyal, işlemci tarafından oluşturulan içsel kesmelerle işletim sistemi tarafından prosese
    gönderilmektedir. Bunların en çok karşılaşılanı SIGSEGV isimli sinyaldir. Bu sinyal tahsis edilmemiş bir bellek bölgesine 
    erişildiğinde işletim sistemi tarafından prosese gönderilmektedir. Bu sinyalin default eylemi prosesin sonlandırılmasıdır. 
    Bu sinyal bloke edilemez ve ignore edilemez. Programcı nadiren bu sinyalde prosesinin sonlandırılmasını istemeyebilir. 
    Bunun tek yolu "long jump" uygulamaktır.

    Linux sistemlerinde SIGSEGV sinyali için bir sinyal fonksiyonu set edildiyse sinyal oluştuğunda bu sinyal fonksiyonu çalıştırılır. 
    Ancak sinyal fonksiyonunda proses, exit ya da _exit fonksiyonuyla sonlandırılmamışsa aynı sinyal yeniden oluşturulmaktadır. 
    Bazı UNIX türevi sistemlerde sinyal fonksiyonu sonlandığında proses işletim sistemi tarafından sonlandırılmaktadır. (Bu sinyalin 
    oluşmasına yol açan makine komutlarına Intel işlemcilerinde "fault" denilmektedir. Bu tür fault işlemlerinde sinyal fonksiyonu
    geri döndüğünde fault'a yol açan makine komutuyla akış devam ettirilir. Böylece yeniden fault oluşmaktadır.)

    Aşağıdaki örnekte tahsis edilmemiş bir bellek alanına erişilmesinden dolayı SIGSEGV sinyali oluşturulmuştur. Bu sinyal için 
    sinyal fonksiyonu set edilmiş ancak sinyal fonksiyonu içerisinde exit fonksiyonuyla proses sonlandırılmıştır. (Proses exit 
    fonksiyonu ile sonlandırılmasaydı aynı sinyal oluşturulmaya devam edecekti.)
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sigsegv_handler(int sig);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;
    char *str = (char *)0x12345678;

    sa.sa_handler = sigsegv_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGSEGV, &sa, NULL) == -1)
        exit_sys("sigaction");

    *str = 'x';

    printf("unreachable code!...\n");

    return 0;
}

void sigsegv_handler(int sig)
{
    printf("SIGSEGV handler\n");        /* UNSAFE */

    _exit(EXIT_FAILURE);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    SIGSEGV sinyali ile aynı biçimde ele alınan diğer sinyaller SIGBUS, SIGEMT, SIGFPE, SIGILL, SIGTRAP sinyalleridir. SIGFPE 
    sinyali "floating point birimi (FPU)" tarafından oluşturulmaktadır. SIGILL sinyali user mode'da çalışan prosesin özel makine 
    komutlarını kullanmasından dolayı oluşmaktadır (illegal instruction). Bu sinyallerin davranışı SIGSEGV sinyalinde olduğu 
    gibidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Diğer önemli bir sinyal de SIGCHLD isimli sinyaldir. Aslında biz bu sinyalden proses yaratımı kısmında bahsetmiştik. 
    UNIX/Linux sistemlerinde bir alt proses sonlanırken üst prosese SIGCHLD sinyalini göndermektedir. Eskiden bu sinyalin 
    ismi SIGCLD biçimindeydi. Linux sistemlerinde her iki sinyal eşdeğerdir ve aynı numaraya sahiptir. Ancak POSIX standartlarında
    SIGCLD sinyali yoktur.

    Anımsanacağı gibi wait fonksiyonları alt prosesi bekleyerek onu zombie olmaktan kurtarıyordu. İşte zombie proses oluşumunun
    engellenmesinin bir yolu da SIGCHLD sinyalini kullanmaktır. Bu yöntemde üst proses alt prosesleri yaratmadan önce SIGCHLD 
    sinyalini set eder. Böylece alt prosesler sonlandığında programcının set etmiş olduğu sinyal fonksiyonu çalışır. İşte bu 
    sinyal fonksiyonu içerisinde programcı wait fonksiyonlarını uygular. SIGCHLD sinyalinin default eylemi sinyalin "ignore" 
    edilmesidir. Yani biz bu sinyal için herhangi bir şey yapmamışsak alt proses bittiğinde yine bu sinyal oluşur. Ancak 
    işletim sistemi tarafından sinyal "ignore" edilir.

    Zombie proses oluşumunun, wait fonksiyonlarıyla beklemeden engellenmesi için yukarıda da belirttiğimiz gibi wait fonksiyonlarının
    SIGCHLD sinyalinde uygulanması gerekmektedir. Ancak bu uygulama sırasında dikkat edilmesi gereken bir nokta vardır. SIGCHLD
    sinyali geldiğinde sinyal fonksiyonu çalıştırılırken birden fazla alt proses de o sırada sonlanmış olabilir. Sinyaller 
    biriktirilmediği için SIGCHLD için set edilen sinyal fonksiyonundan çıkıldığında askıda (pending) olan SIGCHLD sinyali 
    prosese yalnızca bir kez gönderilecektir. Halbuki birden fazla alt proses o sırada sonlanmış olabilmektedir. İşte bu nedenle 
    SIGCHLD sinyal fonksiyonunda wait işlemi bir kez değil, bir döngü içerisinde uygulanmalıdır. Tabii wait işleminin blokeye 
    yol açmaması için waitpid fonksiyonu son parametresinde WNOHANG değeriyle çağrılmalıdır. Örneğin:

    while (waitpid(-1, NULL, WNOHANG) > 0)
        ;

    Anımsanacağı gibi waitpid fonksiyonu eğer beklenecek herhangi bir alt proses yoksa -1 değerine, WNOHANG değeri geçildiğinde ancak 
    henüz bir alt proses sonlanmamışsa 0 değerine geri dönmektedir. Yukarıdaki döngüde sonlanan bütün alt prosesler beklenmiş 
    olacaktır. Tabii bu sırada errno değişkeni değer değiştirebileceği için fonksiyonun başında alınıp çıkışta yeniden set edilmesi 
    uygun olur. Örneğin:

    void sigchld_handler(int sig)
    {
        int errno_temp = errno;

        while (waitpid(-1, NULL, WNOHANG) > 0)
            ;

        errno = errno_temp;
    }

    waitpid fonksiyonu aslında başka nedenlerle de başarısız olabilir. Gerçi bu durumlar programcı her şeyi doğru yapmışsa 
    söz konusu olmamaktadır. Ancak bazı programcılar waitpid başarısız olmuşsa ve başarısızlık nedeni beklenecek alt prosesin 
    olmayışından dolayı değilse bir hata rapor edebilmektedir. Bu durumda sinyal fonksiyonu şöyle de oluşturulabilmektedir:

    void sigchld_handler(int sig)
    {
        int errno_temp = errno;
        int result;

        while ((result = waitpid(-1, NULL, WNOHANG)) > 0)
            ;

        if (result == -1 && errno != ECHILD)
            exit_sys("waitpid");

        errno = errno_temp;
    }

    Aşağıdaki örnekte üst proses 10 tane alt proses yaratmıştır. Bu alt proseslerin zombie oluşturmasını, SIGCHLD sinyal 
    fonksiyonunda yukarıda belirtildiği gibi engellemiştir. Bu programı çalıştırıp başka bir terminalden "ps -u" komutu 
    ile zombie prosesin oluşmadığını gözlemleyiniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <sys/wait.h>

void sigchld_handler(int sig);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;
    pid_t pid;

    sa.sa_handler = sigchld_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGCHLD, &sa, NULL) == -1)
        exit_sys("sigaction");

    for (int i = 0; i < 10; ++i) {

        if ((pid = fork()) == -1)
            exit_sys("fork");

        if (pid == 0) {
            printf("child process\n");
            usleep(rand() % 500000);
            _exit(EXIT_SUCCESS);
        }
    }

    printf("Press ENTER to continue...\n");
    getchar();

    return 0;
}

void sigchld_handler(int sig)
{
    int errno_temp = errno;
    int result;

    while ((result = waitpid(-1, NULL, WNOHANG)) > 0)
        ;

    if (result == -1 && errno != ECHILD)
        exit_sys("waitpid");

    errno = errno_temp;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Zombie proses oluşumunun otomatik engellenmesinin bir yolu da SIGCHLD sinyalini "ignore" etmektir. Her ne kadar bu sinyalin
    default eylemi zaten "ignore" ise de bu sinyali açıkça "ignore" etmek başka bir anlama gelmektedir. SIGCHLD sinyali, signal 
    fonksiyonu ile ya da sigaction fonksiyonu ile ignore edilirse bu durumda işletim sistemi alt proses bittiğinde onun kaynaklarını
    hemen boşaltır. Böylece zombie oluşumu engellenmiş olur. Tabii biz SIGCHLD sinyalini açıkça ignore edersek artık wait fonksiyonlarını
    uygulayamayız. Ancak bu sinyalin ignore işlemi bazı alt proseslerin yaratılmasından sonra yapılırsa bu durumda bu alt proseslerin
    otomatik kaynak boşaltımının yapılıp yapılmayacağı işletim sisteminden işletim sistemine farklılık gösterebilmektedir. Linux 
    sistemlerinde daha önce yaratılmış olan alt prosesler için otomatik boşaltım yapılmamaktadır. Ayrıca POSIX standartlarında 
    sigaction fonksiyonunda SA_NOCLDWAIT bayrağı bulundurulmuştur. Bu bayrak yalnızca SIGCHLD sinyali için kullanılabilir. 
    Programcı isterse bu bayrak yoluyla da aynı şeyi yapabilir. Ancak bu bayrak kullanıldığında hala SIGCHLD sinyali için set 
    edilmiş olan sinyal fonksiyonunun çalıştırılıp çalıştırılmayacağı işletim sisteminden işletim sistemine farklılık 
    gösterebilmektedir. Linux sistemlerinde bu durumda sinyal fonksiyonu çalıştırılmaktadır.

    Aşağıdaki örnekte yine üst proses 10 tane alt proses yaratmıştır. Ancak üst proses bu işlemlerden önce SIGCHLD sinyalini
    sigaction fonksiyonu ile "ignore" etmiştir. Bu örneği çalıştırıp diğer bir terminalden alt zombie proses oluşmadığını 
    gözlemleyiniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <sys/wait.h>

void sigchld_handler(int sig);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;
    pid_t pid;

    sa.sa_handler = SIG_IGN;
    sigemptyset(&sa.sa_mask);        /* zaten bu elemana bakılmayacak, bu satır olmasa da olur */
    sa.sa_flags = SA_RESTART;        /* zaten bu elemana bakılmayacak, bu satır olmasa da olur */

    if (sigaction(SIGCHLD, &sa, NULL) == -1)
        exit_sys("sigaction");

    for (int i = 0; i < 10; ++i) {

        if ((pid = fork()) == -1)
            exit_sys("fork");

        if (pid == 0) {
            printf("child process\n");
            usleep(rand() % 500000);
            _exit(EXIT_SUCCESS);
        }
    }

    printf("Press ENTER to continue...\n");
    getchar();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    SIGUSR1 ve SIGUSR2 sinyalleri tamamen programcılar kendi uygulamalarında kullansınlar diye bulundurulmuştur. Örneğin bu 
    sinyalleri biz prosesler arası haberleşme amacıyla kullanabiliriz. Bu sinyallerin default eylemi prosesin sonlandırılmasıdır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX'e 90 yılların ortalarında "realtime extensions" başlığı altında "gerçek zamanlı (realtime)" sinyal kavramı da eklenmiştir.
    Gerçek zamanlı sinyallere ayrı isimler verilmemiştir. Gerçek zamanlı sinyallerin numaraları [SIGRTMIN, SIGRTMAX] değerleri 
    arasındadır. Gerçek zamanlı sinyallerin normal sinyallerden (ilk 32 sinyal numarası normal sinyaller için ayrılmıştır) 
    farkları şunlardır:

    1) Gerçek zamanlı sinyaller kuyruklanmaktadır. Yani birden fazla gerçek zamanlı aynı sinyal oluştuğunda kaç tane oluşmuş 
    olduğu tutulur ve o sayıda sinyal prosese teslim edilir. Halbuki normal sinyallerde bir sayaç (biriktirme) mekanizması yoktur. 
    Örneğin biz bir sinyali bloke etmiş olalım. Bu arada o sinyal 10 kere oluşmuş olsun. Sinyalin blokesini açtığımızda bu askıdaki 
    sinyalden yalnızca bir tane prosese teslim edilecektir. Halbuki gerçek zamanlı sinyallerde bu 10 kez oluşmuş sinyal için 
    prosese 10 sinyal teslim edilecektir.

    2) Gerçek zamanlı sinyallerde bir bilgi de sinyale iliştirilebilmektedir. Bu bilgi ya int bir değer ya da bir gösterici olur.
    Gösterici kullanıldığında bu göstericinin gösterdiği yerin hedef proseste anlamlı olması gerekmektedir. Yani bu adresin tipik olarak
    paylaşılan bir bellek alanındaki (shared memory) bir adres olması gerekir. (Tabii paylaşılan bellek alanları farklı proseslerde 
    farklı adreslere map (ya da attach) edilmiş olabilir. Bu durumda bu tür adreslerin göreli bir biçimde oluşturulması uygun olur.)

    3) Gerçek zamanlı sinyallerde bir öncelik ilişkisi (priority) vardır. Birden fazla farklı numaralı gerçek zamanlı sinyal bloke 
    edildiği durumda bloke açılınca bunların oluşma sırası küçük numaradan büyük numaraya göredir. Yani gerçek zamanlı sinyallerde
    küçük numara yüksek öncelik belirtmektedir. Gerçi Linux kernel kodları incelendiğinde Linux'un da bu tür durumlarda önce düşük 
    numaralı sinyali prosese teslim ettiği görülmektedir. Ancak ne olursa olsun bu UNIX türevi sistemlerde standart bir özellik 
    değildir.

    Gerçek zamanlı sinyaller kill fonksiyonu ile değil, sigqueue isimli fonksiyonla gönderilmektedir. Eğer bu sinyaller kill ile 
    gönderilirse kuyruklama yapılıp yapılmayacağı işletim sisteminden işletim sistemine değişebilmektedir. Linux gerçek zamanlı 
    sinyaller için bu kuyruklamayı yapmaktadır. Ancak gerçek zamanlı sinyaller kill POSIX fonksiyonu ile değil, sigqueue POSIX 
    fonksiyonuyla gönderilmelidir.

    Gerçek zamanlı sinyaller set edilirken sigaction fonksiyonu kullanılmak zorundadır. Gerçek zamanlı sinyaller signal fonksiyonu 
    ile set edilememektedir. Bu fonksiyonda sinyal fonksiyonunun adresi artık sigaction yapısının sa_handler elemanına değil, 
    sa_sigaction elemanına yerleştirilmelidir. Tabii fonksiyonun bunu anlaması için flags parametresine de ayrıca SA_SIGINFO 
    eklenmelidir. (Yani başka bir deyişle fonksiyon sa_flags parametresinde SA_SIGINFO değerini gördüğünde artık sinyal 
    fonksiyonu için yapının sa_sigaction elemanına bakar.) Örneğin:

    struct sigaction sa;
    ...
    sa.sa_sigaction = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART|SA_SIGINFO;

    sigaction yapısının sa_sigaction elemanına girilecek fonksiyonun parametrik yapısı aşağıdaki gibi olmak zorundadır:

    void signal_handler(int signo, siginfo_t *info, void *context);

    Aşağıdaki örnekte proc1 programı n tane gerçek zamanlı sinyal gönderir. proc2 ise bunları almaktadır. Programları çalıştırarak
    kuyruklamanın yapıldığına dikkat ediniz. sigqueue fonksiyonunda iliştirilen sinyal bilgisi siginfo_t yapısının si_value
    elemanından alınmaktadır.

    sigqueue fonksiyonuyla set edilen sinyal fonksiyonundaki siginfo_t yapısının diğer elemanlarını ilgili dokümanlardan inceleyiniz.
    (Örneğin burada sinyali gönderen proses id'si, gerçek kullanıcı id'si, sinyalin neden gönderildiği gibi bilgiler vardır.)
---------------------------------------------------------------------------------------------------------------------------*/

/* proc1.c */

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

void exit_sys(const char *msg);

/* ./prog1 <realtime signal no> <process id> <count> */

int main(int argc, char *argv[])
{
    int signo;
    pid_t pid;
    int count;
    int i;
    union sigval val;

    if (argc != 4) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    signo = (int)strtol(argv[1], NULL, 10);
    pid = (pid_t)strtol(argv[2], NULL, 10);
    count = (int)strtol(argv[3], NULL, 10);

    for (i = 0; i < count; ++i) {
        val.sival_int = i;
        if (sigqueue(pid, SIGRTMIN + signo, val) == -1)
            exit_sys("sigqueue");
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigusr1_handler(int sno)
{
    printf("sigusr1 occurred...\n");        /* UNSAFE */
}

/* proc2.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigrt_handler(int signo, siginfo_t *info, void *context);

/* ./prog2 <realtime signal no> */

int main(int argc, char *argv[])
{
    struct sigaction act;
    int signo;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    signo = (int)strtol(argv[1], NULL, 10);

    act.sa_sigaction = sigrt_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_SIGINFO;

    if (sigaction(SIGRTMIN + signo, &act, NULL) == -1)
        exit_sys("sigaction");

    for(;;)
        pause();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigrt_handler(int signo, siginfo_t *info, void *context)
{
    printf("SIGRTMIN + 0 occurred with %d code\n", info->si_value.sival_int);        /* UNSAFE */
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                78. Ders 03/09/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi gerçek zamanlı sinyallere farklı isimler karşı getirilmemiştir. Gerçek zamanlı sinyallerin
    minimum numaraları SIGRTMIN ve maksimum numaraları SIGRTMAX sembolik sabitleriyle <signal.h> içerisinde define edilmiştir. 
    Kursun yapıldığı Linux sistemlerinde SIGRTMIN değeri 34, SIGRTMAX değeri 64'tür. Aslında Linux'ta gerçek zamanlı sinyallerin 
    numaraları 32'den başlamaktadır. Ancak pthread kütüphanesi bunların ilk iki tanesini kullandığı için SIGRTMIN değeri 34'tür. 
    POSIX standartlarında bir sistemin minimum destekleyeceği gerçek zamanlı sinyal sayısı _POSIX_RTSIG_MAX sembolik sabitiyle 
    belirtilmiştir. Bu sembolik sabit 8'dir. Yani UNIX türevi bir sistem en azından 8 gerçek zamanlı sinyali desteklemelidir. 
    Tabii aslında bu minimum değerdir. Pek çok UNIX türevi sistem bundan daha fazla sayıda gerçek zamanlı sinyali desteklemektedir. 
    Bir sistemde, o sistem tarafından desteklenen gerçek zamanlı sinyallerin sayısı ayrıca <limits.h> içerisinde RTSIG_MAX sembolik 
    sabitiyle belirtilmiştir. Yani RTSIG_MAX aslında _POSIX_RTSIG_MAX sembolik sabitinin ilgili sistemdeki gerçek değerini belirtmektedir. 
    Ancak bu RTSIG_MAX sembolik sabiti aslında define edilmek zorunda değildir. Bu durumda bu değer sysconf fonksiyonuyla 
    argüman olarak _SC_RTSIG_MAX değeri geçirilmek suretiyle elde edilmektedir. (Sistem limitleri biraz karmaşık bir konudur.
    Zaten bu konu ayrı bir başlık altında ileride ele alınacaktır.) Linux sistemlerinde <limits.h> dosyası içerisinde RTSIG_MAX değeri 
    32 olarak define edilmiştir.

    Yukarıda da belirttiğimiz gibi gerçek zamanlı sinyaller kuyruklanmaktadır. Yani bir sinyal birden fazla kez oluştuğunda 
    bunlar işletim sistemi tarafından bir kuyruk sisteminde saklanmaktadır. İşte bu kuyruğun uzunluğu da sistemden sisteme 
    değişebilmektedir. POSIX standartları bir sistemin desteklemesi gereken en az kuyruk uzunluğunu _POSIX_SIGQUEUE_MAX
    sembolik sabitiyle <limits.h> dosyası içerisinde belirtmiştir. Bu sembolik sabitin değeri 32'dir. Ancak buradaki kuyruk 
    uzunluğu toplam kuyruk uzunluğudur. Yani her sinyal için ayrı bir kuyruk düşünülmemelidir. Belli bir sistemdeki gerçek değer 
    SIGQUEUE_MAX sembolik sabitiyle <limits.h> içerisinde belirtilmektedir. Ancak bu sembolik sabit de define edilmek zorunda 
    değildir. Linux sistemlerinde SIGQUEUE_MAX sembolik sabiti define edilmemiştir. Linux'ta bu değer eskiden 1024'tü. 
    Sonra NPROC sayısına hizalanmıştır. Programcı bunu Linux sistemlerinde en az 1024 olarak düşünebilir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#include <signal.h>

void exit_sys(const char *msg);

int get_queuemax(void)
{
    int queue_max;

#ifdef SIGQUEUE_MAX
    queue_max = SIGQUEUE_MAX;
#else
    queue_max = sysconf(_SC_SIGQUEUE_MAX);
#endif

    return queue_max;
}

int main(void)
{

    printf("%d\n", SIGRTMIN);            /* 34 */
    printf("%d\n", SIGRTMAX);            /* 64 */
    printf("%d\n", RTSIG_MAX);            /* 32 */
    // printf("%d\n", SIGQUEUE_MAX);    /* Undeclared */
    printf("%d\n", get_queuemax());        /* 30231 */

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Gerçek zamanlı sinyalleri gönderebilmek için sigqueue isimli bir POSIX fonksiyonu kullanılmaktadır. Fonksiyonun prototipi
    şöyledir:

    #include <signal.h>

    int sigqueue(pid_t pid, int signo, union sigval value);

    Fonksiyonun birinci parametresi sinyalin gönderileceği prosesin id değerini almaktadır. İkinci parametre gönderilecek sinyalin
    numarasını belirtmektedir. Üçüncü parametre ise sinyale iliştirilecek ekstra bilgiyi belirtmektedir. sigval isimli birlik (union) 
    şöyle bildirilmiştir:

    union sigval {
        int   sival_int;
        void *sival_ptr;
    };

    Görüldüğü gibi sinyale int bir bilgi de bir adres bilgisi de iliştirilebilmektedir. Tabii sinyale adres bilgisi iliştirilecekse
    bu adresin hedef proseste anlamlı olması gerekmektedir. Fonksiyon başarı durumunda 0, başarısızlık durumunda -1 değerine geri 
    dönmektedir. Bir fonksiyona sigqueue fonksiyonuyla sinyal gönderebilmek için tıpkı kill fonksiyonunda olduğu gibi sinyal gönderen 
    prosesin gerçek ya da etkin kullanıcı id'sinin, hedef prosesin gerçek ya da saklı kullanıcı id'si aynı olması ya da prosesin uygun 
    önceliğe sahip olması gerekmektedir.

    sigqueue fonksiyonu ile gerçek zamanlı sinyallerin dışında normal sinyaller de gönderilebilmektedir. Ancak normal sinyaller
    sigqueue fonksiyonu ile gönderilse bile kuyruklanmayacaktır. Benzer biçimde kill fonksiyonu ile gerçek zamanlı sinyaller de 
    gönderilebilmektedir. Ancak kill fonksiyonunun bu kuyruklamaya yol açıp açmayacağı sistemden sisteme değişebilmektedir.

    sigqueue fonksiyonunda, kill fonksiyonunda olduğu gibi "proses grubuna" sinyal gönderebilme gibi bir özellik yoktur.

    sigqueue fonksiyonu ile gönderilen sinyalin sigaction fonksiyonunda SA_SIGINFO bayrağı ile üç parametreli fonksiyon tarafından 
    alınması da zorunlu değildir. Yani sigqueue fonksiyonu ile gönderilen sinyal, normal sinyal fonksiyonu ile de elde edilebilir. 
    Ancak bu durumda sinyale iliştirilen bilgi elde edilemeyecektir. Özetle:

    1) sigqueue ile gerçek zamanlı sinyal göndermek zorunda değiliz. Ancak gerçek zamanlı olmayan sinyaller kuyruklanmaz.
    2) sigqueue ile gönderilen sinyalin üç parametreli sinyal fonksiyonuyla ele alınması da zorunlu değildir. Ancak bu 
    durumda sinyale iliştirilen bilgi elde edilemektedir. 
    3) Ters bir biçimde kill fonksiyonuyla gönderilen sinyal üç parametreli sinyal fonksiyonu ile de ele alınabilir. Tabii 
    bu durumda bir değer elde edilmeyecektir.
    4) kill fonksiyonuyla gerçek zamanlı sinyal gönderilebilir. Ancak bunun semantiği açıkça belirtilmemiştir. Yani gönderilen 
    sinyal kuyruklanmayabilir. kill fonksiyonuyla gerçek zamanlı sinyal göndermeye çalışmayınız.

    kill kabuk komutu default durumda kill fonksiyonu kullanılarak yazılmıştır. Ancak kill kabuk komutunda -q <değer> seçeneği
    kullanılırsa bu durumda kill kabuk komutu sigqueue fonksiyonunu kullanacaktır.

    Aşağıda bir prosese sigqueue fonksiyonu ile sinyal gönderen bir örnek program verilmiştir. Program üç komut satırı argümanı
    almaktadır. Kullanımı şöyledir:

    $ ./sq <process id> <sig> <value> 

    Linux'ta ilk gerçek zamanlı sinyalin 34 numara olduğunu anımsayınız. Normal olarak gerçek zamanlı sinyaller sigqueue 
    fonksiyonu ile gönderilirken numara SIGRTMIN + n biçiminde belirtilmektedir. Örneğin:

    if (sigqueue(atoi(argv[1]), SIGRTMIN + 1, sv) == -1)
        exit_sys("sigqueue");

    Normal sinyallerin Linux'taki numaraları için signal(7) man sayfasına başvurabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* sq.c */

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

/* ./sq <process id> <sig> <value> */

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    union sigval sv;

    if (argc != 4) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    sv.sival_int = atoi(argv[3]);
    if (sigqueue(atoi(argv[1]), atoi(argv[2]), sv) == -1)
        exit_sys("sigqueue");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    sigqueue fonksiyonu ile gönderilen sinyalin üç parametreli sinyal fonksiyonu ile alınması uygundur. Anımsanacağı gibi üç
    parametreli sinyal fonksiyonunun parametrik yapısı şöyleydi:

    void signal_handler(int signo, siginfo_t *info, void *context);

    Burada fonksiyonun birinci parametresi yine sinyalin numarasını belirtir. İkinci parametresi ise oluşan sinyal hakkındaki
    ayrıntılı bilgilerin bulunduğu siginfo_t türünden bir yapı nesnesinin adresini belirtir. Bu yapının pek çok elemanı vardır:

    siginfo_t {
        int      si_signo;     /* Signal number */
        int      si_errno;     /* An errno value */
        int      si_code;      /* Signal code */
        int      si_trapno;    /* Trap number that caused hardware-generated signal (unused on most architectures) */
        pid_t    si_pid;       /* Sending process ID */
        uid_t    si_uid;       /* Real user ID of sending process */
        int      si_status;    /* Exit value or signal */
        clock_t  si_utime;     /* User time consumed */
        clock_t  si_stime;     /* System time consumed */
        union sigval si_value; /* Signal value */
        int      si_int;       /* POSIX.1b signal */
        void    *si_ptr;       /* POSIX.1b signal */
        int      si_overrun;   /* Timer overrun count; POSIX.1b timers */
        int      si_timerid;   /* Timer ID; POSIX.1b timers */
        void    *si_addr;      /* Memory location which caused fault */
        long     si_band;      /* Band event (was int in glibc 2.3.2 and earlier) */
        int      si_fd;        /* File descriptor */
        short    si_addr_lsb;  /* Least significant bit of address (since Linux 2.6.32) */
        void    *si_lower;     /* Lower bound when address violation occurred (since Linux 3.19) */
        void    *si_upper;     /* Upper bound when address violation occurred (since Linux 3.19) */
        int      si_pkey;      /* Protection key on PTE that caused fault (since Linux 4.6) */
        void    *si_call_addr; /* Address of system call instruction (since Linux 3.5) */
        int      si_syscall;   /* Number of attempted system call (since Linux 3.5) */
        unsigned int si_arch;  /* Architecture of attempted system call (since Linux 3.5) */
    }

    Bu yapının önemli elemanları ve anlamları şunlardır:

    int si_signo:    Oluşan sinyalin numarası.
    int si_errno:    O andaki errno değeri (saklayıp geri yüklemek için gerekebilmektedir).
    pid_t si_pid:    Sinyali gönderen prosesin proses id'sini belirtmektedir.
    uid_t si_uid:    Sinyali gönderen prosesin gerçek kullanıcı id'sini belirtir.
    int si_int:        sigqueue fonksiyonundaki sinyale iliştirilen int değer.
    void *si_ptr:    sigqueue fonksiyonundaki sinyale iliştirilen adres bilgisi.

    sinyal fonksiyonunun üçüncü parametresi (context parametresi) sinyal oluşmadan önceki durum bilgisinin bulunduğu yerin 
    adresini belirtmektedir. Bu parametre Linux sistemlerinde ucontext_t türünden bir yapı nesnesinin adresini tutmaktadır.
    Bu parametreye çok nadir biçimde gereksinim duyulmaktadır.

    Aşağıdaki örnekte "sample" programı üç parametreli sinyal fonksiyonunu kullanmaktadır. Program hangi sinyal için sinyal 
    fonksiyonunu set edeceğini belirten bir komut satırı argümanı almaktadır. Program sonsuz bir döngüde pause çağrılarıyla 
    beklemektedir. Dolayısıyla programı Ctrl+C tuşları ile sonlandırabilirsiniz. Programın kullanımı şöyledir:

    $ ./sample 34

    Bu örnekte 34 Linux'taki ilk gerçek zamanlı sinyal numarasıdır. Bu programa yukarıdaki programı kullanarak sigqueue fonksiyonu 
    ile sinyal gönderebilirsiniz. Örneğin:

    $ ./sq 34183 34 123

    sample programı ona iliştirilen int bilgiyi de sinyal geldiğinde ekrana yazdırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <signal.h>
#include <unistd.h>

void signal_handler(int signo, siginfo_t *info, void *context);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    struct sigaction sa;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("Process id: %jd\n", (intmax_t)getpid());

    sa.sa_sigaction = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART|SA_SIGINFO;

    if (sigaction(atoi(argv[1]), &sa, NULL) == -1)
        exit_sys("sigaction");

    printf("waiting for signals...\n");

    for (;;)
        pause();

    return 0;
}

void signal_handler(int signo, siginfo_t *info, void *context)
{
    printf("#%d signal handler: %d\n", signo, info->si_int);        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekle gerçek zamanlı sinyallerin kuyruklandığını ancak gerçek zamanlı olmayan sinyallerin kuyruklanmadığını 
    gözlemleyebilirsiniz. Buradaki "sample" programını önce 10 numaralı sinyal ile (SIGUSR1) sonra da 34 numaralı sinyal ile 
    (SIGRTMIN + 0) çalıştırınız. Diğer bir terminalden "sample" programı 30 saniye beklerken birkaç sinyal gönderiniz. "sample" 
    programı 30 saniye sonra blokeyi açtığında gerçek zamanlı olmayan sinyaller için bunlardan bir tanesinin teslim edildiğini, 
    gerçek zamanlı sinyaller için hepsinin teslim edildiğini göreceksiniz. Örneğin 10 numaralı sinyal ile (SIGUSR1) şöyle bir 
    durum oluşmuştur:

    Birinci terminal

    $ ./sample 10
    Process id: 46480
    sleep 30 seconds...
    #10 signal handler: 12
    ^C

    İkinci Terminal

    $ ./sq 46480 10 12
    $ ./sq 46480 10 13
    $ ./sq 46480 10 14
    $ ./sq 46480 10 15
    $ ./sq 46480 10 16
    $ ./sq 46480 10 17

    Örneğin 34 numaralı sinyal ile (SIGRTMIN + 0) şöyle bir durum oluşmuştur:

    Birinci Terminal

    $ ./sample 34
    Process id: 46528
    sleep 30 seconds...
    #34 signal handler: 17
    #34 signal handler: 18
    #34 signal handler: 100
    #34 signal handler: 120
    #34 signal handler: 60
    #34 signal handler: 10

    İkinci Terminal

    $ ./sq 46528 34 17
    $ ./sq 46528 34 18
    $ ./sq 46528 34 100
    $ ./sq 46528 34 120
    $ ./sq 46528 34 60
    $ ./sq 46528 34 10
---------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <signal.h>
#include <unistd.h>

void signal_handler(int signo, siginfo_t *info, void *context);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    struct sigaction sa;
    sigset_t ss;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("Process id: %jd\n", (intmax_t)getpid());

    sa.sa_sigaction = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART|SA_SIGINFO;

    if (sigaction(atoi(argv[1]), &sa, NULL) == -1)
        exit_sys("sigaction");

    sigfillset(&ss);
    sigdelset(&ss, SIGINT);
    if (sigprocmask(SIG_BLOCK, &ss, NULL) == -1)
        exit_sys("sigprocmask");

    printf("sleep 30 seconds...\n");
    sleep(30);

    if (sigprocmask(SIG_UNBLOCK, &ss, NULL) == -1)
        exit_sys("sigprocmask");

    for (;;)
        pause();

    return 0;
}

void signal_handler(int signo, siginfo_t *info, void *context)
{
    printf("#%d signal handler: %d\n", signo, info->si_int);        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* sq.c */

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    union sigval sv;

    if (argc != 4) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    sv.sival_int = atoi(argv[3]);
    if (sigqueue(atoi(argv[1]), atoi(argv[2]), sv) == -1)
        exit_sys("sigqueue");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                79. Ders 09/09/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Senkron biçimde sinyal oluşmasını bekleyen iki ilginç fonksiyon vardır: sigwait ve sigwaitinfo. sigwaitinfo fonksiyonu 
    POSIX'e "Realtime Extensions" eklemeleri sırasında dahil edilmiştir. sigwait fonksiyonu uzun süredir zaten bulunmaktadır. 
    Fonksiyonların prototipleri şöyledir:

    #include <signal.h>

    int sigwait(const sigset_t *set, int *sig);
    int sigwaitinfo(const sigset_t *set, siginfo_t *info);

    Bu fonksiyonlar birinci parametresiyle belirtilmiş olan sinyal kümesindeki herhangi bir sinyal oluşana kadar thread'i blokede 
    bekletmektedir. Yani bu fonksiyonlarda biz hangi sinyaller için bekleme yapacağımızı fonksiyonun birinci parametresiyle 
    fonksiyona veririz. Fonksiyon da bu sinyallerden biri oluşana kadar çağrıyı yapan thread'i bloke bekletir. Fonksiyonlar 
    bizim belirttiğimiz kümedeki hangi sinyal dolayısıyla sonlanmışsa o sinyalin bilgilerini bizim ikinci parametreyle verdiğimiz 
    nesneye yerleştirmektedir. sigwait ile sigwaitinfo arasındaki tek fark sigwait fonksiyonunun yalnızca oluşan sinyalin numarasını 
    bize vermesi ancak sigwaitinfo fonksiyonunun oluşan sinyalin pek çok bilgisini siginfo_t yapısı eşliğinde bize vermesidir. 
    sigwait fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda errno değerinin kendisine geri dönmektedir. Zaten 
    POSIX standartları başarısızlık durumunda yalnızca EINVAL errno değerini tanımlamıştır. Ancak sigwaitinfo fonksiyonu başarı 
    durumunda 0, başarısızlık durumunda -1 değerine geri dönmekte ve errno değişkenini uygun biçimde set etmektedir. (sigwait 
    fonksiyonunun errno değişkenini set etmediğine ancak sigwaitinfo fonksiyonunun set ettiğine dikkat ediniz.)

    Biz bu fonksiyonların sinyal kümelerine normal sinyalleri de gerçek zamanlı sinyalleri de ekleyebiliriz. Gerçek zamanlı sinyaller 
    kuyruklandığı için kuyruktaki yalnızca ilk sinyalin bilgisi elde edilecektir. Ancak POSIX standartları pending duruma geçen 
    birden fazla sinyal olduğunda gerçek zamanlı sinyallerden düşük numarada (yüksek öncelikte) olanın bilgilerinin elde edileceğini
    belirtmiş olsa da pending durumda olan hem normal sinyal hem de gerçek zamanlı sinyal olduğunda bunların hangisinin bilgilerinin
    elde edileceği konusunda bir belirlemede bulunmamıştır (unspecified).

    Normal olarak fonksiyonların birinci parametrelerinde belirtilen sinyallerin daha önceden bloke edilmiş olması gerekmektedir. 
    POSIX standartları eğer bu sinyaller bloke edilmediyse fonksiyon çağrısının tanımsız davranış oluşturacağını belirtmektedir.

    Görüldüğü gibi biz sinyalleri bloke edip sigwait ya da sigwaitinfo fonksiyonlarıyla bekleyerek işlediğimizde aslında o 
    sinyalleri asenkron değil, senkron bir biçimde işlemiş olmaktayız.

    Aşağıdaki örnekte önce SIGINT ve SIGUSR1 sinyalleri bloke edilmiş sonra da sigwait fonksiyonu ile bu sinyaller oluşana kadar
    bekleme yapılmıştır. Bu sinyallerden biri gerçekleştiğinde gerçekleşen sinyalin numarası da stdout dosyasına yazdırılmıştır.
    Daha sonra bloke edilen sinyallerin blokelerinin de açıldığına dikkat ediniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

void exit_sys(const char *msg);

int main(void)
{
    sigset_t sset;
    int signo;
    int result;

    sigaddset(&sset, SIGUSR1);
    sigaddset(&sset, SIGINT);

    if (sigprocmask(SIG_BLOCK, &sset, NULL) == -1)
        exit_sys("sigprocmask");

    printf("waiting for signal...\n");

    if ((result = sigwait(&sset, &signo)) != 0) {
        fprintf(stderr, "sigwait: %s\n", strerror(result));
        exit(EXIT_FAILURE);
    }

    printf("%d signal occurred and processing...\n", signo);

    if (sigprocmask(SIG_UNBLOCK, &sset, NULL) == -1)
        exit_sys("sigprocmask");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi C'de goto işlemi aynı fonksiyon içerisinde yapılabilen bir işlemdir. Yani biz C'de bir fonksiyondan başka 
    bir fonksiyonun bir yerine goto yapamayız. Zaten goto etiketleri de C'de "fonksiyon faaliyet alanına (function scope)"
    sahiptir. İşte bir fonksiyondan başka bir fonksiyona goto yapmaya C dünyasında "long jump" denilmektedir. Her ne kadar
    bu "long jump" konusu aslında C Programlama Dili'ne ilişkin bir konu ise de genellikle bu eğitimlerde çok ayrıntı olduğu için
    bu fonksiyon üzerinde durulmamaktadır. Ancak long jump işlemleri sinyaller söz konusu olduğunda UNIX/Linux Sistem Programlama
    faaliyetlerinde kullanılabilmektedir. Biz de burada önce "long jump" işlemini ele alacağız. Sonra da onun sinyaller 
    konusundaki kullanımları üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyondan başka bir fonksiyona goto yapılamamasının temel nedenleri şunlardır:

    1) goto işleminin yapıldığı fonksiyondaki yerel değişkenler stack'tan nasıl boşaltılacaktır? (Bu problem kısmen çözülebilir)
    2) goto yapılan fonksiyondaki yerel değişkenler goto yapıldığı noktada yaratılmış olmayacağı için bu durumda ne olacaktır?
    3) goto yapılan fonksiyon return işlemi yaptığında nereye geri dönecektir? Bu fonksiyon çağrılmadığına göre nereye geri 
    döneceği belli değildir.

    Ancak program akışının daha önce geçilmiş olan başka bir fonksiyondaki bir noktaya aktarılmasında teknik bir sorun yoktur.
    Çünkü daha önce geçilen noktadaki CPU yazmaçlarının konumu saklanırsa ve "long jump" sırasında bu yazmaçların konumu o
    değerlerle yüklenirse adeta akış sanki zamanda geri gitmiş ve geçmişteki o noktaya geri dönülmüş gibi olmaktadır. İşte 
    biz C'de long jump işlemi ile ancak daha önce geçmiş olduğumuz bir noktaya geri dönebiliriz.

    C'de long jump işlemi oldukça basit olarak iki standart C fonksiyonuyla yapılmaktadır: setjmp ve longjmp. Fonksiyonların 
    prototipleri şöyledir:

    #include <setjmp.h>

    int setjmp(jmp_buf env);
    void longjmp(jmp_buf env, int val);

    setjmp fonksiyonu, fonksiyonun çağrıldığı noktadaki CPU yazmaçlarının konumunu alarak jmp_buf ile belirtilen alana yerleştirmektedir. 
    setjmp fonksiyonuna geçirilen jmp_buf nesnesinin global bir biçimde oluşturulmuş olması gerekir. Çünkü bu nesne geriye 
    dönüşte başka bir fonksiyonda longjmp yaparken de kullanılacaktır. longjmp işleminde geri dönüş aslında setjmp fonksiyonunun 
    içerisine yapılmaktadır. Böylece setjmp fonksiyonunun geri dönmesi akışın ilk kez geçişi sırasında olabileceği gibi longjmp 
    ile geri dönüş sırasında da olabilmektedir. Tabii programcının sonsuz döngüye girmemek için setjmp fonksiyonundan akışın 
    ilk kez geçmesinden dolayı mı yoksa longjmp işleminden dolayı mı çıkıldığını anlaması gerekir. İşte setjmp fonksiyonundan ilk 
    kez çıkılırken setjmp fonksiyonu 0 ile geri dönmekte ancak setjmp fonksiyonundan longjmp nedeniyle çıkıldığında setjmp 
    fonksiyonu, longjmp fonksiyonunun ikinci parametresi için girilen argümanla geri dönmektedir. Böylece programcı setjmp 
    fonksiyonundan hangi nedenle çıkıldığını anlayıp geri dönüşte sonsuz döngü oluşmasını engelleyebilir. Örneğin:

    jmp_buf g_jbuf;
    ...

    void foo(void)
    {
        ...

        if (setjmp(g_jbuf) == 1) {
            ...
        }
        else
            bar();
        ...
    }

    void some_func(void)
    {
        ...
        longjmp(g_jbuf, 1);
        ...
    }

    Burada foo fonksiyonunun içerisinde geri dönüş için geri dönüş noktası setjmp fonksiyonunda kaydedilmiştir. Bu kayıttan 
    sonra programcı bar fonksiyonunu çağırarak yoluna devam etmiştir. Ancak akış bar tarafından çağrılan fonksiyon zincirinden 
    biri olan some_func tarafından yeniden longjmp fonksiyonu ile geçmişe yani foo içerisindeki setjmp içerisine aktarılmıştır. 
    Bu durumda artık setjmp'den 1 değeri ile çıkılacak ve tekrar bar fonksiyonu çağrılmayacaktır.

    Aşağıda longjump kullanımına bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <setjmp.h>

void foo(void);
void bar(void);
void tar(void);

jmp_buf g_jbuf;

int main(void)
{
    printf("main begins...\n");

    foo();

    printf("main ends...\n");

    return 0;
}

void foo(void)
{
    printf("foo begins...\n");

    if (setjmp(g_jbuf) != 1)
        bar();

    printf("foo ends...\n");
}

void bar(void)
{
    printf("bar begins...\n");

    tar();

    printf("bar ends...\n");
}

void tar(void)
{
    printf("tar begins...\n");

    longjmp(g_jbuf, 1);

    printf("tar ends...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz setjmp yaptığımızda prosesteki bazı sinyaller bloke edilmişse ve daha sonra bu sinyallerin blokesi açılmışsa 
    biz longjmp ile eski noktaya dönerken sinyallerin bloke durumu ne olacaktır? İşte POSIX standartları setjmp işleminde 
    kayıt yapılırken prosesin sinyal bloke kümesinin de kaydedilip longjmp sırasında geri yükleneceği konusunda bir garanti 
    vermemiştir (unspecified). Bu nedenle eğer geri dönüşte aynı sinyal bloke kümesinin de yüklenmesi isteniyorsa setjmp ve 
    longjmp yerine sigsetjmp ve siglongjmp fonksiyonları kullanılmalıdır. Bu fonksiyonların prototipleri şöyledir:

    #include <setjmp.h>

    int sigsetjmp(sigjmp_buf env, int savemask);
    void siglongjmp(sigjmp_buf env, int val);

    Görüldüğü gibi fonksiyonların genel kullanımı setjmp ve longjmp fonksiyonu ile benzerdir. Ancak sigsetjmp fonksiyonu iki
    parametre almaktadır. Bu ikinci parametre (savemask parametresi) 0 ise prosesin sinyal bloke kümesi kaydedilip geri yükleme 
    yapılmaz, sıfır dışı ise kaydedilip geri yükleme yapılır. (Yani ikinci parametre 0 geçilirse fonksiyon setjmp gibi 
    davranmaktadır.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi "long jump" işlemine neden gereksinim duyulmaktadır? İşte bazı durumlarda programcı bulunan durumdan kaçıp geçmişteki 
    daha güvenli bir noktaya dönmek isteyebilir. Örneğin sinyal fonksiyonlarının içerisinde long jump işlemine sıkça rastlanmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                80. Ders 10/09/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Örneğin biz SIGSEGV sinyali oluştuğunda programı sonlandırmayıp başka birtakım işlemlerle programın çalışmasına devam etmesini
    isteyebiliriz. Bu durumda SIGSEGV sinyali için sinyal fonksiyonu set ederiz, ancak bu sinyal fonksiyonunda daha önceki bir 
    noktaya "long jump" yapabiliriz. Aşağıda bu duruma bir örnek verilmiştir. Bu örnekte sigsetjmp ve siglongjmp kullanmanın 
    özellikle bir nedeni yoktur. Yani örneğimizde setjmp ve longjmp fonksiyonlarını da kullanabilirdik.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <setjmp.h>

void sigsegv_handler(int sig);
void exit_sys(const char *msg);

jmp_buf g_jbuf;

int main(void)
{
    struct sigaction sa;
    char *str = (char *)0x12345678;

    sa.sa_handler = sigsegv_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGSEGV, &sa, NULL) == -1)
        exit_sys("sigaction");

    if (sigsetjmp(g_jbuf, 1) == 1) {
        printf("SIGSEGV occures, but we continue...\n");        /* UNSAFE */
        /* ... */
    }
    else {
        *str = 'x';
        /* ... */
    }

    return 0;
}

void sigsegv_handler(int sig)
{
    /* ... */

    siglongjmp(g_jbuf, 1);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz sinyal fonksiyonları içerisinde yalnızca asenkron sinyal güvenli fonksiyonları kullanabiliyorduk. Sinyal fonksiyonu 
    içerisinde longjmp yaparsak "long jump" yaptığımız yerde sinyal güvenli fonksiyonlar kullanmak zorunda mıyız? İşte sinyal 
    fonksiyonu çalıştırılıp oradan "long jump" yapıldığında atlanılan yerde de sinyal güvenli fonksiyonların kullanılması 
    gerekir. Çünkü bu bakımdan "reentancy" durumunda bir değişiklik yoktur.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sinyal fonksiyonları içerisinde tüm programın sonlandırılması isteniyorsa bu işlem exit standart C fonksiyonu ile yapılmamalıdır.
    Çünkü exit fonksiyonu stdio dosyalarını kapatıp onların tamponlarını tazelemektedir. Dolayısıyla exit fonksiyonu asenkron sinyal 
    güvenli bir fonksiyon değildir. Bu tür durumlarda doğrudan _exit POSIX fonksiyonu ile proses sonlandırılabilir. Anımsanacağı 
    gibi _exit fonksiyonu aslında doğrudan işletim sisteminin prosesi sonlandıran sistem fonksiyonunu çağırmaktadır. Ayrıca 
    C99 ile C'ye eklenen _Exit fonksiyonu da POSIX standartlarına göre asenkron sinyal güvenlidir. _Exit standart C fonksiyonunun 
    stdio tamponlarını flush edip etmeyeceği derleyicileri yazanların isteğine bırakılmıştır. POSIX standartlarına göre 
    bu fonksiyon tamamen _exit fonksiyonu ile eşdeğer işleve sahiptir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi bazı sinyallerdeki default eylem, prosesin sonlandırılmasıyla birlikte bir "core" dosyasının oluşturulmasıdır. 
    Buradaki "core" terimi eski bir terimdir ve ana belleği belirtmektedir. Core dosyasının üretilmesinin amacı onun debugger 
    altında incelenmesine olanak sağlanmasıdır. Böylece çöken bir programda, programın neden ve nerede çöktüğüne ilişkin bir 
    analiz yapılabilmektedir. Core dosyasının incelenmesi çeşitli debugger'larla yapılabilmektedir. Tabii UNIX/Linux dünyasında 
    en yaygın kullanılan debugger "gdb" isimli GNU projesi kapsamında oluşturulmuş olan debugger'dır. Biz izleyen paragraflarda 
    Linux sistemlerinde "core dosyalarına" yönelik bazı açıklamalarda bulunacağız. gdb debugger'ının temel kullanımı başka 
    bölümlerde ele alınacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde sinyal yoluyla core dosyası oluşturulması için sistem limitlerinin uygun olması gerekmektedir. 
    "ulimit -a" komutu ile sistem limitlerine bakılabilir. Eğer burada "core file size" 0 ise bunun artırılması gerekir. 
    "ulimit -c" ile yalnızca "core file size" bilgisi de görüntülenebilmektedir. Bu sınırın "unlimited" hale getirilmesi 
    şöyle yapılabilir:

    $ ulimit -c unlimited

    Core dosyasının üretildiği yer Linux sistemlerinde kullanılan bazı sistem paketlerine göre değişebilmektedir. Eskiden core 
    dosyaları prosesin çalışma dizininde yaratılıyordu. Daha sonra "systemd" paketi ile birlikte core dosyalarının yaratılması 
    biraz daha ayrıntılı hale getirilmiştir. Öncelikle core dosyalarının nasıl isimlendirildiğinin belirlenmesi gerekir. 
    Bunun için proc dosya sisteminde "/proc/sys/kernel/core_pattern" dosyasına bakılmalıdır. Bu dosya core dosyasının hangi 
    isimlendirme biçimiyle nerede yaratılacağını belirtmektedir. Örneğin bu dosyanın içeriği şöyle olabilir:

    |/lib/systemd/systemd-coredump %P %u %g %s %t 9223372036854775808 %h

    Burada core dosyasının üretilmesinde "systemd-coredump" isimli programın kullanılacağı belirtilmektedir. Bu programın dokümantasyonu 
    SYSTEMD-COREDUMP(8) man sayfasında yapılmıştır. Buradaki core_pattern dosyasının içeriğinde bulunan % format karakterleri core
    dosyasının hangi isimlerle kombine edilerek üretileceğini belirtmektedir. core dosyasının yeri aslında systemd-coredump programının 
    konfigürasyonunda belirlenmektedir. Default olarak /var/lib/systemd/coredump dizini kullanılmaktadır. Core dosyaları genellikle 
    lz4 formatında sıkıştırılmış bir biçimde tutulmaktadır. Bazı sistemlerde "core dump" utility'si olarak apport denilen program 
    da kullanılmaktadır. Bazı sistemlerde core_pattern dosyasının içeriği aşağıdaki gibi de olabilir:

    |/usr/share/apport/apport -p%p -s%s -c%c -d%d -P%P -u%u -g%g -- %E

    Burada core dosyasının yaratılma organizasyonu "apport" denilen programa devredilmiştir. Bu program da "core" dosyasını
    "/var/lib/systemd/coredump" dizininde ya da "/var/lib/apport/coredump" dizininde oluşturmaktadır.

    Core dosyalarını kolay yüklemek için ayrıca "coredumpctl" isimli bir programdan da faydalanılabilir. Ancak bu program default
    olarak kurulu durumda değildir. Bunun kurulabilmesi için aşağıdaki komut uygulanabilir:

    $ sudo apt install systemd-coredump

    coredumpctl programı core dosyaları üzerinde işlem yapmayı kolaylaştıran bir programdır. Örneğin üretilmiş olan core dosyalarının 
    listeleri şöyle alınabilir:

    $ coredumpctl list

    Bu komutla tüm üretilmiş olan core dosyaları listelenecektir. En son üretilen dosya listenin sonunda olacaktır. Ancak ters 
    sırada görüntüleme için -r seçeneği kullanılabilmektedir.

    Artık coredumptctl programı yüklendiğine göre ondan faydalanabiliriz. En son core dosyasını gdb ile yüklemek için şöyle 
    yapılır:

    $ coredumpctl gdb

    Bu komut ile her zaman son core dosyası yüklenmektedir. Spesifik bir core dosyasının yüklenmesi de sağlanabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir grup prosesin oluşturduğu gruba "proses grubu" denilmektedir. Proses grubu kavramı bir grup prosese sinyal gönderebilmek 
    için uydurulmuştur. Gerçekten de kill sistem fonksiyonunun birinci parametresi olan pid sıfırdan küçük bir sayı olarak girilirse 
    abs(pid) numaralı proses grubuna sinyal gönderilmektedir. Bir sinyal bir proses grubuna gönderilirse o proses grubunun bütün 
    üyeleri olan proseslere gönderilmiş olur. Anımsanacağı gibi kill fonksiyonun birinci parametresi 0 girildiğinde, sinyal kill 
    fonksiyonunu uygulayan prosesin içinde bulunduğu proses grubuna gönderilmektedir. Yani proses kendi proses grubuna sinyali 
    göndermektedir.

    Her proses grubunun bir id'si vardır. Bir proses grubunun id'si o proses grubundaki bir prosesin proses id'si ile aynıdır. İşte
    proses id'si proses grup id'sine eşit olan prosese, o proses grubunun "proses grup lideri (process group leader)" denilmektedir. 
    Proses grup lideri genellikle proses grubunu yaratan prosestir. fork işlemi sırasında alt prosesin proses grubu onu yaratan 
    üst prosesten alınmaktadır. Yani üst proses hangi proses grubundaysa fork işlemi sonucunda yaratılan proses de aynı proses
    grubunda olur.

    Bir prosesin ilişkin olduğu proses grubunun id'sini alabilmek için getpgrp ya da getpgid POSIX fonksiyonları kullanılır.

    #include <unistd.h>

    pid_t getpgrp(void);
    pid_t getpgid(pid_t pid);

    getpgrp fonksiyonu prosesin kendi grup id'sini elde etmekte kullanılmaktadır. getpgid fonksiyonu ise herhangi bir prosesin 
    proses grup id'sini elde etmekte kullanılmaktadır. getpgid fonksiyonunun parametresi 0 geçilirse fonksiyonu çağıran prosesin 
    proses grup id'si alınmış olur. Yani aşağıdaki çağrı eşdeğerdir:

    pgid = getpgrp();
    pgid = getpgid(0);

    Proses grup lideri olan proses sonlanmış olsa bile proses grubunun id'si aynı biçimde kalmaya devam eder. Yani işletim 
    sistemi bu durumda prosesin id'sini o proses grubu bu id ile temsil edildiği için başka proses'te kullanmaz. Proses grubu 
    gruptaki son prosesin sonlanması ya da grup değiştirmesiyle ömrünü tamamlamaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kabuktan bir program çalıştırdığımızda kabuk fork işlemini yaptıktan sonra alt proses için yeni bir proses grubu oluşturur
    ve alt prosesi o proses grubunun grup lideri yapar. Artık bu program kendi içerisinde fork yaptığında oluşturulacak olan 
    alt proseslerin hepsi aynı proses grubunun içerisinde olacaktır. Örneğin aşağıdaki gibi "sample" isimli bir programı bir 
    terminalden çalıştırmış olalım:

    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>

    void exit_sys(const char *msg);

    int main(void)
    {
        pid_t pid;

        if ((pid = fork()) == -1)
            exit_sys("fork");

        pause();

        return 0;
    }

    void exit_sys(const char *msg)
    {
        perror(msg);

        exit(EXIT_FAILURE);
    }

    Diğer bir terminalden giriş yaparak o terminaldeki (örneğimizde "pts/0") programların proses id'leri, üst proses id'leri ve
    proses grup id'leri hakknda bilgi edinelim:

    $ ps -t pts/0 -o pid,ppid,pgid,cmd
    PID     PPID     PGID CMD
    26158   25044   26158 bash
    29577   26158   29577 ./sample
    29578   29577   29577 ./sample

    Burada ilk çalıştırdığımız sample programının yaratılan proses grubunun grup lideri olduğu görülmektedir. sample programında 
    fork yapılarak oluşturulmuş olan prosesin de proses grup id'sinin aynı olduğuna dikkat ediniz. Proses grup id'leri fork işlemi
    sırasında üst prosesten alt prosese aktarılmaktadır.

    Kabuk üzerinden boru sembolü ile birden fazla programı çalıştırdığımızda kabuk birden fazla proses oluşturmaktadır. 
    Örneğin:

    $ ls -l | grep "sample"

    Burada kabuk "ls" ve "grep" programını çalıştırmak için fork işlemleri yapacaktır. Ancak kabuk burada "ls" ve "grep" proseslerinin
    proses id'lerini aynı yapmaktadır. Örneğin pts/1 terminalinden aşağıdaki gibi bir komut çalıştırmış olalım:

    $ cat | grep "test"

    Burada kabuk programı bir proses grubu oluşturup "cat" ve "grep" komutlarını aynı proses grubuna atayacaktır. Diğer terminalden
    durumu inceleyelim:

    $ ps -t pts/0 -o pid,ppid,pgid,cmd
    PID     PPID    PGID CMD
    34667   34658   34667 bash
    49484   34667   49484 cat
    49485   34667   49484 grep --color=auto test

    Burada "cat" programının yaratılan proses grubunun proses lideri olduğu görülmektedir. "grep" programı da aynı proses 
    grubuna atanmıştır. Yani burada kabuk programı bir proses grubu yaratıp "cat" ve "grep" programlarını aynı proses grubuna
    atamıştır. Tabii burada eğer "cat" ve "grep" programları da kendi içlerinde fork yapsalardı onların alt prosesleri de 
    aynı proses grubuna dahil olacaklardı. Thread'lerin ayrı proses id'leri yoktur. Yalnızca proseslerin proses id'leri vardır. 
    Dolayısıyla bir prosesin herhangi bir thread'inde biz getpgrp fonksiyonunu uygularsak aynı değeri elde ederiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yeni bir proses grubu yaratmak için ya da bir prosesin proses grubunu değiştirmek için setpgid POSIX fonksiyonu kullanılmaktadır.

    #include <unistd.h>

    int setpgid(pid_t pid, pid_t pgid);

    Fonksiyonun birinci parametresi proses grup id'si değiştirilecek prosesi, ikinci parametresi de hedef proses grup id'sini 
    belirtmektedir. Eğer bu iki parametre aynı ise yeni bir proses grubu yaratılır ve bu yeni grubun lideri de buradaki proses 
    olur. Bir proses (uygun önceliğe sahip olsa bile) ancak kendisinin ya da kendi alt proseslerinin proses grup id'lerini 
    değiştirebilir. Fakat üst proses, alt proses exec uyguladıktan sonra artık onun proses grup id'sini değiştirememektedir. 
    Ayrıca setpgid fonksiyonu ile proses ancak kendisinin ya da alt proseslerinin proses grup id'lerini aynı "oturum (session)" 
    içerisindeki bir proses grup id'si olarak değiştirebilmektedir. Oturum (session) kavramı izleyen paragraflarda ele alınmaktadır.

    setpgid fonksiyonunun birinci parametresi 0 girildiğinde fonksiyonu çağıran proses anlaşılmaktadır. İkinci parametresi 0 
    girildiğinde birinci parametresinde belirtilen proses anlaşılmaktadır. Yani aşağıdaki çağrılar eşdeğerdir:

    setpgid(getpid(), getpid());
    setpgid(getpid(), 0);
    setpgid(0, getpid());
    setpgid(0, 0);

    Örneğin kabuktan bir program çalıştırdığımızda kabuk önce fork işlemini yapar sonra alt proseste setpgid fonksiyonu ile 
    yeni bir proses grubu yaratır. Çalıştırılan programı da yeni yaratılan proses grubunun proses grup lideri yapar.

    Aşağıdaki örnekte üst proses fork yaparak alt prosesi oluşturmuştur. Alt proseste de setpgid fonksiyonu ile yeni bir proses 
    grubu yaratılmıştır. Programın örnek çıktısı şöyledir:

    $ ./sample
    Parent process id: 49658
    Parent process id of the parent: 34667
    Parent process group id: 49658
    Child process id: 49659
    Parent process id of the child: 49658
    Child process group id: 49659

    Buradan şunlar anlaşılmaktadır:

    - Kabuk, sample programını çalıştırırken yeni bir proses grubu oluşturup sample programını bu proses grubunun grup lideri 
    yapmıştır.

    - Alt proseste yeni bir proses grubu yaratılmış, alt proses de bu proses grubunun grup lideri olmuştur.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pgid;
    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {        /* parent process */
        printf("Parent process id: %jd\n", (intmax_t)getpid());
        printf("Parent process id of the parent: %jd\n", (intmax_t)getppid());
        pgid = getpgrp();
        printf("Parent process group id: %jd\n", (intmax_t)pgid);

        if (waitpid(pid, NULL, 0) == -1)
            exit_sys("waitpid");
    }
    else {        /* child process */
        sleep(1);
        if (setpgid(getpid(), getpid()) == -1)        /* setpgid(0, 0) */
            exit_sys("setpgid");

        printf("Child process id: %jd\n", (intmax_t)getpid());
        printf("Parent process id of the child: %jd\n", (intmax_t)getppid());
        pgid = getpgrp();
        printf("Child process group id: %jd\n", (intmax_t)pgid);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtildiği gibi kill POSIX fonksiyonuyla (ya da kill komutuyla) bir proses grubuna sinyal gönderildiğinde
    aslında proses grubundaki tüm proseslere sinyal gönderilmektedir. Bunu aşağıdaki programla test edebilirsiniz.

    Aşağıdaki programda üst proses SIGSUR1 sinyalini set ederek fork işlemi yapmıştır. Böylece aynı sinyal alt proseste de 
    set edilmiş durumdadır. Bu programı çalıştırınca üst proses alt prosesi wait fonksiyonunda bekleyecek, alt proses de
    pause ile sinyal oluşana kadar blokede bekleyecektir. Diğer bir terminalden bu proses grubuna kill komutu ile SUGUSR1
    sinyalini göndermeyi deneyiniz. Bunu yaparken kill komutunda proses grup id'sini negatif yapmayı unutmayınız. Aşağıda 
    testin nasıl yapıldığına ilişkin örnek verilmiştir:

    - Terminallerden birinde "sample" programı çalıştırılır:

    $ ./sample
    Parent process id: 49792
    Parent process id of the parent: 34667
    Parent process group id: 49792
    Child process id: 49793
    Parent process id of the child: 49792
    Child process group id: 49792
    SIGUSR1 occurred in process 49793
    SIGUSR1 occurred in process 49792
    waitpid: Interrupted system call

    - Diğer bir terminalden proses grubuna SIGUSR1 sinyali gönderilir:

    $ kill -USR1 -49792
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/wait.h>

void sigusr1_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    pid_t pgid;
    pid_t pid;
    struct sigaction sa;

    sa.sa_handler = sigusr1_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGUSR1, &sa, NULL) == -1)
        exit_sys("siagaction");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {        /* parent process */
        printf("Parent process id: %jd\n", (intmax_t)getpid());
        printf("Parent process id of the parent: %jd\n", (intmax_t)getppid());
        pgid = getpgrp();
        printf("Parent process group id: %jd\n", (intmax_t)pgid);

        if (waitpid(pid, NULL, 0) == -1)
            exit_sys("waitpid");
    }
    else {        /* child process */
        sleep(1);
        printf("Child process id: %jd\n", (intmax_t)getpid());
        printf("Parent process id of the child: %jd\n", (intmax_t)getppid());
        pgid = getpgrp();
        printf("Child process group id: %jd\n", (intmax_t)pgid);

        pause();
    }

    return 0;
}

void sigusr1_handler(int sno)
{
    printf("SIGUSR1 occurred in process %ld\n", (intmax_t)getpid());        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                81. Ders 16/09/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Oturum (session) kabuktaki arka plan çalışmayı düzene sokmak için uydurulmuş bir kavramdır. Bir oturum proses gruplarından 
    oluşur. Oturumu oluşturan proses gruplarından yalnızca biri "ön plan (foreground)", diğerlerinin hepsi "arka plan (background)"
    proses gruplardır. İşte aslında terminal sürücüsü (tty) klavye sinyallerini oturumun ön plan proses grubuna yollamaktadır.

    Kabuk üzerinden bir komut yazıp komutun sonuna & karakteri getirilirse bu & karakteri "bu komutu arka planda çalıştır" 
    anlamına gelmektedir. Böylece kabuk çalıştırılan komutu wait fonksiyonlarıyla beklemez. Yeniden prompt'a düşer. Ancak o komut 
    çalışmaya devam etmektedir. İşte kabuk & ile çalıştırılan her komut için yeni bir proses grubu yaratır ve o proses grubunu 
    oturumun arka plan proses grubu durumuna getirir. Sonunda & olmadan çalıştırılan komutlar ise ön plan proses grubunu oluşturur. 
    Tabii oturumu yaratan aslında genellikle kabuk programlarıdır. Kabuk, oturumu ve proses grubunu yaratır. Kendisi de oturumda bir 
    proses grubunda bulunuyor olur. Oturumların birer id'si vardır. Bir oturumun id'si onu yaratan prosesin içinde bulunduğu proses 
    grubunun id'si olur. Oturumu yaratan bu prosese de "oturum lideri (session leader)" denilmektedir. (Oturum liderinin proses 
    id'sinin, proses grup id'sinin ve oturum id'sinin aynı olması gerektiğine dikkat ediniz.)

    O halde durum özetle şöyledir: Kabuk bir oturum ve bir proses grubu yaratır. Kendisini bu proses grubunun lideri yapar. 
    kendisi proses grubunun ve oturumun lideri durumundadır. (Bu işlemlerin nasıl yapıldığına ilişkin ayrıntılar izleyen paragraflarda 
    açıklanmaktadır.) Sonra kabuk sonu & ile biten komutlar için proses grupları yaratıp bu proses gruplarını oturumun arka plan 
    proses grupları yapar. Sonunda & olmayan komutları da oturumun ön plan proses grubu yapmaktadır. Böylece belli bir anda oturumun 
    içerisinde bir ön plan proses grubu ve çeşitli arka plan proses grupları bulunacaktır. Tabii kabuğun kendisi de "sonunda & 
    olmayan" bir komut uygulandığında oturumun arka plan proses grubu içerisinde bulunuyor olacaktır. Terminal sürücüsü de SIGINT 
    ve SIGQUIT gibi sinyalleri oturumun ön plan proses grubuna göndermektedir. Örneğin biz mample programını sonunda & olacak biçimde 
    sample programını da normal bir biçimde aşağıdaki gibi çalıştırmış olalım:

    $ ./mample &
    [1] 52630
    $./sample

    Her iki program da pause fonksiyonunda bekleyecek biçimde yazılmıştır. Şimdi diğer bir terminalden bu proseslerin id'lerini, 
    proses grup id'lerini, oturum id'lerini yazdıralım:

    $ ps -o pid,pgid,sid,cmd -t pts/0
    PID     PGID    SID CMD
    31684   31684   31684 bash
    52630   52630   31684 ./mample
    52632   52632   31684 ./sample

    Burada görülen şudur: Kabuğun kendisi, mample ve sample prosesleri için ayrı birer proses grubu yaratmıştır. Ancak bu proses grupları 
    aynı oturum içerisindedir. Oturumun lideri ise kabuktur. Komut çıktısından göremesek de kabuk ve mample oturumun arka plan proses gruplarını, 
    sample ise ön plan proses grubunu oluşturmaktadır. mample ve sample proseslerinin grup id'lerinin farklı olduğuna dikkat ediniz.

    Yukarıda da belirttiğimiz gibi oturumların da proses gruplarında olduğu gibi id'leri vardır. Oturumların id'leri (session id) oturum 
    içerisindeki bir proses grubunun liderinin id'si ile aynıdır. Bu prosese aynı zamanda "oturum lideri (session leader)" denilmektedir.

    Kabuktaki bütün arka plan proses komutları "jobs" komutu ile görülebilmektedir. Örneğin:

    $ cat > x &
    [1] 14797
    $ cat > y &
    [2] 14798
    $ cat > z &
    [3] 14799
    $ cat > z | grep "test" &
    [4] 14827
    $ jobs
    [1]   Running                 cat > x &
    [2]   Running                 cat > y &
    [3]-  Running                 cat > z &
    [4]+  Running                 cat > z | grep --color=auto "test" &

    Belli bir arka plan proses grubunu ön plana çekmek için "fg %n (n burada arka plandaki işin numarasını belirtmektedir) 
    komutu uygulanır. % karakteri hiç kullanılmayabilir. Örneğin:

    $ fg %3
    cat > z

    Belli bir arka plan işe (job) yani proses grubuna "kill %n" komutuyla sinyal de gönderebiliriz. Örneğin:

    $ kill %2

    Oturum terminal sürücüsüyle ilişkili bir kavram olarak sisteme sokulmuştur. Oturumların bir "ilişkin olduğu terminal ya da 
    terminal sürücüsü (controlling terminal)" vardır. Bu terminal gerçek terminal ise "/dev/ttynnn" (buradaki nnn bir sayıyı temsil 
    ediyor) terminallerinden biridir. Sahte (pseudo) bir terminal ise "dev/pts/nnn" terminallerinden biridir. Pencere yöneticilerinin
     içerisinde açılan terminaller sahte (pseudo) terminallerdir. Ancak işlev olarak sahte terminallerin gerçek terminallerden bir 
     farkları yoktur. Klavyeden Ctrl+C ve Ctrl+\ (ya da Ctrl + Backspace) tuşlarına basıldığında SIGINT ve SIGQUIT sinyalleri bu 
     terminal sürücüsü tarafından oturumun ön plan proses grubuna gönderilmektedir. Örneğin:

    $ cat | grep "test"

    Bu komut terminalden uygulandıktan sonra biz Ctrl+c tuşlarına bastığımızda SIGINT sinyali ön plan proses grubuna gönderileceğinden 
    dolayı burada hem cat prosesi hem de grep prosesi sonlandırılacaktır.

    Burada aktardığımız bilgiler üzerinde şu anahtar noktalara yeniden dikkatinizi çekmek istiyoruz:

    1) Kabuk programları bir proses grubu ve oturum yaratmakta ve kendilerini proses grubunun ve oturumun oturum lideri yapmaktadır.
    Kabuğun çalıştığı terminal de oturumun "ilişkin olduğu terminal (controlling terminal)" durumundadır.

    2) Kabuk "sonu & ile bitmeyen" her komut için bir proses grubu oluşturur ve o proses grubunu oturumun ön plan proses grubu yapar. 
    Terminal sinyalleri bu proses grubuna gönderilmektedir.

    3) Kabuk "sonu & ile biten" her komut için ayrı bir proses grubu oluşturur ve o proses grubunu oturumun arka plan proses grubu 
    haline getirir.

    4) Terminal tuşlarıyla oluşturulan SIGINT ve SIGQUIT gibi sinyaller oturumun ön plan proses grubuna gönderilmektedir.

    Yukarıda açıklandığı gibi çalışan kabuk programlarına "görev kontrol kabukları (job control shells)" denilmektedir.
    Eski "Bourne Shell" kabuklarında görev kontrol özelliği yoktu. Bugün kullanılan kabuk programlarında genel olarak görev 
    kontrol özelliği bulunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosesin ilişkin olduğu oturum id'si (session id) getsid POSIX fonksiyonuyla alınmaktadır:

    #include <unistd.h>

    pid_t getsid(pid_t pid);

    Fonksiyon parametre olarak prosesin id'sini almaktadır. Eğer bu id değeri 0 olarak girilirse fonksiyonu çağıran prosesin oturum 
    id'si elde edilir.

    Aşağıdaki programda bir prosesin ve onun alt prosesinin id bilgileri stdout dosyasına yazdırılmıştır. Üst ve alt proseslerin 
    aynı session id'ye sahip olduğuna onun da bash'in session id'si (dolayısıyla proses id'si) olduğuna dikkat ediniz. Programın
    çalıştırılması ile elde edilen bir çıktı şöyledir:

    Parent process id: 52812
    Parent process id of the parent: 31684
    Parent process group id: 52812
    Parent process session id: 31684
    Child process id: 52813
    Parent process id of the child: 52812
    Child process group id: 52812
    Child process session id: 31684
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pgid, sid;
    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {        /* parent process */

        pgid = getpgrp();
        sid = getsid(0);

        printf("Parent process id: %jd\n", (intmax_t)getpid());
        printf("Parent process id of the parent: %jd\n", (intmax_t)getppid());
        printf("Parent process group id: %jd\n", (intmax_t)pgid);
        printf("Parent process session id: %jd\n", (intmax_t)sid);

        if (waitpid(pid, NULL, 0) == -1)
            exit_sys("waitpid");
    }
    else {        /* child process */

        sleep(1);

        pgid = getpgrp();
        sid = getsid(0);

        printf("Child process id: %jd\n", (intmax_t)getpid());
        printf("Parent process id of the child: %jd\n", (intmax_t)getppid());
        printf("Child process group id: %jd\n", (intmax_t)pgid);
        printf("Child process session id: %jd\n", (intmax_t)sid);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz sıfırdan bir "job control shell" yazmak istersek bu oturum işlemlerini nasıl yaparız? Öncelikle bizim bir oturum 
    yaratıp oturumumuzu bir terminal aygıt sürücü ile ilişkilendirmemiz gerekir. Yani oturumumuzun bir terminale ("controlling 
    terminal) sahip olması gerekir.

    Yeni bir oturum (session) yaratmak için setsid fonksiyonu kullanılmaktadır:

    #include <unistd.h>

    pid_t setsid(void);

    Fonksiyon şunları yapar:

    - Yeni bir oturum (session) oluşturur.
    - Bu oturum içerisinde yeni bir proses grubu oluşturur.
    - Oluşturulan oturumun ve proses grubunun lideri fonksiyonu çağıran prosestir.

    Görüldüğü gibi bir proses setsid fonksiyonunu çağırdığında bir oturumla birlikte yeni bir proses grubu da oluşturulmaktadır. 
    Bu proses grubu oturumun lideri olmaktadır. setsid fonksiyonu tipik olarak kabuk programları tarafından işin başında 
    çağrılmaktadır. Böylece kabuk yeni bir oturumun hem lideri olur hem de o oturum içerisinde yaratılmış olan bir proses 
    grubunun lideri olur. O halde bir komut uygulanmamış durumdaki kabuk ortamında bir oturum ve bir de proses grubu vardır. 
    Kabuk bu ikisinin de lideri durumundadır. Sonra kabukta sonu & ile bitmeyen bir komut çalıştırıldığında kabuk bu 
    komuta ilişkin proses için yeni proses grubu yaratacak ve bu grubu oturumun ön plan proses grubu yapacaktır.

    setsid fonksiyonunu çağıran proses eğer zaten bir proses grubunun grup lideri ise fonksiyon başarısız olmaktadır. Örneğin 
    biz kabuktan çalıştırdığımız bir programda setsid çağrısı yaparsak başarısız oluruz. O halde bir oturum yaratabilmemiz için
    bizim zaten bir proses grubunun proses grup lideri olmamamız gerekir. Bunu sağlayabilmek için tipik olarak proses önce fork 
    yapar sonra alt proseste setsid fonksiyonunu çağırır. Böylece üst proses proses grup lideri olsa bile alt proses hiçbir 
    zaman proses grup lideri olamayacaktır.

    Örneğin biz kabuktan çalıştırdığımız programda setsid fonksiyonunu çağırırsak fonksiyon başarısız olacaktır. Çünkü 
    kabuk bizim programımız için bir proses grubu yaratıp bizi o proses grubunun grup lideri yapmaktadır. Aşağıdaki 
    programı çalıştırarak hatayı inceleyiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    if (setsid() == -1)        /* function possibly will fail! */
        exit_sys("setsid");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi eğer yeni bir oturum yaratılmak isteniyorsa programın nasıl çalıştırılacağı bilinmediğine 
    göre önce fork uygulayıp alt proseste setsid uygulamak gerekir. Çünkü alt proses hiçbir zaman zaten proses grup lideri 
    olamayacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0)
        _exit(EXIT_SUCCESS);

    if (setsid() == -1)
        exit_sys("setsid");

    printf("Ok, i am session leader of the new session!\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz sıfırdan bir kabuk programı oluşturmak istediğimizde fork yapıp alt proseste setsid fonksiyonunu çağırıp oturum
    yaratabildik. Pekiyi oturumumuzu nasıl bir terminal aygıt sürücüsü ile ilişkilendireceğiz? İşte oturum lideri open 
    fonksiyonuyla O_NOCTTY bayrağı kullanılmadan bir terminal aygıt sürücüsünü açtığında ve elde ettiği dosya betimleyicisi
    ile ioctl(fd, TIOCSCTTY) çağrısı yaptığında artık o terminal oturumun ilişkin olduğu terminal (controlling terminal) 
    durumuna gelir. Örneğin:

    if ((fd = open("/dev/tty1", O_RDWR)) == -1)
        _exit(EXIT_FAILURE);

    if (ioctl(fd, TIOCSCTTY) == -1)
        _exit(EXIT_FAILURE)

    ioctl fonksiyonu aygıt sürücülerdeki fonksiyonların çağrılması için kullanılan genel amaçlı bir fonksiyondur. Bu fonksiyonun 
    kullanımını "aygıt sürücüler" konusunda göreceğiz. (Bazı sistemlerde bu ioctl işlemini yapmaya gerek kalmamaktadır. Ancak Linux 
    sistemlerinde bu işlemin yapılması gerekmektedir.)

    Eğer ioctl işlemi yapılırken terminal o anda başka bir oturumun terminaliyse (controlling terminal) ve çağrıyı yapan proses 
    uygun önceliğe de sahip değilse, çağrı EPERM errno değeri ile başarısız olmaktadır. Ancak ioctl çağrısı yapılırken eğer terminal 
    başka bir oturumun terminaliyse ancak çağrıyı yapan proses uygun önceliğe sahipse bu durumda terminal o oturumdan koparılıp 
    çağrının yapıldığı oturumun terminali (controlling terminal) haline getirilmektedir. Bu durumda ioctl işlemini yapan prosese 
    de "terminali kontrol eden proses (controlling process)" biçiminde isimlendirilmektedir. Normal olarak kabuk programı (bash) 
    terminali kontrol eden proses (controlling process) durumundadır. Dosyaların betimleyicileri üst prosesten alt prosese aktarıldığına 
    göre bu terminal betimleyicisi her proseste gözükecektir. Yukarıda belirttiğimiz gibi buna "ilgili prosesin ilişkin terminal 
    (process controlling terminal)" denilmektedir. Anımsanacağı gibi aslında 0 numaralı betimleyici terminal aygıt sürücüsünün 
    O_RDONLY modunda açılmasıyla, 1 numaralı betimleyici aynı aygıt sürücünün O_WRONLY moduyla açılmasıyla ve stderr dosyası da 
    1 numaralı betimleyicinin dup yapılmasıyla oluşturulmaktadır. Yani aslında 0, 1 ve 2 betimleyiciler aynı terminale ilişkindir.

    Bir oturumun ilişkin olduğu terminalin oturumdan kopartılması işlemi de ioctl(fd, TIOCNOTTY) çağrısıyla yapılabilmektedir.

    Şimdiye kadar oturum ve terminale ilişkin pek çok terim gördük. Bu terimlerin neler olduğunu ve ne anlamlara geldiğini aşağıda
    topluca listelemek istiyoruz:

    - Oturum (Session): Proses gruplarından oluşan görev kontrol kabuklarının faydalandığı bir kavramdır. Yeni bir oturum oluşturmak 
    için setsid fonksiyonu kullanılmaktadır.

    - Oturumun İlişkin Olduğu Terminal (Controlling Terminal): Oturumdaki proseslerin kullandığı terminali (terminal aygıt
     sürücüsünü) belirtmektedir.

    - Prosesin İlişkin Olduğu Terminal (Process Controlling Terminal): Belli bir prosesin kullandığı terminali (terminal aygıt 
    sürücüsünü) belirtmektedir.

    - Oturum Lideri (Session Leader): Oturumu yaratan prosesi belirtir. Bu prosesin proses id'si, proses grup id'si ve oturum id'si
    aynıdır.

    - Oturum Id'si (Session Id): Oturumu temsil eden proses id değeridir. Oturum id'si normal olarak oturum içerisindeki bir 
    proses grubunun, dolayısıyla da prosesin id'si ile aynıdır.

    - Ön Plan Proses Grubu (Foreground Process Group): Oturum içerisindeki özel klavye tuşları için sinyallerin gönderildiği proses 
    grubu. Bu proses grubu doğrudan terminalle etkileşebilmektedir. Sonuna & getirilmeden uygulanan komutlardaki prosesleri kabuk 
    aynı proses grubuna yerleştirmekte ve o proses grubunu da kabuğun ön plan proses grubu yapmaktadır. Belli bir anda oturumda 
    yalnızca bir tane ön plan proses grubu bulunmaktadır.

    - Arka Plan Proses Grubu (Background Process Group): Sonuna & getirilerek uygulanan komutlardaki prosesleri kabuk aynı proses 
    grubuna yerleştirmekte ve o proses grubunu da kabuğun arka plan proses grubu haline getirmektedir. Belli bir anda oturumda 
    birden fazla arka plan proses grubu bulunabilmektedir.

    Aşağıdaki örnekte bir oturum yaratılmış ve "/dev/tty1" terminali oturumun ilişkin olduğu terminal (controlling terminal) 
    yapılmıştır. Sonra prosesin açmış olduğu bütün dosyalar kapatılmış ve ilk üç betimleyicinin söz konusu terminale ilişkin 
    stdini, stdout ve stderr betimleyicisi olması sağlanmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;
    int fd;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0)
        _exit(EXIT_SUCCESS);

    if (setsid() == -1)
        exit_sys("setsid");

    for (int i = 0; i < 1024; ++i)
        close(i);

    if ((fd = open("/dev/tty1", O_RDONLY)) == -1)
        _exit(EXIT_FAILURE);

    if (open("/dev/tty1", O_WRONLY) == -1)
        _exit(EXIT_FAILURE);

    if (dup(1) == -1)
        _exit(EXIT_FAILURE);

    if (ioctl(fd, TIOCSCTTY) == -1)
        _exit(EXIT_FAILURE);

    for (int i = 0; i < 30; ++i) {
    printf("%d\n", i);
    sleep(1);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Oturumdaki ön plan proses grubunun hangisi olduğu tcgetpgrp POSIX fonksiyonuyla elde edilebilir. Oturumun ön plan proses
    grubu da tcsetpgrp POSIX fonksiyonuyla değiştirilebilir.

    #include <unistd.h>

    pid_t tcgetpgrp(int fd);
    int tcsetpgrp(int fd, pid_t pgid_id);

    Fonksiyonlar terminal aygıt sürücüsüne ilişkin dosya betimleyicileri ile çalışmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Oturumun arka plan bir prosesi, prosesin ilişkin olduğu terminalden (controlling terminal) okuma yapmak isterse terminal 
    sürücüsü o arka plan prosesin içinde bulunduğu proses grubuna SIGTTIN sinyalini göndermektedir. Bu sinyalin default eylemi 
    (default action) prosesin durdurulmasıdır. Bu biçimde durdurulmuş olan prosesler SIGCONT sinyali ile yeniden çalıştırılmak 
    istenebilir. Ancak yeniden okuma yapılırsa yine proses durdurulacaktır. Bu tür prosesler kabuk üzerinden fg %n komutuyla ön 
    plana çekilebilir. Bu durumda kabuk önce prosesin proses grubunu ön plan proses grubu yapar sonra da onu SIGCONT sinyali 
    ile yeniden proses grubunu çalışır duruma getirir.

    Aşağıdaki programı komut satırında sonuna & getirerek çalıştırınız. Program 10 saniye sonra stdin dosyasından okuma yapmaya
    çalışacak ve bu nedenden dolayı SIGTTIN sinyali gönderilerek durdurulacaktır. Prosesin durdurulmuş olduğunu "ps -l" komutu 
    ile ya da "ps -o stat,cmd" komutuyla gözlemleyiniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <unistd.h>

int main(void)
{
    int ch;

    sleep(10);
    ch = getchar();
    putchar(ch);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Arka plan proses grubundaki bir proses SIGTTIN sinyalini işleyebilir. Bu durumda proses durdurulmaz. Ancak tabii eğer 
    bu sırada sinyal yeniden başlatılabilir (SA_RESTART) biçimde set edilmemişse read fonksiyonu EINTR errno değeriyle 
    başarısız olacaktır. Eğer SIGTTIN sinyali yeniden başlatılabilir biçimde (yani SA_RESTART bayrağı kullanılarak) set edilmişse 
    bu durumda read fonksiyonu çekirdek tarafından yeniden başlatılacak ve yeniden aynı sinyal oluşacaktır. Dolayısıyla program 
    sonsuz döngüye girecektir.

    Aşağıda programın sonuna & getirerek çalıştırıp log dosyasını inceleyiniz. Programda stdin dosyasından okuma yapılmak 
    istendiğinde SIGTTIN sinyali oluşacak ve read fonksiyonu EINTR errno değeri ile başarısız olacaktır. Bu örnekte sigaction 
    fonksiyonunda sinyalin SA_RESTART özelliği kullanılmadan set edildiğine dikkat ediniz. Eğer biz sinyal fonksiyonunu 
    "otomatik olarak yeniden başlatılabilir biçimde" set etmiş olsaydık read fonksiyonu tekrar tekrar başarısız olacak ve 
    sürekli bir biçimde sinyal fonksiyonu çağrılacaktı. Arka plan proseslerin stdout dosyasına yazmaya çalıştığındaki özel 
    durum izleyen paragrafta ele alınmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <signal.h>

void sigttin_handler(int sno);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;
    char ch;

    sa.sa_handler = sigttin_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    if (sigaction(SIGTTIN, &sa, NULL) == -1)
        exit_sys("sigaction");

    if (read(STDIN_FILENO, &ch, 1) && errno == EINTR)
        printf("read terminated by signal!...\n");

    return 0;
}

void sigttin_handler(int sno)
{
    printf("SIGTTIN occurred!...\n");        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Arka plan proses grubundaki bir prosesin ilişkin olduğu terminale (process controlling terminal) bir şeyler yazmaya çalışması 
    da uygun değildir. Bu durumda da terminal sürücüsü prosesin ilişkin olduğu arka plan proses grubuna SIGTTOU sinyalini 
    göndermektedir. Bu sinyalin default eylemi yine prosesin durdurulmasıdır. Ancak bu sinyalin aygıt sürücüsü tarafından arka 
    plan proses grubuna gönderilmesi için Linux'ta terminalin TOSTOP modunda olması gerekir. Eğer terminal bu modda değilse 
    SIGTTOU sinyali gönderilmemektedir. Bu durumda write fonksiyonu işlemini başarıyla sonlandırabilecektir. Terminal sürücüsünün 
    default davranışını şöyle öğrenebilirsiniz:

    $ stty -a
    speed 38400 baud; rows 27; columns 90; line = 0;
    intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>;
    swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V;
    discard = ^O; min = 1; time = 0;
    -parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
    -ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc
    -ixany -imaxbel iutf8
    opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
    isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt echoctl echoke
    -flusho -extproc

    Burada -tostop SIGTTOU sinyalinin gönderilmeyeceğini belirtmektedir. Arka plan proseslerin terminal sürücüsüne bir şeyler 
    yazdığında SIGTTOU sinyalini göndermesini istiyorsanız şu komutu uygulamalısınız:

    $ stty tostop

    Artık aynı komutu uyguladığımızda ilgili seçenek "-tostop" yerine "tostop" biçiminde görüntülenecektir.

    Terminal aygıt sürücüsünün sinyal göndermemesini sağlamak için ise aşağıdaki komutu uygulayabilirsiniz:

    $ stty -tostop

    Yukarıdaki komutları da kullanarak aşağıdaki programı sonuna & getirerek arka plan proses grubu olarak çalıştırmayı 
    deneyiniz ve durumu gözlemleyiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    if (write(STDOUT_FILENO, "test\n", 5) == -1)
        exit_sys("write");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Eskiden UNIX/Linux sistemlerine RS232 gibi seri haberleşme arayüzleriyle terminaller bağlanırdı. Programcılar ve kullanıcılar 
    da bu terminalleri kullanarak başka bir odadan ya da uzaktan modem ile bağlanarak işlemlerini yapardı. Bu eski terminaller 
    bilgisayar gibi değildi. Yalnızca ekran ve klavyeden oluşuyordu. Bunlara o zamanlar "aptal terminaller (dummy terminals)"
    deniliyordu. Teknoloji gelişince bu aptal terminaller ortadan kalktı. Artık uzaktan bağlanma için aptal terminaller yerine
    aynı zamanda kendisi bilgisayar olan akıllı terminaller kullanılmaya başlandı. Sonra uzaktan kablolu bağlantı büyük ölçüde
    teknoloji dışı kaldı. Bağlantılar genellikle (ssh gibi protokollerle) uzaktan yapılır hale geldi.

    Bugün kullandığımız bilgisayarlarda eski terminallerin simüle edilmesini sağlayan iki temel mekanizma bulunmaktadır. 
    Bunlardan birisi "Ctrl+F+N" tuşlarına basılarak açılan terminallerdir. Bu terminallere genellikle "sanal terminaller 
    (virtual terminals)" denilmektedir. Diğeri ise GUI ortamında pencere yöneticilerinden açılan terminal pencereleridir. 
    Bunlara ise "sahte terminaller (pseudo terminals)" denilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Terminal bağlantısı koptuğunda ya da sahte terminal penceresi kapatıldığında terminal aygıt sürücüsü o terminalin ilişkin 
    olduğu oturumun liderine (aslında oturum liderinin proses grubuna) SIGHUP sinyali göndermektedir. Tipik komut satırlı 
    çalışmada oturum lideri kabuk programıdır. Dolayısıyla terminal penceresi kapatıldığında SIGHUP sinyali kabuk programına 
    (örneğin bash programına) gönderilmektedir. SIGHUP sinyalinin default eylemi prosesin sonlandırılmasıdır. Eğer terminalin 
    ilişkin olduğu (controlling terminal) oturumun lideri bu sinyali "ignore" ederse bu durumda terminalden yapılacak okumalarda 
    read fonksiyonu 0 ile (yani sanki EOF durumu oluşmuş gibi) geri dönmekte write fonksiyonu da EIO errno değeri ile başarısız 
    olmaktadır.

    Terminal bağlantısı koptuğunda ya da sahte terminal penceresi kapatıldığında terminal aygıt sürücüsünün kabuk 
    programına SIGHUP sinyali gönderdiğini belirtmiştik. İşte kabuk programları da bu SIGHUP sinyalini işleyerek oturumdaki 
    tüm proses gruplarına SIGHUP sinyali göndermektedir. Sonuç olarak terminal bağlantısı koptuğunda ya da terminal penceresi 
    kapatıldığında oturumdaki tüm proseslere SIGHUP sinyali gönderilmiş olur ve default durumda oturumun tüm prosesleri bu 
    biçimde sonlandırılır.

    Ancak burada ince bir nokta da vardır. Oturumun arka plan bir proses grubundaki proses terminalden okuma yapmak istediğinde 
    ona SIGTTIN sinyalinin gönderildiğini bu sinyalin de default durumda prosesi durdurduğunu (stop ettirdiğini) belirtmiştik. 
    İşte terminal bağlantısı koptuğunda ya da terminal penceresi kapatıldığında kabuk programı tüm proses gruplarına SIGHUP sinyalini
    gönderdiğinde arka plandaki durdurulmuş olan prosesler bu durumda sonlanmayacaktır. (Durdurulmuş bir prosesin SIGKILL dışında 
    bir sinyali işlemediğini, o sinyal gönderilse bile "pending" durumda kaldığını anımsayınız.) İşte bunun için kabuk programları 
    (ancak tüm kabuk programları değil) durdurulmuş proseslerin bulunduğu proses gruplarına yalnızca SIGHUP sinyalini değil, aynı 
    zamanda SIGCONT sinyalini de göndermektedir. Böylece bu durdurulmuş prosesler çalışmaya başlar başlamaz sonlandırılmaktadır.

    Pekiyi terminale ilişkin proses (controlling process) sonlanırsa ne olacaktır? İşte bu durumda çekirdek oturuma ilişkin tüm 
    prosesleri terminalden koparmaktadır ve oturumun ön plan proses grubuna SIGHUP sinyali göndermektedir. Tabii tipik olarak 
    terminali kontrol eden proses kabuk programı olduğu için kabuk programları bu tür durumlarda özel işlemler uygulamaktadır. 
    Örneğin bash programından "exit" komutu ile çıkmak isterseniz "bash" programı eğer arka planda durdurulmuş prosesler varsa 
    bir uyarı mesajı çıkartmaktadır. Örneğin:

    $ cat &
    [1] 26338
    $ exit
    exit
    Durmuş işler var.

    [1]+  Durdu                   cat
    $

    Ancak bu tür durumlarda üst üste iki kez exit yapıldığında artık "bash" oturumun tüm ön plan ve arka plan proses gruplarına 
    SIGHUP sinyali göndererek onları sonlandırmaktadır. Tabii durdurulmuş proseslere ilişkin proses grupları için aynı zamanda
    SIGCONT sinyalini de göndermektedir.

    Terminal kapatıldığında ya da kabuk programından çıkıldığında o terminalde çalışan programların çalışmasına devam etmesi 
    isteniyorsa bunun için "nohup" ve "disown" isimli programlardan faydalanılmaktadır. nohup programı çalıştırdığı programın
    SIGHUP sinyalini "ignore" eder, disown ise prosesi oturumdan koparır. Örneğin:

    $ nohup ./sample &

    Burada terminal kapatılsa bile bu prosesler çalışmaya devam edecektir. nohup programı stdout dosyasını "nohup.out" isimli
    bir dosyaya yönlendirmektedir. Bu iki komut hakkında ayrıntılı açıklamalar için dokümanlara başvurabilirsiniz.

    Pekiyi terminal bağlantısı koptuğunda ya da terminal penceresi kapatıldığında oluşan SIGHUP sinyali "ignore" edilirse ne olur?
    İşte bir proses ister ön planda isterse arka planda çalışıyor olsun eğer SIGHUP sinyalini "ignore" ederse terminal okumasında
    read fonksiyonu sanki EOF durumu oluşmuş gibi 0 değeri ile geri dönmektedir. Yine ister ön planda isterse arka planda 
    çalışıyor olursa olsun SIGHUP sinyali "ignore" edildiğinde terminale yazma yapılırsa write fonksiyonu EIO errno değeri ile
    başarısız olmaktadır. Bu durum terminalin ilişkin olduğu proses için de (yani kabul prosesi için de) böyledir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Terminal ve oturum konusu ile ilgili diğer bir konu da "öksüz proses grupları (orphan process groups)" konusudur. Anımsanacağı 
    gibi öksüz proses "kendisi devam ettiği halde üst prosesi sonlanmış olan proseslere" deniyordu.

    "Bir proses grubundaki her prosesin üst prosesi o proses grubundaysa ya da aynı oturumda değilse" böyle proses gruplarına
    öksüz proses grupları denilmektedir. Bu tanım kişilere biraz karışık gibi gelmektedir. De Morgan kuralına göre bunun değili 
    alınırsa belki daha sade bir tanım elde edilecektir: "Eğer bir proses grubundaki en az bir prosesin üst prosesi aynı 
    oturumda ancak farklı bir proses grubunda bulunuyorsa" o proses grubu öksüz değildir. Örneğin kabuktan bir program çalıştırmış 
    olalım. Program da birkaç kez fork yapıp alt proses oluşturmuş olsun. Şimdi bu proses grubu öksüz değildir. Çünkü bu gruptaki 
    tüm proseslerin üst prosesleri aynı gruptadır ya da aynı oturumdadır. Kabuktan çalıştırılan prosesin üst prosesinin kabuk 
    olduğuna ve onun da aynı oturumda olduğuna dikkat ediniz. Şimdi kabuktan bir program çalıştıralım. Bu program fork işlemi yapıp 
    kendisini sonlandırsın. Bu durumda alt prosesin üst prosesi "init" prosesi olacaktır. Böylece proses grubundaki söz konusu 
    alt prosesin üst prosesi aynı grupta değildir.

    Yukarıdaki örneği yinelemek istiyoruz. Biz kabuktan "./sample" programını çalıştıralım. Kabuk bu komut için bir ön plan proses 
    grubu oluşturacaktır. sample prosesi de bu ön plan proses grubunun lideri olacaktır. Şimdi biz bu sample prosesi içerisinde 
    fork yapıp üst prosesi sonlandırırsak proses grubu yaşamaya devam eder ancak öksüz durumda olur. Çünkü alt prosesin artık 
    üst prosesi init olacağı için init prosesi de aynı oturumda olmadığından yukarıdaki tanım sağlanmış olacaktır.

    Aşağıdaki örnekte "sample" programında bir kez fork yapılıp üst proses sonlandırılmıştır. ps komutuyla oluşan duruma dikkat 
    ediniz:

    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>

    void exit_sys(const char *msg);

    int main(void)
    {
        pid_t pid;

        if ((pid = fork()) == -1)
            exit_sys("fork");

        if (pid != 0)
            _exit(EXIT_SUCCESS);

        alarm(30);        // 30 saniye sonra proses sonlanacak
        pause();

        return 0;
    }

    void exit_sys(const char *msg)
    {
        perror(msg);

        exit(EXIT_FAILURE);
    }

    Burada ps komutuyla elde edilen çıktılara bakınız:

    $ ps -o pid,ppid,pgid,sid,cmd
      PID    PPID    PGID     SID CMD
    26667   26642   26667   26667 bash
    27410    1136   27409   26667 ./sample
    27411   26667   27411   26667 ps -o pid,ppid,pgid,sid,cmd

    $ ps -p 1136,1 -o pid,ppid,pgid,sid,cmd
     PID    PPID    PGID     SID CMD
       1       0       1       1 /sbin/init splash
    1136       1    1136    1136 /lib/systemd/systemd --user

    Buradan elde edilen değerlere bakıldığında üst prosesi sonlanmış prosesin üst prosesinin 1136 pid değerine sahip olan 
    systemd isimli proses olduğu, systemd prosesinin de üst prosesinin init olduğu anlaşılmaktadır. Biz bir prosesin üst prosesi
    sonlandığında onun üst prosesinin init olacağını söylemiştik. Ancak günümüzdeki systemd init paketlerinde bu durum yukarıdaki 
    gibi biraz farklıdır. Bu konu "servislerin (daemons) anlatıldığı" bölümde ele alınacaktır. Öksüz proses grubu tanımına dikkat 
    edilirse aslında kabuk programının içinde bulunduğu proses grubunun da öksüz olduğu görülmektedir:

    $ ps -o pid,ppid,pgid,sid,cmd
      PID    PPID    PGID     SID CMD
    26667   26642   26667   26667 bash
    27434   26667   27434   26667 ps -o pid,ppid,pgid,sid,cmd

    $ ps -p 26642 -o pid,ppid,pgid,sid,cmd
      PID    PPID    PGID     SID CMD
    26642    1136   26642   26642 /usr/libexec/gnome-terminal-server

    Burada bash kabuk programının üst prosesinin aynı oturuma dahil olmadığını görüyorsunuz. O halde bash prosesi de aslında 
    oturumdaki öksüz bir proses grubundadır.

    Öksüz proses gruplarında şöyle bir ayrıntı da vardır: Kabuk programları terminal bağlantısı koptuğunda ya da sahte terminal 
    penceresi kapatıldığında oturumun öksüz proses gruplarına SIGHUP sinyali göndermemektedir. Ancak bir proses grubu öksüz 
    hale geldiğinde eğer o proses grubu içerisinde durdurulmuş olan (stop edilmiş olan) bir proses varsa terminal aygıt 
    sürücüsü öksüz hale gelmiş olan bu proses grubuna SIGHUP ve SIGCONT sinyalleri göndermektedir. Öksüz proses gruplarındaki 
    proseslerin kabuk programı sonlansa bile yaşamaya devam edeceğine dikkat ediniz.

    Pekiyi öksüz proses grubundaki bir proses terminalden okuma yapmaya çalışırsa ya da terminale yazma yapmaya çalışırsa 
    ne olur? İşte bu durumda read fonksiyonu EIO errno değeri ile başarısız olmaktadır. write fonksiyonu ise terminal aygıt
    sürücünün TOSTOP ayarı aktif değilse normal olarak terminale yazmakta eğer aktif ise o da EIO errno değeri ile başarısız 
    olmaktadır. Örneğin biz üst prosesi sonlanmış bir alt proseste terminalden okuma yapmaya çalışırsak read fonksiyonu başarısız
    olacaktır. Ancak terminale yazma yapmaya çalışırsak terminalin TOSTOP ayarında göre ya yazdıklarımız ekrana çıkacak ya da 
    write fonksiyonu EIO errno değeri ile başarısız olacaktır. (Michael Kerrisk'in "The Linux Programming Environment" kitabının 
    730'uncu sayfasında sanki öksüz proses grubundaki proseslerin terminale yazma yapması durumunda write fonksiyonunun EIO errno 
    değeriyle başarısız olacağı gibi bir cümle edilmiştir. Halbuki bu durum terminalin TOSTOP ayarı ile ilgilidir.)

    Öksüz proses grubundaki proseslere (arka planda çalıştırılsın ya da çalıştırılmasın) terminalden okuma yaptığında 
    SIGTTIN sinyalinin gönderilmediğine, terminalin TOSTOP ayarı ne olursa olsun terminale yazma yapıldığında da SIGTTOU 
    sinyalinin gönderilmediğine dikkat ediniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                82. Ders 17/09/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir thread'in akışını belli bir süre bekletmek için işletim sistemlerinde sleep fonksiyonları bulundurulmaktadır. Bu fonksiyonlar
    thread'i bloke ederek çalışma kuyruğundan çıkartır ve özel sleep kuyruklarına yerleştirir. İstenen zaman dolduğunda yeniden 
    thread çalışma kuyruğuna yerleştirilir. Böylece istenilen miktarda bekleme CPU zamanı harcanmadan sağlanmış olur.

    UNIX türevi sistemlerde ilk zamanlardan beri sleep isimli bir bekleme fonksiyonu bulunmaktadır. Bu fonksiyon saniye 
    cinsinden bir duyarlılığa sahiptir. Günümüzde saniye düşük bir çözünürlük durumuna gelmiştir. sleep fonksiyonunun prototipi 
    şöyledir:

    #include <unistd.h>

    unsigned sleep(unsigned seconds);

    Fonksiyon parametre olarak beklenecek saniye sayısını almaktadır. Fonksiyonun geri dönüş değeri sinyal dolayısıyla erken 
    sonlanmada kalan saniye değerini belirtmektedir. Fonksiyonun 0 ile geri dönmesi normal bir sonlanma anlamına gelmektedir. 
    Ancak fonksiyonun geri döndürdüğü değerin de saniye duyarlılığında olması kalan zaman hakkında detaylı bilgi verememektedir. 
    sleep fonksiyonu sinyal geldiğinde hiçbir zaman otomatik yeniden çalıştırılmaz. Yani örneğin biz bir sinyali SA_RESTART
    bayrağı ile set etmiş olalım ve o anda sleep fonksiyonunda bekliyor olalım. İlgili sinyal geldiğinde sleep yeniden başlatılmaz. 
    Programcılar genel olarak sleep fonksiyonunun geri dönüş değeri ile ilgilenmezler. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz daha önceki kodlarımızda kullanım kolaylığından dolayı kullanmış olsak da aslında usleep fonksiyonu bir POSIX fonksiyonu
    değildir. Ancak Linux ve bazı UNIX türevi sistemlerde glibc kütüphanesinin içerisinde bulunmaktadır. usleep fonksiyonu 
    mikrosaniye çözünürlüğüne sahiptir. Prototipi şöyledir:

    #include <unistd.h>

    int usleep(useconds_t usec);

    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Fonksiyon sinyalden dolayı 
    başarısız olursa yeniden başlatılmaz ve errno değişkeni EINTR değeriyle set edilir. Fonksiyona uygunsuz argüman girildiğinde
    errno değişkeni EINVAL değeriyle set edilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Nanosaniye çözünürlüğe sahip ismine nanosleep denilen bir POSIX fonksiyonu da bulunmaktadır. Bu fonksiyon sonradan POSIX 
    standartlarına eklenmiştir. Fonksiyonun prototipi şöyledir:

    #include <time.h>

    int nanosleep(const struct timespec *rqtp, struct timespec *rmtp);

    Buradaki timespec yapısını daha önce de kullanmıştık. Bu yapı <time.h> dosyası içerisinde aşağıdaki gibi bildirilmiştir:

    struct timespec {
        time_t tv_sec;
        long tv_nsec;
    };

    nanosleep fonksiyonu da bir sinyal oluştuğunda sinyal fonksiyonu set edilmişse başarısız olur ve errno değeri EINTR ile 
    set edilir. Bu durumda bekleme için kalan süre fonksiyonun ikinci parametresiyle belirtilen timespec yapısının içerisine 
    yerleştirilmektedir. Fonksiyonun ikinci parametresi NULL adres girilebilir. Bu durumda bu yerleştirme yapılmaz. Birinci 
    parametreyle ikinci parametreye aynı nesnenin adreslerinin girilmesinde de bir sakınca yoktur.

    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    Aşağıdaki örnekte 3.5 saniyelik bir sleep uygulanmıştır. 1 saniyenin bir milyar nanosaniyeden oluştuğuna dikkat ediniz.
    Bu durumda yarım saniye 500000000 nanosaniyedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void exit_sys(const char *msg);

int main(void)
{
    struct timespec ts;

    printf("sleeping 3.5 seconds...\n");

    ts.tv_sec = 3;
    ts.tv_nsec = 500000000;

    if (nanosleep(&ts, NULL) == -1)
        exit_sys("nanosleep");

    printf("ok...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte SIGINT sinyali set edilmiş ve nanosleep fonksiyonu ile 10.5 saniye bekleme yapılmıştır. Bu programı
    iki durumda test ediniz. Birincisi klavyeden hiçbir tuşa basmadan zamanın dolmasını bekleyiniz. Bu durumda kalan zaman 0 
    olacaktır. İkinci durumda programı çalıştırdıktan sonra Ctrl+C tuşlarına basarak SIGINT sinyali oluşturunuz. Bu durumda 
    kalan zamanın sıfırdan büyük olduğunu göreceksiniz. Örnek iki denemenin sonuçları şöyledir:

    $ ./mample
    sleeping 10.5 second...
    Left second: 0
    Left nanosecond: 0

    $ ./mample
    sleeping 10.5 second...
    ^Csignt handler...
    Left second: 9
    Left nanosecond: 464386077
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <time.h>
#include <errno.h>
#include <signal.h>

void sigint_handler(int sig);
void exit_sys(const char *msg);

int main(void)
{
    struct timespec ts, tsleft;
    struct sigaction sa;

    sa.sa_handler = sigint_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    if (sigaction(SIGINT, &sa, NULL) == -1)
        exit_sys("sigaction");

    printf("sleeping 10.5 second...\n");

    ts.tv_sec = 10;
    ts.tv_nsec = 500000000;

    if (nanosleep(&ts, &tsleft) == -1 && errno != EINTR)
        exit_sys("nanosleep");

    printf("Left second: %ju\n", (intmax_t)tsleft.tv_sec);
    printf("Left nanosecond: %ld\n", (intmax_t)tsleft.tv_nsec);

    return 0;
}

void sigint_handler(int sig)
{
    printf("sigint handler...\n");        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    nanosleep fonksiyonu gerçek zamana (CLOCK_REALTIME) göre bekleme yapmaktadır. Beklemenin değişik zamanlamalara göre (bunlara 
    saat (clock) da denilmektedir) yapılabilmesi için clock_nanosleep fonksiyonu POSIX standartlarına eklenmiştir. Fonksiyonun
    prototipi şöyledir:

    #include <time.h>

    int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *rqtp, struct timespec *rmtp);

    Fonksiyonun birinci parametresi beklemede kullanılacak saatin cinsini belirtmektedir. POSIX standartlarında şu saat cinsleri 
    bulunmaktadır:

    CLOCK_REALTIME: Bu saat kullanılırsa bekleme sistem zamanının değiştirilmesinden etkilenebilmektedir. Örneğin 30 saniye 
    beklemek isterken sistem zamanı ileri alınırsa daha az bekleme söz konusu olabilmektedir.

    CLOCK_MONOTONIC: Sistem zamanının değiştirilmesinden ve diğer faktörlerden etkilenmeyen göreli bir saattir. Monotonic saat
    kararlı beklemeler için tercih edilmesi gereken saattir.

    CLOCK_PROCESS_CPUTIME_ID: Bu saat proses zamanının ölçülmesinde kullanılan saattir. Genel olarak bu saat timer tick'lerle
    ilerletilmektedir.

    CLOCK_THREAD_CPUTIME_ID: Bu saat de thread zamanının ölçülmesinde kullanılan saattir. Genel olarak bu saat de timer tick'lerle
    ilerletilmektedir.

    Linux sistemlerine özgü CLOCK_TAI ve CLOCK_BOOTTIME gibi başka saatler de bulunmaktadır.

    Fonksiyonun ikinci parametresine (flags) ya 0 ya da TIMER_ABSTIME değeri geçilebilir. Eğer bu parametreye TIMER_ABSTIME 
    değeri geçilirse bu durumda bekleme göreli zaman ile değil, mutlak zaman ile yapılmaktadır. Yani başka bir deyişle bu durumda
    bekleme miktarını belirten timespec yapısında beklemenin sonlandırılacağı mutlak zaman bilgisi bulunmalıdır. (Aslında biz 
    mutlak zamanlı beklemeleri thread konusunda bazı senkronizasyon nesnelerinin zaman aşımlı biçimlerini anlatırken görmüştük.)
    Mutlak zaman beklemesi için önce o andaki zaman bilgisinin clock_gettime fonksiyonuyla alınıp üzerine ekleme yapılması 
    gerekmektedir. Örneğin:

    if (clock_gettime(CLOCK_REALTIME, &ts) == -1)
        exit_sys("clock_gettime");

    ts.tv_sec += 10;

    Fonksiyonun üçüncü parametresi bekleme zamanını, dördüncü parametresi ise işlemin sinyal dolayısıyla sonlanması durumunda kalan
    zamanı belirtmektedir. Bu son parametre yine NULL adres geçilebilir. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda 
    errno değerine geri dönmektedir.

    Aşağıda daha önce nanosleep fonksiyonu için yapılan örneğin clock_nanosleep kullanan biçimi verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <time.h>
#include <errno.h>
#include <signal.h>

void sigint_handler(int sig);
void exit_sys(const char *msg);

int main(void)
{
    struct timespec ts, tsleft;
    struct sigaction sa;

    sa.sa_handler = sigint_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    if (sigaction(SIGINT, &sa, NULL) == -1)
        exit_sys("sigaction");

    printf("sleeping 10.5 second...\n");

    ts.tv_sec = 10;
    ts.tv_nsec = 500000000;

    if (clock_nanosleep(CLOCK_MONOTONIC, 0, &ts, &tsleft) == -1 && errno != EINTR)
        exit_sys("clock_nanosleep");

    printf("Left second: %ju\n", (intmax_t)tsleft.tv_sec);
    printf("Left nanosecond: %ld\n", (intmax_t)tsleft.tv_nsec);

    return 0;
}

void sigint_handler(int sig)
{
    printf("sigint handler...\n");        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Şu andaki almak için ve zaman ölçmek için zaten C'de prototipleri <time.h> içerisinde olan standart C fonksiyonları bulundurulmuştur.
    Ancak bu standart C fonksiyonları genel olarak düşük bir çözünürlüğe sahiptir. Bu fonksiyonlar C Programlama Dili kurslarında 
    ele alındığı için biz yalnızca bir özet yapacağız.

    time isimli standart C fonksiyonu epoch'tan geçen (epoch göreli orijini belirten bir terimdir) zamanı time_t türünden vermektedir. 
    Prototipi şöyledir:

    time_t time(time_t *timer);

    Buradaki time_t türü C standartlarına göre nümerik herhangi bir tür olabilmektedir. (Örneğin double ya da float da olabilmektedir.)
    Ancak POSIX standartlarında bu türün bir tamsayı türü olması gerektiği belirtilmiştir. Ayrıca C standartlarında "epoch" belirtilmemiştir. 
    POSIX standartlarında epoch 01/01/1970 : 00:00:00 olarak belirlenmiştir. (Genel olarak C derleyicilerinin hemen hepsi zaten epoch 
    olarak bu tarihi almaktadır.)

    localtime fonksiyonu time_t değerini alarak bunu bileşenlerine ayrıştırır ve struct tm yapısı biçiminde bize verir. Fonksiyonun 
    prototipi şöyledir:

    struct tm *localtime(const time_t *timer);

    gmtime fonksiyonu localtime fonksiyonunun tarih ve zamanı UTC olarak (eski adıyla GMT) veren biçimidir. Fonksiyonun prototipi
    şöyledir:

    struct tm *gmtime(const time_t *timer);

    Türkiye'nin yerel saati UTC'ye göre "day light saving" durumuna bağlı olarak +2 ya da +3 durumundadır.

    ctime ve asctime fonksiyonları doğrudan tarih ve zamanı bize bir yazı olarak vermektedir. Bu iki fonksiyon arasındaki tek fark ctime 
    fonksiyonu time_t parametresi alırken asctime fonksiyonunun struct tm parametresi almasıdır. Bu fonksiyonların prototipleri şöyledir:

    char *ctime(const time_t *timer);
    char *asctime(const struct tm *timeptr);

    mktime fonksiyonu epoch'tan (POSIX'te 01/01/1970'ten) belli bir tarih zamana kadar geçen zamanın elde edilmesinde kullanılmaktadır:

    time_t mktime(struct tm *timeptr);

    Programcı bir struct tm nesnesi tanımlar. Onun içini doldurur ve fonksiyona verir, fonksiyon da epoch'tan geçen zamanı time_t 
    türünden vermektedir.

    C standartlarında epoch ve time_t türü açıkça belirtilmediği için iki time_t değerinin çıkartılması için difftime fonksiyonu 
    bulundurulmuştur:

    double difftime(time_t time1, time_t time0);

    POSIX sistemlerinde zaten time_t saniye belirttiği için bu fonksiyonun kullanılmasına gerek kalmamaktadır.

    strftime fonksiyonu adeta snprintf fonksiyonunun tarih zaman üzerinde formatlama yapan bir biçimi gibidir. Fonksiyonun 
    prototipi şöyledir:

    size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *timeptr);

    Format karakterlerinin neler olduğu ilgili dokümanlardan görülebilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    C'de programın iki noktası arasındaki zamanı ölçmek için iki yöntem kullanılabilmektedir. Birincisi time fonksiyonu 
    ile zamanı elde edip bunları çıkartmak olabilir. Örneğin:

    time_t start, stop;
    ...

    start = time(NULL);
    ...
    ...
    ...
    stop = time(NULL);

    POSIX standartlarında bu yöntem ancak saniye duyarlılıkta ölçüm yapılmasına izin vermektedir. C standartlarında time 
    fonksiyonunun ne verdiği de belirsizdir. Dolayısıyla C standartlarında taşınabilir bir biçimde bu fonksiyonla zaman ölçmek
    aslında mümkün değildir.

    İkinci yöntem clock fonksiyonunu kullanmaktır. clock fonksiyonunun prototipi şöyledir:

    #include <time.h>

    clock_t clock(void);

    Fonksiyon bize clock_t türünden bir timer tick sayısı verir. Ancak bir saniyenin kaç tick'ten oluştuğu CLOCKS_PER_SEC sembolik 
    sabitiyle define edilmiştir. O halde programcı programın iki noktası arasında clock fonksiyonunu çağırıp bunları çıkartıp
    sonucu CLOCKS_PER_SEC değerine bölerse geçen zamanı elde edebilir. Örneğin:

    clock_t start, stop;
    double result;

    start = clock();
    ...
    ...
    ...
    stop = clock();

    result = (double)(stop - start) / CLOCKS_PER_SEC;

    Güncel Linux sistemlerinde CLOCKS_PER_SEC sembolik sabiti 1000000 olarak define edilmiştir. Dolayısıyla bu yöntemle Linux 
    sistemlerinde mikrosaniye duyarlılıkta zaman ölçülebilir. Windows sistemlerinde ise CLOCKS_PER_SEC sembolik sabiti 1000 
    değerindedir. Yani bu yöntemle milisaniye duyarlılıkta ölçüm yapılabilmektedir.

    clock_t türünün C standartlarında ve POSIX standartlarında nümerik bir tür olarak (yani tamsayı ya da gerçek sayı türü) typedef 
    edilmesi gerektiği belirtilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                83. Ders 23/09/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX standartlarında zaman ölçmek için en uygun fonksiyon clock_gettime fonksiyonudur. Biz zaten bu fonksiyonu daha önce
    senkronizasyon nesnelerinde zaman aşımlı bekleme yapmak için kullanmıştık. Fonksiyonun prototipi şöyledir:

    #include <time.h>

    int clock_gettime(clockid_t clock_id, struct timespec *tp);

    Fonksiyonun birinci parametresi zaman ölçümünde kullanılacak saatin türünü almaktadır. Bu tür şunlardan biri olabilir:

    CLOCK_REALTIME
    CLOCK_MONOTONIC
    CLOCK_PROCESS_CPUTIME_ID
    CLOCK_THREAD_CPUTIME_ID

    Biz daha önce CLOCK_REALTIME ile CLOCK_MONOTONIC arasındaki farkı belirtmiştik. CLOCK_REALTIME sistem zamanının değişmesinden
    etkilenebilecek bir saati belirtirken CLOCK_MONOTONIC sistem zamanının değişmesinden etkilenmeyecek stabil bir saati temsil 
    ediyordu. CLOCK_PROCESS_CPUTIME_ID belli bir prosesin tüm thread'lerinin harcadığı CPU zamanını ölçmek için, CLOCK_THREAD_CPUTIME_ID 
    ise belli bir thread'in harcadığı CPU zamanını ölçmek için kullanılmaktadır. Fonksiyonun ikinci parametresi timespec yapı 
    nesnesinin adresini almaktadır. Zaman bilgisi bu nesnenin içerisine yerleştirilmektedir. Fonksiyon başarı durumunda 0, başarısızlık 
    durumunda -1 değerine geri dönmektedir. timespec yapısını yeniden anımsatmak istiyoruz:

    struct timespec {
        time_t   tv_sec;        /* seconds */
        long     tv_nsec;        /* nanoseconds */
    };

    Aşağıda clock_gettime ile programın iki noktası arasındaki zaman ölçümüne bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void exit_sys(const char *msg);

int main(void)
{
    struct timespec ts1, ts2;
    long long elapsed_time;

    if (clock_gettime(CLOCK_MONOTONIC, &ts1) == -1)
        exit_sys("clock_gettime");

    for (int i = 0; i < 2000000000; ++i)
        ;

    if (clock_gettime(CLOCK_MONOTONIC, &ts2) == -1)
        exit_sys("clock_gettime");

    elapsed_time = (ts2.tv_sec * 1000000000LL + ts2.tv_nsec) - (ts1.tv_sec * 1000000000LL + ts1.tv_nsec);
    /* elsapsed_time = (ts2.tv_sec - ts1.tv_sec) * 1000000000.0 + ts2.tv_nsec - ts1.tv_nsec; */

    printf("Elapsed Nanosecond: %lld\n", elapsed_time);
    printf("Elapsed Second: %f\n", elapsed_time / 1000000000.);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    clock_gettime fonksiyonu ile elde edilen zaman her ne kadar nanosaniye mertebesindeki timespec yapısının içerisine 
    yerleştiriliyorsa da ölçüm duyarlılığı umulan kadar yüksek olmayabilir. Çünkü ölçümün duyarlılığı işlemciye ve işletim
    sisteminin çekirdeğine bağlı olabilmektedir. İşte ölçümün duyarlılığı ayrıca clock_getres fonksiyonu ile elde edilebilmektedir.

    #include <time.h>

    int clock_getres(clockid_t clock_id, struct timespec *res);

    Fonksiyonun birinci parametresi duyarlılığı ölçülecek olan saat türünü belirtmektedir. İkinci parametre ise duyarlılığın 
    yerleştirileceği timespec yapısının adresini belirtmektedir.

    Aşağıda fonksiyonun kullanımına bir örnek verilmiştir. Kursun yürütüldüğü sanal makinede bu fonksiyon 1 nanosaniye duyarlılık 
    belirtmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void exit_sys(const char *msg);

int main(void)
{
    struct timespec ts;
    long long result;

    if (clock_getres(CLOCK_MONOTONIC, &ts) == -1)
        exit_sys("clock_getres");

    result = (ts.tv_sec * 1000000000LL + ts.tv_nsec);

    printf("%lld\n", result);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    clock_gettime fonksiyonunda clockid_t olarak CLOCK_PROCESS_CPUTIME_ID geçilirse prosesin yalnızca CPU'da harcadığı zamanların
    toplamı verilir. Bu muhtemelen gerçek zamandan daha kısa olacaktır. Eğer proses çok thread'ten oluşuyorsa bu hesaba tüm 
    thread'lerin CPU zamanları dahil edilmektedir. Fakat clockid_t olarak CLOCK_THREAD_CPUTIME_ID verilirse bu da spesifik 
    bir thread'in (fonksiyonu çağıran) CPU zamanını ölçmekte kullanılır.

    Aşağıdaki örnekte aslında programın iki noktası arasında geçen zaman 5 saniyeden daha yüksek olduğu halde ölçüm 
    CLOCK_PROCESS_CPUTIME_ID ile yapıldığından ve yalnızca prosesin CPU'da harcadığı zamanın ölçülmesinden dolayı işlemden 
    çok küçük bir değer elde edilecektir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    struct timespec ts1, ts2;
    long long elapsed_time;

    if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts1) == -1)
        exit_sys("clock_gettime");

    for (int i = 0; i < 5; ++i) {
        for (int k = 0; k < 10000000; ++k)
            ;
        sleep(1);
    }

    if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts2) == -1)
        exit_sys("clock_gettime");

    elapsed_time = (ts2.tv_sec * 1000000000LL + ts2.tv_nsec) - (ts1.tv_sec * 1000000000LL + ts1.tv_nsec);
    /* elsapsed_time = (ts2.tv_sec - ts1.tv_sec) * 1000000000.0 + ts2.tv_nsec - ts1.tv_nsec; */

    printf("Elapsed Nanosecond: %lld\n", elapsed_time);
    printf("Elapsed Second: %f\n", elapsed_time / 1000000000.);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    clock_gettime fonksiyonunda eğer clock id olarak CLOCK_THREAD_CPUTIME_ID verilirse yalnızca fonksiyonu çağıran thread'in
    CPU'da harcadığı zaman elde edilmektedir. Tabii tek thread'li uygulamalarda CLOCK_PROCESS_CPUTIME_ID ile CLOCK_THREAD_CPUTIME_ID
    arasında bir fark oluşmayacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Ayrıca POSIX standartlarında clock_settime isimli bir fonksiyon da vardır. Bu fonksiyon söz konusu saati set etmek için
    kullanılmaktadır. Ancak set işlemi yalnızca uygun önceliğe sahip prosesler tarafından yapılabilmektedir. Her saat türü de
    set edilemeyebilmektedir. Fonksiyonun prototipi şöyledir:

    #include <time.h>

    int clock_settime(clockid_t clock_id, const struct timespec *tp);

    Biz burada bu fonksiyonun kullanımına örnek vermeyeceğiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosesin user mode'da ve kernel mode'da harcadığı zamanlar işletim sistemi tarafından proses kontrol bloğunda saklanmaktadır. 
    Proses kontrol bloğundan bu bilgiler times isimli POSIX fonksiyonu ile (doğrudan ilgili sistem fonksiyonunu çağırmaktadır)
    elde edilebilmektedir. Fonksiyonun prototipi şöyledir:

    #include <sys/times.h>

    clock_t times(struct tms *buffer);

    Fonksiyon çağrıldığı ana kadarki prosesin zaman bilgisini alarak tms isimli bir yapı nesnesinin içerisine yerleştirmektedir. 
    Fonksiyonun geri dönüş değeri belli bir orijinden geçen gerçek zamanı belirten bir değerdir. (Yani bu değer tek başına bir 
    anlam taşımaz.) Fonksiyon başarısızlık durumunda -1 değerine geri dönmektedir.

    tms yapısı şöyledir:

    struct tms {
        clock_t tms_utime;    /* user time */
        clock_t tms_stime;    /* system time */
        clock_t tms_cutime;    /* user time of children */
        clock_t tms_cstime;    /* system time of children */
    };

    Yapının tms_utime elemanı prosesin user mode'da harcadığı zamanı, tms_stime elemanı kernel mode'da harcadığı zamanı vermektedir. 
    tms_cutime elemanı wait fonksiyonlarıyla beklenen tüm alt proseslerin (ve onların alt proseslerinin de) user mode'daki zamanlarını
    tms_cstime da wait fonksiyonu ile beklenen tüm alt proseslerin (ve onların alt proseslerinin de) kernel mode'daki zamanlarını 
    vermektedir. Fonksiyonun verdiği zamanlar proses kontrol bloktan alınmaktadır. Proses kontrol bloğa da zamanlar "timer tick" 
    olarak yazılmaktadır. Timer tick değerleri günümüzün masaüstü sistemlerinde 1 milisaniye, yavaş sistemlerde 10 milisaniye 
    periyottadır. Bu fonksiyon prosesin bloke olup uykuda beklediği zamanları bize herhangi bir biçimde vermemektedir. Yalnızca
    prosesin ve alt proseslerin user mode'da ve kernel mode'da harcadığı zamanları bize vermektedir.

    Standard time kabuk komutu bu fonksiyon ve muhtemelen clock_gettime fonksiyonu kullanılarak gerçekleştirilmiştir.

    Aşağıdaki örnekte komut satırından alınan program çalıştırılmış ve onun user ve kernel mode'daki zamanı yazdırılmıştır. 
    Ancak programın çalışması için gereken gerçek zaman yazdırılmamıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/wait.h>
#include <time.h>
#include <sys/times.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    struct tms tms;
    pid_t pid;

    if (argc < 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0 && execvp(argv[1], &argv[1]) == -1)
        _exit(EXIT_FAILURE);

    if (wait(NULL) == -1)
        exit_sys("wait");

    if (times(&tms) == -1)
        exit_sys("times");

    printf("User time: %f\n", (double)tms.tms_cutime / CLOCKS_PER_SEC);
    printf("Kernel time: %f\n", (double)tms.tms_cstime / CLOCKS_PER_SEC);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bazen belli periyotta sürekli işlemlerin yapılması gerekebilmektedir. Örneğin ekrana canlı bir saat çıkartmak istediğimizi 
    düşünelim. Saatimizin duyarlılığı da saniye cinsinden olsun. Biz saniyede bir periyodik olarak bir fonksiyonumuzun çağrılmasını
    sağlarsak bu işlemi kolaylıkla yapabiliriz. Bu tür periyodik timer mekanizmalarına "interval timer" da denilmektedir. 
    POSIX standartlarında "interval timer" oluşturmak için iki fonksiyon bulundurulmuştur.

    Şüphesiz interval timer oluşturmanın basit bir yolu bir thread yaratmak ve o thread içerisinde bir döngü oluşturup 
    clock_nanosleep gibi bir fonksiyonla bekleme yapmak olabilir. Ancak bunun için bir thread'e gereksinim duyulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Interval timer setitimer isimli POSIX fonksiyonu ile basit bir biçimde oluşturulabilmektedir. Ancak POSIX standartlarına 
    izleyen paragraflarda ele alacağımız daha yetenekli bir "interval timer" mekanizması eklendiği için bu fonksiyon "obsolete"
    yani "deprecated" yapılmıştır. Fonksiyonun prototipi şöyledir:

    #include <sys/time.h>

    int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);

    setitimer fonksiyonunda periyodik işleme başlamak için gereken zaman ile periyot zamanı fonksiyona ayrı ayrı verilmektedir. 
    setitimer fonksiyonu ile oluşturulan "interval timer" mekanizmasının türleri vardır. Her tür, zaman dolduğunda farklı bir 
    sinyalin oluşmasına yol açmaktadır. Fonksiyonun birinci parametresi interval timer'ın türünü belirtmektedir. Bu tür 
    şunlardan biri olabilir:

    ITIMER_REAL: Bu gerçek zamana dayalı ölçüm yapar. Zaman dolduğunda SIGALRM sinyali gönderilmektedir.

    ITIMER_VIRTUAL: Buradaki ölçüm prosesin çalışmasına göre yapılmaktadır. Yani proses çalışmadığı sürece saat artmamaktadır. 
    Bu türde zaman dolduğunda SIGVTALRM sinyali gönderilmektedir.

    ITIMER_PROF: Burada ölçüm yine prosesin çalışmasına göre yapılmaktadır. Ancak bekleme zamanları da buna dahil edilmektedir. 
    Zaman dolduğunda SIGPROF sinyali gönderilmektedir.

    Fonksiyonun ikinci parametresi itimerval isimli bir yapı türündendir. Bu yapı şöyle bildirilmiştir:

    struct itimerval {
        struct timeval it_interval;        /* next value */
        struct timeval it_value;        /* current value */
    };

    Yapının elemanlarının struct timeval türünden olduğuna dikkat ediniz. Bu yapı da şöyle bildirilmiştir:

    struct timeval {
        time_t      tv_sec;            /* seconds */
        suseconds_t tv_usec;        /* microseconds */
    };

    itimerval yapısının it_value elemanı ilk periyoda kadar geçen zamanı, it_interval elemanı da periyodik zamanı belirtmektedir. 
    Fonksiyonun üçüncü parametresi bir önceki itimer çağrısında set edilen değerin elde edilmesi için kullanılmaktadır. Bu
    parametre NULL geçilebilir. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    setitemer ile oluşturulan interval timer'ın disable hale getirilmesi için fonksiyonun ikinci parametresindeki yapının 
    it_value elemanı sıfırlanarak çağrılması gerekmektedir.

    Aşağıdaki örnekte interval timer ilk periyoda kadar 5 saniye bekleyecek biçimde oluşturulmuştur. Timer periyodu da 
    1 saniye olarak ayarlanmıştır. 10 kere sinyal oluşturulduktan sonra interval timer disable edilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <sys/time.h>

int g_count;

void sigalrm_handler(int signo);
void exit_sys(const char *msg);

int main(void)
{
    struct sigaction sa;
    struct itimerval itval;

    sa.sa_handler = sigalrm_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGALRM, &sa, NULL) == -1)
        exit_sys("sigaction");

    itval.it_value.tv_sec = 5;
    itval.it_value.tv_usec = 0;

    itval.it_interval.tv_sec = 1;
    itval.it_interval.tv_usec = 0;

    if (setitimer(ITIMER_REAL, &itval, NULL) == -1)
        exit_sys("setitimer");

    for (;;) {
        pause();
        ++g_count;
        if (g_count == 10) {
            itval.it_value.tv_sec = 0;
            itval.it_value.tv_usec = 0;

            if (setitimer(ITIMER_REAL, &itval, NULL) == -1)
                exit_sys("setitimer");
            break;
        }
    }

    printf("timer disabled, sleeps for extra 5 seconds before finish...\n");
    sleep(5);

    return 0;
}

void sigalrm_handler(int signo)
{
    printf("interval timer...\n");        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                84. Ders 24/09/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Periyodik timer oluşturabilmek için kullanılan setitimer fonksiyonunun bazı yetersizlikleri şunlardır:

    - Haberdar etme mekanizması yalnızca sinyalle yapılmaktadır.
    - Kullanılan sinyal gerçek zamanlı olmayan sinyallerdir. Bunların da biriktirilmesi söz konusu değildir.
    - Sinyal oluştuğunda sinyal gerçek zamanlı olmadığı için sinyale iliştirilecek bir bilgi de yoktur.
    - Thread yoluyla haberdar edilme mekanizması yoktur.
    - Zaman duyarlılığı mikrosaniye mertebesindedir.

    İşte bu eksikliklerden dolayı POSIX'e yeni bir interval timer mekanizması eklenmiştir. Bu interval timer mekanizmasının 
    kullanılması setitimer mekanizmasına göre daha zordur. Bu yeni mekanizmada ilk yapılacak şey bir interval timer nesnesinin
    timer_create fonksiyonu ile yaratılmasıdır. timer_create fonksiyonunun prototipi şöyledir:

    #include <time.h>

    int timer_create(clockid_t clockid, struct sigevent *evp, timer_t *timerid);

    Fonksiyonun birinci parametresi zamanlamada kullanılacak saatin türünü belirtmektedir. Bu tür daha önce gördüğümüz CLOCK_MONOTONIC,
    CLOCK_REALTIME, CLOCK_PROCESS_CPUTIME_ID, CLOCK_THREAD_CPUTIME_ID olabileceği gibi clock_getcpuclockid ve pthread_getcpuclockid
    fonksiyonlarından elde edilen clock id'ler kullanılabilmektedir. Fonksiyonun ikinci parametresi sigevent isimli bir yapı 
    nesnesinin adresini almaktadır. sigevent yapısı şöyle bildirilmiştir:

    #include <signal.h>

    union sigval {                /* Data passed with notification */
        int     sival_int;        /* Integer value */
        void   *sival_ptr;        /* Pointer value */
    };

    struct sigevent {
        int    sigev_notify;                            /* Notification method */
        int    sigev_signo;                                /* Notification signal */
        union  sigval sigev_value;                        /* Data passed with notification */
        void  (*sigev_notify_function)(union sigval);    /* Function used for thread notification (SIGEV_THREAD) */
        void   *sigev_notify_attributes;                /* Attributes for notification thread (SIGEV_THREAD) */
        pid_t  sigev_notify_thread_id;                    /* ID of thread to signal (SIGEV_THREAD_ID); Linux-specific */
    };

    Yapının sigev_notify elemanı periyot dolduğunda haberdar edilmenin nasıl yapılacağını belirtmektedir. Bu elemana şu değerlerden
    biri yerleştirilebilir:

    SIGEV_NONE: Haberdar edilme yapılmaz.

    SIGEV_SIGNAL: Haberdar edilme sinyal yoluyla yapılır.

    SIGEV_THREAD: Haberdar edilme bu mekanizma tarafından yaratılan bir thread tarafından yapılır.

    SIGEV_THREAD_ID: Haberdar edilme prosesin spesifik bir thread'i ile sinyal yoluyla yapılmaktadır. (Bu yöntem POSIX 
    standartlarında yoktur, dolayısıyla Linux'a özgüdür.)

    Yapının sigev_signo elemanı eğer haberdar edilme sinyal yoluyla yapılacaksa oluşturulacak sinyalin numarasını almaktadır.
    Bu sinyal numarası normal bir sinyal olabileceği gibi gerçek zamanlı bir sinyal de olabilmektedir. Yapının sigev_value 
    elemanı gerçek zamanlı sinyallerde sinyale iliştirilecek bilgiyi belirtmektedir. Bu aynı zamanda thread yoluyla haberdar 
    edilmede de kullanılmaktadır. Yapının sigev_notify_function elemanı eğer haberdar edilme thread yoluyla yapılacaksa haberdar
    edecek thread'in çağıracağı fonksiyonu belirtmektedir. Yapının sigev_notify_attributes elemanı ise yaratılacak thread'in 
    özellik bilgilerini belirtmektedir. Bu elemana NULL adres geçilebilir. Yapının sigev_notify_thread_id elemanı Linux'a özgüdür. 
    Eğer birinci parametreye Linux'a özgü olan SIGEV_THREAD_ID değeri geçilirse bu elemana da thread'in pid değeri girilmelidir. 
    Aslında fonksiyonun ikinci parametresi NULL adres de geçilebilmektedir. Bu durumda haberdar edilme SIGALRM sinyali yoluyla
    yapılmaktadır. (Aslında POSIX standartları bu durumda sinyalin SIGALRM olduğunu açıkça belirtmemiştir, "default signal" ifadesini
    kullanmıştır. Bu "default signal" Linux sistemlerinde SIGABRT sinyalidir.)

    timer_create fonksiyonunun son parametresi yaratılan interval timer'ın id'sinin yerleştirileceği timer_t türünden nesnenin
    adresini almaktadır. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Örneğin:

    struct sigaction sa;
    struct sigevent se;
    timer_t itimer;

    sa.sa_sigaction = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART|SA_SIGINFO;

    if (sigaction(SIGRTMIN, &sa, NULL) == -1)
        exit_sys("sigaction");

    se.sigev_notify = SIGEV_SIGNAL;
    se.sigev_signo = SIGRTMIN;
    se.sigev_value.sival_int = 100;

    if (timer_create(CLOCK_MONOTONIC, &se, &itimer) == -1)
        exit_sys("timer_create");

    Interval timer nesnesi yaratıldıktan sonra artık periyot timer_settime fonksiyonu ile belirlenmelidir. Fonksiyonun prototipi
    şöyledir:

    #include <time.h>

    int timer_settime(timer_t timerid, int flags, const struct itimerspec *new_value, struct itimerspec *old_value);

    Fonksiyonun birinci parametresi timer_create fonksiyonundan elde edilen "timer id" değeridir. İkinci parametre 0 ya da 
    TIMER_ABSTIME biçiminde geçilebilir. Bu parametre 0 geçilirse "göreli zaman", TIMER_ABSTIME geçilirse mutlak zaman 
    dikkate alınır. Programcılar hemen her zaman göreli zaman kullanırlar. Fonksiyonun üçüncü parametresi ilk haberdar 
    edilmenin ve periyodik haberdar edilmenin zamanlamasının ayarlandığı itimerspec isimli yapı nesnesinin adresini almaktadır. 
    Bu yapı programcı tarafından doldurulup fonksiyona verilmelidir. Yapı şöyle bildirilmiştir:

    #include <time.h>

    struct itimerspec {
        struct timespec it_interval;    /* Interval for periodic timer */
        struct timespec it_value;        /* Initial expiration */
    };

    Yapının it_value elemanı ilk haberdar edilmeye kadar geçecek zamanı, it_interval elemanı haberdar edilme periyodunu 
    belirtmektedir. Anımsanacağı gibi timespec yapısı da şöyle bildirilmiştir:

    struct timespec {
        time_t tv_sec;        /* Seconds */
        long tv_nsec;        /* Nanoseconds [0, 999'999'999] */
    };

    Fonksiyonun son parametresi eski değerlerin yerleştirileceği yapı nesnesinin adresini almaktadır. Bu parametre NULL 
    geçilebilir. Ya da ikinci parametre NULL geçilip eski değerler de alınabilir.

    timer_settime fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Örneğin:

    if (timer_create(CLOCK_MONOTONIC, &se, &itimer) == -1)
        exit_sys("timer_create");

    ts.it_value.tv_sec = 5;
    ts.it_value.tv_nsec = 0;

    ts.it_interval.tv_sec = 1;
    ts.it_interval.tv_nsec = 0;

    if (timer_settime(itimer, 0, &ts, NULL) == -1)
        exit_sys("timer_settime");

    Interval timer ile işimiz bitince onu timer_delete fonksiyonu ile yok etmemiz gerekir. Fonksiyonun prototipi şöyledir:

    #include <time.h>

    int timer_delete(timer_t timerid);

    Fonksiyon parametre olarak timer_create fonksiyonundan elde edilen timer id değerini almaktadır. Başarı durumunda 0 değerine, 
    başarısızlık durumunda -1 değerine geri döner. Başarısının kontrol edilmesine normal olarak gerek yoktur. Örneğin:

    timer_delete(itimer);

    Aşağıda POSIX modern interval timer mekanizmasını sinyal yoluyla haberdar etmeye bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>
#include <unistd.h>
#include <signal.h>
#include <time.h>

void signal_handler(int signo, siginfo_t *info, void *context);
void exit_sys(const char *msg);

jmp_buf g_jb;
int g_count;

int main(void)
{
    struct sigaction sa;
    struct sigevent se;
    timer_t itimer;
    struct itimerspec ts;

    sa.sa_sigaction = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART|SA_SIGINFO;

    if (sigaction(SIGRTMIN, &sa, NULL) == -1)
        exit_sys("sigaction");

    se.sigev_notify = SIGEV_SIGNAL;
    se.sigev_signo = SIGRTMIN;
    se.sigev_value.sival_int = 100;

    if (timer_create(CLOCK_MONOTONIC, &se, &itimer) == -1)
        exit_sys("timer_create");

    ts.it_value.tv_sec = 5;
    ts.it_value.tv_nsec = 0;

    ts.it_interval.tv_sec = 1;
    ts.it_interval.tv_nsec = 0;

    if (timer_settime(itimer, 0, &ts, NULL) == -1)
        exit_sys("timer_settime");

    for (;;) {
        if (setjmp(g_jb) == 1)
            break;
        pause();
        ++g_count;
    }

    timer_delete(itimer);

    return 0;
}

void signal_handler(int signo, siginfo_t *info, void *context)
{
    if (g_count == 10)
        longjmp(g_jb, 1);

    printf("interval timer code %d\n", info->si_int);        /* UNSAFE */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de thread yoluyla haberdar edilmeye bir örnek verelim. Bu yöntemde thread bu mekanizma tarafından yaratılıp bizim
    fonksiyonumuz çağrılmaktadır. Burada yaratılacak olan thread'in toplamda bir tane mi olacağı yoksa her periyot için ayrı 
    bir thread'in yeniden mi yaratılacağı POSIX standartlarında işletim sistemini yazanların isteğine bırakılmıştır. Linux 
    tek bir thread yaratıp tüm periyotlarda aynı thread'i kullanmaktadır. Bu durumda çağrılacak callback fonksiyonun sigevent 
    yapısının sigev_notify_function elemanına girilmesi gerekmektedir. Fonksiyonun parametrik yapısı şöyle olmalıdır:

    void notification_proc(union sigval);

    Örneğin:

    struct sigevent se;
    timer_t itimer;
    struct itimerspec ts;

    se.sigev_notify = SIGEV_THREAD;
    se.sigev_notify_function = notification_proc;
    se.sigev_notify_attributes = NULL;
    se.sigev_value.sival_int = 100;

    if (timer_create(CLOCK_MONOTONIC, &se, &itimer) == -1)
        exit_sys("timer_create");

    ts.it_value.tv_sec = 5;
    ts.it_value.tv_nsec = 0;

    ts.it_interval.tv_sec = 1;
    ts.it_interval.tv_nsec = 0;

    if (timer_settime(itimer, 0, &ts, NULL) == -1)
        exit_sys("timer_settime");

    Aşağıda thread yaratılarak haberdar edilmeye bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>
#include <unistd.h>
#include <signal.h>
#include <time.h>

void notification_proc(union sigval sval);
void exit_sys(const char *msg);

int main(void)
{
    struct sigevent se;
    timer_t itimer;
    struct itimerspec ts;

    se.sigev_notify = SIGEV_THREAD;
    se.sigev_notify_function = notification_proc;
    se.sigev_notify_attributes = NULL;
    se.sigev_value.sival_int = 100;

    if (timer_create(CLOCK_MONOTONIC, &se, &itimer) == -1)
        exit_sys("timer_create");

    ts.it_value.tv_sec = 5;
    ts.it_value.tv_nsec = 0;

    ts.it_interval.tv_sec = 1;
    ts.it_interval.tv_nsec = 0;

    if (timer_settime(itimer, 0, &ts, NULL) == -1)
        exit_sys("timer_settime");

    printf("Press ENTER to exit...\n");
    getchar();

    timer_delete(itimer);

    return 0;
}

void notification_proc(union sigval sval)
{
    printf("interval timer code %d\n", sval.sival_int);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz sinyal yoluyla haberdar edilirken gerçek zamanlı bir sinyal kullanmamışsak bir biriktirme yapılmadığı için ilgili 
    sinyal bloke edildiğinde ondan kaç periyot geçtiğini anlayamayız. İşte bunu anlayabilmek için POSIX interval mekanizmasında 
    timer_getoverrun fonksiyonu bulundurulmuştur. Fonksiyonun prototipi şöyledir:

    #include <time.h>

    int timer_getoverrun(timer_t timerid);

    Fonksiyon bize sinyal bloke edildiğinde kaç kez periyot geçtiğini vermektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX türevi sistemlerde çok sayıda sistemden sisteme değişebilecek parametrik değer vardır. Örneğin bir yol ifadesinin 
    maksimum uzunluğu, bir prosesin açık durumda tutabileceği maksimum dosya sayısı (yani dosya betimleyici tablosunun büyüklüğü), 
    bir kullanıcının yaratabileceği alt proseslerin sayısı, exec fonksiyonuna geçirilecek komut satırı argümanlarının sayısı, 
    ek grupların (supplementary groups) sayısı (bu konu ileride ele alınmaktadır) gibi pek çok parametrik değer sistemden sisteme 
    değişebilmektedir. Halbuki taşınabilir programlar oluşturabilmek için bu parametrik değerlerin o anda programın çalıştığı 
    sistemde biliniyor olması gerekebilmektedir.

    Genel olarak sistemdeki parametrik değerler <limits.h> dosyası içerisinde sembolik sabitler biçiminde define edilmiştir. 
    (C standartlarında da bir <limits.h> dosyası vardır, ama POSIX limits.h dosyası çok daha geniş kapsamlıdır.) <limits.h> 
    dosyası içerisindeki sembolik sabitler POSIX standartlarında şu gruplara ayrılmıştır:

    - Runtime Invariant Values (Possibly Indeterminate)
    - Pathname Variable Values
    - Runtime Increasable Values
    - Maximum Values
    - Minimum Values
    - Numerical Limits (C standartlarında da var)
    - Other Invariant Values

    POSIX standartları bazı parametrik değerlerin POSIX uyumlu sistemler için olabilecek en küçük değerlerini "Minimum Values"
    kategorisi içerisinde define etmiştir. Buradaki sembolik sabitlerin hepsi _POSIX_ öneki başlatılmıştır ve genellikle sonunda 
    MAX soneki bulunmaktadır. Yani bu sembolik sabitlerin isimleri tipik olarak _POSIX_XXX_MAX biçimindedir. Her ne kadar sembolik 
    sabit isminde MAX soneki kullanılmışsa da aslında bu değerler her POSIX uyumlu sistemin destekleyeceği minimum değerlerdir. 
    Bu minimum değerlerin hepsi açıkça POSIX standartlarında belirtilmiştir. Örneğin bir prosesin açık durumda tutabileceği dosya 
    sayısı (yani dosya betimleyici tablosunun uzunluğu) _POSIX_OPEN_MAX sembolik sabitiyle belirtilmiştir ve bunun değeri 20'dir. 
    Yine örneğin bir kullanıcının yaratabileceği maksimum alt proses sayısı _POSIX_CHILD_MAX sembolik sabitiyle belirtilmiştir ve
    bunun değeri de 25'tir. Buradaki isimsel karışıklığa dikkat ediniz. _POSIX_CHILD_MAX sembolik sabiti bir kullanıcının yaratabileceği
    maksimum alt proses sayısına ilişkindir. Ancak bu sembolik sabitin değeri POSIX uyumlu sistemdeki olabilecek minimum değerdir. 
    Örneğin _POSIX_ARG_MAX sembolik sabiti exec fonksiyonlarında girilebilecek maksimum argüman ve çevre değişkenlerinin byte uzunluğu 
    ile ilgilidir. Ancak bu sembolik sabit POSIX uyumlu bir sistemdeki minimal değeri belirtmektedir ve 4096 olarak belirlenmiştir. 
    Başka bir deyişle bir POSIX uyumlu bir işletim sistemi yazacaksak bir kullanıcının yaratabileceği maksimum alt proses sayısının 
    en az 25 olmasını, exec fonksiyonuna girilebilecek maksimum argüman sayısının ve çevre değişkeni sayısının en az 4096 olmasını 
    sağlamalıyız.

    POSIX tarafından belirlenen ve _POSIX_XXX_MAX biçiminde <limits.h> içerisinde define edilmiş olan minimum değerler aslında
    çok küçük değerlerdir. Örneğin _POSIX_NAME_MAX bir dosyanın karakter uzunluğunu belirtir. Bunun minimum değeri 14'tür. Halbuki 
    yaygın hiçbir sistem 14 karakterden çok daha fazla dosya isimlerini desteklemektedir. Benzer biçimde bir kullanıcının maksimum 
    yaratacağı alt proses sayısının 25 olması da çok düşük bir değerdir. İşte bu sembolik sabitler tüm POSIX sistemlerindeki 
    olabilecek en küçük değerleri belirtmektedir, ancak modern sistemler dikkate alındığında bir kullanımı yoktur. O halde 
    programcının POSIX standartlarının desteklediği en küçük değere değil, o sistemdeki mevcut değere ihtiyacı vardır.

    <limits.h> dosyası içerisinde "Runtime Invariant Values (Possibly Indeterminate)" kategorisi bazı _POSIX_XXX_MAX değerlerinin 
    ilgili sistemdeki gerçek değerlerini belirtmektedir. Bu gerçek değerler <limits.h> içerisinde başında _POSIX_ öneki olmadan 
    bildirilmiştir. Örneğin _POSIX_CHILD_MAX minimum değerinin ilgili sistemdeki gerçek değeri CHILD_MAX sembolik sabitiyle,
    _POSIX_OPEN_MAX minimum değerinin ilgili sistemdeki gerçek değeri OPEN_MAX sembolik sabitiyle bildirilmiştir. Böylece 
    <limits.h> içerisinde hem POSIX sistemlerindeki minimum değerler hem de ilgili sistemdeki gerçek değerler define edilmiş 
    durumdadır. Ancak burada da önemli bir pürüz vardır. Bazı parametrik değerler sistemin çalışması sırasında değiştirilebilmektedir 
    ya da bazı parametrik değerler o andaki sistem kaynaklarının miktarıyla ilgilidir. Bu durumda bu parametrelerin ilgili 
    sistemdeki değerleri baştan tespit edilememektedir. Ayrıca bazı parametrelerin ilgili sistemde bir sınırı da olmayabilir. 
    İşte POSIX standartları "Runtime Invariant Values (Possibly Indeterminate)" başlığı altında "eğer bir parametrik değer 
    sistem çalışırken değiştirilebiliyorsa ya da onun bir sınırı yoksa" ona ilişkin sembolik sabitin <limits.h> içerisinde define 
    edilmemesi gerektiğini belirtmektedir. Yani aslında OPEN_MAX gibi, ARG_MAX gibi, CHILD_MAX gibi sembolik sabitler <limits.h> 
    içerisinde define edilmemiş de olabilirler. Yani bu parametrelere ilişkin sembolik sabitler ancak define edilmişse 
    kullanılabilmektedir. Pekiyi bir sembolik sabitin define edilip edilmeyeceği belirsizse biz bundan faydalanabilir miyiz? 
    İşte POSIX standartlarının örtük bir biçimde önerdiği yöntem şudur: Eğer bir parametrik değer <limits.h> içerisinde define 
    edilmişse programcı onu doğrudan derleme zamanında kullanabilir. Ancak define edilmemişse o anki gerçek değer programın 
    çalışma zamanı sırasında sysconf, pathconf ve fpathconf fonksiyonlarıyla elde edilmelidir. (Tabii hiç sembolik sabite 
    bakılmadan doğrudan bu fonksiyonlar da çağrılabilir. Yalnızca fonksiyon çağırma maliyeti bir dezavantaj oluşturmaktadır.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                85. Ders 30/09/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    <limits.h> içerisindeki diğer bir grup da "Pathname Variable Values" isimli gruptur. Bu başlık altında belirtilen 
    sembolik sabitlerin değerleri o anda kullanılan dosya sistemine bağlı olarak değişebilmektedir. UNIX/Linux sistemlerinde 
    farklı dosya sistemleri farklı noktalara mount edilebilmektedir. Bu farklı dosya sistemlerinin isim uzunlukları gibi 
    özellikleri de birbirinden farklı olabilmektedir. İşte bu tür büyüklükler <limits.h> içerisinde "Pathname Variable Values"
    başlığı altında toplanmıştır. Bu gruptaki en önemli sembolik sabitler NAME_MAX ve PATH_MAX sembolik sabitleridir. NAME_MAX 
    bir dizin girişinin isminin olabilecek maksimum karakter sayısını belirtmektedir. PATH_MAX ise toplamda mutlak bir yol 
    ifadesinin olabileceği en fazla karakter sayısını belirtir. Bir dosya isminin ya da bir yol isminin bir yerde saklanacağı 
    durumlarda saklanacak yerin büyüklüğünün belirlenmesi için bu değerlere gereksinim duyulmaktadır. Yukarıda da belirttiğimiz 
    gibi bu değerler dosya sisteminden sistemine değişebilecek değerlerdir. İşte POSIX standartları eğer bu değerler tüm dizin 
    ağacı içerisinde sabit ise bu sembolik sabitlerin define edilmesi, ancak sabit değilse define edilmemesi gerektiğini 
    belirtmektedir. Yani örneğin PATH_MAX sembolik sabiti bir UNIX türevi sistemde define edilmişken başka bir sistemde edilmemiş 
    olabilir. İşte "Pathname Variable Values" grubundaki sembolik sabitler eğer <limits.h> içerisinde define edilmemişse bu 
    durumda onların değerleri pathconf ya da fpathconf POSIX fonksiyonuyla alınmalıdır.

    <limits.h> içerisindeki "Runtime Increasable Values" grubundaki sembolik sabitler sistemden sisteme değişebilir ve işletiminin
    çalışma zamanı sırasında artırılabilir. Bu sembolik sabitlerin ilgili sistemdeki minimum değerleri bu başlık altında define 
    edilmek zorundadır. Anımsanacağı gibi bazı sembolik sabitlerin tüm POSIX sistemleri genelindeki minimum değerleri _POSIX_XXX
    biçiminde "Minimum Values" grubunda belirtilmiştir. Özetle "Runtime Increasable Values" grubundaki değerler o sistemdeki
    minimum değerler olarak kullanılabilir. Ancak bunların gerçek değerleri programın çalışma zamanı sırasında sysconf fonksiyonu
    ile elde edilmelidir.

    <limits.h> içerisindeki "Numeric Limits" grubundaki sembolik sabitler aslında C'nin <limits.h> dosyası içerisinde de bulunmaktadır. 
    Bu sembolik sabitler temel türlerin o sistemdeki maksimum ve minimum değerlerini belirtmektedir. Örneğin INT_MIN int türünün 
    o sistemdeki minimum değerini, INT_MAX ise maksimum değerini belirtir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    sysconf fonksiyonu yukarıda da belirttiğimiz gibi "Runtime Invariant Values" ve "untime Increasable Values" grubundaki 
    büyüklüklerin programın çalışma zamanı sırasında elde edilmesinde kullanılmaktadır. Tabii "Runtime Invariant Values" 
    grubundaki sembolik sabitler eğer define edilmişse bu fonksiyonu çağırmaya gerek yoktur. Doğrudan o sembolik sabitlerin 
    değeri programcı tarafından kullanılabilir. sysconf fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    long sysconf(int name);

    Fonksiyon parametre olarak hangi büyüklüğün değerinin elde edilmek istendiğini almaktadır. Bu değerler _SC_XXX biçiminde 
    define edilmiştir. Bu sembolik sabitlerin oluşturulmasındaki kurala dikkat ediniz: POSIX'teki minimum değerler _POSIX_XXX
    biçiminde, o sistemdeki değerler XXX biçiminde, sysconf fonksiyonun parametreleri ise _SC_XXX biçiminde isimlendirilmiştir. 
    Örneğin dosya betimleyici tablosunun POSIX'teki minimum uzunluğu _POSIX_OPEN_MAX sembolik sabitiyle, ilgili sistemdeki uzunluğu
    OPEN_MAX sembolik sabitiyle, sysconf fonksiyonundaki parametre ismi ise _SC_OPEN_MAX ismiyle define edilmiştir.

    sysconf fonksiyonu başarı durumunda ilgili büyüklüğe, başarısızlık durumunda -1 değerine geri dönmektedir. sysconf ile 
    elde edilmek istenen büyüklük belirli olmayabilir ve sınırsız (infinite) da olabilir. Bu durumda fonksiyon başarısız 
    olur. Ancak errno, değer değiştirmez. (Yani bu durumu belirlemek için errno değişkenine sysconf fonksiyonunu çağırmadan önce 0 
    değeri yerleştirilir. Sonra fonksiyon başarısız olduğunda errno değişkenine bakılır. Eğer hala 0 değeri duruyorsa ilgili 
    büyüklüğün belirsiz ya da sınırsız olduğu sonucu çıkartılır.)

    Örneğin dosya betimleyici tablosunun uzunluğunu (yani açılacak maksimum dosya sayısını) sysconf fonksiyonu ile şöyle elde 
    edebiliriz:

    errno = 0;
    if ((result = sysconf(_SC_OPEN_MAX)) == -1)
        if (errno == 0)
            fprintf(stderr, "infinite value...\n");
        else
            exit_sys("sysconf");
    else
        printf("%ld\n", result);
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#include <errno.h>

void exit_sys(const char *msg);

int main(void)
{
    long result;

    errno = 0;
    if ((result = sysconf(_SC_OPEN_MAX)) == -1)
        if (errno == 0)
            fprintf(stderr, "infinite value...\n");
        else
            exit_sys("sysconf");
    else
        printf("%ld\n", result);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi <limits.h> içerisindeki "Pathname Variable Values" grubunda bulunan sembolik sabitler eğer
    ilgili sistemde define edilmemişse bunların değerleri pathconf ya da fpathconf fonksiyonlarıyla elde edilmelidir. Bu 
    fonksiyonların prototipleri şöyledir:

    #include <unistd.h>

    long fpathconf(int fildes, int name);
    long pathconf(const char *path, int name);

    Fonksiyonların ikinci parametreleri değeri elde edilecek büyüklüğü belirtmektedir. Büyüklüğün POSIX sistemlerindeki minimum 
    değeri _POSIX_XXX, ilgili sistemdeki değeri XXX olmak üzere buradaki büyüklük isimleri _PC_XXX biçiminde isimlendirilmiştir. 
    Örneğin bir dosyanın maksimum karakter uzunluğunun POSIX'teki minimum değeri _POSIX_NAME_MAX biçimindedir. İlgili sistemdeki
    değeri NAME_MAX biçiminde pathconf ve fpathconf fonksiyonlarındaki isimleri ise _PC_NAME_MAX biçimindedir. path fonksiyonu
    yol ifadesiyle çalışırken, fpathconf fonksiyonu açık dosya betimleyicisi ile çalışmaktadır. Bazı büyüklükler için bu yol 
    ifadesinin ya da betimleyicinin dizine ilişkin olması gerekir.

    Fonksiyon başarı durumunda ilgili büyüklük değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Eğer ilgili 
    büyüklüğün o sistemde belli bir sınırı yoksa fonksiyonlar başarısız olmakta ancak errno değerini değiştirmemektedir.

    Biz yukarıda genel olarak açıklamış olsak da belli büyüklüklerin değerlerini elde ederken ayrıntılar için POSIX dokümanlarına 
    başvurmanızı tavsiye ederiz. Örneğin _PC_NAME_MAX ve _PC_PATH_MAX değerlerini elde etmek için yol ifadesinin ya da betimleyicinin 
    bir dizine ilişkin olması gerekmektedir. Aksi takdirde fonksiyonun çalışması sistemden sisteme değişebilmektedir. Ayrıca örneğin 
    _PC_PATH_MAX ile verilen uzunluk o dizine göreli uzunluktur. Yani bu uzunluğa o dizine kadarki karakter uzunluğu da eklenmelidir. 
    Ayrıca örneğin NAME_MAX sembolik sabitiyle ya da _PC_NAME_MAX ismiyle elde edilen uzunluğa null karakter dahil değildir. 
    Halbuki PATH_MAX ya da _PC_PATH_MAX ile elde edilen uzunluğa null karakter dahildir. Örneğin PATH_MAX değerini pathconf 
    fonksiyonu ile şöyle elde edebiliriz:

    long result;

    errno = 0;
    if ((result = pathconf("/", _PC_PATH_MAX)) == -1)
        if (errno == 0)
            fprintf(stderr, "infinite value...\n");
        else
            exit_sys("pathmax");
    else
        printf("%ld\n", result);

    Biz burada kök dizinden itibaren (yani kök dizine göreli biçimde) yol ifadesinin uzunluğunu elde ettik. Dolayısıyla mutlak 
    yol ifadesi için gereken karakter sayısı burada elde edilenden 1 fazla olmalıdır. Çünkü bu fonksiyonların verdikleri değer
    bizim onlara geçtiğimiz dizine görelidir. Tabii Linux sistemlerinde NAME_MAX ve PATH_MAX sembolik sabitleri zaten define 
    edilmiştir. Dolayısıyla aslında Linux sistemlerinde bu fonksiyonların bu amaçla çağrılmasına gerek yoktur. Yani yazacağınız
    kod yalnızca Linux sistemlerinde kullanılacaksa zaten siz NAME_MAX ve PATH_MAX sembolik sabitlerini doğrudan kullanabilirsiniz. 
    Ancak taşınabilir programlar için bu fonksiyonlara gereksinim duyulabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#include <errno.h>

void exit_sys(const char *msg);

int main(void)
{
    long result;

    errno = 0;
    if ((result = pathconf("/", _PC_PATH_MAX)) == -1)
        if (errno == 0)
            fprintf(stderr, "infinite value...\n");
        else
            exit_sys("pathmax");
    else
        printf("%ld\n", result);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bazı büyüklüklere ilişkin değerler ilgili sistemde define edilmeyebileceğine göre taşınabilir programlar için nasıl 
    bir yol izlenmelidir? Tabii yöntemlerden biri her zaman sysconf ya da pathcnf, fpathconf fonksiyonlarını çağırmak olabilir. 
    Ancak ilgili sembolik sabitler o sistemde define edilmişse bu çağrı gereksiz zaman kaybına yol açacaktır. Taşınabilirliği 
    sağlamak için Stevens "Advanced Programming in the UNIX Environment" kitabında aşağıdaki gibi bir yöntem önermektedir:

    #define PATH_MAX_GUESS        4096

    #ifdef MAX_PATH
        static long g_max_path = MAX_PATH;
    #else
        static long g_max_path = 0;
    #endif

    long path_max(void)
    {
        if (!g_max_path) {
            errno = 0;
            if ((g_max_path = pathconf("/", _PC_PATH_MAX)) == -1)
                if (errno == 0)
                    g_max_path = PATH_MAX_GUESS;
                else
                    exit_sys("pathmax");
            else
                ++g_max_path;
        }

        return g_max_path;
    }

    Burada path_max fonksiyonu toplamda sıfır kere ya da en fazla bir kere pathconf fonksiyonunu çağırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#include <errno.h>

void exit_sys(const char *msg);

#define PATH_MAX_GUESS        4096

#ifdef MAX_PATH
    static long g_max_path = MAX_PATH;
#else
    static long g_max_path = 0;
#endif

long path_max(void)
{
    if (!g_max_path) {
        errno = 0;
        if ((g_max_path = pathconf("/", _PC_PATH_MAX)) == -1)
            if (errno == 0)
                g_max_path = PATH_MAX_GUESS;
            else
                exit_sys("pathmax");
        else
            ++g_max_path;
    }

    return g_max_path;
}

int main(void)
{
    char *path;

    if ((path = (char *)malloc(path_max())) == NULL) {
        fprintf(stderr, "cannot allocate memory!...\n");
        exit(EXIT_FAILURE);
    }

    free(path);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sistemini bir kaynak yöneticisi olarak da düşünebiliriz. Prosesler işletim sisteminin sunduğu çeşitli kaynakları 
    kullanmaktadır. Tabii işletim sistemleri proseslerin kaynak kullanımlarını sınırlandırmaktadır. Aksi takdirde bir proses
    çok fazla kaynak kullanıp diğer proseslerin o kaynağa erişimini güçleştirebilir. Prosesin kaynak limitleri (yani kaynakları 
    hangi sınırlar içerisinde kullanabileceği) proses kontrol bloğu içerisinde saklanmaktadır. (Linux'ta bu bilgi task_struct 
    yapısının signal elemanının gösterdiği struct signal yapısının içerisindeki struct rlimit dizisinde bulunmaktadır.)

    UNIX türevi işletim sistemleri her kaynak için bir "soft limit (buna current limit de denilmektedir)" bir de "hard limit"
    değeri tutmaktadır. Kontroller soft limit dikkate alınarak yapılır. Herhangi bir proses soft limiti yükseltebilir. Ancak 
    en fazla hard limit kadar yükseltebilir. Yani hard limit, soft limit için tavan değeri belirtmektedir. Sıradan prosesler 
    hard limiti yükseltemezler, ancak düşürebilirler. Eğer hard limit sıradan prosesler tarafından düşürülürse bir daha eski 
    değerine bile yükseltilemez. Uygun önceliğe sahip prosesler hard limiti yükseltebilirler. Dolayısıyla soft limiti de
    yükseltebilirler. Bir özelliğin hard limiti, soft limitin aşağısına çekilememektedir.

    O halde bizim şu bilgileri edinmemiz gerekir: Prosesin kaynakları nelerdir ve bu kaynak limitleri nasıl elde edilip 
    değiştirilmektedir?

    Prosesin kaynak limitlerini elde etmek için getrlimit POSIX fonksiyonu, set etmek için setrlimit POSIX fonksiyonu 
    kullanılmaktadır. getrlimit fonksiyonunun prototipi şöyledir:

    #include <sys/resource.h>

    int getrlimit(int resource, struct rlimit *rlp);

    Fonksiyonun birinci parametresi kaynağın türünü, ikinci parametresi kaynak bilgilerinin yerleştirileceği rlimit yapı 
    nesnesinin adresini almaktadır. rlimit yapısı şöyle bildirilmiştir:

    struct rlimit {
        rlim_t rlim_cur;        /* Soft limit */
        rlim_t rlim_max;        /* Hard limit (ceiling for rlim_cur) */
    };

    Buradaki rlimit tür ismi işaretsiz bir tamsayı biçiminde typedef edilmek zorundadır. Fonksiyon başarı durumunda 0 değerine,
    başarısızlık durumunda -1 değerine geri dönmektedir.

    getrlimit fonksiyonunda dikkat edilmesi gereken birkaç nokta vardır: Fonksiyonun birinci parametresindeki kaynak belirten 
    değer <sys/resource.h> dosyası içerisinde RLIMIT_XXX sembolik sabitleriyle define edilmiştir. Fonksiyon ile elde edilmek 
    istenen limitler sınırsız olabilir. Bu durumda rlimit yapısının rlim_cur ve rlim_max elemanlarına RLIM_INFINITY özel 
    değeri yerleştirilir. Elde edilmek istenen limit o sistemde belirsiz olabilir ya da o limitin o sistemde elde edilme yolu 
    olmayabilir (unspecified). Bu durumda yapının rlim_cur elemanına RLIM_SAVED_CUR özel değeri, yapının rlim_max elemanına ise
    RLIM_SAVED_MAX değeri yerleştirilir. getrlimit fonksiyonu aşağıdaki gibi kullanılmalıdır:

    struct rlimit rl;

    if (getrlimit(RLIMIT_STACK, &rl) == -1)
        exit_sys("getrlimit");

    if (rl.rlim_cur == RLIM_INFINITY)
        printf("soft limit infinite...\n");
    else if (rl.rlim_cur == RLIM_SAVED_CUR)
        printf("soft limit unrepresentable...\n");
    else
        printf("Soft limit: %ju\n", (uintmax_t)rl.rlim_cur);

    if (rl.rlim_max == RLIM_INFINITY)
        printf("hard limit infinite...\n");
    else if (rl.rlim_max == RLIM_SAVED_MAX)
        printf("hard limit unrepresentable...\n");
    else
        printf("hard limit: %ju\n", (uintmax_t)rl.rlim_max);
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/resource.h>

void exit_sys(const char *msg);

int main(void)
{
    struct rlimit rl;

    if (getrlimit(RLIMIT_STACK, &rl) == -1)
        exit_sys("getrlimit");

    if (rl.rlim_cur == RLIM_INFINITY)
        printf("soft limit infinite...\n");
    else if (rl.rlim_cur == RLIM_SAVED_CUR)
        printf("soft limit unrepresentable...\n");
    else
        printf("Soft limit: %ju\n", (uintmax_t)rl.rlim_cur);

    if (rl.rlim_max == RLIM_INFINITY)
        printf("hard limit infinite...\n");
    else if (rl.rlim_max == RLIM_SAVED_MAX)
        printf("hard limit unrepresentable...\n");
    else
        printf("hard limit: %ju\n", (uintmax_t)rl.rlim_max);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    setrlimit fonksiyonu prosesin kaynaklarındaki hard ve/veya soft limitleri değiştirmek için kullanılmaktadır. Yukarıda da 
    belirttiğimiz gibi soft limit en fazla hard limit kadar yükseltilebilir. Hard limit ise ancak uygun önceliğe sahip prosesler
    tarafından yükseltilebilmektedir. Fonksiyonun prototipi şöyledir:

    #include <sys/resource.h>

    int setrlimit(int resource, const struct rlimit *rlp);

    Fonksiyonun yine birinci parametresi kaynağı, ikinci parametresi yükseltilecek limitleri belirtmektedir. Örneğin:

    struct rlimit rl;

    if (getrlimit(RLIMIT_NOFILE, &rl) == -1)
        exit_sys("getrlimit");

    rl.rlim_cur = 4096;

    if (setrlimit(RLIMIT_NOFILE, &rl) == -1)
        exit_sys("getrlimit");

    Burada önce dosya betimleyici tablosunun soft ve hard limitleri getrlimit fonksiyonuyla elde edilmiştir. Daha sonra da
    setrlimit fonksiyonu ile yalnızca soft limit değiştirilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/resource.h>

void exit_sys(const char *msg);

int main(void)
{
    struct rlimit rl;

    if (getrlimit(RLIMIT_NOFILE, &rl) == -1)
        exit_sys("getrlimit");

    rl.rlim_cur = 4096;

    if (setrlimit(RLIMIT_NOFILE, &rl) == -1)
        exit_sys("setrlimit");

    if (getrlimit(RLIMIT_NOFILE, &rl) == -1)
        exit_sys("getrlimit");

    if (rl.rlim_cur == RLIM_INFINITY)
        printf("soft limit infinite...\n");
    else if (rl.rlim_cur == RLIM_SAVED_CUR)
        printf("soft limit unrepresentable...\n");
    else
        printf("Soft limit: %ju\n", (uintmax_t)rl.rlim_cur);

    if (rl.rlim_max == RLIM_INFINITY)
        printf("hard limit infinite...\n");
    else if (rl.rlim_max == RLIM_SAVED_MAX)
        printf("hard limit unrepresentable...\n");
    else
        printf("hard limit: %ju\n", (uintmax_t)rl.rlim_max);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                86. Ders 01/10/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Prosesin kaynak limitleri üst prosesten alt prosese fork işlemi sırasında aktarılmaktadır. Yani örneğin kabuk programının 
    kaynak limiti değiştirilirse bu limit kabuktan çalıştırılan bütün programlara yansıtılacaktır. Ancak bu konuda genellikle 
    yanlış anlaşılan bir nokta vardır. İşletim sistemi kaynak aşımına ilişkin kontrolleri o prosesin proses kontrol bloğundaki 
    değerlere göre yapmaktadır. Örneğin bir kullanıcının yaratacağı maksimum proses sayısı RLIMIT_NPROC isimli kaynak ile 
    belirlenmiştir. Biz bu değeri değiştirdiğimizde artık bizim prosesimiz ve bizim yarattığımız prosesler bu limitten etkilenir. 
    Ancak bizim başka proseslerimizin proses kontrol bloğunda bu değişiklik yapılmamış olduğu için onlar bu değişiklikten 
    etkilenmeyecektir. Oysa kişiler bu limitin kullanıcı tabanlı bir limit olduğunu gördüğünde sanki bir proses bu limiti 
    değiştirdiğinde sistem genelinde bir değişiklik yapılıyormuş gibi düşünmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kabuk programının proses limitleri ulimit isimli içsel (internal) kabuk komutuyla görüntülenip değiştirilebilmektedir. 
    (ulimit komutunun tıpkı cd komutu gibi dışsal bir komut olamayacağına dikkat ediniz.) ulimit komutu -a seçeneği ile 
    kullanılırsa tüm soft limitler görüntülenir. Örneğin:

    $ ulimit -a
    real-time non-blocking time  (microseconds, -R) unlimited
    core file size              (blocks, -c) 0
    data seg size               (kbytes, -d) unlimited
    scheduling priority                 (-e) 0
    file size                   (blocks, -f) unlimited
    pending signals                     (-i) 15070
    max locked memory           (kbytes, -l) 497904
    max memory size             (kbytes, -m) unlimited
    open files                          (-n) 1000
    pipe size                (512 bytes, -p) 8
    POSIX message queues         (bytes, -q) 819200
    real-time priority                  (-r) 0
    stack size                  (kbytes, -s) 8192
    cpu time                   (seconds, -t) unlimited
    max user processes                  (-u) 15070
    virtual memory              (kbytes, -v) unlimited
    file locks                          (-x) unlimited

    Hard limitleri görüntülemek için -H, soft limitleri görüntülemek için (default) -S seçenekleri kullanılmaktadır. Örneğin:

    $ ulimit -H -a
    real-time non-blocking time  (microseconds, -R) unlimited
    core file size              (blocks, -c) unlimited
    data seg size               (kbytes, -d) unlimited
    scheduling priority                 (-e) 0
    file size                   (blocks, -f) unlimited
    pending signals                     (-i) 15070
    max locked memory           (kbytes, -l) 497904
    max memory size             (kbytes, -m) unlimited
    open files                          (-n) 1048576
    pipe size                (512 bytes, -p) 8
    POSIX message queues         (bytes, -q) 819200
    real-time priority                  (-r) 0
    stack size                  (kbytes, -s) unlimited
    cpu time                   (seconds, -t) unlimited
    max user processes                  (-u) 15070
    virtual memory              (kbytes, -v) unlimited
    file locks                          (-x) unlimited

    Limitlerde değişiklik yapmak için limite özgü seçenekler kullanılmalıdır. Örneğin -n seçeneği dosya betimleyici tablosunun 
    uzunluğu ile ilgilidir. Değişiklik şöyle yapılabilir:

    $ ulimit -n 2048
    $ ulimit -n
    2048

    Burada default olarak hem hard hem de soft limit değiştirilmiştir. Yalnızca soft limitin değiştirilmesi için -S, yalnızca 
    hard limitin değiştirilmesi için -H seçeneğinin de komuta eklenmesi gerekir. Örneğin:

    $ ulimit -H -n 5000
    $ ulimit -H
    unlimited
    $ ulimit -a -H
    real-time non-blocking time  (microseconds, -R) unlimited
    core file size              (blocks, -c) 0
    data seg size               (kbytes, -d) unlimited
    scheduling priority                 (-e) 0
    file size                   (blocks, -f) unlimited
    pending signals                     (-i) 15070
    max locked memory           (kbytes, -l) 497904
    max memory size             (kbytes, -m) unlimited
    open files                          (-n) 5000
    pipe size                (512 bytes, -p) 8
    POSIX message queues         (bytes, -q) 819200
    real-time priority                  (-r) 0
    stack size                  (kbytes, -s) unlimited
    cpu time                   (seconds, -t) unlimited
    max user processes                  (-u) 15070
    virtual memory              (kbytes, -v) unlimited
    file locks                          (-x) unlimited

    Burada biz yalnızca hard limiti değiştirdik. Yukarıda da belirttiğimiz gibi hard limit, soft limitin aşağısına indirilememektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de bazı proses limitlerinden bahsedelim. Bunlar hakkında daha ayrıntılı bilgileri ilgili dokümanlardan edinebilirsiniz.

    - RLIMIT_AS: Prosesin maksimum kullanabileceği sanal bellek miktarını belirtir. Bu limitin Linux'taki default hard ve soft default 
    RLIM_INFINITY biçimindedir.

    - RLIMIT_CORE: Bu limit üzerinde daha önce de "core dosyalarının oluşturulması" konusunda bazı şeyler söylemiştik. Bu limit
    core dosyalarının maksimum uzunluğunu belirtmektedir. Linux'ta default olarak soft ve hard değerleri 0 durumundadır. Yani
    core dosyalarının oluşturulabilmesi için bu limitin yükseltilmesi (örneğin RLIM_INFINITY yapılması) gerekmektedir.

    - RLIMIT_CPU: Bu limit prosesin harcayacağı CPU zamanını sınırlandırmak için bulundurulmuştur. Eğer proses burada belirtilen 
    CPU zamanını saniye olarak aşarsa bu durumda çekirdek prosese SIGXCPU sinyalini göndermektedir. Bu sinyalin default eylemi
    prosesin sonlandırılması biçimindedir. Linux'ta bu sinyal için sinyal fonksiyonu yazıldığında proses hemen sonlandırılmaz ve
    her saniyede bu sinyal yeniden gönderilir. Soft limit değerine ulaşıldığında prosese SIGKILL sinyali gönderilerek proses 
    sonlandırılmaktadır.

    - RLIMIT_DATA: Bu limit prosesin "data segment" kısmının limitini belirlemektedir. malloc gibi tahsisat fonksiyonları 
    bu data segment kısmını büyüttüğü için bu limitten etkilenmektedir. Bu limitin Linux'taki default hard ve soft değeri 
    RLIM_INFINITY biçimindedir.

    - RLIMIT_FSIZE: Prosesin toplamda yaratabileceği maksimum dosya uzunluğudur. Örneğin bu limit 5 MB'a ayarlanmışsa proses
    toplamda (tüm yarattığı dosyaların uzunluğu) ancak 5 MB uzunluğunda dosya yaratabilecektir. Bu limitin Linux'taki default
    hard ve soft değerleri RLIM_INFINITY biçimindedir. Eğer bu limit aşılırsa işletim sistemi prosese SIGXFSZ sinyalini 
    göndermektedir. Bu sinyalin default eylemi prosesin sonlandırılmasıdır.

    - RLIMIT_NICE: Bu değer SCHED_OTHER prosesler için nice değerine sınır koymak amacıyla düşünülmüştür. Anımsanacağı gibi 
    normalize edilmiş olan nice değerleri [0, 39] arasındaydı. Buradaki değer 20 - RLIMIT_NICE biçiminde normalize edilmektedir. 
    Bu değerin sıfır olması, prosesin nice değerini yükseltemeyeceği anlamına gelmektedir. Bu limitin Linux'taki default hard ve 
    soft değerleri 0 biçimindedir.

    - RLIMIT_NOFILE: Prosesin dosya betimleyici tablosunun uzunluğunu belirtmektedir. Bu limitin Linux'taki default soft değeri 1024, 
    hard değeri ise 1048576 biçimindedir. Biz bu limitin soft değerini değiştirdiğimizde kendi prosesimizin dosya betimleyici 
    tablosunu otomatik olarak büyütmüş olmaktayız. Ayrıca fork yaptığımız proseslerin de artık dosya betimleyici tabloları büyümüş
    olacaktır. Linux'ta tüm proseslerin dosya betimleyici tablolarının uzunlukları toplamı için de bir kısıt vardır. Bu kısıt 
    Linux'ta proc dosya sistemindeki /proc/sys/fs/file-max dosyasında belirtilmiştir. Güncel çekirdeklerde buradaki değer 
    9223372036854775807 biçiminde aşırı derecede büyüktür. Prosesin hard limiti olan 1048576 değeri de aslında proc dosya sistemi 
    ile değiştirilebilmektedir. Bunun için proc dosya sistemindeki /proc/sys/fs/nr_open dosyası kullanılmaktadır. Bu dosyadaki değeri 
    aşağıdaki gibi bir komutla değiştirebilirsiniz:

    $ sudo sh -c "echo 20 > /proc/sys/fs/mqueue/msg_max"

    Anımsanacağı gibi bu bilgi aynı zamanda sysconf fonksiyonundan da elde edilebilmektedir.

    - RLIMIT_NPROC: Belli bir kullanıcının yaratabileceği maksimum proses sayısıdır. Anımsanacağı gibi Linux sistemlerinde 
    thread'ler için de task_struct yapısı ayrılmaktadır. Bu nedenle buradaki limitler Linux sistemlerinde thread'leri de 
    kapsamaktadır. Yani biz thread yarattıkça da bu limite doğru ilerlemiş oluruz. Mevcut sistemlerde bu limitin hard ve 
    soft değerleri default olarak 15070 biçimindedir.

    Anımsanacağı gibi bu bilgi aynı zamanda sysconf fonksiyonundan da elde edilebilmektedir.

    - RLIMIT_RTPRIO: Bu limit uygun önceliğe sahip olmayan SCHED_FIFO ve SCHED_RR proseslerin önceliklerini sınırlandırmak için 
    kullanılmaktadır. (Anımsanacağı gibi bu çizelgeleme politikalarına sahip proseslerin Linux'taki öncelikleri [0, 99] arasında 
    olabiliyordu). Bu limitin Linux'taki default hard ve soft değerleri 0 biçimindedir.

    - RLIMIT_SIGPENDING: Gerçek zamanlı sinyallerdeki kuyruk uzunluğunu belirtmektedir. Bu limitin Linux'taki default hard ve soft 
    değerleri mevcut çekirdeklerde 15070 biçimindedir.

    - RLIMIT_STACK: Bir thread'in stack uzunluğunu sınırlandırmak için kullanılmaktadır. Linux'ta default durumda thread'lerin 
    stack uzunlukları 8 MB'dir. Bu limitin Linux'taki default soft değeri 8 MB, hard değeri ise RLIM_INFINITY biçimindedir. 
    (Yani biz thread yaratırken stack uzunluğunu bu soft limiti yukarı çekmeden artıramayız, ancak düşürebiliriz.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux'ta limitlerin hard ve soft değerlerini kalıcı bir biçimde değiştirebilmek için /etc/security/limits.conf dosyası 
    bulundurulmuştur. Örneğin bu dosya sayesinde biz sistem açıldığında prosesimizin dosya betimleyici tablosunun default 
    uzunluğunun (soft limitini) istediğimiz bir değerde olmasını sağlayabiliriz. Bu dosyanın formatı için man sayfalarına 
    başvurabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosesin kaynak kullanımlarını elde etmek için getrusage isimli bir POSIX fonksiyonu bulundurulmuştur. Fonksiyonun 
    prototipi şöyledir:

    #include <sys/resource.h>

    int getrusage(int who, struct rusage *r_usage);

    Fonksiyonun birinci parametresi kaynak bilgilerinin elde edileceği prosesleri belirtmektedir. İkinci parametresi kaynak 
    bilgilerinin yerleştirileceği yapı nesnesinin adresini almaktadır. Bu yapıda Linux'a özgü bazı elemanlar da vardır. 
    Ayrıntıları için ilgili dokümanlara başvurabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sonraki konuya yardımcı olması için UNIX türevi sistemlerin dosya sistemlerinde kullandığı i-node yapısı üzerinde durmak 
    istiyoruz.

    Biz daha önce dosya betimleyici tablosundaki slotların "dosya nesnesi" denilen yapı nesnelerini gösterdiğini belirtmiştik. 
    Dosya nesneleri Linux kaynak kodlarında "struct file" yapısıyla temsil edilmektedir. Daha önceki modelimiz şöyleydi:

    Proses Kontrol Blok
    ...
    ---------------------------->   Dosya Betimleyici Tablosu
    ...                             0
                                    1
                                    2
                                    3 --------------------------------> Dosya Nesnesi
                                    4
                                    ...

    İşte diskteki dosya için o dosya kullanılmaya başlandığı zaman işletim sistemi aynı zamanda i-node isimli bir nesne 
    oluşturmaktadır. i-node nesnesi farklı prosesler aynı dosya dosyayı açsalar bile o dosya için toplamda bir tanedir. 
    i-node nesnesi içerisinde tipik olarak bizim stat fonksiyonlarıyla elde ettiğimiz bilgiler bulunmaktadır. (Örneğin fstat
    fonksiyonu hiç disk işlemi yapmadan bilgileri doğrudan bu i-node nesnesinin içerisinden almaktadır.) Burada anahtar nokta
    toplamda bir dosya için işletim sisteminin sistem genelinde tek bir i-node nesnesi oluşturmasıdır. Çünkü i-node nesneleri
    işletim sisteminin diskte tek olan dosya bilgilerini yerleştirdiği nesnelerdir. O dosya diskte tek olduğuna göre o dosya 
    bilgilerinin çekirdek tarafından bellekteki temsili de tek olmalıdır. Tabii modern işletim sistemleri dosyalara ilişkin 
    bu i-node elemanlarını bir cache sistemi içerisinde tutmaktadır. Yani bir dosya artık hiçbir proses tarafından kullanılmıyor 
    olsa da o dosyanın bilgileri i-node cache içerisinde bulunuyor olabilir. Linux i-node nesneleri için LRU (Least Recently Used)
    stratejisine sahip bir cache sistemi kullanmaktadır. Bu durumda yukarıdaki şeklin daha gerçekçi biçimi aşağıdaki gibi olabilir:

        Proses Kontrol Blok
    ...
    ---------------------------->   Dosya Betimleyici Tablosu
    ...                             0
                                    1
                                    2
                                    3 --------------------------------> Dosya Nesnesi ------> i-node nesnesi
                                    4
                                    ...

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kursumuzun bu bölümünde birden fazla prosesin aynı dosyaya erişim yaptığı durumlardaki problemleri ve bu problemlerin 
    nasıl çözülmesi gerektiği üzerinde duracağız. Bu konuya genel olarak işletim sistemlerinde "dosya kilitleme (file locking)"
    de denilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İki prosesin aynı anda, aynı dosyanın, aynı bölümü üzerinde işlem yaptığını düşünelim. Bu durumda ne olur? Örneğin bir 
    proses dosyanın belli bir kısmına write fonksiyonu ile yazma yaparken diğer bir proses aynı kısımdan, aynı anda read 
    fonksiyonu ile okuma yapmak istese bir problem oluşur mu? İşte UNIX türevi sistemlerde read ve write işlemleri sistem 
    genelinde atomik işlemlerdir. Yani işletim sistemi read ve write işlemlerini sıraya sokarak onların biri tamamen bitince 
    diğeri işleme sokulacak biçimde yapmaktadır. Bu nedenle bir proses, dosyanın belli bir bölümüne yazma yaparken diğer bir 
    proses de aynı dosyanın, aynı bölümünden okuma yapıyorsa; okuyan proses ya yazan prosesin yazmış olduğu değeri okur ya da 
    dosyadaki yazma işleminden önceki değeri okur. Karışık bir değer okumaz. Yani read ve write işlemleri iç içe geçmemektedir. 
    POSIX standartları bunu garanti etmektedir. Benzer biçimde iki proses de aynı dosyanın aynı bölümüne yazma yapmak istese,
    dosyada ya birinin ya da diğerinin yazdığı gözükecektir. Karışık bir bilgi (yani biraz birinin, biraz ötekinin yazdığı değer)
    gözükmeyecektir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Veritabanı yönetim sistemleri ya da veritabanı kütüphaneleri bir dosyaya birbirleriyle ilgili birden fazla read ve 
    write işlemi yapabilmektedir. Örneğin şöyle bir senaryo düşünelim. Siz bir dosyanın belli bir yerine bir bilgi yazmak 
    isteyin, ancak o bilginin hash değeri de dosyanın başka bir yerine yazılacak olsun. Burada birbiriyle uyumlu iki farklı write 
    işlemi söz konusudur. Siz birinci write işlemini yaptıktan sonra henüz ikinci write işlemini yapmadan başka bir proses 
    bu iki write işlemini hızlı davranıp yaparsa, siz ikinci write işlemini yaptığınızda artık yazdığınız hash değeri ile 
    asıl bilgi uyumsuz hale gelecektir. İşte veritabanı uygulamalarında bu biçimdeki işlemler çok yoğun yapılmaktadır. 
    Veritabanı programı bir dosyaya önce kaydı yazıp sonra dosyanın başka bir yerine onun indeks bilgisini yazabilmektedir. 
    Bu bilginin tutarlı olması gerekmektedir. Özetle tek bir read ve write sistem genelinde atomiktir, ancak birden fazla read ve 
    write için böyle bir durum söz konusu değildir. Bu tür problemlerin çözümü için akla gelen ilk yöntem senkronizasyon nesnelerini
    kullanmaktır. Örneğin proses iki write işlemi öncesinde mutex nesnesini kilitler ve iki write işlemi bittiğinde kilidi açar. 
    Diğer prosesler de aynı mutex nesnesini aynı biçimde kullanır. Tabii burada mutex nesnesinin prosesler arasında kullanılabiliyor 
    olması gerekmektedir. Ancak bu çözüm hem yorucu hem de yavaş bir çözümdür. İşte bu tür problemler için "dosya kilitleme"
    denilen mekanizmalar kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dosya kilitleme bütünsel olarak ve offset temelinde (yani dosyanın bir bölümünü kapsayacak biçimde) yapılabilmektedir. Bütünsel 
    dosya kilitleme kullanışlı değildir ve seyrek uygulanmaktadır. Offset temelinde dosya kilitleme de kendi içerisinde ikiye 
    ayrılmaktadır: İsteğe bağlı kilitleme (advisory lock) ve zorunlu kilitleme (mandatory lock). Biz bu bölümde önce bütünsel 
    kilitlemeyi daha sonra offset temelinde kilitlemeyi ele alacağız. Bütünsel kilitleme adeta mutex benzeri bir senkronizasyon 
    nesnesi ile dosyaya tüm ulaşımı engelleyecek bir mekanizma oluşturmaktadır. Offset temelinde kilitlemede dosyanın yalnızca 
    istenilen bölümleri kilitlenmekte, diğer bölümleri üzerinde işlemler yapılabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bütünsel dosya kilitleme için Linux sistemlerinde flock isimli fonksiyon kullanılmaktadır. flock fonksiyonu ilk kez BSD 
    sistemlerinde gerçekleştirilmiştir. POSIX standartlarında bulunmamaktadır. Fonksiyonun prototipi şöyledir:

    #include <sys/file.h>

    int flock(int fd, int operation);

    Fonksiyonun birinci parametresi bütünsel olarak kilitlenecek dosyaya ilişkin betimleyiciyi belirtmektedir. İkinci parametre 
    kilitlemenin nasıl yapılacağını belirtir. İkinci parametre şunlardan biri olabilir:

    LOCK_SH: Okuma için kilidi alma
    LOCK_EX: Yazma için kilidi alma
    LOCK_UN: Kilidi bırakma

    Bu değerlerden biri ayrıca LOCK_NB (non-blocking) değeri ile de bit OR işlemine sokulabilmektedir. Buradaki mekanizma 
    "reader-writer lock" mekanizmasına benzemektedir. Yani dosyaya birden fazla proses read işlemi yapabilir. Ancak bir proses 
    write yapıyorsa diğerlerinin işlem bitene kadar beklemesi sağlanmalıdır. Buradaki LOCK_SH (shared lock) okuma eylemi için 
    erişme anlamına gelmektedir. LOCK_EX ise yazma işlemi için erişmek anlamına gelir. LOCK_UN kilitlemeyi kaldırmaktadır. Bu 
    durumda dosyaya yazma amaçlı erişilecekse önce LOCK_EX ve işlem bitince de LOCK_UN uygulanmalıdır. Dosyaya okuma amaçlı 
    erişilecekse önce LOCK_SH ve işlem bitince de LOCK_UN uygulanmalıdır. Fonksiyon başarı durumunda 0 değerine, başarısızlık 
    durumunda -1 değerine geri dönmektedir.

    Proseslerden bir dosyanın değişik yerlerine tutarlı bir biçimde yazma yapacak olsun. Kodunu şöyle organize etmelidir (kontroller
    yapılmamıştır):

    flock(fd, LOCK_EX);

    /* yazma işlemleri */

    flock(fd, LOCK_UN);

    Bu durumda diğer bir proses flock fonksiyonunu LOCK_SH ya da LOCK_EX ile çağırdığında blokede bekler. Ta ki bu proses 
    flock fonksiyonunu LOCK_UN ile çağırana kadar. Dosyadan okuma yapacak proses de kodunu şöyle organize etmelidir:

    flock(fd, LOCK_SH);

    /* okuma işlemleri */

    flock(fd, LOCK_UN);

    Bu durumda başka bir proses de aynı dosyaya flock fonksiyonunu LOCK_SH ile çağırarak erişmek istese bloke oluşmaz. Ancak 
    bir proses dosyaya flock fonksiyonunu LOCK_EX ile çağırarak erişmeye çalışırsa blokede bekler. Ta ki bu proses LOCK_UN 
    yapana kadar. Mekanizma tamamen daha önce görmüş olduğumuz reader-writer lock senkronizasyon nesnesindeki gibidir.

    Bu biçimdeki kilitler alt prosese fork işlemi sırasında da geçirilmektedir ve exec işlemi sırasında bu kilitler korunmaktadır. 
    Kilit bilgisi dosya nesnesinin içerisinde saklanmaktadır. Dolayısıyla birden fazla kez open fonksiyonu çağrılarak elde edilmiş 
    olan dosya betimleyicilerinden biri ile kilit alındığında diğer betimleyici bu kilidi almamış gibi olmaktadır. Ancak aynı dosya 
    nesnesini gösteren betimleyici ile birden fazla kez flock fonksiyonu çağrılırsa bu durumda ikinci flock birincinin etkisini 
    kaldırır ve yeni etki oluşur.

    Bütünsel lock işlemi uygulanırken LOCK_NB bayrağı da kullanılırsa bu durumda uyuşmayan lock işlemleri blokeye yol açmaz. 
    Fonksiyon başarısız olur ve errno değeri EWOULDBLOCK biçiminde set edilir.

    Eğer kilit hiç açılmazsa kilidin ilişkin olduğu dosya nesnesine ilişkin son betimleyici kapatıldığında kilit otomatik olarak 
    açılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                87. Ders 07/10/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Offset temelinde dosya kilitleme işlemleri yukarıda da belirttiğimiz gibi kendi aralarında "isteğe bağlı (advisory)" ve 
    "zorunlu (mandatory)" olmak üzere ikiye ayrılmaktadır. Offset temelinde lock işlemleri fcntl fonksiyonu ile gerçekleştirilmektedir. 
    fcntl fonksiyonu bir dosya betimleyicisi ile bazı özel işlemler yapmakta kullanılan genel bir fonksiyondu. Biz bu fonksiyonu
    daha önce tanıtmıştık. Fonksiyonun prototipi şöyleydi:

    #include <fcntl.h>

    int fcntl(int fd, int cmd, ...);

    Fonksiyon iki argümanla ya da üç argümanla çağrılmaktadır. İkinci parametreye komut parametresi denilmektedir. Üçüncü 
    parametrenin anlamı ikinci parametredeki komuta göre değişmektedir.

    Offset temelinde kilitleme için kilitlenecek dosyayı temsil eden bir dosya betimleyicisi olmalıdır (birinci parametre). 
    fcntl fonksiyonunun ikinci parametresine F_SETLK, F_SETLKW ya da F_GETLK değerlerinden biri girilir. Üçüncü parametresine 
    ise her zaman flock isimli bir yapı nesnesinin adresi girilmelidir. F_SETLK ve F_SETLKW komutlarında bu flock yapı
    nesnesinin içi programcı tarafından doldurulmalıdır. Ancak F_GETLK komutunda bu yapı nesnesinin içi fonksiyon tarafından 
    doldurulmaktadır. flock yapısı şöyle bildirilmiştir:

    struct flock {
        short l_type;
        short l_whence;
        off_t l_start;
        off_t l_len;
        pid_t l_pid;
    };

    Bu yapı nesnesinin elemanları pid dışında programcı tarafından doldurulur. l_type elemanı kilitlemenin cinsini belirtir. 
    Bu elemana F_RDLCK, F_WRLCK, F_UNLCK değerlerinden biri girilmelidir. Yapının l_whence elemanı offset için orijini belirtmektedir. 
    Bu elemana da SEEK_SET (0), SEEK_CUR (1) ya da SEEK_END (2) değerleri girilmelidir. l_start elemanı kilitlenecek bölgenin 
    başlangıç offset'ini l_len ise uzunluğunu belirtmektedir. l_pid, F_GETLK komutu tarafından doldurulmaktadır. Yapının l_type elemanının
    kilidin türünü belirttiğini söylemiştik. Bu tür tıpkı thread senkronizasyonu konusunda görmüş olduğumuz "okuma-yazma kilitleri 
    (reader-writer lock)" gibi işlem görmektedir. Yani biz belli bir bölgeye F_WRLCK ile kilit yerleştirirsek bu durum "bizim o bölgeye
    başkalarının okuma ya da yazma yapmasını istemediğimiz" anlamına gelmektedir. Biz belli bir bölgeye F_RDLCK ile kilit yerleştirirsek
    bu durum da "bizim o bölgeye başkalarının yazma yapmasını istemediğimiz ancak okuma yapmalarına izin verdiğimiz" anlamına gelmektedir. 
    F_UNLCK ise bizim o bölgedeki kilidi kaldırmak istediğimiz anlamına gelmektedir. Bu kilit türlerini şöyle özetleyebiliriz:

    F_WRLCK: Başkaları yazma da okuma da yapmamalı
    F_RDLCK: Başkaları okuma yapabilir ancak yazma yapmamalı
    F_UNLCK: Bu bölgedeki kilit kaldırılmak isteniyor

    l_len değeri 0 ise bu l_start değerinden itibaren dosyanın sonuna ve ötesine kadar kilitleme anlamına gelmektedir. (Bu durumda
    örneğin lseek ile dosya göstericisi EOF ötesine konumlandırılsa bile kilit geçerli olmaktadır.) Yani yapının l_len elemanı 0
    olarak girilirse dosya ne kadar büyütülürse büyütülsün tüm büyütülen alanlar da kilitli olacaktır.

    Pekiyi fcntl fonksiyonunun ikinci parametresindeki F_SETLK, F_SETLKW ve F_GETLK komutları ne anlama gelmektedir? F_SETLK blokesiz, 
    F_SETLKW blokeli kilitleme yapmaktadır. Blokesiz kilitlemede "çelişen (incompatible)" kilitleme isteklerinde thread bloke olmaz,
    ancak fcntl fonksiyonu başarısız olur. Blokeli kilitlemede ise çelişen (incompatible) kilitleme isteklerinde thread bloke olur. 
    Ta ki bu çelişki ortadan kaldırılana kadar. Örneğin biz bir dosyanın 100 ile 110 offset'leri arasını F_WRLCK türü ile F_SETLK 
    komutunu kullanarak kilitlemek isteyelim. Eğer bu bölge başka bir proses tarafından F_RDLCK ya da F_WRLCK türü ile kilitlenmişse
    kilitleme başarısız olur ve fcntl fonksiyonu -1 değeri ile geri döner. Ancak biz aynı bölgeyi F_SETLKW ile blokeli kilitlemek 
    istersek bu durumda çelişkili bir kilitleme isteği söz konusu olduğu için thread bloke olur. Ta ki bu çelişki giderilene kadar. 
    (Yani kilidi yerleştiren proses onu kaldırana kadar.) Özetle F_SETLK ile çelişkili kilit yerleştirilmek istenirse fcntl başarısız 
    olmakta, ancak F_SETLKW ile çelişkili kilit yerleştirilmek istenirse fcntl blokeye yol açmaktadır. Genellikle uygulamalarda F_SETLKW 
    kullanılmaktadır.

    Yukarıda da belirttiğimiz gibi F_SETLK ile bir bölgeyi kilitlemek isteyen proses eğer bu alan başka bir proses tarafından çelişki 
    yaratacak biçimde kilitlenmişse fcntl fonksiyonu başarısız olur ve -1 değerine geri döner. Bu durumda errno değişkeni EACCES 
    ya da EAGAIN değerlerinden biri ile set edilmektedir.

    Aynı proses kendisinin yerleştirmiş olduğu bir kilidin türünü değiştirebilir. Bu durumda bir çelişkiye bakılmamaktadır. Yani 
    örneğin biz bir dosyanın belli bölgesine bir F_WRLCK yerleştirmiş olabiliriz. Sonra bunu F_RDLCK ile yer değiştirebiliriz. 
    Bu işlem atomik düzeyde yapılmaktadır.

    F_GETLK komutu için de programcının flock nesnesini oluşturmuş olması gerekir. Bu durumda fcntl bu alanın isteğe bağlı biçimde
    kilitlenip kilitlenmeyeceğini bize söyler. Yani bu durumda fcntl kilitleme yapmaz ama sanki yapacakmış gibi duruma bakar. 
    Eğer çelişki yoksa fcntl yalnızca yapının l_type elemanını F_UNLCK haline getirir. Eğer çelişki varsa bu çelişkiye yol açan 
    kilit bilgilerini yapı nesnesinin içerisine doldurur. Fakat o alan birden farklı biçimlerde kilitlenmişse bu durumda
    fcntl bu kilitlerin herhangi birinin bilgisini bize verecektir. Örneğin kilit durumunu öğrenmek istediğimiz bölgede ayrık
    iki farklı kilit bulunuyor olabilir. Bu tür durumlarda fcntl fonksiyonu bu kilit bilgilerinin herhangi birini bize vermektedir.

    fcntl ile offset temelinde konulmuş olan kilitler fork işlemi sırasında alt prosese aktarılmazlar. Yani üst prosesin 
    kilitlemiş olduğu alanlar alt proses tarafından da kilitlenmiş gibi olmazlar. (Halbuki flock fonksiyonu ile bütünsel 
    kilitlemelerin fork işlemi sırasında alt prosese aktarıldığını anımsayınız.) exec işlemleri sırasında offset temelindeki 
    kilitlemeler varlığını devam ettirmektedir.

    Dosyanın kilit bilgileri dosyanın diskteki varlığı üzerine kaydedilmemektedir. İşletim sisteminin çekirdek içerisinde 
    oluşturduğu i-node elemanının içerisinde kaydedilmektedir. Dolayısıyla aynı dosyayı açmış olan prosesler aynı i-node 
    nesnesini gördükleri için aynı kilit bilgilerine sahip olurlar. Genellikle UNIX türevi işletim sistemleri kilit 
    bilgilerini i-node nesnesi içerisinde bir bağlı listede proses id'lere göre sıralı bir biçimde tutmaktadır.

    Prosesin yerleştirmiş olduğu bir kilit o proses tarafından kilit türü F_UNLCK yapılarak kaldırılabilmektedir. Ancak en kötü 
    olasılıkla ilgili dosya kapatıldığında o prosesin o dosya üzerinde yerleştirmiş olduğu kilitler de kaldırılmaktadır. Burada 
    önemli bir nokta bir dosya betimleyicisi dup yapıldığında onlardan herhangi biri close ile kapatılırsa kilidin kaldırılacağıdır. 
    Yani kilidin kaldırılması için bir betimleyicinin close edilmesi yeterli olmaktadır. Benzer biçimde aynı proses, aynı dosyayı 
    ikinci kez açtığı durumda, onlardan herhangi biri close işlemi yaptığında kilit kaldırılmaktadır. Proses biterken zaten 
    betimleyiciler üzerinde close işlemleri yapılacağı için o prosesin açmış olduğu dosyalar üzerinde yerleştirdiği kilitler de 
    ortadan kaldırılacaktır.

    Prosesin dosyaya F_WRLCK kilidi yerleştirebilmesi için dosyanın yazma modunda, F_RDLCK kilidi koyabilmesi için ise dosyanın 
    okuma modunda açılmış olması gerekir.

    Offset temelinde kilitlemede "deadlock" oluşumuna dikkat edilmelidir. Yani biz bir prosesin kilidi açmasını beklerken o 
    proses de bizim başka bir kilidi açmamızı bekliyorsa burada bir "deadlock" durumu söz konusudur. İşte deadlock durumu 
    fcntl fonksiyonu tarafından otomatik olarak tespit edilmektedir. Eğer bir proses F_SETLKW ile (F_SETLK ile değil) kilit 
    koymak isterken bir "deadlock" durumu söz konusu ise fcntl başarısız olmakta ve errno değeri EDEADLK değeri ile set edilmektedir.

    Kilitlenmek istenen bölgede birden fazla ayrık kilit bulunuyor olabilir. Bu durumda kilitlemenin yapılabilmesi için bu 
    ayrık kilitlerin hiçbirinde bir çelişkinin olmaması gerekir. Aksi takdirde F_SETLK komutunda fcntl başarısız olur, F_SETLKW 
    komutunda ise fcntl blokeye yol açar. Yani kilitleme işlemi "yap hep ya hiç" biçiminde yapılmaktadır.

    Bir bölgenin belli bir kilit türüyle kilitlenmiş olduğunu varsayalım. Aynı proses bu bölgenin bir alt bölgesini başka 
    bir kilit türüyle kilitleyebilir ya da o alt bölgenin kilidini kaldırabilir. Bu durumda işletim sistemi otomatik olarak 
    kilitleri birbirinden ayıracaktır. Örneğin:

    WWWWWWWWWWWWWWWWWWWWW

    Bu bölgenin F_WRLCK ile kilitlenmiş olduğunu düşünelim. Biz bu bölgenin ortasında bir bölgenin kilidini F_RDLCK olarak 
    değiştirelim:

    WWWWWWWWWRRRRRWWWWWWW

    Burada artık üç kilit bölgesi oluşmaktadır. Kilidin kaldırılması eğer kilidi koyan proses tarafından yapılıyorsa her zaman 
    başarılı olmaktadır. Yani biz yukarıdaki üç bölgenin kilidini tek bir F_UNLCK ile kaldırabiliriz. Kilitlenmemiş bölgeye 
    F_UNLCK uygulansa bile fcntl fonksiyonu başarısız olmamaktadır.

    Pekiyi fcntl fonksiyonunun başarısı nasıl kontrol edilmelidir. Eğer kilitleme F_SETLK fonksiyonu ile yapılıyorsa EACCES
    ve EAGAIN değerleri test edilmelidir. Mesajlar bu durumlar için özel olarak verilmesi daha iyi bir tekniktir. Eğer kilitleme 
    F_SETLKW ile yapılıyorsa EDEADLK değeri de test edilmelidir. Örneğin:

    if (fcntl(fd, F_SETLK, &fl) == -1) {
        if (errno == EACCES || errno == EAGAIN) {
            fprintf(stderr, "lock failed!...\n");
            ...
        }
        else
            exit_sys("fcntl");
    }

    Ya da örneğin:

    if (fcntl(fd, F_SETLKW, &fl) == -1) {
        if (errno == EDEADLK) {
            fprintf(stderr, "deadlock danger!...\n");
            ...
        }
        else
            exit_sys("fcntl");
    }

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda kilitleme işlemlerini test etmek için "flock-test.c" isimli örnek bir program verilmektedir. Bu programı çalıştırırken
    komut satırı argümanı olarak kilitlemeye konu olacak dosyanın yol ifadesi verilmelidir. Örneğin:

    $ ./flock-test test.txt

    Program aşağıdaki gibi bir prompt'a düşmektedir:

    CSD (55306)>

    Parantezler içerisinde prosesin proses id'si bulunmaktadır. Buraya kullanıcı komutlar girerek fcntl ile kilit yerleştirebilir. 
    Girilecek komutların biçimi şöyle olmalıdır:

    <fcntl command code> <lock type> <starting offset> <length>

    Örneğin:

    CSD (55306)>F_SETLK F_RDLCK 0 64

    Bu komutla fcntl fonksiyonu ile "test.txt" dosyasının 0 offset'inden 64 byte uzunluktaki bölgeye F_RDLCK yerleştirilmek 
    istenmiştir. Yerleştirme işlemi blokeye yol açmayan F_SETLK komut kodu ile yapılacaktır. Aynı programı başka bir terminalden 
    girerek çalıştırmalısınız. Örneğin:

    CSD (55377)>F_SETLK F_WRLCK 0 64
    Locked failed!..

    F_GETLK komutunda aslında kilit türünün belirtilmesi gereksizdir. Ancak buradaki programı kısaltmak için kullanılmayacak olsa 
    da bir kilit türünü yine belirtmek zorundayız. Örneğin:

    CSD (55471)>F_GETLK F_RDLCK 0 64
    Write Lock
    Whence: 0
    Start: 0
    Length: 64
    Process Id: 55469

    Komutun ikinci argümanı aslında program tarafından kullanılmamaktadır. Ancak girilmek zorundadır.

    Programdan çıkmak için komut satırına "quit" yazılabilir.

    Bu programı kllanarak F_SETLKW komutuyla blokeli işlemleri de deneyiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* fclock-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define MAX_CMDLINE        4096
#define MAX_ARGS        64

void parse_cmd(void);
int get_cmd(struct flock *fl);
void disp_flock(const struct flock *fl);
void exit_sys(const char *msg);

char g_cmd[MAX_CMDLINE];
int g_count;
char *g_args[MAX_ARGS];

int main(int argc, char *argv[])
{
    int fd;
    pid_t pid;
    char *str;
    struct flock fl;
    int fcntl_cmd;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    pid = getpid();

    if ((fd = open(argv[1], O_RDWR)) == -1)
        exit_sys("open");

    for (;;) {
        printf("CSD (%ld)>", (long)pid), fflush(stdout);
        fgets(g_cmd, MAX_CMDLINE, stdin);
        if ((str = strchr(g_cmd, '\n')) != NULL)
            *str = '\0';
        parse_cmd();
        if (g_count == 0)
            continue;
        if (g_count == 1 && !strcmp(g_args[0], "quit"))
            break;
        if (g_count != 4) {
            printf("invalid command!\n");
            continue;
        }

        if ((fcntl_cmd = get_cmd(&fl)) == -1) {
            printf("invalid command!\n");
            continue;
        }

        if (fcntl(fd, fcntl_cmd, &fl) == -1)
            if (errno == EACCES || errno == EAGAIN)
                printf("Locked failed!...\n");
            else
                perror("fcntl");
        if (fcntl_cmd == F_GETLK)
            disp_flock(&fl);
    }

    close(fd);

    return 0;
}

void parse_cmd(void)
{
    char *str;

    g_count = 0;
    for (str = strtok(g_cmd, " \t"); str != NULL; str = strtok(NULL, " \t"))
        g_args[g_count++] = str;
}

int get_cmd(struct flock *fl)
{
    int cmd, type;

    if (!strcmp(g_args[0], "F_SETLK"))
        cmd = F_SETLK;
    else if (!strcmp(g_args[0], "F_SETLKW"))
        cmd = F_SETLKW;
    else if (!strcmp(g_args[0], "F_GETLK"))
        cmd = F_GETLK;
    else
        return -1;

    if (!strcmp(g_args[1], "F_RDLCK"))
        type = F_RDLCK;
    else if (!strcmp(g_args[1], "F_WRLCK"))
        type = F_WRLCK;
    else if (!strcmp(g_args[1], "F_UNLCK"))
        type = F_UNLCK;
    else
        return -1;

    fl->l_type = type;
    fl->l_whence = SEEK_SET;
    fl->l_start = (off_t)strtol(g_args[2], NULL, 10);
    fl->l_len = (off_t)strtol(g_args[3], NULL, 10);

    return cmd;
}

void disp_flock(const struct flock *fl)
{
    switch (fl->l_type) {
        case F_RDLCK:
            printf("Read Lock\n");
            break;
        case F_WRLCK:
            printf("Write Lock\n");
            break;
        case F_UNLCK:
            printf("Unlocked (can be locked)\n");
    }

    printf("Whence: %d\n", fl->l_whence);
    printf("Start: %ld\n", (long)fl->l_start);
    printf("Length: %ld\n", (long)fl->l_len);
    if (fl->l_type != F_UNLCK)
        printf("Process Id: %ld\n", (long)fl->l_pid);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi dosya kilitleme mekanizmasından nasıl faydalanılacaktır? Örneğin biz aynı dosyanın iki bölgesi üzerinde birbirleriyle 
    ilgili iki güncelleme yapmak isteyelim. Tipik olarak bunun için önce iki bölgeyi kilitleriz. Sonra güncellemeleri yaparız. 
    Sonra da kilitleri açarız. Örneğin (kontroller yapılmamıştır):

    fcntl(fd, F_SETLKW, &region1);        /* F_WRLCK */
    fcntl(fd, F_SETLKW, &region2);        /* F_WRLCK */

    write(fd, region1, size1);
    write(fd, region2, size2);

    fcntl(fd, F_SETLKW, &region1);        /* F_UNLCK */
    fcntl(fd, F_SETLKW, &region2);        /* F_UNLCK */

    Şimdi belli bir kaydın bir elemanını değiştirmek isteyelim:

    fcntl(fd, F_SETLKW, &region);        /* F_WRLCK */

    read(fd, buf, elem_size);
    <update işlemi>
    write(fd, buf, elem_size);

    fcntl(fd, F_SETLKW, &region);        /* F_UNLCK */
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir programın tek bir kopyasının çalışması istenebilmektedir. Örneğin program bir kaynak kullanıyor olabilir. Programın 
    kullandığı kaynak sistem genelinde tek olabilir. Ya da programın birden fazla kopyasının çalıştırılması tasarım bakımından 
    anomalilere yol açıyor da olabilir. Bunu sağlamak için kayıt kilitleme mekanizması kullanılabilmektedir. Program çalışmaya 
    başladığında bir dosyayı bütünsel olarak kilitlemeye çalışır. Eğer kilitleme başarısız olursa programın başka bir kopyasının 
    çalışıyor olduğu sonucuna varılır. Aslında bu işlem isimli senkronizasyon nesneleriyle de yapılabilmektedir. Örneğin Windows
    sistemlerinde bunun için dosya kilitleme mekanizması yerine "isimli mutex nesneleri" tercih edilmektedir. Ancak UNIX/Linux
    sistemlerindeki geleneksel yaklaşım dosya kilitleme mekanizmasının kullanılmasıdır.

    Aşağıda programın tek bir kopyasının çalışmasını sağlayan basit bir örnek verilmiştir. Bu örnekte proses dosyayı bütünsel 
    olarak "exclusive" bir biçimde kilitlemeye çalışmıştır. Dosya kapatıldığında zaten kilit de ortadan kalkmaktadır. Burada 
    flock fonksiyonunda LOCK_NB bayrağını da kullandık. Çünkü bu tür durumlarda bloke oluşmasının engellenmesi gerekmektedir. 
    Bu yöntemde içi boş bir dosyanın yaratılmış olduğuna dikkat ediniz. Bu tür dosyaların "/temp" dizini içerisinde yaratılması 
    da sık karşılaşılan bir uygulamadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/file.h>

#define LOCK_FILE_PATH        "lock.dat"

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open(LOCK_FILE_PATH, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR)) == -1)
        exit_sys("open");

    if (flock(fd, LOCK_EX|LOCK_NB) == -1)
        if (errno == EWOULDBLOCK) {
            fprintf(stderr, "only one instance of this program can run...\n");
            exit(EXIT_FAILURE);
        }
        else
            exit_sys("flock");

    sleep(10);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda "isteğe bağlı (advisory)" kilitleme işlemi yaptık. Burada "isteğe bağlı (advisory)" demekle aslında read/write 
    fonksiyonlarının bu kilitlere hiç bakmaması anlatılmak istenmiştir. Örneğin biz dosyanın bir bölgesine F_WRLCK ile bir 
    kilit yerleştirelim. Başka bir proses o bölgeye write ile yazma yapabilir. Tabii dosya erişen ilgili programların hepsi
    birbirleriyle koordineli yazıldığı için onlar da read/write yapmadan önce aynı kilit mekanizmasını kullanarak senkronizasyon 
    sağlamaktadır. Özetle "isteğe bağlı kilitleme (advisory locking)" demekle read/write fonksiyonlarının bakmadığı, fcntl 
    fonksiyonunun baktığı kilit anlaşılmaktadır. Pekiyi "zorunlu (mandatory)" kilit sistemi nedir? Zorunlu kilitlemede read/write 
    fonksiyonları kilitlere bakarak çalışmaktadır. Yani örneğin biz bir bölgeye F_WRLCK ile zorunlu kilit yerleştirmişsek o 
    bölgeden read işlemi ya da o bölgeye write işlemi yapıldığında bu fonksiyonlar otomatik blokeye yol açmakta ya da başarısız 
    olmaktadır. Uygulamada "isteğe bağlı (advisory) kilitleme" çok daha yoğun kullanılmaktadır. Çünkü zorunlu kilitlemede read/write 
    fonksiyonlarının her defasında kilitlere bakması (kilitler konulmamış bile olsa) zaman kaybına yol açmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi zorunlu (mandatory) kilitleme nasıl uygulanmaktadır? İsteğe bağlı kilitleme ile zorunlu kilitlemenin uygulanış biçimi 
    arasında hiçbir farklılık yoktur. Kilitleme isteğe bağlı mı yoksa zorunlu mu olduğu "mount parametrelerine" ve "dosyanın erişim 
    haklarına" bakılarak belirlenmektedir.

    Zorunlu kilitleme kavramı POSIX standartlarında bulunmamaktadır. POSIX standartları fcntl fonksiyonunun açıklamasında bunun 
    gerekçelerini belirtmiştir. Zaten bazı işletim sistemleri zorunlu kilitlemeyi hiç desteklememektedir. Linux 2.4 çekirdeği 
    ile birlikte zorunlu dosya kilitlemesini destekler hale gelmiştir. Yukarıda da belirttiğimiz gibi zorunlu kilitleme için aslında 
    fcntl fonksiyonunda ek bir şey yapılmaz. Linux'ta zorunlu kilitleme için şu koşulların sağlanmış olması gerekmektedir:

    1) Dosyanın içinde bulunduğu dosya sisteminin -o mand ile mount edilmiş olması gerekir. Mevcut mount edilmiş olan bir dosya 
    sisteminin mount parametreleri aşağıdaki gibi değiştirilebilir:

    $ sudo mount -o mand,remount <device> <mount point>

    Hangi dosya sisteminin "mand" parametresi ile mount edileceğini tespit etmeniz gerekir. Bunun için df komutunu argümansız 
    biçimde kullanabilirsiniz. Örneğin:

    $ df
    Dosyasistemi    1K-blok     Dolu      Boş Kull% Bağlanılan yer
    udev            1471368        0  1471368    0% /dev
    tmpfs            303552     1364   302188    1% /run
    /dev/sda5      81526200 41496476 35845404   54% /
    tmpfs           1517748        4  1517744    1% /dev/shm
    tmpfs              5120        4     5116    1% /run/lock
    tmpfs           1517748        0  1517748    0% /sys/fs/cgroup
    /dev/sda1        523248        4   523244    1% /boot/efi
    tmpfs            303548      104   303444    1% /run/user/1000

    mount parametrelerini görebilmek için mount komutunu parametresiz olarak kullanabilirsiniz. Ancak burada karşınıza uzun 
    bir liste çıkabilir. grep utility'si ile ilgili satırı görüntüleyebilirsiniz. Örneğin:

    $ mount | grep /dev/sda5
    /dev/sda5 on / type ext4 (rw,relatime,mand,errors=remount-ro)

    Aslında mount komutu bu bilgileri /proc/mounts dosyasından elde etmektedir. Örneğin:

    $ sudo mount -o mand,remount /dev/sda5 /

    Sistem açıldığında ilgili dosya sisteminin "mand" parametresi ile mount edilebilmesi için bazı start-up dosyaları 
    kullanabilirsiniz. Örneğin /etc/fstab dosyası bu amaçla kullanılabilmektedir.

    2) İlgili dosyanın set-group-id bayrağı set edilip gruba x hakkı varsa reset edilmelidir. Bu işlem şöyle yapılmalıdır:

    $ chmod g+s,g-x <dosya>

    Örneğin:

    $ chmod g+s,g-x test.txt

    Bir dosyanın bir proses tarafından zorunlu kilitlenmiş olması dosyanın silinmesini engellememektedir. Dosyanın truncate 
    ve ftruncate fonksiyonu ile genişletilmesi ya da budanması işleminde zorunlu kilitleme mekanizması devreye girmektedir. 
    Yani bu fonksiyonlar sanki dosyaya yazma yapıyormuş gibi etki göstermektedir. Benzer biçimde örneğin dosyaya zorunlu 
    kilit konulmuşsa dosya O_TRUNC modunda açılamamaktadır. Ancak yukarıda belirttiğimiz gibi dosya remove ya da unlink 
    fonksiyonlarıyla üzerinde zorunlu kilit olsa bile silinebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                88. Ders 08/10/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda zorunlu kilitlemeyi test etmek için bir örnek hazırlanmıştır. Bu örnekte iki program vardır. "flock-test.c" 
    programı yukarıdaki programın aynısıdır. "rw-test.c" programı ise belli bir dosyanın belli bir offset'inden belli miktarda
    okuma ya da yazma yapan bir programdır. "flock-test.c" programını yukarıda açıklamıştık. "rw-test.c" programının komut 
    satırı argümanları şöyledir:

    $ ./rw-test <dosya ismi> <r|w> <offset> <uzunluk>

    Burada "r" okuma, "w" ise yazma yapma anlamına gelmektedir. Örneğin:

    $ ./rw-test test.txt w 60 10

    Bu çalıştırmayla program write fonksiyonu ile "test.txt" dosyasına 60'ıncı offset'inden itibaren 10 byte yazacaktır. Örneğin:

    $ ./rw-test test.txt r 0 64

    Burada da program "test.txt" dosyasının 0'ıncı offset'inden 64 byte okuyacaktır.

    Aşağıdaki örneği test yaparken şu biçimde kullanabilirsiniz: Önce "flock-test" programı ile dosyanın belli bir bölgesine kilit 
    yerleştiriniz. Sonra "rw-test" programı ile ilgili offset'i kapsayan bölgeden okuma/yazma yapmaya çalışınız. read ve write 
    fonksiyonlarındaki blokeyi gözlemleyiniz. Sonra kilidi kaldırınca fonksiyonların blokeden çıkacağını göreceksiniz. Tabii 
    örnekte test işleminde kullanacağınız dosyanın (örneğin "test.txt") yukarıda belirttiğimiz gibi zorunlu kilitlemeye 
    hazırlanmış olması gerekir.

    Zorunlu kilitleme uygulanmış bir dosya open fonksiyonu ile O_NONBLOCK bayrağı kullanılarak açılmışsa (normal dosyaların 
    bu bayrak kullanılarak açılması genellikle işlevsizdir, ancak burada bir istisna vardır) bu durumda read/write fonksiyonları
    çelişkili kilitle karşılaştığında bloke olmazlar ve başarısızlıkla (-1 değeriyle) geri dönerler. Bu durumda errno değeri 
    EAGAIN (Resource temporarily unavailable) değeri ile set edilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* flock-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define MAX_CMDLINE        4096
#define MAX_ARGS        64

void parse_cmd(void);
int get_cmd(struct flock *fl);
void disp_flock(const struct flock *fl);
void exit_sys(const char *msg);

char g_cmd[MAX_CMDLINE];
int g_count;
char *g_args[MAX_ARGS];

int main(int argc, char *argv[])
{
    int fd;
    pid_t pid;
    char *str;
    struct flock fl;
    int fcntl_cmd;
F_SETLKW"wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    pid = getpid();

    if ((fd = open(argv[1], O_RDWR)) == -1)
        exit_sys("open");

    for (;;) {
        printf("CSD (%ld)>", (long)pid), fflush(stdout);
        fgets(g_cmd, MAX_CMDLINE, stdin);
        if ((str = strchr(g_cmd, '\n')) != NULL)
            *str = '\0';
        parse_cmd();
        if (g_count == 0)
            continue;
        if (g_count == 1 && !strcmp(g_args[0], "quit"))
            break;
        if (g_count != 4) {
            printf("invalid command!\n");
            continue;
        }

        if ((fcntl_cmd = get_cmd(&fl)) == -1) {
            printf("invalid command!\n");
            continue;
        }

        if (fcntl(fd, fcntl_cmd, &fl) == -1)
            if (errno == EACCES || errno == EAGAIN)
                printf("Locked failed!...\n");
            else
                perror("fcntl");
        if (fcntl_cmd == F_GETLK)
            disp_flock(&fl);
    }

    close(fd);

    return 0;
}

void parse_cmd(void)
{
    char *str;

    g_count = 0;
    for (str = strtok(g_cmd, " \t"); str != NULL; str = strtok(NULL, " \t"))
        g_args[g_count++] = str;
}

int get_cmd(struct flock *fl)
{
    int cmd, type;

    if (!strcmp(g_args[0], "F_SETLK"))
        cmd = F_SETLK;
    else if (!strcmp(g_args[0], "F_SETLKW"))
        cmd = F_SETLKW;
    else if (!strcmp(g_args[0], "F_GETLK"))
        cmd = F_GETLK;
    else
        return -1;

    if (!strcmp(g_args[1], "F_RDLCK"))
        type = F_RDLCK;
    else if (!strcmp(g_args[1], "F_WRLCK"))
        type = F_WRLCK;
    else if (!strcmp(g_args[1], "F_UNLCK"))
        type = F_UNLCK;
    else
        return -1;

    fl->l_type = type;
    fl->l_whence = SEEK_SET;
    fl->l_start = (off_t)strtol(g_args[2], NULL, 10);
    fl->l_len = (off_t)strtol(g_args[3], NULL, 10);

    return cmd;
}

void disp_flock(const struct flock *fl)
{
    switch (fl->l_type) {
        case F_RDLCK:
            printf("Read Lock\n");
            break;
        case F_WRLCK:
            printf("Write Lock\n");
            break;
        case F_UNLCK:
            printf("Unlocked (can be locked)\n");
    }

    printf("Whence: %d\n", fl->l_whence);
    printf("Start: %ld\n", (long)fl->l_start);
    printf("Length: %ld\n", (long)fl->l_len);
    if (fl->l_type != F_UNLCK)
        printf("Process Id: %ld\n", (long)fl->l_pid);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* rw-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

/* ./rwtest <dosya ismi> <r/w> <offset> <uzunluk> */

int main(int argc, char *argv[])
{
    int fd;
    int operation;
    off_t offset;
    off_t len;
    char *buf;
    ssize_t result;

    if (argc != 5) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (strcmp(argv[2], "r") && strcmp(argv[2], "w")) {
        fprintf(stderr, "invalid operation!\n");
        exit(EXIT_FAILURE);
    }

    offset = (off_t)strtol(argv[3], NULL, 10);
    len = (off_t)strtol(argv[4], NULL, 10);

    if ((buf = (char *)calloc(len, 1)) == NULL) {
        fprintf(stderr, "cannot allocate memory!...\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], argv[2][0] == 'r' ? O_RDONLY : O_WRONLY)) == -1)
        exit_sys("open");

    lseek(fd, offset, SEEK_SET);
    if (argv[2][0] == 'r') {
        if ((result = read(fd, buf, len)) == -1)
            exit_sys("read");
        printf("%ld bytes read\n", (long)result);
    }
    else {
        if ((result = write(fd, buf, len)) == -1)
            exit_sys("write");
        printf("%ld bytes written\n", (long)result);
    }

    free(buf);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Dosyalardaki kilitleri izlemek için proc dosya sistemindeki /proc/locks dosyasından faydalanılabilmektedir. Örneğin:

    $ cat /proc/locks
    1: POSIX  ADVISORY  WRITE 34561 08:05:4194918 0 EOF
    2: POSIX  MANDATORY WRITE 57926 08:05:1207498 0 63
    3: POSIX  ADVISORY  READ 34560 00:36:103 0 EOF
    4: POSIX  ADVISORY  READ 34560 08:05:3031150 0 EOF
    5: POSIX  ADVISORY  READ 34560 08:05:3050341 0 EOF
    6: FLOCK  ADVISORY  WRITE 705 00:19:673 0 EOF

    Buradaki ilk sütun kilidin hangi fonksiyonlarla konulduğunu belirtmektedir. Bu sütunda POSIX belirteci kilidin fcntl ya da 
    lockf fonksiyonu ile konulduğunu belirtir. flock fonksiyonu Linux'a özgü olduğu için burada LINUX belirteci ile görüntülenecektir. 
    İkinci sütun kilidin isteğe bağlı mı zorunlu mu olduğunu belirtmektedir. Üçüncü sütun ise kilidin türünü belirtmektedir. 
    Dördüncü sütun kilidi koyan prosesin proses id'sini belirtmektedir. Sonraki sütun ':' karakterleriyle ayrılmış üç alandan 
    oluşmaktadır. İlk iki alan dosyanın içinde bulunduğu aygıtın majör ve minör numaralarını belirtmektedir. Üçüncü alanda 
    kilit uygulanan dosyanın i-node numarası belirtilmektedir. Sonraki iki sütunda da kilidin başlangıç offset'i ve uzunluğu
    belirtilmektedir.

    UNIX/Linux sistemlerinde dosyanın yol ifadesinden hareketle stat, fstat, lstat fonksiyonlarıyla biz dosyanın i-node
    numarasını elde edebiliriz. Ancak bunun tersini yapan bir mekanizma yoktur. Bu işlem ancak find utility'si ile arama 
    yöntemiyle yapılabilir. Örneğin:

    $ find / -inum 1207498 2> /dev/null

    Burada find utility'sine biz i-node numarası 1207498 olan dizin girişlerini kökten itibaren özyinelemeli biçimde aratmaktayız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dosya kilitleme için POSIX standartlarında lockf isimli bir fonksiyon da bulundurulmuştur. Bu fonksiyon aslında yukarıda 
    görmüş olduğumuz fcntl fonksiyonuna sarma yapan bir fonksiyondur. lockf fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    int lockf(int fd, int function, off_t size);

    Fonksiyonun birinci parametresi dosya betimleyicisini, ikinci parametresi uygulanacak lock işleminin türünü, üçüncü 
    parametresi ise kilitlenecek alanının uzunluğunu belirtmektedir. Fonksiyonda başlangıç offset'inin olmadığına dikkat ediniz.
    Fonksiyon her zaman dosya göstericisinin gösterdiği yerden itibaren kilitleme yapmaktadır. İkinci parametrede belirtilen 
    kilit türü şunlardan biri olabilir:

    Kilit Türü        fcntl Karşılığı            Anlamı

    F_ULOCK            F_SETLK, F_UNLCK        Kilidi kaldırır
    F_LOCK            F_SETLK, F_WRLCK        Blokesiz yazma kilidi yerleştirir
    F_TLOCK            F_SETLKW, F_WRLCK        Blokeli yazma kilidi yerleştirir
    F_TEST            F_GETLK                    Kilidin yerleştirilmiş olup olmadığına bakar

    Görüldüğü gibi fonksiyon her zaman "yazma (yani "exclusive")" bir kilit yerleştirmektedir. Dolayısıyla bu fonksiyon fcntl 
    fonksiyonuna göre daha yeteneksizdir. Programcılar tarafından pek tercih edilmemektedir.

    Fonksiyonun üçüncü parametresi 0 geçilirse bu durum "bulunulan offset'ten dosya sonuna kadar ve daha sonraki eklemeleri 
    kapsayacak biçimde" kilit yerleştirilmesi anlamına gelir. Eğer F_ULOCK işleminde bu parametre 0 girilirse bulunulan offset'ten 
    itibaren sonraki bütün kilitler kaldırılmaktadır. Fonksiyonun uzunluk belirten size parametresi negatif de girilebilir. 
    Bu durumda dosya göstericisinin gösterdiği yerden geriye doğru alan kilitlenir. Fonksiyon başarı durumunda 0 değerine, 
    başarısızlık durumunda -1 değerine geri dönmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar proc dosya sistemindeki bazı dosyaları hedefe yönelik biçimde gördük. Şimdi proc dosya sistemini 
    genel olarak ele almak istiyoruz. proc dosya sistemi disk tabanlı bir dosya sistemi değildir. Bu dosya sistemi bellek 
    tabanlıdır. Genellikle bu dosya sistemindeki bilgiler çekirdek modülleri ve aygıt sürücüler tarafından talep edildiğinde
    verilmektedir. proc dosya sistemi standart bir dosya sistemi değildir. Dolayısıyla bu dosya sistemi POSIX standartlarında 
    belirtilmemiştir. Linux gibi bazı UNIX türevi sistemler bu dosya sistemini desteklerken bazıları desteklememektedir. 
    (Örneğin macOS sistemleri proc dosya sistemini desteklememektedir.) proc dosya sistemi boot işlemi sırasında "/proc" dizinine 
    mount edilmektedir.

    proc dosya sistemindeki dosyaların ve dizinlerin listesi alındığında sanki onların uzunlukları "0" imiş gibi rapor edilmektedir. 
    Bunun nedeni bu dizindeki dosyaların içeriklerinin talep edildiğinde oluşturulmasıdır. Örneğin:

    $ ls -l /proc

    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 1
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 10
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 100
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 1001
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 1003
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 101
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 102
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 103
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 105
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 107
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 108
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 11
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 110
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 111
    dr-xr-xr-x  9 root             root                           0 Ağu 21 11:21 112
    ...

    proc dosya sistemi içerisinde dizinler ve dosyalar bulunmaktadır. Bu dizinlerin ve dosyaların nasıl oluşturulduğu aygıt 
    sürücülerin ele alındığı bölümde açıklanmaktadır.

    proc dosya sistemi çekirdeğin ve aygıt sürücülerin birtakım bilgileri dış dünyaya iletmesini basit bir biçimde sağlamaktadır. 
    Bu dosya sistemi sayesinde biz sistemde ne olup bittiğini buradaki dosyaların içeriklerini okuyarak anlayabiliriz. Gerçekten 
    de pek çok UNIX/Linux komutu aslında çekirdeğe ilişkin birtakım bilgileri bu dosya sisteminden elde etmektedir. Örneğin 
    "ps" komutu ile sistemdeki proseslerin bilgilerini elde edebiliyorduk. Aslında "ps" komutu bu bilgileri proc dosya sistemindeki
    dosyalardan elde etmektedir. Biz bazı konularda bazı bilgileri elde etmek için bu proc dosya sistemindeki birtakım dosyaları 
    kullanmıştık. proc dosya sistemindeki dosyaların bazıları yazmaya da izin vermektedir. Eğer sistem yöneticisi bu dosyalarda
    değişiklik yaparsa çekirdek ve aygıt sürücüler bu değişiklikleri dikkate alıp çalışmasını bu değişikliklere göre ayarlayabilmektedir.
    proc dosya sistemi içerisindeki dosyalar genel olarak "text dosyalar" biçimindedir. Yani bunların içeriklerini biz "cat" 
    komutuyla elde edebiliriz.

    proc dosya sisteminde iç içe pek çok dizin ve dosya bulunmaktadır. Biz burada bu dosya sisteminin genel içeriği hakkında 
    bazı bilgiler vereceğiz.

    proc dosya sisteminin kökünde (yani "/proc" dizininde) her proses için ayrı bir dizin yaratılmaktadır. Yaratılan dizinin 
    ismi prosesin id değeri biçimindedir. Yani örneğin biz bir programı çalıştırdığımızda yaratılan prosesin proses id'sine 
    ilişkin bir dizin "/proc" dizinin kökünde yaratılmaktadır:

    $ ./app
    press ENTER to exit...

    Şimdi yaratılan prosesin proses id'sine başka bir terminalden bakalım:

    $ ps -a
    PID TTY          TIME CMD
    16852 pts/0    00:00:00 app
    16854 pts/3    00:00:00 ps

    İşte çekirdek "/proc" dizininde "16852" ismiyle bir dizin yaratıp o ilgili prosesin tüm bilgilerini bu dizinin içerisine 
    yerleştirmektedir:

    $ ls -ld /proc/16852
    dr-xr-xr-x 9 kaan study 0 Ağu 27 13:40 /proc/16852

    Bu dizin içeriğini görüntülediğimizde aşağıdaki gibi bir dizin yapısıyla karşılaşmaktayız:

    $ ls /proc/16852
    arch_status  cmdline             environ  limits     mounts      oom_score      root       smaps_rollup  task
    attr         comm                exe      loginuid   mountstats  oom_score_adj  sched      stack         timens_offsets
    autogroup    coredump_filter     fd       map_files  net         pagemap        schedstat  stat          timers
    auxv         cpu_resctrl_groups  fdinfo   maps       ns          patch_state    sessionid  statm         timerslack_ns
    cgroup       cpuset              gid_map  mem        numa_maps   personality    setgroups  status        uid_map
    clear_refs   cwd

    Buradaki girişlerin bazıları "dizin" bazıları da dosyadır. Buradaki bazı dizin ve dosyalar hakkında kısa açıklamalar yapalım:

    - fd dizini prosesin açmış olduğu dosyalara ilişkin bilgileri bulundurmaktadır. Örneğin:

    $ ls -l
    toplam 0
    lrwx------ 1 kaan study 64 Ağu 27 14:00 0 -> /dev/pts/0
    lrwx------ 1 kaan study 64 Ağu 27 14:00 1 -> /dev/pts/0
    lrwx------ 1 kaan study 64 Ağu 27 14:00 2 -> /dev/pts/0

    Burada dosyaların sembolik bağlantı dosyaları olduğuna dikkat ediniz.

    - fdinfo isimli dizin içerisinde açılmış dosyaların bazı önemli bilgileri bulundurulmaktadır.

    - environ isimli dosya prosesin çevre değişken listesini bize vermektedir.

    - cmdline isimli dosyada program çalıştırılırken kullanılan komut satırı argümanları bulunmaktadır.

    proc dosya sisteminin kök dizininde sisteme ilişkin bilgi veren pek çok dosya dosya bulunmaktadır. Burada bunların
    birkaçı üzerinde duralım:

    - version isimli dosya yüklü olan çekirdek ve dağıtım hakkında temel bilgileri vermektedir.

    - devices dosyası yüklü olan aygıt sürücüler hakkında bilgiler vermektedir.

    - modules isimli dosya yüklü olan çekirdek modülleri hakkında bilgiler vermektedir.

    proc dosya sistemi oldukça fazla dizine ve dosyaya sahiptir. Bazı dosyalar özel birtakım konularla ilgilidir. Dolayısıyla 
    bu dosyaların ve dizinlerin "konuya göre gerektikçe öğrenilmesi" yoluna gidilebilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar read/write fonksiyonlarıyla klasik IO işlemleri yaptık. UNIX/Linux sistemlerinde bloke durumlarında 
    kullanılabilecek alternatif IO modelleri de vardır. Bunlara "ileri IO (advanced IO)" de denilmektedir. Bu bölümde özellikle 
    client-server programların gerçekleştirilmesinde kullanılabilecek ileri IO modelleri üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi ileri IO işlemlerine neden gereksinim duyulmaktadır? Client-server bir sistem için bir server programı yazacak olalım. 
    Server program N tane client'tan gelen istekleri okusun ve onlara yanıt göndersin. Haberleşme ortamı isimli borularla ya da 
    sonraki bölümde göreceğimiz soketlerle yapılabilmektedir. Ancak isimli borulardan ve soketlerden okuma yapılırken eğer boruda
    ya da sokette hiçbir bilgi yoksa read fonksiyonu bloke olmaktadır. Bu nedenle böyle bir program aşağıdaki gibi bir döngüyle 
    yazılamamaktadır:

    for (;;) {
        for (int i = 0; i < N; ++i) {
            read(...);
            write(...);
        }
        ...
    }

    Burada bir client'ın borusunda ya da soketinde hiç bilgi yoksa read fonksiyonu blokeye yol açacak ve diğer client'lardan 
    gelen bilgiler işleme sokulamayacaktır. Tabii bu durum yalnızca borular ve soketler için değil, bloke yok açan diğer kaynaklar 
    için de söz konusudur. Bu tür durumlarda ilk akla gelen şey blokesiz modda işlem yapmak olabilir. Örneğin:

    for (;;) {
        for (int i = 0; i < N; ++i) {
            result = read(...);
            if (result == -1 && errno == EAGAIN)
                continue;
            write(...);
        }
        ...
    }

    Burada problem çözülmüş gibi gözükmekle birlikte aslında başka bir sorun oluşmaktadır. Eğer hiçbir client'tan bilgi gelmemişse 
    burada "meşgul bir döngü (busy loop)" oluşmaktadır. Bu tür durumlarda akla gelen en basit çözüm "thread ya da proses" modelini 
    kullanmaktadır. Tabii proses yaratımı, thread yaratımına göre çok daha maliyetli olduğu için thread modeli tercih edilmektedir. 
    Bu modelde her client için ayrı bir thread (ya da proses) oluşturulur. O client'ın istekleri o thread (ya da proses) tarafından 
    sağlanır. Böylece bir client'a bilgi gelmediği zaman yalnızca o thread (ya da proses) bloke olacaktır. Diğerlerinin çalışması 
    devam edecektir. Bu model basitliği nedeniyle az sayıda client'ın bulunduğu durumlarda uygun bir yöntemdir. Ancak ölçeklenebilir 
    (scalable) değildir. Yani client sayısı arttığında çok fazla sistem kaynağı kullanılacağından dolayı olumsuzluk ortaya çıkacaktır.
    İşte ileri IO modelleri temel olarak yukarıdaki tarzda problemleri çözmek için geliştirilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX sistemlerinde ileri IO işlemleri dört bölüme ayrılarak incelenebilir:

    1) Multiplexed IO: Bu modelde bir grup betimleyici izlemeye alınır. Bu betimleyicilerde ilgilenilen olay (read/write/error) 
    gerçekleşmemişse blokede beklenir. Ta ki bu betimleyicilerden en az birinde ilgilenilen olay gerçekleşene kadar. Multiplexed 
    IO için select ve poll POSIX fonksiyonları kullanılmaktadır. Ancak Linux epoll isimli daha yetenekli bir fonksiyona da sahiptir.

    2) Sinyal Tabanlı (Signal Driven) IO: Burada belli betimleyiciler izlemeye alınır. Ancak blokede beklenmez. Bu betimleyicilerde 
    olay gerçekleştiğinde SIGIO isimli sinyal oluşur. Programcı da bu sinyal oluştuğunda blokeye maruz kalmadan read/write 
    işlemini yapılabilir.

    3) Asenkron IO: Burada read/write işlemleri başlatılır. Ancak bir bloke oluşmaz. Arka planda çekirdek tarafından okuma 
    ve yazma bir yandan devam ettirilir. Ancak aktarım bittiğinde programcı bundan haberdar edilir. Bunun signal driven IO'dan 
    farkı şudur: Signal tabanlı IO'da aktarım yapılmamaktadır. Yalnızca okuma yazma yapılırsa bloke olunmayacağı prosese söylenmektedir. 
    Halbuki asenkron IO'da okuma ve yazma işlemi bloke çözüldüğünde arka planda gerçekleştirilmekte ve yalnızca işlemin bittiği 
    haber verilmektedir.

    4) Scatter-Gather IO: Burada okuma birden fazla adrese, yazma ise birden fazla adresten kaynağa yapılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Multiplexed IO işlemlerinde select ve poll isimli POSIX fonksiyonları ve Linux sistemlerinde de Linux sistemlerine özgü 
    epoll fonksiyonu kullanılmaktadır. select fonksiyonu çok eskiden beri var olan klasik fonksiyonlardan biridir. select ilk 
    kez BSD sistemlerinde gerçekleştirilmiştir. POSIX standartları oluşturulduğunda doğrudan standartlarda bulundurulmuştur. Aslında
    select fonksiyonunun tasarımında bazı kusurlar vardır. Ancak fonksiyon hala en çok kullanılan ileri IO fonksiyonlarındandır.
    select fonksiyonunun prototipi şöyledir:

    #include <sys/select.h>

    int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);

    Fonksiyonun parametrelerindeki fd_set türü bir bit dizisi belirtmektedir. Bu bit dizisinin belli bitini 1 yapmak için
    FD_SET, belli bitini 0 yapmak için FD_CLR, tüm bitlerini sıfır yapmak için FD_ZERO, belli bitini test etmek için ise 
    FD_ISSET makroları kullanılmaktadır. Biz fonksiyonun ikinci (readfds), üçüncü (writefds) ve dördüncü (errorfds) parametrelerine 
    bir grup betimleyiciyi o betimleyicilerin numaralarına karşı gelen bitleri 1 yaparak veririz. Örneğin biz 18, 23 ve 47 numaralı
    betimleyicilerle ilgilenmek isteyelim. Bunun için fd_set veri yapısının 18, 23 ve 47 numaralı bitlerini 1 yaparız. Fonksiyonun 
    ikinci parametresi (readfds) "okuma amaçlı izlenecek betimleyicilerin kümesini", üçüncü parametresi (writefds) "yazma 
    amaçlı izlenecek betimleyicilerin kümesini" ve dördüncü parametresi (errorfds) ise "hata (exception) oluşumu için izlenecek 
    betimleyicilerin kümesini" belirtmektedir. Bu parametrelerin biri ya da birden fazlası NULL geçilebilir. Bu durum ilgili 
    izlemenin yapılmayacağını belirtmektedir. Fonksiyonun birinci parametresi bu kümelerdeki en yüksek betimleyicinin bir fazla 
    değerini almaktadır. Bu parametre aslında işlemleri hızlandırmak için düşünülmüştür. En yüksek betimleyici değeri 
    FD_SETSIZE (1024) ile define edilmiş durumdadır. (Yani bu parametreye istersek doğrudan bu değeri de geçebiliriz.) Örneğin 
    biz 18, 23 ve 47 numaralı betimleyicileri izlemek istiyorsak bu birinci parametreye 48 değerini (47 + 1) girebiliriz. Ancak 
    buraya en yüksek betimleyici değeri olan FD_SETSIZE girilse de bir sorun oluşmayacaktır. Yukarıda da belirttiğimiz gibi 
    bu birinci parametre yalnızca işlemleri hızlandırmak için bir ipucu niteliğindedir.

    Fonksiyonun son parametresi "zaman aşımı" belirtmektedir. Zaman aşımı için NULL adres girilebilir. Bu durum zaman aşımının
    uygulanmayacağı anlamına gelir. timeval yapısını biz daha önce kullanmıştık. Anımsatmak istiyoruz:

    struct timeval {
        time_t        tv_sec;
        suseconds_t tv_usec;
    };

    Bu yapı mikrosaniye çözünürlüğünde bir zaman aralığı belirtmek için oluşturulmuştur. Yapının her iki elemanı 0'da girilebilir. 
    Bu durumda select fonksiyonu hemen testini yapar ve geri döner.

    select fonksiyonu ile bir grup betimleyiciyi okuma amaçlı izlemek isteyelim. İlk yapacağımız şey izlenecek betimleyicileri 
    bir fd_set nesnesi içerisinde belirtmek ve bu nesnesin adresini fonksiyonun ikinci parametresine vermektir. Birinci parametreye 
    de buradaki en yüksek betimleyici değerinin 1 fazlası geçirilecektir. Örneğin:

    fd_set rset;
    ...

    FD_ZERO(&rset);
    FD_SET(fd1, &rset);        // fd1 = 18 varsayalım
    FD_SET(fd2, &rset);        // fd2 = 23 varsayalım
    FD_SET(fd3, &rset);        // fd3 = 48 varsayalım

    maxfds = getmax(fd1, fd2, fd3);

    select(maxfds + 1, &rset, NULL, NULL, NULL);

    select fonksiyonu bizim ona verdiğimiz betimleyicileri okuma amaçlı izler. Bu betimleyicilere hiçbir bilgi gelmemişse select 
    akışı blokede bekletmektedir. Ancak bu betimleyicilerin en az birine bir bilgi geldiyse bu durumda select blokeyi çözmektedir. 
    Görüldüğü gibi select fonksiyonu "okunacak hiçbir bilgi betimleyicilerde oluşmamışsa akışı blokede bekletmekte ancak en az bir 
    betimleyicide okunacak bilgi oluşmuşsa okuma işleminin yapılması için blokeyi çözmektedir. select fonksiyonun okumayı yapmadığına 
    yalnızca okuma yapılabilecek bir durumun oluştuğunu tespit ettiğine dikkat ediniz. Tabii programıcının select'in blokesi 
    çözüldüğünde hangi betimleyicilere bilgi gelmiş olduğunu anlaması gerekir. Çünkü gelen bilgileri read ile o betimleyicilerden 
    okuyacaktır. Tabii select fonksiyonu aslında bir kez değil, genellikle bir döngü içerisinde kullanılmaktadır.

    Pekiyi select blokeyi çözdüğünde programcı ne yapmalıdır? Örneğin biz yine 18, 23 ve 48 numaralı betimleyicileri okuma amaçlı
    izlemek isteyelim. select fonksiyonu 23 numaralı betimleyiciye bilgi geldiğinden dolayı blokeyi çözmüş olsun. Bizim bunu 
    anlayıp 23 numaralı betimleyiciden read fonksiyonu ile (ya da soketler söz konusu ise recv ya da recvfrom fonksiyonları ile) 
    okuma yapmamız gerekir. İşte select bizim ona verdiğimiz fd_set nesnelerini çıkışta yeniden uygun biçimde set etmektedir. 
    Hangi betimleyicilerde ilgili olay gerçekleşmişse o betimleyicilere ilişkin bitleri set edip diğerlerini reset etmektedir. 
    Yani select bizim ona verdiğimiz fd_set nesnelerinin içeriğini bozup ilgili olayın gerçekleştiği betimleyicileri o nesnelerde 
    belirtmektedir. O halde bizim select fonksiyonu geri döndüğünde bu fd_set nesnelerinin bitlerine bakıp hangi betimleyiciye 
    ilişkin bitlerin set edildiğini anlamamız ve onlardan okuma yapmamız gerekir. select ile beklerken birden fazla betimleyicide 
    olayın gerçekleşmiş olabileceğine dikkat ediniz. Bu nedenle kontrolü else-if ile değil, ayrık if deyimleriyle yapmalısınız. 
    Aşağıdaki kod parçasında üç betimleyici select ile izlenmiş, select fonksiyonunun blokesi çözüldüğünde bu betimleyicilere ilişkin 
    bitler tek tek FD_ISSET makrosu ile kontrol edilmiştir. Hangi betimleyicide okuma olayı gerçekleşmişse read fonksiyonu ile o 
    betimleyiciden okuma yapılmıştır. Bu noktada artık read fonksiyonunun blokeye yol açmayacağına dikkat ediniz.

    fd_set rset;
    ...

    FD_ZERO(&rset);
    FD_SET(fd1, &rset);        // fd1 = 18 varsayalım
    FD_SET(fd2, &rset);        // fd2 = 23 varsayalım
    FD_SET(fd3, &rset);        // fd3 = 48 varsayalım

    maxfds = getmax(fd1, fd2, fd3);

    if (select(maxfds + 1, &rset, NULL, NULL, NULL) == -1)
        exit_sys("select");

    if (FD_ISSET(fd1, &rset)) {
        result = read(fd1, ...);
        ...
    }
    if (FD_ISSET(fd2, &rset)) {
        result = read(fd2, ...);
        ...
    }
    if (FD_ISSET(fd3, &rset)) {
        result = read(fd3, ...);
        ...
    }

    Programcı select yoluyla çok sayıda betimleyiciyi izliyorsa select çıkışında onlar için ayrı if deyimleriyle kontrol yapmak 
    yorucu olabilmektedir. Bu durumda iki yol izlenebilir. Birincisi tüm betimleyicileri bir döngü içerisinde kontrol etmektir:

    ...
    if (select(maxfds + 1, &rset, NULL, NULL, NULL) == -1)
        exit_sys("select");

    for (int fd = 0; fd <= maxfds; ++fd)
        if (FD_ISSET(fd, &rset)) {
            result = read(fd, ...);
            ...
        }

    Burada 0'dan maxfds değerine kadar rset nesnesindeki tüm bitlere bakılmış ve set edilen bitlere ilişkin betimleyicilerden 
    okuma yapılmıştır. İkinci yöntem, izlenecek betimleyicileri aynı zamanda bir diziye yerleştirmektir. Örneğin:

    fd_set rset;
    int fds[3];
    ...

    fds[0] = fd1;
    fds[1] = fd2;
    fds[2] = fd3;
    ...
    FD_ZERO(&rset);

    for (int i = 0; i < 3; ++i)
        FD_SET(fds[i], &rset);

    maxfds = getmax(fds, 3);

    if (select(maxfds + 1, &rset, NULL, NULL, NULL) == -1)
        exit_sys("select");

    for (int i = 0; i < 3; ++i)
        if (FD_ISSET(fds[i], &rset)) {
            result = read(fds[i], ...);
            ...
        }

    Burada izlenecek betimleyicilerin numaraları fds dizisine yerleştirilmiştir. select geri döndüğünde yalnızca fds dizisindeki 
    betimleyicilere ilişkin bitler FD_ISSET makrosuyla kontrol edilmiştir.

    Yukarıda da belirttiğimiz gibi select fonksiyonu genel olarak bir döngü içerisinde kullanılmaktadır. Fonksiyonu döngü 
    içerisinde kullanırken bizim ona verdiğimiz fd_set kümesinin bozulacağına, dolayısıyla döngünün başında onun yeniden yüklenmesi 
    gerektiğine dikkat ediniz. Örneğin:

    fd_set rset, orset;
    ...

    FD_ZERO(&rset);
    FD_SET(fd1, &rset);        // fd1 = 18 varsayalım
    FD_SET(fd2, &rset);        // fd2 = 23 varsayalım
    FD_SET(fd3, &rset);        // fd3 = 48 varsayalım

    maxfds = getmax(fd1, fd2, fd3);

    for (;;) {
        orset = rset;
        if (select(maxfds + 1, &orset, NULL, NULL, NULL) == -1)
            exit_sys("select");

        if (FD_ISSET(fd1, &orset)) {
            read(fd1, ...);
        }
        if (FD_ISSET(fd2, &orset)) {
            read(fd2, ...);
        }
        if (FD_ISSET(fd3, &orset)) {
            read(fd3, ...);
        }
    }

    Burada her döngünün başında izlemenin yapılacağı rset nesnesi orset (output rset) nesnesine atanmıştır. Böylece her defasında 
    orset izlenmesi gereken betimleyicileri belirtmektedir. İki fd_set nesnesi birbirine atanabilmektedir. (fd_set türü tipik 
    olarak bir yapı biçiminde oluşturulmuştur. İki yapı nesnesi birbirine atandığında karşılıklı elemanların atanacağına dikkat 
    ediniz.)

    Pekiyi boru, soket gibi betimleyicilerden select eşliğinde okuma yapılırken karşı taraf bu betimleyicileri kapatırsa ne olacaktır?
    İşte bu durumda select fonksiyonu sanki o betimleyicide "okuma" olayı varmış gibi davranmaktadır. Örneğin boruyu karşı taraf 
    kapattığında select fonksiyonu okuma olayı gerçekleşmiş gibi geri döner, biz de read fonksiyonu ile 0 byte okuruz ve artık
    karşı tarafın boruyu kapatmış olduğunu anlarız.

    select ile çok sayıda betimleyiciyi izlerken bu betimleyicileri karşı taraf kapattığında biz de read fonksiyonu ile bunu 
    anladığımızda artık betimleyiciyi okuma kümesinden çıkartmamız gerekir.

    select fonksiyonu başarısızlık durumunda -1 değerine geri döner. Eğer hiçbir betimleyicide olay gerçekleşmemiş, ancak zaman 
    aşımı dolmuşsa fonksiyon 0 değerine geri dönmektedir. Eğer en az bir betimleyicide ilgili olay gerçekleşmişse select fonksiyonu 
    bu durumda toplam gerçekleşen olay sayısına geri dönmektedir. (Aynı betimleyici örneğin hem okuma hem de yazma için izleniyorsa 
    ve bu betimleyicide hem okuma hem de yazma olayı gerçekleşmişse bu değer 2 artırılmaktadır.) Fonksiyonun geri dönüş değeri 
    genellikle programcılar tarafından kullanılmamaktadır.

    select fonksiyonunun normal disk dosyaları için kullanılması anlamsızdır. Eğer select normal disk dosyaları için kullanılırsa 
    select her zaman olay gerçekleşmiş gibi geri dönecektir. select fonksiyonu uzun süre beklemeye yol açabilecek terminal 
    gibi, boru gibi, soket gibi aygıtlar için kullanılmalıdır. Normal olarak select ile beklenecek betimleyicilere ilişkin 
    kaynaklar "blokeli" modda açılmalıdırlar. select blokeyi kendisi uygulamaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                89. Ders 14/10/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda select fonksiyonunun kullanımına basit bir örnek verilmiştir. Bu örnekte select ile stdin dosyası (0 numaralı
    betimleyici) okuma amaçlı izlenmektedir. Klavyeden giriş yapılıp ENTER tuşuna basıldığında select blokeyi çözmekte ve 
    read ile artık bloke olmadan okuma yapılabilmektedir. select fonksiyonunun tek bir betimleyici için kullanılmasının 
    bir anlamı yoktur. Bu örnek yalnızca select fonksiyonunun kullanımını ana hatlarıyla açıklamak için verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/select.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    fd_set rset, orset;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;

    FD_ZERO(&rset);
    FD_SET(0, &rset);

    for (;;) {
        orset = rset;
        if (select(0 + 1, &orset, NULL, NULL, NULL) == -1)
            exit_sys("select");

        if (FD_ISSET(0, &orset)) {
            if ((result = read(0, buf, BUFFER_SIZE)) == -1)
                exit_sys("read");
            if (result == 0)
                break;

            buf[result] = '\0';
            printf("%s", buf);
        }
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir grup betimleyici select fonksiyonu ile izlenirken karşı taraf ilgili betimleyiciyi kapatırsa ne olacaktır? Örneğin 
    biz select fonksiyonu ile isimli boruları ya da soketleri izleyebiliriz. Böylece borunun ya da soketin karşı tarafındakilerin
    yazdıklarını etkin bir biçimde elde edebiliriz. Pekiyi ya karşı taraf boruyu ya da soketi kapatırsa ne olacaktır. İşte
    yukarıda da belirttiğimiz gibi karşı taraf boru ya da soketi kapattığında select sanki "okuma" olayı oluşmuş gibi davranır. 
    Biz de bunu read fonksiyonu ile anlarız (read bu durumda 0 ile geri dönecektir). Böylece kendi betimleyicimizi kapatıp 
    ilgili betimleyiciyi de izleme listesinden çıkartırız.

    Aşağıdaki örnekte program komut satırı argümanlarıyla aldığı isimli boruları okuma amacıyla select fonksiyonuyla izlemektedir. 
    İsimli boruların O_RDONLY modda açılması sırasında karşı taraf boruyu O_WRONLY modunda (ya da O_RDWR modunda) açana kadar
    open fonksiyonunun blokeye yol açtığını anımsayınız. Bu programı kullanırken önce mkfifo komutuyla isimli boruları yaratmalısınız. 
    Örneğin:

    $ mkfifo x y Z

    Burada x, y ve z isimli boruları yaratılacaktır. Daha sonra programı bu isimli boruların yol ifadeleriyle çalıştırmalısınız. 
    Örneğin:

    $ ./sample x y z

    Artık bu isimli borular açıldığında program bir döngü içerisinde select fonksiyonunda bekleyecektir. Bu borulardan herhangi 
    birine yazma yapıldığında select blokesi çözülecek ve artık program o borudan okuma yapacaktır. Bütün borular kapatıldığında
    program sonlandırılmaktadır.

    Aşağıdaki programı test etmek için en pratik yöntem başka terminaller açarak cat programını borulara yönlendirerek çalıştırmaktır. 
    Örneğin:

    $ cat > x

    Artık klavyeden bir şeyler yazıp ENTER tuşuna bastığımızda cat onu boruya yazacaktır. cat programından Ctrl+D tuşu ile 
    çıkabilirsiniz. Tabii aslında cat programı Ctrl+C ile sinyal yoluyla sonlandırılsa da bir sorun oluşmayacaktır. Bir 
    proses nasıl sonlanırsa sonlansın işletim sistemi o prosesin açmış olduğu dosyaları kapatmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/select.h>

#define BUFFER_SIZE        4096
#define MAX_SIZE        4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    fd_set rset, orset;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;
    int fds[MAX_SIZE];
    int maxfd;
    int count;

    if (argc == 1) {
        fprintf(stderr, "too few arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("opens named pipes... it may block...\n");

    FD_ZERO(&rset);

    maxfd = -1;
    for (int i = 1; i < argc; ++i) {
        if ((fds[i] = open(argv[i], O_RDONLY)) == -1)
            exit_sys("open");
        printf("%s opened...\n", argv[i]);
        if (fds[i] > maxfd)
            maxfd = fds[i];

        FD_SET(fds[i], &rset);
        ++count;
    }

    for (;;) {
        orset = rset;
        printf("waiting at select...\n");
        if (select(maxfd + 1, &orset, NULL, NULL, NULL) == -1)
            exit_sys("select");

        for (int i = 0; i <= maxfd; ++i)
            if (FD_ISSET(fds[i], &orset)) {
                if ((result = read(fds[i], buf, BUFFER_SIZE)) == -1)
                    exit_sys("read");
                if (result == 0) {
                    printf("peer closed descriptor...\n");
                    close(fds[i]);
                    FD_CLR(fds[i], &rset);
                    --count;

                    if (count == 0)
                        goto EXIT;
                }

                buf[result] = '\0';
                printf("%s", buf);
            }
    }
EXIT:

    printf("there is no descriptor open, finishes...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    select fonksiyonu en çok okuma amaçlı izlemede kullanılmaktadır. Pekiyi yazma amaçlı izleme nedir? İşte bazı aygıtlar 
    yazma sırasında da blokeye yol açabilmektedir. Örneğin biz borulara write fonksiyonu ile yazma yaptığımızda eğer boru
    tamamen doluysa boruda yer açılana kadar blokede bekleriz. Ancak bu bizim diğer borulara yazma yapmamızı engelleyebilir. 
    O zaman biz select fonksiyonunu yazma izlemesi için de kullanabiliriz. Örneğin select fonksiyonuna biz üç boru betimleyicisini
    yazma izlemesi için vermiş olalım. select boruda yer açılınca blokeyi çözecek ve yazma yapılabilecek betimleyicileri yine
    okumadaki gibi set edecektir. Biz de okumadakine benzer bir biçimde hangi boruda boşluk oluştuysa ona yazma yaparız. 
    (Borularda tüm bilgi boruya yazılana kadar bloke oluşmaktadır. select az bir byte yazabilme durumunda blokeyi çözmektedir. 
    Tabii okuyan taraf da aynı miktar bilgiyi okuyorsa burada yine sorun çıkmayacaktır.) Benzer biçimde soketlere yazma yapılırken 
    yazılan bilgiler önce network tamponuna yazılmaktadır. Eğer bu tampon doluysa yine bloke oluşmaktadır. Görüldüğü gibi 
    okumadaki benzer bloke problemi yazmada da ortaya çıkabilmektedir.

    Borularda önce yazan tarafın boruyu kapatması gerekmektedir. Ancak okuyan taraf boruyu kapatırsa yazan taraf boruya 
    yazma yaptığında SIGPIPE sinyalinin oluştuğunu anımsayınız. select fonksiyonunda okuyan taraf boruyu kapatırsa yazma
    takibinde sanki bir yazma olayı varmış gibi durum oluşmaktadır. Tabii bu durumda select geri dönünce yazma yapılırsa yine 
    SIGPIPE sinyali oluşturulacaktır. Aynı durum aslında soketlerde de söz konusudur.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    select fonksiyonunun dördüncü parametresi olan "errorfds" ne anlama gelmektedir?

    int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);

    Bu parametre programcılar tarafından genellikle yanlış anlaşılmaktadır. İsminden dolayı sanki betimleyicide bir hata 
    izlemesinin yapılacağı sanılmaktadır. Oysa bu parametre çok kısıtlı bir kullanıma sahiptir. Borularda bu parametrenin 
    bir etkisi yoktur. Soketlerde ise "out of band data" oluştuğunda bir etkisi olmaktadır. Yani bu parametre bulunuyor 
    olsa da önemli bir kullanıma sahip değildir. Dolayısıyla genellikle NULL geçilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    select fonksiyonunun son parametresi zaman aşımı belirtmektedir. Zaman aşımı "en kötü olasılıkla blokenin ne kadar süreceğini"
    belirtir. select eğer zaman aşımından dolayı sonlanırsa 0 değerine geri dönmektedir. Bu zaman aşımı parametresi NULL geçilirse
    bu durum herhangi bir zaman aşımının uygulanmayacağı anlamına gelir. Linux sistemlerinde bu zaman aşımı parametresi girilirse
    çıkışta bu elemana "kalan zaman" set edilmektedir. Ancak POSIX standartları bu davranışı garanti etmemektedir.

    select fonksiyonundaki zaman aşımı parametresi mikrosaniye duyarlılığındadır. Ancak pek çok işletim sistemi bu duyarlılıkta 
    işlem yapamamaktadır. timeval yapısını yeniden anımsatmak istiyoruz:

    struct timeval {
        time_t      tv_sec;            /* seconds */
        suseconds_t tv_usec;        /* microseconds */
    };

    Eskiden UNIX türevi sistemlerde yüksek çözünürlüklü bekleme yapan nanosleep ve clock_nanosleep fonksiyonları yoktu. 
    Programcılar da bu amaçla select fonksiyonunu kullanabiliyordu. Eğer select fonksiyonunun izleme parametrelerinin hepsine
    NULL geçilirse ancak zaman aşımı parametresine belli bir süre girilirse fonksiyon sanki mikrosaniye duyarlılığına sahip 
    sleep gibi çalışmaktadır. Tabii buradaki duyarlılık sistemlerde sağlanamayabiliyordu. Örneğin:

    struct timeval tv;
    ...

    tv.tv_sec = 3;
    tv.tv_usec = 500000;

    printf("waiting at sleep for 3.5 second...\n");

    if (select(0, NULL, NULL, NULL, &tv) == -1)
        exit_sys("select");
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/select.h>

void exit_sys(const char *msg);

int main(void)
{
    struct timeval tv;

    tv.tv_sec = 3;
    tv.tv_usec = 500000;

    printf("waiting at sleep for 3.5 second...\n");

    if (select(0, NULL, NULL, NULL, &tv) == -1)
        exit_sys("select");

    printf("Ok\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    select fonksiyonunda kullanılan fd_set bit dizisi en fazla FD_SETSIZE kadar biti içermektedir. Linux sistemlerinde FD_SETSIZE
    1024 olarak define edilmiştir. Dolayısıyla Linux sistemlerinde select fonksiyonu ile ancak ilk 1024 betimleyici izlenebilir. 
    Biz setrlimit fonksiyonu ile dosya betimleyici tablomuzu büyütsek bile select fonksiyonu yalnızca ilk 1024 betimleyici ile
    çalışmaya devam edecektir. Bunun için çeşitli çözümler uyduruldaysa da bunların hiçbiri genel ve taşınabilir değildir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    select fonksiyonunun pselect isminde sigset_t parametreli bir biçimi de vardır:

    #include <sys/select.h>

    int pselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timespec *timeout,
            const sigset_t *sigmask);

    Fonksiyon sigmask parametresiyle aldığı sinyal kümesini thread'in sinyal bloke kümesi yapar. Böylece fonksiyon çalıştığı 
    sürece bazı sinyaller bloke edilebilmekte ya da onların blokesi açılabilmektedir. Fonksiyon sonlandığında eski sinyal bloke
    kümesini yeniden thread'in sinyal bloke kümesi olarak set edilmektedir. Yani buraya girilecek sinyal bloke kümesi fonksiyon 
    çalıştığı sürece etkili olmaktadır. Bu parametre NULL adres geçilirse fonksiyonun pselect fonksiyonundan bir farkı kalmaz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    poll fonksiyonu select fonksiyonun alternatifi olan bir fonksiyondur. select ile poll aynı amaçlarla kullanılmaktadır. 
    Fakat bu iki fonksiyonun parametrik yapıları ve kullanılma biçimleri farklıdır. Daha önceden de belirttiğimiz gibi select
    fonksiyonu BSD sistemlerinde tasarlanmışken poll fonksiyonu klasik AT&T UNIX sistemlerinde tasarlanmıştır. Tabii bu iki 
    fonksiyon da ilk zamandan beri POSIX standartlarında bulunmaktadır.

    poll fonksiyonu bazı bakımlardan select fonksiyonundan daha iyi gibi gözükmektedir. Ancak poll fonksiyonunun kullanımı 
    biraz daha zordur.

    poll fonksiyonunun prototipi şöyledir:

    #include <poll.h>

    int poll(struct pollfd fds[], nfds_t nfds, int timeout);

    poll fonksiyonu izlenilecek betimleyicileri bit dizisi olarak değil, bir yapı dizisi olarak almaktadır. Fonksiyonun birinci 
    parametresi pollfd türünden bir yapı dizisinin adresini, ikinci parametresi ise onun uzunluğunu almaktadır. Son parametre 
    milisaniye cinsinden zaman aşımını belirtir. Bu parametre -1 girilirse zaman aşımı uygulanmaz, 0 girilirse fonksiyon 
    betimleyicilerin durumuna bakıp hemen geri döner. pollfd yapısı şöyle bildirilmiştir:

    struct pollfd {
        int fd;                /* file descriptor */
        short events;        /* requested events */
        short revents;        /* returned events */
    };

    Yapının fd elemanı izlenecek betimleyiciyi, events elemanı izleme biçimini belirtmektedir. Eğer bu betimleyici değeri negatif 
    herhangi bir değer olarak girilirse o betimleyici için izleme yapılmamaktadır. Dolayısıyla pollfd dizisinden bir elemanı 
    mantıksal olarak çıkartmak için bu betimleyici negatif bir değere çekilebilir. Programcı poll fonksiyonunu çağırmadan önce bu 
    iki elemana değer yerleştirmelidir. Ancak yapının revents elemanı fonksiyon geri döndüğünde oluşan olay hakkında bilgi vermektedir. 
    Bu eleman programcı tarafından events elemanında set edilmez, fonksiyon tarafından revents elemanında set edilir. (Bu sayede yapının 
    elemanlarının bozulmadığına dikkat ediniz.) 

    En önemli izleme olayları şunlardır:

    POLLIN: Okuma amaçlı izlemeyi belirtir. Boruda ya da sokette okunacak bilgi oluştuğunda fonksiyon tarafından bu bayrak 
    set edilmektedir. Soketlerde accept yapan tarafta bir bağlantı isteği oluştuğunda da POLLIN bayrağı set edilmektedir. 
    Aynı zamanda soketlerde karşı taraf soketi kapattığında da POLLIN bayrağı set edilmektedir.

    POLLOUT: Yazma amaçlı izlemeyi belirtir. Boruya ya da sokete yazma durumu oluştuğunda (yani boruda ya da network tamponunda yazma 
    için yer açıldığında) fonksiyon tarafından bu bayrak set edilmektedir. Aynı zamanda soketlerde karşı taraf soketi kapattığında da 
    POLLOUT bayrağı set edilmektedir.

    POLLERR: Hata amaçlı izlemeyi belirtir. Bu bayrak yapının events elemanında set edilmez, fonksiyon tarafından yapının revents 
    elemanında set edilmektedir. Bu bayrak borularda okuma yapan tarafın boruyu kapatmasıyla yazma yapan tarafta set edilmektedir. 
    (Normal olarak okuyan tarafın boruyu kapattığı durumda boruya yazma yapıldığında SIGPIPE sinyalinin oluştuğunu anımsayınız.) 
    Eğer okuyan taraf boruyu kapattığında boruya yazma için yer varsa yazma yapan tarafta aynı zamanda POLLOUT bayrağı da set edilmektedir. 
    POLLERR bayrağı soketlerde kullanılmamaktadır.

    POLLHUP: Boruya yazan tarafın boru betimleyicisini kapattığında okuma yapan tarafta bu bayrak set edilmektedir. Bu bayrak yapının 
    events elemanında set edilmez, fonksiyon tarafından yapının revents elemanında set edilmektedir. (HUP, "hang up" anlamına gelmektedir.) 
    Eğer boruya yazma yapan taraf boruyu kapattığında hala boruda okunacak bilgi varsa okuma yapan tarafta aynı zamanda POLLIN bayrağı 
    da set edilmektedir. POLLHUP bayrağı soketlerde kullanılmamaktadır.

    POLLRDHUP: Soketlerde karşı taraf soketi kapattığında ya da shutdown fonksiyonu SHUT_WR argümanıyla çağrıldığında oluşur.

    POLLNVAL: Bu bayrak yapının events elemanında set edilmez. Fonksiyon tarafından eğer izlenen bir betimleyici kapalıysa 
    yapının revents elemanında fonksiyon tarafından set edilmektedir.

    Bu bayraklar bit OR işlemine sokulabilmektedir. Örneğin hem okuma hem de yazma izlemesi için POLLIN|POLLOUT kullanılabilir.

    Bayrakların anlamları için "The Linux Programming Interface" kitabından şu tabloları da vermek istiyoruz:

    Boruda bilgi yok ve yazan tarafın betimleyicisi kapalı ===> Okuyan tarafta POLLHUP
    Boruda bilgi var ve yazan tarafın betimleyicisi kapalı ===> Okuyan tarafta POLLIN|POLLHUP
    Boruda bilgi var ve yazan tarafın betimleyicisi açık ===> Okuyan tarafta POLLIN

    Boruda yazma için yer yok ve okuyan tarafın betimleyicisi kapalı ===> Yazan tarafta POLLERR
    Boruda yazma için yer var ve okuyan tarafın betimleyicisi kapalı ===> Yazan tarafta POLLOUT|POLLERR
    Boruda yazma için yer var ve okuyan tarafın betimleyicisi açık ===> Yazan tarafta POLLOUT

    Sokette bilgi var ===> Okuyan tarafta POLLIN
    Network tamponunda yazacak yer var ===> Yazan tarafta POLLOUT
    accept yapan tarafta bağlantı isteği oluştuğunda ===> accept yapan tarafta POLLIN
    Karşı taraf soketi kapattığında ===> karşı tarafta POLLIN|POLLOUT|POLLRDHUP

    Geri döndürülen olayların birden fazlası birlikte gerçekleşmiş olabilir. Bu nedenle programcının kontrolü else-if ile 
    değil, ayrık if deyimleriyle yapması gerekir. Okuyan taraf boruları ve soketleri kapatırsa bu durum poll fonksiyonunda POLLERR 
    olayı biçiminde ele alınmaktadır. Programcının POLLHUP ve POLLERR bayraklarını yapının events elemanında set etmesi gerekmemektedir. 
    Bu bayraklar gerektiğinde fonksiyon tarafından yapının revents elemanında set edilmektedir. Borular kapatıldığında seyrek de 
    olsa hem POLLIN hem de POLLHUP olayları birlikte gerçekleşebilmektedir. Karşı taraf bir boruyu kapatıldığında POLLHUP 
    oluştuktan sonra yeniden karşı tarafı kapalı olan boru poll işlemi uygulanırsa yine POLLHUP olayı gerçekleşmektedir. Yani 
    karşı tarafın borusu kapalıysa artık her defasında POLLHUP olayı gerçekleşir.

    poll fonksiyonuna geçersiz bir betimleyici ya da açık olmayan bir betimleyici girilmişse poll fonksiyonu o betimleyici için 
    POLLNVAL olayı oluşturmaktadır. Bu nedenle kapatılmış betimleyicilerin ya negatif bir değere çekilmesi ya da diziden çıkartılması 
    gerekir.

    Server uygulamalarında programcı yine tipik olarak poll fonksiyonunu bir döngü içerisinde çağırır. Döngüden çıkışta dizinin 
    tüm elemanlarının revents elemanını uygun olay için kontrol eder. Eğer bir betimleyici üzerinde hiçbir olay gerçekleşmemişse revents 
    elemanı 0 değerinde olacaktır. Örneğin okuma amaçlı nfds kadar betimleyiciyi poll fonksiyonu ile izlemek isteyelim. İzlenecek 
    betimleyici bilgilerinin pfds isimli dizi de olduğuna varsayalım. poll sonrasındaki kontrol şöyle yapılabilir (kontroller uygulanmamıştır):

    poll(pfds, nfds, -1);

    for (int i = 0; i < nfds; ++i) {
        if (pfds[i].revents & POLLIN) {
            read(pfds[i].fd, ...);
            ...
        }
        if (pfds[i].revents & POLLOUT) {
            read(pfds[i].fd, ...);
            ...
        }
        ...
    }

    Görüldüğü gibi dizinin hangi elemanlarında olay gerçekleştiği bilinmemektedir. (select fonksiyonunda da bizim tek tek
    betimleyicilere FD_ISSET makrosuyla baktığımızı anımsayınız.)

    poll fonksiyonu başarı durumunda bizim dizideki olay gerçekleşen eleman sayısına (olay sayısına değil) geri dönmektedir. 
    Fonksiyon zaman aşımından dolayı sonlanmışsa 0 değerine geri dönmektedir. Zaman aşımı 0 verildiyse ve hiçbir olay 
    gerçekleşmemişse fonksiyon yine 0 değerine geri dönmektedir. Fonksiyon başarısızlık durumunda -1 değerine geri döner ve 
    errno değişkeni uygun biçimde set edilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                90. Ders 15/10/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda poll fonksiyonunun stdin üzerinde basit bir kullanımına örnek verilmiştir. poll fonksiyonu terminal ile kullanılırken
    Ctrl+d tuşlarına basıldığında POLLHUP olayı değil, POLLIN olayı gerçekleşmektedir. Dolayısıyla aşağıdaki kodda döngüden read
    fonksiyonu ile 0 byte okunduğunda çıkılmaktadır. Ctrl+d tuşlarına basıldığında EOF etkisi oluşturulmakta ve read fonksiyonu 
    0 byte okumaktadır. Ancak izleyen paragraflarda görüleceği gibi borular kapatıldığında poll fonksiyonu POLLHUP olayı 
    oluşturmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <poll.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    char buf[BUFFER_SIZE + 1];
    ssize_t result;
    struct pollfd pfds[1];

    pfds[0].fd = 0;
    pfds[0].events = POLLIN;

    for (;;) {
        if (poll(pfds, 1, -1) == -1)
            exit_sys("poll");

        if (pfds[0].revents & POLLIN) {
            if ((result = read(pfds[0].fd, buf, BUFFER_SIZE)) == -1)
                exit_sys("read");
            if (result == 0)
                break;
            buf[result] = '\0';
            printf("%s", buf);
        }
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de gerçek bir server uygulamasına benzer biçimde bir grup isimli borudan poll fonksiyonu ile okuma yapmaya çalışalım.
    Aşağıdaki örnek daha önce select fonksiyonuyla yaptığımız örneğin poll versiyonudur. Yani bu örnekteki program yine bir 
    grup isimli boru, komut satırı argümanı yapılarak çalıştırılmalıdır. Örneğin:

    $ ./sample x y z

    Örneğimizde önce borular açılıp pfds dizisi oluşturulmuştur:

    struct pollfd pfds[MAX_SIZE];
    ...

    for (int i = 1; i < argc; ++i) {
        if (count >= MAX_SIZE) {
            fprintf(stderr, "too many arguments, last arguments ignored!...\n");
            break;
        }
        if ((pfds[i - 1].fd = open(argv[i], O_RDONLY)) == -1)
            exit_sys("open");
        pfds[i - 1].events = POLLIN;
        printf("%s opened...\n", argv[i]);
        ++count;
    }

    İzlemenin POLLIN ile okuma izlemesi olduğuna dikkat ediniz. Yukarıda da belirttiğimiz gibi izlemede POLLHUP belirtilmemektedir. 
    Yine örneğimizde bir döngü içerisinde poll fonksiyonu çağrılmıştır:

    for (;;) {
        printf("waiting at poll...\n");

        if (poll(pfds, count, -1) == -1)
            exit_sys("poll");
        ...
    }

    Buradaki count, pfds dizisindeki eleman sayısını belirtmektedir. poll fonksiyonu blokeyi çözdüğünde bizim dizinin tüm 
    elemanlarını kontrol edip POLLIN ve POLLHUP olaylarının gerçekleşip gerçekleşmediğine bakmamız gerekmektedir:

    for (int i = 0; i < count; ++i) {
        if (pfds[i].revents & POLLIN) {
            ...
        }
        else if (pfds[i].revents & POLLHUP) {
            ...
        }
        ...
    }

    Burada POLLIN ve POLLHUP olaylarının else-if biçiminde ele alındığına dikkat ediniz. Normalde örneğin okuma ve yazma izlemesi 
    yapılırken bu olayların ayrık if deyimleriyle yapılması gerekir. Ancak POLLIN ve POLLHUP olaylarının else-if biçiminde ele 
    alınması daha uygundur. Bunun nedenini şöyle açıklayabiliriz: Karşı taraf boruya (ya da sokete) bilgi yazıp hemen boruyu 
    kapattığında POLLIN ve POLLHUP olayları birlikte oluşabilmektedir. Bu durumda POLLIN ve POLLHUP ayrık if deyimleriyle ele 
    alınırsa ve POLLIN olayında borudakilerin hepsi okunmazsa arkadan POLLUP işlemi ele alınırken boru kapatılacağı için eksik 
    yapılmış olacaktır. Halbuki else-if durumunda biz borudakilerin tamamını okumasak bile sonraki poll işleminde yeniden POLLIN 
    ve POLLHUP oluşacak ve boruyu bitirdikten sonra artık yalnızca POLLHUP olayı oluşacaktır.

    Örneğimizde bir boru kapatıldığında onun dizi elemanındaki betimleyicisi negatif bir değere çekilmiş ve böylece mantıksal 
    olarak diziden atılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <poll.h>

#define BUFFER_SIZE        4096
#define MAX_SIZE        128

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    char buf[BUFFER_SIZE + 1];
    struct pollfd pfds[MAX_SIZE];
    ssize_t result;
    int tcount, count;

    if (argc == 1) {
        fprintf(stderr, "too few arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("opens named pipes... it may block...\n");

    count = 0;
    for (int i = 1; i < argc; ++i) {
        if (count >= MAX_SIZE) {
            fprintf(stderr, "too many arguments, last arguments ignored!...\n");
            break;
        }
        if ((pfds[i - 1].fd = open(argv[i], O_RDONLY)) == -1)
            exit_sys("open");
        pfds[i - 1].events = POLLIN;
        printf("%s opened...\n", argv[i]);
        ++count;
    }
    tcount = count;

    for (;;) {
        printf("waiting at poll...\n");

        if (poll(pfds, count, -1) == -1)
            exit_sys("poll");

        for (int i = 0; i < count; ++i) {
            if (pfds[i].revents & POLLIN) {
                printf("POLLIN occurred...\n");
                if ((result = read(pfds[i].fd, buf, BUFFER_SIZE)) == -1)
                    exit_sys("read");
                buf[result] = '\0';
                printf("%s\n", buf);

            }
            else if (pfds[i].revents & POLLHUP) {
                printf("POLLHUP occurred...\n");
                close(pfds[i].fd);
                pfds[i].fd = -1;
                --tcount;
            }
        }
        if (tcount == 0)
            break;
    }

    printf("there is no descriptor open, finishes...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi aslında kapanan betimleyicileri mantıksal olarak diziden atmak için onun betimleyicisi 
    negatif bir değere çekilebilmektedir. Ancak istersek gerçekten kapanan betimleyicileri diziden atabiliriz. Tabii bu atma
    işlemi aslında dizinin sonundaki elemanın, atılacak elemanla yer değiştirilmesi yoluyla yapılabilmektedir. Aşağıda buna 
    bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <poll.h>

#define BUFFER_SIZE        4096
#define MAX_SIZE        128

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    char buf[BUFFER_SIZE + 1];
    struct pollfd pfds[MAX_SIZE];
    ssize_t result;
    int tcount, count;

    if (argc == 1) {
        fprintf(stderr, "too few arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("opens named pipes... it may block...\n");

    count = 0;
    for (int i = 1; i < argc; ++i) {
        if (count >= MAX_SIZE) {
            fprintf(stderr, "too many arguments, last arguments ignored!...\n");
            break;
        }
        if ((pfds[i - 1].fd = open(argv[i], O_RDONLY)) == -1)
            exit_sys("open");
        pfds[i - 1].events = POLLIN;
        printf("%s opened...\n", argv[i]);
        ++count;
    }
    tcount = count;

    for (;;) {
        printf("waiting at poll...\n");

        if (poll(pfds, count, -1) == -1)
            exit_sys("poll");

        for (int i = 0; i < count; ++i) {
            if (pfds[i].revents & POLLIN) {
                printf("POLLIN occurred...\n");
                if ((result = read(pfds[i].fd, buf, BUFFER_SIZE)) == -1)
                    exit_sys("read");
                buf[result] = '\0';
                printf("%s\n", buf);

            }
            else if (pfds[i].revents & POLLHUP) {
                printf("POLLHUP occurred...\n");
                close(pfds[i].fd);
                pfds[i] = pfds[tcount - 1];
                --tcount;
            }
        }
        count = tcount;
        if (count == 0)
            break;
    }

    printf("there is no descriptor open, finishes...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Tıpkı select fonksiyonunda olduğu gibi poll fonksiyonun da ppoll isimli sigset_t parametreli bir biçimi de vardır:

    #define _GNU_SOURCE        /* See feature_test_macros(7) */
    #include <poll.h>

    int ppoll(struct pollfd *fds, nfds_t nfds, const struct timespec *tmo_p, const sigset_t *sigmask);

    ppoll fonksiyonu POSIX standartlarında bulunmamaktadır. Linux sistemlerine özgüdür. Fonksiyon poll fonksiyonundan farklı
    olarak sinyal bloke kümesini parametre olarak alarak thread'in sinyal bloke kümesini set eder. Çıkışta da onu eski haline
    getirir. Yani buradaki sinyal bloke kümesi fonksiyon çalıştığı sürece etkili olmaktadır. Bu parametre NULL geçilirse 
    fonksiyon poll fonksiyonu gibi çalışmaktadır. Ancak ppoll fonksiyonunun zaman aşımı parametresinin timespec türünden olduğuna 
    dikkat ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi select ve poll fonksiyonlarını birbiriyle kıyaslarsak neler söyleyebiliriz?

    - poll fonksiyonunun kullanımı biraz daha kolay gibidir.

    - select fonksiyonu FD_SETSIZE (1024) kadar betimleyiciyi desteklemektedir. Oysa poll fonksiyonundaki dizi istenildiği 
    kadar büyük olabilir.

    - select fonksiyonunda fonksiyona verdiğimiz kümeler fonksiyon tarafından güncellendiği için fonksiyonun her çağrılmasında
    eski kümeyi saklayarak yeniden kullanmamız gerekir. Halbuki poll fonksiyonunda yapının giriş ve çıkış elemanları birbirinden
    ayrılmıştır.

    - select fonksiyonundaki zaman aşımı duyarlılığı mikrosaniye, poll fonksiyonundaki zaman aşımı duyarlılığı milisaniye 
    mertebesindendir.

    - Her iki fonksiyonda da betimleyici sayısı fazlalaştıkça performans düşme eğilimindedir.

    - poll fonksiyonunu kullanabilmek için pollfd türünden bir yapı dizisinin oluşturulması gerekmektedir. Halbuki select 
    fonksiyonunda fd_set veri yapısı bitsel düzeyde olduğu için az yer kaplamaktadır.

    poll fonksiyonunun select fonksiyonuna göre en önemli avantajı betimleyici sayısının istenildiği kadar çok olabilmesidir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                91. Ders 22/10/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    select ve poll fonksiyonlarının en önemli sorunu betimleyici sayısı arttığında performansın ciddi biçimde düşmesidir. Yani
    bu fonksiyonlar iyi bir ölçeklenebilirliğe (scalability) sahip değildir. İşte bu nedenden dolayı multiplexed IO işlemleri için 
    Linux sistemlerinde bu sistemlere özgü epoll fonksiyonları da bulundurulmuştur. epoll fonksiyonları, select ve poll fonksiyonlarına 
    göre özellikle betimleyici sayısı arttığında çok daha iyi performans göstermektedir. Bu nedenle Linux sistemlerinde ölçeklenebilir 
    server uygulamaları için tercih edilecek yöntem epoll yöntemi olmalıdır. Ancak epoll fonksiyonlarının taşınabilir olmadığına, 
    yalnızca Linux sistemlerine özgü olduğuna dikkat ediniz.

    epoll arayüzünün kullanımı temelde üç fonksiyon ile yapılmaktadır. epoll_create (ya da epoll_create1), epoll_ctl ve epoll_wait. 
    epoll arayüzünün kullanımı tipik olarak aşağıdaki adımlardan geçilerek yapılmaktadır:

    1) Programcı önce epoll_create isimli fonksiyonla bir betimleyici elde eder. Bu betimleyicinin IO olaylarının izleneceği 
    betimleyici ile bir ilgisi yoktur. Bu betimleyici diğer fonksiyonlara bir handle gibi geçirilmektedir. Fonksiyonun prototipi 
    şöyledir:

    #include <sys/epoll.h>

    int epoll_create(int size);

    Fonksiyonun parametresi kaç betimleyicinin izlenileceğine yönelik bir ipucu değeri alır. Programcı burada verdiği değerden
    daha fazla betimleyiciyi izleyebilir. Dolayısıyla bu parametre yalnızca bir ipucu niteliğindedir. Zaten daha sonra bu parametre 
    tasarımcıları rahatsız etmiş ve epoll_create1 isimli fonksiyonla kaldırılmıştır:

    #include <sys/epoll.h>

    int epoll_create1(int flags);

    Buradaki flags şimdilik yalnızca FD_CLOEXEC değerini ya da 0 değerini alabilmektedir. Fonksiyonların geri dönüş değeri
    başarı durumunda handle görevinde olan bir betimleyicidir.

    epoll_create ve epoll_create1 fonksiyonları başarı durumunda epoll betimleyicisine, başarısızlık durumunda -1 değerine geri 
    dönmektedir.

    2) Artık programcı izleyeceği betimleyicileri epoll sistemine epoll_ctl fonksiyonuyla ekler. Örneğin programcı 3 boru 
    betimleyicisini izleyecekse bu 3 betimleyici için de ayrı ayrı epoll_ctl çağrısı yapmalıdır. Fonksiyonun prototipi şöyledir:

    #include <sys/epoll.h>

    int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);

    Fonksiyonun birinci parametresi epoll_create ya da epoll_create1 fonksiyonundan elde edilen betimleyici değeridir. İkinci parametre
    EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL değerlerinden birini alır. EPOLL_CTL_ADD sisteme betimleyici eklemek için, EPOLL_CTL_DEL 
    sistemden betimleyici çıkartmak için, EPOLL_CTL_MOD da mevcut eklenmiş betimleyicide izleme değişikliği yapmak için kullanılmaktadır. 
    Üçüncü parametre izlenecek betimleyiciyi belirtir. Son parametre izlenecek olayı belirtmektedir. struct epoll_event yapısı 
    şöyle bildirilmiştir:

    struct epoll_event {
        uint32_t events;
        epoll_data_t data;
    };

    Yapının events elemanı tıpkı poll fonksiyonunda olduğu gibi izlenecek olayları belirten bayrak değerlerini almaktadır. Bu 
    bayrak değerleri epoll_ctl fonksiyonunda izlenecek olayları belirtir. İzleyen paragraflarda göreceğimiz epoll_wait fonksiyonunda 
    da gerçekleşen olayları belirtmektedir. İzleme amacıyla kullanılan tipik bayraklar şunlardır:

    EPOLLIN: Okuma amaçlı izlemeyi belirtir. Boruda ya da sokette okunacak bilgi oluştuğunda epoll_wait tarafından bu bayrak set 
    edilir. Soketlerde accept yapan tarafta bir bağlantı isteği oluştuğunda da EPOLLIN bayrağı epoll_wait tarafından set 
    edilmektedir. EPOLLIN bayrağı aynı zamanda karşı taraf soketi kapattığında da oluşmaktadır.

    EPOLLOUT: Yazma amaçlı izlemeyi belirtir. Boruya ya da sokete yazma durumu oluştuğunda (yani boruda ya da network tamponunda 
    yazma için yer açıldığında) fonksiyon tarafından bu bayrak set edilmektedir. EPOLLOUT bayrağı aynı zamanda karşı taraf soketi 
    kapattığında da oluşmaktadır.

    EPOLLERR: Hata amaçlı izlemeyi belirtir. Bu bayrak epoll_ctl fonksiyonunda set edilmez, epoll_wait fonksiyonu tarafından set 
    edilmektedir. Bu bayrak borularda okuma yapan tarafın boruyu kapatmasıyla yazma yapan tarafta set edilmektedir. (Normal olarak 
    okuyan tarafın boruyu kapattığı durumda boruya yazma yapıldığında SIGPIPE sinyalinin oluştuğunu anımsayınız.) Eğer okuyan taraf 
    boruyu kapattığında boruya yazma için yer varsa yazma yapan tarafta aynı zamanda EPOLLOUT bayrağı da set edilmektedir. 
    EPOLLERR bayrağı soketlerde kullanılmamaktadır.

    EPOLLHUP: Boruya yazan tarafın boru betimleyicisini kapattığında okuma yapan tarafta bu bayrak set edilmektedir. Bu bayrak 
    epoll_ctl fonksiyonunda set edilmez, epoll_wait tarafından yapının set edilmektedir. (HUP, "hang up" anlamına gelmektedir.) 
    Eğer boruya yazma yapan taraf boruyu kapattığında hala boruda okunacak bilgi varsa okuma yapan tarafta aynı zamanda EPOLLIN 
    bayrağı da set edilmektedir. EPOLLHUP bayrağı soketlerde kullanılmamaktadır.

    EPOLLRDHUP: Bu olay soketlerde karşı taraf soketi kapattığında ya da shutdown fonksiyonu SHUT_WR argümanıyla çağrıldığında 
    oluşur.
    Bayrak hem epoll_ctl fonksiyonunda set edilebilir hem de epoll_wait tarafından set edilebilir.

    Daha önce poll bayrakları için verdiğimiz tabloyu epoll bayrakları için de benzer biçimde vermek istiyoruz:

    Boruda bilgi yok ve yazan tarafın betimleyicisi kapalı ===> Okuyan tarafta EPOLLHUP
    Boruda bilgi var ve yazan tarafın betimleyicisi kapalı ===> Okuyan tarafta EPOLLIN|EPOLLHUP
    Boruda bilgi var ve yazan tarafın betimleyicisi açık ===> Okuyan tarafta EPOLLIN

    Boruda yazma için yer yok ve okuyan tarafın betimleyicisi kapalı ===> Yazan tarafta EPOLLERR
    Boruda yazma için yer var ve okuyan tarafın betimleyicisi kapalı ===> Yazan tarafta EPOLLOUT|EPOLLERR
    Boruda yazma için yer var ve okuyan tarafın betimleyicisi açık ===> Yazan tarafta EPOLLOUT

    Sokette bilgi var ===> Okuyan tarafta EPOLLIN
    Network tamponunda yazacak yer var ===> Yazan tarafta EPOLLOUT
    accept yapan tarafta bağlantı isteği oluştuğunda ===> accept yapan tarafta EPOLLIN
    Karşı taraf soketi kapattığında ===> karşı tarafta EPOLLIN|EPOLLOUT|EPOLLRDHUP

    epoll_event yapısının data elemanı aslında çekirdek tarafından saklanıp epoll_wait fonksiyonu yoluyla bize geri verilmektedir.
    Bu eleman bir birlik biçiminde bildirilmiştir (yani programcı tarafından bu birliğin yalnızca tek elemanı set edilmelidir):

    typedef union epoll_data {
        void *ptr;
        int fd;
        uint32_t u32;
        uint64_t u64;
    } epoll_data_t;

    Programcının tipik olarak olayın gerçekleştiği dosya betimleyicisinin hangisi olduğunu bilmesi gerekmektedir. Dolayısıyla 
    genellikle birliğin fd elemanı set edilmektedir. Tabii programcı daha fazla bilgi set etmek istiyorsa bir yapı oluşturabilir. 
    Betimleyiciyi ve diğer bilgileri bu yapının içerisine yerleştirebilir. Yapı nesnesinin adresini de birliğin ptr elemanına 
    atayabilir.

    epoll_ctl fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. errno değişkeni uygun 
    biçimde set edilmektedir.

    Kenar tetiklemeli (edge triggered) ve düzey tetiklemeli (level triggered) kavramları lojik elektronikte kullanılmaktadır. 
    Kenar tetikleme belli bir olay ilk gerçekleştiğinde birtakım değişikliklerin yapıldığını, düzey tetikleme ise belli bir olay 
    devam ettiği sürece değişikliklerin sürekli yapıldığını anlatmaktadır. Her ne bu terimler elektronikten geçtiyse de yazılımda da 
    anlatımları kolaylaştırmak için kullanılmaktadır. Örneğin select ve poll fonksiyonları "düzey tetiklemeli (level triggered)" 
    olarak çalışmaktadır. Yani bir boruya bilgi geldiği zaman bu fonksiyonlar çağrıldığında durumu bize bildirirler. O bilgi borudan 
    okunmadığı sürece bu fonksiyonları tekrar çağırdığımızda bu fonksiyonlar yine durumu bize bildirmektedir. epoll fonksiyonu 
    ise default durumda yine düzey tetiklemeli çalışırken özel olarak epoll_event yapısının events elemanına EPOLLET eklenirse o 
    betimleyici için "kenar tetiklemeli (edge triggered)" mod kullanılır.

    Yukarıda da belirtildiği gibi düzey tetiklemeli mod demek (select, poll'daki durum ve epoll'daki default durum) bir okuma 
    ya da yazma olayı açılıp bloke çözüldüğünde programcı eğer okuma ya da yazma yapmayıp yeniden bu fonksiyonları çağırırsa 
    bekleme yapılmayacak demektir. Yani örneğin biz select ya poll ile stdin dosyasını izliyorsak ve klavyeden bir giriş yapıldıysa 
    bu fonksiyonlar blokeyi çözer. Fakat biz read ile okuma yapmazsak ve yeniden select ve poll fonksiyonlarını çağırırsak artık 
    bloke oluşmaz. Halbuki kenar tetiklemeli modda biz okuma yapmasak bile yeni okuma eylemi oluşana kadar yine blokede kalırız. 
    Biz buradaki örneklerimizde epoll fonksiyonunu düzey tetiklemeli olarak kullanacağız. Soketler konusunda epoll fonksiyonunun 
    kenar tetiklemeli kullanımı üzerinde duracağız.

    Tabii programcının izleyeceği her betimleyici için epoll_ctl fonksiyonunu çağırması gerekir. Örneğin biz 3 farklı betimleyiciyi 
    izleyeceksek bizim üç kere epoll_ctl fonksiyonunu çağırmamız gerekir.

    3) Asıl bekleme ve izleme işlemi epoll_wait fonksiyonu tarafından yapılmaktadır. Bu fonksiyon select ve poll fonksiyonu gibi 
    eğer izlenen betimleyicilerde hiçbir olay gerçekleşmemişse bloke oluşturur ve eğer en az bir betimleyicide izlenen olaylardan 
    biri gerçekleşmişse blokeyi çözer. epoll_wait fonksiyonunun prototipi şöyledir: 

    #include <sys/epoll.h>

    int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);

    Fonksiyonun birinci parametresi epoll_create ya da epoll_create1 fonksiyonundan elde edilmiş olan betimleyici değeridir. 
    İkinci parametre oluşan olayların depolanacağı yapı dizisinin adresidir. Biz bu yapının events elemanından oluşan olayın 
    ne olduğunu anlarız. Yapının data elemanı epoll_ctl sırasında verdiğimiz değeri belirtir. Bizim en azından epoll_ctl fonksiyonunda 
    ilgili betimleyiciyi bu data elemanında girmiş olmamız gerekir. Fonksiyonun üçüncü parametresi, ikinci parametresiyle belirtilen 
    dizinin uzunluğudur. Normal olarak bu dizinin eklenmiş olan betimleyici sayısı kadar olması gerekir. Ancak buradaki değer 
    toplam izlenecek betimleyici sayısından az olabilir. Bu parametre tek hamlede en fazla kaç betimleyici hakkında bilgi 
    verileceğini belirtmektedir. Örneğin biz fonksiyonun ikinci parametresine 5 elemanlı bir yapı dizisinin adresini, üçüncü 
    parametresine de 5 değerini girebiliriz. Bu durumda epoll_wait fonksiyonunu çağırdığımızda fonksiyon bize en fazla 5 olay
    hakkında bilgi verecektir. Son parametre yine milisaniye cinsinden zaman aşımını belirtir. -1 değeri zaman aşımının 
    kullanılmayacağını, 0 değeri hemen betimleyicilere bakılıp çıkılacağını belirtmektedir. Fonksiyon başarı durumunda diziye 
    doldurduğu eleman sayısı ile, başarısızlık durumda -1 değeri ile geri dönmektedir. Örneğin fonksiyon 2 değerine geri dönmüş 
    olsun. Bu durum fonksiyon tarafından verdiğimiz dizinin "ilk 2" elemanının doldurulduğu anlamına gelmektedir. Fonksiyon 0 
    değeri ile geri dönerse sonlanmanın zaman aşımından dolayı oluştuğu anlaşılmaktadır. Tabii epoll_wait fonksiyonunun yine 
    bir döngü içerisinde çağrılması gerekmektedir.

    4) İzleme işlemlerinin kapatılması için tek yapılacak şey epoll_create ya da epoll_create1 fonksiyonundan elde edilen 
    betimleyicinin close fonksiyonuyla kapatılmasıdır.

    Belli bir betimleyiciyi izleme listesinden çıkartmak için normal olarak epoll_ctl fonksiyonu EPOLL_CTL_DEL parametresiyle 
    çağrılmalıdır. Ancak epoll sisteminde çoğu kez buna gerek yoktur. Bir dosyaya ilişkin son betimleyici de kapatılmışsa 
    o betimleyici otomatik olarak izleme listesinden çıkartılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda stdin dosyasından (0 numaralı betimleyiciden) epoll fonksiyonu ile okuma işlemine bir örnek verilmiştir. Örnekte
    sanki birden fazla betimleyici söz konusuymuş gibi işlem yapılmıştır. Bunun amacı kodun genel durum için bir şablon 
    oluşturmasını sağlamaktır. Tıpkı poll fonksiyonunda olduğu gibi terminalden Ctrl+d tuşlarına basıldığında EPOLLIN olayı 
    gerçekleştiğine dikkat ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/epoll.h>

#define MAX_EVENTS        1
#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(void)
{
    int epfd;
    struct epoll_event ee;
    struct epoll_event ree[MAX_EVENTS];
    int nevents;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;

    if ((epfd = epoll_create(1)) == -1)
        exit_sys("epoll_create");

    ee.events = EPOLLIN;
    ee.data.fd = 0;        /* yalnızca 0 numaralı betimleyici kullanıyoruz, aslında bu örnekte gerek yok */

    if (epoll_ctl(epfd, EPOLL_CTL_ADD, 0, &ee) == -1)
        exit_sys("epoll_ctl");

    for (;;) {
        if ((nevents = epoll_wait(epfd, ree, MAX_EVENTS, -1)) == -1)
            exit_sys("epoll_wait");

        for (int i = 0; i < nevents; ++i) {
            if (ree[i].events & EPOLLIN) {
                if ((result = read(ree[i].data.fd, buf, BUFFER_SIZE)) == -1)
                    exit_sys("read");
                if (result == 0)
                    goto EXIT;
                buf[result] = '\0';
                printf("%s", buf);
            }
        }
    }
EXIT:
    close(epfd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de daha vermiş olduğumuz borulardan okuma örneğini aşağıda epoll fonksiyonu ile gerçekleştirelim. Örneğimizde yine program 
    isimli boruları komut satırı argümanı olarak almaktadır. Örneğin:

    $ ./sample x y z

    Bu borular üzerinde okuma olayları izlenmektedir. Borular kapatıldığında EPOLLHUP olayı gerçekleşmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/epoll.h>

#define BUFFER_SIZE        4096
#define MAX_SIZE        128
#define MAX_EVENTS        5

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    char buf[BUFFER_SIZE + 1];
    int epfd, fd;
    struct epoll_event ee;
    struct epoll_event ree[MAX_EVENTS];
    int nevents;
    ssize_t result;
    int count;

    if (argc == 1) {
        fprintf(stderr, "too few arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((epfd = epoll_create(1)) == -1)
        exit_sys("epoll_create");

    printf("opens named pipes... it may block...\n");

    count = 0;
    for (int i = 1; i < argc; ++i) {
        if (count >= MAX_SIZE) {
            fprintf(stderr, "too many arguments, last arguments ignored!...\n");
            break;
        }
        if ((fd = open(argv[i], O_RDONLY)) == -1)
            exit_sys("open");

        ee.events = EPOLLIN;
        ee.data.fd = fd;
        if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ee) == -1)
            exit_sys("epoll_ctl");

        printf("%s opened...\n", argv[i]);
        ++count;
    }
    for (;;) {
        printf("waiting at epoll_wait...\n");

        if ((nevents = epoll_wait(epfd, ree, MAX_EVENTS, -1)) == -1)
            exit_sys("epoll_wait");

        for (int i = 0; i < nevents; ++i) {
            if (ree[i].events & EPOLLIN) {
                printf("EPOLLIN occurred...\n");
                if ((result = read(ree[i].data.fd, buf, BUFFER_SIZE)) == -1)
                    exit_sys("read");
                buf[result] = '\0';
                printf("%s\n", buf);

            }
            else if (ree[i].events & EPOLLHUP) {
                printf("EPOLLHUP occurred...\n");
                close(ree[i].data.fd);
                --count;
            }
        }
        if (count == 0)
            break;
    }

    printf("there is no descriptor open, finishes...\n");

    close(epfd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi Linux sistemlerinde epoll fonksiyonunun performansı select ve poll fonksiyonlarından 
    çok daha iyidir. Bu nedenle Linux sistemlerinde ilk tercih edilecek multiplexed IO sistemi epoll olmalıdır. Tabii epoll
    sistemi POSIX uyumlu değildir. Yani epoll kullandığımız kodlar taşınabilir olmamaktadır.

    epoll performansı için Michael Kerrisk'in "The Linux Programming Environment" kitabında karşılaştırmalı olarak saniye 
    cinsinden şu değerler verilmektedir:

    Number of descriptors   poll() CPU time         select() CPU time           epoll CPU time

    10                      0.61                    0.73                        0.41
    100                     2.9                     3.0                         0.42
    1000                    35                      35                          0.53
    10000                   990                     930                         0.66

    Burada görüldüğü gibi Linux sistemlerinde select ile poll fonksiyonlarının performansı birbirine çok yakındır. Ancak
    epoll sisteminin performansı açık ara çok daha iyidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    epoll fonksiyonu ile sistem genelinde izlenecek maksimum betimleyici sayısı default durumda sistem belleği ile ilgili bir 
    biçimde ayarlanmaktadır. Bu bilgi /proc/sys/fs/epoll/max_user_watches dosyasında bulunmaktadır. Bu değer değiştirilebilmektedir. 
    Kursun yapıldığı sanal makinede bu değer 858824 biçimindedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    epoll ile kenar tetiklemeli işlemler üzerinde burada örnek vermeyeceğiz. Bunun için ilgili dokümanlara başvurabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sinyal tabanlı (signal driven) IO işlemlerinde belli bir betimleyicide olay oluştuğunda prosese bir sinyal gönderilmektedir. 
    Böylece sinyal oluştuğunda ilgili kaynaktan okuma/yazma işlemleri yapılabilmektedir. Bunun için SIGIO isimli bir sinyal 
    bulundurulmuştur. Ancak izleyen paragraflarda da görüleceği üzere olay gerçekleştiğinde oluşturulacak olan bu sinyal 
    değiştirilebilmektedir. Ancak bu model güncel POSIX standartlarında bulunmamaktadır. Bazı UNIX türevi sistemler ve Linux 
    sistemleri bu modeli desteklemektedir.

    Sinyal tabanlı IO modeli tipik olarak şu aşamalardan geçilerek gerçekleştirilmektedir.

    1) Betimleyici open fonksiyonuyla açılır. Eğer soketler söz konusu ise betimleyici socket fonksiyonuyla ya da accept 
    fonksiyonuyla elde edilmektedir.

    2) Oluşturulacak sinyal için (default durumda SIGIO sinyali) sinyal fonksiyonu set edilir.

    3) İlgili betimleyicide olay oluştuğunda hangi prosese sinyal gönderileceği fcntl fonksiyonu ile set edilir. Tabii genel olarak 
    programcı sinyalin kendi prosesine gönderilmesini ister. Bunun için fcntl fonksiyonunun ikinci parametresi olan fcntl komutu için
    F_SETOWN girilmelidir. fcntl fonksiyonunun üçüncü parametresine ise sinyalin gönderileceği prosesin id değeri girilir. Bu 
    parametreye getpid() fonksiyonunun geri dönüş değeri girilirse ilgili olay gerçekleştiğinde kendi prosesimize sinyal gönderilir. 
    Üçüncü parametre negatif bir proses id girilirse, bu değerin mutlak değeri proses grup belirtmektedir.

    4) Betimleyici blokesiz moda sokulur ve aynı zamanda O_ASYNC bayrağı da set edilir. Bu işlem fcntl fonksiyonunda F_SETFL komut 
    koduyla yapılabilmektedir.

    fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_NONBLOCK | O_ASYNC);

    O_ASYNC bayrağı POSIX standartlarında bulunmamaktadır.

    Bu yöntemde ilgilenilen olay (yani okuma olayının mı yazma olayının mı izleneceği) gizlice open fonksiyonundaki açış modunda 
    belirtilmektedir. Yani örneğin bizim open fonksiyonuyla dosyayı O_RDONLY modunda açmamız yalnızca okuma olayıyla ilgilendiğimizi, 
    O_WRONLY modunda açmamız yalnızca yazma olayı ile ilgilendiğimizi, O_RDWR modunda açmamız da hem okuma hem de yazma ile ilgilendiğimizi
    belirtir.

    5) Artık normal akış devam eder. İlgilenilen olay gerçekleştiğinde sinyal oluşturulmaktadır.

    Sinyal tabanlı IO işlemleri "kenar tetiklemeli (edge triggered)" bir biçimde oluşturulmaktadır. Yani yalnızca yeni bilgi 
    geldiğinde sinyal oluşturulur. Bu nedenle programcının sinyal oluştuğunda bir döngü içerisinde başarısız olana kadar 
    okuma/yazma yapması uygun olmaktadır. Örneğin boruya ya da sokete 100 byte gelmiş olsun. Bu durumda sinyal oluşturulur. 
    Eğer biz sinyal oluştuğunda eksik bilgi okursak (örneğin 50 byte okuduğumuzu varsayalım) kenar tetikleme yüzünden artık
    boruya ya da sokete yeni bir bilgi gelene kadar sinyal oluşmayacaktır. Bu nedenle bizim o zamana kadar gelmiş olan tüm 
    bilgileri bir döngü içerisinde okumamız uygun olur. Örneğin:

    for (;;) {
        result = read(STDIN_FILENO, buf, BUFFER_SIZE);

        if (result == -1) {
            if (errno == EAGAIN)
                break;
            exit_sys("read");
        }

        if (result == 0)
            exit(EXIT_SUCCESS);

        buf[result] = '\0';
        printf("%s", buf);        // UNSAFE
    }

    Burada bir döngü içerisinde errno değeri EAGAIN olmayana kadar okuma yapılmıştır.

    Pekiyi sinyal geldiğinde okuma işlemi nasıl yapılmalıdır? İlk akla gelen yöntem okumanın sinyal fonksiyonun içerisinde 
    yapılmasıdır. Ancak bu durum genellikle iyi bir teknik değildir. Bunun tipik nedenleri şunlardır:

    - Sinyal oluştuğunda sinyal fonksiyonunda uzun süre işlem yapmak iyi bir teknik değildir. Çünkü sinyal fonksiyonu çalıştığı 
    sürece aynı sinyal blokede kalmaktadır. SIGIO sinyali gerçek zamanlı bir sinyal olmadığı için kuyruklanmamaktadır. Ancak 
    mekanizmanın kenar tetiklemeli olduğunu anımsayınız. Bu nedenle sinyalin blokesi açıldığında o ana kadar gelmiş olan tüm 
    bilgiler döngü içerisinde okunacaktır.

    - Sinyal fonksiyonu içerisinde ancak biz sinyal güvenli (signal safe) fonksiyonları çağırabiliriz. Ancak okuma ve sonrasında 
    pek çok sinyal güvenli olmayan fonksiyonların çağrılması gerekebilmektedir.

    Pekiyi okuma/yazma işlemlerini sinyal geldiği zaman sinyal fonksiyonu içerisinde yapmayacaksak nerede ve nasıl yapmalıyız? 
    İşte tipik olarak sinyal fonksiyonu içerisinde bir flag set edilip işlemler dışarıda yapılabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                92. Ders 28/10/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte stdin dosyasından sinyal tabanlı okuma yapılmıştır. Bu örnekte sinyal fonksiyonunda yalnızca bir flag 
    set edilmiştir. Okumalar sinyal fonksiyonunun dışında bu flag değişkenine bakılarak gerçekleştirilmiştir. flag değişkeni 
    sig_atomic_t türünden tanımlanmıştır. Anımsanacağı gibi bu türden nesnelere atama işlemleri tek makine komutuyla atomik 
    yapılmaktadır. Her ne kadar sig_atomic_t türü "volatile" özelliğine de kapsıyor gibiyse de biz yine de flag değişkeninde 
    volatile niteleyicisini kullandık.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>

#define BUFFER_SIZE        1024

void sigio_handler(int signo);
void exit_sys(const char *msg);

volatile sig_atomic_t g_sigio_flag;

int main(void)
{
    struct sigaction sa;
    int flags;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;

    sa.sa_handler = sigio_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGIO, &sa, NULL) == -1)
        exit_sys("sigaction");

    if (fcntl(STDIN_FILENO, F_SETOWN, getpid()) == -1)
        exit_sys("fcntl");

    flags = fcntl(STDIN_FILENO, F_GETFL);

    if (fcntl(STDIN_FILENO, F_SETFL, flags|O_NONBLOCK|O_ASYNC) == -1)
        exit_sys("fcntl");

    for (;;) {
        pause();

        if (g_sigio_flag) {
            for (;;) {
                result = read(STDIN_FILENO, buf, BUFFER_SIZE);

                if (result == -1) {
                    if (errno == EAGAIN)
                        break;
                    exit_sys("read");
                }

                if (result == 0)
                    exit(EXIT_SUCCESS);

                buf[result] = '\0';
                printf("%s", buf);
            }
            g_sigio_flag = 0;
        }
    }

    return 0;
}

void sigio_handler(int signo)
{
    g_sigio_flag = 1;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi sinyal tabanlı IO işlemlerinde birden fazla betimleyici ile nasıl işlem yapılacaktır? Örneğin biz 3 boru betimleyicisinden 
    okuma yapmak isteyelim. SIGIO sinyali oluştuğunda hangi boruya bilgi geldiğini nasıl anlayacağız? Yukarıdaki örnekte yalnızca 
    stdin dosyasından okuma yaptık. Bu örnekte böyle bir bilgiye ihtiyacımız yoktu. İşte bu yöntemin aslında etkin bir biçimde 
    kullanılabilmesi için IO olayı olduğunda SIGIO sinyali yerine gerçek zamanlı bir sinyalin oluşturulması gerekmektedir. 
    Gerçek zamanlı sinyaller hem kuyruklanmakta hem de bu sinyallere ek bir bilgi yerleştirilebilmektedir.

    Sinyal tabanlı IO işlemindeki default sinyalin SIGIO sinyali olduğunu belirtmiştik. Ancak SIGIO sinyalinin gerçek zamanlı 
    olmaması bir handikap oluşturmaktadır. İşte default sinyal aslında fcntl fonksiyonu ile F_SETSIG komutu kullanılarak 
    değiştirilebilmektedir. Örneğin:

    fcntl(fd, F_SETSIG, SIGRTMIN);

    Benzer biçimde oluşturulacak sinyalin numarası da fcntl fonksiyonunda F_GETSIG komutuyla elde edilebilmektedir. Biz F_SETSIG
    komutu ile gerçek zamanlı bir sinyal set ettiğimizde artık sinyal fonksiyonumuzun siginfo_t parametreli olması gerekmektedir. 
    Gerçek zamanlı sinyallerin nasıl set edildiğini anımsatmak istiyoruz:

    void signal_handler(int signo, siginfo_t *info, void *context);
    ...
    struct sigaction sa;
    ...

    sa.sa_sigaction = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART|SA_SIGINFO;

    Gerçek zamanlı sinyallerin bu konudaki faydasını izleyen paragraflarda açıklayacağız. Ancak şimdi aşağıda sinyal tabanlı 
    IO işlemleri için gerçek zamanlı sinyalin set edilmesine yönelik örnek vermek istiyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>

#define BUFFER_SIZE        1024

void signal_handler(int signo, siginfo_t *info, void *context);
void exit_sys(const char *msg);

volatile sig_atomic_t g_sigio_flag;

int main(void)
{
    struct sigaction sa;
    int flags;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;

    sa.sa_sigaction = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART|SA_SIGINFO;

    if (sigaction(SIGRTMIN, &sa, NULL) == -1)
        exit_sys("sigaction");

    if (fcntl(STDIN_FILENO, F_SETOWN, getpid()) == -1)
        exit_sys("fcntl");

    flags = fcntl(STDIN_FILENO, F_GETFL);

    if (fcntl(STDIN_FILENO, F_SETFL, flags|O_NONBLOCK|O_ASYNC) == -1)
        exit_sys("fcntl");

    if (fcntl(STDIN_FILENO, F_SETSIG, SIGRTMIN) == -1)
        exit_sys("fcntl");

    for (;;) {
        pause();

        if (g_sigio_flag) {
            for (;;) {
                result = read(STDIN_FILENO, buf, BUFFER_SIZE);

                if (result == -1) {
                    if (errno == EAGAIN)
                        break;
                    exit_sys("read");
                }

                if (result == 0)
                    exit(EXIT_SUCCESS);

                buf[result] = '\0';
                printf("%s", buf);
            }
            g_sigio_flag = 0;
        }
    }

    return 0;
}

void signal_handler(int signo, siginfo_t *info, void *context)
{
    g_sigio_flag = 1;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi gerçek zamanlı sinyallerde sinyal fonksiyonuna çekirdek tarafından içi doldurulan siginfo_t türünden bir 
    yapı nesnesinin adresi geçiriliyordu. siginfo_y yapısını anımsayınız:

    siginfo_t {
        int      si_signo;     /* Signal number */
        int      si_errno;     /* An errno value */
        int      si_code;      /* Signal code */
        int      si_trapno;    /* Trap number that caused hardware-generated signal (unused on most architectures) */
        pid_t    si_pid;       /* Sending process ID */
        uid_t    si_uid;       /* Real user ID of sending process */
        int      si_status;    /* Exit value or signal */
        clock_t  si_utime;     /* User time consumed */
        clock_t  si_stime;     /* System time consumed */
        union sigval si_value; /* Signal value */
        int      si_int;       /* POSIX.1b signal */
        void    *si_ptr;       /* POSIX.1b signal */
        int      si_overrun;   /* Timer overrun count; POSIX.1b timers */
        int      si_timerid;   /* Timer ID; POSIX.1b timers */
        void    *si_addr;      /* Memory location which caused fault */
        long     si_band;      /* Band event (was int in glibc 2.3.2 and earlier) */
        int      si_fd;        /* File descriptor */
        short    si_addr_lsb;  /* Least significant bit of address (since Linux 2.6.32) */
        void    *si_lower;     /* Lower bound when address violation occurred (since Linux 3.19) */
        void    *si_upper;     /* Upper bound when address violation occurred (since Linux 3.19) */
        int      si_pkey;      /* Protection key on PTE that caused fault (since Linux 4.6) */
        void    *si_call_addr; /* Address of system call instruction (since Linux 3.5) */
        int      si_syscall;   /* Number of attempted system call (since Linux 3.5) */
        unsigned int si_arch;  /* Architecture of attempted system call (since Linux 3.5) */
    }

    Anımsanacağı gibi yapının si_signo elemanı oluşan sinyalin numarasını, si_pid elemanı sinyali oluşturan prosesin id 
    değerini vermekteydi. Sinyal tabanlı IO işlemlerinde yapının si_fd elemanı sinyale yol açan betimleyicinin numarasını 
    vermektedir. si_code elemanı ise sinyalin neden oluştuğuna yönelik bilgi vermektedir. Yapının bu si_code elemanında şu 
    bitler set edilmiş olabilir:

    POLL_IN: Okuma ya da kapatma olayı
    POLL_OUT: Yazma olayı
    POLL_ERR: IO hatası

    Diğer bayraklar için dokümanlara başvurabilirsiniz.

    Aşağıda daha önce yaptığımız boru örneğinin sinyal tabanlı IO modeli ile gerçekleştirimini veriyoruz. Bu örnekte sinyaller
    senkron biçimde sigwaitinfo fonksiyonu ile işlenmiştir. Dolayısıyla bir sinyal fonksiyonu yazılmamıştır. sigwaitinfo 
    uygulamadan önce beklenecek sinyalleri bloke etmeyi unutmayınız. Örneğimizde sigwaitinfo fonksiyonundan çıkıldığında 
    oluşan olay siginfo_t yapısının si_code elemanından elde edilmiş ve yapının si_fd elemanından okuma yapılmıştır. Karşı 
    taraf boruyu ya da soketi kapattığında yine POLL_IN olayının gerçekleşeceğini anımsatmak istiyoruz. 
---------------------------------------------------------------------------------------------------------------------------*/

#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <unistd.h>

#define BUFFER_SIZE        4096
#define MAX_SIZE        128

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    char buf[BUFFER_SIZE + 1];
    int fd;
    ssize_t result;
    sigset_t sset;
    siginfo_t sinfo;
    int count;

    if (argc == 1) {
        fprintf(stderr, "too few arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("opens named pipes... it may block...\n");

    count = 0;
    for (int i = 1; i < argc; ++i) {
        if (count >= MAX_SIZE) {
            fprintf(stderr, "too many arguments, last arguments ignored!...\n");
            break;
        }
        if ((fd = open(argv[i], O_RDONLY)) == -1)
            exit_sys("open");

        if (fcntl(fd, F_SETOWN, getpid()) == -1)
            exit_sys("fcntl");

        if (fcntl(fd, F_SETFL, fcntl(fd, F_GETFL)|O_NONBLOCK|O_ASYNC) == -1)
            exit_sys("fcntl");

        if (fcntl(fd, F_SETSIG, SIGRTMIN) == -1)
            exit_sys("fcntl");

        printf("%s opened...\n", argv[i]);
        ++count;
    }

    sigaddset(&sset, SIGRTMIN);

    if (sigprocmask(SIG_BLOCK, &sset, NULL) == -1)
        exit_sys("sigprocmask");

    for (;;) {
        if ((sigwaitinfo(&sset, &sinfo)) == -1)
            exit_sys("sigwaitinfo");

        if (sinfo.si_code & POLL_IN) {
            for (;;) {
                result = read(sinfo.si_fd, buf, BUFFER_SIZE);

                if (result == -1) {
                    if (errno == EAGAIN)
                        break;
                    exit_sys("read");
                }

                if (result == 0) {
                    --count;
                    close(sinfo.si_fd);
                    break;
                }

                buf[result] = '\0';
                printf("%s", buf);
            }
            if (count == 0)
                break;
        }
    }

    if (sigprocmask(SIG_UNBLOCK, &sset, NULL) == -1)
        exit_sys("sigprocmask");

    printf("there is no descriptor open, finishes...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi multiplexed select ve poll modeli ile sinyal tabanlı IO modelini kıyaslarsak neler söyleyebiliriz? Linux sistemlerinde 
    sinyal tabanlı IO modeli, select ve poll modeline göre daha yüksek performans sunmaktadır. Özellikle önceki örnekte yaptığımız 
    senkron sinyal işlemesi yüksek miktarda betimleyici söz konusu olduğunda select ve poll modelinden daha iyi sonuçlar 
    vermektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İleri IO modellerinden biri de "Asenkron IO" modelidir. Bu modelde okuma/yazma gibi işlemler başlatılır ancak akış devam 
    eder. İşlemler bittiğinde durum programcıya bir sinyal ya da fonksiyon çağrısı ile bildirilir. Asenkron IO işlemleri POSIX 
    standartları tarafından desteklenmektedir. Asenkron IO modelinde kullanılan fonksiyonlar aio_xxx biçiminde isimlendirilmiştir. 
    Asenkron IO işlemleri için kullanılan fonksiyonlar ve yapılar <aio.h> dosyası içerisinde bildirilmiştir.

    Asenkron IO işlemleri tipik olarak şu aşamalardan geçilerek yürütülmektedir:

    1) Önce <aio.h> içerisinde bildirilmiş olan struct aiocb (asynchronous IO control block) isimli bir yapı türünden nesne tanımlanıp 
    içinin doldurulması gerekir. Yapı şöyle bildirilmiştir.

    #include <aio.h>

    struct aiocb {
        int             aio_fildes;
        off_t           aio_offset;
        volatile void  *aio_buf;
        size_t          aio_nbytes;
        int             aio_reqprio;
        struct sigevent aio_sigevent;
        int             aio_lio_opcode;
    };

    Yapının aio_fildes elemanına okuma/yazma yapılmak istenen dosyaya ilişkin dosya betimleyicisi yerleştirilir. Asenkron okuma/yazma
    işlemleri dosya göstericisinin gösterdiği yerden itibaren yapılmamaktadır. Okuma/yazmanın dosyanın neresinden yapılacağı yapının 
    aio_offset elemanında belirtilir. (Seekable olmayan aygıtlar için bu elemana 0 girilebilir. Eğer yazma durumu söz konusuysa 
    ve dosya O_APPEND modda açıldıysa bu durumda aio_offset elemanının değeri dikkate alınmaz. Her yazılan dosyaya eklenir.) 
    Yapının aio_buf elemanı transferin yapılacağı bellek adresini belirtir. Bu adresteki dizinin işlem sonlanana kadar yaşıyor 
    durumda olması gerekmektedir. Yapının aio_nbytes elemanı okunacak ya da yazılacak byte miktarını belirtmektedir. Tabii burada 
    belirtilen byte miktarı aslında aio_buf dizisinin uzunluğunu belirtmektedir. Yoksa kesin olarak okunacak byte sayısını belirtmez. 
    Yani örneğin asenkron biçimde bir borudan 100 byte okumak isteyelim. Bize "işlem bitti" bildirimi 100 byte okuduktan sonra 
    gelmek zorunda değildir. En az 1 byte'lık okuma olayı gerçekleşmişse de "işlem bitti bildirimi" yapılır. Tabii hiçbir zaman burada 
    belirtilen byte miktarından fazla okuma yazma yapılmayacaktır. Başka bir deyişle yapının bu aio_nbytes elemanı en fazla yapılacak 
    okuma/yazma miktarını belirtmektedir. Yapının aio_reprio elemanı ise okuma/yazma için bir öncelik derecesi belirtmektedir. Yani 
    bu değer yapılacak transferin önceliğine ilişkin bir ipucu belirtir. Ancak işletim sisteminin bu ipucunu kullanıp kullanmayacağı 
    isteğe bağlı bırakılmıştır. Bu elemana 0 geçilebilir. Yapının aio_sigevent elemanı işlem bittiğinde yapılacak bildirim hakkında 
    bilgileri barındırmaktadır. Bu sigevent yapısını daha önce timer konusunda görmüştük. Burada yeniden anımsatmak istiyoruz:

    #include <signal.h>

    struct sigevent {
        int          sigev_notify;
        int          sigev_signo;
        union sigval sigev_value;
        void       (*sigev_notify_function) (union sigval);
        void        *sigev_notify_attributes;
    };

    Bu yapının sigev_notify elemanı bildirimin türünü belirtir. Anımsanacağı gibi bu tür SIGEV_NONE, SIGEV_SIGNAL, SIGEV_THREAD
    biçiminde olabilmektedir. SIGEV_NONE IO olayı bittiğinde bir bildirimin yapılmayacağını, SIGEV_SIGNAL bir sinyal ile 
    bildirimin yapılacağını, SIGEV_THREAD ise bildirimin kernel tarafından yaratılan bir thread yoluyla yapılacağını belirtmektedir. 
    Yapının sigev_signo elemanı ise eğer sinyal yoluyla bildirimde bulunulacaksa sinyalin numarasını belirtmektedir. Yapının 
    sigev_value elemanı sinyal fonksiyonuna ya da thread fonksiyonuna gönderilecek kullanıcı tanımlı bilgiyi temsil etmektedir. 
    Buradaki birliğin aşağıdaki gibi bildirildiğini anımsayınız:

    #include <signal.h>

    union sigval {            /* Data passed with notification */
        int     sival_int;    /* Integer value */
        void   *sival_ptr;    /* Pointer value */
    };

    Yapının sigev_notify_function elemanı eğer bildirim thread yoluyla yapılacaksa işletim sistemi tarafından yaratılan thread'in 
    çağıracağı callback fonksiyonunu belirtmektedir. Yapının sigev_notify_attributes elemanı ise yaratılacak thread'in özelliklerini 
    belirtir. Bu parametre NULL geçilebilir.

    Örneğin:

    struct aiocb cb;
    char buf[BUFFER_SIZE + 1];
    ...

    cb.aio_fildes = STDIN_FILENO;
    cb.aio_offset = 0;
    cb.aio_buf = buf;
    cb.aio_nbytes = BUFFER_SIZE;
    cb.aio_reqprio = 0;
    cb.aio_sigevent.sigev_notify = SIGEV_THREAD;
    cb.aio_sigevent.sigev_value.sival_ptr = &cb;
    cb.aio_sigevent.sigev_notify_function = io_proc;
    cb.aio_sigevent.sigev_notify_attributes = NULL;

    2) Şimdi okuma ya da yazma olayını aio_read ya da aio_write fonksiyonuyla başlatmak gerekir. Artık akış bu fonksiyonlarda bloke 
    olmayacak fakat işlem bitince bize bildirimde bulunulacaktır.

    #include <aio.h>

    int aio_read(struct aiocb *aiocbp);
    int aio_write(struct aiocb *aiocbp);

    Fonksiyonlar başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. İşlemlerin devam ettiğine yani 
    henüz sonlanmadığına dikkat ediniz. Bu fonksiyonlara verdiğimiz aiocb yapılarının işlem tamamlanana kadar yaşıyor olması gerekir. 
    Yani fonksiyon bizim verdiğimiz aiocb yapısını çalışırken kullanıyor olabilir.

    aio_read ve aio_write fonksiyonları yalnızca bir defalık okuma yazma için mekanizmayı kurmaktadır. Mekanizmanın nasıl devam 
    ettirileceği izleyen maddede ele alınacaktır.

    Örneğin:

    if (aio_read(&cb) == -1)
        exit_sys("aio_read");

    3) Anımsanacağı gibi biz aiocb yapısının aio_nbytes elemanına maksimum okuma/yazma miktarını vermiştik. Halbuki bundan daha
    az okuma/yazma yapılması mümkündür. Pekiyi bize bildirimde bulunulduğunda ne kadar miktarda bilginin okunmuş ya da yazılmış 
    olduğunu nasıl anlayacağız? İşte bunun için aio_return isimli fonksiyon kullanılmaktadır:

    #include <aio.h>

    ssize_t aio_return(struct aiocb *aiocbp);

    Fonksiyon başarı durumunda transfer edilen byte sayısına, başarısızlık durumunda -1 değerine geri dönmektedir. Eğer bildirim 
    gelmeden bu fonksiyon çağrılırsa geri dönüş değeri anlamlı olmayabilir. aio_read ve aio_write fonksiyonları sinyal güvenli 
    değildir, ancak aio_return ve aio_error fonksiyonları sinyal güvenlidir.

    Yukarıda aio_read ve aio_write işlemlerinin bir defalık okuma/yazma sağladığını belirtmiştik. İşlemin devamının sağlanması 
    için her okuma/yazma olayı gerçekleştiğinde yeniden aio_read ve aio_write fonksiyonlarının çağrılması gerekmektedir. Yani
    IO işlemi gerçekleştiğinde, biz yeniden IO işlemi için bu fonksiyonların çağrılmasını sağlamalıyız.

    Aşağıda asenkron IO modelinin uygulanmasına ilişkin bir örnek verilmiştir. Örnekte stdin dosyasından sürekli okuma yapılmak 
    istenmiştir. Burada bildirim SIGEV_THREAD ile kernel tarafından yaratılan thread yoluyla yapılmaktadır. Okuma olayı bittiğinde 
    kernel tarafından yaratılmış olan thread, bizim belirlediğimiz fonksiyonu çağırmaktadır. Ancak bu işlemler için kaç thread'in 
    yaratılacağı gibi özellikler sistemden sisteme değişebilmektedir. Örneğin Linux genellikle tek bir thread yaratıp tüm olayları 
    bu thread'e yaptırmaktadır. Biz de bu fonksiyon içerisinde aio_return fonksiyonu ile kaç byte okunduğunu belirleyip işlemin devam 
    etmesi için aio_read fonksiyonunu yeniden çağırmaktayız. Burada thread fonksiyonuna bizim aiocb yapısını nasıl geçirdiğimize 
    dikkat ediniz:

    cb.aio_sigevent.sigev_value.sival_ptr = &cb;

    aio_sigevent yapısının sigev_value elemanı thread fonksiyonuna parametre olarak aktarılmaktadır. sigev_value elemanının 
    bir birlik olduğunu anımsayınız. Biz de bu birliğin sival_ptr elemanına, aiocb yapı nesnesinin adresini yerleştirdik. 
    Klavyeden Ctrl+d tuşlarına basıldığında bu da bir IO olayı olarak ele alınmaktadır. Ancak bu durumda aio_return fonksiyonu
    0 değeri ile geri dönmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <aio.h>

#define BUFFER_SIZE        4096

void io_proc(union sigval sval);
void exit_sys(const char *msg);

int main(void)
{
    struct aiocb cb;
    char buf[BUFFER_SIZE + 1];

    cb.aio_fildes = STDIN_FILENO;
    cb.aio_offset = 0;
    cb.aio_buf = buf;
    cb.aio_nbytes = BUFFER_SIZE;
    cb.aio_reqprio = 0;
    cb.aio_sigevent.sigev_notify = SIGEV_THREAD;
    cb.aio_sigevent.sigev_value.sival_ptr = &cb;
    cb.aio_sigevent.sigev_notify_function = io_proc;
    cb.aio_sigevent.sigev_notify_attributes = NULL;

    if (aio_read(&cb) == -1)
        exit_sys("aio_read");

    printf("waiting at pause, press Ctrl+C to exit...\n");

    pause();

    return 0;
}

void io_proc(union sigval sval)
{
    ssize_t result;
    struct aiocb *cb = (struct aiocb *)sval.sival_ptr;
    char *buf = (char *)cb->aio_buf;

    if ((result = aio_return(cb)) == -1)
        exit_sys("aio_return");

    if (result == 0) {
        printf("Ctrl+d pressed...\n");
        return;
    }

    buf[result] = '\0';
    printf("%s", buf);

    if (aio_read(cb) == -1)
        exit_sys("aio_read");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                93. Ders 29/10/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte daha önce yapmış olduğumuz birden fazla borudan okuma örneğini asenkron IO modeli ile gerçekleştiriyoruz.
    Burada yine komut satırı argümanları ile alınan bir grup isimli boru açılmıştır. Her boru açıldığında bir aiocb yapısı 
    dinamik bir biçimde tahsis edilerek içi doldurulmuştur. Tabii her asenkron IO işleminde farklı bir tamponun kullanılması 
    gerekmektedir. Burada yine bildirim thread yoluyla yapılmaktadır. IO olayı bittiğinde belirlediğimiz fonksiyon kernel 
    tarafından çağrılacaktır. Biz de bu fonksiyon içerisinde kaç byte okumanın yapıldığını belirleyip okunanları ekrana (stdout 
    dosyasına) yazdırmaktayız. Tahsis edilen alanların betimleyici kapatıldıktan sonra free edildiğine dikkat ediniz. Ana akış
    bu sırada pause fonksiyonunda bekletilmektedir. Son boru betimleyicisi de kapatıldığında raise fonksiyonu ile kendi prosesimize
    SIGINT sinyalini göndererek işlemleri sonlandırmaktayız. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <stdatomic.h>
#include <aio.h>

#define BUFFER_SIZE        4096
#define MAX_SIZE        128

void io_proc(union sigval sval);
void exit_sys(const char *msg);

volatile atomic_int g_count;

int main(int argc, char *argv[])
{
    char buf[BUFFER_SIZE + 1];
    int fd;
    struct aiocb *cb;

    if (argc == 1) {
        fprintf(stderr, "too few arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("opens named pipes... it may block...\n");

    g_count = 0;
    for (int i = 1; i < argc; ++i) {
        if (g_count >= MAX_SIZE) {
            fprintf(stderr, "too many arguments, last arguments ignored!...\n");
            break;
        }
        if ((fd = open(argv[i], O_RDONLY)) == -1)
            exit_sys("open");

        printf("%s opened...\n", argv[i]);

        if ((cb = (struct aiocb *)malloc(sizeof(struct aiocb))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }

        cb->aio_fildes = fd;
        cb->aio_offset = 0;
        if ((cb->aio_buf = malloc(BUFFER_SIZE + 1)) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }
        cb->aio_nbytes = BUFFER_SIZE;
        cb->aio_reqprio = 0;
        cb->aio_sigevent.sigev_notify = SIGEV_THREAD;
        cb->aio_sigevent.sigev_value.sival_ptr = cb;
        cb->aio_sigevent.sigev_notify_function = io_proc;
        cb->aio_sigevent.sigev_notify_attributes = NULL;

        if (aio_read(cb) == -1)
            exit_sys("aio_read");

        ++g_count;
    }

    printf("waiting at pause, press Ctrl+C to exit...\n");

    pause();

    free(cb->aio_buf);

    free(cb);

    return 0;
}

void io_proc(union sigval sval)
{
    ssize_t result;
    struct aiocb *cb = (struct aiocb *)sval.sival_ptr;
    char *buf = (char *)cb->aio_buf;

    if ((result = aio_return(cb)) == -1)
        exit_sys("aio_return");

    if (result == 0) {
        printf("pipe closed...\n");
        close(cb->aio_fildes);
        free(buf);
        free(cb);
        --g_count;

        if (g_count == 0)
            if (raise(SIGINT) != 0)
                exit_sys("raise");
        return;
    }

    buf[result] = '\0';
    printf("%s", buf);

    if (aio_read(cb) == -1)
        exit_sys("aio_read");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örneği biraz farklı bir biçimde de düzenleyebiliriz. Örneğin aiocb yapısı ile tampon, bizim oluşturduğumuz 
    bir yapının içerisinde saklanabilir. Böylece tahsisat işlemleri ve kullanım işlemleri biraz daha kolaylaştırılabilir. 
    Örneğin:

    typedef struct {
        struct aiocb cb;
        char buf[BUFFER_SIZE + 1];
    } IOCB_BUF;

    Bu sayede biz aiocb yapısı ve tampon için iki ayrı tahsisat yapmak yerine tek bir tahsisat yapabiliriz. Aynı zamanda
    bu yapının içerisine başka bilgiler de yerleştirilebilmektedir. Gerçekten de özellikle TCP soket uygulamalarında okunan
    bilgilerin bir araya getirilmesi için tampona eşlik eden başka bilgilerinde bu yapıda tutulması gerekebilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <stdatomic.h>
#include <aio.h>

#define BUFFER_SIZE        4096
#define MAX_SIZE        128

typedef struct {
    struct aiocb cb;
    char buf[BUFFER_SIZE + 1];
} IOCB_INFO;

void io_proc(union sigval sval);
void exit_sys(const char *msg);

volatile atomic_int g_count;

int main(int argc, char *argv[])
{
    int fd;
    IOCB_INFO *ioinfo;

    if (argc == 1) {
        fprintf(stderr, "too few arguments!...\n");
        exit(EXIT_FAILURE);
    }

    printf("opens named pipes... it may block...\n");

    g_count = 0;
    for (int i = 1; i < argc; ++i) {
        if (g_count >= MAX_SIZE) {
            fprintf(stderr, "too many arguments, last arguments ignored!...\n");
            break;
        }
        if ((fd = open(argv[i], O_RDONLY)) == -1)
            exit_sys("open");

        printf("%s opened...\n", argv[i]);

        if ((ioinfo = (IOCB_INFO *)malloc(sizeof(IOCB_INFO))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }

        ioinfo->cb.aio_fildes = fd;
        ioinfo->cb.aio_offset = 0;
        ioinfo->cb.aio_buf = ioinfo->buf;
        ioinfo->cb.aio_nbytes = BUFFER_SIZE;
        ioinfo->cb.aio_reqprio = 0;
        ioinfo->cb.aio_sigevent.sigev_notify = SIGEV_THREAD;
        ioinfo->cb.aio_sigevent.sigev_value.sival_ptr = ioinfo;
        ioinfo->cb.aio_sigevent.sigev_notify_function = io_proc;
        ioinfo->cb.aio_sigevent.sigev_notify_attributes = NULL;

        if (aio_read(&ioinfo->cb) == -1)
            exit_sys("aio_read");

        ++g_count;
    }

    printf("waiting at pause, press Ctrl+C to exit...\n");

    pause();

    free(ioinfo);

    return 0;
}

void io_proc(union sigval sval)
{
    ssize_t result;
    IOCB_INFO *ioinfo = (IOCB_INFO *)sval.sival_ptr;

    if ((result = aio_return(&ioinfo->cb)) == -1)
        exit_sys("aio_return");

    if (result == 0) {
        printf("pipe closed...\n");
        close(ioinfo->cb.aio_fildes);
        free(ioinfo);
        --g_count;

        if (g_count == 0)
            if (raise(SIGINT) != 0)
                exit_sys("raise");
        return;
    }

    ioinfo->buf[result] = '\0';
    printf("%s", ioinfo->buf);

    if (aio_read(&ioinfo->cb) == -1)
        exit_sys("aio_read");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    aio_cancel fonksiyonu ise başlatılmış olan bir asenkron IO işlemini iptal etmek için kullanılmaktadır.

    #include <aio.h>

    int aio_cancel(int fd, struct aiocb *aiocbp);

    Fonksiyonun birinci parametresi iptal edilecek betimleyiciyi belirtir. Eğer iocb NULL geçilirse bu betimleyiciye ilişkin 
    bütün asenkron işlemler iptal edilmektedir.

    Fonksiyon AIO_CANCELED değerine geri dönerse iptal başarılıdır. AIO_NOTCANCELED değerine geri dönerse işlem aktif biçimde 
    devam etmekte olduğu için iptal başarısızdır. AIO_ALLDONE değeri ise işlemin zaten bittiğini belirtir. Fonksiyon başarısızlık 
    durumunda -1 değerine geri dönmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    aio_error isimli fonksiyon herhangi bir durumda başlatılan işlemin akıbeti konusunda bilgi almak için kullanılabilir.

    #include <aio.h>

    int aio_error(const struct aiocb *aiocbp);

    Fonksiyonun geri dönüş değeri bu asenkron işlemin o anda ne durumda olduğu hakkında bize bilgi vermektedir. Eğer fonksiyon 
    EINPROGRESS biçiminde özel bir değere geri dönerse işlemin hala devam ettiği anlamı çıkar. Geri dönüş değeri ECANCELED 
    ise bu durumda işlem aio_cancel fonksiyonuyla iptal edilmiştir (Bu geri dönüş değeri POSIX standartlarında bulunmamaktadır. Linux 
    sistemlerinde bulunmaktadır.) Fonksiyon errno değerini set etmez. Geri dönüş değeri diğer pozitif değerlerden birisi ise 
    hata ile ilgili errno değerini belirtir. Başlatılan IO işlemi başarılı bir biçimde sonlanmışsa fonksiyon 0 değerine geri 
    dönmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdiye kadar görmüş olduğumuz IO modellerinin kullanımları ve performansları hakkında şunları söyleyebiliriz:

    - select, poll modeli ve asenkron IO modeli POSIX standartlarında bulunan taşınabilir modellerdir.
    - epoll modeli ve sinyal tabanlı IO modeli Linux sistemlerine özgüdür. Yani taşınabilir değildir.
    - Linux sistemlerinde performansı en yüksek model epoll modelidir. Performans sıralaması iyiden kötüye doğru şöyledir:

    1) epoll modeli
    2) sinyal tabanlı IO modeli ve asenkron IO modeli
    3) select ve poll modeli
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Üzerinde duracağımız son IO modeli İngilizce "scatter/gather" IO modeli denilen modeldir. ("scatter" saçmak, "gather"
    toplamak anlamına gelmektedir. Buna Türkçe "saçma/toplama IO modeli" diyebiliriz.)

    Pek çok uygulamada değişik adreslerdeki bilgilerin peşi sıra dosyaya yazılması ya da dosyadan okunanların değişik adreslere
    yazılması söz konusu olabilmektedir. Örneğin bir kaydı temsil eden aşağıdaki üç bilginin birbiri ardına dosyaya yazılmak 
    istendiğini düşünelim:

    int record_len;
    char record[RECORD_SIZE];
    int record_no;

    Bu bilgilerin dosyaya yazılması için normal olarak üç ayrı write işlemi yapmak gerekir:

    if (write(fd, &record_len, sizeof(int)) != sizeof(int)) {
        ...
    }

    if (write(fd, record, RECORD_SIZE) != RECORD_SIZE) {
        ...
    }

    if (write(fd, &record_no, sizeof(int)) != sizeof(int)) {
        ...
    }

    Burada farklı adreslerde bulunan üç farklı bilgi dosyaya peşi sıra yazılmak istenmiştir. Ancak bu write işlemi göreli bir 
    zaman kaybı oluşturabilmektedir. Tabii zaman kaybı uygulamaların ancak çok azında bir önem oluşturur. Buradaki zaman kaybının 
    en önemli nedeni her write çağrısının kernel mode'a geçiş yapmasıdır. Eğer bu zaman kaybını aşağı çekmek istiyorsak ilk 
    akla gelen yöntem önce bu bilgileri başka bir tampona kopyalayıp tek bir write işlemi yapmaktır:

    char buf[BUFSIZE];

    memcpy(buf, &recordlen, sizeof(int));
    memcpy(buf + sizeof(int), record, RECORD_SIZE);
    memcpy(buf + sizeof(int) + RECORD_SIZE, &record_no, sizeof(int));

    if (write(fd, buf, 2 * sizeof(int) + RECORD_SIZE) != 2 * sizeof(int) + RECORD_SIZE) {
        ...
    }

    Bu işlem üç ayrı write işlemine göre oldukça hızlıdır. işte readv ve writev isimli fonksiyonlar farklı adreslerdeki bilgileri 
    yukarıdakine benzer biçimde dosyaya yazıp dosyadan okumaktadır. Bu işlemlere İngilizce "scatter/gather IO" denilmektedir. readv ve 
    writev fonksiyonlarının prototipleri şöyledir:

    #include <sys/uio.h>

    ssize_t readv(int fildes, const struct iovec *iov, int iovcnt);
    ssize_t writev(int fildes, const struct iovec *iov, int iovcnt);

    Fonksiyonların birinci parametreleri okuma ya da yazma işleminin yapılacağı dosya betimleyicisini, ikinci parametreleri 
    kullanılacak tampon uzunluklarının ve adreslerinin belirtildiği yapı dizisinin adresini, üçüncü parametresi de bu yapı dizisinin 
    uzunluğunu belirtir. Programcı struct iovec türünden bir yapı dizisi oluşturup onun içini doldurmalıdır. Fonksiyonlar 
    başarısızlık durumunda -1 değerine, diğer durumlarda okunan yazılan toplam byte miktarına geri dönmektedir. Okuma ve 
    yazma işlemleri tek parça halinde atomik biçimde yapılmaktadır. Yani bu okuma yazma işlemlerinin arasına başka bir dosya
    işlemi girememektedir. iovec yapısı şöyle bildirilmiştir:

    struct iovec {
        void *iov_base;
        size_t iov_len;
    };

    Yapının iov_base elemanı yazılacak ya da okunacak bilginin bellek adresini, iov_len elemanı ise bunun uzunluğunu belirtmektedir.

    Aşağıdaki örnekte aslında üç farklı write işlemi ile yapılacak yazma işlemleri tek hamlede atomik olarak writev fonksiyonuyla
    yapılmıştır. Burada farklı adreslerdeki bilgilerin dosyaya dosya göstericisinin gösterdiği yerden itibaren peşi sıra 
    yazıldığına dikkat ediniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/uio.h>

#define BUFFER_SIZE        10

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char *buf1[BUFFER_SIZE];
    char *buf2[BUFFER_SIZE];
    char *buf3[BUFFER_SIZE];
    struct iovec vec[3];

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");

    memset(buf1, 'a', BUFFER_SIZE);
    memset(buf2, 'b', BUFFER_SIZE);
    memset(buf3, 'c', BUFFER_SIZE);

    vec[0].iov_base = buf1;
    vec[0].iov_len = BUFFER_SIZE;

    vec[1].iov_base = buf2;
    vec[1].iov_len = BUFFER_SIZE;

    vec[2].iov_base = buf3;
    vec[2].iov_len = BUFFER_SIZE;

    if (writev(fd, vec, 3) == -1)
        exit_sys("writev");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda readv fonksiyonun kullanımına bir örnek verilmiştir. Burada yukarıdaki örnekte oluşturulan dosya ters bir biçimde
    readv fonksiyonu ile farklı adreslere okunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/uio.h>

#define BUFFER_SIZE        10

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char *buf1[BUFFER_SIZE];
    char *buf2[BUFFER_SIZE];
    char *buf3[BUFFER_SIZE];
    struct iovec vec[3];

    if ((fd = open("test.txt", O_RDONLY)) == -1)
        exit_sys("open");

    vec[0].iov_base = buf1;
    vec[0].iov_len = BUFFER_SIZE;

    vec[1].iov_base = buf2;
    vec[1].iov_len = BUFFER_SIZE;

    vec[2].iov_base = buf3;
    vec[2].iov_len = BUFFER_SIZE;

    if (readv(fd, vec, 3) == -1)
        exit_sys("writev");

    write(1, buf1, BUFFER_SIZE);
    write(1, buf2, BUFFER_SIZE);
    write(1, buf3, BUFFER_SIZE);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Arka planda sessiz sedasız çalışan bir kullanıcı arayüzü olmayan, kullanıcılarla terminal yoluyla etkileşmeyen programlara 
    Windows dünyasında "servis (service)", UNIX/Linux dünyasında ise "daemon (di:mın biçiminde okunuyor)" denilmektedir. Servisler 
    ya da daemon'lar tipik olarak boot süreci sırasında çalışmaya başlatılırlar ve yine tipik olarak makine reboot edilene kadar 
    çalışmaya devam ederler. Tabii böyle bir zorunluluk yoktur. Yani servis ya da daemon programlar istenildiği zaman başlatılıp 
    istenildiği zaman sonlandırılabilmektedir. "Servis" ya da "daemon" kernel mod bir kavram değildir. Yani servisler ve daemon'lar 
    genellikle "user mode'da" çalışmak üzere yazılırlar. UNIX/Linux dünyasında geleneksel olarak daemon'lar "xxxxxd" biçiminde 
    sonuna 'd' harfi getirilerek isimlendirilmektedir. Çekirdeğe ilişkin bazı thread'ler de servis benzeri işlemler yaptıkları için 
    bunlar da çoğu kez sonu 'd' ile bitecek ancak başı da 'k' ile başlayacak biçimde isimlendirilmiştir. Bu kernel daemon'ların 
    bizim şu andaki konumuz olan daemon'larla hiçbir ilgisi yoktur. Yalnızca işlev bakımından bir benzerlik söz konusudur. UNIX/Linux 
    dünyasında daemon denildiğinde akla öncelikle "server programlar" gelmektedir. Örneğin ftp server programı (ftpd) ve http server 
    programı (httpd) daemon programlar biçiminde yazılmışlardır. Daemon'lar genellikle arka planda önemli işlemler yaptıkları için 
    uygun önceliklerle (yani sudo ile root hakkıyla) çalıştırılırlar.

    Daemon programlar pek çok modern UNIX/Linux sisteminde "init paketleri" içerisindeki özel utility'ler tarafından başlatılıp, 
    sürdürülüp, sonlandırılmaktadır. Yani ilgili dağıtımın bu daemon'ları idare etmek için özel komutları bulunabilmektedir. Linux 
    sistemlerinde init prosesi ve diğer proseslerin kodları ve boot süreci ile ilgili utility'ler "init paketleri" denilen paketler 
    biçiminde farklı proje grupları tarafından oluşturulmuştur. Başka bir deyişle "servis yönetim (service management)" işlemleri 
    organize bir biçimde bu "init paketleri" tarafından yapılmaktadır. Yaygın olarak kullanılan üç "init paketi" bulunmaktadır:

    1) SysVinit: Klasik System5'teki işlevleri yapan init paketidir. Linux uzun bir süre bu paketi kullanmıştır.
    2) Upstart: 2006 yılında oluşturulmuştur ve 2010'ların ortalarına kadar (bazı dağıtımlarda hala) kullanılmaya yaygın 
    biçimde kullanılmıştır.
    3) systemd: 2010 yılında oluşturulmuştur ve son yıllarda pek çok Linux dağıtımında kullanılmaya başlanmıştır. Bugün en 
    yaygın kullanılan init paketi durumundadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                94. Ders 04/11/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir daemon programı yazabilmek için öncelikle onun terminal bağlantısının kesilmesi gerekmektedir. Bir programı komut 
    satırından sonuna & getirerek "arka plan proses grubu" biçiminde çalıştırarak daemon oluşturamayız. Çünkü bu durumda terminal 
    kapatıldığında bizim prosesimiz de SIGHUP sinyali yüzünden kapatılacaktır.

    Bir daemon programın yazılması tipik olarak şu aşamalardan geçilerek yapılmaktadır:

    1) Daemon programlar bir dosya açmak istediklerinde tam olarak belirlenen haklarla bunu yapmalıdırlar. Bu nedenle bu proseslerin
    umask değerlerinin 0 yapılması uygun olur. Örneğin:

    umask(0);

    2) Bir prosesin daemon etkisi yaratması için terminalle bir bağlantısının kalmaması gerekir. Bu da basit bir biçimde maalesef
    0, 1, 2 numaralı terminal betimleyicilerinin kapatılmasıyla sağlanamaz. Bunu sağlamanın en temel yolu setsid fonksiyonunu 
    çağırmaktır. Anımsanacağı gibi setsid fonksiyonu yeni bir oturum (session) ve yeni bir proses grubu oluşturup ilgili prosesi 
    bu proses grubunun ve oturumun lideri yapmaktadır. Ayrıca setsid fonksiyonu prosesin terminal ilişkisini (controlling terminal) 
    de ortadan kaldırmaktadır. Ancak setsid uygulayabilmek için prosesin herhangi bir proses grup lideri olmaması gerekir. Aksi 
    takdirde setsid fonksiyonu başarısız olmaktadır. Yine anımsanacağı gibi kabuk programlar çalıştırdıkları programlar için bir 
    proses grubu yaratıp o programı da proses grup lideri yapıyordu. İşte proses grup lideri olmaktan kurtulmak için bir kez fork 
    yapıp üst prosesi sonlandırabiliriz. Aynı zamanda bu işlem kabuk programının hemen komut satırına yeniden düşmesine yol açacaktır. 
    O halde 2'nci aşamada fork işlemi yapılıp üst proses sonlandırılmalıdır. Örneğin:

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0)
        _exit(EXIT_SUCCESS);

    3) Artık alt proses setsid fonksiyonunu uygulayarak yeni bir oturum yaratır ve terminal ilişkisini keser. Terminal ilişkisinin 
    kesilmesi ile artık terminal kapatılsa bile programımız çalışmaya devam edecektir. Tabii setsid ile terminal bağlantısının kesilmiş 
    olması programın terminale bir şey yazamayacağı anlamına gelmez. Hala 0, 1, 2 numaralı betimleyiciler açıktır. Terminal açık 
    olduğu sürece oraya yazma yapılabilir. Örneğin:

    if (setsid() == -1)
        _exit(EXIT_FAILURE);

    4) Daemon programların çalışma dizinlerinin (current working directory) sağlam bir dizin olması tavsiye edilir. Aksi takdirde 
    o dizin silinirse arka plan programların çalışmaları bozulabilir. Bu nedenle daemon programlar çoğu kök dizini (silinemeyeceği 
    için) çalışma dizini yapmaktadır. Tabii bu zorunlu değildir. Bunun yerine varlığı garanti edilmiş olan herhangi bir dizin de 
    çalışma dizini yapılabilir. Örneğin:

    if (chdir("/") == -1)
        _exit(EXIT_FAILURE);

    5) Daemon programın o ana kadar açılmış olan tüm betimleyicileri kapatması uygun olur. Örneğin 0, 1, 2 numaralı betimleyiciler
    ilgili terminale ilişkindir ve artık o terminal kapatılmış ya da kapatılacak olabilir. Program kendini daemon yaptığı sırada 
    açmış olduğu diğer dosyaları da kapatmalıdır. Bunu sağlamanın basit bir yolu prosesin toplam dosya betimleyici tablosunun 
    uzunluğunu elde edip her bir betimleyici için close işlemi uygulamaktır. Çünkü maalesef biz açık betimleyicileri pratik bir 
    biçimde tespit edememekteyiz. Zaten kapalı bir betimleyiciye close uygulanırsa close başarısız olur, ancak program çökmez. 
    Anımsanacağı gibi prosesin toplam betimleyici sayısı sysconf çağrısında _SC_OPEN_MAX argümanıyla ya da getrlimit fonksiyonunda 
    RLIMIT_NOFILE argümanıyla elde edilebilir. İki fonksiyon da aynı değeri vermektedir. Örneğin:

    long maxfd;

    if ((maxfd = sysconf(_SC_OPEN_MAX)) == -1)
        _exit(EXIT_FAILURE);

    for (long i = 0; i < maxfd; ++i)
        close(i);

    6) Zorunlu olmamakla birlikte ilk üç betimleyiciyi "/dev/null" aygıtına yönlendirmek iyi bir fikirdir. Çünkü daemon içerisinde
    çağıracağımız bazı fonksiyonlar bu betimleyicileri kullanıyor olabilirler. Anımsanacağı gibi "/dev/null" aygıtına yazılanlar 
    zaten kaybolmaktadır. Bu aygıttan okuma yapılmak istendiğinde ise EOF etkisi oluşmaktadır. Örneğin:

    int fd;

    if ((fd = open("/dev/null", O_RDONLY)) == -1)        // fd is guaranteed to be 0
        _exit(EXIT_FAILURE);

    if (dup(fd) == -1 || dup(fd) == -1)                    // now descriptor 1 and 2 redirected /dev/null
        _exit(EXIT_FAILURE);

    Burada bazı programcılar (örneğin Stevent & Rago ile Kerrisk'in kitaplarında bu biçimde) elde edilen betimleyicilerin 
    0, 1 ve 2 olduğunu doğrulamaya çalışmaktadır. Tüm betimleyiciler kapatıldığına göre ve open ile dup fonksiyonları 
    en düşük betimleyicileri verdiğine göre böyle bir kontrolün yapılmasına aslında gerek yoktur. Bu kontrolün tek anlamı
    çok thread'li uygulamalarda o sırada başka bir thread'in bu noktada dosya açıyor olmasıdır. Böyle bir olasılığı 
    değerlendirmek isterseniz kodu şöyle değiştirebilirsiniz:

    int fd0, fd1, fd2;

    if ((fd0 = open("/dev/null", O_RDONLY)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd1 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd2 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if (fd0 != 0 || fd1 != 1 || fd2 != 2)
        _exit(EXIT_FAILURE);

    Pekiyi daemon'lar ne yaparlar? İşte daemon'lar arka planda genellikle sürekli bir biçimde birtakım işler yapmaktadır. 
    Bu anlamda en tipik daemon örnekleri "server" programlardır. Örneğin http server aslında httpd isimli bir daemon'dan 
    ibarettir. Bunun gibi UNIX/Linux sistemlerinde genellikle boot zamanında devreye giren onlarca daemon program vardır. 
    Örneğin belli zamanlarda belli işlerin yapılması için kullanılan "cron" utility'si aslında bir daemon olarak çalışmaktadır.

    Yukarıda da belirttiğimiz gibi daemon'lar genellikle yetki gerektiren işlemler yaptıkları için uygun önceliğe sahip olacak 
    biçimde (yani root olarak) çalıştırılmaktadırlar.

    Aşağıdaki örnekte tipik bir daemon program iskeleti oluşturulmuştur. Programın sonuna bir pause çağrısı yerleştirdik. 
    Daemon'ı sonlandırmak için proses id'sini bulup kill işlemi uygulayabilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/* mydaemond.c */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

#define DEF_FDT_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;
    long maxfd;
    int fd0, fd1, fd2;

    umask(0);

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0)
        _exit(EXIT_SUCCESS);

    if (setsid() == -1)
        _exit(EXIT_FAILURE);

    if (chdir("/") == -1)
        _exit(EXIT_FAILURE);

    errno = 0;
    if ((maxfd = sysconf(_SC_OPEN_MAX)) == -1)
        if (errno == 0)
            maxfd = DEF_FDT_SIZE;
        else
            _exit(EXIT_FAILURE);

    for (long i = 0; i < maxfd; ++i)
        close(i);

    if ((fd0 = open("/dev/null", O_RDONLY)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd1 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd2 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if (fd0 != 0 || fd1 != 1 || fd2 != 2)
        _exit(EXIT_FAILURE);

    pause();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında yukarıdaki işlemleri bir fonksiyona da yaptırabiliriz. Böylece o fonksiyonu çağırdığımızda proses bir daemon 
    haline getirilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* mydaemond.c */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void exit_sys(const char *msg);

#define DEF_FDT_SIZE        4096

void make_daemon(void)
{
    pid_t pid;
    long maxfd;
    int fd0, fd1, fd2;

    umask(0);

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0)
        _exit(EXIT_SUCCESS);

    if (setsid() == -1)
        _exit(EXIT_FAILURE);

    if (chdir("/") == -1)
        _exit(EXIT_FAILURE);

    errno = 0;
    if ((maxfd = sysconf(_SC_OPEN_MAX)) == -1)
        if (errno == 0)
            maxfd = DEF_FDT_SIZE;
        else
            _exit(EXIT_FAILURE);

    for (long i = 0; i < maxfd; ++i)
        close(i);

    if ((fd0 = open("/dev/null", O_RDONLY)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd1 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd2 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if (fd0 != 0 || fd1 != 1 || fd2 != 2)
        _exit(EXIT_FAILURE);
}

int main(void)
{
    make_daemon();

    pause();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                95. Ders 05/11/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir daemon ne zaman ve nasıl sonlandırılmalıdır? Daemon'lar arka planda sessiz sedasız çalıştığından onların 
    sonlandırılması sinyaller yoluyla yapılabilir. Tipik olarak daemon'lar SIGTERM sinyali ile sonlandırılmaktadır. Anımsanacağı
    gibi SIGTERM sinyali ele alınabilir bir sinyaldir (SIGKILL sinyalinin ele alınamayacağını anımsayınız). İşte bir daemon 
    birtakım son işlemler yapacaksa bunu SIGTERM sinyali oluştuğunda bu sinyali set ederek yapabilmektedir. Pekiyi daemon 
    hiç sonlandırılmazsa ne olur? İşletim sistemi kapanırken bütün proseslere zaten önce SIGTERM sinyali göndermektedir. 
    Dolayısıyla daemon'lar en kötü olasılıkla birtakım son işlemleri sistem kapatılırken SIGTERM sinyali yoluyla yapabilirler. 
    Ancak sistemler genellikle SIGTERM sinyalinden sonra proseslere belli bir süre bekleyip SIGKILL sinyali de göndermektedir. 
    Örneğin Linux kapanırken SIGTERM sinyalindan yaklaşık 5 saniye sonra her ihtimale karşı proseslere SIGKILL sinyali de
    göndermektedir. Bu durumda daemon programların son işlemlerini bu zaman aralığı içerisinde yavaş olmayacak biçimde 
    yapması beklenir.

    Aşağıdaki daemon programının SIGTERM sinyalini işlemesi örneği verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* mydaemond.c */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <signal.h>

void sigterm_handler(int signo);
void exit_sys(const char *msg);

#define DEF_FDT_SIZE        4096

void make_daemon(void)
{
    pid_t pid;
    long maxfd;
    int fd0, fd1, fd2;

    umask(0);

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0)
        _exit(EXIT_SUCCESS);

    if (setsid() == -1)
        _exit(EXIT_FAILURE);

    if (chdir("/") == -1)
        _exit(EXIT_FAILURE);

    errno = 0;
    if ((maxfd = sysconf(_SC_OPEN_MAX)) == -1)
        if (errno == 0)
            maxfd = DEF_FDT_SIZE;
        else
            _exit(EXIT_FAILURE);

    for (long i = 0; i < maxfd; ++i)
        close(i);

    if ((fd0 = open("/dev/null", O_RDONLY)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd1 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd2 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if (fd0 != 0 || fd1 != 1 || fd2 != 2)
        _exit(EXIT_FAILURE);
}

int main(void)
{
    struct sigaction sa;

    sa.sa_handler = sigterm_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGTERM, &sa, NULL) == -1)
        exit_sys("sigaction");

    make_daemon();

    pause();

    return 0;
}

void sigterm_handler(int signo)
{
    /* cleanup processing */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Daemon programlar genellikle başlatılırken bazı yönergeleri kullanıcıların oluşturduğu konfigürasyon dosyalarından okumaktadır.
    Bu konfigürasyon dosyaları geleneksel olarak "/etc" dizininin altında uzantısı ".conf" olacak biçimde oluşturulmaktadır. 
    Örneğin bizim daemon programımız "/etc/mydaemond.conf" dosyasını okuyup yönergeleri oradan alacak olabilir. Bu dosya henüz 
    daemon'laştırma yapılmadan da okunabilir ya da daemon'laştırma yapıldıktan sonra da okunabilir. Daemon'laştırma yapıldıktan 
    sonra konfigürasyon dosyasını açarken ve sonraki işlemlerde başarısızlıklara ilişkin mesajların artık terminale yazılamayacağına 
    dikkat ediniz. Bunun için log mekanizmaları kullanılmaktadır. Örneğin:

    int main(void)
    {
        struct sigaction sa;

        make_daemon();
        read_config();

        sa.sa_handler = sigterm_handler;
        sigemptyset(&sa.sa_mask);
        sa.sa_flags = SA_RESTART;

        if (sigaction(SIGTERM, &sa, NULL) == -1) {
            // log mekanizması yoluyla hata mesajı oluşturulabilir
            _exit(EXIT_FAILURE);
        }

        // ...

        return 0;
    }

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Daemon'ların çoğu tek bir proses olarak çalışmak zorundadır. Yani daemon'ın başka kopyasının da çalıştırılabilmesi 
    problemlere yol açabilmektedir. Daemon yazarken onun tek kopyasının çalıştığına emin olmak isteyebilirsiniz. Bunun nasıl 
    yapıldığını "dosya kilitleme işlemlerinde" açıklamıştık. Geleneksel olarak daemon'lar bu amaçla "/run" dizini içerisinde 
    ".pid" uzantılı dosyalar oluşturmaktadır. Bu "/run" dizinine sıradan prosesler tarafından yazma hakkı verilmemektedir. Yani 
    bu dizinde dosya yaratmak istiyorsanız daemon programınızı uygun önceliğe sahip olacak biçimde (yani root olarak)" 
    çalıştırmalısınız.

    Aşağıda daemon'ın tek bir kopyasının çalıştırılmasının sağlanmasına yönelik bir örnek verilmiştir. Programı sudo ile 
    çalıştırmayı unutmayınız.
---------------------------------------------------------------------------------------------------------------------------*/

/* mydaemond.c */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <signal.h>
#include <sys/file.h>

void read_config(void);
void check_instance(void);
void sigterm_handler(int signo);
void exit_sys(const char *msg);

#define DEF_FDT_SIZE        4096
#define LOCK_FILE_PATH        "/run/mydaemond.pid"
#define CONFIG_FILE            "/etc/mydaemond.conf"

void make_daemon(void)
{
    pid_t pid;
    long maxfd;
    int fd0, fd1, fd2;

    umask(0);

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0)
        _exit(EXIT_SUCCESS);

    if (setsid() == -1)
        _exit(EXIT_FAILURE);

    if (chdir("/") == -1)
        _exit(EXIT_FAILURE);

    errno = 0;
    if ((maxfd = sysconf(_SC_OPEN_MAX)) == -1)
        if (errno == 0)
            maxfd = DEF_FDT_SIZE;
        else
            _exit(EXIT_FAILURE);

    for (long i = 0; i < maxfd; ++i)
        close(i);

    if ((fd0 = open("/dev/null", O_RDONLY)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd1 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd2 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if (fd0 != 0 || fd1 != 1 || fd2 != 2)
        _exit(EXIT_FAILURE);
}

int main(void)
{
    struct sigaction sa;

    make_daemon();
    check_instance();
    read_config();

    sa.sa_handler = sigterm_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGTERM, &sa, NULL) == -1) {
        /* log mekanizması yoluyla hata mesajı oluşturulabilir */
        _exit(EXIT_FAILURE);
    }

    pause();

    return 0;
}

void read_config(void)
{
    /* ... */
}

void check_instance(void)
{
    int fd;

    if ((fd = open(LOCK_FILE_PATH, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR)) == -1) {
        /* log mekanizması ile mesaj oluşturulabilir */
        _exit(EXIT_FAILURE);
    }

    if (flock(fd, LOCK_EX|LOCK_NB) == -1) {
        if (errno == EWOULDBLOCK) {
                /* log mekanizması ile mesaj oluşturulabilir */
        }
        else {
                /* log mekanizması ile mesaj oluşturulabilir */
        }
        _exit(EXIT_FAILURE);
    }
}

void sigterm_handler(int signo)
{
    /* cleanup processing */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Daemon programların "reinitialize" edilebilmesi sık karşılaşılan bir uygulamadır. Daemon program konfigürasyon dosyasını 
    okuyup çalıştıktan sonra onu durdurmadan adeta reset etmek isteyebiliriz. Örneğin daemon çalışırken konfigürasyon dosyasında
    bir değişiklik yapabiliriz. O değişiklikten sonra yeniden daemon programının o konfigürasyon dosyasını çalıştırmasını sağlamak 
    isteyebiliriz. Genel olarak bu işlem için SIGHUP sinyalinden faydalanılmaktadır. SIGHUP sinyali terminal aygıt sürücüsü ve 
    kabuk programları tarafından kullanılan bir sinyaldir. Ancak daemon programının terminal bağlantısı kesildiğinden SIGHUP 
    sinyali daemon programlar için "boşa çıkmış ve kullanılabilir" bir sinyal durumundadır.

    Aşağıda SIGHUP sinyalinin işlenmesine yönelik bir örnek verilmiştir. Burada konfigürasyon dosyası sinyal fonksiyonu 
    içerisinde okunmuştur. Bu durumda bu işlemlerin asenkron sinyal güvenli bir biçimde yapılması gerekir. Tabii buna 
    alternatifler de söz konusu olabilir. Örneğin sinyal fonksiyonunda bir bayrak set edilip başka bir yerde bu bayrağa
    bakılabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* mydaemond.c */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <signal.h>
#include <sys/file.h>

void read_config(void);
void check_instance(void);
void sigterm_handler(int signo);
void sighup_handler(int signo);
void exit_sys(const char *msg);

#define DEF_FDT_SIZE        4096
#define LOCK_FILE_PATH        "/run/mydaemond.pid"
#define CONFIG_FILE            "/etc/mydaemond.conf"

void make_daemon(void)
{
    pid_t pid;
    long maxfd;
    int fd0, fd1, fd2;

    umask(0);

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0)
        _exit(EXIT_SUCCESS);

    if (setsid() == -1)
        _exit(EXIT_FAILURE);

    if (chdir("/") == -1)
        _exit(EXIT_FAILURE);

    errno = 0;
    if ((maxfd = sysconf(_SC_OPEN_MAX)) == -1)
        if (errno == 0)
            maxfd = DEF_FDT_SIZE;
        else
            _exit(EXIT_FAILURE);

    for (long i = 0; i < maxfd; ++i)
        close(i);

    if ((fd0 = open("/dev/null", O_RDONLY)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd1 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if ((fd2 = dup(fd0)) == -1)
        _exit(EXIT_FAILURE);

    if (fd0 != 0 || fd1 != 1 || fd2 != 2)
        _exit(EXIT_FAILURE);
}

int main(void)
{
    struct sigaction sa;
    int fd;

    make_daemon();
    check_instance();
    read_config();

    sa.sa_handler = sigterm_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGTERM, &sa, NULL) == -1) {
        /* log mekanizması yoluyla hata mesajı oluşturulabilir */
        _exit(EXIT_FAILURE);
    }

    sa.sa_handler = sighup_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGHUP, &sa, NULL) == -1) {
        /* log mekanizması yoluyla hata mesajı oluşturulabilir */
        _exit(EXIT_FAILURE);
    }

    /* ... */

    pause();

    return 0;
}

void read_config(void)
{
    /* ... */
}

void check_instance(void)
{
    int fd;

    if ((fd = open(LOCK_FILE_PATH, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR)) == -1) {
        /* log mekanizması ile mesaj oluşturulabilir */
        _exit(EXIT_FAILURE);
    }

    if (flock(fd, LOCK_EX|LOCK_NB) == -1) {
        if (errno == EWOULDBLOCK) {
                /* log mekanizması ile mesaj oluşturulabilir */
        }
        else {
                /* log mekanizması ile mesaj oluşturulabilir */
        }
        _exit(EXIT_FAILURE);
    }
}

void sigterm_handler(int signo)
{
    /* cleanup processing */
}

void sighup_handler(int signo)
{
    read_config();        /* read_config asenkron sinyal güvenli bir fonksiyon olmalı */
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Daemon gibi programlarda, kernel modüllerinde bir terminal bağlantısı olmadığı için hata mesajlarının ve diğer mesajların 
    ekrana yazdırılması mümkün olmayabilir ya da uygun olmayabilir. İşte bu tür durumlarda birtakım mesajların bir log'lama
    mekanizması yoluyla oluşturulması gerekebilmektedir.

    UNIX/Linux sistemlerinde kernel tarafından desteklenen kapsamlı bir log mekanizması bulunmaktadır. Bu log mekanizması 
    değişik kaynaklardan gelen mesajların biriktirilip saklanmasını sağlamaktadır. Bu merkezi log mekanizması aslında ilk BSD 
    sistemlerinde uygulanmıştır. Ancak daha sonra genelleştirilmiştir ve POSIX standartlarına yansıtılmıştır. Bu log mekanizması 
    genel olarak "syslog" ismiyle belirtilmektedir. Öncelikle Linux sistemleri için bu merkezi syslog mekanizmasının çalışma 
    biçimi hakkında bilgi vereceğiz. Bu çalışma açıklanırken genellikle şekillerden faydalanılmaktadır. Ancak burada text editörde 
    çalıştığımızdan dolayı bu şekli çizemiyoruz. Bunun için "Linux Programming Environment" kitabının 775'inci sayfasına başvurabilirsiniz. 
    Biz burada sözel anlatım uygulayacağız. Linux sistemlerindeki merkezi syslog mekanizması ile diğer sistemlerdeki syslog 
    mekanizması bazı ayrıntılar dışında birbirine benzemektedir.

    Merkezi syslog mekanizmasının üst seviye önemli bir bileşeni "syslogd" isimli bir daemon programdır. Bu program user mode'da
    çalışmaktadır. syslogd daemon programı iki kaynaktan mesajları alarak hedefte oluşturmaktadır. Loglamanın hedefi değiştirilebilmektedir. 
    syslogd daemon programının mesajları okuduğu iki kaynak şöyledir:

    1) Yerel kullanımlar için /dev/log isimli UNIX domain datagram soket dosyası
    2) Uzaktan kullanımlar için UDP 514 portu

    "/dev/log" isimli UDP UNIX domain soketine temelde iki aktör yazmaktadır. Bunlardan biri normal kullanıcılardır. Örneğin 
    biz bir daemon yazarken mesajları syslog isimli POSIX fonksiyonu ile oluştururuz. Bu POSIX fonksiyonu da aslında bu 
    sokete yazma yapmaktadır:

    user (syslog POSIX fonksiyonu) ---> /dev/log (UDP UNIX domain soket) <--- syslogd daemon okuyor

    /dev/log dosyasına yazan ikinci aktör ise aygıt sürücüler ve kernel modüllerdir. Bu kodlar kernel fonksiyonları ile "klogd" 
    isimli kernel mode'daki daemon programa mesajları aktarmaktadır. Bu kernel mod daemon programı da /dev/log dosyasına yazma 
    yapmaktadır:

    Aygıt sürücüler ve kernel modüller (printk) <--- klogd daemon'ı okuyor ---> /dev/log <--- syslogd daemon okuyor

    Loglama amacıyla user mod programlarda biz genellikle izleyen paragraflarda açıklayacağımız POSIX fonksiyonlarını kullanırız. 
    Ancak kernel mod programlarda (kernel modüllerinde ve aygıt sürücülerinde) genellikle printk gibi bir kernel fonksiyonu 
    kullanılmaktadır. Yukarıdaki şekillerden de gördüğünüz gibi her iki mekanizmada aynı loglama sistemine bilgileri aktarmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                96. Ders 11/11/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    User mode'da loglama işlemleri için üç POSIX fonksiyonu kullanılmaktadır:

    openlog
    syslog
    closelog

    openlog fonksiyonu loglama mekanizmasını başlatır, syslog fonksiyonu loglama işlemlerini yapar ve closelog fonksiyonu da 
    sistemi kapatır. openlog fonksiyonu aslında mekanizma için zorunlu bir fonksiyon değildir. openlog fonksiyonunun prototipi 
    şöyledir:

    #include <syslog.h>

    void openlog(const char *ident, int logopt, int facility);

    Fonksiyonun birinci parametresi log mesajlarında görüntülenecek program ismini belirtmektedir. Genellikle programcılar bu 
    parametre için program ismini argüman olarak verirler. Linux sistemlerinde bu parametreye NULL geçilebilmektedir. Bu durumda 
    sanki bu parametre için program ismi yazılmış gibi işlem yapılır. Ancak POSIX standartlarında NULL geçme durumu belirtilmemiştir. 
    İkinci parametre aşağıdaki sembolik sabitlerin bit or işlemine sokulmasıyla oluşturulabilir:

    LOG_PID
    LOG_CONS
    LOG_NDELAY
    LOG_ODELAY
    LOG_NOWAIT

    Burada LOG_PID log mesajında prosesin proses id'sinin de bulundurulacağını belirtir. LOG_CONS log mesajlarının aynı zamanda 
    default console'a ("/dev/console") da yazılacağını belirtmektedir. LOG_NDELAY bayrağı loglama sisteminin hemen açılması gerektiğini
    belirtir. Normal olarak bu sistem ilk loglama yapıldığında açılmaktadır. LOG_ODELAY zaten default durumdur. Loglama sistemi 
    ilk log işlemi yapıldığında açılır. LOG_NOWAIT alt prosesler söz konusu olduğunda loglama için alt proseslerin yaratılmasının 
    beklenmeyeceği anlamına gelmektedir. Bu parametre istenirse 0 olarak da geçilebilir. Ancak tipik uygulamalarda LOG_PID 
    biçiminde geçilmektedir.

    Fonksiyonun üçüncü parametresi log mesajını yollayan prosesin kim olduğu hakkında temel bir bilgi vermek için düşünülmüştür. 
    LOG_USER bir user proses tarafından bu loglamanın yapıldığını belirtmektedir. LOG_KERN mesajın kernel tarafından gönderildiğini 
    belirtir. LOG_DAEMON (POSIX'te yok) mesajın bir sistem daemon programı tarafından gönderildiğini belirtmektedir. LOG_LOCAL0'dan 
    LOG_LOCAL7'ye kadarki sembolik sabitler özel log kaynaklarını belirtmektedir. Bu parametre de 0 olarak geçilebilir. Bu durumda 
    LOG_USER değeri girilmiş gibi işlem yapılmaktadır. Ancak tipik olarak LOG_USER biçiminde geçilmektedir.

    openlog fonksiyonunun başarısı kontrol edilememektedir. Çünkü fonksiyonun geri dönüş değeri void biçimdedir.

    Örneğin:

    openlog("sample", LOG_PID, LOG_USER);

    Log mesajlarının aktarımı için asıl fonksiyon syslog isimli fonksiyondur. Fonksiyonun prototipi şöyledir:

    #include <syslog.h>

    void syslog(int priority, const char *format, ...);

    Fonksiyonun birinci parametresi mesajın öncelik derecesini (yani önemini) belirtir. Diğer parametreler tamamen printf fonksiyonundaki 
    gibidir. Öncelik değerleri şunlardır:

    LOG_EMERG
    LOG_ALERT
    LOG_CRIT
    LOG_ERR
    LOG_WARNING
    LOG_NOTICE
    LOG_INFO
    LOG_DEBUG

    En çok kullanılanlar error mesajları için LOG_ERR, uyarı mesajları için LOG_WARNING ve genel bilgilendirme mesajları 
    için LOG_INFO değerleridir. Buradaki değerler log mesajlarında görüntülenmektedir. Örneğin:

    syslog(LOG_ERR, "invalid operation");

    Yukarıda openlog fonksiyonunun çağrılmasının zorunlu olmadığını belirtmiştik. Bu durumda openlog fonksiyonundaki belirlemeler
    için default değerler alınmaktadır. Ancak istenirse openlog fonksiyonunun üçüncü parametresi syslog fonksiyonunun birinci 
    parametresiyle kombine edilebilir. Biz örneklerimizde openlog fonksiyonunu çağıracağız. syslog fonksiyonunun da geri dönüş 
    değerinin void olduğuna dikkat ediniz.

    Nihayet loglama mekanizması eğer açılmışsa onu kapatmak için closelog fonksiyonu kullanılmaktadır. Bu fonksiyon eğer loglama 
    mekanizması henüz açılmadıysa bir şey yapmamaktadır. Fonksiyonun prototipi şöyledir:

    #include <syslog.h>

    void closelog(void);

    Pekiyi log mesajları nereye aktarılmaktadır? İşte aslında işletim sistemlerinde hedef çeşitli biçimlerde değiştirilebilmektedir. 
    Ancak Linux'un ileri sürümlerinde default hedef "/var/log/syslog" dosyasıdır. Bu dosya sistemi disk tabanlı bir sistem değildir. 
    Dolayısıyla buradaki bilgiler reboot işleminde kalıcı değildir. Bu dosya uzayabileceği için bir kuyruk sistemi gibi oluşturulmaktadır. 
    Yani belli süre sonra önce yazılmış olan mesajlar kaybolabilmektedir. Dosyanın sonunu görebilmek için "tail" komutunu 
    kullanabilirsiniz. tail komutu default olarak dosyanın sonundaki 10 satırı göstermektedir. Ancak -n seçeneği ile daha fazla 
    satır görüntülenebilmektedir.

    Aşağıda loglama için basit bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <syslog.h>

int main(void)
{
    openlog("sample", LOG_PID, LOG_USER);

    syslog(LOG_INFO, "This is a test...");

    closelog();

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi syslog log mesajlarını nereye yazmaktadır? Yukarıda da belirttiğimiz gibi aslında syslog fonksiyonu log mesajlarını 
    "/dev/log" ismindeki UNIX domain datagram sokete yazmaktadır. Bu soketten okuma yapan "syslogd" isimli bir daemon vardır.
    Ancak yeni Linux sistemlerinde bu daemon'ın biraz daha gelişmiş biçimi olan "rsyslogd" daemon'ı da kullanılmaktadır. 
    Kursun yapıldığı zamanlarda Linux sistemlerinde yaygın olarak "rsyslogd" isimli daemon kullanılmaktadır. İşte aslında 
    log mesajlarının hangi dosyalara yazılacağına "syslogd" ya da "rsyslogd" daemon'ları karar vermektedir. Bu daemon'lar 
    çalışmaya başladıklarında default durumda "/etc/syslog.conf" ya da "/etc/rsyslog.conf" dosyalarına bakmaktadır. İşte aslında 
    bu daemon'ların hangi dosyalara yazacağı bu konfigürasyon dosyalarında sistem yöneticisi tarafından belirlenmektedir. 
    Ancak bu dosyada da belirleme yapılmamışsa default olarak pek çok mesaj grubu (error, warning, info) "/var/log/syslog" 
    dosyasına yazılmaktadır. O halde programcı syslog mesajları için default durumda bu dosyaya başvurmalıdır.

    Log dosyalarını incelemek için pek çok utility bulunmaktadır. Örneğin lnav, glogg, ksystemlog gibi. systemd init paketi 
    içerisindeki servis programları olan systemctl ve journalctl komutları ile de görüntüleme yapılabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de log mekanizmasının bir daemon programda kullanımına bir örnek verelim. Merkezi log mekanizması daha çok terminal 
    ilişkisi olmayan daemon'lar ve aygıt sürücüler gibi programlar tarafından kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/* mydaemond.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <signal.h>
#include <sys/file.h>
#include <syslog.h>

void read_config(void);
void check_instance(void);
void sigterm_handler(int signo);
void sighup_handler(int signo);
void exit_daemon(const char *msg);

#define DEF_FDT_SIZE        4096
#define LOCK_FILE_PATH        "/run/mydaemond.pid"
#define CONFIG_FILE            "/etc/mydaemond.conf"

void make_daemon(void)
{
    pid_t pid;
    long maxfd;
    int fd0, fd1, fd2;

    umask(0);

    if ((pid = fork()) == -1)
        exit_daemon("fork");

    if (pid != 0)
        _exit(EXIT_SUCCESS);

    if (setsid() == -1)
        exit_daemon("setsid");

    if (chdir("/") == -1)
        exit_daemon("chdir");

    errno = 0;
    if ((maxfd = sysconf(_SC_OPEN_MAX)) == -1)
        if (errno == 0)
            maxfd = DEF_FDT_SIZE;
        else
            exit_daemon("sysconf");

    for (long i = 0; i < maxfd; ++i)
        close(i);

    if ((fd0 = open("/dev/null", O_RDONLY)) == -1)
        exit_daemon("open");

    if ((fd1 = dup(fd0)) == -1)
        exit_daemon("dup");

    if ((fd2 = dup(fd0)) == -1)
        exit_daemon("dup");

    if (fd0 != 0 || fd1 != 1 || fd2 != 2) {
        syslog(LOG_ERR, "invalid file descriptors");
        _exit(EXIT_FAILURE);
    }
}

int main(void)
{
    struct sigaction sa;
    int fd;

    openlog("mydaemond", LOG_PID, LOG_USER);

    make_daemon();
    check_instance();
    read_config();

    sa.sa_handler = sigterm_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGTERM, &sa, NULL) == -1)
        exit_daemon("sigaction");

    sa.sa_handler = sighup_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGHUP, &sa, NULL) == -1)
        exit_daemon("sigaction");

    syslog(LOG_INFO, "ok, daemon is running");

    for (;;)
        pause();

    closelog();

    return 0;
}

void read_config(void)
{
    syslog(LOG_INFO, "mydaemon is reading configuration file...");
}

void check_instance(void)
{
    int fd;

    if ((fd = open(LOCK_FILE_PATH, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR)) == -1)
        exit_daemon("open");

    if (flock(fd, LOCK_EX|LOCK_NB) == -1) {
        if (errno == EWOULDBLOCK) {
            syslog(LOG_ERR, "Only one instance of this daemon can be run...");
            _exit(EXIT_FAILURE);
        }
        exit_daemon("flock");
    }
}

void sigterm_handler(int signo)
{
    syslog(LOG_INFO, "mydaemond is terminating...");

    closelog();

    _exit(EXIT_SUCCESS);
}

void sighup_handler(int signo)
{
    syslog(LOG_INFO, "mydaemond got SIGHUP and read config file...");

    read_config();        /* read_config asenkron sinyal güvenli bir fonksiyon olmalı */
}

void exit_daemon(const char *msg)
{
    syslog(LOG_ERR, "%s: %s", msg, strerror(errno));

    closelog();

    _exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux dünyasında boot işleminden sonra sistemin işler hale getirilebilmesi için ve servis yönetimlerinin yapılması 
    için kullanılan programların bulunduğu paketlere "init paketleri" denilmektedir. Örneğin init prosesinin kodları da bu 
    paketin içerisindedir.

    Yukarıda da belirtildiği gibi pek çok daemon aslında sistem boot edilirken çalıştırılmakta ve sistem kapatılana kadar 
    çalışır durumda kalmaktadır. Fakat bazı daemon'lar ise gerektiğinde çalıştırılıp, gerekmediğinde durdurulabilmektedir. 
    İşte UNIX/Linux sistemlerinde bu çalıştırma, durdurma gibi faaliyetler için "init paketleri" içerisinde daha yüksek seviyeli 
    araçlar bulundurulmaktadır. Tarihsel süreç içerisinde Linux sistemlerinde boot sonrası işlemlerden ve servis işlemlerinden 
    sorumlu üç önemli init paketi geliştirilmiştir:

    SysVinit (klasik)
    upstart
    systemd

    Kursun yapıldığı zaman diliminde ağırlıklı biçimde init paketi olarak "systemd" paketi kullanılmaktadır. Upstart paketinin 
    de sürdürümü artık yapılmamaktadır. Tabii eskiden kurulmuş Linux sistemleri ve bazı dağıtımlar hala bu paketi kullanıyor 
    olabilir. Biz kursumuzda "systemd" paketi hakkında temel bilgiler vereceğiz.

    Sisteminizde hangi init paketinin kurulu olduğunu çeşitli biçimlerde anlayabilirsiniz. Örneğin:

    $ sudo ls -l /proc/1/exe

    Buradan aşağıdakine benzer bir çıktı elde edilmiştir:

    lrwxrwxrwx 1 root root 0 Kas 11 11:45 /proc/1/exe -> /usr/lib/systemd/systemd

    Hangi init paketinin kullanıldığının anlaşılması için diğer bir yöntem de şöyle olabilir:

    $ cat /proc/1/status
    Name:    systemd
    Umask:    0000
    State:    S (sleeping)
    Tgid:    1
    Ngid:    0
    Pid:    1
    PPid:    0
    ...

    Sisteminizde hangi init paketinin kullanıldığını anlamanın diğer bir yolu da doğrudan ps komutunu "-p 1" seçeneği ile 
    kullanmaktır:

    $ ps -p 1 (ya da "ps -p 1 -o comm")
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    systemd paketi boot sonrasında devreye girecek programlardan ve daemon'lardan ve bazı faydalı komutlardan oluşmaktadır. 
    Bu komutlar genel olarak xxxctl biçiminde isimlendirilmiştir. Paketin en önemli komutu şüphesiz "systemctl" isimli komuttur.
    Servis yönetimleri temel olarak bu komut yoluyla yapılmaktadır. Yani "systemctl" komutu adeta systemd paketinin ön yüzü
    (front-end) gibidir.

    systemd paketi çalışmaya başladığında çeşitli konfigürasyon dosyalarına başvurmaktadır. Bu konfigürasyon dosyaları 
    "/etc/systemd" dizini içerisinde bulunmaktadır. Örneğin:

    $ ls -l /etc/systemd
    toplam 56
    -rw-r--r--  1 root root  615 Nis  1  2020 coredump.conf
    -rw-r--r--  1 root root 1042 Nis 22  2020 journald.conf
    -rw-r--r--  1 root root 1042 Nis 22  2020 logind.conf
    drwxr-xr-x  2 root root 4096 Nis 22  2020 network
    -rw-r--r--  1 root root  584 Nis  1  2020 networkd.conf
    -rw-r--r--  1 root root  529 Nis  1  2020 pstore.conf
    -rw-r--r--  1 root root  642 Mar 18  2021 resolved.conf
    -rw-r--r--  1 root root  790 Nis  1  2020 sleep.conf
    drwxr-xr-x 20 root root 4096 Ara 26  2021 system
    -rw-r--r--  1 root root 1759 Nis 22  2020 system.conf
    drwxr-xr-x  2 root root 4096 Tem  3  2021 system.conf.d
    -rw-r--r--  1 root root  604 Nis 22  2020 timesyncd.conf
    drwxr-xr-x  4 root root 4096 Tem  3  2021 user
    -rw-r--r--  1 root root 1185 Nis 22  2020 user.conf

    Buradaki .conf dosyalarının içi genel olarak "değişken=değer" biçiminde satırlardan oluşmaktadır. Kolaylık olsun diye
    özellikler # ile yorum satırı haline getirilip dosyada bulundurulmuştur. Sistem yönticisi ilgili satırdaki #'i kaldırarak
    o özelliği değiştirebilir.

    systemd paketi içerisinde pek çok çalıştırılabilir program da bulunmaktadır. Bu programların bazıları "daemon" biçiminde 
    yazılmıştır. systemd paketinin çalıştırılabilir (executable) program dosyaları "/lib/systemd" dizinindedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda systemd paketinin aynı zamanda bir "servis yöneticiliği" yaptığını da belirtmiştik. İşte bizim bir servisimizin 
    (daemon'umuzun) systemd yönetiminin kontrolüne girebilmesi için ismine "unit dosyası (unit file)" denilen bir dosyanın 
    hazırlanması gerekmektedir. Çeşitli amaçlar için çeşitli unit dosyaları kullanılmaktadır. Bu unit dosyalarının türlerine 
    göre uzantıları farklı olabilmektedir. Önemli unit dosya türleri şunlardır:

    - Service unit dosyası (.service)
    - Socket unit dosyası (.socket)
    - Slice unit dosyası (.slice)
    - Mount ve Automount unit dosyası (.mount, .automount)
    - Target unit dosyası (.target)
    - Timer unit dosyası (.timer)
    - Path unit dosyası (.path)
    - Swap unit dosyası (.swap)

    Programcının kendi daemon'ları için "service unit dosyası" oluşturması gerekmektedir. Unit dosyaları genel olarak 
    "/lib/systemd/system" dizini içerisindedir. Aslında "systemd" paketinin unit dosyaları için hangi dizinlere bakacağı 
    konfigürasyon dosyalarında ayarlanabilmektedir. Default bakılan dizinler sırasıyla şunlardır:

    /lib/systemd/system
    /etc/systemd/system
    /run/systemd/system
    /usr/lib/systemd/system
    /usr/local/lib/systemd/system

    Sistem yöneticileri genellikle kendi unit dosyalarını "/etc/systemd/system" dizini içerisine yerleştirmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sistem boot edildiğinde belli çalışma modellerinde belli servislerin aktive edilmesi ya da edilmemesi gerekebilmektedir. 
    Örneğin sistem grafik modda açılmayacaksa XWindow sistemine ilişkin daemon'ların aktif hale getirilmesi anlamsızdır. Benzer 
    biçimde sistemde bir network kartı yoksa veya wireless özelliği yoksa bunlara yönelik daemon'ların (inetd gibi) aktif hale
    getirilmesi gereksizdir.

    Eskiden klasik SystemVinit paketlerinde "çalışma düzeyi (run level)" denilen boot seçenekleri bulunuyordu. Sistem yöneticisi 
    de hangi servisin hangi çalışma düzeyinde aktive edeceğini belirtiyordu. Böylece sistem bir çalışma düzeyinde boot edildiğinde 
    yalnızca o çalışma düzeyinde aktif edilmesi gereken servisler (daemon'lar) aktive ediliyordu. Ancak bu çalışma düzeyi sistemi 
    kısıtlı bir seçenek oluşturmaktaydı. systemd paketinde bu "çalışma düzeyi" kullanımı kaldırılmıştır. Bunun yerine "target unit 
    dosyası" yöntemi kullanılmaya başlanmıştır. Bu sistemlerde "çalışma düzeyi" yerine ismine "target unit" denilen ve bir boot 
    seçeneğini belirten bir unit dosyası bulundurulur. Servisler de hangi target unit için aktive edileceklerini kendileri belirtirler.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Unit dosyalarının içerikleri konusunda çeşitli ayrıntılar vardır. Ancak biz burada bu ayrıntıların üzerinde durmayacağız. 
    Tipik bir "service unit dosyası" minimalist biçimde şöyle oluşturulmaktadır:

    # mydaemon.service

    [Unit]
    Description=Mydaemon Unit
    [Service]
    Type=forking
    ExecStart=/usr/bin/mydaemond
    [Install]
    WantedBy=multi-user.target

    Burada "Description" bizim unit dosyamızı temsil eden bir yazıdır. Type daemon'ın nasıl çalıştırılacağını belirtir. 
    Burada "forking" normal fork mekanizmasıyla çalıştırma anlamına gelmektedir. ExecStart daemon dosyasının nerede olduğunu 
    belirtmektedir. Daemon dosyaları tipik olarak "/usr/bin" dizinine ya da "/usr/local/bin" dizinlerine yerleştirilmelidir. 
    WantedBy hangi target ile sistem boot edildiğinde bu daemon'ın yükleneceğini belirtir. Buradaki "multi-user.target" isimli
    target unit klasik ve tipik boot işlemini belirtmektedir.

    Biz burada minimalist bir service unit dosyası oluşturduk. Servis unit dosyalarının içeriğine yönelik pek çok ayrıntı 
    vardır. Bunun resmi dokümanları için "man systemd.service" sayfasına başvurabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                97. Ders 12/11/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki adımları sırasıyla bir daha özetlemek istiyoruz. Daemon'ımızı systemd kontrolüne verebilmek için sırasıyla
    şu işlemlerin yapılması gerekmektedir.

    1) Bir service unit dosyası oluşturulmalıdır. Bu dosyanın uzantısı ".service" biçiminde olmalıdır. Bu dosyada daemon 
    programının yol ifadesi ExecStart ismiyle bulunmaktadır.
    2) Bu service unit dosyası "/etc/systemd/system" dizinine kopyalanmalıdır.
    3) Daemon programı "/usr/bin" ya da "usr/local/bin" dizinine kopyalanmalıdır. (Tabii bu dizin servis unit dosyasındaki
    ExecStart ile aynı olmalıdır.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki işlemler yapıldıktan sonra artık servis yönetimi "systemctl" komutuyla yapılabilir. Bu komutun çeşitli parametreleri
    vardır. Burada biz bazı parametreleri üzerinde açıklamalar yapacağız.

    - Daemon'ımızın boot zamanında devreye sokulması için "systemctl enable" komutunun kullanılması gerekmektedir. Komutun 
    genel biçimi şöyledir:

    sudo systemctl enable <daemon_ismi>

    Buradaki <daemon_ismi> service unit dosyasının ismidir. Uzantı belirtilmeyebilir. Örneğin:

    $ sudo systemctl enable mydaemon

    Eğer daemon'ın o anda yüklenmesi isteniyorsa ayrıca komuta --now seçeneği de eklenmelidir. Örneğin:

    $ sudo systemctl enable mydaemon --now

    - Daemon'ımızın boot sırasında devreye sokulmasının kaldırılması için "systemctl disable" komutu kullanılmaktadır. 
    Komutun genel biçimi şöyledir:

    $ sudo systemctl disable <daemon_ismi>

    Örneğin:

    $ sudo systemctl disable mydaemon

    - Daemon'ı çalıştırmak için "systemctl start" komutu kullanılmaktadır. Komutun genel biçimi şöyledir:

    $ sudo systemctl start <daemon_ismi>

    - Daemon'ı durdurmak için "systemctl stop" komutu kullanılmalıdır. Komutun genel biçimi şöyledir:

    $ sudo systemctl stop <daemon_ismi>

    Daemon durdurulurken ona default SIGTERM sinyali gönderilmektedir. systemd SIGTERM sinyalini gönderdikten sonra bir süre
    bekler, daemon hala sonlanmamışsa bu kez ona SIGKILL sinyalini gönderir.

    - Daemon'ımızın durumunu anlamak için "systemctl status" komutu kullanılır. Komutun genel biçimi şöyledir:

    systemctl status [daemon_ismi]

    Örneğin:

    $ systemctl status mydaemon

    - Bazen daemon'ımızı "restart" etmek isteyebiliriz. restart önce durdurup sonra çalıştırmak anlamına gelmektedir. Komutun
    genel biçimi şöyledir:

    sudo systemctl restart <daemon_ismi>

    Örneğin:

    $ sudo systemctl restart mydaemon

    - Daemon'ımızın boot zamanında devreye girip girmeyeceğini "systemctl status" komutunun yanı sıra "systemctl is-enabled"
    komutuyla da anlayabiliriz. Örneğin:

    $ systemctl is-enabled mydaemon

    - systemd tüm unit dosyalarını inceleyerek bir çalıştırma ağacı oluşturmaktadır. Biz bir unit dosyasını değiştirdiğimizde
    bu ağacın yeniden oluşturulması gerekmektedir. Bunun için "systemctl daemon-reload" komutu kullanılmaktadır. Komutun genel 
    biçimi şöyledir:

    $ sudo systemctl daemon-reload

    Komutun parametresiz olduğuna dikkat ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz prosesler arası haberleşmeyi iki grubu ayırmıştık:

    1) Aynı makinenin prosesleri arasında haberleşme
    2) Farklı makinelerin prosesleri arasında haberleşme

    Kursumuzda aynı makinenin prosesleri arasındaki haberleşmeleri (boru haberleşmeleri, mesaj kuyrukları) görmüştük. Şimdi farklı 
    makinelerin prosesleri arasındaki haberleşmeler üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Farklı makinelerin prosesleri arasında haberleşme (yani bir ağ içerisinde haberleşme), aynı makinenin prosesleri arasındaki 
    haberleşmeye göre daha karmaşık unsurlar içermektedir. Çünkü burada ilgili işletim sisteminin dışında pek çok belirlemelerin 
    önceden yapılmış olması gerekir. İşte ağ haberleşmesinde önceden belirlenmiş kurallar topluluğuna "protokol" denilmektedir. 
    Ağ haberleşmesi için tarihsel süreç içerisinde pek çok protokol ailesi gerçekleştirilmiştir. Bunların bazıları büyük şirketlerin 
    kontrolü altındadır ve hala kullanılmaktadır. Ancak açık bir protokol ailesi olan "IP protokol ailesi" günümüzde farklı 
    makinelerin prosesleri arasındaki haberleşmede hemen her zaman tercih edilen protokol ailesidir.

    Protokol ailesi (protocol family) denildiğinde birbirleriyle ilişkili bir grup protokol anlaşılmaktadır. Bir protokol ailesinin 
    pek çok protokolü başka protokollerin üzerine konumlandırılmış olabilmektedir. Böylece protokol aileleri katmanlı (layered) 
    bir yapıya sahip olmuştur. Üst seviye bir protokol alt seviye protokolün "zaten var olduğu fikriyle" o alt seviye protokol 
    kullanılarak oluşturulmaktadır. Bu katmanlı yapıyı prosedürel programlama tekniğinde "zaten var olan bir fonksiyonu kullanarak 
    daha yüksek seviyeli bir fonksiyon yazmaya" benzetebiliriz.

    Ağ haberleşmesi için katmanlı bir protokol yapısının kavramsal olarak nasıl oluşturulması gerektiğine yönelik ISO tarafından 
    80'li yılların başlarında "OSI Model (Open System Interconnection Model)" isimli bir referans dokümanı oluşturulmuştur. OSI 
    model bir gerçekleştirim değildir. Kavramsal bir referans dokümanıdır. Ancak bu referans dokümanı pek çok çalışma için bir 
    zemin oluşturmuştur. OSI referans modeline göre bir protokol ailesinde tipik olarak 7 katman bulunmalıdır. Bu katmanlar 
    aşağıdaki gibi birbirlerini üzerine oturtulmuştur:

    Uygulama Katmanı (Application Layer)
    Sunum Katmanı (Presentation Layer)
    Oturum Katmanı (Session Layer)
    Aktarım Katmanı (Transport Layer)
    Network Katmanı (Network Layer)
    Veri Bağlantı Katmanı (Data Link Layer)
    Fiziksel Katman (Physical Layer)

    - En aşağı seviyeli elektriksel tanımlamaların yapıldığı katmana "fiziksel katman (physical layer)" denilmektedir. (Örneğin 
    kabloların, konnektörlerin özellikleri, akım, gerilim belirlemeleri vs. gibi.) Yani bu katman iletişim için gereken fiziksel 
    ortamı betimlemektedir.

    - Veri bağlantı katmanı (data link layer) artık bilgisayarlar arasında fiziksel bir adreslemenin yapıldığı ve bilgilerin paketlere 
    ayrılarak gönderilip alındığı bir ortam tanımlarlar. Yani bu katmanda bilgilerin gönderildiği ortam değil, gönderilme biçimi 
    ve fiziksel adresleme tanımlanmaktadır. Ağ üzerinde her birimin donanımsal olarak tanınabilen fiziksel bir adresinin olması 
    gerekir. Örneğin bugün kullandığımız Ethernet kartları "Ethernet Protocolü (IEEE 802.11)" denilen bir protokole uygun tasarlanmıştır. 
    Bu ethernet protokolü OSI'nin fiziksel ve veri bağlantı katmanına karşılık gelmektedir. Ethernet protokolünde yerel ağa bağlı 
    olan her birimin ismine "MAC adresi" denilen 6 byte'lık fiziksel bir adresi vardır. Ethernet protokolünde MAC adresini bildiğimiz 
    ağa bağlı bir birime bilgi gönderebiliriz. Bilgiler "paket anahtarlaması packet switching)" denilen teknikle gönderilip alınmaktadır. 
    Bu teknikte byte'lar bir paket adı altında bir araya getirilir sonra ilgili fiziksel katmanla seri bir biçimde gönderilir. 
    Bugün kullandığımız yerel ağlarda aslında bilgi bir birimden diğerine değil hub'lar yoluyla ağa bağlı olan tüm birimlere
    gönderilmektedir. Ancak bunlardan yalnızca biri gelen bilgiyi sahiplenmektedir. Bugün kablosuz haberleşmede kullanılan 
    "IEEE 802.11" protokolü de tıpkı Ethernet protokolü gibi hem bir fiziksel katman hem de veri bağlantı katmanı tanımlamaktadır.

    Fiziksel katman ve veri katmanı oluşturulduğunda artık biz yerel ağda bir birimden diğerine paket adı altında bir grup byte'ı 
    gönderip alabilir duruma gelmekteyiz.

    - Ağ Katmanı (network layer) artık "internetworking" yapmak için gerekli kuralları tanımlamaktadır. "Internetworking" terimi 
    "network'lerden oluşan network'ler" anlamına gelir. Aynı fiziksel ortamda bulunan ağlara "Yerel Ağlar (Local Area Networks)" 
    denilmektedir. Bu yerel ağlar "router" denilen aygıtlarla birbirlerine bağlanmaktadır. Böylece "internetworking" ortamı 
    oluşturulmaktadır. Tabii böyle bir ortamda artık ağa bağlı birimler için fiziksel adresler kullanılamaz. Bu ortamlarda ağa 
    bağlı birimlere mantıksal bir adreslerin atanması gerekmektedir. İşte "network katmanı" internetworking ortamı içerisinde bir 
    birimden diğerine bir paket bilginin gönderilmesi için gereken tanımlamaları içermektedir. Ağ katmanı bu nedenle en önemli 
    katmandır. Ağ katmanında artık fiziksel adresleme değil, mantıksal adresleme sistemi kullanılmaktadır. Ayrıca bilgilerin 
    paketlere ayrılarak router'lardan dolaşıp hedefe varması için rotalama mekanizması da bu katmanda tanımlanmaktadır. Yani 
    elimizde yalnızca ağ katmanı ve onun aşağısındaki katmanlar varsa biz artık "internetworking" ortamında belli bir kaynaktan 
    belli bir hedefe paketler yollayıp alabiliriz.

    - Aktarım katmanı (transport layer) network katmanının üzerindedir. Aktarım katmanında artık kaynak ile hedef arasında 
    mantıksal bir bağlantı oluşturulabilmekte ve veri aktarımı daha güvenli olarak yapılabilmektedir. Aynı zamanda aktarım 
    katmanı "multiplex" bir kaynak-hedef yapısı da oluşturmaktadır. Bu sayede bilgiler hedefteki spesifik bir programa 
    gönderilebilmektedir. Bu işleme "port numaralandırması" da denilmektedir. Bu durumda aktarım katmanında tipik şu işlemlere 
    yönelik belirlemeler bulunmaktadır:

        - Bağlantının nasıl yapılacağına ilişkin belirlemeler
        - Ağ katmanından gelen paketlerin stream tabanlı organizasyonuna ilişkin belirlemeler
        - Veri aktarımını güvenli hale getirmek için akış kontrolüne ilişkin belirlemeler
        - Gönderilen bilgilerin hedefte ayrıştırılmasını sağlayan protokol port numaralandırmasına ilişkin belirlemeler

    - Oturum katmanı (session) katmanı pek çok protokol ailesinde yoktur. Görevi oturum açma kapama gibi yüksek seviyeli bazı 
    belirlemeleri yapmaktır. Örneğin bu katmanda bir grup kullanıcıyı bir araya getiren oturumların nasıl açılacağına ve nasıl 
    kapatılacağına ilişkin belirlemeler bulunmaktadır. IP protokol ailesinde OSI'de belirtilen biçimde bir oturum katmanı yoktur.

    - Sunum katmanı (presentation layer) verilerin sıkıştırılması, şifrelenmesi gibi tanımlamalar içermektedir. Yine bu katman 
    IP protokol ailesinde OSI'de belirtildiği biçimde bulunmamaktadır.

    - Nihayet protokol ailesini kullanarak yazılmış olan tüm kullanan bütün programlar aslında uygulama katmanını oluşturmaktadır. 
    Yani ağ ortamında haberleşen her program zaten kendi içerisinde açık ya da gizli bir protokol oluşturmuş durumdadır. Örneğin 
    IP protokol ailesindeki somut işleri yapmakta kullanılan Telnet, SSH, HTTP, POP3, FTP gibi protokoller uygulama katmanı 
    protokolleridir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bugün farklı makinelerin prosesleri arasında en çok kullanılan protokol ailesi IP (Internet Protocol) denilen protokol 
    ailesidir. IP protokol ailesi temel ve yardımcı pek çok protokolden oluşmaktadır. Aileye ismini veren ailenin ağ katmanı 
    (network layer) protokolü olan IP protokolüdür. Pekiyi pekiyi IP ailesi neden bu kadar popüler olmuştur? Bunun en büyük 
    nedeni 1983 yılında hepimizin katıldığı Internet'in (I'nin büyük yazıldığına dikkat ediniz) bu aileyi kullanmaya başlamasıdır. 
    Böylece IP ailesini kullanarak yazdığımız programlar hem aynı bilgisayarda hem yerel ağımızdaki bilgisayarlarda hem de 
    Internet'te çalışabilmektedir. Aynı zamanda IP ailesinin açık bir (yani bir şirketin malı değil) protokol olması da cazibeyi 
    çok artırmıştır.

    IP ailesi 70'li yıllarda Vint Cerf ve Bob Kahn tarafından geliştirilmiştir. IP ismi Internet Protocol'den gelmektedir. 
    Burada internet "internetworking" anlamında kullanılmıştır. Cerf ve Kahn 1974 yılında önce TCP protokolü üzerinde sonra da 
    IP protokolü üzerinde çalışmışlar ve bu protokollerin ilk versiyonlarını oluşturmuşlardır.

    Bugün hepimizin bağlandığı büyük ağa "Internet" denilmektedir. Bu ağ ilk kez 1969 yılında Amerika'da Amerikan Savunma Bakanlığı'nın 
    bir soğuk savaş projesi biçiminde başlatıldı. O zamana kadar yalnızca kısıtlı ölçüde yerel ağlar vardı. 1969 yılında ilk kez 
    bir "WAN (Wide Area Network)" oluşturuldu. Bu proje Amerikan Savunma Bakanlığı'nın DARPA isimli araştırma kurumu tarafından 
    başlatılmıştır ve projeye "ARPA.NET" ismi verilmiştir. Daha sonra bu ağa Amerika'daki çeşitli devlet kurumları ve üniversiteler 
    katıldı. Sonra ağ Avrupa'ya sıçradı. 1983 yılında bu ağ NCP protokolünden IP protokol ailesine geçiş yaptı. Bundan sonra 
    artık APRA.NET ismi yerine "Internet" ismi kullanılmaya başlandı. (Internet sözcüğü I harfi küçük harfle yazılırsa "internetworking" 
    anlamında büyük harfle yazılırsa bugün katıldığımız dev ağ anlamında kullanılmaktadır.) Biz de IP ailesini kullanarak kendi 
    "internetworking" ortamımızı oluşturabiliriz. Örneğin bir şirket hiç Internet'e bağlanmadan kendi internet'ini oluşturabilir. Buna 
    eskiden "intranet" denirdi. IP protokol ailesi herkesin kendi internet'ini oluşturabilmesi için bütün gerekli protokolleri 
    barındırmaktadır. Tabii sinerji bakımından herkes zaten var olan ve "Internet" denilen bu dev ağa bağlanmayı tercih etmektedir.

    IP protokol ailesi 4 katmanlı bir ailedir. Bu ailede "fiziksel ve veri bağlantı katmanı" bir arada düşünülebilir. Bugün bunlar 
    Ethernet ve Wireless protokolleri biçiminde kullanılmaktadır. IP ailesinin ağ katmanı aileye ismini veren IP protokolünden 
    oluşmaktadır. Aktarım katmanı ise TCP ve UDP protokollerinden oluşur. Nihayet TCP üzerine oturtulmuş olan HTTP, TELNET, SSH, 
    POP3, IMAP gibi pek çok protokol ailenin uygulama katmanını oluşturmaktadır. Tabii IP protokol ailesinde bu hiyerarşik yapıyla 
    ilgili olmayan irili ufaklı pek çok protokol de bulunmaktadır.

    +---------------------+-------------------------------+
    |  Application Layer  |   HTTP, SSH, POP3, IMAP, ...  |
    +---------------------+---------------+---------------+
    |    Transport Layer  |      TCP      |      UDP      |
    +---------------------+---------------+---------------+
    |     Network Layer   |               IP              |
    +---------------------+-------------------------------+
    |  Physical/Data Link |           Ethernet            |
    |       Layer         |           Wireless            |
    +---------------------+-------------------------------+

    IP protokolü tek başına kullanılırsa ancak ağa bağlı bir birimden diğerine bir paket gönderip alma işini yapar. Bu nedenle 
    bu protokolün tek başına kullanılması çok seyrektir. Uygulamada genellikle "aktarım (transport) katmanına" ilişkin TCP ve 
    UDP protokolleri kullanılmaktadır. IP ailesinin uygulama katmanındaki HTTP, SSH, POP3, IMAP, FTP gibi önemli protokollerinin 
    hepsi TCP protokolü üzerine oturtulmuştur. Ailede genellikle TCP protokolü kullanıldığı için buna kısaca "TCP/IP" de denilmektedir.

    IP protokolü ailenin en önemli ve taban protokolüdür. IP protokolünde ağa bağlı olan ve kendisine IP adresiyle erişilebilen 
    her birime "host" denilmektedir. IP protokolü bir host'tan diğerine bir paket (buna IP paketi denilmektedir) bilginin 
    gönderimine ilişkin tanımlamaları içermektedir. IP protokolünde her host'un ismine "IP adresi" denilen mantıksal bir adresi 
    vardır. Paketler belli bir IP adresinden diğerine gönderilmektedir. IP protokolünün iki önemli versiyonu vardır: IPv4 ve 
    IPv6. Bugün her iki versiyon da aynı anda kullanılmaktadır. IPv4'te IP adresleri 4 byte uzunluktadır. (Protokolün tasarlandığı 
    70'li yıllarda 4 byte adres alanı çok geniş sanılmaktaydı). IPv6'da ise IP adresleri 16 byte uzunluğundadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP bağlantılı (connection-oriented), UDP bağlantısız (connectionless) bir protokoldür. Buradaki bağlantı IP paketleriyle 
    yapılan mantıksal bir bağlantıdır. Bağlantı sırasında gönderici ve alıcı birbirlerini tanır ve haberleşme boyunca haberleşmenin 
    güvenliği için birbirleriyle konuşabilirler. Bağlantılı protokol "client-server" tarzı bir haberleşmeyi akla getirmektedir. 
    Bu nedenle TCP/IP denildiğinde akla "client-server" haberleşme gelmektedir. TCP modelinde client önce server'a bağlanır. 
    Sonra iletişim güvenli bir biçimde karşılıklı konuşmalarla sürdürürlür. Tabii TCP bunu yaparken IP paketlerini yani IP 
    protokolünü kullanmaktadır. UDP protokolü bağlantısızdır. Yani UDP protokolünde bizim bir host'a UDP paketi gönderebilmemiz 
    için bir bağlantı kurmamıza gerek kalmaz. Örneğin biz televizyon yayını UDP modeline benzemektedir. Verici görüntüyü yollar 
    ancak alıcının alıp almadığıyla ilgilenmez. Vericinin görüntüyü yollaması için alıcıyla bağlantı kurması gerekmemektedir.

    TCP "stream tabanlı", UDP ise "datagram (paket) tabanlı" bir protokoldür. Stream tabanlı protokol demek tamamen boru haberleşmesinde 
    olduğu gibi gönderen tarafın bilgilerinin bir kuyruk sistemi eşliğinde oluşturulması ve alıcının istediği kadar byte'ı parça 
    parça okuyabilmesi demektir. Datagram tabanlı haberleşme demek tamamen mesaj kuyruklarında olduğu gibi bilginin paket paket 
    iletilmesi demektir. Yani datagram haberleşmede alıcı taraf gönderen tarafın tüm paketini tek hamlede almak zorundadır. 
    Stream tabanlı haberleşmenin oluşturulabilmesi için IP paketlerine bir numara verilmesi ve bunların hedefte birleştirilmesi 
    gerekmektedir. Örneğin biz bir host'tan diğerine 10K'lık bir bilgi gönderelim. TCP'de bu bilgi IP paketlerine ayrılıp numaralandırılır. 
    Bunlar hedefte birleştirilir ve sanki 10000 byte'lık ardışıl bir bilgiymiş gibi gösterilir. Halbuki UDP'de paketler birbirinden 
    bağımsızdır. Dolayısıyla bunların hedefte birleştirilmesi zorunlu değildir. IP protokolünde bir host birtakım paketleri diğer 
    host'a gönderdiğinde alıcı taraf bunları aynı sırada almayabilir. Bu özelliğinden dolayı TCP, ailenin en çok kullanılan transport 
    katmanı durumundadır.

    TCP güvenilir (reliable), UDP güvenilir olmayan (unreliable) bir protokoldür. TCP'de mantıksal bir bağlantı oluşturulduğu için 
    yolda kaybolan paketlerin telafi edilmesi mümkündür. Alıcı taraf gönderenin bilgilerini eksiksiz ve bozulmadan aldığını bilir.
    Aynı zamanda TCP'de "bir akış kontrolü (flow control)" de uygulanmaktadır. Akış kontrolü sayesinde alıcı taraf tampon taşması 
    durumuna karşı gönderici tarafı durdurabilmektedir. Halbuki UDP'de böyle bir mekanizma yoktur. Gönderen taraf alıcının bilgiyi 
    alıp almadığını bilmez.

    Tüm bunlar eşliğinde IP ailesinin en çok kullanılan transport katmanının neden TCP olduğunu anlayabilirsiniz. Uygulama katmanındaki
    protokoller hep TCP kullanmaktadır.

    Yukarıda da belirttiğimiz gibi IP protokol ailesinde ağa bağlı olan birimlere "host" denilmektedir. Host bir bilgisayar olmak 
    zorunda değildir. İşte bu protokolde her host'un mantıksal bir adresi vardır. Bu adrese IP adresi denilmektedir. IP adresi 
    IPv4'te 4 byte uzunlukta, IPv6'da 16 byte uzunluktadır. Ancak bir host'ta farklı programlar farklı host'larla haberleşiyor 
    olabilir. İşte aynı host'a gönderilen IP paketlerinin o host'ta ayrıştırılması için "protokol port numarası" diye isimlendirilen 
    içsel bir numara uydurulmuştur. Port numarası bir şirketin içerisinde çalışanların dahili numarası gibi düşünülebilir. Port 
    numaraları IPv4'te ve IPv6'da 2 byte'la ifade edilmektedir. İlk 1024 port numarası IP ailesinin uygulama katmanındaki protokoller 
    için ayrılmıştır. Bunlara "well known ports" denilmektedir. Bu nedenle programcıların port numaralarını 1024'ten büyük olacak 
    biçimde almaları gerekir. Bir host TCP ya da UDP kullanarak bir bilgi gönderecekse bilginin gönderileceği host'un IP numarasını 
    ve bilginin orada kime gönderileceğini anlatan port numarasını belirtmek zorundadır. IP numarası ve port numarası çiftine 
    "IP End Point" de denilmektedir. Bilgiyi almak isteyen program kendisinin hangi portla ilgilendiğini de belirtmek durumundadır. 
    Örneğin biz bir host'ta çalışacak bir TCP/IP ya da UDP/IP program yazmak istiyorsak o host'un belli bir port numarasına gelen 
    bilgilerle ilgileniriz. Port numarası  kavramının IP protokolünde olmadığına TCP ve UDP protokollerinde bulunduğuna dikkat 
    ediniz.

    TCP ve UDP protokollerinin IP protokolü üzerine oturtulduğunu belirtmiştik. Bu ne anlama gelmektedir? Biz TCP kullanarak 
    belli bir IP numarası ve port numarası (end point) belirterek bir grup byte'ı göndermiş olalım. Aslında bu byte topluluğu
    bir TCP paketi oluşturularak bir paket biçiminde yola çıkarılmaktadır. Ancak ana network protokolü IP'dir. O halde bu 
    paketin aslında bir IP paketi olarak gönderilmesi gerekir. Bir IP paketi iki kısımdan oluşmaktadır: IP Header ve IP data

    +-------------------------+
    |        IP Header        |
    +-------------------------+
    |         IP Data         |
    +-------------------------+

    IP Header'da söz konusu IP paketinin hedefe ulaştırılabilmesi için gerekli bilgiler bulunur. Gönderilecek asıl bilgi bu 
    paketin "IP Data" kısmındadır. İşte bir TCP paketi aslında bir IP paketi olarak IP paketinin "IP Data" kısmına gömülerek
    gönderilmektedir. Bu durumda TCP paketinin genel görünümü şöyledir:

    +-------------------------+
    |        IP Header        |
    +-------------------------+   <---+
    |        TCP Header       |       |
    +-------------------------+     IP Data
    |         TCP Data        |       |
    +-------------------------+   <---+

    Yani TCP paketinin header ve data kısmı aslında IP paketinin data kısmı gibi oluşturulmaktadır. Böylece yolculuk eden 
    paket aslında bir TCP paketi değil IP paketidir. TCP bilgileri bu IP paketinin data kısmında bulunmaktadır. IPv4 başlık 
    uzunluğu 20 byte'dır. IPv4 paket başlık alanları aşağıdaki verilmiştir.

    <------- Byte 1 -------><------- Byte 2 -------><------- Byte 3 -------><------- Byte 4 ------->
    +-----------+-----------+----------------------+-----------------------------------------------+             ^
    |  Version  |    IHL    |    Type of Service   |                  Total Length                 |  (4 bytes)  |
    | (4 bits)  | (4 bits)  |       (8 bits)       |                   (16 bits)                   |             |
    +-----------+-----------+----------------------+-----------+-----------------------------------+             |
    |                 Identification               |   Flags   |           Fragment Offset         |  (4 bytes)  |
    |                   (16 bits)                  |  (3 bits) |              (13 bits)            |             |
    +-----------------------+----------------------+-----------+-----------------------------------+             |
    |   Time to Live (TTL)  |       Protocol       |                 Header Checksum               |  (4 bytes)  |  20 bytes
    |         (8 bits)      |       (8 bits)       |                    (16 bits)                  |             |
    +-----------------------+----------------------+-----------------------------------------------+             |
    |                                  Source IP Address (32 bits)                                 |  (4 bytes)  |
    +----------------------------------------------------------------------------------------------+             |
    |                               Destination IP Address (32 bits)                               |  (4 bytes)  |
    +----------------------------------------------------------------------------------------------+             v
    |                            Segment (L4 protocol (TCP/UDP) + Data)                            |
    +----------------------------------------------------------------------------------------------+

    TCP header'ı 20 byte'tan oluşmaktadır ve yapısı aşağıdaki gibidir.

    <------- Byte 1 -------><------- Byte 2 -------><------- Byte 3 -------><------- Byte 4 ------->
    +----------------------------------------------+-----------------------------------------------+             ^
    |                  Source Port                 |                Destination Port               |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             |
    |                                        Sequence Number                                       |  (4 bytes)  |
    |                                          (32 bits)                                           |             |
    +----------------------------------------------------------------------------------------------+             |
    |                                    Acknowledgement Number                                    |  (4 bytes)  |
    |                                          (32 bits)                                           |             |  20 bytes
    +-----------+----------------+-----------------+-----------------------------------------------+             |
    |Header Len.|    Reserved    |   Control Bits  |                  Window Size                  |  (4 bytes)  |
    |  (4 bits) |    (6 bits)    |     (6 bits)    |                   (16 bits)                   |             |
    +-----------+----------------+-----------------+-----------------------------------------------+             |
    |                   Checksum                   |                     Urgent                    |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             v
    |                                           Options                                            |
    |                                        (0 or 32 bits)                                        |
    +----------------------------------------------------------------------------------------------+
    |                                    Application Layer Data                                    |
    |                                         (Size Varies)                                        |
    +----------------------------------------------------------------------------------------------+

    UDP header'ı 8 byte'tan oluşmaktadır ve yapısı aşağıdaki gibidir.

    <------- Byte 1 -------><------- Byte 2 -------><------- Byte 3 -------><------- Byte 4 ------->
    +----------------------------------------------+-----------------------------------------------+             ^
    |                  Source Port                 |                Destination Port               |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             |  8 bytes
    |                 Header Length                |                   Checksum                    |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             v
    |                                    Application Layer Data                                    |
    |                                         (Size Varies)                                        |
    +----------------------------------------------------------------------------------------------+

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                98. Ders 18/11/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    IP haberleşmesi (yani paketlerin, oluşturulması, gönderilmesi alınması vs.) işletim sistemlerinin çekirdekleri tarafından 
    yapılmaktadır. Tabii User mod programlar için sistem çağrılarını yapan API fonksiyonlarına ve kütüphanelerine gereksinim 
    vardır. İşte bunların en yaygın kullanılanı "soket kütüphanesi" denilen kütüphanedir. Bu kütüphane ilk kez 1983 yılında 
    BSD 4.2'de gerçekleştirilmiştir ve pek çok UNIX türevi sistem bu kütüphaneyi aynı biçimde benimsemiştir. Microsoft'un 
    Windows sistemleri de bu API kütüphanesini desteklemektedir. Bu kütüphaneye "Winsock" ya da kısaca "WSA (Windows Socket API)" 
    denilmektedir. Microsoft'un Winsock kütüphanesi hem klasik BSD soket API fonksiyonlarını hem de başı WSAXXX ile başlayan 
    Windows'a özgü API fonksiyonlarını barındırmaktadır. Yani UNIX/Linux sistemlerinde yazdığımız soket programlarını küçük 
    değişikliklerle Windows sistemlerine de port edebiliriz.

    Soket kütüphanesi yalnızca IP protokol ailesi için tasarlanmış bir kütüphane değildir. Bütün protokollerin ortak kütüphanesidir.
    Bu nedenle kütüphanedeki fonksiyonlar daha genel biçimde tasarlanmıştır.

    Biz soket fonksiyonlarını kullanırken aslında arka planda işlemler TCP/IP ve UDP/IP protokollerine uygun bir biçimde 
    gerçekleştirilmektedir. Örneğin biz send soket fonksiyonu ile bir bilgiyi göndermek istediğimizde aslında bu fonksiyon 
    arka planda bir TCP paketi dolayısıyla da bir IP paketi oluşturarak protokole uygun bir biçimde bu bilgiyi göndermektedir. 
    Soket kütüphanesinin yalnızca bir API arayüzü olduğuna dikkat ediniz.

    Berkeley soket kütüphanesi POSIX tarafından desteklenmektedir. Yani burada göreceğimiz soket fonksiyonları aynı zamanda 
    birer POSIX fonksiyonudur. Soket fonksiyonlarının prototiplerinin önemli bir bölümü <sys/socket.h> dosyası içerisinde 
    bulunmaktadır. Ancak bu başlık dosyasının dışında bazı fonksiyonlar için başka başlık dosyalarının da include edilmesi 
    gerekmektedir.

    Ağ protokollerinde "endian'lık" da önemli olmaktadır. IP ailesi "Big Endian" formata göre tasarlanmıştır. Buna protokolde
    "network byte ordering" denilmektedir. Dolayısıyla bizim soket API'lerine verdiğimiz birtakım değerlerin big endian formata 
    dönüştürülmesi gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz kursumuzda önce soket kütüphanesi ile TCP/IP client-server programların oluşturulması konusunu ele alacağız. 
    Sonra TCP/IP haberleşmesinin bazı protokol detaylarından bahsedeceğiz. Sonra da UDP/IP haberleşme üzerinde duracağız. 
    Berkeley soket kütüphanesinin bazı fonksiyonları hem TCP/IP hem de UDP/IP haberleşmede ortak olarak kullanılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir TCP/IP uygulamasında server ve client olmak üzere iki ayrı program yazılır: "TCP Server Program" ve "TCP Client Program".
    Biz önce TCP server programın daha sonra da TCP client programın yazımı üzerinde duracağız. Tabii TCP server programın 
    üzerinde dururken zaten bazı ortak soket fonksiyonlarını da göreceğiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir TCP server program tipik olarak aşağıdaki soket API'lerinin sırayla çağrılmasıyla gerçekleştirilmektedir:

    socket ---> bind ---> listen ---> accept ---> send/recv ya da read/write ---> shutdown ---> close

    Haberleşme için öncelikle bir soket nesnesinin yaratılması gerekmektedir. Bu işlem socket isimli fonksiyonla yapılmaktadır.
    socket fonksiyonu bir soket nesnesi (handle alanı) yaratır ve bize bir dosya betimleyicisi verir. Biz diğer fonksiyonlarda 
    soket biçiminde isimlendirilen bu betimleyiciyi kullanırız. socket fonksiyonunun prototipi şöyledir:

    #include <sys/socket.h>

    int socket(int domain, int type, int protocol);

    Fonksiyonun birinci parametresi kullanılacak protokol ailesini belirtir. Bu parametre AF_XXX (Address Family) biçimindeki 
    sembolik sabitlerden biri olarak girilir. IPv4 için bu parametreye AF_INET, IPv6 için AF_INET6 girilmelidir. UNIX domain 
    soketler için bu parametre AF_UNIX olarak girilmelidir.

    Fonksiyonun ikinci parametresi kullanılacak protokolün stream tabanlı mı yoksa datagram tabanlı mı olacağını belirtmektedir. 
    Stream soketler için SOCK_STREAM, datagram soketler için SOCK_DGRAM kullanılmalıdır. Ancak başka soket türleri de vardır. 
    TCP protokolü stream tabanlı olduğu için TCP uygulamalarında bu parametre SOCK_STREAM olarak girilmelidir. Ancak UDP datagram 
    tabanlı olduğu için UDP uygulamalarında bu parametre SOCK_DGRAM biçiminde girilmelidir.

    Fonksiyonun üçüncü parametresi transport katmanındaki protokolü belirtmektedir. Ancak zaten ikinci parametreden transport 
    protokolü anlaşılıyorsa üçüncü parametre 0 olarak geçilebilmektedir. Örneğin IP ailesinde üçüncü parametreye gerek duyulmamaktadır. 
    Çünkü ikinci parametredeki SOCK_STREAM zaten TCP'yi, SOCK_DGRAM ise zaten UDP'yi anlatmaktadır. Fakat yine de bu parametreye 
    istenirse IP ailesi için IPPROTO_TCP ya da IPPROTO_UDP girilebilir. (Bu sembolik sabitler <netinet/in.h> içerisindedir.) 

    socket fonksiyonu başarı durumunda soket betimleyicisine, başarısızsa -1 değerine geri döner ve errno uygun biçimde set 
    edilir. socket nesnesinin bir dosya gibi kullanıldığına dikkat ediniz. socket fonksiyonu bize open fonksiyonunda olduğu 
    gibi dosya betimleyici tablosunda indeks belirten en düşük numaralı dosya betimleyicisini vermektedir.

    Örneğin:

    int server_sock;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Server program soketi yarattıktan sonra onu bağlamalıdır (bind etmelidir). bind işlemi sırasında server'ın hangi portu 
    dinleyeceği ve hangi network arayüzünden (kartından) gelen bağlantı isteklerini kabul edeceği belirlenir. Ancak bind 
    fonksiyonu dinleme işlemini başlatmaz. Yalnızca soket nesnesine bu bilgileri yerleştirir. Fonksiyonun prototipi şöyledir:

    #include <sys/socket.h>

    int bind(int socket, const struct sockaddr *addr, socklen_t addrlen);

    Fonksiyonun birinci parametresi yaratılmış olan soket betimleyicisini alır. İkinci parametre her ne kadar sockaddr isimli 
    yapı türündense de aslında her protokol için ayrı bir yapı adresini almaktadır. Yani sockaddr yapısı genelliği (void gösterici
    gibi) temsil etmek için kullanılmıştır. IPv4 için kullanılacak yapı sockaddr_in, IPv6 için sockaddr_in6 ve örneğin Unix 
    domain soketler için ise sockaddr_un biçiminde olmalıdır. Üçüncü parametre, ikinci parametredeki yapının uzunluğu olarak 
    girilmelidir.

    sockaddr_in yapısı <netinet/in.h> dosyası içerisinde aşağıdaki gibi bildirilmiştir:

    #include <netinet/in.h>

    struct sockaddr_in {
        sa_family_t     sin_family;
        in_port_t       sin_port;
        struct in_addr  sin_addr;
    };

    Yapının sin_family elemanına protokol ailesini belirten AF_XXX değeri girilmelidir. Bu eleman tipik olarak short biçimde 
    bildirilmiştir. Yapının sin_port elemanı in_port_t türündendir ve bu tür uint16_t olarak typedef edilmiştir. Bu eleman server'ın 
    dinleyeceği port numarasını belirtir. Yapının sin_addr elemanı IP numarası belirten bir elemandır. Bu eleman in_addr isimli 
    bir yapı türündendir. in_addr yapısı <netint/in.h> dosyası içerisinde şöyle bildirilmiştir:

    #include <netinet/in.h>

    struct in_addr {
        in_addr_t s_addr;
    };

    in_addr_t 4 byte'lık işaretsiz tamsayı türünü (uint32_t) belirtmektedir. Böylece s_addr 4 byte'lık IP adresini temsil eder. 
    Eğer biz tüm network kartlarından gelen bağlantı isteklerini kabul etmek istiyorsak IP adresi olarak INADDR_ANY özel değerini 
    geçmeliyiz.

    Yukarıda da belirttiğimiz gibi IP ailesinde tüm sayısal değerler "big endian" formatıyla belirtilmek zorundadır. Bu ailede 
    "network byte ordering" denildiğinde "big endian" format anlaşılır. Oysa makinelerin belli bir bölümü (örneğin Intel ve 
    default ARM) "little endian" kullanmaktadır. İşte elimizdeki makinenin endian'lığı ne olursa olsun onu big endian formata 
    dönüştüren htons (host to network byte ordering short) ve htonl (host to network byte ordering long) isimli iki fonksiyon 
    vardır. Bu işlemlerin tersini yapan da ntohs (network byte ordering to host short) ve ntohl (network byte ordering to host 
    long) fonksiyonları da bulunmaktadır. Fonksiyonların prototipleri şöyledir:

    #include <arpa/inet.h>

    uint32_t htonl(uint32_t hostlong);
    uint16_t htons(uint16_t hostshort);
    uint32_t ntohl(uint32_t netlong);
    uint16_t ntohs(uint16_t netshort);

    Yukarıda da belirttiğimiz üzere IP adresi olarak INADDR_ANY özel değeri "tüm network kartlarından gelen bağlantı isteklerini 
    kabul et" anlamına gelmektedir. Bu durumda sockaddr_in yapısı tipik olarak şöyle doldurulabilir:

    struct sockaddr_in sinaddr;

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(SERVER_PORT);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind fonksiyonu başarı durumunda sıfır değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Örneğin:

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    server program bind işleminden sonra soketi aktif dinleme konumuna sokmak için listen fonksiyonunu çağırmalıdır. Fonksiyonun 
    prototipi şöyledir:

    #include <sys/socket.h>

    int listen(int socket, int backlog);

    Fonksiyonun birinci parametresi soket betimleyicisini, ikinci parametresi kuyruk uzunluğunu belirtir. listen işlemi blokeye 
    yol açmamaktadır. İşletim sistemi listen işleminden sonra ilgili porta gelen bağlantı isteklerini uygulama için oluşturduğu 
    bir bağlantı kuyruğuna yerleştirmektedir. Kuyruk uzunluğunu yüksek tutmak meşgul server'larda bağlantı isteklerinin kaçırılmamasını
    sağlayabilir. Linux'ta default durumda verilebilecek en yüksek değer 128'dir. Ancak /proc/sys/net/core/somaxconn dosyasındaki
    değer değiştirilerek bu default uzunluk artırılabilir. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine 
    geri dönmektedir. Örneğin:

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    Bu fonksiyon işletim sistemlerinin "firewall mekanizması" tarafından denetlenebilmektedir. Eğer çalıştığınız sistemde söz konusu 
    port firewall tarafından kapatılmışsa bunu açmanız gerekir. (Windows sistemlerinde listen fonksiyonu bir pop pencere çıkartarak
    uyarı mesajı görüntülemektedir.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bağlantıyı sağlayan asıl fonksiyon accept fonksiyonudur. accept fonksiyonu bağlantı kuyruğuna bakar. Eğer orada bir bağlantı 
    isteği varsa onu alır ve hemen geri döner. Eğer orada bir bağlantı isteği yoksa default durumda blokede bekler. Fonksiyonun 
    prototipi şöyledir:

    #include <sys/socket.h>

    int accept(int socket, struct sockaddr *address, socklen_t *address_len);

    Fonksiyonun birinci parametresi dinleme soketinin dosya betimleyicisini almaktadır. İkinci parametre bağlanılan client'a 
    ilişkin bilgilerin yerleştirileceği sockaddr_in yapısının adresini almaktadır. Bu parametre yine genel bir sockaddr yapısı 
    türünden gösterici ile temsil edilmiştir. Bizim bu parametre için IPv4'te sockaddr_in türünden, IPv6'da sockaddr_in6 
    türünden bir yapı nesnesinin adresini argüman olarak vermemiz gerekir. sockaddr_in yapısının üç elemanı olduğunu anımsayınız. 
    Biz bu parametre sayesinde bağlanan client programın IP adresini ve o host'taki port numarasını elde edebilmekteyiz. Client 
    program server programa bağlanırken bir IP adresi ve port numarası belirtir. Ancak kendisinin de bir IP adresi ve port 
    numarası vardır. Client'ın port numarası kendi makinesindeki (host'undaki) port numarasıdır. Client'ın IP adresine ve oradaki 
    port numarasına "remote end point" de denilmektedir. Örneğin 178.231.152.127 IP adresinden bir client programın 52310 portu 
    ile server'ın bulunduğu 176.234.135.196 adresi ve 55555 numaralı portuna bağlandığını varsayalım. Burada remote endpoint 
    "178.231.152.127:52310" biçiminde ifade edilmektedir. İşte biz accept fonksiyonunun ikinci parametresinden client hakkında 
    bu bilgileri almaktayız.

    Client (178.231.152.127:52310) ---> Server (176.234.135.196:55555)

    accept fonksiyonunun üçüncü parametresi yine ikinci parametredeki yapının (yani sockaddr_in yapısının) byte uzunluğunu 
    belirtmektedir. Ancak bu parametre bir adres olarak alınmaktadır. Yani programcı socklen_t türünden bir nesne tanımlamalı,
    bu nesneye bu sizeof değerini yerleştirmeli ve nesnenin adresini de fonksiyonun üçüncü parametresine geçirmelidir. Fonksiyon 
    bağlanılan client'a ilişkin soket bilgilerinin byte uzunluğunu yine bu adrese yerleştirmektedir. Tabii IP protokol ailesinde 
    her iki taraf da aynı yapıyı kullanıyorsa fonksiyon çıkışında bu sizeof değerinde bir değişiklik olmayacaktır. Ancak tasarım 
    genel yapıldığı için böyle bir yola gidilmiştir.

    accept fonksiyonu başarı durumunda bağlanılan client'a ilişkin yeni bir soket betimleyicisine geri dönmektedir. Artık bağlanılan
    client ile bu soket yoluyla konuşulacaktır. accept başarısızlık durumunda -1 değeri ile geri dönmektedir. Örneğin:

    struct sockaddr_in sin_client;
    socklen_t sin_len;
    int client_sock;
    ...

    sin_len = sizeof(sin_client);
    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
        exit_sys("accept");

    Server tarafta temelde iki soket bulunmaktadır. Birincisi bind, listen, accept işlemini yapmakta kullanılan sokettir. 
    Bu sokete TCP/IP terminolojisinde "pasif soket (passive socket)" ya da "dinleme soketi (listening socket)" denilmektedir. 
    İkinci soket ise client ile konuşmakta kullanılan accept fonksiyonunun geri döndürdüğü sokettir. Buna da "aktif soket
    (active socket)" denilmektedir. Tabii server program birden fazla client ile konuşacaksa accept fonksiyonunu bir kez değil,
    çok kez uygulamalıdır. Her accept o anda bağlanılan client ile konuşmakta kullanılabilecek yeni bir soket vermektedir. 
    bind, listen işlemleri bir kez yapılmaktadır. Halbuki accept işlemi her client bağlantısı için ayrıca uygulanmalıdır.

    accept fonksiyonu default durumda blokeli modda çalışmaktadır. Eğer accept çağrıldığında o anda bağlantı kuyruğunda hiç
    bir client isteği yoksa accept fonksiyonu blokeye yol açmaktadır.

    accept fonksiyonu ile elde edilen client bilgilerindeki IP adresini ve port numaraları "big endian" formatında yani 
    "network byte ordering" formatındadır. Bunları sayısal olarak görüntülemek için ntohl ve ntohs fonksiyonlarının kullanılması
    gerekir. Tabii izleyen paragrafta ele alacağımız gibi aslında IP adresleri genellikle "noktalı desimal format" denilen 
    bir format ile yazı biçiminde görüntülenmektedir.

    Aşağıda accept işlemine kadar olan bir örnek server programı verilmiştir. Tabii programda sonraki paragraflarda göreceğimiz 
    bazı eksiklikler vardır.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define SERVER_PORT        55555

void exit_sys(const char *msg);

int main(void)
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORT);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("waiting for connection...\n");
    sin_len = sizeof(sin_client);
    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
        exit_sys("accept");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                99. Ders 19/11/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    IP adresleri sockaddr_in yapısının içerisindeki in_addr yapısında belirtilmiştir. IPv4'te IP adreslerinin 4 byte uzunlukta 
    olduğunu söylemiştik. sockaddr_in yapısını ve in_addr yapısını yeniden veriyoruz:

    #include <netinet/in.h>

    struct sockaddr_in {
        sa_family_t     sin_family;
        in_port_t       sin_port;
        struct in_addr  sin_addr;
    };

    struct in_addr {
        in_addr_t s_addr;
    };

    Buradaki in_addr_t türü uint32_t biçiminde typedef edilmiştir. Yani 4 byte'lık bir tamsayı türüdür. Elimizde sockaddr_in
    türünden bir nesne olsun:

    struct sockaddr_in sin_client;

    Biz bu nesne yoluyla 4 byte'lık IP adresini "sin_client.sin_addr.s_addr" ifadesi ile elde ederiz.

    IPv4 adresleri genellikle kullanıcılar tarafından "noktalı desimal format (dotted decimal format)" denilen bir formatla 
    gösterilmektedir. Bu formatta IP adresinin her byte'ı arasına "." karakteri getirilir ve IP adresi bir yazı olarak gösterilir. 
    Örneğin:

    "127.0.0.1"
    "192.168.1.1"
    "176.234.135.196"

    İşte 4 byte'lık işaretsiz bir tamsayı biçimindeki IP adresini noktalı desimal formata dönüştürmek için inet_ntoa isimli
    bir POSIX fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <arpa/inet.h>

    char *inet_ntoa(struct in_addr in);

    Fonksiyon in_addr yapısını almaktadır (yapının tek bir elemanı olduğu için adresini almamaktadır). Fonksiyon başarı durumunda 
    noktalı desimal formattaki IP adres yazısına geri dönmektedir. Fonksiyon başarısız olamamaktadır. Fonksiyonun geri döndürdüğü 
    adres statik bir alanın adresidir. Dolayısıyla verilen adres thread güvenli değildir.

    inet_ntoa fonksiyonunun yaptığının tersini yapan inet_addr isimli bir POSIX fonksiyonu da vardır. Fonksiyonun prototipi 
    şöyledir:

    #include <arpa/inet.h>

    in_addr_t inet_addr(const char *cp);

    Fonksiyon noktalı desimal formattaki yazıyı alarak onu 4 byte'lık IP adresine dönüştürmektedir. Başarı durumunda bu IP 
    adresine, başarısızlık durumunda (in_addr_t)-1 değerine geri dönmektedir. (in_addr_t türü işaretsiz ise geri döndürülen 
    değer -1 değil, en büyük pozitif sayı olmaktadır. Ancak işaretsiz tamsayı türünü -1 ile karşılaştırırsak zaten -1 değeri 
    de o türe dönüştürüleceği için sorun ortaya çıkmayacaktır.) Başarısızlık durumunda herhangi bir errno değeri set edilmemektedir.

    inet_ntoa fonksiyonundaki ve bunun tersini yapan inet_addr fonksiyonundaki IP adresleri "big endian" formata göre yani 
    "network byte ordering" formatına göre verilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bağlantı işleminden sonra artık bilgi gönderip alma işlemi yapılabilir. Sonra da aktif soket düzgün bir biçimde kapatılmalıdır. 
    Ancak biz önce client programda da belli bir noktaya gelip bu ortak kısımları ondan sonra ele alacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP client program, server programa bağlanabilmek için tipik bazı adımları uygulamak zorundadır. Bu adımlar sırasında 
    çağrılacak fonksiyonlar şunlardır:

    socket ---> bind (isteğe bağlı) ---> gethostbyname (isteğe bağlı) ---> connect ---> send/recv ya da read/write 
    ---> shutdown ---> close

    Client taraf önce yine socket fonksiyonuyla bir soket yaratır. Örneğin:

    int client_sock;
    ...

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    Soketin bind edilmesi gerekmez. Zaten genellikle client taraf soketi bind etmez. Eğer client taraf belli bir porttan 
    bağlanmak istiyorsa bu durumda bind işlemini uygulayabilir. Eğer client bind işlemi yapmazsa zaten işletim sistemi 
    connect işlemi sırasında sokete boş bir port numarasını atamaktadır. İşletim sisteminin bind edilmemiş client programa 
    connect işlemi sırasında atadığı bu port numarasına İngilizce "ephemeral port" (ömrü kısa olan port) denilmektedir. Seyrek 
    olarak bazı server programlar client için belli bir remote port numarası talep edebilmektedir. Bu durumda client'ın bu 
    remote porta sahip olabilmesi için bind işlemini uygulaması gerekir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Client bağlantı için server'ın IP adresini ve port numarasını bilmek zorundadır. IP adreslerinin akılda tutulması zordur. 
    Bu nedenle IP adresleri ile eşleşen "host isimleri" oluşturulmuştur. Ancak IP protokol ailesi host isimleriyle değil, IP
    numaralarıyla çalışmaktadır. İşte host isimleriyle IP numaralarını eşleştiren ismine DNS (Domain Name Server) denilen 
    özel server'lar bulunmaktadır. Bu server'lar IP protokol ailesindeki DNS isimli bir protokol ile çalışmaktadır. Dolayısıyla
    client programın elinde IP adresi yerine host ismi varsa DNS işlemi yaparak o host ismine karşı gelen IP numarasını elde
    etmesi gerekir. DNS server'lar dağıtık biçimde bulunmaktadır. Bir kayıt bir DNS server'da yoksa başka bir DNS server'a 
    referans edilmektedir.

    DNS server'larda host isimleriyle IP numaraları bire bir karşılık gelmemektedir. Belli bir host ismine birden fazla IP
    numarası eşleştirilmiş olabileceği gibi belli bir IP numarasına da birden fazla host ismi eşleştirilmiş olabilmektedir.

    DNS işlemleri yapan iki geleneksel fonksiyon vardır: gethostbyname ve gethostbyaddr. Bu fonksiyonların kullanımları 
    kolaydır. Ancak bu fonksiyonlar artık "deprecated" yapılmış ve POSIX standartlarından da silinmiştir. Bunların yerine 
    getnameinfo ve getaddrinfo fonksiyonları oluşturulmuştur. Bu fonksiyonlar POSIX standartlarında bulunmaktadır. Biz önce 
    gethostbyname ve gethostbyaddr fonksiyonlarını göreceğiz. (Çünkü ana noktalar üzerinde durmak için vakit kaybetmemek 
    istemiyoruz.) Belli süre sonra da getnameinfo ve getaddrinfo fonksiyonlarını açıklayacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    gethostbyname fonksiyonunun prototipi şöyledir:

    #include <netdb.h>

    struct hostent *gethostbyname(const char *name);

    Fonksiyon bizden host ismini alır ve DNS işlemi yaparak bize statik düzeyde tahsis edilmiş olan bir hostent yapı nesnesinin 
    adresini verir. Fonksiyon errno değişkeni yerine h_errno isimli bir değişkeni set etmektedir. Bu değişkenin değerini yazıya 
    dönüştürmek için strerror fonksiyonu değil, prototipi <netdb.h> içerisinde olan hstrerror fonksiyonu kullanılmaktadır. hostent 
    yapısı aşağıdaki gibi bildirilmiştir:

    struct hostent {
        char  *h_name;            /* official name of host */
        char **h_aliases;         /* alias list */
        int    h_addrtype;        /* host address type */
        int    h_length;          /* length of address */
        char **h_addr_list;       /* list of addresses */
    };

    Yapının h_name elemanı host'un asıl ismini vermektedir. Her host'un alternatif isimleri de olabilmektedir. Yapının 
    h_aliases elemanı ise host'un diğer isimlerini belirtmektedir. Bu gösterici dizisinin her elemanı host'un bir ismini 
    belirtir. Dizinin sonunda NULL adres vardır. Örneğin:

    h_aliases ----> adres -----> isim
                    adres -----> isim
                    adres -----> isim
                    ...
                    NULL

    Yapının h_addrtype elemanı adresin ilişkin olduğu protokol ailesini belirtmektedir. h_length elemanı söz konusu adresin 
    byte uzunluğunu belirtir. Bu genel bir fonksiyon olduğundan ve adresler de değişik uzunluklarda ve türlerde olabileceğinden
    adresler char türden bir dizi içerisine byte byte kodlanmıştır. IPv4'te bu diziler 4 eleman uzunluğundadır. Buradaki adresler
    "big endian" formatta yani "network byte ordering" biçimindedir. Yine h_addr_list göstericinin gösterdiği dizinin son elemanı 
    NULL adres içermektedir. Örneğin:

    h_addr_list ----> adres -----> byte byte byte byte
                      adres -----> byte byte byte byte
                      adres -----> byte byte byte byte
                      ...
                      NULL

    Biz h_addr_list elemanında belirtilen adreslerden ilkini (0'ıncı indekstekini alabiliriz)

    Tipik olarak client program önce server host isminin noktalı desimal formatta olup olmadığına bakar. Eğer bu host ismi 
    noktalı desimal formatta ise onu inet_addr fonksiyonu ile IP numarasına dönüştürür. Eğer host ismi noktalı desimal formatta
    değilse, gethostbyname fonksiyonunu uygulayarak bu kez oradan IP adresini elde eder. Örneğin:

    #define SERVER_NAME        "some_host_name or dotted decimal ip name"

    int client_sock;
    struct sockaddr_in sin_server;
    struct hostent *hent;
    ...

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORT);
    if ((sin_server.sin_addr.s_addr = inet_addr(SERVER_NAME)) == -1) {
        if ((hent = gethostbyname(SERVER_NAME)) == NULL) {
            fprintf(stderr, "gethostbyname: %s\n", hstrerror(h_errno));
            exit(EXIT_FAILURE);
        }
        memcpy(&sin_server.sin_addr.s_addr, hent->h_addr_list[0], hent->h_length);
    }

    gethostbyname fonksiyonu isme karşı IP numaralarının elde edilmesi için kullanılmaktadır. Bunun ters olan gethostbyaddr 
    isimli yine "deprecated" yapılmış bir fonksiyon daha vardır:

    #include <netdb.h>

    struct hostent *gethostbyaddr(const void *addr, socklen_t len, int af);

    Fonksiyonun birinci parametresi "big endian" biçiminde byte dizilimine sahip adresi belirtmektedir. İkinci parametre bu 
    adresin uzunluğunu, üçüncü parametre ise protokol ailesini belirtir. Yine fonksiyon başarı durumunda hostent nesnesinin 
    adresine, başarısızlık durumunda NULL adrese geri dönmektedir. Bu fonksiyon da errno yerine h_errno değişkeninin set 
    etmektedir. Yine bu h_errno değerine yazıya dönüştürmek için hstrerror fonksiyonu kullanılmaktadır.

    O anda çalışılan makinenin IPv4 adresi "127.0.0.1" ile temsil edilmektedir. Bu adrese "loopback address" de denilmektedir. 
    Bazı işletim sistemlerinde (Windows, Linux ve macOS) "localhost" ismi de o anda çalışılan makinenin host ismi olarak 
    kullanılabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Artık client program connect fonksiyonuyla TCP bağlantısını sağlayabilir. connect fonksiyonunun prototipi şöyledir:

    #include <sys/socket.h>

    int connect(int socket, const struct sockaddr *address, socklen_t address_len);

    Fonksiyonun birinci parametresi soket betimleyicisini belirtir. İkinci parametre bağlanılacak server'a ilişkin sockaddr_in
    yapı nesnesinin adresini belirtmektedir. Fonksiyonun üçüncü parametresi, ikinci parametredeki yapının uzunluğunu almaktadır. 
    Fonksiyon başarı durumunda sıfır değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    Eğer connect fonksiyonu çağrıldığında server program çalışmıyorsa ya da server programın bağlantı kuyruğu doluysa connect
    belli bir zaman aşımı süresi kadar bekler ve sonra başarısız olur ve errno değeri ECONNREFUSED ("Connection refused") ile
    set edilir. Örneğin:

    if (connect(client_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("connect");

    Aşağıda örnekte bağlantı için gereken minimum client program verilmiştir. Burada henüz görmediğimiz işlemleri hiç uygulamadık.
---------------------------------------------------------------------------------------------------------------------------*/

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define SERVER_NAME        "127.0.0.1"
#define SERVER_PORT        55555

void exit_sys(const char *msg);

int main(void)
{
    int client_sock;
    struct sockaddr_in sin_server;
    struct hostent *hent;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    /*
    {
        struct sockaddr_in sin_client;

        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(50000);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }
    */

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORT);
    if ((sin_server.sin_addr.s_addr = inet_addr(SERVER_NAME)) == -1) {
        if ((hent = gethostbyname(SERVER_NAME)) == NULL) {
            fprintf(stderr, "gethostbyname: %s\n", hstrerror(h_errno));
            exit(EXIT_FAILURE);
        }
        memcpy(&sin_server.sin_addr.s_addr, hent->h_addr_list[0], hent->h_length);
    }

    if (connect(client_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("connect");

    printf("connected...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Tıpkı borularda olduğu gibi soketlerlerde de "blokeli" ve "blokesiz" çalışma söz konusudur. Soketlerde default çalışma 
    biçimi "blokeli" moddur. Blokeli modda gönderme ve alma işlemlerinde aşağıda açıklayacağımız gibi belli koşullarda bloke
    oluşmaktadır. Blokesiz modda ise hiçbir zaman bloke oluşmaz. Biz de default mod olan blokeli modu ele alacağız. 
    Genellikle kullanılan mod da zaten blokeli moddur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bağlantı sağlandıktan sonra artık recv ya da read ve write fonksiyonlarıyla gönderme alma işlemleri yapılabilir. 
    recv fonksiyonunun prototipi şöyledir:

    #include <sys/socket.h>

    ssize_t recv(int socket, void *buffer, size_t length, int flags);

    Fonksiyonun birinci parametresi aktif soketin betimleyicisini belirtmektedir. İkinci parametre alınacak bilginin 
    yerleştirileceği dizinin adresini almaktadır. Üçüncü parametre ise okunmak istenen byte sayısını belirtmektedir. 
    Fonksiyonun son parametresi aşağıdaki üç sembolik sabitin bit OR işlemine sokulmasıyla oluşturulabilir:

    MSG_PEEK
    MSG_OOB
    MSG_WAITALL

    Biz şimdilik bu değerlerin anlamlarını açıklamayacağız. Ancak MSG_PEEK değeri bilginin network tamponundan alındıktan sonra
    oradan atılmayacağını belirtmektedir. Bu parametre 0 da geçilebilir. Zaten recv fonksiyonunun read fonksiyonundan tek farkı
    bu son parametredir. Bu son parametrenin 0 geçilmesiyle read kullanılması arasında hiçbir farklılık yoktur.

    recv fonksiyonu blokeli modda (default durum blokeli moddur) tıpkı borularda olduğu gibi eğer hazırda en az 1 byte varsa
    okuyabildiği kadar bilgiyi okur ve okuyabildiği byte sayısına geri döner. Eğer o anda network tamponunda hiç byte yoksa
    recv fonksiyonu en az 1 byte okuyana kadar blokede bekler. (Yani başka bir deyişle recv tıpkı borularda olduğu gibi eğer 
    okunacak bir şey yoksa blokede bekler, ancak okunacak en az 1 byte varsa okuyabildiğini okur ve beklemeden geri döner.)

    recv fonksiyonu başarı durumunda okunabilen byte sayısına, başarısızlık durumunda -1 değerine geri dönmektedir. 
    Eğer karşı taraf soketi (peer socket) kapatmışsa bu durumda tıpkı borularda olduğu gibi recv fonksiyonu 0 ile 
    geri dönmektedir. Soketlerle boruların kullanımlarının birbirlerine çok benzediğine dikkat ediniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                100. Ders 25/11/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Soketten bilgi göndermek için send ya da write fonksiyonu kullanılmaktadır. send fonksiyonunun da parametrik yapısı şöyledir:

    #include <sys/socket.h>

    ssize_t send(int socket, const void *buffer, size_t length, int flags);

    Fonksiyonun birinci parametresi aktif soketin betimleyicisini belirtmektedir. İkinci parametre gönderilecek bilgilerin 
    bulunduğu dizinin adresini belirtir. Üçüncü parametre ise gönderilecek byte miktarını belirtmektedir. Son parametre aşağıdaki
    sembolik sabitlerin bit düzeyinde OR işlemine sokulmasıyla oluşturulabilir:

    MSG_EOR
    MSG_OOB
    MSG_NOSIGNAL

    Biz şimdilik bu bayraklar üzerinde durmayacağız.

    send fonksiyonu bilgileri karşı tarafa o anda göndermez. Onu önce network tamponuna yerleştirir. İşletim sistemi o tampondan 
    TCP (dolayısıyla IP) paketleri oluşturarak mesajı göndermektedir. Yani send fonksiyonu geri döndüğünde bilgiler network tamponuna 
    yazılmıştır, ancak henüz karşı tarafa gönderilmemiş olabilir. Pekiyi o anda network tamponu doluysa ne olacaktır? İşte UNIX/Linux 
    sistemlerinde send fonksiyonu, gönderilecek bilginin tamamı network tamponuna aktarılana kadar blokede beklemektedir. Ancak bu 
    konuda işletim sistemleri arasında farklılıklar olabilmektedir. Örneğin Windows sistemlerinde send fonksiyonu eğer network 
    tamponunda gönderilmek istenen kadar yer yoksa ancak en az bir byte'lık boş bir yer varsa tampona yazabildiği kadar byte'ı 
    yazıp hemen geri dönmektedir. Diğer UNIX/Linux sistemleri arasında da send fonksiyonunun davranışı bakımından bu yönde farklılıklar 
    olabilmektedir. Ancak POSIX standartları blokeli modda tüm bilginin network tamponuna yazılana kadar send fonksiyonunun bloke 
    olacağını belirtmektedir. Linux çekirdeği de buna uygun biçimde çalışmaktadır.

    send fonksiyonu network tamponuna yazılan byte sayısı ile geri dönmektedir. Blokeli modda bu değer, yazılmak istenen değerle
    aynı olur. send fonksiyonu başarısızlık durumunda -1 değeri ile geri döner ve errno uygun biçimde set edilir. Tıpkı borularda 
    olduğu gibi send fonksiyonunda da eğer karşı taraf soketi kapatmışsa send fonksiyonu default durumda SIGPIPE sinyalinin 
    oluşmasına yol açmaktadır. Eğer bu sinyalin oluşturulması istenmiyorsa bu durumda send fonksiyonunun son parametresi (flags)
    MSG_NOSIGNAL olarak geçilmelidir. Bu durumda karşı taraf soketi kapatmışsa send fonksiyonu başarısız olur ve errno değeri 
    EPIPE olarak set edilir. send fonksiyonunun soketlerdeki davranışının borulardaki davranışa çok benzediğine dikkat ediniz.

    send fonksiyonunun son parametresi 0 geçildiğinde bu fonksiyonun davranışı tamamen write fonksiyonunda olduğu gibidir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Haberleşmenin sonunda TCP soketi nasıl kapatılmalıdır? Mademki soketler UNIX/Linux sistemlerinde birer dosya betimleyicisi 
    gibidir o halde soketi kapatma işlemi "close" ile yapılabilir. Tabii tıpkı dosyalarda olduğu gibi soketlerde de close işlemi 
    yapılmazsa işletim sistemi proses normal ya da sinyal gibi nedenlerle sonlandığında otomatik olarak betimleyicileri kapatır
    yani close işlemini kendisi yapar.

    Soket betimleyicileri de "dup" işlemine sokulabilir. Bu durumda close işlemi uygulandığında soket nesnesi yok edilmez. 
    Çünkü o nesneyi gören başka bir betimleyici daha vardır. Benzer biçimde fork işlemi sırasında da betimleyicilerin çiftlendiğine 
    dikkat ediniz.

    Aktif soketlerin doğrudan close ile kapatılması iyi bir teknik değildir. Bu soketler önce "shutdown" ile haberleşmeden 
    kesilmeli sonra close ile kapatılmalıdır. Bu biçimde soketlerin kapatılmasına İngilizce "graceful close (zarif kapatma)" 
    denilmektedir. Pekiyi shutdown fonksiyonu ne yapmaktadır ve neden gerekmektedir? close işlemi ile bir soket kapatıldığında 
    işletim sistemi sokete ilişkin tüm veri yapılarını ve bağlantı bilgilerini siler. Örneğin biz karşı tarafa send ile bir 
    şey gönderdikten hemen sonraki satırda close yaparsak artık send ile gönderdiklerimizin karşı tarafa ulaşacağının hiçbir 
    garantisi yoktur. Çünkü anımsanacağı gibi send aslında "gönderme tamponuna" bilgiyi yazıp geri dönmektedir. Hemen arkasından 
    close işlemi uygulandığında artık bu sokete ilişkin gönderme ve alma tamponları da yok edileceğinden tamponda gönderilmeyi 
    bekleyen bilgiler hiç gönderilmeyebilecektir. close işlemini bilgisayarımızı "power düğmesine basarak kapatmaya" benzetebiliriz. 
    Bu durumda o anda çalışan tüm programlar ve işletim sistemi aniden yok edilmektedir. shutdown işlemini de "işletim sistemindeki 
    shutdown" mekanizmasına benzetebiliriz. İşletim sistemini shutdown ettiğimizde tüm prosesler uygun biçimde sonlandırılıp sistem 
    stabil olarak kapatılmaktadır. Tabii soketlerde doğrudan close işlemi çoğu kez önemli bir probleme yol açmayabilir. Ancak doğru 
    teknik aktif soketlere önce shutdown uygulayıp sonra close etmektedir.

    shutdown fonksiyonunun üç işlevi vardır:

    1) Haberleşmeyi TCP çerçevesinde el sıkışarak sonlandırmak (bu konu ileride ele alınacaktır).
    2) Gönderme tamponuna yazılan bilgilerin gönderildiğine emin olmak.
    3) Okuma ya da yazma işlemini sonlandırıp diğer işleme devam edebilmek (half close işlemi).

    shutdown fonksiyonunun prototipi şöyledir:

    #include <sys/socket.h>

    int shutdown(int socket, int how);

    Fonksiyonun birinci parametresi sonlandırılacak soketin betimleyicisini, ikinci parametresi biçimini belirtmektedir. İkinci 
    parametre şunlardan biri olarak girilebilir:

    SHUT_RD: Bu işlemden sonra artık soketten okuma yapılamaz. Fakat sokete yazma yapılabilir. Bu seçenek pek kullanılmamaktadır.

    SHUR_WR: Burada artık shutdown daha önce gönderme tamponuna yazılmış olan byte'ların gönderilmesine kadar bloke oluşturabilir. 
    Bu işlemden sonra artık sokete yazma yapılamaz ancak okuma işlemi devam ettirilebilir.

    SHUT_RDWR: En çok kullanılan seçenektir. Burada da artık shutdown daha önce gönderme tamponuna yazılmış olan byte'ların 
    gönderilmesine kadar bloke oluşturabilir. Artık bundan sonra soketten okuma ya da yazma yapılamamaktadır.

    shutdown başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    O halde aktif bir soketin kapatılması tipik olarak şöyle yapılmaktadır:

    shutdown(sock, SHUT_RDWR);
    close(sock);

    Karşı taraf soketi (peer socket) shutdown ile SHUT_WR ya da SHUT_RDWR ile sonlandırmışsa artık biz o soketten okuma 
    yaptığımızda recv ya da read fonksiyonları 0 ile geri döner. Benzer biçimde karşı taraf doğrudan soketi close ile kapatmışsa 
    yine recv ya da read fonksiyonları 0 ile geri döner.

    Karşı tarafın soketi kapatıp kapatmadığı tipik olarak recv fonksiyonunda anlaşılabilmektedir. Yukarıda da belirttiğimiz 
    gibi karşı taraf soketi kapattıktan sonra biz sokete write ya da send ile bir şeyler yazmak istersek default durumda 
    UNIX/Linux sistemlerinde SIGPIPE sinyali oluşmaktadır. Programcı send fonksiyonunun flags parametresine MSG_NOSIGNAL 
    değerini girerse bu durumda send başarısız olmakta ve errno değişkeni EPIPE değeri ile set edilmektedir. Karşı taraf 
    soketi kapatmamış ancak bağlantı kopmuş olabilir. Bu durumda send/write ve recv/read fonksiyonları başarısız olur ve 
    -1 değeriyle ile geri döner.

    O halde recv ya da read işlemi yapılırken fonksiyonların geri dönüş değerleri -1 ve 0 ile kontrol edilmelidir. Örneğin:

    if ((result = recv(...)) == -1)
        exit_sys("recv");
    if (result == 0) {
        // karşı taraf soketi kapatmış, gerekli işlemleri yap
    }

    Benzer biçimde send ya da write fonksiyonlarıyla yazma yapılırken fonksiyonların geri dönüş değerleri -1 ile kontrol 
    edilmelidir. Örneğin:

    if (send(...) == -1)
        exit_sys("send");
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte client program, server programa bağlanarak stdin dosyasından okuduğu yazıları send fonksiyonu ile server
    programa göndermektedir. Server program da bu yazıları alarak stdout dosyasına basmaktadır. Haberleşme normal olarak 
    client tarafın "quit" yazısını girmesiyle sonlandırılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define SERVER_PORT        55555
#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORT);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("waiting for connection...\n");
    sin_len = sizeof(sin_client);
    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
        exit_sys("accept");

    printf("connected client ===> %s:%d\n", inet_ntoa(sin_client.sin_addr), ntohs(sin_client.sin_port));

    for (;;) {
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received: \"%s\"\n", (intmax_t)result, buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    close(server_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define SERVER_NAME        "127.0.0.1"
#define SERVER_PORT        55555
#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(void)
{
    int client_sock;
    struct sockaddr_in sin_server;
    struct hostent *hent;
    char buf[BUFFER_SIZE];
    char *str;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    /*
    {
        struct sockaddr_in sin_client;

        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(50000);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }
    */

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORT);
    if ((sin_server.sin_addr.s_addr = inet_addr(SERVER_NAME)) == -1) {
        if ((hent = gethostbyname(SERVER_NAME)) == NULL) {
            fprintf(stderr, "gethostbyname: %s\n", hstrerror(h_errno));
            exit(EXIT_FAILURE);
        }
        memcpy(&sin_server.sin_addr.s_addr, hent->h_addr_list[0], hent->h_length);
    }

    if (connect(client_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("connect");

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bu noktada UNIX/Linux sistemlerinde yazılan soket programlarının Windows sistemlerine nasıl port edileceği hakkında bazı 
    açıklamalarda bulunmak istiyoruz.

    Windows sistemlerindeki soket kütüphanesine "Winsock" denilmektedir. Şu anda bu kütüphanenin 2'nci versiyonu kullanılmaktadır. 
    Winsock API fonksiyonları "UNIX/Linux uyumlu" fonksiyonlar ve Windows'a özgü fonksiyonlar olmak üzere iki biçimde kullanılabilmektedir. 
    Ancak Winsock'un UNIX/Linux uyumlu fonksiyonlarında da birtakım değişiklikler söz konusudur. Bir UNIX/Linux ortamında yazılmış
    soket uygulamasının Windows sistemlerine aktarılması için şu düzeltmelerin yapılması gerekir:

    1) POSIX'in soket sistemine ilişkin tüm başlık dosyaları kaldırılır. Onun yerine <winsock2.h> dosyası include edilir.

    2) xxx_t'li typedef türleri silinir ve onların yerine (dokümanlara da bakabilirsiniz) int, short, unsigned int, unsigned short
    türleri kullanılır. (Örneğin ssize_t türü ve socklen_t türleri yerine int türleri kullanılmalıdır.)

    3) Windows'ta soket sisteminin başlatılması için WSAStartup fonksiyonu işin başında çağrılır ve işin sonunda da bu işlem
    WSACleanup fonksiyonuyla geri alınır. Bu fonksiyonları şöyle kullanabilirsiniz:

    WSADATA wsadata;
    ...
    if ((result = WSAStartup(MAKEWORD(2, 2), &wsadata)) != 0)
        exit_sys("WSAStartup", EXIT_FAILURE, result);
    ...
    WSACleanup();

    4) Windows'ta dosya betimleyicisi kavramı yoktur. (Onun yerine "handle" kavramı vardır.) Dolayısıyla soket türü de int değil,
    SOCKET isimli bir typedef türüdür.

    5) shutdown fonksiyonunun ikinci parametresi SD_RECEIVE, SD_SEND ve SD_BOTH biçimindedir.

    6) close fonksiyonu yerine closesocket fonksiyonu ile soket kapatılır.

    7) Windows'ta soket fonksiyonları başarısızlık durumunda -1 değerine geri dönmezler. socket fonksiyonu başarısızlık durumunda
    INVALID_SOCKET değerine, diğerleri ise SOCKET_ERROR değerine geri dönmektedir.

    8) Visual Studio IDE'sinde default durumda "deprecated" durumlar "error"e yükseltilmiştir. Bunlar için bir makro 
    define edilebilmektedir. Ancak proje ayarlarından "sdl check" disable da edilebilir. Benzer biçimde proje ayarlarından 
    "Unicode" değeri "not set" yapılmalıdır.

    9) Projenin linker ayarlarından Input/Additional Dependencies edit alanına Winsock kütüphanesi olan "Ws2_32.lib" import 
    kütüphanesi eklenir.

    10) Windows'ta son soket API fonksiyonlarının başarısızlık nedenleri WSAGetLastError fonksiyonuyla elde edilmektedir. Yani 
    Windows sistemlerinde errno değişkeni set edilmemektedir. Belli bir hata kodunun yazıya dönüştürülmesi de biraz ayrıntılıdır. 
    Bunun için aşağıdaki fonksiyonu kullanabilirsiniz:

    void ExitSys(LPCSTR lpszMsg, DWORD dwLastError)
    {
        LPTSTR lpszErr;

        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
            fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
            LocalFree(lpszErr);
        }

        exit(EXIT_FAILURE);
    }

    Yukarıdaki programların Winsock'a dönüştürülmüş biçimleri aşağıda verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <winsock2.h>

#define SERVER_PORT        55555
#define BUFFER_SIZE        4096

void ExitSys(LPCSTR lpszMsg, DWORD dwLastError);

int main(void)
{
    WSADATA wsadata;
    SOCKET server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    int sin_len;
    char buf[BUFFER_SIZE + 1];
    int result;

    if ((result = WSAStartup(MAKEWORD(2, 2), &wsadata)) != 0)
        ExitSys("WSAStartup", result);

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
        ExitSys("socket", WSAGetLastError());

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORT);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == SOCKET_ERROR)
        ExitSys("bind", WSAGetLastError());

    if (listen(server_sock, 8) == SOCKET_ERROR)
        ExitSys("listen", WSAGetLastError());

    printf("waiting for connection...\n");
    sin_len = sizeof(sin_client);
    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == SOCKET_ERROR)
        ExitSys("accept", WSAGetLastError());

    printf("connected client ===> %s:%d\n", inet_ntoa(sin_client.sin_addr), ntohs(sin_client.sin_port));

    for (;;) {
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == SOCKET_ERROR)
            ExitSys("recv", WSAGetLastError());
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received: \"%s\"\n", (intmax_t)result, buf);
    }

    shutdown(client_sock, SD_BOTH);
    closesocket(client_sock);

    closesocket(server_sock);

    WSACleanup();

    return 0;
}

void ExitSys(LPCSTR lpszMsg, DWORD dwLastError)
{
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <winsock2.h>

#define SERVER_NAME        "192.168.153.131"
#define SERVER_PORT        55555
#define BUFFER_SIZE        4096

void ExitSys(LPCSTR lpszMsg, DWORD dwLastError);

int main(void)
{
    WSADATA wsadata;
    SOCKET client_sock;
    struct sockaddr_in sin_server;
    struct hostent *hent;
    char buf[BUFFER_SIZE];
    char *str;
    int result;

    if ((result = WSAStartup(MAKEWORD(2, 2), &wsadata)) != 0)
        ExitSys("WSAStartup", result);

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
        ExitSys("socket", WSAGetLastError());

    /*
    {
        struct sockaddr_in sin_client;

        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(50000);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == SOCKET_ERROR)
            ExitSys("bind", WSAGetLastError());
    }
    */

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(SERVER_PORT);
    if ((sin_server.sin_addr.s_addr = inet_addr(SERVER_NAME)) == SOCKET_ERROR) {
        if ((hent = gethostbyname(SERVER_NAME)) == NULL)
            ExitSys("gethostbyname", WSAGetLastError());
        memcpy(&sin_server.sin_addr.s_addr, hent->h_addr_list[0], hent->h_length);
    }

    if (connect(client_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == SOCKET_ERROR)
        ExitSys("connect", WSAGetLastError());

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, (int)strlen(buf), 0) == SOCKET_ERROR)
            ExitSys("send", WSAGetLastError());
        if (!strcmp(buf, "quit"))
            break;
    }

    shutdown(client_sock, SD_BOTH);
    closesocket(client_sock);

    WSACleanup();

    return 0;
}

void ExitSys(LPCSTR lpszMsg, DWORD dwLastError)
{
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                101. Ders 26/11/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kurstaki denemeleri genellikle sanal makine üzerinden yapmaktayız. Sanal makine programları zaman içerisinde oldukça 
    gelişmiştir. Bunlardan "docker" sistemleri de evrimleştirilmiştir. Sanal makine için bedava iki önemli alternatif
    "VMware Player" ve "VirtualBox" programlarıdır. Biz kursumuzda "VMware Player" kullanıyoruz. Ancak "VirtualBox" da 
    problemsiz bir biçimde aynı kalitede işlev görmektedir.

    VMware Player donanım sanallaştırmasını tam olarak yapmaktadır. Yani oluşturulan sanal makine tamamen sanki aynı yerel
    ağa bağlı olan bağımsız bir makine gibi davranmaktadır. Bu sanal makineye biz istediğimiz kadar network kartı 
    takabiliriz. TCP/IP denemelerinde client ve server programlar "host" ve "guest" sistemlerde konuşlandırılabilir. Bu durumda
    kullanılacak IP adreslerine dikkat etmek gerekir. VMWare'deki guest IP adresini öğrenebilmek için önce "Virtual Machine 
    Settings/Network Adapter/Advanced" düğmelerinden sanal ethernet kartının MAC adresini görmelisiniz. Sonra host sistemde 
    bu MAC adresine karşı gelen IP adresini bulmaya çalışabilirsiniz. Bunun için "arp -a" komutu kullanılabilir. Bu komutta
    aşağıdaki gibi bir çıktı göreceksiniz:

    Interface: 192.168.153.1 --- 0x10
    Internet Address      Physical Address      Type
    192.168.153.128       00-0c-29-76-3b-e8     dynamic
    192.168.153.131       00-0c-29-76-3b-fc     dynamic
    192.168.153.255       ff-ff-ff-ff-ff-ff     static
    224.0.0.22            01-00-5e-00-00-16     static
    224.0.0.251           01-00-5e-00-00-fb     static
    224.0.0.252           01-00-5e-00-00-fc     static
    239.255.255.250       01-00-5e-7f-ff-fa     static
    255.255.255.255       ff-ff-ff-ff-ff-ff     static

    Burada MAC adresine karşı gelen IP adresini elde edebilirsiniz.

    Benzer biçimde guest sistemden host sisteme erişebilmek için host sistemin guest sistemde kullanılacak IP adresini elde 
    etmeniz gerekir. Bu IP adresi host sistemin LAN üzerindeki yerel IP adresi değildir. Bu IP adresi "arp -a" komutuyla ya da 
    Windows'taki "ipconfig" komutuyla elde edilebilir. Yukarıdaki çıktıdaki ilk satır zaten bunu belirtmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Client ve server programları yazarken onların ilgili olduğu server ve port numaralarını komut satırı argümanlarıyla 
    almak iyi bir tekniktir. Örneğin biz client programı şöyle çalıştırabilmeliyiz:

    ./client -s <server_ismi> -p <server_port> -b <client_port>

    Tabii buradaki -s ve -p seçeneklerinin default değerleri de söz konusu olacaktır.

    Benzer biçimde server program da aşağıdaki gibi çalıştırılabilir olmalıdır:

    ./server -p <port_numarası>

    Buradaki port numarası server'ın dinlediği port numarasıdır. Bunun da bir default değeri olabilir.

    Aşağıda daha önce yazmış olduğumuz client ve server programların bu biçime getirilmiş hallerini veriyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;
    int option;
    int server_port;
    int p_flag, err_flag;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("listening port %d\n", server_port);

    printf("waiting for connection...\n");
    sin_len = sizeof(sin_client);
    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
        exit_sys("accept");

    printf("connected client ===> %s:%d\n", inet_ntoa(sin_client.sin_addr), ntohs(sin_client.sin_port));

    for (;;) {
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received: \"%s\"\n", (intmax_t)result, buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    close(server_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_server, sin_client;
    struct hostent *hent;
    char buf[BUFFER_SIZE];
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int server_port, bind_port;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    if ((sin_server.sin_addr.s_addr = inet_addr(server_name)) == -1) {
        if ((hent = gethostbyname(server_name)) == NULL) {
            fprintf(stderr, "gethostbyname: %s\n", hstrerror(h_errno));
            exit(EXIT_FAILURE);
        }
        memcpy(&sin_server.sin_addr.s_addr, hent->h_addr_list[0], hent->h_length);
    }

    if (connect(client_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("connect");

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    TCP protokolünün gerçekleştirimlerinde tipik olarak işletim sistemleri her soket için "gönderme tamponu (sending buffer)" 
    ve "alma tamponu (receiving buffer)" kullanmaktadır. TCP'de bir akış kontrolünün de uygulandığını anımsayınız. Bu akış 
    kontrolünün nasıl uygulandığına izleyen paragraflarda değineceğiz. Bizim send ya da write fonksiyonlarıyla karşı tarafa 
    göndermek istediğimiz bilgiler önce gönderme tamponuna yazılmakta sonra işletim sistemi tarafından TCP/IP paketi haline 
    getirilip gönderilmektedir. send ve write fonksiyonları bilgiyi gönderme tamponuna yazıp hemen geri dönmektedir. Bu 
    fonksiyonların geri dönmesi bilgilerin karşı tarafa iletildiği anlamına gelmemektedir. Benzer biçimde işletim sistemi 
    network kartına gelen bilgileri onun ilişkin olduğu soketin alma tamponuna kendisi yerleştirmektedir. recv ve read 
    fonksiyonları bu alma tamponuna bakmaktadır. Default blokeli modda bu alma tamponu boşsa bu fonksiyonların blokeye yol 
    açtığını belirtmiştik. Benzer biçimde send ve write fonksiyonları da default blokeli modda gönderme tamponuna bilgi tam 
    olarak yazılamıyorsa bilgi tam olarak tampona yazılana kadar blokeye yol açmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Soket programlamada bir tarafın tek bir send ya da write ile gönderdiklerini diğer tarafın tek bir recv ya da read ile 
    okuması garanti değildir. Örneğin biz tek bir send ile 10000 byte göndermiş olalım. Karşı taraf da recv fonksiyonu ile 
    bir döngüde sürekli okuma yapıyor olsun. Örneğin karşı taraf önce recv ile 4096 byte okuyabilir. Sonra diğer recv ile 
    kalan byte'ları okuyabilir. Bu durum soket programlarının organizasyonunu biraz karışık hale getirmektedir. Bu nedenle 
    örneğin biz 10000 byte gönderen bir tarafın gönderdiği 10000 byte'ı okuyabilmek için bir döngü kullanmamız gerekir. 
    Soketten belli miktarda byte okuyana kadar okumayı devam ettiren bir fonksiyon aşağıdaki gibi yazılabilir:

    ssize_t read_socket(int sock, char *buf, size_t len)
    {
        size_t left, index;

        left = len;
        index = 0;

        while (left > 0) {
            if ((result = recv(sock, buf + index, left, 0)) == -1)
                return -1;
            if (result == 0)
                break;
            index += result;
            left -= result;
        }

        return (ssize_t) index;
    }

    Bu fonksiyonun çalışması oldukça basittir. recv ile her defasında left kadar byte okunmak istenmiştir. Ancak left 
    kadar değil, result kadar byte okunmuş olabilir. Bu durumda left okunan miktar kadar azaltılmış index ise o miktar 
    kadar artırılmıştır. Yukarıdaki fonksiyondan üç nedenle çıkılabilir:

    1) Bağlantı kopmuştur ve recv başarısız olur.
    2) Karşı taraf soketi kapatmıştır. recv 0 ile geri döner.
    3) İstenen kadar miktar okunmuştur.

    Aslında recv fonksiyonunun talep edilen miktarda byte'ların hepsinin okunabilmesi için MSG_WAITALL biçiminde bir flags 
    parametresi de vardır. Ancak MSG_WAITALL flags parametresi alma tamponundan daha yüksek miktarda verilerin okunması 
    için uygun olmayabilmektedir. Bu konu ileride ele alınacaktır.

    Yeniden vurgulamak gerekirse bir soketten n byte okuma işlemi tek bir recv ile başarılmak zorunda değildir. Soket 
    programlamaya yeni başlayanlar sanki bir disk dosyasından ya da borudan bilgi okunuyor gibi tek bir okuma çağrısı ile 
    bunu yapma eğilimindedirler. Halbuki bu işlem yukarıdaki gibi bir döngüyle ya da recv fonksiyonuna MSG_WAITALL flags 
    parametresi girilerek yapılmak zorundadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Zamanla bazı klasik soket fonksiyonları yerine onların işlevini yapabilecek daha yetenekli fonksiyonlar oluşturulmuştur. 
    Eski fonksiyonlar IPv4 zamanlarında tasarlanmıştı. IPv6 ile birlikte bu IPv4 için tasarlanmış olan fonksiyonların IPv6'yı 
    da destekleyecek daha genel versiyonları oluşturuldu. Bu eski fonksiyonların bir bölümü de "deprecated" hale getirildi.
    Biz yukarıdaki örneklerde bu eski fonksiyonları kullandık. Ancak artık yeni uygulamalarda IPv6'yı da destekleyen eski bazı 
    fonksiyonların yeni biçimlerinin kullanılması daha uygundur. Biz de bu bölümde bu fonksiyonları ele alacağız bundan sonra 
    bu fonksiyonları kullanacağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    inet_ntoa fonksiyonu bilindiği gibi 4 byte'lık IPv4 adresini noktalı desimal formata dönüştürüyordu. İşte bu fonksiyonun 
    inet_ntop isimli IPv6'yı da kapsayan gelişmiş bir biçimi vardır:

    #include <arpa/inet.h>

    const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);

    Fonksiyonun birinci parametresi AF_INET (IPv4) ya da AF_INET6 (IPv6) olarak girilmelidir. İkinci parametre dönüştürülecek 
    nümerik IPv4 ya da IPv6 adresinin bulunduğu nesnenin adresini belirtmektedir. Fonksiyon dönüştürme sonucunda elde edilecek 
    yazısal noktalı desimal formatı üçüncü parametreyle belirtilen adresten itibaren yerleştirir. Son parametre üçüncü parametredeki 
    dizinin uzunluğunu belirtir. Bu parametre INET_ADDRSTRLEN ya da INET6_ADDRSTRLEN biçiminde girilebilir. Fonksiyon başarı 
    durumunda üçüncü parametreyle belirtilen adrese, başarısızlık durumunda NULL adrese geri döner. Örneğin bu fonksiyon server 
    programda şöyle kullanılabilir:

    char ntopbuf[INET_ADDRSTRLEN];
    ...
    printf("connected client ===> %s:%u\n", inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN), 
            (unsigned)ntohs(sin_client.sin_port));

    inet_ntoa işleminin tersinin inet_addr ile yapıldığını belirtmiştik. İşte inet_addr fonksiyonunun yerine hem IPv4 hem de 
    IPv6 ile çalışan inet_pton fonksiyonu kullanılabilmektedir:

    #include <arpa/inet.h>

    int inet_pton(int af, const char *src, void *dst);

    Fonksiyonun birinci parametresi yine AF_INET ya da AF_INET6 biçiminde geçilir. İkinci parametre noktalı desimal formatın 
    bulunduğu yazının adresini, üçüncü parametre ise nümerik adresin yerleştirileceği adresi almaktadır. Bu parametreye IPv4 için 
    4 byte'lık, IPv6 için 16 byte'lık yerleştirme yapılmaktadır. Fonksiyon başarı durumunda 1 değerine, başarısızlık durumunda 
    0 ya da -1 değerine geri döner. Eğer başarısızlık birinci parametreden kaynaklanıyorsa -1, ikinci parametreden kaynaklanıyorsa 
    0 değerine geri dönmektedir. Bu durumda örneğin client programda inet_addr yerine inet_pton fonksiyonunu şöyle çağırabilirdik:

    if (inet_pton(AF_INET, server_name, &sin_server.sin_addr.s_addr) == 0) {
        ...
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                102. Ders 02/12/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    IPv6 ile birlikte yeni gelen diğer bir fonksiyon da getaddrinfo isimli fonksiyondur. Bu fonksiyon aslında inet_addr ve 
    gethosybyname fonksiyonlarının IPv6'yı da içerecek biçimde genişletilmiş bir biçimidir. Yani getaddrinfo hem noktalı 
    desimal formatı nümerik adrese dönüştürür hem de eğer geçersiz bir noktalı desimal format söz konusuysa (bu durumda server 
    isimsel olarak girilmiş olabilir) DNS işlemi yaparak ilgili host'un IP adresini elde eder. Maalesef fonksiyon biraz karışık 
    tasarlanmıştır. Fonksiyonun prototipi şöyledir:

    #include <netdb.h>

    int getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res);

    Fonksiyonun birinci parametresi "noktalı desimal formatlı IP adresi" ya da "host ismini" belirtmektedir. İkinci parametre 
    NULL geçilebilir ya da buraya port numarası girilebilir. Ancak bu parametreye port numarası girilecekse yazısal biçimde 
    girilmelidir. Fonksiyon bu port numarasını htons yaparak "big endian" formata dönüştürüp bize verecektir. Bu parametreye
    aynı zamanda IP ailesinin uygulama katmanına ilişkin spesifik bir protokolün ismi de girilebilmektedir (Örneğin "http" gibi, 
    "ftp" gibi). Bu durumda bu protokollerin port numaraları bilindiği için sanki o port numaraları girilmiş gibi işlem yapılır.
    Eğer bu parametreye NULL girilirse bize port olarak 0 verilecektir. Port numarasını biz yerleştiriyorsak bu parametreye NULL 
    girebiliriz. Fonksiyonun üçüncü parametresi nasıl bir adres istediğimizi anlatan filtreleme seçeneklerini belirtir. Bu parametre 
    addrinfo isimli bir yapı türündendir. Bu yapının yalnızca ilk dört elemanı programcı tarafından girilebilmektedir. Ancak POSIX 
    standartları bu yapının elemanlarının sıfırlanmasını öngörmektedir (buradaki sıfırlanmak terimi normal türdeki elemanlar için 
    0 değerini, göstericiler için NULL adres değerini belirtmektedir). addrinfo yapısı şöyledir:

    struct addrinfo {
        int              ai_flags;
        int              ai_family;
        int              ai_socktype;
        int              ai_protocol;
        socklen_t        ai_addrlen;
        struct sockaddr *ai_addr;
        char            *ai_canonname;
        struct addrinfo *ai_next;
    };

    Yapının ai_flags elemanı pek çok bayrak değeri alabilmektedir. Bu değer 0 olarak da geçilebilir. Yapının ai_family elemanı 
    AF_INET girilirse host'a ilişkin IPv4 adresleri, AF_INET6 girilirse host'a ilişkin IPv6 adresleri, AF_UNSPEC girilirse hem 
    IPv4 hem de IPv6 adresleri elde edilir. Yapının ai_socktype elemanı 0 girilebilir ya da SOCK_STREAM veya SOCK_DGRAM girilebilir. 
    Fonksiyonun ayrıntılı açıklaması için dokümanlara başvurunuz. Bu parametre NULL adres de girilebilir. Bu durumda ilgili host'a 
    ilişkin tüm adresler elde edilir.

    getaddrinfo fonksiyonunun son parametresine bir bağlı listenin ilk elemanını gösteren adres yerleştirilmektedir. Buradaki 
    bağlı listenin bağ elemanı struct addrinfo yapısının ai_next elemanıdır. Bu bağlı listenin boşaltımı freeaddrinfo fonksiyonu
    tarafından yapılmaktadır.

    getaddrinfo fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda error koduna geri döner. Bu error kodları klasik 
    errno değerlerinden farklı olduğu için strerror fonksiyonuyla değil, gai_strerror fonksiyonuyla yazıya dönüştürülmelidir.

    Bağlı listenin düğümlerini free hale getirmek için freeaddrinfo fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <netdb.h>

    void freeaddrinfo(struct addrinfo *ai);

    Fonksiyon getaddrinfo fonksiyonunun verdiği bağlı listenin ilk düğümünün (head pointer) adresini parametre olarak alır ve tüm
    bağlı listeyi boşaltır. gai_strerror fonksiyonunun prototipi de şöyledir:

    #include <netdb.h>

    const char *gai_strerror(int ecode);

    getaddrinfo fonksiyonunun client programda tipik kullanımı aşağıda verilmiştir.

    getaddrinfo fonksiyonu sayesinde client program için önceki örneklerde yaptığımız işlemleri oldukça basitleştirmiş olmaktayız. 
    Biz daha önce client programda önce inet_addr fonksiyonu ya da inet_pton fonksiyonu ile server adresinin noktalı formatta olup
    olmadığını anlayıp duruma göre gethostbyname fonksiyonu ile DNS işlemi yapmıştık. Oysa getaddrinfo fonksiyonu bu iki işlemi 
    birlikte yapmaktadır. Bu fonksiyon bize connect için gereken sockaddr_in ya da sockadd_in6 yapı nesnelerini kendisi oluşturup
    sockaddr türünden bir adres gibi vermektedir. Client programın bu fonksiyonu kullanarak bağlantı sağlaması aşağıdaki gibi 
    bir kalıpla sağlanabilir:

    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    ...

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    Burada server_name noktalı desimal formattaki server IP numarasını ya da server ismini belirtmektedir. server_port ise yazısal
    biçimde port numarasını belirtmektedir. sockaddr yapı nesnesinin oluşturulması için gereken bilgiler ise hints parametresinde 
    girilmiştir. Fonksiyon DNS işlemi sonucunda elde edilen host bilgilerini bir bağlı liste biçiminde vermektedir. Bu örnek kodda
    bağlı listenin her elemanı connect fonksiyonuna sokulmuş ve bağlantı sağlanmaya çalışılmıştır. Örneğimizde biz hints parametresine
    AF_INET değerini girdik. Bu durumda DNS işlemi yapılırken fonksiyon yalnızca IPv4 adreslerini elde edecektir. IP bağlantısında 
    bir taraf IPv4, diğer taraf IPv6 da olabilmektedir. hints parametresine eğer biz AF_UNSPEC geçseydik fonksiyon bize hem IPv4 
    hem de IPv6 adreslerini verecektir. Örnek kodda elde edilen adreslerden hiçbiri ile bağlantı sağlanamamışsa program 
    sonlandırılmıştır.

    getaddrinfo fonksiyonunun tersini yapan getnameinfo isminde bir fonksiyon da sonraları soket kütüphanesine eklenmiştir. 
    getnameinfo aslında inet_ntop, getserverbyname (biz görmedik) fonksiyonlarının birleşimi gibidir. Biz aşağıdaki
    örnekte bu fonksiyonu kullanmayacağız.

    #include <netdb.h>

    int getnameinfo(const struct sockaddr *addr, socklen_t addrlen, char *host, 
            socklen_t hostlen, char *serv, socklen_t servlen, int flags);

    Fonksiyonun birinci parametresi sockaddr_in ya da sockaddr_in6 yapısını almaktadır. İkinci parametre birinci parametredeki 
    yapının uzunluğudur. Fonksiyonun sonraki dört parametresi sırasıyla noktalı hostun yazısal temsilin yerleştirileceği dizinin 
    adresi ve uzunluğu, port numarasına ilişkin yazının (servis ismi) yerleştirileceği dizinin adresi ve uzunluğudur. Son parametre 
    0 geçilebilir. Maksimum host ismi NI_MAXHOST ile maksimum servis ismi ise NI_MAXSERV ile belirtilmiştir.

    Yukarıda yazdığımız server ve client programlarının yeni fonksiyonlarla modern yazım biçimini de aşağıda veriyoruz. Bu 
    server ve client programları birer şablon olarak kullanabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;
    char buf[BUFFER_SIZE + 1];
    char ntopbuf[INET_ADDRSTRLEN];
    ssize_t result;
    int option;
    int server_port;
    int p_flag, err_flag;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("listening port %d\n", server_port);

    printf("waiting for connection...\n");
    sin_len = sizeof(sin_client);
    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
        exit_sys("accept");

    printf("connected client ===> %s:%u\n", inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sin_client.sin_port));

    for (;;) {
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received: \"%s\"\n", (intmax_t)result, buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    close(server_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[BUFFER_SIZE];
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Soket bağlantısında kullanılan diğer iki fonksiyon da getpeername ve getsockname fonksiyonlarıdır. getpeername fonksiyonu
    bağlı bir soketi parametre olarak alır ve karşı tarafın ip adresini ve port numarasını bize sockaddr_in ya da sockaddr_in6 
    biçiminde verir. Tabii aslında server bağlantıyı yaptığında karşı tarafın bilgisini zaten accept fonksiyonunda almaktadır. 
    Bu bilgi saklanarak kullanılabilir. Ancak bu bilgi saklanmamışsa istenildiği zaman getpeername fonksiyonuyla alınabilmektedir. 
    Fonksiyonun prototipi şöyledir:

    #include <sys/socket.h>

    int getpeername(int sock, struct sockaddr *addr, socklen_t *addrlen);

    Fonksiyonun birinci parametresi soket betimleyicisidir. İkinci parametre duruma göre karşı tarafın bilgilerinin yerleştirileceği 
    sockaddr_in ya da sockaddr_in6 yapı nesnesinin adresini alır. Son parametre ikinci parametredeki yapının uzunluğunu belirtmektedir. 
    Eğer buraya az bir uzunluk girilirse kırpma yapılır ve gerçek uzunluk verdiğimiz adresteki nesneye yerleştirilir. Fonksiyon başarı 
    durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir.

    getpeername fonksiyonunun ters işlemini getsockname fonksiyonu yapmaktadır. Bu fonksiyon kendi bağlı soketimizin ip adresini ve 
    port numarasını elde etmek için kullanılır. Genellikle bu fonksiyona gereksinim duyulmamaktadır.

    #include <sys/socket.h>

    int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

    Fonksiyonun parametrik yapısı ve geri dönüş değeri getpeername fonksiyonundaki gibidir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar TCP bağlantısının sağlanması ve send/recv fonksiyonlarının kullanımlarını gördük. Artık dikkatimizi 
    bağlantı sonrasındaki haberleşmeye yönelteceğiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP/IP client-server programlamada en önemli konulardan biri "çok client'lı (multi-client)" server programların yazılmasıdır.
    Server program birden fazla client ile haberleşme yaparken bir client için recv ya da read fonksiyonunu kullandığında 
    eğer o client'a bilgi gelmemişse bloke oluşacağından dolayı diğer client'lardan bilgi okuyamayacaktır. Bu durumda daha önce
    görmüş olduğumuz ileri IO tekniklerinin uygulanması gerekmektedir. Biz daha önce bu ileri IO tekniklerini borular üzerinde
    incelemiştik. Aslında bu tekniklerin borularda kullanılmasıyla soketlerde kullanılması benzer biçimdedir. Daha önce ele 
    aldığımız ileri IO teknikleri şunlardı (scatter/getter IO tekniğini burada listelemiyoruz):

    1) Multiplexed IO
    2) Sinyal Tabanlı (Signal Driven) IO
    3) Asenkron IO

    İşte biz bu bölümde bu IO tekniklerini de kullanarak çok client'lı TCP server uygulamalarının nasıl yazılabileceği üzerinde
    duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çok client'lı server uygulamalarında accept fonksiyonu bir kez çağrılmaz. Bir döngü içerisinde çağrılır. Çünkü server 
    her client için accept uygulamak zorundadır. Örneğin:

    for (;;) {
        printf("waiting for connection...\n");
        sin_len = sizeof(sin_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
            exit_sys("accept");

        printf("connected client ===> %s:%u\n", inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN), 
                (unsigned)ntohs(sin_client.sin_port));
    }

    Tabii accept fonksiyonu default durumda blokeye yol açmaktadır. Pekiyi hem accept fonksiyonunda beklenip hem de 
    bağlanılmış client'lar ile konuşma nasıl yapılacaktır?
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                103. Ders 03/12/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Multi-client programlar için en basit ancak en verimsiz yöntem/model "fork modeli"dir. Eğer az sayıda client söz konusu ise 
    bu model basitliğinden dolayı tercih edilebilir. Bu modelde her accept işleminde bir fork yapılır. Alt proses bağlanılan
    client ile konuşur. Ancak her client için yeni bir prosesin yaratılması aslında verimsiz bir yöntemdir. Tabii az client
    söz konusu ise basitliğinden dolayı bu yöntem yine de kullanılabilir.

    Aşağıda fork modeliyle multi-client bir server örneği verilmiştir. Örnekte client programlar server ile bağlanıp ona yazı 
    göndermekte, server program da bu yazıyı ters çevirerek client programlara geri yollamaktadır. Örneği test etmek için 
    birden fazla terminal penceresi açmalısınız. Bu programda fork işlemi yapıldığında üst prosesin o andaki bellek alanının 
    alt prosese kopyalandığına dolayısıyla alt prosesin son accept yapılan client sokete sahip olduğuna dikkat ediniz. 
    Örneğimizde server program sonsuz döngüde çalışmaktadır. Server programı sonlandırmak için Ctrl+c tuşlarıyla ona SIGINT
    sinyalini gönderebilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096

void client_proc(int sock, struct sockaddr_in *sin);
char *revstr(char *str);
void exit_sys(const char *msg);

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;
    char ntopbuf[INET_ADDRSTRLEN];
    int option;
    int server_port;
    int p_flag, err_flag;
    pid_t pid;
    struct sigaction sa;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    sa.sa_handler = SIG_IGN;

    if (sigaction(SIGCHLD, &sa, NULL) == -1)
        exit_sys("sigaction");

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("listening port %d\n", server_port);

    for (;;) {
        printf("waiting for connection...\n");
        sin_len = sizeof(sin_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
            exit_sys("accept");

        printf("connected client ===> %s:%u\n", inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sin_client.sin_port));

        if ((pid = fork()) == -1)
            exit_sys("fork");

        if (pid == 0) {
            client_proc(client_sock, &sin_client);
            exit(EXIT_SUCCESS);
        }
    }

    close(server_sock);

    return 0;
}

void client_proc(int sock, struct sockaddr_in *sin)
{
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    char ntopbuf[INET_ADDRSTRLEN];
    unsigned port;
    ssize_t result;

    inet_ntop(AF_INET, &sin->sin_addr, ntopbuf, INET_ADDRSTRLEN);
    port = (unsigned)ntohs(sin->sin_port);

    for (;;) {
        if ((result = recv(sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received from %s:%u: \"%s\"\n", (intmax_t)result, ntopbuf, port, buf);
        revstr(buf);
        if (send(sock, buf, result, 0) == -1)
            exit_sys("send");
    }

    printf("client disconnected %s:%u\n", ntopbuf, port);

    shutdown(sock, SHUT_RDWR);
    close(sock);
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    ssize_t result;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;

        buf[result] = '\0';
        printf("%s\n", buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Thread modeli fork modeline benzemektedir. Ancak thread yaratmak proses yaratmaktan daha kolay olduğu için proses modeline
    göre daha az maliyetlidir. Bu modelde her accept işleminde bir proses değil, thread yaratılmaktadır. Tabii thread'ler aynı 
    adres alanını kullandığı için onlara gerekli parametreler uygun biçimde geçirilmelidir.

    Aşağıdaki örnekte fork işlemi ile proses yaratmak yerine pthread_create fonksiyonu ile thread yaratılmıştır. Yaratılan 
    thread'e client bilgileri CLIENT_INFO yapısı eşliğinde geçirilmiştir. CLIENT_INFO yapı nesnesi dinamik olarak tahsis edilmiş 
    ve thread fonksiyonu içerisinde free işlemi uygulanmıştır. UNIX/Linux sistemlerinde nasıl "zombie proses" oluyorsa "zombie
    thread" de oluşabilmektedir. Örneğimizde zombie thread oluşumunu engellemek için thread yaratılır yaratılmaz pthread_detach
    fonksiyonu ile thread detach moda sokulmuştur. 
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096

void *client_thread_proc(void *param);
char *revstr(char *str);
void exit_sys(const char *msg);

typedef struct tagCLIENT_INFO {
    int sock;
    struct sockaddr_in sin;
} CLIENT_INFO;

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;
    char ntopbuf[INET_ADDRSTRLEN];
    int option;
    int server_port;
    int p_flag, err_flag;
    pthread_t tid;
    CLIENT_INFO *ci;
    int result;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("listening port %d\n", server_port);

    for (;;) {
        printf("waiting for connection...\n");
        sin_len = sizeof(sin_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
            exit_sys("accept");

        printf("connected client ===> %s:%u\n", inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sin_client.sin_port));

        if ((ci = (CLIENT_INFO *)malloc(sizeof(CLIENT_INFO))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }

        ci->sock = client_sock;
        ci->sin = sin_client;

        if ((result = pthread_create(&tid, NULL, client_thread_proc, ci)) != 0) {
            fprintf(stderr, "pthread_create: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }

        if ((result = pthread_detach(tid)) != 0) {
            fprintf(stderr, "pthread_detach: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }
    }

    close(server_sock);

    return 0;
}

void *client_thread_proc(void *param)
{
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    char ntopbuf[INET_ADDRSTRLEN];
    unsigned port;
    ssize_t result;
    CLIENT_INFO *ci = (CLIENT_INFO *)param;

    inet_ntop(AF_INET, &ci->sin.sin_addr, ntopbuf, INET_ADDRSTRLEN);
    port = (unsigned)ntohs(ci->sin.sin_port);

    for (;;) {
        if ((result = recv(ci->sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received from %s:%u: \"%s\"\n", (intmax_t)result, ntopbuf, port, buf);
        revstr(buf);
        if (send(ci->sock, buf, result, 0) == -1)
            exit_sys("send");
    }

    printf("client disconnected %s:%u\n", ntopbuf, port);

    shutdown(ci->sock, SHUT_RDWR);
    close(ci->sock);

    free(ci);

    return NULL;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    ssize_t result;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;

        buf[result] = '\0';
        printf("%s\n", buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Multi-client server uygulamaları için diğer model de select modelidir. Biz daha önce bu modeli zaten görmüştük ve borular
    üzerinde bu modeli kullanmıştık. Soketler üzerinde de select modelinin kullanılması borulara çok benzerdir. Burada dikkat 
    edilmesi gereken noktalar şunlardır:

    1) Sokete bilgi geldiğinde, karşı taraf soketi kapattığında ve yeni bir bağlantı isteği oluştuğunda bu durum select tarafından 
    bir "okuma olayı" olarak ele alınmaktadır.

    2) İşin başında dinleme soketi (pasif soket) select fonksiyonunun okuma kümesine yerleştirilmelidir. select fonksiyonunun 
    blokesi çözüldüğünde eğer söz konusu okuma olayı dinleme soketi üzerinde gerçekleşmişse bu durumda yeni bir bağlantı isteği
    söz konusudur. Bizim de accept fonksiyonunu çağırıp buradan elde ettiğimiz yeni soketi de select fonksiyonunun okuma kümesine
    dahil etmemiz gerekir.

    3) Karşı taraf soketi kapattığında bu durum recv fonksiyonunda anlaşılmaktadır. Dolayısıyla programcının soketi kapatıp ilgili 
    betimleyiciyi select fonksiyonunun okuma kümesinden çıkarması da gerekir.

    Aşağıda select modeli ile bir TCP server örneği verilmiştir. Bu örnekte select fonksiyonunun blokesi çözüldüğünde
    önce betimleyicinin dinleme soketine ilişkin betimleyici olup olmadığına bakılmıştır. Eğer betimleyici dinleme soketine
    ilişkinse accept işlemi uygulanmıştır. Değilse recv işlemi uygulanmıştır. Karşı taraf soketi kapattığında recv fonksiyonu 
    0 ile geri dönecektir. Bu durumda ilgili soket okuma kümesinden çıkartılmıştır. Örneğimizdeki server kodunda iç içe 
    birkaç if deyimi kullanılmıştır. Kod aslında fonksiyonlar yoluyla daha anlaşılabilir biçimde de düzenlenebilirdi.

    Server program için diğer bir tasarım şöyle de olabilirdi: Bağlanan her client için yine bir CLIENT_INFO yapısı tahsis 
    edilebilirdi. Client bilgileri bu yapının içinde saklanabilirdi. Sonra da dosya betimleyicisinden hareketle CLIENT_INFO 
    nesnesine hızlı bir biçimde erişmek için "hash tablosu" oluşturulabilirdi. 
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096

char *revstr(char *str);
void exit_sys(const char *msg);

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sinaddr_len;
    char buf[BUFFER_SIZE + 1];        /* BUFFER_SIZE is enough */
    socklen_t sin_len;
    char ntopbuf[INET_ADDRSTRLEN];
    int option;
    int server_port;
    int p_flag, err_flag;
    fd_set rset, tset;
    int maxfds;
    ssize_t result;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    FD_ZERO(&rset);
    FD_SET(server_sock, &rset);
    maxfds = server_sock;

    printf("listening port %d\n", server_port);

    for (;;) {
        printf("waiting for connection...\n");

        tset = rset;
        if (select(maxfds + 1, &tset, NULL, NULL, NULL) == -1)
            exit_sys("select");

        for (int fd = 0; fd <= maxfds; ++fd)
            if (FD_ISSET(fd, &tset)) {
                if (fd == server_sock) {
                    sin_len = sizeof(sin_client);
                    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
                        exit_sys("accept");
                    FD_SET(client_sock, &rset);
                    if (client_sock > maxfds)
                        maxfds = client_sock;

                    inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                    printf("connected client ===> %s:%u\n", ntopbuf, (unsigned)ntohs(sin_client.sin_port));
                }
                else {
                    sinaddr_len = sizeof(sin_client);
                    if (getpeername(fd, (struct sockaddr *)&sin_client, &sinaddr_len) == -1)
                        exit_sys("getpeername");
                    inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);

                    if ((result = recv(fd, buf, BUFFER_SIZE, 0)) == -1)
                        exit_sys("recv");
                    if (result > 0) {
                        buf[result] = '\0';
                        if (!strcmp(buf, "quit"))
                            goto DISCONNECT;

                        printf("%jd byte(s) received from %s:%u: \"%s\"\n", (intmax_t)result, ntopbuf, (unsigned)ntohs(sin_client.sin_port), buf);

                        revstr(buf);
                        if (send(fd, buf, result, 0) == -1)
                            exit_sys("send");
                    }
                    else {        /* result == 0 */
                    DISCONNECT:
                        shutdown(fd, SHUT_RDWR);
                        close(fd);
                        FD_CLR(fd, &rset);

                        printf("client disconnected ===> %s:%u\n", ntopbuf, (unsigned)ntohs(sin_client.sin_port));
                    }
                }
            }
    }

    close(server_sock);

    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    ssize_t result;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;

        buf[result] = '\0';
        printf("%s\n", buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    poll modeli de select modeline benzer biçimde uygulanabilir. Bu modelde dikkat edilmesi gereken noktalar şunlardır:

    1) İşin başında yine dinleme soketi (pasif soket) pollfd dizisi içerisine yerleştirilmiş olmalıdır.

    2) pollfd yapısının izlenecek olayı belirten events elemanı POLLIN olarak girilebilir.

    3) poll geri döndüğünde pollfd dizisinin revents elemanlarına bakılmalı ve bu elemanlar üzerinde POLLIN olayının 
    gerçekleşip gerçekleşmediği kontrol edilmelidir.

    4) Yeni bağlantı isteği geldiğinde dinleme soketi üzerinde POLLIN olayı oluşmaktadır. Bu durumda programcının accept işlemini
    yapması gerekir. Yeni bağlantı kurulan client'ın pollfd bilgileri yine diziye eklenmelidir.

    5) Karşı taraf soketi kapattığında yine POLLIN olayı gerçekleşmektedir. Bu durumda recv fonksiyonu ile 0 byte okunursa 
    soketin kapatıldığı anlaşılmaktadır. Tabii bu durumda programcının bu pollfd dizisinden bu elemanı çıkarması gerekir.

    Aşağıda multi-client server için poll modeline bir örnek verilmiştir. Burada pfds isimli bir pollfd dizisini oluşturulmuştur. 
    Bu dizinin maksimum uzunluğu MAX_CLIENT kadardır. Her bağlantı sağlandığında yeni client için bu pollfd dizisine bir eleman 
    eklenmiştir. Bir client disconnect olduğunda bu diziden ilgili eleman silinmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <poll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096
#define MAX_CLIENT            1000

char *revstr(char *str);
void exit_sys(const char *msg);

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sinaddr_len;
    char buf[BUFFER_SIZE + 1];        /* BUFFER_SIZE is enough */
    socklen_t sin_len;
    char ntopbuf[INET_ADDRSTRLEN];
    int option;
    int server_port;
    int p_flag, err_flag;
    struct pollfd pfds[MAX_CLIENT];
    int npfds, count;
    ssize_t result;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    pfds[0].fd = server_sock;
    pfds[0].events = POLLIN;
    npfds = 1;

    printf("listening port %d\n", server_port);

    for (;;) {
        printf("waiting for connection...\n");

        if (poll(pfds, npfds, -1) == -1)
            exit_sys("poll");

        count = npfds;

        for (int i = 0; i < count; ++i) {
            if (pfds[i].revents & POLLIN) {
                if (pfds[i].fd == server_sock) {
                    if (npfds >= MAX_CLIENT) {
                        fprintf(stderr, "number of clints exceeds %d limit!...\n", MAX_CLIENT);
                        continue;
                    }
                    sin_len = sizeof(sin_client);
                    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
                        exit_sys("accept");
                    pfds[npfds].fd = client_sock;
                    pfds[npfds].events = POLLIN;
                    ++npfds;

                    inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                    printf("connected client ===> %s:%u\n", ntopbuf, (unsigned)ntohs(sin_client.sin_port));
                }
                else {
                    sinaddr_len = sizeof(sin_client);
                    if (getpeername(pfds[i].fd, (struct sockaddr *)&sin_client, &sinaddr_len) == -1)
                        exit_sys("getpeername");
                    inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);

                    if ((result = recv(pfds[i].fd, buf, BUFFER_SIZE, 0)) == -1)
                        exit_sys("recv");
                    if (result > 0) {
                        buf[result] = '\0';
                        if (!strcmp(buf, "quit"))
                            goto DISCONNECT;

                        printf("%jd byte(s) received from %s:%u: \"%s\"\n", (intmax_t)result, ntopbuf, (unsigned)ntohs(sin_client.sin_port), buf);

                        revstr(buf);
                        if (send(pfds[i].fd, buf, result, 0) == -1)
                            exit_sys("send");
                    }
                    else {
                    DISCONNECT:
                        shutdown(pfds[i].fd, SHUT_RDWR);
                        close(pfds[i].fd);
                        pfds[i] = pfds[npfds - 1];
                        --npfds;

                        printf("client disconnected ===> %s:%u\n", ntopbuf, (unsigned)ntohs(sin_client.sin_port));
                    }
                }
            }
        }
    }

    close(server_sock);

    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    ssize_t result;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;

        buf[result] = '\0';
        printf("%s\n", buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                104. Ders 09/12/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi Linux sistemlerinde en etkin asenkron IO yöntemi epoll isimli yöntemdir. epoll yönteminin
    yalnızca Linux sistemlerine özgü olduğunu anımsayınız. Yine anımsayacağınız gibi bu yöntemde önce epoll_create ya da 
    epoll_create1 fonksiyonlarıyla bir epoll betimleyicisinin yaratılması gerekiyordu. Daha sonra izlenecek betimleyiciler 
    epoll_ctl fonksiyonu ile izlemeye dahil ediliyordu. Ancak olay beklemesi epoll_wait fonksiyonu ile yapılıyordu.

    Biz daha önce borularla epoll örneği yapmıştık. Soketlerle de işlemler benzer biçimde yürütülmektedir. epoll server 
    modelinin anahtar noktalarını şöyle açıklayabiliriz:

    - Önce dinleme soketi epoll ile izlemeye alınmalıdır. Soketten okuma işlemleri için yine EPOLLIN olayı oluşmaktadır.

    - EPOLLIN olayı oluştuğunda olaya konu olan soket betimleyicisinin dinleme soketi olup olmadığına bakılmalıdır. Eğer olaya
    konu olan betimleyici dinleme soketiyse accept işlemi uygulanıp elde edilen betimleyicinin de izlenmesi sağlanmalıdır.

    - Karşı taraf soketi kapattığında hem EPOLLIN hem de EPOLLERR olayları oluşmaktadır. EPOLLIN olayı oluştuğunda recv 
    uygulanıp 0 byte okunduğunda karşı tarafın soketi kapatmış olacağı düşünülmeli ve client soket kapatılmalıdır.

    - Client soketin kapatılması ile otomatik olarak izleme sona erdirilmektedir. Bunun için ayrıca epoll_ctl kullanılmasına
    gerek yoktur.

    - epoll modelinde karşı tarafın soketi kapatmasından dolayı oluşan EPOLLIN ve EPOLLERR olaylarında getpeername fonksiyonu
    kullanılmamalıdır. (Halbuki select ve poll fonksiyonlarında bu durumda getpeername fonksiyonu kullanılabilmektedir.)

    Anımsanacağı gibi epoll modelinde default izleme biçimi "düzey tetiklemeli (level triggered)" biçimdedir. Düzey tetiklemeli
    izlemede bir olay oluştuğunda o olayda olayın gereği yapılmadıktan sonra o olay yeniden oluşuyor gibi izleme yapılmaktadır. 
    Örneğin düzey tetiklemeli izlemede sokete bilgi gelmiş olsun. Bu durumda epoll_wait yapıldığında EPOLLIN olayı gerçekleşecektir. 
    Ancak eğer biz sokete gelen tüm bilgileri okumazsak epoll_wait fonksiyonunu bir daha çağırdığımızda yine EPOLLIN olayı 
    gerçekleşecektir. Çünkü düzey tetiklemede sokette okunacak bilgi olduğu sürece epoll_wait hep bu olayı oluşturacaktır. Ancak 
    kenar tetiklemede durum böyle değildir. Kenar tetiklemeli modda sokete bilgi gelmiş olsun. Bu durumda epoll_wait yapıldığında
    EPOLLIN olayı gerçekleşecektir. Biz bu olayda soketteki tüm bilgileri okumazsak bile artık epoll_wait fonksiyonunu çağırdığımızda
    EPOLLIN olayı oluşmayacaktır. EPOLLIN olayı bu modda yalnızca sokete yeni bir bilgi geldiğinde oluşmaktadır.

    Aşağıda daha önce yaptığımız client/server örneğinin epoll modeli ile düzey tetiklemeli gerçekleştirimi verilmiştir. 
    Örneğimizde disconnect olan client'ın bilgilerini o sırada getpeername uygulayamadığımızdan dolayı yazdırmadık. (Tabii 
    aslında bu tür uygulamalarda sürekli getpeername uygulamak iyi bir teknik değildir. Bağlanılan client'ın bilgilerini
    bir kere saklayıp oradan elde etmek daha iyi bir yöntemdir. Ancak biz buradaki uygulamalarda kodu karmaşık göstermemek 
    için her defasında getpeername fonksiyonunu kullandık.)
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/epoll.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096
#define MAX_EVENTS            1024

char *revstr(char *str);
void exit_sys(const char *msg);

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sinaddr_len;
    char buf[BUFFER_SIZE + 1];            /* BUFFER_SIZE is enough */
    socklen_t sin_len;
    char ntopbuf[INET_ADDRSTRLEN];
    int option;
    int server_port;
    struct epoll_event ee;
    struct epoll_event ree[MAX_EVENTS];
    int p_flag, err_flag;
    int epfd;
    int nevents;
    ssize_t result;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    if ((epfd = epoll_create(1024)) == -1)
        exit_sys("epoll_create");

    ee.events = EPOLLIN;
    ee.data.fd = server_sock;

    if (epoll_ctl(epfd, EPOLL_CTL_ADD, server_sock, &ee) == -1)
        exit_sys("epoll_ctl");

    printf("listening port %d\n", server_port);

    for (;;) {
        printf("waiting for connection...\n");

        if ((nevents = epoll_wait(epfd, ree, MAX_EVENTS, -1)) == -1)
            exit_sys("epoll_wait");

        for (int i = 0; i < nevents; ++i) {
            if (ree[i].events & EPOLLIN) {
                if (ree[i].data.fd == server_sock) {
                    sin_len = sizeof(sin_client);
                    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
                        exit_sys("accept");

                    ee.events = EPOLLIN;
                    ee.data.fd = client_sock;
                    if (epoll_ctl(epfd, EPOLL_CTL_ADD, client_sock, &ee) == -1)
                        exit_sys("epoll_ctl");

                    inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                    printf("connected client ===> %s:%u\n", ntopbuf, (unsigned)ntohs(sin_client.sin_port));
                }
                else {
                    if ((result = recv(ree[i].data.fd, buf, BUFFER_SIZE, 0)) == -1)
                        exit_sys("recv");
                    buf[result] = '\0';

                    if (result > 0) {
                        sinaddr_len = sizeof(sin_client);
                        if (getpeername(ree[i].data.fd, (struct sockaddr *)&sin_client, &sinaddr_len) == -1)
                            exit_sys("getpeername");
                        inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                        printf("%jd byte(s) received from %s:%u: \"%s\"\n", (intmax_t)result, ntopbuf, (unsigned)ntohs(sin_client.sin_port), buf);
                        revstr(buf);
                        if (send(ree[i].data.fd, buf, result, 0) == -1)
                            exit_sys("send");
                    }
                    else {
                        shutdown(ree[i].data.fd, SHUT_RDWR);
                        close(ree[i].data.fd);

                        printf("client disconnected\n");
                    }
                }
            }
        }
    }

    close(server_sock);

    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    ssize_t result;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;

        buf[result]     = '\0';
        printf("%s\n", buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında bu tür client/server uygulamalarında epoll modelinin "kenar tetiklemeli (edge triggered)" modda kullanılmasının 
    daha iyi bir performans sağladığı belirtilmektedir. Kenar tetiklemeli modu kullanırken göz önüne alınması gereken önemli
    anahtar noktalar şunlardır:

    - Kenar tetiklemeli modda sokete bilgi geldiğinde gelen bilgilerin hepsinin okunmasına gayret edilmelidir. Çünkü eğer biz
    sokete bilgi geldiğinde onların hepsini okumazsak bir daha EPOLLIN olayı ancak yeni bir bilgi geldiğinde oluşacağından 
    gelmiş olan bilgilerin işleme sokulması gecikebilecektir. (Halbuki düzey tetiklemeli modda gelen bilgilerin hepsi okunmasa 
    bile bir sonraki epoll_wait çağrımında yine EPOLLIN olayı gerçekleşeceği için böyle bir durum söz konusu olmayacaktır.)

    - Betimleyiciyi kenar tetiklemeli modda izlemek için epoll_event yapısının events elemanına EPOLLET bayrağının eklenmesi 
    gerekmektedir.

    - Kenar tetiklemeli modda sokete gelen tüm bilgilerin okunması için betimleyicinin blokesiz modda olması gerekir. Aksi takdirde
    recv ya da read yaparken sokette bilgi kalmamışsa bloke oluşacaktır. Soket default olarak blokeli moddadır. Soketi daha 
    önce görmüş olduğumuz fcntl fonksiyonu ile aşağıdaki gibi blokesiz moda sokabiliriz:

    if (fcntl(sock, F_SETFL, fcntl(sock, F_GETFL) | O_NONBLOCK) == -1)
        exit_sys("fcntl");

    Blokesiz modda recv ya da read fonksiyonu ile başarısız olana kadar okuma da şöyle yapılabilir:

    for (;;) {
        if ((result = recv(...)) == -1)
            if (errno == EAGAIN)
                break;
            exit_sys("recv");
        }
        // ...
    }

    - Aslında epoll modelinde bazı soket betimleyicileri düzey tetiklemeli bazıları kenar tetiklemeli modda olabilir. Örneğin
    pasif soketi düzey tetiklemeli modda tutup diğerlerini kenar tetiklemeli modda tutabilirsiniz.

    Aşağıda daha önce yazmış olduğumuz client/server programın epoll modeli ile kenar tetiklemeli biçimi verilmiştir. Bu örnekte
    dinleme soketi düzey tetiklemeli modda bırakılmış ancak client soketler kenar tetiklemeli moda sokulmuştur. Soket üzerinde
    EPOLLIN olayı gerçekleştiğinde bir döngü içerisinde recv fonksiyonu EAGAIN nedeniyle başarısız olana kadar okuma yapılmıştır. 
    Tabii bu örnek aslında kenar tetiklemeli modele iyi bir örnek oluşturmamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/epoll.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096
#define MAX_EVENTS            1024

char *revstr(char *str);
void exit_sys(const char *msg);

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sinaddr_len;
    char buf[BUFFER_SIZE + 1];            /* BUFFER_SIZE is enough */
    socklen_t sin_len;
    char ntopbuf[INET_ADDRSTRLEN];
    int option;
    int server_port;
    struct epoll_event ee;
    struct epoll_event ree[MAX_EVENTS];
    int p_flag, err_flag;
    int epfd;
    int nevents;
    ssize_t result;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    if ((epfd = epoll_create(1024)) == -1)
        exit_sys("epoll_create");

    ee.events = EPOLLIN;
    ee.data.fd = server_sock;

    if (epoll_ctl(epfd, EPOLL_CTL_ADD, server_sock, &ee) == -1)
        exit_sys("epoll_ctl");

    printf("listening port %d\n", server_port);

    for (;;) {
        printf("waiting for connection...\n");

        if ((nevents = epoll_wait(epfd, ree, MAX_EVENTS, -1)) == -1)
            exit_sys("epoll_wait");

        for (int i = 0; i < nevents; ++i) {
            if (ree[i].events & EPOLLIN) {
                if (ree[i].data.fd == server_sock) {
                    sin_len = sizeof(sin_client);
                    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
                        exit_sys("accept");

                    if (fcntl(client_sock, F_SETFL, fcntl(client_sock, F_GETFL) | O_NONBLOCK) == -1)
                        exit_sys("fcntl");

                    ee.events = EPOLLIN|EPOLLET;
                    ee.data.fd = client_sock;
                    if (epoll_ctl(epfd, EPOLL_CTL_ADD, client_sock, &ee) == -1)
                        exit_sys("epoll_ctl");

                    inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                    printf("connected client ===> %s:%u\n", ntopbuf, (unsigned)ntohs(sin_client.sin_port));
                }
                else {
                    for (;;) {
                        if ((result = recv(ree[i].data.fd, buf, BUFFER_SIZE, 0)) == -1) {
                            if (errno == EAGAIN)
                                break;
                            exit_sys("recv");
                        }
                        buf[result] = '\0';

                        if (result > 0) {
                            sinaddr_len = sizeof(sin_client);
                            if (getpeername(ree[i].data.fd, (struct sockaddr *)&sin_client, &sinaddr_len) == -1)
                                exit_sys("getpeername");
                            inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                            printf("%jd byte(s) received from %s:%u: \"%s\"\n", (intmax_t)result, ntopbuf, (unsigned)ntohs(sin_client.sin_port), buf);
                            revstr(buf);
                            if (send(ree[i].data.fd, buf, result, 0) == -1)
                                exit_sys("send");
                        }
                        else {
                            shutdown(ree[i].data.fd, SHUT_RDWR);
                            close(ree[i].data.fd);

                            printf("client disconnected\n");
                            break;
                        }
                    }
                }
            }
        }
    }

    close(server_sock);

    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    ssize_t result;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;

        buf[result] = '\0';
        printf("%s\n", buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi asenkron IO için başı aio_ ile başlayan bir grup asenkron IO fonksiyonları da bulunuyordu. Bu fonksiyonlarla
    okuma yazma yapılırken işlemler başlatılıyor ancak akış bloke olmadan arka planda devam ettiriliyordu. Olayın bittiği de bize 
    bir sinyal ya da bir callback fonksiyonu yoluyla bildiriliyordu. Biz bu yöntemi daha önce incelemiş ve bununla ilgili bazı 
    örnekler yapmıştık. Şimdi de bu yöntemi soketlerde kullanacağız.

    Asenkron IO modelinin soketlerde kullanılmasına ilişkin anahtar noktalar şunlardır:

    - accept işleminin bu mekanizmaya dahil edilmesi gerekmemektedir. Yani akış accept işleminde bloke olabilir. Tabii istenirse 
    accept işlemi de bu mekanizmaya dahil edilebilir. Çünkü accept işlemi de bir okuma durumu oluşturmaktadır.

    - Bir okuma (ya da yazma) olayından sonra yeniden aynı mekanizmanın aio_read fonksiyonu çağrılarak kurulması gerekmektedir. 
    Yani aio_read bir kez değil, her defasında yeniden çağrılmalıdır.

    Aşağıda daha önce yapmış olduğumuz server programını bu kez asenkron IO fonksiyonlarıyla gerçekleştiriyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <aio.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096
#define MAX_EVENTS            1024

void io_proc(union sigval sval);
char *revstr(char *str);
void exit_sys(const char *msg);

typedef struct tagCLIENT_INFO {
    struct aiocb cb;
    char buf[BUFFER_SIZE + 1];        /* BUFFER_SIZE is enough */
    char ntopbuf[INET_ADDRSTRLEN];
    unsigned port;
} CLIENT_INFO;

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;
    int option;
    int server_port;
    CLIENT_INFO *ci;
    int p_flag, err_flag;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("listening port %d\n", server_port);

    for (;;) {
        printf("waiting for connection...\n");

        sin_len = sizeof(sin_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
            exit_sys("accept");

        if ((ci = (CLIENT_INFO *)calloc(1, sizeof(CLIENT_INFO))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }

        inet_ntop(AF_INET, &sin_client.sin_addr, ci->ntopbuf, INET_ADDRSTRLEN);
        ci->port = ntohs(sin_client.sin_port);

        printf("connected client ===> %s:%u\n", ci->ntopbuf, ci->port);

        ci->cb.aio_fildes = client_sock;
        ci->cb.aio_offset = 0;
        ci->cb.aio_buf = ci->buf;
        ci->cb.aio_nbytes = BUFFER_SIZE;
        ci->cb.aio_reqprio = 0;
        ci->cb.aio_sigevent.sigev_notify = SIGEV_THREAD;
        ci->cb.aio_sigevent.sigev_value.sival_ptr = ci;
        ci->cb.aio_sigevent.sigev_notify_function = io_proc;
        ci->cb.aio_sigevent.sigev_notify_attributes = NULL;

        if (aio_read(&ci->cb) == -1)
            exit_sys("aio_read");
    }

    close(server_sock);

    return 0;
}

void io_proc(union sigval sval)
{
    CLIENT_INFO *ci = (CLIENT_INFO *)sval.sival_ptr;
    ssize_t result;

    if ((result = aio_return(&ci->cb)) == -1)
        exit_sys("aio_return");

    ci->buf[result] = '\0';

    if (result > 0) {
        printf("%jd byte(s) received from %s:%u: \"%s\"\n", (intmax_t)result, ci->ntopbuf, (ci->port), ci->buf);
        revstr(ci->buf);
        if (send(ci->cb.aio_fildes, ci->buf, result, 0) == -1)
            exit_sys("send");

        if (aio_read(&ci->cb) == -1)
            exit_sys("aio_read");
    }
    else {
        shutdown(ci->cb.aio_fildes, SHUT_RDWR);
        close(ci->cb.aio_fildes);

        printf("client disconnected ===> %s:%u\n", ci->ntopbuf, (ci->port));
        free(ci);
    }
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    ssize_t result;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;
        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;

        buf[result] = '\0';
        printf("%s\n", buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                105. Ders 10/12/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bu noktada dikkatimizi UDP protokolü üzerine yönelteceğiz. UDP protokolünü ele aldıktan sonra yine TCP protokolü ile ilgili
    bazı ayrıntılar üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Giriş kısmında da belirttiğimiz gibi UDP (User Datagram Protocol) bağlantılı olmayan bir protokoldür. Dolayısıyla bir 
    taraf bir tarafa hiç bağlanmadan onun IP adresini ve port numarasını bilerek UDP paketlerini gönderebilir. Gönderen taraf 
    alan tarafın paketi alıp almadığını bilmez. Yani UDP protokolünde bir akış kontrolü yoktur. Dolayısıyla alan taraf bilgi 
    kaçırabilir. Protokol kaçırılan bilgilerin telafisini kendisi yapmamaktadır. Halbuki TCP protokolünde bir bağlantı oluşturulduğu 
    için bir akış kontrolü uygulanarak karşı tarafa ulaşmamış TCP paketlerinin yeniden gönderilmesi sağlanmaktadır.

    UDP tabii ki TCP'ye göre daha hızlıdır. Zaten TCP bir bakıma UDP'nin organize edilmiş bağlantılı biçimidir. Pekiyi UDP protokolü 
    ile ağ katmanı protokolü olan IP protokolü arasındaki fark nedir? Her iki protokolde aslında paketlerin iletimini yapmaktadır. 
    Aslında UDP protokolünün gerçekten de IP protokolünden çok farkı yoktur. Ancak UDP bir aktarım (transport) katmanı protokolü olduğu 
    için port numarası içermektedir. Halbuki IP protokolünde port numarası kavramı yoktur. Yani IP protokolünde biz bir host'a paket 
    gönderebiliriz. Onun belli bir portuna paket gönderemeyiz. Bunun dışında UDP ile IP protokollerinin kullanımları konusunda yine 
    bazı farklılıklar vardır. Aslında biz programcı olarak doğrudan IP paketleri de gönderebiliriz. Buna "raw socket" kullanımı 
    denilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP'de accept uygulayan tarafa "server", connect uygulayana tarafa "client" denilmektedir. Ancak UDP bağlantısız bir protokol
    olduğu için "client" ve "server" kavramları bu protokolde tam oturmamaktadır. Ancak yine de genellikle hizmet alan tarafa
    "client", hizmet veren tarafa "server" denilmektedir. UDP'de client daha çok gönderim yapan, server ise okuma yapan taraftır.

    UDP özellikle periyodik kısa bilgilerin gönderildiği ve alındığı durumlarda hız nedeniyle tercih edilmektedir. UDP haberleşmesinde 
    bilgiyi alan tarafın (server) bilgi kaçırabilmesi söz konusu olabileceğinden dolayı böyle kaçırmalarda sistemde önemli bir
    aksamanın olmaması gerekir. Eğer bilgi kaçırma durumlarında sistemde önemli aksamalar oluşabiliyorsa UDP yerine TCP tercih 
    edilmelidir. Örneğin bir televizyon yayınında görüntüye ilişkin bir frame karşı taraf tarafından alınmadığında önemli bir 
    aksama söz konusu değildir. Belki görüntüde bir kasis olabilir ancak bu durum önemli kabul edilmemektedir. Örneğin birtakım 
    makineler belli periyotlarda server'a "ben çalışıyorum" demek için periyodik UDP paketleri yollayabilir. Server da hangi 
    makinenin çalışmakta olduğunu (bozulmamış olduğunu) bu sayede anlayabilir. Örneğin bir araba simülatörü arabanın durumunu 
    UDP paketleriyle dış dünyaya verebilir. Bir UDP paketi 64K gibi bir sınıra sahiptir.

    TCP ve UDP protokollerinde bir uzunluk bilgisi yoktur. Uzunluk bilgisi IP protokolünde bulunmaktadır. IPv4 ve IPv6 
    protokollerinde bir IP paketi en fazla 64K uzunlukta olabilmektedir. Tabii TCP stream tabanlı olduğu için bu 64K uzunluğun 
    TCP için bir önemi yoktur. Ancak UDP paket tabanlı olduğu için bir UDP paketi IP paketinin uzunluğunu aşamaz. Dolayısıyla bir 
    UDP paketi en fazla 64K uzunlukta olabilmektedir. Büyük paketlerin UDP ile gönderilmesi için programcının paketlere kendisinin 
    manuel numaralar vermesi gerekebilir. Zaten TCP protokolü bu şekilde bir numaralandırmayı kendi içerisinde yapmaktadır. UDP 
    haberleşmesinin önemli bir farkı da "broadcasting" işlemidir. Broadcasting, yerel ağda belli bir host'un tüm host'lara UDP 
    paketleri gönderebilmesine denilmektedir. TCP'de böyle bir broadcasting mekanizması yoktur.

    UDP header'ı 8 byte'tan oluşmaktadır ve yapısı aşağıdaki gibidir.

    <------- Byte 1 -------><------- Byte 2 -------><------- Byte 3 -------><------- Byte 4 ------->
    +----------------------------------------------+-----------------------------------------------+             ^
    |                  Source Port                 |                Destination Port               |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             |  8 bytes
    |                 Header Length                |                   Checksum                    |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             v
    |                                    Application Layer Data                                    |
    |                                         (Size Varies)                                        |
    +----------------------------------------------------------------------------------------------+

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UDP server programı tipik olarak şu adımlardan geçilerek oluşturulur:

    1) Server SOCK_DGRAM parametresiyle bir socket yaratır.

    2) Soketi bind fonksiyonuyla bağlar.

    3) recvfrom fonksiyonuyla gelen paketleri alır ve sendto fonksiyonuyla UDP paketi gönderir.

    4) Haberleşme bitince server soketi close fonksiyonuyla ile kapatır.

    Haberleşme bittiğinde shutdown gibi bir işlemin gerekmediğine dikkat ediniz. shutdown işlemi TCP'de bağlantıyı koparmak için
    kullanılmaktadır. Halbuki UDP protokolünde zaten bağlantı yoktur. Yukarıdaki adımları fonksiyon temelinde aşağıdaki gibi 
    de özetleyebiliriz:

    socket (SOCK_DGRAM) ---> bind ---> recfrom/sendto ---> close
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UDP client program da şu adımlardan geçilerek oluşturulur:

    1) Client soketi SOCK_DGRAM parametresiyle yaratır.

    2) Client isteğe bağlı olarak soketi bind fonksiyonuyla bağlayabilir.

    3) Client, server'ın host isminden hareketle server'ın IP adresini gethostbyname ya da getaddrinfo fonksiyonuyla elde edebilir.

    4) Client sendto fonksiyonuyla UDP paketlerini gönderir ve recvfrom fonksiyonuyla UDP paketlerini alabilir.

    5) Haberleşme bitince client close fonksiyonuyla soketi kapatır.

    Bu adımları fonksiyon isimleriyle şöyle özetleyebiliriz:

    socket (SOCK_DGRAM) ---> bind (isteğe bağlı) ---> gethostbyname/getaddrinfo (isteğe bağlı) ---> sendto/recvfrom ---> close
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UDP paketlerini okumak için kullanılan recvfrom prototipi şöyledir:

    #include <sys/socket.h>

    ssize_t recvfrom(int socket, void *buffer, size_t length, int flags, struct sockaddr *address, socklen_t *address_len);

    Fonksiyonun birinci parametresi okuma işleminin yapılacağı soketi belirtir. İkinci parametre alınacak bilginin yerleştirileceği 
    adresi belirtmektedir. Üçüncü parametre ikinci parametredeki alanın uzunluğunu belirtir. Eğer buradaki değer UDP paketindeki 
    gönderilmiş olan byte sayısından daha az ise kırpılarak diziye yerleştirme yapılmaktadır. Fonksiyonun üçüncü parametresi (flags) 
    birkaç seçeneğe sahiptir. Bu parametre için 0 girilebilir. Fonksiyonun dördüncü parametresi UDP paketini gönderen tarafın IP 
    adresinin ve port numarasının yerleştirileceği sockaddr_in yapısının adresini alır. Son parametre ise bu yapının uzunluğunu tutan 
    int nesnenin adresini almaktadır. Fonksiyon başarı durumunda UDP paketindeki byte sayısına, başarısızlık durumunda -1 değerine 
    geri dönmektedir.

    recvfrom fonksiyonunun herhangi bir client'tan gelen paketi alabildiğine dikkat ediniz. Dolayısıyla her recvfrom ile alınan paket 
    farklı bir client'a ilişkin olabilmektedir.

    recvfrom fonksiyonu, eğer soket blokeli moddaysa (default durum) UDP paketi gelene kadar blokeye yol açar. Blokesiz modda fonksiyon
    bekleme yapmaz, -1 değeriyle geri döner ve errno EAGAIN değeriyle set edilir.

    sendto fonksiyonunun prototipi de şöyledir:

    #include <sys/socket.h>

    ssize_t sendto(int socket, const void *message, size_t length, int flags, const struct sockaddr *dest_addr, socklen_t dest_len);

    Fonksiyonun parametreleri recvfrom da olduğu gibidir. Yani birinci parametre gönderim yapılacak soketi belirtir. İkinci 
    ve üçüncü parametreler gönderilecek bilgilerin bulunduğu tamponu ve onun uzunluğunu belirtmektedir. Yine bu fonksiyonda 
    da bir flags parametresi vardır. Dördüncü parametre bilginin gönderileceği IP adresini ve port numarasını belirtir. Son 
    parametre ise dördüncü parametredeki yapının (sockaddr_in ya da sockaddr_in6) uzunluğunu alır.

    Fonksiyon blokeli modda paket network tamponuna yazılana kadar blokeye yol açmaktadır. sendto fonksiyonu da başarı durumunda 
    network tamponuna yazılan byte sayısına, başarısızlık durumunda -1'e geri dönmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda tipik bir UDP client-server örneği verilmiştir. Bu örnekte client yine bir prompt'a düşerek kullanıcıdan bir 
    yazı istemektedir. Bu yazıyı UDP paketi biçiminde server'a yollamaktadır. Server da bu yazıyı alıp görüntüledikten sonra 
    yazıyı ters çevirip client'a geri yollamaktadır. Programların komut satırı argümanları diğer örneklerde olduğu gibidir.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <getopt.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096

char *revstr(char *str);
void exit_sys(const char *msg);

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;
    int server_port;
    char buf[BUFFER_SIZE + 1];
    char ntopbuf[INET_ADDRSTRLEN];
    ssize_t result;
    int option;
    int p_flag, err_flag;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
            exit_sys("bind");

    printf("waiting UDP packet...\n");
    for (;;) {
        sin_len = sizeof(sin_client);
        if ((result = recvfrom(server_sock, buf, BUFFER_SIZE, 0, (struct sockaddr *)&sin_client, &sin_len)) == -1)
            exit_sys("recvfrom");
        buf[result] = '\0';

        inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
        printf("%jd byte(s) received from %s:%u: \"%s\"\n", (intmax_t)result, ntopbuf, (unsigned)ntohs(sin_client.sin_port), buf);

        revstr(buf);

        if (sendto(server_sock, buf, result, 0, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("sendto");
    }

    close(server_sock);

    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>

#define DEF_SERVER_NAME        "localhost"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client, sin_server;
    socklen_t sin_len;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res;
    int gai_result;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    char buf[BUFFER_SIZE + 1];        /* BUFFER_SIZE is enough */
    char ntopbuf[INET_ADDRSTRLEN];
    ssize_t result;
    char *str;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    freeaddrinfo(res);

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        if (!strcmp(buf, "quit"))
            break;

        if (sendto(client_sock, buf, strlen(buf), 0, res->ai_addr, sizeof(struct sockaddr_in)) == -1)
            exit_sys("send");

        sin_len = sizeof(sin_server);
        if ((result = recvfrom(client_sock, buf, BUFFER_SIZE, 0, (struct sockaddr *)&sin_server, &sin_len)) == -1)
            exit_sys("recvfrom");
        buf[result] = '\0';

        inet_ntop(AF_INET, &sin_server.sin_addr, ntopbuf, INET_ADDRSTRLEN);
        printf("%jd byte(s) received from server %s:%u: \"%s\"\n", (intmax_t)result, ntopbuf, (unsigned)ntohs(sin_server.sin_port), buf);
    }

    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                106. Ders 16/12/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP/IP ya da UDP/IP server uygulamalarında server'ın bir client'tan gelen isteği yerine getirmesi bir zaman kaybı 
    oluşturabilmektedir. Server bir client ile uğraşırken diğer client'ların istekleri mecburen bekletilir. İşte bu durumu 
    en aza indirmek için select, poll (ve epoll) modellerinde server bir client'ın isteğini bir thread ile yerine getirebilir. 
    Böylece server birden fazla client'a aynı anda hizmet verebilecektir. Örneğin select modelinde bu işlem şöyle yapılabilir:

    for (;;) {
        select(...);
        if (<belli bir sokete bilgi geldi>) {
            <thread oluştur ve işlemi thread'e devret>
        }
    }

    Benzer biçimde UDP server uygulamasında da işlem şöyle yapılabilir:

    for (;;) {
        recvfrom(...)
        <thread oluştur ve işlemi thread'e devret>
    }

    Tabii burada küçük bir işlem için yeni bir thread'in yaratılıp yok edilmesi etkin bir yöntem değildir. Çünkü bilindiği gibi
    thread'lerin yaratılıp yok edilmeleri de dikkate değer bir zaman kaybı oluşturmaktadır. Thread'ler konusunda da belirttiğimiz 
    gibi bu tür durumlarda "thread havuzları (thread pools)" kullanılabilir. Thread havuzlarında zaten belli bir miktar thread 
    yaratılmış ve bekler durumda (suspend durumda) tutulmaktadır. Böylece client'tan gelen isteğin bu thread'lerden biri tarafından 
    gerçekleştirilmesi sağlanır. POSIX sistemlerinde C'de kullanılabilecek standart bir thread havuzu mekanizmasının olmadığını
    anımsayınız. Bu nedenle böyle bir thread havuzunu programcının kendisi yazabilir ya da C için yazılmış olan bir thread havuzu
    kütüphanesini kullanabilir. Windows sistemlerinde işletim sistemi düzeyinde thread havuzlarına ilişkin standart API fonksiyonları 
    bulunmaktadır. C++'ta pek çok framework içerisinde (MFC gibi, Qt gibi) zaten thread havuzları sınıfsal biçimde bulunmaktadır.

    Pekiyi yoğun bir server düşünelim. Makinemizde de bir tane işlemci bulunuyor olsun. Böyle bir thread havuzunun kullanılması
    gerçek anlamda bir fayda sağlayabilir mi? Örneğin 5 tane client'ın isteğini thread yoluyla sağlamaya çalışalım. Her client'ın 
    isteği için 3 quanta süresi gerekiyor olsun. İşlemler seri yapıldığında toplam 15 quanta zamanında tüm client'ların mesajları 
    işlenmiş olacaktır. Thread'ler kullanıldığında işlemcinin çalışma kuyruğunda (run queue) 5 thread bulunacak ve bunlar 
    zaman paylaşımlı biçimde çalışacaktır. Dolayısıyla yine bu client'ların hepsinin işlerini bitirmesi için 15 quanta süresi 
    gerekecektir. Tabii sistemde başka proseslerin thread'leri de varsa çok thread'li çalışma toplamda bu server'ın diğer 
    proseslere göre daha fazla işlemci zamanı kullanmasına yol açacaktır.

    Ancak makinemizde birden fazla işlemci varsa bu durumda yukarıdaki thread sistemi belirgin bir avantaj sağlayacaktır. 
    Bu tür durumlarda işlemci sayısı kadar thread'in aynı anda çalışması sağlanabilir. Bu thread'ler farklı işlemcilerde
    eş zamanlı bir biçimde çalışabileceği için ciddi bir hızlanma sağlanacaktır. Tabii buradaki thread'lerin aynı anda 
    farklı işlemciler tarafından çalıştırılması gerekir. İşletim sistemleri genellikle bu ayarlamayı kendi içlerinde yapabilmektedir. 
    Örneğin Linux sistemlerinde kullanılan güncel çizelgeleme algoritmasında her işlemci için ayrı bir çalışma kuyruğu oluşturulmakta
    ve thread'ler bunlara dinamik bir biçimde dağıtılmaktadır. Ancak yine de bazı durumlarda thread'lerin belli işlemcilere
    programcı tarafından atanması (processor affinity) gerekebilmektedir.

    Örneğin makinemizde 8 işlemci ya da çekirdek olsun. Bu durumda biz 8 tane thread yaratıp bu 8 thread'in farklı işlemcilerde 
    eş zamanlı olarak kendi içlerinde seri bir biçimde çalışmasını sağlayabiliriz. Bunun sağlanması iki biçimde yapılabilir. 
    Birincisi her thread için yukarıdaki döngü yeniden oluşturulabilir. Örneğin:

    // 1'inci thread

    for (;;) {
        recvfrom(...)
        <mesajı işle>
    }

    // 2'nci thread

    for (;;) {
        recvfrom(...)
        <mesajı işle>
    }
    ...

    Soket fonksiyonları bu bağlamda thread güvenlidir. İkinci yöntemde server aldığı mesajları bir kuyruğa yazar. Thread'ler de 
    aynı kuyruktan mesajları alarak işleme sokar. Örneğin:

    for (;;) {
        recvfrom(...)
        <mesajı kuyruğa yerleştir>
    }
    ...

    // 1'inci thread

    for (;;) {
        <kuyruktan mesajı al işle>
    }

    // 2'nci thread

    for (;;) {
        <kuyruktan mesajı al işle>
    }
    ...

    Bu tür durumlarda işlemci ya da çekirdek sayısından daha fazla thread'in oluşturulması özel durumlar dışında önemli bir 
    fayda sağlamamaktadır.

    Linux'un epoll modelinde thread'li kullanımda Linux genel olarak her işlemci ya da çekirdek için gerektiğinde kendisi 
    thread oluşturmaktadır. Dolayısıyla epoll modeli yukarıdaki gibi bir organizasyon yapılmasa da daha iyi bir performans 
    göstermektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi client istekleri için çok işlemcili ya da çok çekirdekli bir bilgisayar yetmiyorsa ne olacak? Bu tür durumlarda 
    işleri birden fazla server makineye dağıtmak gerekir. Client'ın birden çok server olduğunu fark etmemesi dolayısıyla bu 
    sürecin tamamen server tarafta otomatik hale getirilmesi uygun olur. Aynı makinenin klonundan çıkartılıp sisteme eklendiğinde
    yükü paylaşabilmesi sağlanmalıdır. Böylece "ölçeklenebilir (scalable)" bir sistem söz konusu olacaktır. Pekiyi yük bu server
    makinelere nasıl dağıtılabilir? İşte bunun için kullanılan mekanizmaya "load balancing", bu mekanizmayı sağlayan birime de
    "load balancer" denilmektedir.

    Server Makine        Server Makine        Server Makine        Server Makine        ...

                                Load Balancer

    Bu tür dağıtık sistemlerde client aslında "load balancer" ile bağlantı sağlar. Load balancer, client'ı en az meşgul olan 
    server'a iletir. Bugün kullanılan cloud sistemler de kendi içlerinde load balancer benzeri mekanizmalar içermektedir. 
    Load Balancer'lar tamamen donanımsal olarak ya da tamamen yazılımsal olarak gerçekleştirilebilmektedir. Yazılımsal gerçekleştirim
    daha esnek olabilmektedir. Ancak donanımsal gerçekleştirimler bazı durumlarda daha etkin olabilmektedir.

    Donanımsal load balancer'larda client, server ile bağlantı kurmak istediğinde load balancer devreye girip sanki yalnızca 
    en az meşgul olan server sistemde varmış gibi bağlantıyı onun kabul etmesini sağlamaktadır. Yazılımsal load balancer'larda
    load balancer bir "proxy" gibi çalışmaktadır. Client load balancer ile bağlantı sağlar. Load balancer bunu en az meşgul server'a
    yönlendirir. Bu kez client bu server ile bağlantı kurar. Buradaki load balancer görevini yapan "proxy" programınının server
    yüklerini sürekli izlemesi gerekmektedir. Bunun için genellikle UDP protokolü kullanılmaktadır. Yani UDP ile server makineler
    sürekli bir biçimde kendi durumlarını proxy'ye iletirler. Proxy'de bu bilgilerden hareketle en az meşgul server'ı tespit 
    eder. Tabii server makineler eğer devre dışı kalırsa proxy'inin bunu fark etmesi ve artık ona yönlendirme yapmaması gerekir.
    Benzer biçimde yeni bir server makinesi sisteme eklendiğinde proxy hemen onu da sisteme otomatik olarak dahil etmelidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de TCP/IP ve UDP/IP protokollerinin ve bunun için kullanılan soket fonksiyonlarının ayrıntıları üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP için kullandığımız recv ve send fonksiyonlarının, read ve write fonksiyonlarından tek farkı flags parametresidir. 
    Biz yukarıdaki örneklerde bu parametreyi 0 geçtik. Dolayısıyla yukarıdaki örneklerde kullandığımız recv ve send fonksiyonlarının, 
    read ve write fonksiyonlarından hiçbir farkı yoktur. Pekiyi bu flag değerleri neler olabilir? İşte POSIX standartlarında 
    recv fonksiyonundaki flag değerleri şunlardan biri ya da birden fazlası olabilir:

    MSG_PEEK: Bu bayrak gelen bilginin tampondan okunacağını ancak tampondan atılmayacağını belirtmektedir. Yani biz MSG_PEEK 
    flag değeri ile okuma yaparsak hem bilgiyi elde ederiz hem de sanki hiç okuma yapmamışız gibi bilgi network tamponunda kalır. 
    Dolayısıyla bizim thread'imiz ya da başka bir thread recv yaparsa tampondakini okuyacaktır. Pekiyi bu bayrak hangi amaçla
    kullanılmaktadır. Bazen (çok seyrek olarak) mesajın ne olduğuna MSG_PEEK ile bakıp duruma göre onu kuyruktan almak isteyebiliriz. 
    Eğer mesaj bizim beğenmediğimiz bir mesajsa onu almak istemeyebiliriz. Onun başka bir thread tarafından işlenmesini sağlayabiliriz.

    MSG_OOB: Out-of-band data (urgent data) denilen okumalar için kullanılmaktadır. Out-of-band data konusu ayrı bir paragrafta 
    açıklanacaktır.

    MSG_WAITALL: Bu bayrak n byte okunmak istendiğinde bu n byte'ın hepsi okunana kadar bekleme sağlamaktadır. Fakat bu durumda bir 
    sinyal geldiğinde yine recv -1 ile geri döner ve errno EINTR ile set edilir. Yine soket kapatıldığında ya da soket üzerinde 
    bir hata oluştuğunda fonksiyon talep edilen kadar bilgiyi okuyamamış olabilir. Biz daha önce n byte okuma yapmak için aşağıdaki 
    gibi bir fonksiyon önermiştik:

    ssize_t read_socket(int sock, char *buf, size_t len)
    {
        size_t left, index;

        left = len;
        index = 0;

        while (left > 0) {
            if ((result = recv(sock, buf + index, left, 0)) == -1)
                return -1;
            if (result == 0)
                break;
            index += result;
            left -= result;
        }

        return (ssize_t) index;
    }

    İşte aslında recv fonksiyonundaki MSG_WAITALL bayrağı adeta bunu sağlamaktadır. Ancak yine de bu bayrağın bazı sistemlerde 
    bazı problemleri vardır. Örneğin Windows sistemlerinde ve Linux sistemlerinde bu bayrakla okunmak istenen miktar network alım 
    tamponunun büyüklüğünden fazlaysa istenen miktarda byte okunamayabilmektedir. Ancak bu bayrak yüksek olmayan miktarlarda okumalar 
    için yukarıdaki fonksiyonun yerine kullanılabilmektedir.

    send fonksiyonundaki POSIX bayrakları da şunlardır:

    MSG_EOR: Soket türü SOCK_SEQPACKET ise kaydı sonlandırmakta kullanılır.

    MSG_OOB: Out-of-band data gönderimi için kullanılmaktadır. Bu konu ayrı bir paragrafta ele alınacaktır.

    MSG_NOSIGNAL: Normal olarak send ya da write işlemi yapılırken karşı taraf soketi kapatmışsa bu fonksiyonların çağrıldığı 
    tarafta SIGPIPE sinyali oluşmaktadır. Ancak bu bayrak kullanılırsa böylesi durumlarda SIGPIPE sinyali oluşmaz, send 
    ya da write fonksiyonu -1 ile geri döner ve errno EPIPE değeri ile set edilir.

    Linux, POSIX'in bayraklarından daha fazlasını bulundurmaktadır. Örneğin recv ve send işleminde MSG_DONTWAIT bir çağrımlık 
    "non-blocking" etki yaratmaktadır. Yani recv sırasında network tamponunda hiç bilgi yoksa recv bloke olmaz, -1 ile geri 
    döner ve errno EAGAIN değeri ile set edilir. send işlemi sırasında da network tamponu dolu ise send bloke olmaz -1 ile geri 
    döner ve errno yine EAGAIN değeri ile set edilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Normal olarak connect/accept işlemi TCP'de kullanılmaktadır. Ancak UDP soketlerde de seyrek biçimde connect/accept 
    kullanılabilir. Eğer UDP bir soket connect ile UDP server'a bağlanırsa (server da bunu accept ile kabul etmelidir) bu durumda
    artık iki taraf recvfrom ve sendto fonksiyonlarının yerine recv ve send fonksiyonlarını kullanabilir. Tabii burada yine 
    datagram haberleşmesi yapılmaktadır. Yalnızca her defasında gönderme ve alma işlemlerinde karşı tarafın soketine ilişkin 
    bilgilerin belirtilmesine gerek kalmamaktadır. Bu biçimdeki connect/accept bağlantısında yine bir akış kontrolü uygulanmamaktadır.

    Aslında recv fonksiyonu yerine recvfrom fonksiyonu da kullanılabilir. Yani recvfrom fonksiyonunun son iki parametresi NULL
    geçilirse zaten bu işlem recv ile eşdeğer olmaktadır. Örneğin aşağıdaki iki çağrı eşdeğerdir:

    result = recv(sock, buf, len, flags);
    result = recvfrom(sock, buf, len, flags, NULL, NULL);

    Benzer biçimde send yerine sendto fonksiyonu da kullanılabilir. Bu durumda sendto fonksiyonunun son iki parametresi 
    ihmal edilir. Örneğin aşağıdaki iki çağrı eşdeğerdir:

    result = send(sock, buf, len, flags);
    result = sendto(sock, buf, len, flags, any_value, any_value);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar client ile server programlar arasında ciddi bir mesaj alışverişi yapmadık. Verdiğimiz örneklerde client
    program, server programa bir yazı iletiyordu. Server program da client'a bu yazıyı ters çevirip gönderiyordu. Bu çok basit 
    bir mesajlaşma işlemidir. Halbuki gerçek client-server uygulamalarında mesajlaşmalar çok daha çeşitli ve ayrıntılıdır. 
    Gerçek uygulamalarda client program, server programdan çok çeşitli şeyleri yapmasını isteyebilir. Server'da client'ın isteğine
    uygun bir biçimde yanıtları iletir. Örneğin dört işlem yapan bir server program olsun. Client iki operand'ı server'a gönderip 
    ondan dört işlemden birini yapmasını istesin. Bu durumda client'ın server'a gönderdiği mesajlar fazlalaşmaktadır. Örneğin:

    ADD op1 op2
    SUB op1 op2
    MUL op1 op2
    DIV op1 op2

    Bir chat programında client server'dan pek çok şey isteyebilir. Server da client'a çok çeşitli bilgiler iletebilir. Yani bu 
    tür uygulamalarda mesajın bir içeriği ve parametreleri vardır.

    Pekiyi mesajlar karşı tarafa hangi formatta iletilecektir? İşte bunun için binary ve text olmak üzere iki mesajlaşma 
    tekniği kullanılmaktadır.

    Binary mesajlaşmada kabaca her iki taraf birbirlerine bir yapı nesnesinin içeriğini binary biçimde gönderir. Karşı taraf 
    da bu yapı nesnesini alarak işlemini yapar. Ancak farklı mesajlarda farklı yapılar kullanılacağı için mesajın başında mesajın 
    türünü ve uzunluğunu belirten ortak bir başlık kısmı bulundurulur. Bunun için tipik olarak şöyle bir yol izlenir: Mesajı 
    gönderecek taraf önce mesajın uzunluğunu sonra da mesajın ne mesajı olduğunu belirten mesaj kodunu (numarasını) sonra da 
    mesajın içeriğini karşı tarafa yollar. Bu işlemi "pseudo code" olarak aşağıdaki gibi ifade edebiliriz:

    typedef struct tagMSG_HEADER {
        int len;
        int type;
    } MSG_HEADER;

    typedef struct tagMSG_XXX {
        // message info
    } MSG_XXX;

    typedef struct tagMSG_YYY {
        // message info
    } MSG_YYY;

    Örneğin MSG_XXX mesajı karşı tarafa gönderilecek olsun:

    MSG_HEADER header;
    MSG_XXX msg_xxx;

    header.len = sizeof(MSG_XXX);
    header.type = MSG_TYPE_XXX;
    send(sock, &header, sizeof(MSG_HEADER), 0);

    <msg_xxx'in içi dolduruluyor>

    send(sock, &msg_xxx, sizeof(MSG_XXX), 0);

    Mesajı alan taraf da önce mesajın uzunluğunu ve kodunu elde eder, sonra da türünü elde eder ve soketten o uzunlukta okuma 
    yapar. Örneğin:

    MSG_HEADER header;
    MSG_XXX msg_xxx;
    ...

    recv(sock, &header, sizeof(MSG_HEADER), MSG_WAITALL);

    switch (header.type) {
        case MSG_TYPE_XXX:
            recv(sock, &msg_xxx, sizeof(header.len), MSG_WAITALL);
            process_msg_xxx(&msg_xxx);
            break;
        ...
    }

    Burada aklınıza şöyle bir soru gelebilir: Okuyan taraf zaten mesajın kodunu (numarasını) elde edince o mesajın kaç byte 
    uzunlukta olduğunu bilmeyecek mi? Bu durumda mesajın uzunluğunun karşı tarafa iletilmesine ne gerek var? İşte mesajlar 
    sabit uzunlukta olmayabilir. Örneğin mesajın içerisinde bir metin bulunabilir. Bu durumda mesajın gerçek uzunluğu bu metnin
    uzunluğuna bağlı olarak değişebilir. Genel bir çözüm için mesajın uzunluğunun da karşı tarafa iletilmesi gerekmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                107. Ders 17/12/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki gibi binary tabanlı mesajlaşma daha hızlı ve etkin olma eğiliminde ise de pratikte daha çok text tabanlı mesajlaşmalar
    kullanılmaktadır. Çünkü text tabanlı mesajlaşmalar insanlar tarafından yazısal biçimde de oluşturulabilmektedir. IP protokol 
    ailesinin uygulama katmanındaki POP3, Telnet, FTP gibi protokolleri text tabanlı mesajlaşmayı kullanmaktadır.

    Text tabanlı mesajlaşmada client'tan server'a ve server'dan client'a gönderilen mesajlar bir yazı olarak gönderilir. 
    Karşı taraf bu yazıyı alır, parse eder ve gereğini yapar. Programlama dillerinde yazılarla işlem yapabilen pek çok 
    standart araç bulunduğu için bu biçimde mesajların işlenmesi genel olarak daha kolaydır. Ancak mesaj tabanlı haberleşme 
    genel olarak daha yavaştır. Çünkü birtakım bilgilerin yazısal olarak ifade edilmesi binary ifade edilmesinden genel 
    olarak daha fazla yer kaplama eğilimindedir.

    Text tabanlı mesajlaşmada önemli bir sorun mesajın nerede bittiğinin tespit edilmesidir. Bunun için mesajın sonu özel 
    bir karakterle sonlandırılabilir. Örneğin IP protokol ailesinin uygulama katmanındaki protokoller genel olarak mesajları 
    CR/LF ('\r' ve '\n') çiftiyle bitirmektedir. Örneğin:

    "ADD op1 op2\r\n"
    "SUB op1 op2\r\n"
    "MUL op1 op2\r\n"
    "DIV op1 op2\r\n"

    Tabii bu biçimdeki mesajlaşmalarda soketten CR/LF çifti görülene kadar okuma yapılması gerekir. Bu işlem soketten byte 
    byte okuma ile yapılmamalıdır. Çünkü her byte okuması için prosesin kernel mode'a geçmesi zaman kaybı oluşturmaktadır. 
    Belli bir karakter ya da karakter kümesi görülene kadar soketten okuma işleminin nasıl yapılması gerektiği izleyen 
    paragraflarda açıklanacaktır.

    Yazının sonunun tespit edilmesi için kullanılabilecek diğer bir yöntem de baştan yazının uzunluğunun iletilmesi olabilir. 
    Örneğin:

    "ADD op1 op2"

    Yukarıdaki mesaj için önce bu yazının uzunluğu karşı tarafa iletilebilir. Sonra yazı gönderilir. Okuyan taraf da yazının 
    hepsini belirtilen uzunlukta okuma yaparak elde edebilir.

    Yazının sonuna belli bir karakter yerleştirerek o karakteri görene kadar etkin okuma yapmak için şöyle bir teknik kullanılmaktadır:
    Karakterler soketten tek tek okunmaz. Blok blok okunarak bir tampona yerleştirilir. Sonra bu tampondan karakterler elde edilir. 
    Tabii blok okuması yapıldığında birden fazla satır tamponda bulunabilecektir. Bu durumda okuma sırasında tamponda nerede 
    kalındığının da tutulması gerekir. Bu işlemi yapan klasik bir algoritma "Effective TCP/IP Programming" kitabında verilmiştir. 
    Aşağıda bu biçimde CR/LF çifti görülene kadar soketten etkin bir biçimde yukarıda belirttiğimiz gibi okuma yapan bir fonksiyon 
    örneği veriyoruz:

    ssize_t sock_readline(int sock, char *str, size_t size)
    {
        char *bstr = str;
        static char *bp;
        static ssize_t count = 0;
        static char buf[2048];

        if (size <= 2) {
            errno = EINVAL;
            return -1;
        }

        while (--size > 0) {
            if (--count <= 0) {
                if ((count = recv(sock, buf, sizeof(buf), 0)) == -1)
                    return -1;
                if (count == 0)
                    return 0;
                bp = buf;
            }
            *str++ = *bp++;
            if (str[-1] == '\n')
                if (str - bstr > 1 && str[-2] == '\r') {
                    *str = '\0';
                    break;
                }
        }

        return (ssize_t) (str - bstr);
    }

    Fonksiyonun birinci parametresi okuma yapılacak soketi, ikinci ve üçüncü parametreleri okunacak satırın yerleştirileceği 
    dizinin adresini ve uzunluğunu almaktadır. Buradaki dizinin sonunda her zaman CR/LF ve null karakter bulunacaktır. Fonksiyon 
    başarı durumunda diziye yerleştirilen karakter sayısı ile (CR/LF dahil) geri dönmektedir. Karşı taraf soketi kapatmışsa 
    ve hiçbir okuma yapılamamışsa bu durumda fonksiyon 0 ile geri dönmektedir. Bu durumda programcının verdiği dizinin içeriği 
    kullanılmamalıdır. Mesajın sonunda CR/LF çifti olmadıktan sonra fonksiyon başarılı okuma yapmamaktadır. Fonksiyon başarısızlık 
    durumunda -1 değerine geri döner ve errno uygun biçimde set edilir. Burada yazmış olduğumuz sock_readline fonksiyonu bir 
    satır okunana kadar blokeye yol açmaktadır. Dolayısıyla çok client'lı server uygulamalarında select, poll ve epoll gibi modellerde
    bu fonksiyon bu haliyle kullanılamaz. Örneğin biz select fonksiyonunda bir grup soketi bekliyor olalım. Bir sokete bir satırın 
    yarısı gelmiş olabilir. Bu durumda biz read_line fonksiyonunu çağırırsak bloke oluşacaktır. Tabii gerçi satırın geri kalan kısmı 
    zaten kısa bir süre sonra gelecek olsa da bu durum yine bir kusur oluşturacaktır.

    UNIX/Linux, macOS ve Windows sistemlerinde yalnızca CR ('\r) karakteri imleci bulunulan satırın başına geçirmektedir. Dolayısıyla 
    bir yazının sonunda CR/LF çifti varsa yazının ekrana bastırılmasında bir sorun oluşmayacaktır. Çünkü önce CR karakteri 
    imleci bulunulan satırın başına geçirecek sonra LF karakteri aşağı satırın başına geçirecektir. Böylece yazının sonunda LF
    karakterinin bulunmasıyla CR/LF karakterlerinin bulunması arasında bir fark oluşmayacaktır.

    Aşağıdaki örnekte client program, server programa CR/LF ile sonlandırılmış bir yazı göndermektedir. Server program da bu yazıyı 
    yukarıdaki sock_readline fonksiyonunu kullanarak okuyup ekrana (stdout dosyasına) yazdırmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define DEF_SERVER_PORT        55555
#define BUFFER_SIZE            4096

ssize_t sock_readline(int sock, char *str, size_t size);
void exit_sys(const char *msg);

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;
    char buf[BUFFER_SIZE + 1];
    char ntopbuf[INET_ADDRSTRLEN];
    ssize_t result;
    int option;
    int server_port;
    int p_flag, err_flag;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("listening port %d\n", server_port);

    printf("waiting for connection...\n");
    sin_len = sizeof(sin_client);
    if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
        exit_sys("accept");

    printf("connected client ===> %s:%u\n", inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sin_client.sin_port));

    for (;;) {
        if ((result = sock_readline(client_sock, buf, BUFFER_SIZE)) == -1)
            exit_sys("sock_readline");
        if (result == 0)
            break;
        if (!strcmp(buf, "quit\r\n"))
            break;
        buf[strlen(buf) - 2] = '\0';
        printf("%jd byte(s) received: \"%s\"\n", (intmax_t)result, buf);
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    close(server_sock);

    return 0;
}

ssize_t sock_readline(int sock, char *str, size_t size)
{
    char *bstr = str;
    static char *bp;
    static ssize_t count = 0;
    static char buf[2048];

    if (size <= 2) {
        errno = EINVAL;
        return -1;
    }

    while (--size > 0) {
        if (--count <= 0) {
            if ((count = recv(sock, buf, sizeof(buf), 0)) == -1)
                return -1;
            if (count == 0)
                return 0;
            bp = buf;
        }
        *str++ = *bp++;
        if (str[-1] == '\n')
            if (str - bstr > 1 && str[-2] == '\r') {
                *str = '\0';
                break;
            }
    }

    return (ssize_t) (str - bstr);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define BUFFER_SIZE            4096

void exit_sys(const char *msg);

/* ./client [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[BUFFER_SIZE];
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    printf("connected server...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';

        strcat(str, "\r\n");

        if (send(client_sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit\r\n"))
            break;
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                108. Ders 05/01/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                109. Ders 07/01/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi matematiksel işlemler yapan bir client/server uygulama yazmak isteyelim. Bu multi-client bir uygulama olsun. Bunun için 
    thread modelini kullanalım. (Çünkü bu tür uygulamalarda diğer modeller kullanılırken dikkat etmemiz gereken başka 
    noktalar vardır. Diğer modellerde soketten okunan bilgilerin biriktirilmesi gerekmektedir. Bu biriktirmenin nasıl yapılabileceğini
    izleyen paragraflarda açıklayacağız.)

    Uygulama katmanı protokollerinde genel olarak client'ın server'a her gönderdiği mesaj için server client'a bir yanıt verir. 
    Bu yanıt olumlu ise istenen işlemin yanıtıdır. Olumsuz ise bir hata yanıtıdır. Bu tür protokollerde protokolü tasarlayan baştan 
    client'ın server'a, server'ın da client'a göndereceği mesajları belirlemelidir.

    Matematiksel işlemler yapan client/server programımızda client'ın server'a göndereceği mesajlar şunlar olabilir:

    "LOGIN <user_name> <password>\r\n"
    "ADD op1 op2\r\n"
    "SUB op1 op2\r\n"
    "MUL op1 op2\r\n"
    "DIV op1 op2\r\n"
    "SQRT op1\r\n"
    "POW op1\r\n"
    "LOGOUT\r\n"

    Server'ın client'a gönderdiği mesajlar da şunlar olabilir:

    "LOGIN_ACCEPTED\r\n"
    "LOGOUT_ACCEPTED\r\n"
    "RESULT result\r\n"
    "ERROR message\r\n"

    Bu tür uygulama katmanı protokollerinde fiziksel bağlantı ile mantıksal bağlantının karıştırılmaması gerekir. Bir client'ın
    server'a connect fonksiyonuyla bağlanması onun hizmet alacağı anlamına gelmemektedir. Onun hizmet alabilmesi için mantıksal 
    bir bağlantının da sağlanması gerekir. Bizim protokolümüzde bu mantıksal bağlantı "LOGIN" ve "LOGIN_ACCEPTED" mesajlarıyla
    yapılmaktadır. Client, TCP'den bağlandıktan sonra server'a kullanıcı adını ve parolayı yollar. Server doğrulamayı yaparsa 
    client'a "LOGIN_ACCEPTED\r\n" mesajını iletir. Eğer server doğrulamayı yapamazsa bu durumda örneğin "ERROR LOGIN_FAILED\r\n"
    gibi bir hata mesajıyla geri dönüp soketi kapatacaktır.

    Aşağıda çok client'lı matematiksel işlem yapan bir client-server uygulama kodu verilmiştir. Bu uygulamada "calc-server" 
    programı her client bağlantısında bir thread açıp o thread yoluyla ilgili client ile konuşmaktadır. Yani buradaki server
    IO modeli olarak thread modelini kullanmaktadır. Bir client, server'a "kullanıcı adı" ve "parola" ile bağlanmaktadır. Server
    program bir CSV dosyasına bakarak kullanıcı adı ve parola bilgisini doğrulamaktadır. Bir client bağlandığında server program 
    CLIENT_INFO isimli bir yapı türünden bir nesne yaratıp client'ın bilgilerini orada saklamaktadır. Aslında bu tür programlarda 
    tüm client'ların bilgileri bir dizi ya da bağlı liste içerisinde tutulmalıdır. Çünkü server tüm client'lara belli bir mesajı 
    göndermek isteyebilir. Server programı aşağıdaki gibi derleyebilirsiniz:

    gcc -Wall -o calc-server calc-server.c -lm

    Prototipleri <math.h> içerisinde olan standart C fonksiyonları libc kütüphanesinde değildir. libm isimli ayrı bir 
    kütüphanededir. Maalesef gcc otomatik olarak bu kütüphaneyi link aşamasına dahil etmemektedir. Bu nedenle matematiksel 
    fonksiyonları kullanırken linker için -lm seçeneğinin bulundurulması gerekmektedir.

    Client program (calc-client.c) server'a fiziksel olarak TCP'den bağlandıktan sonra ona kullanıcı adı ve parolayı mesaj 
    olarak gönderir. Sonra bir komut satırına düşer. Komutlar komut satırından verilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/* calc-server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <stdint.h>
#include <stdbool.h>
#include <errno.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define CREDENTIALS_PATH    "credentials.csv"

#define DEF_SERVER_PORT        55555
#define MAX_MSG_SIZE        4096
#define MAX_MSG_PARAMS        32

#define MAX_USER_NAME        64
#define MAX_PASSWORD        64
#define MAX_CREDENTIALS        1024

typedef struct tagCREDENTIAL {
    char user_name[MAX_USER_NAME];
    char password[MAX_PASSWORD];
} CREDENTIAL;

typedef struct tagCLIENT_INFO {
    int sock;
    struct sockaddr_in sin;
    char buf[MAX_MSG_SIZE + 1];                // MAX_MSG_SIZE is enough
    CREDENTIAL credential;
} CLIENT_INFO;

typedef struct tagMSG {
    char *params[MAX_MSG_PARAMS];
    int count;
} MSG;

typedef struct tagCLIENT_MSG_PROC {
    char *msg;
    bool (*proc)(CLIENT_INFO *, const MSG *);
} CLIENT_MSG_PROC;

int read_credentials(void);
void *client_thread_proc(void *param);
ssize_t sock_readline(int sock, char *str, size_t size);
void receive_msg(CLIENT_INFO *ci);
void send_msg(CLIENT_INFO *ci, const char *msg);
int is_empty_line(const char *line);
void exit_client_thread(CLIENT_INFO *ci);
void parse_msg(char *msg, MSG *msgs);

bool login_proc(CLIENT_INFO *ci);
bool add_proc(CLIENT_INFO *ci, const MSG *msg);
bool sub_proc(CLIENT_INFO *ci, const MSG *msg);
bool mul_proc(CLIENT_INFO *ci, const MSG *msg);
bool div_proc(CLIENT_INFO *ci, const MSG *msg);
bool sqrt_proc(CLIENT_INFO *ci, const MSG *msg);
bool pow_proc(CLIENT_INFO *ci, const MSG *msg);
bool logout_proc(CLIENT_INFO *ci, const MSG *msg);

char *revstr(char *str);
void exit_sys(const char *msg);

CLIENT_MSG_PROC g_client_msgs[] = {
    {"ADD", add_proc},
    {"SUB", sub_proc},
    {"MUL", mul_proc},
    {"DIV", div_proc},
    {"SQRT", sqrt_proc},
    {"POW", pow_proc},
    {"LOGOUT", logout_proc},
    {NULL, NULL}
};
CREDENTIAL g_credentials[MAX_CREDENTIALS];
int g_ncredentials;

/* ./server [-p port] */

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_in sin_server, sin_client;
    socklen_t sin_len;
    int option;
    int server_port;
    int p_flag, err_flag;
    pthread_t tid;
    CLIENT_INFO *ci;
    int result;

    p_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "p:")) != -1) {
        switch (option) {
            case 'p':
                p_flag = 1;
                server_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 'p')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (optind - argc != 0) {
        fprintf(stderr, "too many arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (read_credentials() == -1) {
        fprintf(stderr, "cannot read credentials...\n");
        exit(EXIT_FAILURE);
    }

    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sin_server.sin_family = AF_INET;
    sin_server.sin_port = htons(server_port);
    sin_server.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(server_sock, (struct sockaddr *)&sin_server, sizeof(sin_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    printf("listening port %d\n", server_port);

    for (;;) {
        sin_len = sizeof(sin_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sin_client, &sin_len)) == -1)
            exit_sys("accept");

        // printf("connected client ===> %s : %u\n", inet_ntop(AF_INET, &sin_client.sin_addr, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sin_client.sin_port));

        if ((ci = (CLIENT_INFO *)malloc(sizeof(CLIENT_INFO))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }

        ci->sock = client_sock;
        ci->sin = sin_client;

        if ((result = pthread_create(&tid, NULL, client_thread_proc, ci)) != 0) {
            fprintf(stderr, "pthread_create: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }

        if ((result = pthread_detach(tid)) != 0) {
            fprintf(stderr, "pthread_detach: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }
    }

    close(server_sock);

    return 0;
}

int read_credentials(void)
{
    char buf[MAX_USER_NAME + MAX_PASSWORD + 32];
    FILE *f;
    char *str;

    if ((f = fopen(CREDENTIALS_PATH, "r")) == NULL)
        return -1;

    g_ncredentials = 0;
    while (fgets(buf, MAX_USER_NAME + MAX_PASSWORD + 32, f) != NULL) {
        if (is_empty_line(buf) == 0)
            continue;
        if ((str = strtok(buf, ",")) == NULL)
            return -1;
        strcpy(g_credentials[g_ncredentials].user_name, str);
        if ((str = strtok(NULL, "\n")) == NULL)
            return -1;
        strcpy(g_credentials[g_ncredentials].password, str);

        if ((str = strtok(NULL, "\n")) != NULL)
            return -1;

        ++g_ncredentials;
    }

    fclose(f);

    return 0;
}

int is_empty_line(const char *line)
{
    while (*line != '\0') {
        if (!isspace(*line))
            return -1;
        ++line;
    }

    return 0;
}

void *client_thread_proc(void *param)
{
    char ntopbuf[INET_ADDRSTRLEN];
    unsigned port;
    CLIENT_INFO *ci = (CLIENT_INFO *)param;
    MSG msg;
    int i;

    inet_ntop(AF_INET, &ci->sin.sin_addr, ntopbuf, INET_ADDRSTRLEN);
    port = (unsigned)ntohs(ci->sin.sin_port);

    if (!login_proc(ci)) {
        send_msg(ci, "ERROR incorrect user name or password\r\n");
        exit_client_thread(ci);
    }

    send_msg(ci, "LOGIN_ACCEPTED\r\n");
    printf("client connected with user name \"%s\"\n", ci->credential.user_name);

    for (;;) {
        receive_msg(ci);
        *strchr(ci->buf, '\r') = '\0';
        printf("Message from \"%s\": \"%s\"\n", ci->credential.user_name, ci->buf);
        parse_msg(ci->buf, &msg);

        if (msg.count == 0) {
            send_msg(ci, "ERROR empty command\r\n");
            continue;
        }

        for (i = 0; g_client_msgs[i].msg != NULL; ++i)
            if (!strcmp(g_client_msgs[i].msg, msg.params[0])) {
                if (!g_client_msgs[i].proc(ci, &msg))
                    goto EXIT;
                break;
            }
        if (g_client_msgs[i].msg == NULL) {
            send_msg(ci, "ERROR invalid command\r\n");
        }

    }

    printf("client disconnected %s : %u\n", ntopbuf, port);

EXIT:
    shutdown(ci->sock, SHUT_RDWR);
    close(ci->sock);

    free(ci);

    return NULL;
}

ssize_t sock_readline(int sock, char *str, size_t size)
{
    char *bstr = str;
    static char *bp;
    static ssize_t count = 0;
    static char buf[2048];

    if (size <= 2) {
        errno = EINVAL;
        return -1;
    }

    while (--size > 0) {
        if (--count <= 0) {
            if ((count = recv(sock, buf, sizeof(buf), 0)) == -1)
                return -1;
            if (count == 0)
                return 0;
            bp = buf;
        }
        *str++ = *bp++;
        if (str[-1] == '\n')
            if (str - bstr > 1 && str[-2] == '\r') {
                *str = '\0';
                break;
            }
    }

    return (ssize_t) (str - bstr);
}

void receive_msg(CLIENT_INFO *ci)
{
    ssize_t result;

    if ((result = sock_readline(ci->sock, ci->buf, MAX_MSG_SIZE)) == -1) {
        fprintf(stderr, "sock_readline: %s\n", strerror(errno));
        exit_client_thread(ci);
    }

    if (result == 0) {
        fprintf(stderr, "sock_readline: client unexpectedly down...\n");
        exit_client_thread(ci);
    }
}

void send_msg(CLIENT_INFO *ci, const char *msg)
{
    if (send(ci->sock, msg, strlen(msg), 0) == -1)
        exit_client_thread(ci);
}

void exit_client_thread(CLIENT_INFO *ci)
{
    shutdown(ci->sock, SHUT_RDWR);
    close(ci->sock);
    free(ci);
    pthread_exit(NULL);
}

void parse_msg(char *buf, MSG *msg)
{
    char *str;

    msg->count = 0;
    for (str = strtok(buf, " \r\n\t"); str != NULL; str = strtok(NULL, " \r\n\t"))
        msg->params[msg->count++] = str;

    msg->params[msg->count] = NULL;
}

bool login_proc(CLIENT_INFO *ci)
{
    MSG msg;
    char *user_name, *password;

    receive_msg(ci);
    parse_msg(ci->buf, &msg);

    user_name = msg.params[1];
    password = msg.params[2];

    if (msg.count != 3)
        return false;

    if (strcmp(msg.params[0], "LOGIN") != 0)
        return false;

    for (int i = 0; i < g_ncredentials; ++i)
        if (strcmp(user_name, g_credentials[i].user_name) == 0 && strcmp(password, g_credentials[i].password) == 0) {
            ci->credential = g_credentials[i];
            return true;
        }

    return false;
}

bool add_proc(CLIENT_INFO *ci, const MSG *msg)
{
    double op1, op2, result;
    char buf[MAX_MSG_SIZE];

    if (msg->count != 3) {
        send_msg(ci, "ERROR invalid operand in command\r\n");
        return true;
    }
    op1 = atof(msg->params[1]);
    op2 = atof(msg->params[2]);

    result = op1 + op2;

    sprintf(buf, "RESULT %f\r\n", result);
    send_msg(ci, buf);

    return true;
}

bool sub_proc(CLIENT_INFO *ci, const MSG *msg)
{
    double op1, op2, result;
    char buf[MAX_MSG_SIZE];

    if (msg->count != 3) {
        send_msg(ci, "ERROR invalid operand in command\r\n");
        return true;
    }
    op1 = atof(msg->params[1]);
    op2 = atof(msg->params[2]);

    result = op1 - op2;

    sprintf(buf, "RESULT %f\r\n", result);
    send_msg(ci, buf);

    return true;
}

bool mul_proc(CLIENT_INFO *ci, const MSG *msg)
{
    double op1, op2, result;
    char buf[MAX_MSG_SIZE];

    if (msg->count != 3) {
        send_msg(ci, "ERROR invalid operand in command\r\n");
        return true;
    }
    op1 = atof(msg->params[1]);
    op2 = atof(msg->params[2]);

    result = op1 * op2;

    sprintf(buf, "RESULT %f\r\n", result);
    send_msg(ci, buf);

    return true;
}

bool div_proc(CLIENT_INFO *ci, const MSG *msg)
{
    double op1, op2, result;
    char buf[MAX_MSG_SIZE];

    if (msg->count != 3) {
        send_msg(ci, "ERROR invalid operand in command\r\n");
        return true;
    }
    op1 = atof(msg->params[1]);
    op2 = atof(msg->params[2]);

    result = op1 / op2;

    sprintf(buf, "RESULT %f\r\n", result);
    send_msg(ci, buf);

    return true;
}

bool sqrt_proc(CLIENT_INFO *ci, const MSG *msg)
{
    double op, result;
    char buf[MAX_MSG_SIZE];

    if (msg->count != 2) {
        send_msg(ci, "ERROR invalid operand in command\r\n");
        return true;
    }
    op = atof(msg->params[1]);
    result = sqrt(op);

    sprintf(buf, "RESULT %f\r\n", result);
    send_msg(ci, buf);

    return true;
}

bool pow_proc(CLIENT_INFO *ci, const MSG *msg)
{
    double op1, op2, result;
    char buf[MAX_MSG_SIZE];

    if (msg->count != 3) {
        send_msg(ci, "ERROR invalid operand in command\r\n");
        return true;
    }
    op1 = atof(msg->params[1]);
    op2 = atof(msg->params[2]);

    result = pow(op1, op2);

    sprintf(buf, "RESULT %f\r\n", result);
    send_msg(ci, buf);

    return true;
}

bool logout_proc(CLIENT_INFO *ci, const MSG *msg)
{
    send_msg(ci, "LOGOUT_ACCEPTED\r\n");

    printf("%s logging out...\n", ci->credential.user_name);

    return false;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* calc-client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "127.0.0.1"
#define DEF_SERVER_PORT        "55555"
#define MAX_MSG_SIZE        4096
#define MAX_MSG_PARAMS        32

typedef struct tagMSG {
    char *params[MAX_MSG_PARAMS];
    int count;
} MSG;

typedef struct tagSERVER_MSG_PROC {
    char *msg;
    bool (*proc)(const MSG *);
} SERVER_MSG_PROC;

ssize_t sock_readline(int sock, char *str, size_t size);
void receive_msg(int sock, char *msg);
void send_msg(int sock, const char *msg);
void parse_msg(char *buf, MSG *msg);
int parse_error(char *buf, MSG *msg);
int login_attempt(int sock, const char *user_name, const char *password);

bool result_proc(const MSG *msg);
bool error_proc(const MSG *msg);
bool logout_accepted_proc(const MSG *msg);

void exit_sys(const char *msg);

SERVER_MSG_PROC g_server_msgs[] = {
    {"ERROR", error_proc},
    {"RESULT", result_proc},
    {"LOGOUT_ACCEPTED", logout_accepted_proc},
    {NULL, NULL}
};

/* ./calc-client <username> <password> [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char buf[MAX_MSG_SIZE];
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    const char *user_name, *password;
    MSG msg;
    int i;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (argc - optind != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    user_name = argv[optind + 0];
    password = argv[optind + 1];

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    if (login_attempt(client_sock, user_name, password) == -1)
        goto EXIT;

    printf("connection successful...\n");

    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, MAX_MSG_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (buf[strspn(buf, " \t")] == '\0')        /* check if buf contains white spaces */
            continue;
        strcat(str, "\r\n");

        send_msg(client_sock, buf);
        receive_msg(client_sock, buf);

        parse_msg(buf, &msg);

        for (i = 0; g_server_msgs[i].msg != NULL; ++i)
            if (!strcmp(g_server_msgs[i].msg, msg.params[0])) {
                if (!g_server_msgs[i].proc(&msg))
                    goto EXIT;
                break;
            }
    }
EXIT:
    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

ssize_t sock_readline(int sock, char *str, size_t size)
{
    char *bstr = str;
    static char *bp;
    static ssize_t count = 0;
    static char buf[2048];

    if (size <= 2) {
        errno = EINVAL;
        return -1;
    }

    while (--size > 0) {
        if (--count <= 0) {
            if ((count = recv(sock, buf, sizeof(buf), 0)) == -1)
                return -1;
            if (count == 0)
                return 0;
            bp = buf;
        }
        *str++ = *bp++;
        if (str[-1] == '\n')
            if (str - bstr > 1 && str[-2] == '\r') {
                *str = '\0';
                break;
            }
    }

    return (ssize_t) (str - bstr);
}

void receive_msg(int sock, char *msg)
{
    ssize_t result;

    if ((result = sock_readline(sock, msg, MAX_MSG_SIZE)) == -1)
        exit_sys("receive_msg");
    if (result == 0) {
        fprintf(stderr, "receive_msg: unexpectedly down...\n");
        exit(EXIT_FAILURE);
    }
}

void send_msg(int sock, const char *msg)
{
    if (send(sock, msg, strlen(msg), 0) == -1)
        exit_sys("send_msg");
}

void parse_msg(char *buf, MSG *msg)
{
    char *str;

    if (parse_error(buf, msg) == 0)
        return;

    msg->count = 0;
    for (str = strtok(buf, " \r\n\t"); str != NULL; str = strtok(NULL, " \r\n\t"))
        msg->params[msg->count++] = str;

    msg->params[msg->count] = NULL;
}

int parse_error(char *buf, MSG *msg)
{
    while (isspace(*buf))
        ++buf;
    if (!strncmp(buf, "ERROR", 5)) {
        buf += 5;
        while (isspace(*buf))
            ++buf;
        *strchr(buf, '\r') = '\0';
        msg->count = 2;
        msg->params[0] = "ERROR";
        msg->params[1] = buf;

        return 0;
    }
    return -1;
}

int login_attempt(int sock, const char *user_name, const char *password)
{
    char buf[MAX_MSG_SIZE];
    MSG msg;

    sprintf(buf, "LOGIN %s %s\r\n", user_name, password);
    send_msg(sock, buf);
    receive_msg(sock, buf);
    parse_msg(buf, &msg);
    if (!strcmp(msg.params[0], "ERROR")) {
        fprintf(stderr, "login error: %s\n", msg.params[1]);
        return -1;
    }

    if (strcmp(msg.params[0], "LOGIN_ACCEPTED") != 0) {
        fprintf(stderr, "unexpected server message!...\n");
        return -1;
    }
    return 0;
}

bool result_proc(const MSG *msg)
{
    printf("%s\n", msg->params[1]);

    return true;
}

bool error_proc(const MSG *msg)
{
    printf("Error: %s\n", msg->params[1]);

    return true;
}

bool logout_accepted_proc(const MSG *msg)
{
    return false;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                110. Ders 12/01/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de IRC stili bir chat programı yazacağımızı düşünelim. Programlardaki IO modeli üzerinde durmayacağız. Yalnızca 
    mesajlaşmalar üzerinde duracağız.

    Bu tür chat programlarında server kendisine bağlanan tüm client'ların bilgilerini tutmaktadır. Bir client bir yazıyı 
    tüm diğer client'ların görmesi için server'a iletir. Server'da bunu client'lara iletir. Böyle basit bir chat uygulamasında 
    client'tan server'a gönderilecek mesajlar şunlar olabilir:

    "LOGIN <kullanıcı_adı> <parola>\r\n"
    "SEND_MESSAGE <mesaj metni>\r\n
    "LOGOUT\r\n"

    Server'dan client'a gönderilecek mesajlar şunlar olabilir:

    "LOGIN_ACCEPTED\r\n"
    "ACTIVE_USERS\r\n"
    "NEW_USER_LOGGEDIN <kullanıcı adı>\r\n"
    "USER_LOGGEDOUT <kullanıcı_adı>\r\n"
    "LOGOUT_ACCEPTED\r\n"
    "DISTRIBUTE_MESSAGE <mesaj metni>\r\n"
    "LOGOUT_ACCEPTED\r\n"
    "ERROR <hata_mesajı>"

    Çalışma akışı şöyle olabilir:

    - Client önce LOGIN mesajı ile server'a mantıksal bakımdan bağlanır. Server da bağlantıyı kabul ederse client'a 
    LOGIN_ACCEPTED mesajını gönderir. Tabii oturuma yeni kullanıcı katıldığı için aynı zamanda server diğer tüm client'lara
    NEW_USER_LOGGEDIN yollar. Bağlanan client'a ise oturumdakilerin hepsinin listesini ACTIVE_USERS mesajı ile iletmektedir.

    - Client bir mesajın oturumdaki herkes tarafından görülmesini sağlamak amacıyla server'a SEND_MESSAGE mesajını gönderir. 
    Server da bu mesajı oturumdaki tüm client'lara DISTRIBUTE_MESSAGE mesajıyla iletir.

    - Bir kullanıcı logout olmak istediğinde server'a LOGOUT mesajını gönderir. Server'da bunu kabul ederse client'a 
    LOGOUT_ACCEPTED mesajını gönderir. Ancak client'ın logout olduğu bilgisinin oturumdaki diğer client'lara da iletilmesi 
    gerekmektedir. Bunun için server tüm client'lara USER_LOGGED mesajını göndermelidir.

    - Yine bir hata durumunda server client'lara ERROR mesajı gönderebilir.

    Aslında chat programları için IP protocol ailesinde IRC (Internet Relay Chat) protokolü bulunmaktadır. IRC server ve client 
    programlar Linux sistemlerinde zaten bulunmaktadır. Siz de bu protokolün dokümanlarını inceleyerek bu protokol için 
    client ve/veya server programları yazabilirsiniz. IRC protokolü "RFC 1459" olarak dokümante edilmiştir. Başka kurumların da
    chat protokollerinin bazıları artık dokümante edilmiştir. Microsoft'un MSN Chat protokolünün dokümanlarına aşağıdaki 
    adresten erişebilirsiniz:

    http://www.hypothetic.org/docs/msn/
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Komut satırı tabanlı bir telnet, ssh benzeri client-server bir program yazmak isteyelim. Amacımız bir client'ın
    server makinede komut satırından işlem yapmasını sağlamak olsun. Yani client server'a bağlanacak ona shell komutları 
    yollayacak, komutların çıktısını da görecek. Böyle bir programın server tarafının çatısı şöyle oluşturulabilir:

    - Client program bağlandığında server iki boru yaratır ve fork işlemi yapar.

    - fork işleminden sonra henüz exec işlemi yapmadan alt prosesin stdin betimleyicisini borunun birine, stdout betimleyicisini 
    de diğerine yönlendirir. Böylece üst proses boruya yazma yaptığında aslında alt proses bunu stdin betimleyicisinden okuyacaktır.
    Benzer biçimde alt proses diğer boruya yazma yaptığında üst proses de bunu diğer borudan okuyabilecektir.

    - Bu yönlendirmelerden sonra server exec yaparak shell programını çalıştırır.

    - Client, server'a shell komutunu gönderdiğinde server komutu shell programına işletir, çıktısını elde eder ve client'a 
    yollar.

    Aslında bu işlemi yapan iki standart protokol vardır: telnet ve ssh protokolleri. telnet protokolü güvenlik bakımından 
    zayıf olduğu için günümüzde daha çok ssh kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                111. Ders 14/01/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Telnet ya da ssh benzeri programı yazarken üst prosesin /bin/bash programını çalıştırıp ona komutlar yollaması ve ondan 
    komutlar alması gerekmektedir. İşin bu kısmını yapan örnek bir program aşağıda verilmiştir. Aşağıdaki programda üst proses
    iki boru yaratmıştır. Sonra alt prosesi yaratarak exec uygulamıştır. Ancak üst proses henüz exec yapmadan alt prosesin 
    stdin betimleyicisini ve stdout betimleyicisini boruya yönlendirmiştir. Böylece şöyle bir mekanizma oluşturulmuştur: Üst 
    proses borulardan birine yazdığında sanki alt prosesin stdin dosyasına yazmış gibi olmaktadır. Üst proses diğer borudan 
    okuma yaptığında alt prosesin stdout dosyasına yazılanları okumuş gibi olmaktadır.

    Aşağıdaki programda bazı kusurlar vardır. Örneğin:

    - Üst proses kabuğa komutu ilettikten sonra onun stdout ya da stdin dosyasına yazdıklarını okumaya çalışmaktadır. Ancak
    ne kadar bilginin okunacağı belli değildir.

    - Üst proses alt prosesin yazdıklarını okuyabilmek için biraz gecikme uygulamıştır. Ancak alt proses bu gecikmeden uzun süre 
    çalışıyorsa program hatalı çalışır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>

#define BUFFER_SIZE        65536

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;
    int fdsout[2];
    int fdsin[2];
    char buf[BUFFER_SIZE + 1];
    ssize_t result;
    int status;

    if (pipe(fdsin) == -1)
        exit_sys("pipe");

    if (pipe(fdsout) == -1)
        exit_sys("pipe");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0) { /* child */
        close(fdsin[0]);
        close(fdsout[1]);

        if (dup2(fdsin[1], 1) == -1)
            _exit(EXIT_FAILURE);
        if (dup2(fdsin[1], 2) == -1)
            _exit(EXIT_FAILURE);
        if (dup2(fdsout[0], 0) == -1)
            _exit(EXIT_FAILURE);

        close(fdsin[1]);
        close(fdsout[0]);

        if (execl("/bin/bash", "/bin/bash", (char *)NULL) == -1)
            _exit(EXIT_FAILURE);

        /* unreachable code */
    }

    /* parent process */

    close(fdsin[1]);
    close(fdsout[0]);

    /* parent writes fdsout[1] and read fdsin[0] */

    if (fcntl(fdsin[0], F_SETFL, fcntl(fdsin[0], F_GETFL)|O_NONBLOCK) == -1)
        exit_sys("fcntl");

    for (;;) {
        printf("Command: ");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if (write(fdsout[1], buf, strlen(buf)) == -1)
            exit_sys("write");
        if (!strcmp(buf, "exit\n"))
            break;
        usleep(300000);
        if ((result = read(fdsin[0], buf, BUFFER_SIZE)) == -1) {
            if (errno == EAGAIN)
                continue;
            exit_sys("read");
        }

        buf[result] = '\0';
        printf("%s", buf);
    }

    if (wait(&status) == -1)
        exit_sys("wait");

    if (WIFEXITED(status))
        printf("Shell exits normally with exit code: %d\n", WEXITSTATUS(status));
    else
        printf("shell exits abnormally!...\n");

    close(fdsin[0]);
    close(fdsout[1]);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                112. Ders 19/01/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    IP ailesinin uygulama katmanındaki Telnet, SSH, HTTP, POP3, SMTP gibi protokoller daha önceden de belirttiğimiz gibi hep 
    yazısal işlem yapmaktadır. Yani bu protokollerde mesajlar birer yazı biçiminde sonu \r\n ile bitecek biçimde gönderilip 
    alınmaktadır. Burada e-posta almak için kullanılan POP3 (Post Office Protocol Version 3) protokolü üzerinde kısaca duracağız. 
    E-posta almak için yaygın kullanılan diğer protokol IMAP protokolüdür. IMAP protokolü, POP3 protokolünden daha güvenli ve
    ayrıntılı tasarlanmıştır. E-posta okuyucuları iki protokolü de kullanmaktadır. POP3 ve IMAP protokollerinin client program
    olduğuna dikkat ediniz. Client program, POP3 ve IMAP server'lara bağlanarak onlardan e-postaları almaktadır. Yani e-postaları
    tutan sunucu tarafıdır ve client onlara bağlanıp e-postaları yerel makineye çekmektedir.

    Tipik olarak e-posta gönderip alma işlemleri şöyle gerçekleştirilmektedir.

    1) Bunun için bir e-posta sunucu programının bulunuyor olması gerekir. Eğer tüm sistemi siz kuruyorsanız bu sunucuyu (server) 
    da sizin kurmanız gerekmektedir. Zaten Windows sistemlerinde, UNIX/Linux sistemlerinde bu sunucular hazır biçimde bulunmaktadır.
    Tabii eğer domain hizmetini aldığınız bir kurum varsa onlar da zaten e-posta hizmeti vermek için hazır e-posta sunucuları 
    bulundurmaktadır. E-posta gönderebilmek için ya da e-posta alabilmek için bizim e-posta sunucusunun adresini biliyor olmamız 
    gerekir. Gönderme işleminde kullanılacak sunucu ile alma işleminde kullanılacak sunucu farklı olabilmektedir. Örneğin CSD'nin 
    e-posta sunucusuna "mail.csystem.org" adresiyle erişilebilmektedir. Bu sunucu hem gönderme hem de alma işlemini yapmaktadır. 
    E-posta gönderebilmek için client program ile server program, "SMTP (Simple Mail Transfer Protocol)" denilen bir protokolle
    haberleşmektedir. O halde gönderim için bizim e-posta sunucusuna bağlanarak SMTP protokolü ile göndereceğimiz e-postayı ona iletmemiz 
    gerekir.

    2) Biz göndereceğimiz e-postayı SMTP protokolü ile e-posta sunucumuza ilettikten sonra bu sunucu hedef e-posta sunucusuna bu 
    e-postayı yine SMTP protokolü ile iletmektedir. E-postayı alan sunucu bunu bir posta kutusu (mail box) içerisinde saklar.

    3) Karşı taraftaki client program POP3 ya da IMAP protokolü ile kendi e-posta sunucuna bağlanarak posta kutusundaki e-postayı 
    yerel makineye indirir.

    client ---SMTP---> e-posta sunucusu ---SMTP--> e-posta sunucusu ---POP3/IMAP---> client

    Görüldüğü gibi POP3 ve IMAP protokolleri e-posta sunucusunun posta kutusundaki zaten gelmiş ve saklanmış olan e-postaları yerel 
    makineye indirmek için kullanılmaktadır.

    POP3 protokolü RFC 1939 dokümanlarında açıklanmıştır. Protokol kabaca şöyle işlemektedir:

    1) Client program 110 numaralı (ya da 995 numaralı) porttan server'a TCP ile fiziksel olarak bağlanır.

    2) Protokolde mesajlaşma tamamen text tabanlı ve satırsal biçimde yapılmaktadır. Satırlar CR/LF karakterleriyle sonlandırılmaktadır. 
    Protokolde client'ın gönderdiği her komuta karşı server bir yanıt göndermektedir. (Fiziksel bağlantı sağlandığında da server 
    bir onay mesajı gönderir.) Eğer yanıt olumluysa mesaj "+OK" ile, eğer yanıt olumsuzsa mesaj "-ERR" ile başlatılmaktadır. Yani 
    server'ın client'a gönderdiği mesajın genel biçimi şöyledir:

    +OK [diğer bilgiler] CR/LF
    -ERR [diğer bilgiler] CR/LF

    3) Fiziksel bağlantıdan sonra client program mantıksal olarak server'a login olmalıdır. Login olmak için önce "user name" sonra da 
    "password" gönderilmektedir. User name ve password gönderme işlemi aşağıdaki iki komutla yapılmaktadır.

    "USER <user name> CR/LF"
    "PASS <password> CR/LF"

    Kullanıcı adı e-posta adresiyle aynıdır. Örneğin biz "test@csystem.org" için e-posta sunucusuna bağlanıyorsak buradaki kullanıcı 
    ismi "test@csystem.org" olacaktır. Parola e-postalarınızı okumak için kullandığınız paroladır. Sisteme başarılı bir biçimde login 
    olduğumuzu varsayıyoruz. Tipik olarak server bize şu mesajı iletecektir:

    +OK Logged in.

    Eğer password yanlış girilmişse yeniden önce user name ve sonra password gönderilmelidir.

    4) Client program LIST komutunu göndererek e-posta kutusundaki mesaj bilgilerini elde eder. LIST komutuna karşılık server önce aşağıdaki
    gibi bir satır gönderir:

    +OK 6 messages:

    Burada server e-posta kutusunda kaç e-posta olduğunu belirtmektedir. Sonra her e-postaya bir numara vererek onların byte uzunluklarını 
    satır satır iletir. Komut yalnızca '.' içeren bir satırla son bulmaktadır. Örneğin:

    +OK 6 messages:
    1 1565
    2 5912
    3 11890
    4 4920
    5 9714
    6 4932
    .

    5) Belli bir e-posta RETR komutuyla elde edilmektedir. Bu komuta elde edilecek e-postanın index numarası girilir. Örneğin:

    "RETR 2 CR/LF"

    RETR komutuna karşı server önce aşağıdaki gibi bir satır gönderir:

    +OK 5912 octets

    Burada programcı bu satırı parse ederek burada belirtilen miktarda byte kadar soketten okuma yapmalıdır. Anımsanacağı gibi porttan 
    tam olarak n byte okumak TCP'de tek bir recv ile yapılamamaktadır.

    6) Mesajı silmek için DELE komutu kullanılır. Komuta parametre olarak silinecek mesajın indeks numarası girilmektedir. Örneğin:

    "DELE 3 CR/LF"

    Bu komut uygulandığında server henüz e-postayı posta kutusundan silmez. Yalnızca onu "silinecek" biçiminde işaretler. Silme işlemi QUIT 
    komutuyla oturum sonlandırıldığında yapılmaktadır. Eğer client silme eyleminden pişmanlık duyarsa RSET komutuyla ilk duruma gelir.
    RSET komutu logout yapmaz. Yalnızca silinmiş olarak işaretlenenlerin işaretlerini kaldırır.

    7) STAT komutu o anda e-posta kutusundaki e-posta sayısını bize vermektedir. Bu komut gönderildiğinde aşağıdaki gibi bir yanıt
    alınacaktır:

    +OK 5 27043

    Burada server e-posta kutusunda toplam 5 e-postanın bulunduğunu ve bunların byte uzunluklarının da 27043 olduğunu söylemektedir.

    8) Protocol client programın QUIT komutunu göndermesiyle sonlandırılmaktadır. Örneğin:

    "QUIT CR/LF"

    9) POP3 protokolününde client belli bir süre server'a hiç mesaj göndermezse, server client'ın soketini kapatıp bağlantıyı
    koparmaktadır. Her ne kadar RFC 1939'da server'ın en azından 10 dakika beklemesi gerektiği söylenmişse de server'ların 
    çoğu çok daha az bir süre beklemektedir.

    POP3 protokolünde client programın gönderdiği yazısal komutlar için server programın gönderdiği yanıtlar parse edilerek 
    tam gerektiği kadar okuma yapılabilir. Ancak aşağıdaki programda biz basitlik sağlamak amacıyla server'dan gelen mesajları 
    başka bir thread ile ele aldık.
---------------------------------------------------------------------------------------------------------------------------*/

/* pop3.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <pthread.h>

#define DEF_SERVER_NAME        "mail.csystem.org"
#define DEF_SERVER_PORT        "110"
#define BUFFER_SIZE            4096

ssize_t sock_readline(int sock, char *str, size_t size);
void *thread_proc(void *param);
void send_msg(int sock, const char *msg);

void exit_sys_thread(const char *msg, int err);
void exit_sys(const char *msg);

/* ./pop3 [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    char buf[BUFFER_SIZE + 1];
    pthread_t tid;
    int result;

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (argc - optind != 0) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(res);

    if ((result = pthread_create(&tid, NULL, thread_proc, (void *)client_sock)) != 0)
        exit_sys_thread("pthread_create", result);

    usleep(500000);
    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (buf[strspn(buf, " \t")] == '\0')        /* check if buf contains white spaces */
            continue;
        strcat(str, "\r\n");

        send_msg(client_sock, buf);
        sleep(1);
        if (!strcmp(buf, "QUIT\r\n"))
            break;
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    return 0;
}

void *thread_proc(void *param)
{
    int sock = (int)param;
    char buf[BUFFER_SIZE];
    int result;

    for (;;) {
        if ((result = sock_readline(sock, buf, BUFFER_SIZE)) == -1)
            exit_sys("receive_msg");
        if (result == 0) {
            printf("closing connection...\n");
            break;
        }
        printf("%s", buf);
    }

    exit(EXIT_SUCCESS);

    return NULL;
}

ssize_t sock_readline(int sock, char *str, size_t size)
{
    char *bstr = str;
    static char *bp;
    static ssize_t count = 0;
    static char buf[2048];

    if (size <= 2) {
        errno = EINVAL;
        return -1;
    }

    while (--size > 0) {
        if (--count <= 0) {
            if ((count = recv(sock, buf, sizeof(buf), 0)) == -1)
                return -1;
            if (count == 0)
                return 0;
            bp = buf;
        }
        *str++ = *bp++;
        if (str[-1] == '\n')
            if (str - bstr > 1 && str[-2] == '\r') {
                *str = '\0';
                break;
            }
    }

    return (ssize_t) (str - bstr);
}

void send_msg(int sock, const char *msg)
{
    if (send(sock, msg, strlen(msg), 0) == -1)
        exit_sys("send_msg");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                113. Ders 21/01/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında POP3 client programda her mesaja karşılık server'ın nasıl bir yazı gönderdiği bilindiğine göre buradan hareketle
    hiç thread oluşturmadan gönderilen komut için yanıt elde edilebilir. Aşağıda bu fikre bir örnek verilmiştir. Örneğimizde 
    LIST ve RETR komutları özel olarak ele alınmıştır. LIST komutunda server'ın listeyi ilettikten sonra son satırda "." gönderdiğini
    anımsayınız. Biz de aşağıda programda satırda "." görene kadar okuma yaptık. RETR komutunda +OK yazısından sonra mesajdaki
    byte sayısının da gönderildiğini anımsayınız. Biz de bundan faydalanarak soketten o kadar byte okuduk.
---------------------------------------------------------------------------------------------------------------------------*/

/* pop3.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define DEF_SERVER_NAME        "mail.csystem.org"
#define DEF_SERVER_PORT        "110"
#define BUFFER_SIZE            4096

ssize_t sock_readline(int sock, char *str, size_t size);
void send_msg(int sock, const char *msg);
void receive_msg(int sock, char *msg);
void getcmd(const char *buf, char *cmd);
void proc_list(int sock);
void proc_retr(int sock);

void exit_sys(const char *msg);

/* ./pop3 [-s server] [-p server_port] [-b client_port] */

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_in sin_client;
    struct addrinfo hints = {0, AF_INET, SOCK_STREAM};
    struct addrinfo *res, *ri;
    int gai_result;
    char *str;
    int option;
    int s_flag, p_flag, b_flag, err_flag;
    const char *server_name;
    int bind_port;
    const char *server_port;
    char buf[BUFFER_SIZE + 1];
    char cmd[BUFFER_SIZE];

    s_flag = p_flag = b_flag = err_flag = 0;

    opterr = 0;
    while ((option = getopt(argc, argv, "s:p:b:")) != -1) {
        switch (option) {
            case 's':
                s_flag = 1;
                server_name = optarg;
                break;
            case 'p':
                p_flag = 1;
                server_port = optarg;
                break;
            case 'b':
                b_flag = 1;
                bind_port = atoi(optarg);
                break;
            case '?':
                if (optopt == 's' || optopt == 'p' || optopt == 'b')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (argc - optind != 0) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if (!s_flag)
        server_name = DEF_SERVER_NAME;
    if (!p_flag)
        server_port = DEF_SERVER_PORT;

    if ((client_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (b_flag) {
        sin_client.sin_family = AF_INET;
        sin_client.sin_port = htons(bind_port);
        sin_client.sin_addr.s_addr = htonl(INADDR_ANY);

        if (bind(client_sock, (struct sockaddr *)&sin_client, sizeof(sin_client)) == -1)
            exit_sys("bind");
    }

    if ((gai_result = getaddrinfo(server_name, server_port, &hints, &res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }

    for (ri = res; ri != NULL; ri = ri->ai_next)
        if (connect(client_sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    receive_msg(client_sock, buf);
    printf("%s", buf);

    freeaddrinfo(res);

    usleep(500000);
    for (;;) {
        printf("csd>");
        fflush(stdout);

        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (buf[strspn(buf, " \t")] == '\0')        /* check if buf contains white spaces */
            continue;
        strcat(str, "\r\n");

        send_msg(client_sock, buf);
        getcmd(buf, cmd);

        if (!strcmp(cmd, "LIST"))
            proc_list(client_sock);
        else if (!strcmp(cmd, "RETR"))
            proc_retr(client_sock);
        else {
            receive_msg(client_sock, buf);
            printf("%s", buf);
        }
        if (!strcmp(cmd, "QUIT"))
            break;
    }

    shutdown(client_sock, SHUT_RDWR);
    close(client_sock);

    return 0;
}

ssize_t sock_readline(int sock, char *str, size_t size)
{
    char *bstr = str;
    static char *bp;
    static ssize_t count = 0;
    static char buf[2048];

    if (size <= 2) {
        errno = EINVAL;
        return -1;
    }

    while (--size > 0) {
        if (--count <= 0) {
            if ((count = recv(sock, buf, sizeof(buf), 0)) == -1)
                return -1;
            if (count == 0)
                return 0;
            bp = buf;
        }
        *str++ = *bp++;
        if (str[-1] == '\n')
            if (str - bstr > 1 && str[-2] == '\r') {
                *str = '\0';
                break;
            }
    }

    return (ssize_t) (str - bstr);
}

void send_msg(int sock, const char *msg)
{
    if (send(sock, msg, strlen(msg), 0) == -1)
        exit_sys("send_msg");
}

void receive_msg(int sock, char *msg)
{
    ssize_t result;

    if ((result = sock_readline(sock, msg, BUFFER_SIZE)) == -1)
        exit_sys("receive_msg");
    if (result == 0) {
        fprintf(stderr, "receive_msg: unexpectedly down...\n");
        exit(EXIT_FAILURE);
    }
}

void getcmd(const char *buf, char *cmd)
{
    int i;

    for (i = 0; buf[i] != '\0' && !isspace(buf[i]); ++i)
        cmd[i] = buf[i];
    cmd[i] = '\0';
}

void proc_retr(int sock)
{
    ssize_t result;
    char bufrecv[BUFFER_SIZE + 1];
    ssize_t n;
    int i, ch;

    for (i = 0;; ++i) {
        if ((result = recv(sock, &ch, 1, 0)) == -1)
            exit_sys("sock_readline");
        if (result == 0)
            return;
        if ((bufrecv[i] = ch) == '\n')
            break;
    }
    bufrecv[i] = '\0';

    printf("%s\n", bufrecv);
    n = (ssize_t)strtol(bufrecv + 3, NULL, 10);

    while (n > 0) {
        if ((result = recv(sock, bufrecv, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        bufrecv[result] = '\0';
        printf("%s", bufrecv);
        fflush(stdout);
        n -= result;
    }
}

void proc_list(int sock)
{
    ssize_t result;
    char bufrecv[BUFFER_SIZE];

    do {
        if ((result = sock_readline(sock, bufrecv, BUFFER_SIZE)) == -1)
            exit_sys("sock_readline");
        if (result == 0)
            break;
        printf("%s", bufrecv);
    } while (*bufrecv != '.');
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz bir e-postaya bir resim ya da dosya iliştirirsek ne olacaktır? POP3 protokolü çok eski bir protokoldür. Internet'in
    uygulama katmanındaki ilk protokollerden biridir. Bu protokolde her şey yazı gibi gönderilip alınmaktadır. Dolayısıyla 
    kullanıcı e-postasına bir resim ya da dosya iliştirdiğinde onun içeriği yazıya dönüştürülerek sanki bir yazıymış gibi 
    gönderilmektedir. Pekiyi e-postanın bu gibi farklı içerikleri posta okuyan client tarafından nasıl ayrıştırılacaktır?
    İşte bir yazı içerisinde değişik içerikler MIME denilen sistemle başlıklandırılmaktadır. E-postaları içeriklerine 
    ayrıştırabilmek için ilgili içeriklerin nasıl yazıya dönüştürüldüğünü ve nasıl geri dönüşüm yapıldığını bilmeniz gerekmektedir. 
    Bunun için Base 64 denilen yöntem kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Soketler yaratıldıktan sonra onların bazı özellikleri setsockopt isimli fonksiyonla değiştirilebilir ve getsockopt isimli 
    fonksiyonla da elde edilebilir. setsockopt fonksiyonunun prototipi şöyledir:

    #include <sys/socket.h>

    int setsockopt(int socket, int level, int option_name, const void *option_value, socklen_t option_len);

    Fonksiyonun birinci parametresi özelliği değiştirilecek soketi belirtir. İkinci parametresi değişimin hangi düzeyde yapılacağını 
    belirten bir sembolik sabit biçiminde girilir. Soket düzeyi için tipik olarak SOL_SOCKET girilmelidir. Üçüncü parametre hangi 
    özelliğin değiştirileceğini belirtmektedir. Dördüncü parametre değiştirilecek özelliğin değerinin bulunduğu nesnenin adresini 
    almaktadır. Son parametre dördüncü parametredeki nesnenin uzunluğunu belirtmektedir. Fonksiyon başarı durumunda 0, başarısızlık 
    durumunda -1 değerine geri döner.

    Soket seçeneğini elde etmek için de getsockopt fonksiyonu kullanılmaktadır:

    #include <sys/socket.h>

    int getsockopt(int socket, int level, int option_name, void *restrict option_value, socklen_t *restrict option_len);

    Parametreler setsockopt'ta olduğu gibidir. Yalnızca dördüncü parametrenin yönü değişiktir ve beşinci parametre gösterici 
    almaktadır.

    Tipik soket seçenekleri (üçüncü parametre) şunlardan biri olabilir:

    SO_ACCEPTCONN
    SO_BROADCAST
    SO_DEBUG
    SO_DONTROUTE
    SO_ERROR
    SO_KEEPALIVE
    SO_LINGER
    SO_OOBINLINE
    SO_RCVBUF
    SO_RCVLOWAT
    SO_RCVTIMEO
    SO_REUSEADDR
    SO_SNDBUF
    SO_SNDLOWAT
    SO_SNDTIMEO
    SO_TYPE

    Burada bizim için şimdilik önemli olan birkaç seçenek vardır: SO_BROADCAST, SO_OOBLINE, SO_SNDBUF, SO_RECVBUF, SO_REUSEADDR.
    Soket seçeneğinin değiştirilmesi aşağıdaki örnekte olduğu gibi yapılabilir.

    Örneğin:

    int buflen;
    int optsize = sizeof(int)
    ...
    if (getsockopt(sock_client, SOL_SOCKET, SO_RCVBUF, &buflen, &optsize) == -1)
        exit_sys("getsockopt");

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                114. Ders 26/01/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    SO_REUSEADDR seçeneği belli bir port için bind işlemi yapmış bir server'ın client bağlantısı sağladıktan sonra sonlanması 
    sonucunda bu server'ın yeniden çalıştırılıp aynı portu bind edebilmesi için kullanılmaktadır. Bir portu bind eden server, 
    bir client ile bağlandıktan sonra çökerse, ya da herhangi bir biçimde sonlanırsa işletim sistemleri o portun yeniden belli 
    bir süre bind edilmesini engellemektedir. Bunun nedeni eski çalışan server ile yeni çalışacak olan server'ın göndereceği 
    ve alacağı paketlerin karışabilme olasılığıdır. Eski bağlantıda yollanmış olan paketlerin ağda maksimum bir geçerlilik süresi 
    vardır. İşletim sistemi de bunun iki katı kadar bir süre (2 dakika civarı, neden iki katı olduğu protokolün aşağı seviyeli 
    çalışması ile ilgilidir) bu portun yeniden bind edilmesini engellemektedir. İşte eğer SO_REUSEADDR soket seçeneği kullanılırsa 
    artık sonlanan ya da çöken bir server hemen yeniden çalıştırıldığında bind işlemi sırasında "Address already in use" biçiminde 
    bir hata ile karşılaşılmayacaktır. Bu soket seçeneğini aşağıdaki gibi setsockopt fonksiyonu ile set edebiliriz:

    int sockopt = 1;
    ...
    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &sockopt, sizeof(sockopt)) == -1)
      exit_sys("setsockopt");

    SO_REUSEADDR seçeneğini set etmek için int bir nesne alıp onun içerisine sıfır dışı bir değer yerleştirip, onun adresini 
    setsockopt fonksiyonunun dördüncü parametresine girmek gerekir. Bu nesneye 0 girip fonksiyonu çağırırsak bu özelliği kapatmış 
    oluruz.

    SO_REUSEADDR bayrağı daha önce bir program tarafından bind edilmiş soketin ikinci kez diğer bir program tarafından bind 
    edilmesi için kullanılmamaktadır. Eğer böyle bir ihtiyaç varsa (nadiren olabilir) Linux'ta (fakat POSIX'te değil) SO_REUSEPORT 
    soket seçeneği kullanılmalıdır. Bu soket seçeneği benzer biçimde Windows sistemlerinde SO_EXCLUSIVEADDRUSE biçimindedir. 
    Yani bu soket seçenekleri kullanıldığında aynı port birden fazla server tarafından bind edilip aynı anda kullanılabilir. 
    Bu bayraklarla birden fazla proses aynı portu bind ettiğinde bir client'tan bu porta connect işlemi yapıldığı zaman işletim
    sistemi belli bir load balancing yaparak bağlantının server'lardan biri tarafından kabul edilmesini sağlayacaktır.

    Aşağıdaki server programını client ile bağlandıktan sonra Ctrl+C ile sonlandırınız. Sonra yeniden çalıştırmaya çalışınız. 
    SO_REUSEADDR seçeneği kullanıldığından dolayı bir sorun ile karşılaşılmayacaktır. Daha sonra server programdan o kısmı
    silerek yeniden denemeyi yapınız. Örneğimizdeki client program server adresini ve port numarasını, server program ise 
    yalnızca port numarasını komut satırı argümanı olarak almaktadır. Programları farklı terminallerde aşağıdaki gibi 
    çalıştırabilirsiniz:

    $ ./server 55555
    $ ./client localhost 555555
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock, sock_client;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    char ntopbuf[INET_ADDRSTRLEN];
    in_port_t port;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    int sockopt = 1;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &sockopt, sizeof(sockopt)) == -1)
        exit_sys("setsockopt");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");

    sinaddr_len = sizeof(sinaddr_client);
    if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
        exit_sys("accept");

    printf("Connected: %s : %u\n", inet_ntop(AF_INET, &sinaddr_client, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sinaddr_client.sin_port));

    for (;;) {
        if ((result = recv(sock_client, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%ld bytes received from %s (%u): %s\n", (long)result, ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port), buf);
    }

    shutdown(sock_client, SHUT_RDWR);
    close(sock_client);
    close(sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct addrinfo *ai, *ri;
    struct addrinfo hints = {0};
    char buf[BUFFER_SIZE];
    char *str;
    int result;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    if ((result = getaddrinfo(argv[1], argv[2], &hints, &ai)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(result));
        exit(EXIT_FAILURE);
    }

    for (ri = ai; ri != NULL; ri = ri->ai_next)
        if (connect(sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(ai);

    printf("Connected...\n");

    for (;;) {
        printf("Yazı giriniz:");
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;

        if ((send(sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
    }

    shutdown(sock, SHUT_RDWR);
    close(sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    OOB Verisi (Out-Of-Band Data) bazı stream protokollerinde olan bir özelliktir. Örneğin TCP protokolü OOB verisini 1 byte 
    olarak desteklemektedir. OOB verisine TCP'de "Acil (Urgent)" veri de denilmektedir. Bunun amacı OOB verisinin normal stream 
    sırasında değil daha önce gönderilenlerin -eğer hedef host'ta henüz onlar okunmamışsa- önünde ele alınabilmesidir. Yani biz 
    TCP'de birtakım verileri gönderdikten sonra OOB verisini gönderirsek bu veri önce göndermiş olduklarımızdan daha önde işleme 
    sokulabilir. Böylece OOB verisi uygulamalarda önce gönderilen birtakım bilgilerin iptal edilmesi gibi gerekçelerle kullanılabilmektedir.

    OOB verisini gönderebilmek için send fonksiyonunun flags parametresine MSG_OOB bayrağını girmek gerekir. Tabii TCP yalnızca 
    1 byte uzunluğunda OOB verisinin gönderilmesine izin vermektedir. Bu durumda eğer send ile birden fazla byte MSG_OOB bayrağı 
    ile gönderilmek istenirse gönderilenlerin yalnızca son byte'ı OOB olarak gönderilir. Son byte'tan önceki tüm byte'lar normal 
    veri olarak gönderilmektedir.

    Normal olarak OOB verisi recv fonksiyonunda MSG_OOB bayrağı ile alınmaktadır. Ancak bu bayrak kullanılarak recv çağrıldığında 
    eğer bir OOB verisi sırada yoksa recv başarısız olmaktadır. recv fonksiyonunun MSG_OOB bayraklı çağrısında başarılı olabilmesi 
    için o anda bir OOB verisinin gelmiş olması gerekir. Pekiyi OOB verisinin geldiğini nasıl anlarız? İşte tipik yöntem SIGURG 
    sinyalinin kullanılmasıdır. Çünkü sokete bir OOB verisi geldiğinde işletim sistemi SIGURG sinyali oluşturabilmektedir. Bu sinyalin 
    default durumu IGNORE biçimindedir. (Yani ilgili proses eğer bu sinyali set etmemişse sanki sinyal oluşmamış gibi bir davranış 
    gözükür.) Ancak default olarak OOB verisi geldiğinde sinyal oluşmamaktadır. Bunu mümkün hale getirmek için soket üzerinde fcntl 
    fonksiyonu ile F_SETOWN komut kodunu kullanarak set işlemi yapmak gerekir. fcntl fonksiyonunun son parametresi bu durumda sinyalin 
    gönderileceği prosesin id değeri olarak girilmelidir. Eğer bu parametre negatif bir proses grup id'si olarak girilirse bu 
    durumda işletim sistemi bu proses grubunun bütün üyelerine bu sinyali gönderir. Tabii tipik olarak sinyalin soket betimleyicisine 
    sahip olan prosese gönderilmesi istenir. Bu işlem şöyle yapılabilir:

    if (fcntl(sock_client, F_SETOWN, getpid()) == -1)
        exit_sys("fcntl");

    Aşağıdaki server programda bir OOB verisi geldiğinde SIGURG sinyali oluşturulmaktadır. Bu sinyalin içerisinde recv 
    fonksiyonu MSG_OOB bayrağı ile çağrılmıştır. OOB verisinin okunması için MSG_OOB bayrağı gerekir. Ancak OOB verisinin olmadığı 
    bir durumda bu bayrak kullanılırsa recv başarısız olmaktadır. O halde SIGURG sinyali geldiğinde recv fonksiyonu MSG_OOB 
    bayrağı ile çağrılmalıdır. Bu durumda TCP'de her zaman yalnızca 1 byte okunabilmektedir. Ayrıca server programda SIGURG 
    sinyali set edilirken sigaction yapısının flags parametresinin SA_RESTART biçiminde geçildiğine dikkat ediniz. Bu recv 
    üzerinde beklerken oluşabilecek SIGURG sinyalinden sonra recv'in otomatik yeniden başlatılması için kullanılmıştır. 
    Yine buradaki server program port numarasını, client program ise server adresini ve port numarasını komut satırı argümanı
    olarak almaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/* oobserver.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define BUFFER_SIZE        1024

void sigurg_handler(int sno);
void exit_sys(const char *msg);

int sock_client;

int main(int argc, char *argv[])
{
    int sock;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    char ntopbuf[INET_ADDRSTRLEN];
    in_port_t port;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    struct sigaction sa;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    sa.sa_handler = sigurg_handler;
    sa.sa_flags = SA_RESTART;
    sigemptyset(&sa.sa_mask);

    if (sigaction(SIGURG, &sa, NULL) == -1)
        exit_sys("sigaction");

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");

    sinaddr_len = sizeof(sinaddr_client);
    if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
        exit_sys("accept");

    if (fcntl(sock_client, F_SETOWN, getpid()) == -1)
            exit_sys("fcntl");

    printf("Connected: %s : %u\n", inet_ntop(AF_INET, &sinaddr_client, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sinaddr_client.sin_port));

    for (;;) {
        if ((result = recv(sock_client, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%ld bytes received from %s (%u): %s\n", (long)result, ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port), buf);
    }

    shutdown(sock_client, SHUT_RDWR);
    close(sock_client);
    close(sock);

    return 0;
}

void sigurg_handler(int sno)
{
    char oob;

    if (recv(sock_client, &oob, 1, MSG_OOB) == -1)
        exit_sys("recv");

    printf("OOB Data received: %c\n", oob);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* oobclient.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct addrinfo *ai, *ri;
    struct addrinfo hints = {0};
    char buf[BUFFER_SIZE];
    char *str;
    int result;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    if ((result = getaddrinfo(argv[1], argv[2], &hints, &ai)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(result));
        exit(EXIT_FAILURE);
    }

    for (ri = ai; ri != NULL; ri = ri->ai_next)
        if (connect(sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(ai);

    printf("Connected...\n");

    for (;;) {
        printf("Yazı giriniz:");
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
         if (!strcmp(buf, "quit"))
            break;

        if ((send(sock, buf, strlen(buf), buf[0] == 'u' ? MSG_OOB : 0)) == -1)
            exit_sys("send");
    }

    shutdown(sock, SHUT_RDWR);
    close(sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Soket fonksiyonlarını kullanarak aynı makinenin prosesleri arasında haberleşme yapabiliriz. Ancak bunun için IP protokol 
    ailesinin kullanılması oldukça yavaş bir haberleşme sağlamaktadır. İşte aynı makinenin prosesleri arasında soket fonksiyonlarını 
    kullanarak hızlı bir biçimde haberleşmenin sağlanabilmesi için ismine "UNIX Domain Socket" denilen bir soket haberleşmesi 
    oluşturulmuştur. Her ne kadar bu soket haberleşmesinin isminde UNIX geçiyorsa da bu soketler Windows sistemleri ve macOS 
    sistemleri tarafından da desteklenmektedir.

    UNIX domain soket yaratabilmek için socket fonksiyonunun birinci parametresi (protocol family) AF_UNIX geçilmelidir. UNIX domain 
    soketlerin TCP/IP ya da UDP/IP soketlerle bir ilgisi yoktur. Bu soketler UNIX/Linux sistemlerinde oldukça etkin bir biçimde 
    gerçekleştirilmektedir. Dolayısıyla aynı makinenin prosesleri arasında haberleşmede borulara, mesaj kuyruklarına, paylaşılan 
    bellek alanlarına bir seçenek olarak kullanılabilmektedir. Hatta bazı UNIX türevi sistemlerde (ama Linux'ta böyle değil) aslında 
    çekirdek tarafından önce bu protokol gerçekleştirilip daha sonra boru mekanizması bu protokol kullanılarak gerçekleştirilmektedir. 
    Böylece örneğin aynı makinedeki iki prosesin haberleşmesi için UNIX domain soketler TCP/IP ve UDP/IP soketlerine göre çok daha 
    hızlı çalışmaktadır. Aynı makine üzerinde çok client'lı uygulamalar için UNIX domain soketler boru haberleşmesine ve mesaj 
    kuyruklarına göre organizasyonel avantaj bakımından tercih edilebilmektedir. Çünkü çok client'lı boru uygulamalarını ve mesaj 
    kuyruğu uygulamalarını yazmak daha zahmetlidir. Programcılar TCP/IP ve UDP/IP soket haberleşmesi yaparken kullandıkları 
    fonksiyonların aynısını UNIX domain soketlerde de kullanabilmektedir. Böylece örneğin elimizde bir TCP/IP ya da UDP/IP 
    client-server program varsa bu programı kolaylıkla UNIX domain soket kullanılacak biçimde değiştirebiliriz.

    UNIX domain soketlerin kullanımı en çok boru kullanımına benzemektedir. Ancak UNIX domain soketlerin borulara olan bir 
    üstünlüğü "full duplex" haberleşme sunmasıdır. Bilindiği gibi borular "half duplex" bir haberleşme sunmaktadır. Ancak 
    genel olarak boru haberleşmeleri UNIX domain soket haberleşmelere göre daha hızlı olma eğilimindedir.

    UNIX domain soketler kullanım olarak daha önce görmüş olduğumuz TCP/IP ve UDP/IP soketlerine çok benzemektedir. Yani işlemler
    sanki TCP/IP ya da UDP/IP client server program yazılıyormuş gibi yapılır. Başka bir deyişle UNIX domain soketlerinde client ve 
    server programların genel yazım adımları TCP/IP ve UDP/IP ile aynıdır.

    UNIX domain soketlerde client'ın server'a bağlanması için gereken adres bir dosya ismi yani yol ifadesi biçimindedir. Kullanılacak 
    yapı sockaddr_in değil, sockaddr_un yapısıdır. Bu yapı <sys/un.h> dosyası içerisinde bildirilmiştir ve en azından şu elemanlara 
    sahip olmak zorundadır:

    #include <sys/un.h>

    struct sockaddr_un {
        sa_family_t sun_family;
        char sun_path[108];
    };

    Yapının sun_family elemanı AF_UNIX biçiminde, sun_path elemanı da soketi temsil eden dosyanın yol ifadesi biçiminde girilmelidir. 
    Burada yol ifadesiyle belirtilen dosya bind işlemi tarafından yaratılmaktadır. Yaratılan bu dosyanın türü "ls -l komutunda" 
    "(s)ocket" biçiminde görüntülenmektedir. Eğer bu dosya zaten varsa bind fonksiyonu başarısız olur. Dolayısıyla bu dosyanın 
    varsa silinmesi gerekmektedir. O halde client ve server programlar işin başında bir isim altında anlaşmalıdır. Önemli bir 
    nokta da şudur: sockaddr_un yapısının kullanılmadan önce sıfırlanması gerekmektedir. bind tarafından yaratılan bu soket 
    dosyaları normal bir dosya değildir. Yani open fonksiyonuyla açılamamaktadır.

    UNIX domain soketlerde port numarası biçiminde bir kavramın olmadığına dikkat ediniz. Port numarası kavramı IP ailesinin
    aktarım katmanına ilişkin bir kavramdır. UNIX domain soketler AF_UNIX protokol ailesi ismiyle oluşturulan başka bir ailenin
    soketleridir.

    Pekiyi stream tabanlı UNIX domain soketlerde server accept uyguladığında client'a ilişkin sockaddr_un yapısından ne almaktadır?
    Aslında bu protokolde bir port kavramı olmadığına göre server bağlantıdan bir bilgi elde etmeyecektir. Fakat yine de 
    client program da bind uygulayıp ondan sonra sokete bağlanabilir. Bu durumda server, client bağlantısından sonra sockaddr_un
    yapısından client'ın bind ettiği soket dosyasının yol ifadesini elde eder.

    Aşağıdaki örnekte çok client'lı bir UNIX domain soket örneği verilmiştir. Örneğimizdeki server programda thread modeli
    kullanılmıştır. Yani server her client bağlantısında bir thread yaratmaktadır. Bu programların her ikisinde de komut 
    satırı argümanı olarak soket dosyasının yol ifadesi alınmaktadır. Bir soket dosyası zaten var ise bind işleminin başarısız
    olacağını anımsayınız. 
---------------------------------------------------------------------------------------------------------------------------*/

/* uds-server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

typedef struct tagCLIENT_INFO {
    int sock;
    struct sockaddr_un sun;
} CLIENT_INFO;

void *client_thread_proc(void *param);
char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_un sun_server, sun_client;
    socklen_t sun_len;
    CLIENT_INFO *ci;
    ssize_t result;
    pthread_t tid;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((server_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path, argv[1]);

    if (bind(server_sock, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    for (;;) {
        printf("waiting for connection...\n");
        sun_len = sizeof(sun_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sun_client, &sun_len)) == -1)
            exit_sys("accept");

        printf("Connected new client\n");

        if ((ci = (CLIENT_INFO *)malloc(sizeof(CLIENT_INFO))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }

        ci->sock = client_sock;
        ci->sun = sun_client;

        if ((result = pthread_create(&tid, NULL, client_thread_proc, ci)) != 0) {
            fprintf(stderr, "pthread_create: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }

        if ((result = pthread_detach(tid)) != 0) {
            fprintf(stderr, "pthread_detach: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }
    }

    close(server_sock);

    return 0;
}

void *client_thread_proc(void *param)
{
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    CLIENT_INFO *ci = (CLIENT_INFO *)param;
    ssize_t result;

    for (;;) {
        if ((result = recv(ci->sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received: %s\n", (intmax_t)result, buf);
        revstr(buf);
        if (send(ci->sock, buf, result, 0) == -1)
            exit_sys("send");
    }

    printf("client disconnected...\n");

    shutdown(ci->sock, SHUT_RDWR);
    close(ci->sock);

    free(ci);

    return NULL;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* uds-client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_un sun_server;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    char *str;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((client_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path, argv[1]);

    if (connect(client_sock, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
        exit_sys("connect");

    for (;;) {
        printf("Yazı giriniz:");
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if ((send(client_sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;

        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%ld bytes received: %s\n", (long)result, buf);
    }

    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                115. Ders 28/01/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte client program da bind işlemi uygulamaktadır. Böylece server client'ın soket ismini accept fonksiyonundan 
    elde edebilmektedir. Ancak uygulamada client'ın bu biçimde bind yapması genellikle tercih edilmemektedir. Eğer client'a bir 
    isim verilecekse sonraki paragrafta açıklanacağı gibi "soyut bir isim" verilmelidir. Buradaki örneğimizde yine server program 
    socket dosyasının yol ifadesi ile çalıştırılmalıdır. Client program da hem server soketin hem de client soketin yol ifadesi ile 
    çalıştırılmalıdır. Örneğin:

    $ ./uds-server serversock
    $ ./uds-client serversock clientsock
---------------------------------------------------------------------------------------------------------------------------*/

/* uds-server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

typedef struct tagCLIENT_INFO {
    int sock;
    struct sockaddr_un sun;
} CLIENT_INFO;

void *client_thread_proc(void *param);
char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_un sun_server, sun_client;
    socklen_t sun_len;
    CLIENT_INFO *ci;
    ssize_t result;
    pthread_t tid;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((server_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path, argv[1]);

    if (bind(server_sock, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    for (;;) {
        printf("waiting for connection...\n");
        sun_len = sizeof(sun_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sun_client, &sun_len)) == -1)
            exit_sys("accept");

        printf("Connected new client: %s\n", sun_client.sun_path);

        if ((ci = (CLIENT_INFO *)malloc(sizeof(CLIENT_INFO))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }

        ci->sock = client_sock;
        ci->sun = sun_client;

        if ((result = pthread_create(&tid, NULL, client_thread_proc, ci)) != 0) {
            fprintf(stderr, "pthread_create: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }

        if ((result = pthread_detach(tid)) != 0) {
            fprintf(stderr, "pthread_detach: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }
    }

    close(server_sock);

    return 0;
}

void *client_thread_proc(void *param)
{
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    CLIENT_INFO *ci = (CLIENT_INFO *)param;
    ssize_t result;

    for (;;) {
        if ((result = recv(ci->sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received from \"%s\": %s\n", (intmax_t)result, ci->sun.sun_path, buf);
        revstr(buf);
        if (send(ci->sock, buf, result, 0) == -1)
            exit_sys("send");
    }

    printf("\"%s\" client disconnected...\n", ci->sun.sun_path);

    shutdown(ci->sock, SHUT_RDWR);
    close(ci->sock);

    free(ci);

    return NULL;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* uds-client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_un sun_server, sun_client;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    char *str;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((client_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_client, 0, sizeof(sun_client));
    sun_client.sun_family = AF_UNIX;
    strcpy(sun_client.sun_path, argv[2]);

    if (bind(client_sock, (struct sockaddr *)&sun_client, sizeof(sun_client)) == -1)
        exit_sys("bind");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path, argv[1]);

    if (connect(client_sock, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
        exit_sys("connect");

    for (;;) {
        printf("Yazı giriniz:");
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if ((send(client_sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;

        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%ld bytes received: %s\n", (long)result, buf);
    }

    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında Linux sistemlerinde client'ın server'a kendini tanıtması için soyut (abstract) bir adres de oluşturulabilmektedir. 
    Client program sockaddr_un yapısındaki sun_path elemanının ilk byte'ını null karakter olarak geçip diğer byte'larına bir 
    bilgi girebilir. Client bu biçimde bind işlemi yaptığında artık soket dosyası yaratılmaz. Ancak bu isim accept ile karşı 
    tarafa iletilir. Dolayısıyla client'ın girmiş olduğu yol ifadesi aslında soyut bir yol ifadesi olarak client'ı tespit 
    etmek amacıyla kullanılabilir. Bu özelliğin POSIX standartlarında bulunmadığını, yalnızca Linux sistemlerine özgü olduğunu
    bir kez daha anımsatmak istiyoruz.

    Aşağıdaki örnekte client program bind işlemini yukarıda açıkladığımız gibi yapmaktadır. Dolayısıyla client program bir 
    soket yaratmamış olacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/* uds-server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

typedef struct tagCLIENT_INFO {
    int sock;
    struct sockaddr_un sun;
} CLIENT_INFO;

void *client_thread_proc(void *param);
char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_un sun_server, sun_client;
    socklen_t sun_len;
    CLIENT_INFO *ci;
    ssize_t result;
    pthread_t tid;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((server_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path, argv[1]);

    if (bind(server_sock, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    for (;;) {
        printf("waiting for connection...\n");
        sun_len = sizeof(sun_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sun_client, &sun_len)) == -1)
            exit_sys("accept");

        printf("Connected new client: %s\n", sun_client.sun_path + 1);

        if ((ci = (CLIENT_INFO *)malloc(sizeof(CLIENT_INFO))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }

        ci->sock = client_sock;
        ci->sun = sun_client;

        if ((result = pthread_create(&tid, NULL, client_thread_proc, ci)) != 0) {
            fprintf(stderr, "pthread_create: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }

        if ((result = pthread_detach(tid)) != 0) {
            fprintf(stderr, "pthread_detach: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }
    }

    close(server_sock);

    return 0;
}

void *client_thread_proc(void *param)
{
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    CLIENT_INFO *ci = (CLIENT_INFO *)param;
    ssize_t result;

    for (;;) {
        if ((result = recv(ci->sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received from \"%s\": %s\n", (intmax_t)result, ci->sun.sun_path + 1, buf);
        revstr(buf);
        if (send(ci->sock, buf, result, 0) == -1)
            exit_sys("send");
    }

    printf("\"%s\" client disconnected...\n", ci->sun.sun_path + 1);

    shutdown(ci->sock, SHUT_RDWR);
    close(ci->sock);

    free(ci);

    return NULL;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* uds-client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_un sun_server, sun_client;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    char *str;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((client_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_client, 0, sizeof(sun_client));
    sun_client.sun_family = AF_UNIX;
    strcpy(sun_client.sun_path + 1, argv[2]);

    if (bind(client_sock, (struct sockaddr *)&sun_client, sizeof(sun_client)) == -1)
        exit_sys("bind");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path, argv[1]);

    if (connect(client_sock, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
        exit_sys("connect");

    for (;;) {
        printf("Yazı giriniz:");
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if ((send(client_sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;

        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%ld bytes received: %s\n", (long)result, buf);
    }

    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında Linux sistemlerinde server program da bind işlemini yaparken soyut isim kullanabilir. Yani server program da aslında 
    sockaddr_un yapısındaki sun_path elemanının ilk karakterini null karakter yapıp diğer karakterlerine soketin ismini 
    yerleştirebilir. Bu durumda haberleşme sırasında gerçekte hiçbir soket dosyası yaratılmayacaktır. Tabii soket dosyalarının 
    önemli bir işlevi erişim haklarına sahip olmasıdır. Soyut isimler kullanıldığında böyle bir erişim hakkı kontrolü 
    yapılmamaktadır.

    Aşağıdaki örnekte server program da soyut bir isim kullanmaktadır. Buradaki haberleşmede hiç soket dosyasının yaratılmayacağına
    dikkat ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* uds-server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

typedef struct tagCLIENT_INFO {
    int sock;
    struct sockaddr_un sun;
} CLIENT_INFO;

void *client_thread_proc(void *param);
char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int server_sock, client_sock;
    struct sockaddr_un sun_server, sun_client;
    socklen_t sun_len;
    CLIENT_INFO *ci;
    ssize_t result;
    pthread_t tid;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((server_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path + 1, argv[1]);

    if (bind(server_sock, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
        exit_sys("bind");

    if (listen(server_sock, 8) == -1)
        exit_sys("listen");

    for (;;) {
        printf("waiting for connection...\n");
        sun_len = sizeof(sun_client);
        if ((client_sock = accept(server_sock, (struct sockaddr *)&sun_client, &sun_len)) == -1)
            exit_sys("accept");

        printf("Connected new client: %s\n", sun_client.sun_path + 1);

        if ((ci = (CLIENT_INFO *)malloc(sizeof(CLIENT_INFO))) == NULL) {
            fprintf(stderr, "cannot allocate memory!...\n");
            exit(EXIT_FAILURE);
        }

        ci->sock = client_sock;
        ci->sun = sun_client;

        if ((result = pthread_create(&tid, NULL, client_thread_proc, ci)) != 0) {
            fprintf(stderr, "pthread_create: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }

        if ((result = pthread_detach(tid)) != 0) {
            fprintf(stderr, "pthread_detach: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }
    }

    close(server_sock);

    return 0;
}

void *client_thread_proc(void *param)
{
    char buf[BUFFER_SIZE + 1];        // BUFFER_SIZE is enough
    CLIENT_INFO *ci = (CLIENT_INFO *)param;
    ssize_t result;

    for (;;) {
        if ((result = recv(ci->sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%jd byte(s) received from \"%s\": %s\n", (intmax_t)result, ci->sun.sun_path + 1, buf);
        revstr(buf);
        if (send(ci->sock, buf, result, 0) == -1)
            exit_sys("send");
    }

    printf("\"%s\" client disconnected...\n", ci->sun.sun_path + 1);

    shutdown(ci->sock, SHUT_RDWR);
    close(ci->sock);

    free(ci);

    return NULL;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* uds-client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int client_sock;
    struct sockaddr_un sun_server, sun_client;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    char *str;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((client_sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_client, 0, sizeof(sun_client));
    sun_client.sun_family = AF_UNIX;
    strcpy(sun_client.sun_path + 1, argv[2]);

    if (bind(client_sock, (struct sockaddr *)&sun_client, sizeof(sun_client)) == -1)
        exit_sys("bind");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path + 1, argv[1]);

    if (connect(client_sock, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
        exit_sys("connect");

    for (;;) {
        printf("Yazı giriniz:");
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if ((send(client_sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;

        if ((result = recv(client_sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%ld bytes received: %s\n", (long)result, buf);
    }

    close(client_sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX domain soketler aynı makinenin prosesleri arasında haberleşme sağladığına göre bunlarda send işlemi ile gönderilen 
    bilginin tek bir recv işlemi ile alınması beklenir. Gerçekten de Linux sistemlerinde tasarım bu biçimde yapılmıştır. 
    Ancak POSIX standartları bu konuda bir garanti vermemektedir. Ancak Linux sistemlerinde tıpkı borularda olduğu gibi bu işlem 
    için ayrılan tampon büyüklüğünden fazla miktarda byte send (ya da write) ile gönderildiğinde parçalı okuma gerçekleşebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX domain soketlerde datagram haberleşme de yapılabilir. Bu haberleşme mesaj kuyruklarına bir seçenek oluşturmaktadır. 
    UNIX domain soketlerde datagram haberleşmede gönderilen datagram'ların aynı sırada alınması garanti edilmiştir. Yani 
    gönderim UDP/IP'de olduğu gibi güvensiz değil, güvenlidir. Anımsanacağı gibi UDP/IP'de gönderilen datagram'lar hedefe farklı
    sıralarda ulaşabiliyordu. Aynı zamanda bir datagram ağda kaybolursa bunun bir telafisi söz konusu değildi. UNIX domain 
    soketlerde her şey aynı makinede ve işletim sisteminin kontrolü altında gerçekleştirildiği için böylesi bir durum söz konusu
    olmayacaktır.

    Aşağıda UNIX domain soketler kullanılarak bir datagram haberleşme örneği verilmiştir. Burada server hiç bağlantı sağlamadan 
    herhangi bir client'tan paketi alır, oradaki yazıyı ters çevirip ona geri gönderir. Hem client hem de server ayrı ayrı iki 
    dosya ismi ile bind işlemi yapmaktadır. Server program komut satırı argümanı olarak kendi bind edeceği soket dosyasının 
    yol ifadesini, client program ise hem kendi bind edeceği soket dosyasının yol ifadesini hem de server soketin yol ifadesini 
    almaktadır. Bu örnekte server ve client önce remove fonksiyonu ile daha önce yaratılan soket dosyasını aynı zamanda silmektedir.

    Aşağıda UNIX domain datagram sokete ilişkin bir örnek verilmiştir. Örnekte client server'a bir datagram mesaj göndermekte ve 
    server da onu ters çevirip client'a geri yollamaktadır. Server program, server soketin yol ifadesini komut satırı argümanı 
    olarak almaktadır. Client program da hem server soketin yol ifadesini hem de client soketin yol ifadesini komut satırı 
    argümanı olarak almaktadır. Programları şöyle çalıştırabilirsiniz:

    $ ./uds-dg-server serversock
    $ ./uds-dg-client serversock clientsock
---------------------------------------------------------------------------------------------------------------------------*/

/* uds-dg-server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct sockaddr_un sun_server, sun_client;
    socklen_t sun_len;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((sock = socket(AF_UNIX, SOCK_DGRAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path, argv[1]);

    if (remove(argv[1]) == -1 && errno != ENOENT)
        exit_sys("remove");

    if (bind(sock, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
        exit_sys("bind");

    printf("Waiting for client data...\n");

    for (;;) {
        sun_len = sizeof(sun_client);
        if ((result = recvfrom(sock, buf, BUFFER_SIZE, 0, (struct sockaddr *)&sun_client, &sun_len)) == -1)
            exit_sys("recvfrom");

        buf[result] = '\0';
        printf("%ld bytes received from \"%s\": %s\n", (long)result, sun_client.sun_path, buf);

        revstr(buf);
        if (sendto(sock, buf, strlen(buf), 0, (struct sockaddr *)&sun_client, sizeof(sun_client)) == -1)
            exit_sys("sendto");
    }

    close(sock);

    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* uds-dg-client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct sockaddr_un sun_client, sun_server, sun_response;
    socklen_t sun_len;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((sock = socket(AF_UNIX, SOCK_DGRAM, 0)) == -1)
        exit_sys("socket");

    memset(&sun_client, 0, sizeof(sun_client));
    sun_client.sun_family = AF_UNIX;
    strcpy(sun_client.sun_path, argv[2]);

    if (remove(argv[2]) == -1 && errno != ENOENT)
        exit_sys("remove");

    if (bind(sock, (struct sockaddr *)&sun_client, sizeof(sun_client)) == -1)
        exit_sys("bind");

    memset(&sun_server, 0, sizeof(sun_server));
    sun_server.sun_family = AF_UNIX;
    strcpy(sun_server.sun_path, argv[1]);

    for (;;) {
        printf("Yazı giriniz:");
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;

        if (sendto(sock, buf, strlen(buf), 0, (struct sockaddr *)&sun_server, sizeof(sun_server)) == -1)
            exit_sys("sendto");

        sun_len = sizeof(sun_server);
        if ((result = recvfrom(sock, buf, BUFFER_SIZE, 0, (struct sockaddr *)&sun_response, &sun_len)) == -1)
            exit_sys("recvfrom");

        buf[result] = '\0';
        printf("%ld bytes received from \"%s\": %s\n", (long)result, sun_response.sun_path, buf);
    }

    close(sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                116. Ders 02/02/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX domain soketler "isimsiz boru haberleşmesine" benzer biçimde de kullanılabilmektedir. Anımsanacağı gibi isimsiz borularla
    yalnızca üst ve alt prosesler arasında haberleşme yapılabiliyordu. Yine anımsayacağınız gibi pipe fonksiyonu bize iki 
    betimleyici veriyordu. Biz de fork işlemi ile bu betimleyicileri alt prosese geçiriyorduk. İşte isimsiz borularla yapılan 
    şeylerin benzeri soketlerle de yapılabilmektedir. İsimsiz soketlere İngilizce "unbound sockets" de denilmektedir.
    İsimsiz (unbound) soket yaratımı socketpair isimli fonksiyonla yapılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <sys/socket.h>

    int socketpair(int domain, int type, int protocol, int sv[2]);

    Fonksiyonun birinci parametresi protokol ailesinin ismini alır. Her ne kadar fonksiyon genel olsa da pek çok işletim sistemi 
    bu fonksiyonu yalnızca UNIX domain soketler için gerçekleştirmektedir. (Gerçekten de üst ve alt prosesler arasında UNIX domain 
    soketler varken örneğin TCP/IP soketleriyle haberleşmenin zarardan başka bir faydası olmayacaktır.) Linux sistemleri isimsiz 
    soket olarak yalnızca UNIX domain soketlerini desteklemektedir. Dolayısıyla bu birinci parametre Linux sistemlerinde AF_UNIX 
    biçiminde geçilmelidir. Fonksiyonun ikinci parametresi kullanılacak soketin türünü belirtir. Bu parametre yine SOCK_STREAM 
    ya da SOCK_DGRAM biçiminde girilmelidir. Üçüncü parametre kullanılacak transport katmanını belirtmektedir. Bu parametre 0 olarak 
    geçilebilir. Son parametre bir çift soket betimleyicisinin yerleştirileceği iki elemanlı int türden dizinin başlangıç adresini 
    almaktadır. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Örneğin:

    int socks[2];

    if (socketpair(AF_UNIX, SOCK_STREAM, 0, socks) == -1)
        exit_sys("socketpair");

    socketpair fonksiyonu SOCK_STREAM soketler için zaten bağlantı sağlanmış iki soketi bize vermektedir. Yani bu fonksiyon 
    çağrıldıktan sonra listen, accept, connect gibi fonksiyonların çağrılması gereksizdir. Dolayısıyla tipik haberleşme şöyle 
    gerçekleştirilmektedir:

    1) socketpair fonksiyonu ile soket çifti yaratılır.

    2) Soket çifçi yaratıldıktan sonra fork ile alt proses yaratılır.

    3) İki taraf da kullanmayacakları soketleri kapatırlar. Hangi prosesin socketpair fonksiyonunun son parametresine yerleştirilen
    hangi soket betimleyicisini kullanacağının bir önemi yoktur.

    4) Haberleşme soket fonksiyonlarıyla gerçekleştirilir.

    Pekiyi isimsiz borularla socketpair fonksiyonuyla oluşturulan isimsiz UNIX domain soketler arasında ne fark vardır?
    Aslında bu iki kullanım benzer etkilere sahiptir. Ancak en önemli farklılık UNIX domain soketlerin çift yönlü (full duplex)
    bir haberleşme sağlamasıdır. Normalde isimsiz mesaj kuyrukları olmadığına dikkat ediniz. Halbuki isimsiz UNIX domain soketler 
    sanki isimsiz mesaj kuyrukları gibi de kullanılabilmektedir.

    Aşağıdaki programda tıpkı isimsiz boru haberleşmesinde olduğu gibi üst ve alt prosesler birbirleri arasında isimsiz UNIX 
    domain soketler yoluyla haberleşmektedir. Buradaki soketlerin çift yönlü haberleşmeye olanak verdiğini anımsayınız.
---------------------------------------------------------------------------------------------------------------------------*/

/* uds-socketpair.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/socket.h>

#define BUFFER_SIZE        1024

char *revstr(char *str);
void exit_sys(const char *msg);

int main(void)
{
    int socks[2];
    char buf[BUFFER_SIZE + 1];
    char *str;
    ssize_t result;
    pid_t pid;

    if (socketpair(AF_UNIX, SOCK_STREAM, 0, socks) == -1)
        exit_sys("socketpair");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {        /* parent */
        close(socks[1]);

        for (;;) {
            if ((result = recv(socks[0], buf, BUFFER_SIZE, 0)) == -1)
                exit_sys("recv");
            if (result == 0)
                break;
            buf[result] = '\0';
            if (!strcmp(buf, "quit"))
                break;
            revstr(buf);
            if (send(socks[0], buf, strlen(buf), 0) == -1)
                exit_sys("send");
        }

        if (waitpid(pid, NULL, 0) == -1)
            exit_sys("waitpid");

        close(socks[0]);

        exit(EXIT_SUCCESS);
    }
    else {            /* child */
        close(socks[0]);

        for (;;) {
            printf("Yazı giriniz:");
            if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
                continue;
            if ((str = strchr(buf, '\n')) != NULL)
                *str = '\0';
            if ((send(socks[1], buf, strlen(buf), 0)) == -1)
                exit_sys("send");
            if (!strcmp(buf, "quit"))
                break;
            if ((result = recv(socks[1], buf, BUFFER_SIZE, 0)) == -1)
                exit_sys("recv");
            if (result == 0)
                break;
            buf[result] = '\0';

            printf("%ld bytes received: %s\n", (long)result, buf);
        }

        close(socks[1]);
        exit(EXIT_SUCCESS);
    }

    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bu bölümde TCP ve UDP protokollerinin aşağı seviyeli çalışma mekanizması üzerinde durulacaktır. Ancak bu protokollerin aşağı
    seviyeli çalışma biçimleri biraz karmaşıktır. Biz burada çok derine inmeden bu çalışma biçimini açıklayacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP protokolü 1981 yılında RFC 793 dokümanı ile tanımlanmıştır (https://tools.ietf.org/html/rfc793). Sonradan protokole 
    bazı revizyonlar ve eklemeler de yapılmıştır. Protokolün son güncel versiyonu 2022'de RFC 9293 dokümanında tanımlanmıştır.

    Paket tabanlı protokollerin hepsinde gönderilip alınan veriler paket biçimindedir (yani bir grup byte biçimindedir). Bu paketlerin
    "başlık (header) ve veri (data)" kısımları vardır. Örneğin "Ethernet paketinin başlık ve veri kısmı", "IP paketinin başlık ve 
    veri kısmı", "TCP paketinin başlık ve veri kısmı" bulunmaktadır. Öte yandan TCP protokolü aslında IP protokolünün üzerine 
    oturtulmuştur. Yani aslında TCP paketleri IP paketleri gibi gönderilip alınmaktadır. Nihayet aslında bu paketler bilgisayarımıza 
    Ethernet ya da Wireless paketi olarak gelmektedir. Paketlerin başlık kısımlarında önemli "metadata" bilgileri bulunmaktadır. 
    O halde örneğin aslında bizim network kartımıza bilgiler Ethernet paketi gibi gelmektedir. Aslında IP paketi Ethernet paketinin 
    veri kısmında, TCP paketi de aslında IP paketinin veri kısmında konuşlandırılmaktadır. Yani aslında bize gelen Ethernet paketinin 
    veri kısmında IP paketi, IP paketinin veri kısmında da TCP paketi bulunmaktadır. TCP'de gönderdiğimiz veriler aslında IP paketinin 
    veri kısmını oluşturmaktadır.

    Örneğin bir host'tan diğerine bir TCP paketinin gönderildiğini düşünelim. TCP paketi "TCP Header" ve "TCP Data" kısmından oluşmaktadır:

    +-------------------------+
    |        TCP Header       |
    +-------------------------+
    |         TCP Data        |
    +-------------------------+

    Ancak TCP paketi aslında IP paketi gibi gönderilmektedir. IP paketi de "IP Header" ve "IP Data" kısımlarından oluşmaktadır. 
    İşte aslında TCP paketi IP paketinin Data kısmında bulundurulur. Yani yolculuk eden TCP paketinin görünümü şöyledir:

    +-------------------------+
    |        IP Header        |
    +-------------------------+   <---+
    |        TCP Header       |       |
    +-------------------------+     IP Data
    |         TCP Data        |       |
    +-------------------------+   <---+

    TCP paketi de bilgisayarımızın Ethernet kartına sanki Ethernet paketi gibi gelmektedir. Ethernet paketi de "Ethernet Header" ve 
    "Ethernet Data" kısımların oluşmaktadır. İşte bütün TCP paketi aslında IP paketi gibi IP paketi de Ethernet paketi gibi gönderilip 
    alınmaktadır:

    +-------------------------+
    |     Ethernet Header     |
    +-------------------------+   <----------------+
    |        IP Header        |                    |
    +-------------------------+   <---+            |
    |        TCP Header       |       |       Ethernet Data
    +-------------------------+     IP Data        |
    |         TCP Data        |       |            |
    +-------------------------+   <---+------------+

    Bu durumu aşağıdaki gibi de gösterebiliriz:

    +-------------------------+
    |     Ethernet Header     |
    +----+--------------------+----+
         |        IP Header        |
         +----+--------------------+----+
              |        TCP Header       |
              +----+--------------------+----+
                   |         TCP Data        |
                   +-------------------------+

    Örneğin biz TCP'de send fonksiyonuyla "ankara" yazısını gönderiyor olalım. Bu "ankara" yazısını oluşturan byte'lar aslında 
    TCP paketinin veri kısmındadır.

    +-------------------------+
    |     Ethernet Header     |
    +----+--------------------+----+
         |        IP Header        |
         +----+--------------------+----+
              |        TCP Header       |
              +----+--------------------+----+
                   |         "ankara"        |
                   +-------------------------+

    Ethernet protokolü (IEEE 802.3) OSI katmanına göre fiziksel ve veri bağlantı katmanının işlevlerini yerine getirmektedir.
    Wireless haberleşme için kullanılan Wi-Fi protokolü (IEEE 802.11) Ethernet protokolünün telsiz (wireless) biçimi gibi düşünülebilir.

    Tabii IP paketleri aslında yalnızca bilgisayarımıza gelirken Ethernet paketi ya da Wi-Fi paketi olarak gelir. Dışarıda rotalanırken 
    Ethernet paketi söz konusu değildir.

    IP protokolünün IPv4 ve IPv6 biçiminde iki versiyonunun olduğunu anımsayınız. Ancak TCP ve UDP protokollerinin böyle bir 
    versiyon numarası yoktur. TCP paketi IPv4 paketinin veri kısmında da IPv6 paketinin veri kısmında da konuşlandırılmış olabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yerel ağımızda aslında router tarafından gönderilip alınan paketlerin hepsi yerel ağdaki tüm bilgisayarlara ulaşmaktadır. 
    Ethernet ve Wireless kartları yalnızca kendilerini ilgilendiren paketleri alıp işletim sistemini haberdar edebilmektedir. 
    Ancak bu kartlar için yazılmış özel programlar sayesinde bilgisayarımıza ulaşan tüm paketler incelenebilmektedir. Bu tür
    yardımcı programlara "network sniffer" da denilmektedir.

    En yaygın kullanılan "network sniffer" program "wireshark" isimli open source programdır. Bu programın eskiden ismi 
    "Ethereal" biçimindeydi. Aslında wireshark programı "libpcap" isimli open source kütüphane kullanılarak yazılmıştır. Yani
    asıl işlevsellik bu kütüphanededir. Wireshark adeta libpcap kütüphanesinin bir önyüzü (front-end) gibidir. Bu kütüphanenin 
    Windows versiyonuna "npcap" denilmektedir. Linux Debian türevi sistemlerde kütüphane aşağıdaki gibi indirilebilir:

    $ sudo apt-get install libpcap-dev

    Benzer biçimde Linux'ta wireshark programını da GUI arayüzü yazılım yöneticisinden yüklenebileceği gibi komut satırından 
    Debian türevi sistemlerde aşağıdaki gibi yüklenebilir:

    $ sudo apt-get install wireshark

    Wireshark programının kullanımına ilişkin pek çok "tutorial" bulunmaktadır. Kursumuzun EBooks klasöründe de birkaç kitap
    bulunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    IPv4 protokolünün başlık (header) kısmı şöyledir (her satırda 4 byte bulunmaktadır). Toplam başlık uzunluğu 20 byte'dır.

    <------- Byte 1 -------><------- Byte 2 -------><------- Byte 3 -------><------- Byte 4 ------->
    +-----------+-----------+----------------------+-----------------------------------------------+             ^
    |  Version  |    IHL    |    Type of Service   |                  Total Length                 |  (4 bytes)  |
    | (4 bits)  | (4 bits)  |       (8 bits)       |                   (16 bits)                   |             |
    +-----------+-----------+----------------------+-----------+-----------------------------------+             |
    |                 Identification               |   Flags   |           Fragment Offset         |  (4 bytes)  |
    |                   (16 bits)                  |  (3 bits) |              (13 bits)            |             |
    +-----------------------+----------------------+-----------+-----------------------------------+             |
    |   Time to Live (TTL)  |       Protocol       |                 Header Checksum               |  (4 bytes)  |  20 bytes
    |         (8 bits)      |       (8 bits)       |                    (16 bits)                  |             |
    +-----------------------+----------------------+-----------------------------------------------+             |
    |                                  Source IP Address (32 bits)                                 |  (4 bytes)  |
    +----------------------------------------------------------------------------------------------+             |
    |                               Destination IP Address (32 bits)                               |  (4 bytes)  |
    +----------------------------------------------------------------------------------------------+             v
    |                            Segment (L4 protocol (TCP/UDP) + Data)                            |
    +----------------------------------------------------------------------------------------------+

    Version : IP versiyonunu içerir. IPv4 ya da IPv6 değerlerinden birini içermektedir. IPv4 için 4 değeri kullanılmaktadır. (0100)
    IHL : Internet Header Length bilgisini içermektedir. Genelde 20 byte değerini içerir. Fakat farklı değerler aldığı durumlar da 
    söz konusu olabilmektedir.
    Type of Service : DS / DSCP / ECN alanlarını içermektedir. Paket önceliği konusunda kullanılmaktadır.
    Total Length : Header ve data'nın toplam uzunluk bilgisini içermektedir.
    Identification, Flags, Frament Offset : Paketin ikinci 4 byte'lık kısmı fragmentation için kullanılmaktadır.
    Time to Live (TTL) : Paketin yaşam ömrünün bilgisini içermektedir. Yaşam ömrü her router geçildiğinde bir azalmaktadır. Eğer 
    TTL değeri 0 olursa paket router tarafından çöpe atılmaktadır. TTL genel olarak yolunu şaşırmış paketlerin network'lerde sonsuza 
    kadar dolaşmasını önlemek için kullanılmaktadır. Bazen de paket router'lar arasında bir loop (routing loop) içerisinde takılıp 
    kalmaktadır. TTL, bu gibi durumları engellemek için kullanılmaktadır. Dünya'da en uzak noktaya bile data gönderirken maksimum 
    15-20 router geçilmektedir.
    Protocol : L4 protokol bilgisini içermektedir. Örneğin, TCP için 6, UDP için 17, ICMP için 1 değerlerini içermektedir.
    Header Checksum : Router'lar IP paket header'ının yolda bozulup bozulmadığını bu değeri kontrol ederek sağlayabilmektedir.
    Source IP Address : Kaynak IP adresinin unicast IP adresi olması gerekmektedir.
    Destination IP Address : Hedef IP adresi unicast, broadcast ve multicast IP adresi olabilir.

    Buradan da gördüğünüz gibi IP başlığında kaynak ve hedef IP adresleri ve IP paketinin toplam uzunluğu bulunmaktadır. Port
    kavramının IP protokolünde olmadığını anımsayınız.

    IPv6 header kısmı aşağıda verilmiştir. Toplam başlık uzunluğu 40 byte'a sabitlenmiştir.

    <------- Byte 1 -------><------- Byte 2 -------><------- Byte 3 -------><------- Byte 4 ------->
    +-----------+-----------------+----------------------------------------------------------------+             ^
    |  Version  |  Traffic Class  |                           Flow Label                           |  (4 bytes)  |
    | (4 bits)  |    (4 bits)     |                                                                |             |
    +-----------+-----------------+----------------+-----------------------+-----------------------+             |
    |                 Payload Length               |      Next Header      |       Hop Limit       |  (4 bytes)  |
    |                   (16 bits)                  |                       |                       |             |
    +----------------------------------------------+-----------------------+-----------------------+             |
    |                                                                                              |             |
    |                                                                                              |             |
    |                                                                                              |             |
    |                                                                                              |             |
    |                                 Source IP Address (128 bits)                                 | (16 bytes)  |
    |                                                                                              |             |  40 bytes
    |                                                                                              |             |
    |                                                                                              |             |
    +----------------------------------------------------------------------------------------------+             |
    |                                                                                              |             |
    |                                                                                              |             |
    |                                                                                              |             |
    |                                                                                              |             |
    |                              Destination IP Address (128 bits)                               | (16 bytes)  |
    |                                                                                              |             |
    |                                                                                              |             |
    |                                                                                              |             |
    +----------------------------------------------------------------------------------------------+             v

    Version : IP versiyonunu içerir. IPv6 için 6 değeri kullanılmaktadır. (0110)
    Traffic Class : Paket önceliği konusunda kullanılmaktadır.
    Flow Label : Bir sunucuyla yapılan haberleşme için bir numara belirlenmektedir ve haberleşme boyunca bütün paketlerde 
    bu numara kullanılarak iletişim sağlanmaktadır. Farklı amaçlar için de kullanıldığı durumlar vardır.
    Payload Length : Datanın boyutunu içermektedir.
    Next Header : L4 protokol bilgisini içermektedir.
    Hop Limit : IPv4'teki TTL alanıyla aynıdır.

    TCP paketi yukarıda da belirttiğimiz gibi IP paketinin veri (data) kısmındadır. TCP paketi de "TCP Header" ve "TCP Data" 
    kısımlarından oluşmaktadır. TCP başlık kısmı şöyledir. (her satırda 4 byte bulunmaktadır):

    <------- Byte 1 -------><------- Byte 2 -------><------- Byte 3 -------><------- Byte 4 ------->
    +----------------------------------------------+-----------------------------------------------+             ^
    |                  Source Port                 |                Destination Port               |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             |
    |                                        Sequence Number                                       |  (4 bytes)  |
    |                                          (32 bits)                                           |             |
    +----------------------------------------------------------------------------------------------+             |
    |                                    Acknowledgement Number                                    |  (4 bytes)  |
    |                                          (32 bits)                                           |             |  20 bytes
    +-----------+----------------+-----------------+-----------------------------------------------+             |
    |Header Len.|    Reserved    |   Control Bits  |                  Window Size                  |  (4 bytes)  |
    |  (4 bits) |    (6 bits)    |     (6 bits)    |                   (16 bits)                   |             |
    +-----------+----------------+-----------------+-----------------------------------------------+             |
    |                   Checksum                   |                     Urgent                    |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             v
    |                                           Options                                            |
    |                                        (0 or 32 bits)                                        |
    +----------------------------------------------------------------------------------------------+
    |                                    Application Layer Data                                    |
    |                                         (Size Varies)                                        |
    +----------------------------------------------------------------------------------------------+

    Burada her satır 32 bit yani 4 byte yer kaplamaktadır. TCP başlığı 20 byte'tan 60 byte'a kadar değişen uzunlukta olabilir. 
    Başlıktaki Header Length TCP data'sının hangi offset'ten başladığını dolayısıyla TCP başlığının DWORD (4 byte olarak) uzunluğunu 
    belirtir. Yani başlığın byte uzunluğu için buradaki değer 4 ile çarpılmalıdır. Böylece Header Length kısmında en az 5 
    (toplam 20 byte) en fazla 15 (toplam 60 byte) değeri bulunabilir. Bu başlıkta kaynak ve hedef IP adreslerinin ve TCP data 
    kısmının uzunluğunun bulunmadığına dikkat ediniz. Çünkü bu bilgiler zaten IP başlığında doğrudan ya da dolaylı biçimde 
    bulunmaktadır. TCP paketi her zaman IP paketinin data kısmında konuşlandırılmaktadır.

    Başlıktaki Control Bits alanı 6 bitten oluşmaktadır. Her bit bir özelliği temsil eder. Buradaki belli bitler set edildiğinde 
    başlıktaki belli alanlar da anlamlı hale gelebilmektedir. Buradaki bitler yani flag'ler şunlardır: URG, ACK, PSH, RST, 
    SYN, FIN. Flags alanındaki birden fazla bit 1 olabilir. Yani birden fazla flag set edilmiş olabilir. Bir TCP paketi 
    (TCP segment) yalnızca başlık içerebilir. Yani hiç data içermeyebilir. Başka bir deyişle TCP paketinin data kısmı 0 byte 
    uzunluğunda olabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                117. Ders 04/02/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP protokolünde o anda iki tarafın da bulunduğu bir "durum (state)" vardır. Taraflar belli eylemler sonucunda durumdan
    duruma geçiş yaparlar. Bu nedenle TCP'nin çalışması bir "sonlu durum makinesi (finite state machine)" biçiminde ele alınıp 
    açıklanabilir. Henüz bağlantı yoksa iki taraf da CLOSED denilen durumdadır. TCP'de tarafların hangi olaylar sonucunda
    hangi durumda olduklarına ilişkin diyagrama "durum diyagramı (state diagram)" denilmektedir. (TCP durum diyagramı için 
    Google'da "TCP state diagram" araması ile görsellerden çizilmiş diyagramları görebilirsiniz.)

    TCP bağlantısının kurulması için client ile server data kısmı boş olan (yani yalnızca başlık kısmı bulunan) paketleri gönderip 
    almaktadır. Buna el sıkışma (hand shaking) denilmektedir. TCP'de bağlantı kurulması için yapılan el sıkışma 4'lü (four way) 
    ya da 3'lü (three way) olabilir. Burada 3'lü demekle bağlantı için toplam 3 paketin yolculuk etmesi, 4'lü demekle toplam 4 
    paketin yolculuk etmesi kastedilmektedir. Uygulamada daha çok 3'lü el sıkışma kullanılmaktadır.

    TCP'de bağlantının kurulabilmesi için "iki tarafın da birbirlerine SYN biti set edilmiş data kısmı olmayan TCP paketi 
    (20 byte) gönderip karşı taraftan ACK biti set edilmiş data'sı olmayan TCP paketi alması" gerekir. Yukarıda da belirttiğimiz
    gibi bunun iki yolu olabilir:

          Client                                 Server

    +-----------------+                    +-----------------+
    |      CLOSED     |                    |      LISTEN     |
    +-----------------+                    +-----------------+
                        ------- SYN ----->
    +-----------------+
    |     SYN-SENT    |
    +-----------------+
                        <------ ACK ------
                        <------ SYN ------
    +-----------------+                    +-----------------+
    |   ESTABLISHED   |                    |   SYN-RECEIVED  |
    +-----------------+                    +-----------------+
                        ------- ACK ----->
                                           +-----------------+
                                           |   ESTABLISHED   |
                                           +-----------------+

    Burada 4 paket kullanıldığı için buna 4'lü el sıkışma denilmektedir. Yukarıdaki bağlantı kurulurken iki tarafın TCP 
    durumunu (state) da belirttik. Server bağlantı sırasında ACK ile SYN bitini tek bir paket olarak da gönderilebilir. 
    (Yani paketin Flags kısmında hem SYN hem de ACK biti set edilmiş olabilir.) Buna 3'lü el sıkışma denilmektedir:

          Client                                 Server

    +-----------------+                    +-----------------+
    |      CLOSED     |                    |      LISTEN     |
    +-----------------+                    +-----------------+
                        ------- SYN ----->
    +-----------------+
    |     SYN-SENT    |
    +-----------------+
                        <--- SYN + ACK ---
                                           +-----------------+
                                           |   SYN-RECEIVED  |
                                           +-----------------+
                        ------- ACK ----->
    +-----------------+                    +-----------------+
    |   ESTABLISHED   |                    |   ESTABLISHED   |
    +-----------------+                    +-----------------+

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bağlantının kopartılması için iki tarafın da birbirlerine FIN biti set edilmiş paketler gönderip ACK biti set edilmiş 
    paketleri alması gerekir. Bağlantının kopartılması da tipik olarak 3'lü ya da 4'lü el sıkışma yoluyla yapılmaktadır. 
    FIN ve ACK paketleri ayrı ayrı gönderilirse 4'lü el sıkışma tek bir paket olarak gönderilirse 3'lü el sıkışma gerçekleşir. 
    Bağlantının kopartılması talebini herhangi bir taraf başlatabilir. 4'lü el sıkışma ile bağlantının kopartılması şöyle
    yapılmaktadır:

          Peer - 1                               Peer - 2

    +-----------------+                    +-----------------+
    |   ESTABLISHED   |                    |   ESTABLISHED   |
    +-----------------+                    +-----------------+
                        ------- FIN ----->
    +-----------------+                    +-----------------+
    |    FIN-WAIT-1   |                    |    CLOSE_WAIT   |
    +-----------------+                    +-----------------+
                        <------ ACK ------
    +-----------------+
    |    FIN-WAIT-2   |
    +-----------------+
                        <------ FIN ------
                                           +-----------------+
                                           |     LAST-ACK    |
                                           +-----------------+
                        ------- ACK ----->
    +-----------------+                    +-----------------+
    |    TIME-WAIT    |                    |      CLOSED     |
    +-----------------+                    +-----------------+
    +-----------------+
    |      CLOSED     |
    +-----------------+

    Burada iki taraf da birbirlerine FIN biti set edilmiş data kısmı olmayan TCP paketleri gönderip ACK biti set edilmiş data 
    kısmı olmayan TCP paketleri almıştır. 3'lü el sıkışma ile bağlantının kopartılmasında bir taraf tek bir pakette hem FIN biti 
    set edilmiş hem de ACK biti set edilmiş paket göndermektedir:

          Peer - 1                               Peer - 2

    +-----------------+                    +-----------------+
    |   ESTABLISHED   |                    |   ESTABLISHED   |
    +-----------------+                    +-----------------+
                        ------- FIN ----->
    +-----------------+                    +-----------------+
    |    FIN-WAIT-1   |                    |    CLOSE_WAIT   |
    +-----------------+                    +-----------------+
                        <--- FIN + ACK ---
    +-----------------+                    +-----------------+
    |    FIN-WAIT-2   |                    |     LAST-ACK    |
    +-----------------+                    +-----------------+
                        ------- ACK ----->
    +-----------------+                    +-----------------+
    |    TIME-WAIT    |                    |      CLOSED     |
    +-----------------+                    +-----------------+
    +-----------------+
    |      CLOSED     |
    +-----------------+

    Burada özetle bir taraf önce karşı tarafa FIN paketi yollamıştır. Karşı taraf buna ACK+FIN ile karşılık vermiştir. Diğer taraf 
    da son olarak karşı tarafa ACK yollamıştır. Ancak bağlantıyı kopartmak isteyen taraf bu ACK yollama işinden sonra MSL (Maximum Segment Life) 
    denilen bir zaman aralığının iki katı kadar beklemektedir (Tipik olarak 2 dakika). MSL bir paketin kaybolduğuna karar verilmesi 
    için gereken zamanı belirtmektedir. (Eğer alıcı taraf beklemeden hemen CLOSED duruma geçseydi bu durumda gönderici taraf yeniden 
    bağlantı kurduğunda henüz alıcı taraf paketi almamışsa sanki eski bağlantı devam ettiriliyormuş gibi bir durum olabilirdi.)

    Soket programlamada bağlantı shutdown ile SHUT_RD kullanılarak kopartıldığında yukarıdaki 3'lü el sıkışma gerçekleşmektedir.

    Bağlantının koparılması "yarım biçimde de (half close") yapılabilir. Bu durumda bir taraf diğer tarafa FIN paketi gönderir. 
    Karşı taraf da buna ACK paketi ile karşılık verir. Bundan sonra artık FIN gönderen taraf veri gönderemez ama alabilir, 
    ACK gönderen taraf ise veri alamaz ama gönderebilir:

          Peer - 1                               Peer - 2

    +-----------------+                    +-----------------+
    |   ESTABLISHED   |                    |   ESTABLISHED   |
    +-----------------+                    +-----------------+
                        ------- FIN ----->
    +-----------------+                    +-----------------+
    |    FIN-WAIT-1   |                    |    CLOSE_WAIT   |
    +-----------------+                    +-----------------+
                        <------ ACK ------
                                           +-----------------+
                                           |     CLOSING     |
                                           +-----------------+
                                           +-----------------+
                                           |    TIME_WAIT    |
                                           +-----------------+

    Bunun tersi de şöyle söz konusu olabilir:

          Peer - 1                               Peer - 2

                        <------ FIN ------
    +-----------------+                    +-----------------+
    |    CLOSE_WAIT   |                    |    FIN-WAIT-1   |
    +-----------------+                    +-----------------+
                        ------- ACK ----->
    +-----------------+
    |     CLOSING     |
    +-----------------+
    +-----------------+
    |     TIME_WAIT   |
    +-----------------+

    Burada da artık Peer-2 veri gönderemez ama alabilir, Peer-1 ise veri veri alamaz fakat gönderebilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                118. Ders 09/02/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi shutdown fonksiyonunun "half close" işlemindeki etkisi nasıldır? Aslında shutdown fonksiyonunun ikinci parametresinde
    belirtilen SHUT_WR, SHUT_RD ve SHUT_RDWR değerlerinin protokoldeki bağlantının kopartılması süreciyle bir ilgisi yoktur. 
    shutdown fonksiyonu her durumda "half close" uygulamaktadır. Yani shutdown fonksiyonunun ikinci parametresi ne olursa olsun
    bu fonksiyonu çağıran taraf karşı tarafa FIN paketi yollar, karşı taraf da bu tarafa ACK paketi yollar. Zaten protokolün 
    kendisinde "half close" işlemi SHUT_WR, SHUT_RD ya da SHUT_RDWR biçiminde bir bilgi taşımamaktadır. TCP protokolü tasarlandığında 
    "half close" işleminin "bir tarafı göndermeye kapatıp diğer tarafı almaya kapatmak" gibi bir işlev göreceği düşünülmüştür.
    Ancak bu "half close" işleminin işletim sistemleri tarafından tam olarak nasıl ele alınacağı TCP/IP soket gerçekleştirimini 
    yapanlar tarafından belirlenmektedir.

    Şimdi Linux sistemlerinde shutdown fonksiyonunun muhtemel gerçekleştirimi ve arka planda gerçekleşen muhtemel işlemler konusunda 
    bilgi verelim. Örneğin bir taraf shutdown fonksiyonunu SHUT_WR parametresiyle aşağıdaki gibi çağırmış olsun. Ancak karşı taraf 
    shutdown fonksiyonunu çağırmamış olsun:

    shutdown(sock, SHUT_WR);

    Burada SHUT_WR uygulayan taraf diğer tarafa FIN paketi gönderir, diğer taraf da buna ACK ile yanıt verir ve "half close" işlemi 
    gerçekleşir. Artık SHUT_WR uygulayan taraf bundan sonra diğer tarafa veri göndermemeli diğer taraf da karşı taraftan veri almamalıdır. 
    Bir taraf SHUT_WR ile "half close" uyguladığında karşı taraf recv işlemi yaparsa sanki soket kapatılmış gibi recv fonksiyonu 
    0 ile geri dönecektir. SHUT_WR yapan taraf send fonksiyonunu kullandığında ise SIGPIPE sinyali oluşacaktır.

    Şimdi de bir taraf shutdown fonksiyonunu SHUT_RD ile çağırmış olsun.

    shutdown(sock, SHUT_RD);

    Bu durumda yine SHUT_RD uygulayan taraf karşı tarafa FIN paketi gönderir ve karşı taraftan ACK paketi alır. Böylece "half close" 
    işlemi gerçekleşir. Artık SHUT_RD uygulayan taraf veri almayacak fakat veri gönderebilecektir. Karşı taraf ise veri alabilecek 
    ancak veri gönderemeyecektir. Tabii aslında karşı taraf shutdown fonksiyonunun aslında hangi parametreyle çağrıldığını bilmemektedir. 
    Dolayısıyla aslında soket fonksiyonlarıyla veri göndermeye devam edebilecektir. Karşı taraf eğer send işlemi yaparsa 
    burada işletim sistemi değişik davranışlar gösterebilmektedir. Karşı tarafın gönderdiği paketler karşı tarafa ulaştığında SHUT_RD 
    yapan taraftaki işletim sistemi bu paketleri hiç dikkate almayabilir. Böylece SHUT_RD yapan taraf recv fonksiyonunu çağırsa 
    bile recv 0 ile geri döner. Ya da işletim sistemi böylesi bir durumda karşı taraf veri gönderdiğinde ona RST bayrağı set edilmiş 
    paket gönderip (buna "connection reset" denilmektedir) karşı tarafın artık send işlemlerinde SIGPIPE sinyali üretmesini sağlayabilir.

    Şimdi de shutdown fonksiyonunun SHUT_RDWR parametresi ile çağrıldığını düşünelim. Bu en çok kullanılan parametredir. Bu durumda yine 
    fonksiyonu çağıran taraf karşı tarafa FIN paketi gönderir, karşı taraftan ACK paketi alır. Yine "half close" işlemi gerçekleşir. 
    Ancak artık SHUT_RDWR uygulayan taraf recv ve send işlemlerini yapamayacaktır. SHUT_RDWR uygulayan taraf recv fonksiyonunu çağırırsa 
    fonksiyon 0 ile geri dönecek, send fonksiyonunu çağırırsa doğrudan SIGPIPE sinyali oluşacaktır. Bu durumda SHUT_RDWR uygulayan 
    tarafın karşı tarafı, artık send işlemi yaparsa yine davranış yukarıda SHUT_RD fonksiyonunda belirtildiği gibi gerçekleşecektir.

    Tabii normal olarak iki tarafın da aslında ayrı ayrı shutdown fonksiyonunu çağırması gerekir. Bu durumda 4'lü el sıkışma
    gerçekleşecektir. TCP/IP soket programlamada önce bir taraf shutdown uygulayıp "half close" oluşturabilir. Diğer taraf da bunu
    anlayıp o da shutdown uygulayarak 4'lü el sıkışma oluşturabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP'de akış kontrolü için "acknowledgement" yani "alındı" bildirimi kullanılmaktadır. Bir taraf bir tarafa bir paket veri 
    gönderirken verinin yanı sıra aynı zamanda paketin Flags kısmındaki PSH bitini 1 yapar. Karşı taraf da paketi aldığını diğer 
    tarafa haber vermek için diğer tarafa ACK biti set edilmiş bir paket gönderir. TCP'de her gönderilen paket için bir "alındı" 
    bilgisinin alınması gerekir. Eğer paketi gönderen taraf bu paketi içeren bir ACK paketi alamazsa bu durumda "paketin karşı 
    tarafa ulaşmadığından" şüphelenmektedir. Bu durumda paketi gönderen taraf belli bir algoritma ile zaman aralıklarıyla aynı paketi yeniden 
    göndermektedir. Böylesi bir durumda paketi alan taraf aynı paketi birden fazla kez de alabilir. Bunun yalnızca tek bir kopyasını 
    işleme sokmak alan tarafın sorumluluğundadır. Tabii gönderen tarafın paketi yolda kaybolabileceği gibi alan tarafın ACK paketi de
    yolda kaybolabilir. Bu durumda yine gönderen taraf ACK alamadığına göre göndermeye devam edecektir. Bu durumda alıcı taraf bunun 
    için yine ACK gönderecektir.

    Yukarıda da belirttiğimiz gibi paketin "data" kısmı dolu olmak zorunda değildir. Bağlantı sağlanırken ve sonlandırırken gönderilen 
    SYN ve FIN paketleri "data" içermemektedir. ACK paketi ayrı bir paket olarak gönderilmek zorunda değildir. Bilgiyi alan 
    taraf hem bilgi gönderirken hem de ACK işlemi yapabilir. Örneğin:

    +---------+
    |   PSH   |
    +---------+
                --- data --->
                               +---------------+
                               |   PSH + ACK   |
                               +---------------+
                <--- data ---
    +---------+
    |   ACK   |
    +---------+
                ------------>

    Aslında izleyen paragraflarda da ele alınacağı gibi ACK biti yalnızca "alındığını bildirme için değil" pencere genişliklerinin 
    ayarlanması için de kullanılmaktadır. Yani bir taraf karşı taraftan bilgi almadığı halde yine ACK gönderebilir.

    TCP'de kümülatif bir "acknowledgement" sistemi kullanılmaktadır. Yani paketi gönderen taraf bu paket için ACK almadan başka paketleri 
    gönderebilir. Paketleri alan taraf birden fazla paket için tek bir ACK yollayabilir. Kümülatif ACK işlemi için "sıra numarası 
    (sequence number)" denilen bir değerden faydalanılmaktadır. Sıra numarası (sequence number) gönderilen paketin bütün içerisindeki 
    kaçıncı byte'tan başladığını belirten bir değerdir. Bunu dosyalardaki dosya göstericisine benzetebiliriz. Sıra numarası TCP 
    başlığında 32 bitlik bir alanda tutulmaktadır. Sıra numarası 32 bitlik değerin sonuna geldiğinde yeniden başa dönmektedir (wrapping).
    Sıra numarası bağlantı kurulduğunda sıfırdan başlatılmaz, rastgele bir değerden başlatılmaktadır. Örneğin belli bir anda bir tarafın 
    sıra numarası 1552 olsun. Şimdi bu taraf karşı tarafa 300 byte göndersin. Artık bu gönderimden sonra sıra numarası 1852 olacaktır. 
    Yani bir sonraki gönderimde bu taraf sıra numarası olarak 1852'yi kullanacaktır. Sıra numarası her bilgi gönderiminde bulundurulmak 
    zorundadır. Bilgiyi alan taraf ACK paketini gönderirken paketteki sıra numarasını "talep ettiği sonraki sıra numarası" olarak paketin 
    sıra numarasını belirten kısmına yerleştirir. Örneğin:

    Peer-1                                        Peer-2

    300 byte (sequence Number: 3560) ----->
    100 byte (sequence Number: 3860) ----->
                                                  <---- ACK (Acknowledgement Number: 3960)
    50 byte  (sequence Number: 3960) ------>
                                                  <---- ACK (Acknowledgement Number: 4010)
    10 byte  (sequence Number: 4010) ------>

    Buradaki örnek gönderimde gönderen taraf önce 300 byte'lık bir paketi sonra 100 byte'lık bir paketi karşı tarafa göndermiştir. Karşı taraf 
    ise bu iki paket için tek bir ACK göndermiştir. Karşı tarafın gönderdiği ACK aslında diğer taraftan yeni talep edeceği sıra numarasındaki 
    bilgiyi belirtmektedir. İki paketi gönderen taraf karşı taraftan gelen ACK içerisindeki bu sıra numarasına baktığında bu iki paketinde 
    alındığını anlamaktadır. Görüldüğü gibi her paket için ayrı bir ACK yollanmak zorunda değildir. Buna "kümülatif alındı (cumulative 
    acknowledgment)" bildirimi denilmektedir. Örneğin bir tarafın karşı tarafa peş peşe 5 paket gönderdiğini düşünelim. Karşı taraftan 
    bir ACK gelmiş olsun. Gönderen taraf bu ACK paketine bakarak gönderdiği bilginin ne kadarının karşı taraf tarafından alındığını 
    anlayabilmektedir.

    Pekiyi bir TCP paketi (TCP segment) gönderici (sender) tarafından gönderildikten sonra alıcı (receiver) bunu alamamışsa ne olacaktır? 
    Çünkü TCP'nin güvenli bir protokol olması demek bir biçimde böyle bir durumda bir telafinin yapılması demektir. İşte yukarıda da 
    belirttiğimiz gibi TCP protokolü şöyle yöntem izlemektedir: Gönderen taraf her gönderdiği paket (TCP segment) için bir zamanlayıcı 
    kurar. Bu zamanlayıcıya "retransmission timer" denilmektedir. Eğer belli süre içerisinde gönderilen TCP paketini kapsayan bir
    ACK gelmediyse gönderici taraf aynı paketi yeniden göndermektedir. Böylece aslında gönderilen paket henüz onun için ACK gelmedikçe 
    gönderme tamponundan atılmaz. Retransmission timer bazı değerlere göre dinamik bir biçimde oluşturulmaktadır. Bunun detayları için 
    önerilen kaynaklara bakılabilir. Tabii böyle bir sistemde alıcı taraf aynı paketi birden fazla kez alabilmektedir. Yukarıda da belirttiğimiz 
    gibi bu durumda bu paketlerin yalnızca tek bir kopyasını alıp diğerlerini atmak alıcı tarafın sorumluluğundadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                119. Ders 11/02/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP protokolünün bir "akış kontrolü (flow control)" oluşturduğunu belirtmiştik. Akış kontrolünün amacı tampon taşmasının 
    engellenmesidir. Bağlantı sağlandıktan sonra bir tarafın diğer tarafa sürekli bilgi gönderdiğini düşünelim. Bu bilgileri 
    işletim sistemi alacak ve bekletecektir. Pekiyi ya ilgili proses soketten okuma yapmazsa? Bu durumda hala karşı taraf bilgi 
    gönderirse işletim sisteminin ayırdığı tampon taşabilir.

    Tipik olarak işletim sistemleri bağlantı yapılmış her soket için iki tampon bulundurmaktadır: Gönderme tamponu (send buffer) ve
    alma tamponu (receive buffer). Biz send fonksiyonunu kullandığımızda göndermek istediğimiz bilgiler gönderme tamponuna 
    yazılır ve hemen send fonksiyonu geri döner. Gönderme tamponundaki bilgilerin paketlenerek gönderilmesi belli bir zaman sonra
    işletim sistemi tarafından yapılmaktadır. Eğer send işlemi sırasında zaten gönderme tamponu doluysa send fonksiyonu gönderilecek 
    olanları tamamen tampona yazana kadar blokede beklemektedir. Alma tamponu (receive buffer) karşı tarafın gönderdiği bilgilerin 
    alınması için kullanılan tampondur. Karşı tarafın gönderdiği bilgiler alındığında işletim sistemi bu bilgileri alma tamponuna 
    yerleştirir. Aslında recv fonksiyonu bu tampondan bilgileri almaktadır.

    send ---> [gönderme tamponu] ---> işletim sistemi gönderiyor ---> ||||| <--- işletim sistemi alıyor ---> [alma tamponu] <--- recv

    Akış kontrolünün en önemli unsurlarından biri alma tamponunun taşmasını engellemektir. Örneğin gönderici taraf sürekli bilgi gönderirse 
    fakat alıcı taraftaki proses recv işlemiyle hiç okuma yapmazsa alıcı taraftaki işletim sisteminin alıcı tamponu dolabilir ve 
    sistem çökebilir. İşte akış kontrolü sayesinde alıcı taraf gönderici tarafa "artık gönderme, benim tamponum doldu" diyebilmektedir. 
    Şimdi bir taraftaki prosesin diğer tarafa bir döngü içerisinde send fonksiyonuyla bilgi gönderdiğini ancak diğer taraftaki prosesin
    bu bilgiyi almadığını varsayalım. Akış kontrolünün uygulandığı durumda ne olacaktır? İşte önce send ile gönderilenler karşı tarafa 
    iletilecektir. Karşı tamponu dolduğunda karşı taraf gönderen tarafa "artık gönderme" diyecektir. Bu durumda göndermeyi 
    kesen taraftaki proses hala send işlemi yapacağına göre o tarafın gönderme tamponu dolacak ve send fonksiyonu blokeye 
    yol açacaktır. Linux sistemlerinde tek bir send ile gönderme tamponundan daha büyük bir bilgiyi göndermek istediğimizde 
    tüm bilgi yine tampona yerleştirilene kadar bloke oluşmaktadır.

    Aşağıdaki örnekte client program bağlantı kurduktan sonra bir döngü içerisinde server programa send fonksiyonu ile bilgi
    göndermektedir. Ancak server program bu bilgiyi recv ile okumamaktadır. Yukarıda da belirttiğimiz gibi bu durumda server 
    programın tamponu dolacak ve server program karşı tarafa "artık gönderme" diyecek. Bu kez de karşı tarafın gönderme tamponu 
    dolacak dolayısıyla send fonksiyonu da bir süre sonra blokede bekleyecektir. Bu programları farklı terminallerden aşağıdaki 
    gibi çalıştırabilirsiniz:

    $ ./server 55555
    $ ./client localhost 55555
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock_server, sock_client;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    char ntopbuf[INET_ADDRSTRLEN];
    in_port_t port;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((sock_server = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock_server, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    if (listen(sock_server, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");

    sinaddr_len = sizeof(sinaddr_client);
    if ((sock_client = accept(sock_server, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
        exit_sys("accept");

    printf("Connected: %s : %u\n", inet_ntop(AF_INET, &sinaddr_client, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sinaddr_client.sin_port));

    printf("Press any key to EXIT...\n");
    getchar();

    shutdown(sock_client, SHUT_WR);
    close(sock_client);
    close(sock_server);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct addrinfo *ai, *ri;
    struct addrinfo hints = {0};
    char buf[BUFFER_SIZE] = {0};
    int result;
    ssize_t sresult;
    ssize_t stotal;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!...\n");
        exit(EXIT_FAILURE);
    }

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    if ((result = getaddrinfo(argv[1], argv[2], &hints, &ai)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(result));
        exit(EXIT_FAILURE);
    }

    for (ri = ai; ri != NULL; ri = ri->ai_next)
        if (connect(sock, ri->ai_addr, ri->ai_addrlen) != -1)
            break;

    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(ai);

    printf("Connected...\n");

    stotal = 0;
    for (;;) {
        printf("send calls...\n");
        if ((sresult = send(sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("send");
        stotal += sresult;
        printf("bytes sent: %jd, total bytes sent: %jd\n", sresult, stotal);
    }

    close(sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda basit olarak açıkladığımız akış kontrolünün TCP'de bazı detayları vardır.

    TCP'de bunun için "pencere (window)" kavramı kullanılmaktadır. Pencerenin bir büyüklüğü (window size) vardır. Pencere büyüklüğü
    TCP başlığında belirtilmektedir. Pencere büyüklüğü demek "hiç ACK gelmediği durumda göndericinin en fazla gönderebileceği 
    byte sayısı" demektir. Örneğin pencere genişliğinin 8K olması demek "alıcı ACK göndermedikten sonra göndericinin en fazla 
    8K gönderebilmesi" demektir. Pencere genişliği alıcı taraf tarafından gönderici tarafa bildirilir. Örneğin pencere genişliği
    alıcı taraf için 8K olsun. Bu durumda gönderici taraf sırasıyla 1K + 1K + 1K + 1K + 1K uzunluğunda toplam 5K'lık bilgiyi 
    karşı tarafa göndermiş olsun. Eğer henüz ACK gelmemişse gönderici taraf en fazla 3K kadar daha bilgi gönderebilir.

    TCP'de her ACK sırasında yeni pencere genişliği de karşı tarafa gönderilmek zorundadır. Yani ACK paketi gönderilirken aynı 
    zamanda yeni pencere genişliği de gönderilmektedir. ACK paketi yalnızca alındı bilgisini göndermek için değil pencere genişliğini
    ayarlamak için de gönderilebilmektedir. Başka bir deyişle bir taraf "yalnızca bilgi aldığı için" ACK göndermek zorunda değildir. 
    Hiç bilgi almadığı halde yeni pencere genişliğini karşı tarafa bildirmek için de ACK gönderebilir. Pencere genişliği en fazla 
    64K olabilir. Çünkü bunun için TCP başlığında 16 bit yer ayrılmıştır.

    Şimdi bir tarafın diğer tarafa send fonksiyonu ile sürekli bilgi gönderdiğini ancak diğer tarafın bilgiyi recv ile okumadığını 
    düşünelim. İşletim sisteminin alıcı taraf için oluşturduğu alma tamponunun 1 MB olduğunu düşünelim. Alıcı taraf muhtemelen bilgi
    geldikçe ACK yaparken 64K'lık pencere genişliğini karşı tarafa bildirecektir. Ancak zamanla alma tamponu dolduğu için bu pencere 
    genişliğini düşürecek en sonunda ACK ile pencere genişliğini 0 yapacak ve karşı tarafa "artık gönderme" diyecektir. Pencere 
    genişliği ile alma tamponunun genişliği birbirine karıştırılmamalıdır. Alma tamponu gelen bilgilerin yerleştirildiği tampondur. 
    Pencere genişliği karşı tarafın ACK almadıktan sonra gönderebileceği maksimum byte sayısıdır.

    Pekiyi pencere genişlikleri ve sıra numaraları bağlantı sırasında nasıl karşı tarafa bildirilmektedir? İşte bağlantı kurulurken 
    client taraf SYN paketi içerisinde kendi başlangıç sıra numarasını karşı tarafa iletmektedir. Server da bağlantıyı kabul ederken 
    yine SYN (ya da SYN + ACK) paketinde kendi sıra numarasını karşı tarafa bildirmektedir. Pencere genişliği de aslında ilk kez 
    bağlantı yapılırken ACK paketlerinde belirtilmektedir.

    TCP/IP stack gerçekleştirimleri ACK stratejisi için bazı yöntemler uygulamaktadır. Örneğin eğer gönderilecek paket varsa 
    bununla birlikte ACK paketinin gönderilmesi, ACK'ların iki paket biriktirildikten sonra gönderilmesi gibi. Benzer biçimde 
    pencere genişliklerinin ayarlanması için de bazı stratejiler izlenebilmektedir. Bunun için "TCP/IP Protocol Suite" kitabının 
    466'ıncı sayfasına başvurabilirsiniz.

    TCP paketindeki önemli Flag'lerden birisi de "RST" bitidir. Buna "reset isteği" denilmektedir. Bir taraf RST bayrağı set 
    edilmiş paket alırsa artık karşı tarafın "abnormal" bir biçimde bağlantıyı kopartıp yeniden bağlanma talep ettiği anlaşılır. 
    Normal sonlanma el sıkışarak başarılı bir biçimde yapılırken RST işlemi anormal sonlanmaları temsil eder. Örneğin soket 
    kütüphanelerinde hiç shutdown yapmadan soket close edilirse close eden taraf karşı tarafa RST paketi göndermektedir. 
    Halbuki önce shutdown yapılırsa el sıkışmalı sonlanma gerçekleştirilir. O halde her zaman aktif soketler shutdown yapıldıktan 
    sonra close edilmelidir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                120. Ders 16/02/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UDP protokolü aslında saf IP protokolüne çok benzerdir. UDP'yi IP'den ayıran iki önemli farklılık şudur:

    1) UDP port numarası kavramına sahiptir.
    2) UDP'nin hata için bir checksum mekanizması vardır. Yani bir taraf diğer tarafa UDP paketi gönderirken gönderdiği veri için
    checksum bilgisini de UDP başlık kısmına iliştirmektedir.

    Bir UDP paketi yine aslında IP paketinin data kısmında bulunmaktadır. UDP header'ı 8 byte'tan oluşmaktadır ve yapısı aşağıdaki gibidir.

    <------- Byte 1 -------><------- Byte 2 -------><------- Byte 3 -------><------- Byte 4 ------->
    +----------------------------------------------+-----------------------------------------------+             ^
    |                  Source Port                 |                Destination Port               |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             |  8 bytes
    |                    Length                    |                   Checksum                    |  (4 bytes)  |
    |                   (16 bits)                  |                   (16 bits)                   |             |
    +----------------------------------------------+-----------------------------------------------+             v
    |                                    Application Layer Data                                    |
    |                                         (Size Varies)                                        |
    +----------------------------------------------------------------------------------------------+

    Burada UDP paketinin toplam uzunluğunun bulunması aslında gereksizdir. Çünkü uzunluk TCP'de olduğu gibi aslında IP paketinin 
    başlığına bakılarak tespit edilebilmektedir. Ancak hesaplama kolaylığı oluşturmak için bu uzunluk UDP başlığında ayrıca 
    bulundurulmuştur. Ayrıca checksum UDP paketlerinde bulunmak zorunda değildir. Eğer gönderici checksum kontrolü istemiyorsa 
    burayı 0 bitleriyle doldurur. (Eğer zaten checksum 0 ise burayı 1 bitleriyle doldurmaktadır.) Alan taraf checksum hatasıyla 
    karşılaşırsa TCP'de olduğu gibi paketi yeniden talep etmez. Yalnızca onu atar.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bazen TCP ve UDP yerine doğrudan IP protokolünü kullanmak isteyebiliriz. Buna soket programlamada "raw socket" denilmektedir. 
    Diğer protokol ailelerinde de "raw socket" ağ katmanı protokolünü belirtmektedir. Biz kursumuzda "raw socket" işlemleri üzerinde
    durmayacağız. Ancak daha aşağı seviyeli çalışmalar için ya da örneğin aktarım katmanını gerçekleştirmek (implemente etmek)
    için "raw socket" kullanımını bilmek gerekir.

    Genel bir "raw soket" oluşturmak için soket nesnesi yaratılırken protokol ailesi için AF_PACKET girilir. Soket türü için de 
    SOCK_RAW girilmelidir. IP protokolü için protokol ailesi yine AF_INET ya da AF_INET6 girilip soket türü SOCK_RAW olarak 
    girilebilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bu bölümde UNIX/Linux sistemlerinde kullanılan kütüphane dosyaları ve onların ayrıntıları üzerinde duracağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kütüphane "hazır kodların bulunduğu topluluklar" için kullanılan bir terimdir. Ancak aşağı seviyeli dünyada kütüphane 
    kavramı daha farklı bir biçimde kullanılmaktadır. Aşağı seviyeli dünyada "içerisinde derlenmiş bir biçimde fonksiyonların 
    bulunduğu dosyalara kütüphane (library)" denilmektedir. Aslında kütüphaneler yalnızca fonksiyon değil, global nesneler 
    de içerebilmektedir.

    Kütüphaneler "statik" ve "dinamik" olmak üzere ikiye ayrılmaktadır. Statik kütüphane dosyalarının uzantıları UNIX/Linux 
    sistemlerinde ".a (archive)" biçiminde, Windows sistemlerinde ".lib (library)" biçimindedir. Dinamik kütüphane dosyalarının 
    uzantıları ise UNIX/Linux sistemlerinde ".so (shared object), Windows sistemlerinde ".dll (dynamic link library)" biçimindedir. 
    UNIX/Linux dünyasında kütüphane dosyaları geleneksel olarak başında "lib" öneki olacak biçimde isimlendirilmektedir. 
    (Örneğin "x" isimli bir statik kütüphane dosyası UNIX/Linux sistemlerinde genellikle "libx.a" biçiminde, "x" isimli bir 
    dinamik kütüphane dosyası ise UNIX/Linux sistemlerinde genellikle "libx.so" biçiminde isimlendirilmektedir.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Statik kütüphaneler aslında "object modülleri (yani .o dosyalarını)" tutan birer kap gibidir. Yani statik kütüphaneler 
    object modüllerden oluşmaktadır. Statik kütüphanelere link aşamasında linker tarafından bakılır. Bir program statik 
    kütüphane dosyasından bir çağırma yaptıysa (ya da o kütüphaneden bir global değişkeni kullandıysa) linker o statik kütüphane 
    içerisinde ilgili fonksiyonun bulunduğu object modülü link aşamasında statik kütüphane dosyasından çekerek çalıştırılabilir 
    dosyaya yazar. (Yani statik kütüphaneden bir tek fonksiyon çağırsak bile aslında o fonksiyonun bulunduğu object modülün 
    tamamı çalıştırılabilen dosyaya yazılmaktadır.) Statik kütüphaneleri kullanan programlar artık o statik kütüphaneler olmadan 
    çalıştırılabilirler.

    Statik kütüphane kullanımının şu dezavantajları vardır:

    1) Kütüphaneyi kullanan farklı programlar aynı fonksiyonun (onun bulunduğu object modülün) bir kopyasını çalıştırılabilir 
    dosya içerisinde bulundururlar. Yani örneğin printf fonksiyonu statik kütüphanede ise her printf kullanan C programı aslında 
    printf fonksiyonunun bir kopyasını da barındırıyor durumda olur. Bu da programların diskte fazla yer kaplamasına yol açacaktır.

    2) Aynı statik kütüphaneyi kullanan programlar belleğe yüklenirken işletim sistemi aynı kütüphane kodlarınını yeniden fiziksel 
    belleğe yükleyecektir. İşletim sistemi bu kodların ortak olarak kullanıldığını anlayamamaktadır.

    3) Statik kütüphanede bir değişiklik yapıldığında onu kullanan programların yeniden link edilmesi gerekir.

    Statik kütüphane kullanımının şu avantajları vardır:

    1) Kolay konuşlandırılabilirler. Statik kütüphane kullanan bir programın yüklenmesi için başka dosyalara gereksinim 
    duyulmamaktadır.

    2) Statik kütüphanelerin kullanımları kolaydır, statik kütüphane kullanan programlar için daha kolay build ya da make işlemi 
    yapılabilmektedir.

    3) Statik kütüphane kullanan programların yüklenmesi dinamik kütüphane kullanan programların yüklenmesinden çoğu kez daha hızlı
    yapılmaktadır. Ancak bu durum çeşitli koşullara göre tam ters bir hale de gelebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde statik kütüphane dosyaları üzerinde işlemler "ar" isimli utility program yoluyla yapılmaktadır. 
    "ar" programına önce bir seçenek, sonra statik kütüphane dosyasının ismi, sonra da bir ya da birden fazla object modül ismi 
    komut satırı argümanı olarak verilir. Örneğin:

    $ ar r libmyutil.a x.o y.o

    Burada "r" seçeneği belirtmektedir. ar eski bir komut olduğu için burada seçenekler '-' ile başlatılarak verilmeyebilir. 
    Ancak POSIX standartlarında seçenekler yine "-" ile belirtilmektedir. Komuttaki "libmyutil.a" işlemden etkilenecek statik 
    kütüphane dosyasını "x.o" ve "y.o" argümanları ise object modülleri belirtmektedir. Biz buradaki seçeneği "-" ile de 
    belirtebiliriz:

    $ ar -r libmyutil.a x.o y.o

    Tipik ar seçenekleri ve yaptıkları işler şunlardır:

    -r (replace) seçeneği ilgili object modüllerin kütüphaneye yerleştirilmesini sağlar. Eğer kütüphane dosyası yoksa komut aynı 
    zamanda onu yaratmaktadır. Örneğin:

    $ ar -r libmyutil.a x.o y.o

    Burada "libmyutil.a" statik kütüphane dosyasına "x.o" ve "y.o" object modülleri yerleştirilmiştir. Eğer "libmyutil.a" dosyası
    yoksa aynı zamanda bu dosya yaratılacaktır. Bu seçenekte eğer kütüphaneye yerleştirilmek istenen amaç dosya zaten kütüphane
    içerisinde varsa değiştirilmektedir ("replace" zaten buradan geliyor).

    -t seçeneği kütüphane içerisindeki object modüllerin listesini almakta kullanılır. Örneğin:

    $ ar -t libsample.a

    -d (delete) seçeneği kütüphaneden bir object modülü silmekte kullanılır. Örneğin:

    $ ar -d libmyutil.a x.o

    -x (extract) seçeneği kütüphane içerisindeki object modülü bir dosya biçiminde diske save etmekte kullanılır. Ancak bu object 
    modül kütüphane dosyasından silinmeyecektir. Örneğin:

    $ ar -x libmyutil.a x.o

    -m (modify) seçeneği de bir object modülün yeni versiyonunu eski versiyonla değiştirmekte kullanılır.

    O halde "x.c" ve "y.c" dosyalarının içerisindeki fonksiyonları statik kütüphane dosyasına eklemek için sırasıyla şunlar
    yapılmalıdır:

    $ gcc -c x.c
    $ gcc -c y.c
    $ ar r libmyutil.a x.o y.o
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Statik kütüphane kullanan programlar derlenirken statik kütüphane dosyaları komut satırında belirtilebilir. Bu durumda gcc 
    ve clang derleyicileri o dosyayı bağlama (link) işleminde kullanmaktadır. Örneğin:

    $ gcc -o app app.c libmyutil.a

    Burada "libmyutil.a" dosyasına C derleyicisi bakmamaktadır. gcc aslında bu dosyayı bağlayıcıya (linker) iletmektedir. Biz bu 
    işlemi iki adımda da yapabilirdik:

    $ gcc -c app.c
    $ gcc -o app app.o libmyutil.a

    Her ne kadar GNU'nun bağlayıcı programı aslında "ld" isimli programsa da genellikle programcılar bu ld bağlayıcısını doğrudan 
    değil yukarıdaki gibi gcc yoluyla kullanırlar. Çünkü ld bağlayıcısını kullanılırken "libc" kütüphanesinin start-up amaç dosyaların
    (start-up object modules) programcı tarafından ld bağlayıcısına verilmesi gerekmektedir. Bu da oldukça sıkıcı bir işlemdir. 
    Halbuki biz ld bağlayıcısını gcc yoluyla çalıştırdığımızda libc kütüphanesi ve bu start-up amaç dosyalar ld bağlayıcısına gcc 
    tarafından verilmektedir.

    gcc eskiden C derleyicisi anlamına geliyordu (GNU C Compiler). Ancak zamanla derleyicileri çalıştıran bir önyüz (front-end) 
    program haline getirildi ve ismi de "GNU Compiler Collection" biçiminde değiştirildi. Yani aslında uzunca bir süredir gcc 
    programı ile yalnızca C programlarını değil diğer programlama dillerinde yazılmış olan programları da derleyebilmekteyiz.

    Komut satırında kütüphane dosyalarının komut satırı argümanlarının sonunda belirtilmesi uygundur. Çünkü gcc programı kütüphane 
    dosyalarını yalnızca onların solunda belirtilen dosyaların bağlanmasında kullanmaktadır. Örneğin:

    $ gcc -o app app1.o libmyutil.a app2.o

    Böylesi bir kullanımda "libmyutil.a" kütüphanesinin solunda yalnızca "app1.o" dosyası vardır. Dolayısıyla bağlayıcı yalnızca 
    bu modül için bu kütüphaneye bakacaktır, "app2.o" için bu kütüphaneye bakılmayacaktır.

    Şüphesiz statik kütüphane kullanmak yerine aslında amaç dosyaları da doğrudan bağlama işlemine sokabiliriz. Örneğin:

    $ gcc -o sample sample.c x.o y.o

    Ancak çok sayıda object modül söz konusu olduğunda bu işlemin zorlaşacağına dikkat ediniz. Yani amaç dosyalar (object modules) 
    dosyalara benzetilirse statik kütüphane dosyaları dizinler gibi düşünülebilir.

    Derleme işlemi sırasında kütüphane dosyası -l<isim> biçiminde de belirtilebilir. Bu durumda arama sırasında "lib" öneki 
    ve ".a" uzantısı aramaya dahil edilmektedir. Yani örneğin:

    $ gcc -o sample sample.c -lmyutil

    İşleminde aslında "libmyutil.a" (ya da "libmyutil.so") dosyaları aranmaktadır. Arama işlemi sırasıyla bazı dizinlerde 
    yapılmaktadır. Örneğin "/lib" dizini, "/usr/lib dizini", "/usr/local/lib" dizini gibi dizinlere bakılmaktadır. Ancak 
    "bulunulan dizine (current working directory)" bakılmamaktadır. -l seçeneği ile belli bir dizine de bakılması isteniyorsa 
    "-L" seçeneği ile ilgili dizin belirtilebilir. Örneğin:

    $ gcc -o sample sample.c -lmyutil -L.

    Buradaki '.' çalışma dizinini temsil etmektedir. Artık "libmyutil.a" kütüphanesi için bulunulan dizine de (current working 
    directory) bakılacaktır. Birden fazla dizin için -L seçeneğinin yinelenmesi gerekmektedir. Örneğin:

    $ gcc -o sample sample.c -lmyutil -L. -L/home/csd

    Geleneksel olarak "-l" ve "-L" seçeneklerinden sonra boşluk bırakılmamaktadır. Ancak boşluk bırakılmasında bir sakınca 
    yoktur.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir statik kütüphane başka bir statik kütüphaneye bağımlı olabilir. Örneğin biz "liby.a" kütüphanesindeki kodda "libx.a" 
    kütüphanesindeki fonksiyonları kullanmış olabiliriz. Bu durumda "liby.a" kütüphanesini kullanan program "libx.a" kütüphanesini
    de komut satırında belirtmek zorundadır. Örneğin:

    $ gcc -o sample sample.c libx.a liby.a
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                121. Ders 18/02/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphane dosyalarının UNIX/Linux sistemlerinde uzantıları ".so" (shared object'ten kısaltma), Windows sistemlerinde 
    ise ".dll" (Dynamic Link Library) biçimindedir.

    Bir dinamik kütüphaneden bir fonksiyon çağrıldığında linker statik kütüphanede olduğu gibi gidip fonksiyonun kodunu (fonksiyonun 
    bulunduğu amaç dosyayı) çalıştırılabilen dosyaya yazmaz. Bunun yerine çalıştırılabilen dosyaya çağrılan fonksiyonun hangi 
    dinamik kütüphanede olduğu bilgisini yazar. Çalıştırılabilen dosyayı yükleyen işletim sistemi o dosyanın çalışması için 
    gerekli olan dinamik kütüphaneleri çalıştırılabilen dosyayla birlikte bütünsel olarak prosesin sanal bellek alanına yüklemektedir. 
    Böylece birtakım ayarlamalar yapıldıktan sonra artık çağrılan fonksiyon için gerçekten o anda sanal belleğe yüklü olan dinamik 
    kütüphane kodlarına gidilmektedir. Örneğin biz "app" programımızda "libmyutil.so" dinamik kütüphanesinden foo isimli fonksiyonu 
    çağırmış olalım. Bu foo fonksiyonunun kodları dinamik kütüphaneden alınıp "app" dosyasına yazılmayacaktır. Bu "app" dosyası 
    çalıştırıldığında işletim sistemi bu "app" dosyası ile birlikte "libmyutil.so" dosyasını da sanal belleğe yükleyecektir. 
    Programın akışı foo çağrısına geldiğinde akış "libmyutil.so" dosyası içerisindeki foo fonksiyonunun kodlarına aktarılacaktır. 
    Dinamik kütüphane dosyalarının bir kısmının değil hepsinin prosesin adres alanına yüklendiğine dikkat ediniz. (Tabii işletim 
    sisteminin sanal bellek mekanizması aslında yalnızca bazı sayfaları fiziksel belleğe yükleyebilecektir.)

    Dinamik kütüphane kullanımının avantajları şunlardır:

    1) Çalıştırılabilen dosyalar fonksiyon kodlarını içermezler. Dolayısıyla önemli bir disk alanı kazanılmış olur. Oysa statik 
    kütüphanelerde statik kütüphanelerden çağrılan fonksiyonlar çalıştırılabilen dosyalara yazılmaktadır.

    2) Dinamik kütüphaneler birden fazla proses tarafından fiziksel belleğe tekrar tekrar yüklenmeden kullanılabilmektedir.
    Yani işletim sistemi arka planda aslında aynı dinamik kütüphaneyi kullanan programlarda bu kütüphaneyi tekrar tekrar fiziksel 
    belleğe yüklememektedir. Bu da statik kütüphanelere göre önemli bir bellek kullanım avantaj oluşturmaktadır. Bu durumda eğer 
    dinamik kütüphanenin ilgili kısmı daha önce fiziksel belleğe yüklenmişse bu durum dinamik kütüphane kullanan programın daha 
    hızlı yüklemesine de yol açabilmektedir. Prog1 ve Prog2 biçiminde iki programın çalıştığını düşünelim. Bunlar aynı dinamik 
    kütüphaneyi kullanıyor olsun. İşletim sistemi bu dinamik kütüphaneyi bu proseslerin sanal bellek alanlarının farklı yerlerine 
    yükleyebilir. Ancak aslında işletim sistemi sayfa tablolarını kullanarak mümkün olduğunca bu iki dinamik kütüphaneyi aynı 
    fiziksel sayfaya eşlemeye çalışacaktır. Tabii bu durumda proseslerden biri dinamik kütüphane içerisindeki bir statik 
    nesneyi değiştirdiğinde artık "copy on write" mekanizması devreye girecek ve dinamik kütüphanenin o sayfasının yeni bir 
    kopyası oluşturulacaktır. Aslında bu durum fork fonksiyonu ile yeni bir prosesin yaratılması durumuna çok benzemektedir. 
    Burada anlatılan unsurların ayrıntıları "sayfalama ve sanal bellek" kullanımın açıklandığı paragraflarda ele alınmıştır.

    3) Dinamik kütüphaneleri kullanan programlar bu dinamik kütüphanelerdeki değişikliklerden etkilenmezler. Yani biz dinamik 
    kütüphanenin yeni bir versiyonunu oluşturduğumuzda bunu kullanan programları yeniden derlemek ya da bağlamak zorunda kalmayız. 
    Örneğin bir dinamik kütüphaneden foo fonksiyonunu çağırmış olalım. Bu foo fonksiyonunun kodları bizim çalıştırılabilir 
    dosyamızın içerisinde değil de dinamik kütüphanede olduğuna göre dinamik kütüphanedeki foo fonksiyonu değiştirildiğinde 
    bizim programımız artık değişmiş olan foo fonksiyonunu çağıracaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphanelerin gerçekleştiriminde ve kullanımında önemli bir sorun vardır. Dinamik kütüphanelerin tam olarak sanal 
    belleğin neresine yükleneceği baştan belli değildir. Halbuki çalıştırılabilen dosyanın sanal belleğin neresine yükleneceği 
    baştan bilinebilmektedir. Yani çalıştırılabilen dosyanın tüm kodları aslında derleyici ve bağlayıcı tarafından zaten "onun 
    sanal bellekte yükleneceği yere göre" oluşturulmaktadır. Fakat dinamik kütüphanelerin birden fazlası prosesin sanal adres 
    alanına yüklenebildiğinden bunlar için yükleme adresinin önceden tespit edilmesi mümkün değildir. İşte bu sorunu giderebilmek 
    için işletim sistemlerinde değişik teknikler kullanılmaktadır. Windows sistemlerinde "import-export tablosu ve "load time 
    relocation" yöntemleri tercih edilmiştir. Bu sistemlerde dinamik kütüphane belli bir adrese yüklendiğinde işletim sistemi 
    o dinamik kütüphanenin "relocation" tablosuna bakarak gerekli makine komutlarını düzeltmektedir. Dinamik kütüphane 
    fonksiyonlarının çağrımı için de "import tablosu" ve "export tablosu" denilen tablolar kullanılmaktadır. UNIX/Linux dünyasında 
    dinamik kütüphanelerin herhangi bir yere yüklenebilmesi ve minimal düzeyde relocation uygulanabilmesi için "Konumdan Bağımsız 
    Kod (Position Independent Code - PIC)" denilen teknik kullanılmaktadır. Konumdan bağımsız kod "nereye yüklenirse yüklenilsin 
    çalışabilen kod" anlamına gelmektedir. Konumdan bağımsız kod oluşturabilmek derleyicinin yapabileceği bir işlemdir. Konumdan 
    bağımsız kod oluşturabilmek için gcc ve clang derleyicilerinde derleme sırasında "-fPIC" seçeneğinin bulundurulması gerekmektedir. 
    Biz kursumuzda konumdan bağımsız kod oluşturmanın ayrıntıları üzerinde durmayacağız.

    Pekiyi Windows sistemlerinin kullandığı "relocation" tekniği ile UNIX/Linux sistemlerinde kullanılan "konumdan bağımsız
    kod tekniği" arasında performans bakımından ne farklılıklar vardır? İşte bu tekniklerin kendi aralarında bazı avantaj 
    ve dezavantajları bulunmaktadır. Windows'taki teknikte "relocation" işlemi bir zaman kaybı oluşturabilmektedir. Ancak 
    bir "relocation" işlemi yapıldığında kodlar daha hızlı çalışma eğilimindedir. Konumdan bağımsız kod tekniğinde ise
    "relocation" işlemine minimal düzeyde gereksinim duyulmaktadır. Ancak dinamik kütüphanelerdeki fonksiyonlar çağrılırken 
    göreli biçimde daha fazla zaman kaybedilmektedir. Aynı zamanda bu teknikte kodlar biraz daha fazla yer kaplamaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde aslında dinamik kütüphaneler ismine "dinamik linker (dynamic linker)" denilen bir dinamik kütüphane 
    tarafından yüklenmektedir. Bu dinamik kütüphane "ld.so" ya da "ld-linux.so" ismiyle bulunmaktadır. Programın yüklenmesinin
    execve sistem fonksiyonu tarafından yapıldığını anımsayınız. Bu sistem fonksiyonu ayrıntılı birtakım işlemler yaparak 
    tüm yüklemeyi gerçekleştirmektedir. Bu sürecin ayrıntıları olmakla birlikte kabaca execve süreci bu bağlamda şöyle 
    yürütülmektedir: execve fonksiyonu önce işletim sistemi için gereken çeşitli veri yapılarını oluşturur sonra çalıştırılabilen 
    dosyayı belleğe yükler. Sonra da dinamik linker kütüphanesini belleğe yükler. Bundan sonra akış dinamik linker'daki koda
    aktarılır. Dinamik linker da çalıştırılabilir dosyada belirtilen dinamik kütüphaneleri yükler. Sonra da akışı çalıştırılabilen
    dosyada belirtilen gerçek başlangıç adresine (entry point) aktarır. Dinamik linker kodları aslında user mode'da mmap sistem 
    fonksiyonunu kullanarak diğer dinamik kütüphaneleri yüklemektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi neden dinamik kütüphane dosyaları linker tarafından tıpkı çalıştırılabilir dosyalarda olduğu gibi sanal bellekte belli 
    bir yere yüklenince sorunsuz çalışacak biçimde oluşturulmuyor? Çalıştırılabilir dosyalar sanal bellek boşken yüklendiğinden 
    onların belli bir yere yüklenmesinde bir sorun oluşmamaktadır. Ancak bir program çok fazla dinamik kütüphane kullanabileceğine 
    göre bu dinamik kütüphanelerin baştan yerinin belirlenmesi olanaksızdır.

    Pekiyi dinamik kütüphaneler içerisindeki global değişkenlerin ve fonksiyonların yükleme yerinden bağımsız bir biçimde dinamik 
    kütüphane içerisinden kullanılması nasıl sağlanabilir? Dinamik kütüphane içerisinde aşağıdaki gibi bir kod parçası bulunuyor 
    olsun:

    int g_a;
    ...

    g_a = 10;

    Burada derleyicinin yukarıdaki ifadeye ilişkin makine kodlarını üretebilmesi için g_a değişkeninin tüm bellekteki adresini 
    (yani tepeden itibaren adresini) bilmesi gerekir. Bir nesnenin belleğin tepesinden itibarenki adresine "mutlak adres (absolute
    address) de denilmektedir. Örneğin Intel işlemcilerinde yukarıdaki ifade aşağıdaki gibi makine komutlarına dönüştürülmektedir:

    MOV EAX, 10
    MOV [g_a'nın mutlak adresi], EAX

    İşte sorun buradaki g_a değişkeninin mutlak adresinin program yüklenene kadar bilinmemesidir. Bu sorunu çözmenin de iki yolu 
    vardır:

    1) Derleyici ve linker g_a'nın mutlak adresinin bulunduğu yeri boş bırakır. Yükleyicinin bu yeri yükleme adresine göre 
    doldurmasını ister. İşte bu işlem yükleyicinin yaptığı "relocation" işlemidir. Bu tür relocation işlemlerine "load time 
    relocation" da denilmektedir. Windows sistemleri bu yöntemi kullanmaktadır.

    2) Derleyici makine komutunu o anda komutun yürütüldüğü yerin adresini barındıran ve ismine "Instruction Pointer" denilen 
    yazmaca dayalı olarak oluşturabilir. Çünkü linker komutun bulunduğu yerden g_a'ya kadar kaç byte'lık bir açıklık olduğunu 
    bilmektedir. İşte buna "konumdan bağımsız kod (position independent code)" denilmektedir.

    Yukarıda da belirttiğimiz gibi birinci teknik (Windows sistemlerinin kullandığı teknik) relocation yapıldıktan sonra kodun
    hızlı çalışmasını sağlamaktadır. Ancak bu teknikte relocation zamanı yüklemeyi uzatabilmektedir. İkinci teknikte ise relocation
    minimal düzeyde tutulmaktadır. Ancak bu global değişkenlere erişim birkaç makine komutu ile daha yavaş yapılmaktadır. 
    UNIX/Linux sistemleri genel olarak bu tekniği kullanmaktadır. Ayrıca birinci teknikte kod üzerinde relocation uygulandığı 
    için mecburen "copy on write" mekanizması devreye sokulmaktadır. Bu da fiziksel belleğin kullanım verimini düşürebilmektedir.

    Bu noktada ek olarak işlemcilerde bazı makine komutlarının (MOV, LOAD, STORE gibi) mutlak adres kullandığını ancak CALL 
    ve JMP gibi bazı makine komutlarının hem mutlak hem de göreli adres kullanabildiğini belirtelim. Aslında işlemcileri 
    tasarlayanlar relocation işlemi gerekmesin diye CALL ve JMP komutlarının göreli (relative) versiyonlarını da oluşturmuşlardır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde dinamik kütüphaneler şöyle oluşturulmaktadır:

    1) Önce dinamik kütüphaneye yerleştirilecek amaç dosyaların (object files) -fPIC seçeneği ile "Konumdan Bağımsız Kod 
    (Position Independent Code)" tekniği kullanılarak derlenmesi gerekir. (-fPIC seçeneğinde -f'ten sonra boşluk bırakılmamalıdır.)

    2) Bağlama işleminde "çalıştırılabilir (executable)" değil de "dinamik kütüphane" dosyasının oluşturulması için -shared 
    seçeneğinin kullanılması gerekir. "-shared" seçeneği kullanılmazsa bağlayıcı dinamik kütüphane değil, normal çalıştırılabilir 
    dosya oluşturmaya çalışmaktadır. (Zaten bu durumda main fonksiyonu olmadığı için linker hata mesajı verecektir.) Örneğin:

    $ gcc -fPIC a.c b.c c.c
    $ gcc -shared -o libmyutil.so a.o b.o c.o

    Dinamik kütüphanelere daha sonra dosya eklenip çıkartılamaz. Onların her defasında yeniden bütünsel biçimde oluşturulmaları 
    gerekmektedir. Yukarıdaki işlem aslında tek hamlede de aşağıdaki gibi yapılabilmektedir:

    $ gcc -shared -o libmyutil.so -fPIC a.c b.c c.c
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz -fPIC seçeneğini kullanmadan yani "konumdan bağımsız kod" üretmeden dinamik kütüphane oluşturmaya çalışırsak
    ne olur? Mevcut GNU linker programları "-shared" seçeneği kullanıldığında global değişkenler için relocation işlemi söz 
    konusu ise bir mesaj vererek link işlemini yapmamaktadır. Yani bu durumda mevcut GNU linker programları kodun "-fPIC" 
    seçeneği ile derlenmesini zorunlu tutmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                122. Ders 23/02/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda dinamik kütüphanelerin nasıl oluşturulduğunu gördük. Pekiyi dinamik kütüphaneler nasıl kullanılmaktadır?

    Dinamik kütüphane kullanan bir program bağlanırken kullanılan dinamik kütüphanenin komut satırında belirtilmesi gerekir. 
    Örneğin:

    $ gcc -o app app.c libmyutil.so

    Tabii bu işlem yine -l seçeneği ile de yapılabilirdi:

    $ gcc -o app app.c -lmyutil -L.

    Bu biçimde çalıştırılabilir dosya oluşturulduğunda linker bu çalıştırılabilir dosyanın çalıştırılabilmesi için hangi 
    dinamik kütüphanelerin yüklenmesi gerektiğini ELF formatının ".dynamic" isimli bölümüne yazmaktadır. Böylece yükleyici 
    bu programı yüklerken onun kullandığı dinamik kütüphaneleri de yükleyecektir. Ancak linker bu ".dynamic" bölümüne çalıştırılabilir
    dosyanın kullandığı dinamik kütüphanelerin yol ifadesini (yani tam olarak nerede olduğunu) yazmaz. Yalnızca isimlerini 
    yazmaktadır. İşte yükleyici (dinamik linkler) bu nedenle dinamik kütüphaneleri önceden belirlenen bazı yerlerde aramaktadır. 
    Bu yere çalıştırılabilir dosyanın yüklendiği dizin (current working directory) dahil değildir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İster statik kütüphane isterse dinamik kütüphane yazacak olalım yazdığımız kütüphaneler için bir başlık dosyası oluşturmak 
    iyi bir tekniktir. Örneğin içerisinde çeşitli fonksiyonların bulunduğu "libmyutil.so" dinamik kütüphanesini "libmyutil.c" 
    dosyasından hareketle oluşturmak isteyelim. İşte "libmyutil.c" dosyasındaki fonksiyonların prototipleri, gerekli olan sembolik 
    sabitler, makrolar, inline fonksiyonlar, yapı bildirimleri gibi "nesne yaratmayan bildirimler" bir başlık dosyasına yerleştirilmelidir. 
    Böylece bu kütüphaneyi kullanacak kişiler bu dosyayı include ederek gerekli bildirimlerin kodlarını oluşturmuş olurlar. 
    Başlık dosyaları oluşturulurken iki önemli noktaya dikkat edilmelidir:

    1) Başlık dosyalarına yalnızca "nesne yaratmayan bildirimler (declarations)" yerleştirilmelidir.
    2) Başlık dosyalarının başına "include koruması (include guard)" yerleştirilmelidir. Include koruması aşağıdaki gibi yapılabilir:

    #ifndef SOME_NAME
    #define SOME_NAME

    <dosyanın içeriği>

    #endif

    Buradaki SOME_NAME dosya isminden hareketle uydurulmuş olan herhangi bir isim olabilir. Örneğin:

    #ifndef MYUTIL_H_
    #define MYUTIL_H_

    <dosyanın içeriği>

    #endif

    Örneğin "myutil.so" dinamik kütüphanesinde foo ve bar isimli iki fonksiyon bulunuyor olsun. Bunun için "myutil.h" isimli
    başlık dosyası aşağıdaki gibi oluşturulabilir:

    #ifndef MYUTIL_H_
    #define MYUTIL_H_

    void foo(void);
    void bar(void);

    #endif
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Standart C fonksiyonlarının ve POSIX fonksiyonlarının bulunduğu "libc" kütüphanesi gcc ve clang programlarıyla derleme 
    yapıldığında otomatik olarak bağlama aşamasında devreye sokulmaktadır. Yani biz standart fonksiyonları ve POSIX fonksiyonları 
    için bağlama aşamasında kütüphane belirtmek zorunda değiliz. Default durumda gcc ve clang programları standart C fonksiyonlarını 
    ve POSIX fonksiyonlarını dinamik kütüphaneden alarak kullanır. Ancak programcı isterse "-static" seçeneği ile statik bağlama 
    işlemi de yapabilir. Bu durumda bu fonksiyonlar statik kütüphanelerden alınarak çalıştırılabilen dosyalara yazılacaktır. 
    Örneğin:

    $ gcc -o app -static app.c

    "-static" seçeneği ile bağlama işlemi yapıldığında artık üretilen çalıştırılabilir dosyanın dinamik kütüphanelerle hiçbir ilgisi 
    kalmamaktadır. Zaten "-static" seçeneği belirtildiğinde artık dinamik kütüphaneler bağlama aşamasına programcı tarafından da 
    dahil edilememektedir. Tabii bu biçimde statik bağlama işlemi yapıldığında çalıştırılabilen dosyanın boyutu çok büyüyecektir.

    Eğer "libc" kütüphanesinin default olarak bağlama aşamasında devreye sokulması istenmiyorsa "-nodefaultlibs" seçeneğinin 
    kullanılması gerekir. Örneğin:

    $ gcc -nodefaultlibs -o app app.c

    Burada glibc kütüphanesi devreye sokulmadığı için bağlama aşamasında hata oluşacaktır. Tabii bu durumda da kütüphane açıkça 
    belirtilebilir:

    $ gcc -nodefaultlibs -o app app.c -lc

    Bir kütüphanenin statik ve dinamik biçimi aynı anda bulunuyorsa ve biz bu kütüphaneyi "-l" seçeneği ile belirtiyorsak bu 
    durumda default olarak kütüphanenin dinamik versiyonu devreye sokulmaktadır. Eğer bu durumda kütüphanelerin statik versiyonlarının 
    devreye sokulması isteniyorsa "-static" seçeneğinin kullanılması ya da komut satırında açıkça statik kütüphaneye referans 
    edilmesi gerekir. Örneğin:

    $ gcc -o app app.c -lmyutil -L.

    Burada eğer hem "libmyutil.so" hem de "libmyutil.a" dosyaları varsa "libmyutil.so" dosyası kullanılacaktır. Yani dinamik bağlama 
    yapılacaktır. Tabii biz açıkça statik kütüphanenin ya da dinamik kütüphanenin kullanılmasını sağlayabiliriz:

    $ gcc -o app app.c libmyutil.a

    Aynı etkiyi şöyle de sağlayabilirdik:

    $ gcc -static -o app app.c -lmyutil -L.

    Burada "libc" kütüphanesinin dinamik biçimi devreye sokulacaktır. Ancak "libmyutil" kütüphanesi statik biçimde bağlanmıştır.
    Eğer "-static" seçeneği kullanılırsa bu durumda tüm kütüphanelerin statik versiyonları devreye sokulmaktadır. Tabii bu durumda 
    biz açıkça dinamik kütüphanelerin bağlama işlemine sokulmasını isteyemeyiz. Örneğin:

    $ gcc -static -o app app.c libmyutil.so

    Bu işlem başarısız olacaktır. Çünkü "-static" seçeneği zaten "tüm kütüphanelerin statik olarak bağlanacağı" anlamına 
    gelmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir programın kullandığı dinamik kütüphaneler ldd isimli utility program ile basit bir biçimde görüntülenebilir. Örneğin:

    $ ldd sample
    linux-vdso.so.1 (0x00007fff38162000)
    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7ec0b5c000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f7ec114f000

    ldd programı dinamik kütüphanelerin kullandığı dinamik kütüphaneleri de görüntülemektedir. Programın doğrudan kullandığı 
    dinamik kütüphanelerin listesi readelf komutuyla aşağıdaki gibi de elde edilebilir:

    $ readelf -d sample | grep "NEEDED"
    0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde dinamik kütüphane kullanan programların yüklenmesi süreci biraz ilginçtir. Anımsanacağı gibi aslında
    her türlü program exec fonksiyonları tarafından yüklenip çalıştırılmaktadır. Bu exec fonksiyonlarının taban olanı "execve"
    isimli fonksiyondur. (Yani diğer exec fonksiyonları bunu çağırmaktadır.) execve fonksiyonu da bir sistem fonksiyonu olarak 
    yazılmıştır.

    Dinamik kütüphane kullanan programların kullandığı dinamik kütüphaneler ismine "dinamik linker (dynamic linker)" denilen
    özel bir program tarafından yüklenmektedir. exec fonksiyonları aslında sıra dinamik kütüphanelerin yüklenmesine geldiğinde 
    dinamik linker denilen bu programı çalıştırmaktadır. Dinamik linker "ld.so" ismiyle temsil edilmektedir. Programın kullandığı 
    dinamik kütüphanelerin başka bir program tarafından yüklenmesi esneklik sağlamaktadır. Bu sayede sistem programcısı isterse 
    (genellikle istemez) bu dinamik linker programını değiştirerek yükleme sürecinde özel işlemler yapabilir. Dinamik linker 
    tamamen user mode'da çalışmaktadır.

    Programın dinamik kütüphanelerinin yüklenmesinde kullanılacak olan dinamik linker'ın yol ifadesi ELF formatında "Program Başlık 
    Tablosu'nda" INTERP türüyle belirtilmektedir. INTERP türüne ilişkin Program Başlığı'nda dinamik bağlayıcının yol ifadesinin 
    bulunduğu dosya offset'i belirtilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bizim programımız örneğin "libmyutil.so" isimli bir dinamik kütüphaneden çağrı yapıyor olsun. Bu "libmyutil.so" 
    dosyasının program çalıştırılırken nerede bulundurulması gerekir? İşte program çalıştırılırken ilgili dinamik kütüphane 
    dosyasının özel bazı dizinlerde bulunuyor olması gerekmektedir. Dinamik kütüphanelerin dinamik bağlayıcı tarafından yüklendiğini
    ve dinamik bağlayıcının da "ld.so" ismiyle temsil edildiğini anımsayınız. "ld.so" ismiyle temsil edilen dinamik bağlayıcı 
    akkında "man ld.so" komutuyla bilgi alabilirsiniz.

    "ld.so" için hazırlanan "man" sayfasında dinamik kütüphaneleri dinamik bağlayıcının nasıl ve nerelerde aradığı maddeler halinde 
    açıklanmıştır. Bu maddeleri tek tek ele almak istiyoruz:

    1) Dinamik bağlayıcı önce çalıştırılabilen dosyanın ".dynamic" bölümündeki DT_RPATH tag'ına bakar. Bu tag'ın değeri tek bir 
    dizin ya da ':' karakterleriyle ayrılmış olan birden fazla dizin belirten bir yazı olabilir. Bu durumda dinamik bağlayıcı 
    bu dizinlere sırasıyla bakmaktadır. Ancak birinci aşamada bu tag'a bakılmasının bir tasarım kusuru olduğu anlaşılmıştır. 
    Bu nedenle ".dynamic" bölümüne DT_RPATH tag'ının yerleştirilmesi "deprecated" yapılmıştır.

    2) Dinamik bağlayıcı yüklenmekte olan program dosyasına ilişkin prosesin LD_LIBRARY_PATH çevre değişkenine bakar. Eğer böyle 
    bir çevre değişkeni varsa dinamik kütüphaneleri bu çevre değişkeninde belirtilen dizinlerde sırasıyla arar. Bu çevre değişkeni 
    ':' karakterleriyle ayrılmış yol ifadelerinden oluşmaktadır. Biz programı genellikle kabuk üzerinden çalıştırdığımıza göre 
    kabukta bu çevre değişkenini aşağıdaki örnekte olduğu gibi set edebiliriz:

    $ export LD_LIBRARY_PATH=/home/kaan:/home/kaan/Study/UnixLinux-SysProg:.

    Burada artık dinamik kütüphaneler sırasıyla "/home/kaan" dizininde, "/home/kaan/Study/UnixLinux-SysProg" dizininde ve prosesin 
    çalışma dizininde (current working directory) aranacaktır. Çevre değişkeninin sonundaki "." karakterinin exec uygulayan 
    prosesin o andaki çalışma dizinini temsil ettiğine dikkat ediniz. Tabii biz kabuk programının değil çalıştırılacak programın 
    çevre değişken listesine ekleme yaparak da programı aşağıdaki gibi çalıştırabiliriz:

    $ LD_LIBRARY_PATH=:. ./app

    3) Dinamik bağlayıcı çalıştırılabilen dosyanın ".dynamic" bölümündeki DT_RUNPATH tag'ına bakar. Birinci aşamada biz DT_RPATH
    tag'ının "deprecated" yapıldığını belirtmiştik. İşte bu tag yerine artık DT_RUNPATH tag'ı kullanılmalıdır. Bu tag'ın değeri 
    de yine ':' karakterleriyle ayrılmış olan dizin listesinden oluşmaktadır. Dinamik bağlayıcı bu dizinlerde sırasıyla arama 
    yapmaktadır. DT_RPATH ile DT_RUNPATH arasındaki tek fark DT_RUNPATH tag'ına LD_LIBRARY_PATH çevre değişkeninden daha sonra 
    bakılmasıdır.

    4) Dinamik bağlayıcı daha sonra "/etc/ld.so.cache" isimli cache dosyasına bakar. Bu cache dosyası her bir dinamik kütüphanenin
    hangi dizinlerde olduğunu belirtmektedir. Bu konu izleyen paragraflarda ele alınacaktır.

    5) Nihayet dinamik bağlayıcı dinamik kütüphaneleri sırasıyla "/lib", /usr/lib" dizinlerinde de aramaktadır. 64 bit Linux 
    sistemlerininin bir bölümünde 64 bit dinamik kütüphaneler için "/lib64" ve "/usr/lib64" dizinlerine de bakılabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki üçüncü maddede aranacak yol ifadesini çalıştırılabilir dosyanın DT_RUNPATH tag'ına yerleştirmek için ld 
    bağlayıcısında "-rpath <yol ifadeleri>" bağlayıcı seçeneği kullanılmalıdır. Buradaki yol ifadelerinin mutlak olması zorunlu 
    değilse de şiddetle tavsiye edilmektedir. gcc ve clang derleyicilerinde "-rpath" seçeneğini bağlayıcıya geçirebilmek için 
    "-Wl" seçeneği kullanılabilir. "-Wl" seçeneği bitişik yazılan virgüllü alanlardan oluşmalıdır. gcc ve clang bu komut satırı 
    argümanını "ld" bağlayıcısına virgüller yerine boşluklar (SPACE) koyarak geçirmektedir. Örneğin:

    $ gcc -o app app.c -Wl,-rpath,/home/kaan/Study/UnixLinux-SysProg libmyutil.so

    Burada ELF formatının DT_RUNPATH tag'ına yerleştirme yapılmaktadır. Çalıştırılabilir dosyaya iliştirilen DT_RUNPATH bilgisi 
    "readelf" programı ile aşağıdaki gibi görüntülenebilir:

    $ readelf -d app | grep "RUNPATH"
    0x000000000000001d (RUNPATH)            Library runpath: [/home/csd/Study/UnixLinux-SysProg

    Biz bu tag'a birden fazla dizin de yerleştirebiliriz. Bu durumda yine dizinleri ':' ile ayırmamız gerekir. Örneğin:

    $ gcc -o app app.c -Wl,-rpath,/home/csd/Study/UnixLinux-SysProg:/home/kaan libmyutil.so

    Birden fazla kez "-rpath" seçeneği kullanıldığında bu seçenekler tek bir DT_RUNPATH tag'ına aralarına ':' karakteri getirilerek 
    yerleştirilmektedir. Yani aşağıdaki işlem yukarıdaki ile eşdeğerdir:

    $ gcc -o app app.c -Wl,-rpath,/home/csd/Study/UnixLinux-SysProg,-rpath,/home/kaan libmyutil.so

    "-rpath" bağlayıcı seçeneğinde default durumda DT_RUNPATH tag'ına yerleştirme yapıldığına dikkat ediniz. Eğer DT_RPATH tag'ına 
    yerleştirme yapılmak isteniyorsa bağlayıcı seçeneklerine ayrıca "--disable-new-dtags" seçeneğinin de girilmesi gerekmektedir. 
    Örneğin:

    $ gcc -o app app.c -Wl,-rpath,/home/csd/Study/UnixLinux-SysProg,--disable-new-dtags libmyutil.so

    DT_RUNPATH tag'ını da aşağıdaki gibi görüntüleyebiliriz:

    $ readelf -d app | grep "RUNPATH"
    0x000000000000001d (RUNPATH)            Library runpath: [/home/kaan/Study/UnixLinux-SysProg]

    Çalıştırılabilir dosyaya DT_RUNPATH tag'ının mutlak ya da göreli yol ifadesi biçiminde girilmesi bazı kullanım sorunlarına yol 
    açabilmektedir. Çünkü bu durumda dinamik kütüphaneler uygulamanın kurulduğu dizine göreli biçimde konuşlandırılacağı zaman 
    uygulamanın kurulum yeri değiştirildiğinde sorunlar oluşabilmektedir. Örneğin biz çalıştırılabilir dosyanın DT_RUNPATH tag'ına 
    "home/kaan/test" isimli yol ifadesini yazmış olalım. Programımızı ve dinamik kütüphanemizi bu dizine yerleştirirsek bir sorun 
    oluşmayacaktır. Ancak başka bir dizine yerleştirirsek dinamik kütüphanemiz bulunamayacaktır. İşte bunu engellemek için "-rpath" 
    seçeneğinde '$ORIGIN' argümanı kullanılmaktadır. Buradaki '$ORIGIN' argümanı "o anda çalıştırılabilen dosyanın bulunduğu dizini" 
    temsil etmektedir. Örneğin:

    $ gcc -o app app.c -Wl,-rpath,'$ORIGIN'/. libmyutil.so

    Burada artık çalıştırılabilen dosya nereye yerleştirilirse yerleştirilsin ve nereden çalıştırılırsa çalıştırılsın dinamik 
    kütüphaneler çalıştırılabilen dosyanın yerleştirildiği dizinde aranacaktır.

    Yukarıda da belirttiğimiz gibi aslında arama sırası bakımından DT_RPATH tag'ının en yukarıda olması (LD_LIBRARY_PATH'in 
    yukarısında olması) yanlış bir tasarımdır. Geriye doğru uyumu koruyarak bu yanlış tasarım DT_RUNPATH tag'ı ile telafi 
    edilmiştir. DT_RUNPATH tag'ına LD_LIBRARY_PATH çevre değişkeninden sonra başvurulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphanelerin aranması sırasında "/lib" ve "/usr/lib" dizinlerine bakılmadan önce özel bir dosyaya da bakılmaktadır. 
    Bu dosya "/etc/ld.so.cache" isimli dosyadır. "/etc/ld.so.cache" dosyası aslında binary bir dosyadır. Bu dosya hızlı aramanın 
    yapılabilmesi için "sözlük (dictionary)" tarzı yani algoritmik aramaya izin verecek biçimde bir içeriğe sahiptir. Bu dosya
    ilgili dinamik kütüphane dosyalarının hangi dizinler içerisinde olduğunu gösteren bir yapıdadır. (Yani bu dosya ".so" dosyalarının 
    hangi dizinlerde olduğunu belirten binary bir dosyadır.) Başka bir deyişle bu dosyanın içerisinde "falanca .so dosyası filanca 
    dizinde" biçiminde bilgiler vardır. İlgili ".so" dosyasının yerinin bu dosyada aranması dizinlerde aranmasından çok daha 
    hızlı yapılabilmektedir. Ayrıca dinamik kütüphaneler değişik dizinlerde bulunabilmektedir. Bunların LD_LIBRARY_PATH çevre 
    değişkeninde belirtilen dizinlerde tek tek aranması bir yavaşlık oluşturabilmektedir.

    Pekiyi bu "/etc/ld.so.cache" dosyasının içerisinde hangi ".so" dosyaları vardır? Aslında bu dosyanın içerisinde "/lib" ve 
    "/usr/lib" dizinindeki ".so" dosyalarının hepsi bulunmaktadır. Ama programcı isterse kendi dosyalarını da bu cache dosyasının 
    içerisine yerleştirebilir. Burada dikkat edilmesi gereken nokta bu cache dosyasına "/lib" ve "/usr/lib" dizinlerinden 
    daha önce bakıldığı ve bu dizinlerin içeriğinin de zaten bu cache dosyasının içerisinde olduğudur. O halde aslında "/lib" ve 
    "/usr/lib" dizinlerinde arama çok nadir olarak yapılmaktadır. Ayrıca bu cache dosyasına LD_LIBRARY_PATH çevre değişkeninden 
    daha sonra bakıldığına dikkat ediniz. O halde programcının kendi ".so" dosyalarını da -eğer uzun süreliğine konuşlandıracaksa- 
    bu cache dosyasının içerisine yerleştirmesi tavsiye edilmektedir.

    Pekiyi "/etc/ld.so.cache" dosyasına biz nasıl bir dosya ekleriz? Aslında programcı bunu dolaylı olarak yapmaktadır. Şöyle ki: 
    "/sbin/ldconfig" isimli bir program vardır. Bu program "/etc/ld.so.conf" isimli bir text dosyasına bakar. Bu dosya dizinlerden 
    oluşmaktadır. Bu "ldconfig" programı bu dizinlerin içerisindeki "so" dosyalarını "/etc/ld.so.cache" dosyasına eklemektedir. 
    Şimdilerde "/etc/ld.so.conf" dosyasının içeriği şöyledir:

    include /etc/ld.so.conf.d/*.conf

    Bu satır "/etc/ld.so.conf.d" dizinindeki tüm ".conf" uzantılı dosyaların bu işleme dahil edileceğini belirtmektedir.

    Biz "ldconfig" programını çalıştırdığımızda bu program "/lib", "/usr/lib" ve "/etc/ld.so.conf" (dolayısıyla "/etc/ld.so.conf.d" 
    dizinindeki ".conf" dosyalarına) bakarak "/etc/ld.so.cache" dosyasını yeniden oluşturmaktadır. O halde bizim bu cache'e ekleme 
    yapmak için tek yapacağımız şey "/etc/ld.so.conf.d" dizinindeki bir ".conf" dosyasına yeni bir satır olarak bir dizinin yol 
    ifadesini girmektir. (".conf" dosyaları her satırda bir dizinin yol ifadesinden oluşmaktadır.) Tabii programcı isterse bu dizine 
    yeni bir ".conf" dosyası da ekleyebilir. İşte programcı bu işlemi yaptıktan sonra "/sbin/ldconfig" programını çalıştırınca artık 
    onun eklediği dizinin içerisindeki ".so" dosyaları da "/etc/ld.so.cache" dosyasının içerisine eklenmiş olacaktır. Daha açık bir 
    anlatımla programcı bu cache dosyasına ekleme işini adım adım şöyle yapar:

    1) Önce ".so" dosyasını bir dizine yerleştirir.
    2) Bu dizinin ismini "/etc/ld.so.conf.d" dizinindeki bir dosyanın sonuna ekler. Ya da bu dizinde yeni ".conf" dosyası oluşturarak
    dizini bu dosyanın içerisine yazar.
    3) "/sbin/ldconfig" programını çalıştırır.

    "ldconfig" programının "sudo" ile çalıştırılması gerektiğine dikkat ediniz. Zaten "/sbin" dizinindeki tüm programlar "super user"
    için bulundurulmuştur.

    Programcı "/etc/ld.so.conf.d" dizinindeki herhangi bir dosyaya değil de "-f" seçeneği sayesinde kendi belirlediği bir dosyaya 
    da ilgili dizinleri yazabilmektedir. Başka bir deyişle "-f" seçeneği "şu config dosyasına da bak" anlamına gelmektedir. "ldconfig"
    her çalıştırıldığında sıfırdan yeniden cache dosyasını oluşturmaktadır.

    Programcı "/lib" ya da "/usr/lib" dizinine bir ".so" dosyası eklediğinde "ldconfig" programını çalıştırması -zorunlu olmasa da- 
    iyi bir tekniktir. Çünkü o dosya da cache dosyasına yazılacak ve daha hızlı bulunacaktır.

    ldconfig programında "-p" seçeneği ile cache dosyası içerisindeki tüm dosyalar görüntülenebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kütüphane dosyalarının "so" isimleri denilen bir isimleri de bulunabilmektedir. Kütüphane dosyalarının "so" isimleri linker 
    tarafından kullanılan isimleridir. Kütüphane dosyası oluşturulurken "so" isimleri verilmeyebilir. Yani bir kütüphane dosyasının 
    "so" ismi olmak zorunda değildir. Kütüphane dosyalarına "so" isimlerini vermek için "-soname <isim>" linker seçeneği 
    kullanılmaktadır. Kütüphanelere verilen "so" isimleri ELF formatının dinamik bölümündeki (dynamic section) SONAME isimli 
    bir tag'ına yerleştirilmektedir. "-soname" komut satırı argümanı linker'a ilişkin olduğu için "-Wl" seçeneği ile kullanılmalıdır. 
    Örneğin biz libx.so isimli bir dinamik kütüphaneyi "so" ismi vererek oluşturmak isteyelim. Bu işlemi şöyle yapabiliriz:

    $ gcc -o libx.so -fPIC -shared -Wl,-soname,liby.so libx.c

    Burada "libx.so" kütüphane dosyasına "liby.so" "so" ismi verilmiştir. Kütüphane dosyalarına iliştirilen "so" isimleri 
    readelf ile aşağıdaki gibi görüntülenebilir:

    $ readelf -d libx.so | grep "SONAME"
    0x000000000000000e (SONAME)             Kitaplık so_adı: [liby.so]

    Aynı işlem objdump programıyla da şöyle yapılabilir:

    objdump -x libx.so | grep "SONAME"
    SONAME               liby.so

    Tabii yukarıda da belirttiğimiz gibi biz dinamik kütüphanelere "so" ismi vermek zorunda değiliz.

    "so" ismi içeren bir kütüphaneyi kullanan bir program link edilirken linker çalıştırılabilen dosyaya "so" ismini içeren 
    kütüphanenin ismini değil "so" ismini yazmaktadır. Yukarıdaki örneğimizde "libx.so" kütüphanesi "so" ismi olarak "liby.so"
    ismini içermektedir. Şimdi libx.so dosyasını kullanan "app.c" dosyasını derleyip link edelim:

    $ gcc -o app app.c libx.so

    Burada link işleminde "libx.so" dosya ismi kullanılmıştır. Ancak oluşturulan "app" dosyasının içerisine linker bu ismi 
    değil, "so" ismi olan "liby.so" ismini yazacaktır. Örneğin:

    $ readelf -d app | grep "NEEDED"
    0x0000000000000001 (NEEDED)             Paylaşımlı kitaplık: [liby.so]
    0x0000000000000001 (NEEDED)             Paylaşımlı kitaplık: [libc.so.6]

    O halde biz buradaki "app" dosyasını çalıştırmak istediğimizde yükleyici (yani dinamik linker) artık "libx.so" dosyasını 
    değil, "liby.so" dosyasını yüklemeye çalışacaktır. Örneğin.

    $ export LD_LIBRARY_PATH=.
    $ ./app
    ./app: error while loading shared libraries: liby.so: cannot open shared object file: No such file or directory

    Tabii yukarıda belirttiğimiz gibi eğer kütüphaneyi oluştururken ona "so" ismi vermeseydik bu durumda linker "app" dosyasına
    "libx.so" dosyasını yazacaktı ve yükleyici de (dynamic linker) bu dosyası yükleyecekti.

    Pekiyi yukarıdaki örnekte "app" programı artık "liby.so" dosyasını kullanıyor gibi olduğuna göre ve böyle de bir dosya 
    olmadığına göre bu işlemlerin ne anlamı vardır? İşte biz bu örnekte "so" ismine ilişkin dosyayı bir sembolik link dosyası 
    haline getirirsek ve bu sembolik link dosyası da "libx.so" dosyasını gösterir hale gelirse sorunu ortadan kaldırabiliriz. 
    Örneğin:

    $ ln -s libx.so liby.so
    $ ls -l liby.so
    lrwxrwxrwx 1 kaan study 7 Şub 25 16:44 liby.so -> libx.so

    Şimdi artık "app" dosyasını çalıştırmak istediğimizde yükleyici "liby.so" dosyasını yüklemek isteyecektir. Ancak "liby.so" 
    dosyası da zaten "libx.so" dosyasını belirttiği için yine "libx.so" dosyası yüklenecektir. Yani artık "app" dosyasını 
    çalıştırabiliriz. Tabii burada tüm bunları neden yapmış olduğumuza bir anlam verememiş olabilirsiniz. İşte bunun anlamını 
    izleyen paragraflarda dinamik kütüphanelerin versiyonlanması konusunda açıklayacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde dinamik kütüphane dosyalarına isteğe bağlı olarak birer versiyon numarası verilebilmektedir. Bu 
    versiyon numarası dosya isminin bir parçası durumundadır. Linux sistemlerinde izlenen tipik numaralandırma (convention) 
    şöyledir:

    <dosya_ismi>.so.<majör_numara>.<minör_yüksek_numara>.<minör_alçak_numara>

    Örneğin:

    libmyutil.so.2.4.6

    Majör numaralar büyük değişiklikleri, minör numaralar ise küçük değişiklikleri anlatmaktadır. Majör numara değişirse yeni 
    dinamik kütüphane eskisiyle uyumlu olmaz. Burada "uyumlu değildir" lafı eski dinamik kütüphaneyi kullanan programların 
    yenisini kullanamayacağı anlamına gelmektedir. Çünkü muhtemelen bu yeni versiyonda fonksiyonların isimlerinde, parametrik 
    yapılarında değişiklikler söz konusu olmuş olabilir ya da bazı fonksiyonlar silinmiş olabilir. Fakat majör numarası aynı 
    ancak minör numaraları farklı olan kütüphaneler birbirleriyle uyumludur. Yani alçak minör numarayı kullanan program yüksek 
    minör numarayı kullanırsa sorun olmayacaktır. Bu durumda tabii yüksek minör numaralı kütüphanede hiçbir fonksiyonun ismi, 
    parametrik yapısı değişmemiş ve hiçbir fonksiyon silinmemiş olmalıdır. Örneğin yüksek minör numaralarda fonksiyonlarda 
    daha hızlı çalışacak biçimde optimizasyonlar yapılmış olabilir. Ya da örneğin yüksek minör numaralarda yeni birtakım 
    fonksiyonlar da eklenmiş olabilir. Çünkü yeni birtakım fonksiyonlar eklendiğinde eski fonksiyonlar varlığını devam ettirmektedir. 
    Tabii yine de bu durum dinamik kütüphanenin eski versiyonunu kullanan programların düzgün çalışacağı anlamına gelmemektedir. 
    Çünkü programcılar kodlarına yeni birtakım şeyler eklerken istemeden eski kodların çalışmasını da bozabilmektedir. (Bu tür 
    problemler Windows sistemlerinde eskiden ciddi sıkıntılara yol açmaktaydı. Bu probleme Windows sistemlerinde "DLL cehennemi 
    (DLL Hell)" deniyordu.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde versiyonlama bakımından bir dinamik kütüphanenin üç ismi bulunmaktadır:

    1) Gerçek ismi (real name)
    2) so ismi (so name)
    3) Linker ismi (linker name)

    Kütüphanenin majör ve çift minör versiyonlu ismine gerçek ismi denilmektedir. Örneğin:

    libmyutil.so.2.4.6

    "so" ismi ise yalnızca majör numara içeren ismidir. Örneğin yukarıdaki gerçek ismin "so" ismi şöyledir:

    libmyutil.so.2

    Linker ismi ise hiç versiyon numarası içermeyen ismidir. Örneğin yukarıdaki kütüphanelerin linker ismi ise şöyledir:

    libmyutil.so

    İşte tipik olarak "so" ismi gerçek isme sembolik link, linker ismi de en yüksek numaralı "so" ismine sembolik link yapılır.

    linker ismi ---> so ismi ---> gerçek ismi

    Örneğin:

    $ gcc -o libmyutil.so.1.0.0 -shared -fPIC libmyutil.c     (gerçek isimli kütüphane dosyası oluşturuldu)
    $ ln -s libmyutil.so.1.0.0 libmyutil.so.1                 (so ismi oluşturuldu)
    $ ln -s libmyutil.so.1 libmyutil.so                       (linker ismi oluşturuldu)

    Burada oluşturulan üç dosyayı "ls -l" komutu ile görüntüleyelim:

    lrwxrwxrwx 1 kaan study    14 Şub 25 15:45 libmyutil.so -> libmyutil.so.1
    lrwxrwxrwx 1 kaan study    18 Şub 25 15:45 libmyutil.so.1 -> libmyutil.so.1.0.0
    -rwxr-xr-x 1 kaan study 15736 Şub 25 15:45 libmyutil.so.1.0.0
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                123. Ders 25/02/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphanelerin linker isimleri o kütüphaneyi kullanan programlar link edilirken link aşamasında (link ederken) 
    kullanılan isimlerdir. Bu sayede link işlemini yapan programcıların daha az tuşa basarak genel bir isim kullanması 
    sağlanmıştır. Bu durumda örneğin biz libmyutil isimli kütüphaneyi kullanan programı link etmek istersek şöyle yapabiliriz:

    $ gcc -o app app.c libmyutil.so

    Ya da şöyle yapabiliriz:

    $ gcc -o app app.c -lmyutil -L.

    Burada aslında "libmyutil.so" dosyası "so ismine" "so" ismi de "gerçek isme link yapılmış" durumdadır. Yani bu komutun 
    aslında eşdeğeri şöyledir:

    $ gcc -o app app.c libmyutil.so.1.0.0
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                124. Ders 01/03/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda anlattıklarımızı özetlersek geldiğimiz noktayı daha iyi kavrayabiliriz:

    1) Bir dinamik kütüphane oluştururken ona bir versiyon numarası da atanabilmektedir. Örneğin biz oluşturduğumuz "myutil" 
    dinamik kütüphanesine "1.0.0" versiyon numarası atamış olalım. Bu durumda kütüphanemizin gerçek ismi "libmyutil.so.1.0.0" 
    olacaktır. Kütüphanemizi aşağıdaki gibi derlemiş olalım:

    $ gcc -fPIC -shared -o libmyutil.so.1.0.0 -Wl,-soname,libmyutil.so.1 libmyutil.c

    2) Dinamik kütüphanelerin "so ismi" kütüphanelerin içerisine yazılan ismidir. Yukarıdaki gibi bir derlemede biz "libmyutil.so.1.0.0"
    kütüphanesinin içerisine "so ismi" olarak "libmyutil.so" ismini yerleştirdik. "so isimleri" genel olarak yalnızca majör 
    numara içeren isimlerdir. Bizim bu aşamada tipik olarak bir sembolik link oluşturarak "so" ismine ilişkin dosyanın gerçek 
    kütüphane dosyasını göstermesini sağlamamız gerekir. Bunu şöyle yapabiliriz:

    $ ln -s libmyutil.so.1.0.0 libmyutil.so.1

    Şimdi her iki dosyayı da görüntüleyelim:

    lrwxrwxrwx 1 kaan study    18 Mar  1 20:02 libmyutil.so.1 -> libmyutil.so.1.0.0
    -rwxr-xr-x 1 kaan study 15736 Mar  1 19:57 libmyutil.so.1.0.0

    3) Dinamik kütüphanenin link aşamasında kullanılmasını kolaylaştırmak için sonunda versiyon uzantısı olmayan bir "linker ismi"
    oluşturabiliriz. Tabii bu linker ismi aslında gerçek kütüphaneye referans edecektir. Ancak bu referansın doğrudan değil de "so ismi"
    üzerinden yapılması daha esnek bir kullanıma yol açacaktır. Örneğin:

    $ ln -s libmyutil.so.1 libmyutil.so

    Artık kütüphanenin "linker ismi" "so ismine", "so ismi" de gerçek ismine sembolik link yapılmış durumdadır. Bu üç dosyayı 
    aşağıda yeniden görüntüleyelim:

    lrwxrwxrwx 1 kaan study    14 Mar  1 20:07 libmyutil.so -> libmyutil.so.1
    lrwxrwxrwx 1 kaan study    18 Mar  1 20:02 libmyutil.so.1 -> libmyutil.so.1.0.0
    -rwxr-xr-x 1 kaan study 15736 Mar  1 19:57 libmyutil.so.1.0.0

    Aşağıdaki gibi bir durum elde ettiğimize dikkat ediniz:

    Linker ismi ---> so ismi ---> gerçek isim

    4) Şimdi kütüphaneyi kullanan bir "app" programını derleyip link edelim:

    $ gcc -o app app.c libmyutil.so

    Şimdi LD_LIBRARY_PATH çevre değişkenini belirleyip programı çalıştıralım:

    $ LD_LIBRARY_PATH=. ./app
    30.000000
    -10.000000
    200.000000
    0.500000

    Burada app programının kullandığı kütüphane ismi app dosyasının içerisinde kütüphanenin "so ismi" olarak set edilecektir. 
    Yani burada "app" dosyası sanki "libmyutil.so.1" dosyasını kullanıyor gibi olacaktır. Örneğin:

    $ readelf -d app | grep "NEEDED"
    0x0000000000000001 (NEEDED)             Paylaşımlı kitaplık: [libmyutil.so.1]
    0x0000000000000001 (NEEDED)             Paylaşımlı kitaplık: [libc.so.6]

    İşte "app" programını yükleyecek olan dinamik linker aslında "libmyutil.so.1" dosyasını yüklemeye çalışacaktır. Bu dosyann 
    kütüphanenin gerçek ismine sembolik link yapıldığını anımsayınız. Bu durumda gerçekte yüklenecek olan dosya "libmyutil.so.1" 
    dosyası değil, "libmyutil.so.1.0.0" dosyası olacaktır. Yani çalışmada bir sorun ortaya çıkmayacaktır. Pekiyi tüm bunların 
    amacı nedir? Bunu şöyle açıklayabiliriz:

    1) Örneğin kütüphanemizin libmyutil.so.1.1.0 biçiminde majör numarası aynı, minör numarası farklı öncekiyle uyumlu yeni bir 
    versiyonunun daha oluşturulduğunu düşünelim. Şimdi biz uygulamamızı çektiğimiz dizin içerisindeki "libmyutil.so" dosyasını 
    bu yeni versiyonu referans edecek biçimde değiştirebiliriz. Bu durumda dinamik linker "app" programını yüklemeye çalışırken 
    aslında artık "libmyutil.so.1.1.0" kütüphanesini yükleyecektir. Burada biz hiç "app" dosyasının içini değiştirmeden artık "app"
    dosyasının kütüphanenin yeni minör versiyonunu kullanmasını sağlamış olduk.

    2) Şimdi de kütüphanemizin "libmyutil.so.2.0.0" biçiminde yeni bir majör versiyonunun oluşturulduğunu varsayalım. 1 numaralı 
    majör versiyonla 2 numaralı majör versiyon birbirleriyle uyumlu değildir. Biz bu "libmyutil.so.2.0.0" yeni versiyonu derlerken ona
    "so ismi" olarak artık "libmyutil.so.2" ismini vermeliyiz. Tabii bu durumda biz yine "libmyutil.so.2" sembolik bağlantı dosyasının 
    "libmyutil.so.2.0.0" dosyasını göstermesini sağlamalıyız. Artık kütüphanenin 2'nci versiyonunu kullanan programlarda yüklenecek 
    kütüphane "libmyutil.so.2" kütüphanesi olacaktır. Bu kütüphanede 2'nci versiyonunun gerçek kütüphane ismine sembolik link yapılmış 
    durumdadır.

    "so ismine" ilişkin sembolik link çıkartma ve "/etc/ld.so.cache" dosyasının güncellenmesi işlemi ldconfig tarafından otomatik 
    yapılabilmektedir. Yani aslında örneğin biz kütüphanenin gerçek isimli dosyasını "/lib" ya da "/usr/lib" içerisine yerleştirip 
    "ldconfig" programını çalıştırdığımızda bu program zaten "so ismine" ilişkin sembolik linki de oluşturmaktadır. Örneğin biz 
    "libmyutil.so.1.0.0" dosyasını "/usr/lib" dizinine kopyalayalım ve "ldconfig" programını çalıştıralım. "ldconfig" programı 
    "libmyutil.so.1" sembolik link dosyasını oluşturup bu sembolik link dosyasının "libmyutil.so.1.0.0" dosyasına referans etmesini 
    sağlayacaktır. Tabii cache'e de "libmyutil.so.1" dosyasını yerleştirecektir. Örneğin:

    $ ldconfig -p | grep "libmyutil"
    libmyutil.so.1 (libc6,x86-64) => /lib/libmyutil.so.1
    $ ls -l /usr/lib | grep "libmyutil"
    lrwxrwxrwx  1 root root       18 Mar  1 21:02 libmyutil.so.1 -> libmyutil.so.1.0.0
    -rwxr-xr-x  1 root root    15736 Mar  1 21:01 libmyutil.so.1.0.

    Özetle Dinamik kütüphane kullanırken şu konvansiyona uymak iyi bir tekniktir:

    - Kütüphane ismini "lib" ile başlatarak vermek
    - Kütüphane ismine majör ve minör numara vermek
    - Gerçek isimli kütüphane dosyasını oluştururken "so ismi" olarak "-Wl,-soname" seçeneği ile kütüphanenin "so ismini" yazmak
    - Kütüphane için "linker ismi" ve "so ismini" sembolik link biçiminde oluşturmak
    - Kütüphane paylaşılacaksa onu "/lib" ya da tercihen "/usr/lib" dizinine yerleştirmek ve ldconfig programı çalıştırarak 
    /etc/ld.so.cache dosyasının güncellenmesini sağlamak
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphane dosyaları program çalıştırıldıktan sonra çalışma zamanı sırasında çalışmanın belli bir aşamasında 
    da yüklenebilir. Buna "dinamik kütüphane dosyalarının dinamik yüklenmesi" de denilmektedir. Dinamik kütüphane dosyalarının 
    baştan "dinamik linker" tarafından değil de programın çalışma zamanı sırasında yüklenmesinin bazı avantajları şunlar 
    olabilmektedir:

    1) Dinamik kütüphaneler baştan yüklenmediği için program başlangıçta daha hızlı yüklenebilir.

    2) Programın sanal bellek alanı gereksiz bir biçimde doldurulmayabilir. Örneğin nadiren çalışacak bir fonksiyon dinamik 
    kütüphanede olabilir. Bu durumda o dinamik kütüphanenin işin başında yüklenmesi gereksiz bir yükleme zamanı ve bellek 
    israfına yol açabilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphanelerin dinamik yüklenmesi dlopen, dlsym, dlerror ve dlclose fonksiyonlarıyla yapılmaktadır. Bu fonksiyonlar 
    "libdl" kütüphanesi içerisindedir. Dolayısıyla link işlemi için -ldl seçeneğinin bulundurulması gerekir. Dinamik kütüphanelerin
    dinamik yüklenmesi için önce "dlopen" fonksiyonu ile dinamik kütüphanenin yüklenmesinin sağlanması gerekir. dlopen fonksiyonunun 
    prototipi şöyledir:

    #include <dlfcn.h>

    void *dlopen(const char *filename, int flag);

    Fonksiyonun birinci parametresi yüklenecek dinamik kütüphanenin yol ifadesini, ikinci parametresi seçenek belirten bayrakları 
    almaktadır. Fonksiyon başarı durumunda kütüphaneyi temsil eden bir handle değerine, başarısızlık durumunda NULL adrese geri 
    dönmektedir. Başarısızlık durumunda fonksiyon errno değişkenini set etmez. Başarısızlığa ilişkin yazı doğrudan dlerror 
    fonksiyonuyla elde edilmektedir:

    char *dlerror(void);

    dlopen fonksiyonunun birinci parametresindeki dinamik kütüphane isminde eğer hiç / karakteri yoksa bu durumda kütüphanenin 
    aranması daha önce ele aldığımız prosedüre göre yapılmaktadır. Eğer dosya isminde en az bir / karakteri varsa dosya yalnızca 
    bu mutlak ya da göreli yol ifadesinde aranmaktadır. Dinamik yükleme sırasında yüklenecek kütüphanenin SONAME alanında yazılan 
    isme hiç bakılmamaktadır. (Bu SONAME alanındaki isim yalnızca link aşamasında linker tarafından kullanılmaktadır.)

    Örneğin:

    void *dlh;

    if ((dlh = dlopen("libmyutil.so.1.0.0", RTLD_NOW)) == NULL) {
        fprintf(stderr, "dlopen: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    Burada dlopen fonksiyonunun ikinci parametresine RTLD_NOW bayrağı geçilmiştir. Bu bayrağın etkisi izleyen paragraflarda ele
    alınacaktır.

    Kütüphanenin adres alanından boşaltılması ise dlclose fonksiyonuyla yapılmaktadır:

    #include <dlfcn.h>

    int dlclose(void *handle);

    Aynı kütüphane dlopen fonksiyonu ile ikinci kez yüklenebilir. Bu durumda gerçek bir yükleme yapılmaz. Ancak yüklenen 
    sayıda close işleminin yapılması gerekmektedir.

    Kütüphanenin içerisindeki fonksiyonlar ya da global nesneler adresleri elde edilerek kullanılırlar. Bunların adreslerini 
    elde edebilmek için dlsym isimli fonksiyon kullanılmaktadır:

    #include <dlfcn.h>

    void *dlsym(void *handle, const char *symbol);

    Fonksiyon başarı durumunda ilgili sembolün adresine, başarısızlık durumunda NULL adrese geri döner. Örneğin:

    double (*padd)(double, double);
    ...

    if ((padd = (double (*)(double, double))(dlsym(dlh, "add")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    result = padd(10, 20);
    printf("%f\n", result);

    Ancak burada C standartları bağlamında bir pürüz vardır. C'de (ve tabii C++'ta) fonksiyon adresleri ile data adresleri tür
    dönüştürme operatörü ile bile dönüştürülememektedir. Yani yukarıdaki tür dönüştürmesi ile atama geçersizdir. Ayrıca void * türü
    data adresi için anlamlıdır. Yani biz C'de de C++'ta da void bir adresi fonksiyon göstericisine, fonksiyon adresini de 
    void bir göstericiye atayamayız. Ancak pek çok derleyici default durumda bu biçimdeki dönüştürmeleri kabul etmektedir. Yani 
    yukarıdaki kod aslında C'de geçersiz olmasına karşın gcc ve clang derleyicilerinde sorunsuz derlenecektir. (Derleme sırasında 
    -pedantic-errors seçeneği kullanılırsa derleyiciler standartlara uyumu daha katı bir biçimde ele almaktadır. Dolayısıyla 
    yukarıdaki kod bu seçenek kullanılarak derlenirse error oluşacaktır.) Pekiyi bu durumda ne yapabiliriz? İşte bunun için bir 
    hile vardır. Fonksiyon göstericisinin adresini alırsak artık o bir data göstericisi haline gelir. Bir daha * kullanırsak 
    data göstericisi gibi aslında fonksiyon göstericisinin içerisine değer atayabiliriz. Örneğin:

    if ((*(void **)&padd = dlsym(dlh, "add")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    Sembol isimleri konusunda dikkat etmek gerekir. Çünkü bazı derleyiciler bazı koşullar altında isimleri farklı isim gibi 
    object dosyaya yazabilmektedir. Buna "name decoration" ya da "name mangling" denilmektedir. Örneğin C++ derleyicileri 
    fonksiyon isimlerini parametrik yapıyla kombine ederek başka bir isimle object dosyaya yazar. Halbuki dlsym fonksiyonunda 
    sembolün dinamik kütüphanedeki dekore edilmiş isminin kullanılması gerekmektedir. Sembollerin dekore edilmiş isimlerini 
    elde edebilmek için "nm" utility'sini kullanabilirsiniz. Örneğin:

    $ nm libmyutil.so.1.0.0

    nm utility'si ELF formatının string tablosunu görüntülemektedir. Aynı işlem readelf programında -s ile de yapılabilir:

    $ readelf -s libmyutil.so.1.0.0

    Aşağıda bir dinamik kütüphane dinamik olarak yüklenmiş ve oradan bir fonksiyon ve data adresi alınarak kullanılmıştır. 
    Buradaki dinamik kütüphaneyi daha önce yaptığımız gibi derleyebilirsiniz:

    $ gcc -fPIC -shared -o libmyutil.so.1.0.0 -Wl,-soname,libmyutil.so.1 libmyutil.c
---------------------------------------------------------------------------------------------------------------------------*/

/* libmyutil.c */

#include <stdio.h>

double add(double a, double b)
{
    return a + b;
}

double sub(double a, double b)
{
    return a - b;
}

double multiply(double a, double b)
{
    return a * b;
}

double divide(double a, double b)
{
    return a / b;
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

typedef double (*PROC)(double, double);

int main(void)
{
    void *dlh;
    PROC padd, psub, pmul, pdiv;
    double result;

    if ((dlh = dlopen("libmyutil.so.1.0.0", RTLD_NOW)) == NULL) {
        fprintf(stderr, "dlopen: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    if ((*(void **)&padd = dlsym(dlh, "add")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    result = padd(10, 20);
    printf("%f\n", result);

    if ((*(void **)&psub = dlsym(dlh, "sub")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    result = psub(10, 20);
    printf("%f\n", result);

    if ((*(void **)&pmul = dlsym(dlh, "multiply")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    result = pmul(10, 20);
    printf("%f\n", result);

    if ((*(void **)&pdiv = dlsym(dlh, "divide")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    result = pdiv(10, 20);
    printf("%f\n", result);

    dlclose(dlh);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphane dlopen fonksiyonuyla yüklenirken global değişkenlerin ve fonksiyonların nihai yükleme adresleri bu dlopen 
    işlemi sırasında hesaplanabilir ya da onlar kullanıldıklarında hesaplanabilir. İkisi arasında kullanıcı açısından bir fark 
    olmamakla birlikte tüm sembollerin adreslerinin yükleme sırasında hesaplanması bazen yükleme işlemini (eğer çok sembol varsa) 
    uzatabilmektedir. Bu durumu ayarlamak için dlopen fonksiyonunun ikinci parametresi olan flags parametresi kullanılır. Bu flags 
    parametresi RTLD_NOW olarak girilirse (yukarıdaki örnekte böyle yaptık) tüm sembollerin adresleri dlopen sırasında, RTLD_LAZY 
    girilirse kullanıldıkları noktada hesaplanmaktadır. İki biçim arasında çoğu kez programcı için bir farklılık oluşmamaktadır. 
    Ancak aşağıdaki örnekte bu iki biçimin ne anlama geldiği gösterilmektedir.

    Aşağıdaki örnekte "libmyutil.so.1.0.0" kütüphanesindeki foo fonksiyonu gerçekte olmayan bir bar fonksiyonunu çağırmıştır. Bu 
    fonksiyonun gerçekte olmadığı foo fonksiyonunun sembol çözümlemesi yapıldığında anlaşılacaktır. İşte eğer bu kütüphaneyi 
    kullanan "app.c" programı kütüphaneyi RTLD_NOW ile yüklerse tüm semboller o anda çözülmeye çalışılacağından dolayı bar 
    fonksiyonunun bulunmuyor olması hatası da dlopen sırasında oluşacaktır. Eğer kütüphane RTLD_LAZY ile yüklenirse bu durumda 
    sembol çözümlemesi foo'nun kullanıldığı noktada (yani dlsym fonksiyonunda) gerçekleşecektir. Dolayısıyla hata da o noktada 
    oluşacaktır. Bu programı RTLD_NOW ve RTLD_LAZY bayraklarıyla ayrı ayrı derleyip çalıştırınız.
---------------------------------------------------------------------------------------------------------------------------*/

/* libmyutil.c */

#include <stdio.h>

void bar(void);

void foo(void)
{
    bar();
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

int main(void)
{
    void *dlh;
    void (*pfoo)(void);
    double result;

    if ((dlh = dlopen("libmyutil.so.1.0.0", RTLD_LAZY)) == NULL) {
        fprintf(stderr, "dlopen: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    printf("dlopen called\n");

    if ((*(void **)&pfoo = dlsym(dlh, "foo")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    pfoo();

    dlclose(dlh);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                125. Ders 03/03/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bazen bir dinamik kütüphane içerisindeki sembollerin o dinamik kütüphaneyi kullanan kodlar tarafından kullanılması istenmeyebilir. 
    Örneğin dinamik kütüphanede "bar" isimli bir fonksiyon vardır. Bu fonksiyon bu dinamik kütüphanenin kendi içerisinden başka 
    fonksiyonlar tarafından kullanılıyor olabilir. Ancak bu fonksiyonun dinamik kütüphanenin dışından kullanılması istenmeyebilir.
    (Bunun çeşitli nedenleri olabilir. Örneğin kapsülleme sağlamak için, dışarıdaki sembol çakışmalarını ortadan kaldırmak için vs.) 
    İşte bunu sağlamak amacıyla gcc ve clang derleyicilerine özgü "__attribute__((...))" eklentisinden faydalanılmaktadır. "__attribute__((...))" 
    eklentisi pek çok seçeneğe sahip platform spesifik bazı işlemlere yol açmaktadır. Bu eklentinin seçeneklerini gcc dokümanlarından 
    elde edebilirsiniz. Bizim bu amaçla kullanacağımız "__attribute__((...))" seçeneği "visibility" isimli seçenektir.

    Aşağıdaki örnekte bar fonksiyonu foo fonksiyonu tarafından kullanılmaktadır. Ancak kütüphanenin dışından bu fonksiyonun 
    kullanılması istenmemiştir. Eğer fonksiyon isminin soluna "__attribute__((visibility("hidden")))" yazılırsa bu durumda 
    bu fonksiyon dinamik kütüphanenin dışından herhangi bir biçimde kullanılamaz. Örneğin:

    void __attribute__((visibility("hidden"))) bar(void)
    {
        // ...
    }

    Burada fonksiyon özelliğinin (yani __attribute__ sentaksının) fonksiyon isminin hemen soluna getirildiğine ve çift parantez 
    kullanıldığına dikkat ediniz. Burada kullanılan özellik "visibility" isimli özelliktir ve bu özelliğin değeri "hidden" 
    biçiminde verilmiştir.

    Aşağıdaki örnekte "libmyutil.so.1.0.0" kütüphanesindeki foo fonksiyonu dışarıdan çağrılabildiği halde bar fonksiyonu 
    dışarıdan çağrılamayacaktır. Tabii kütüphane içerisindeki foo fonksiyonu bar fonksiyonunu çağırabilmektedir. Dosyaları
    aşağıdaki gibi derleyebilirsiniz:

    $ gcc -shared -fPIC -Wl,-soname,libmyutil.so.1 -o libmyutil.so.1.0.0 libmyutil.c
    $ gcc -o app app.c libmyutil.so.1.0.0 -ldl
---------------------------------------------------------------------------------------------------------------------------*/

/* libmyutil.c */

#include <stdio.h>

void __attribute__((visibility("hidden"))) bar(void)
{
    printf("bar\n");
}

void foo(void)
{
    printf("foo\n");

    bar();
}

/* app.c */

#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

int main(void)
{
    void *dlh;
    void (*pfoo)(void);
    void (*pbar)(void);
    double result;

    if ((dlh = dlopen("./libmyutil.so.1.0.0", RTLD_NOW)) == NULL) {
        fprintf(stderr, "dlopen: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    if ((*(void **)&pfoo = dlsym(dlh, "foo")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    pfoo();

    if ((*(void **)&pbar = dlsym(dlh, "bar")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    pbar();

    dlclose(dlh);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi dinamik kütüphaneyi dinamik yüklemeyip normal yöntemle kullansaydık ne olacaktı? İşte bu durumda hata, programı link
    ederken oluşmaktadır. Örneğin:

    $ gcc -shared -fPIC -Wl,-soname,libmyutil.so.1 -o libmyutil.so.1.0.0 libmyutil.c
    $ gcc -o app app.c libmyutil.so.1.0.0 -ldl
    /usr/bin/ld: /tmp/ccK2cCXC.o: in function `main':
    app.c:(.text+0xe): undefined reference to `bar'
    collect2: error: ld returned 1 exit status

    Bu testi yapabilmek için app.c programı şöyle olabilir:

    #include <stdio.h>

    void __attribute__((visibility("hidden"))) bar(void)
    {
        printf("bar\n");
    }

    void foo(void)
    {
        printf("foo\n");

        bar();
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir dinamik kütüphane normal olarak ya da dinamik olarak yüklendiğinde birtakım ilk işlerin yapılması gerekebilir. (Örneğin
    kütüphane thread güvenli olma iddiasındadır ve birtakım senkronizasyon nesnelerinin ve thread'e özgü alanların yaratılması 
    gerekebilir.) Bunun için gcc ve clang derleyicilerine özgü olan __attribute__((constructor)) fonksiyon özelliği (function 
    attribute) kullanılmaktadır. Benzer biçimde dinamik kütüphane programın adres alanından boşaltılırken de birtakım son işlemler 
    için __attribute__((destructor)) ile belirtilen fonksiyon çağrılmaktadır. (Aslında bu "constructor" ve "destructor" fonksiyonları 
    normal programlarda da kullanılabilir. Bu durumda ilgili fonksiyonlar main fonksiyonundan önce ve main fonksiyonundan sonra 
    çağrılmaktadır.) Dinamik kütüphane birden fazla kez yüklendiğinde yalnızca ilk yüklemede toplamda bir kez constructor 
    fonksiyonu çağrılmaktadır. Benzer biçimde destructor fonksiyonu da yalnızca bir kez çağrılır.

    Aşağıda normal bir programda __attribute__((constructor)) ve __attribute__((destructor)) fonksiyon özelliklerinin 
    kullanımına bir örnek verilmiştir. Ekranda şunları göreceksiniz:

    constructor foo begins...
    constructor foo ends...
    main begins...
    main ends...
    destructor bar begins...
    destructor bar ends...
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>

void __attribute__((constructor)) foo(void)
{
    printf("constructor foo begins...\n");
    printf("constructor foo ends...\n");
}

void __attribute__((destructor)) bar(void)
{
    printf("destructor bar begins...\n");
    printf("destructor bar ends...\n");
}

int main(void)
{
    printf("main begins...\n");

    printf("main ends...\n");

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda da dinamik kütüphane içerisinde __attribute__((constructor)) ve __attribute__((destructor)) fonksiyon özelliklerinin
    kullanımına bir örnek verilmiştir. Derlemeyi aşağıdaki gibi yapabilirsiniz:

    $ gcc -shared -fPIC -Wl,-soname,libmyutil.so.1 -o libmyutil.so.1.0.0 libmyutil.c
    $ gcc -o app app.c libmyutil.so.1.0.0 -ldl

    Kütüphaneye "so ismi" verdiğimiz için sembolik link oluşturmayı unutmayınız:

    $ ln -s libmyutil.so.1.0.0 libmyutil.so.1

    Programı çalıştırmadan önce LD_LIBRARY_PATH çevre değişkenini de ayarlayınız:

    $ export LD_LIBRARY_PATH=.
---------------------------------------------------------------------------------------------------------------------------*/

/* libmyutil.c */

#include <stdio.h>

void __attribute__((constructor)) constructor(void)
{
    printf("constructor begins...\n");
    printf("constructor ends...\n");
}

void __attribute__((destructor)) destructor(void)
{
    printf("destructor begins...\n");
    printf("destructor ends...\n");
}

void foo(void)
{
    printf("foo\n");
}

/* app.c */

#include <stdio.h>

void foo(void);

int main(void)
{
    foo();

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir kütüphane oluşturmak isteyen kişi kütüphanesi için en azından bir başlık dosyasını kendisi oluşturmalıdır. Çünkü
    kütüphane içerisindeki fonksiyonları kullanacak kişiler en azından onların prototiplerini bulundurmak zorunda kalacaklardır. 
    Kütüphaneler için oluşturulacak başlık dosyalarında kütüphane için anlamlı sembolik sabitler, fonksiyon prototipleri,
    inline fonksiyon tanımlamaları, typedef bildirimleri gibi "nesne yaratmayan" bildirimler bulunmalıdır. Başlık dosyalarında
    include korumasının yapılması unutulmamalıdır.

    Aşağıda kütüphane için bir başlık dosyası oluşturma örneği verilmiştir. Örneği aşağıdaki gibi derleyebilirsiniz:

    $ gcc -shared -fPIC -Wl,-soname,libmyutil.so.1 -o libmyutil.so.1.0.0 libmyutil.c
    $ gcc -o app app.c libmyutil.so.1.0.0

    Sembolik bağlantı yoksa aşağıdaki gibi yaratabilirsiniz:

    $ ln -s libmyutil.so.1.0.0 libmyutil.so.1
---------------------------------------------------------------------------------------------------------------------------*/

/* util.h */

#ifndef UTIL_H_
#define UTIL_H_

/* Function prototypes */

void foo(void);
void bar(void);

#endif

/* libmyutil.c */

#include <stdio.h>
#include "util.h"

void foo(void)
{
    printf("foo\n");
}

void bar(void)
{
    printf("bar\n");
}

/* app.c */

#include <stdio.h>
#include "util.h"

int main(void)
{
    foo();
    bar();

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    C++'ta yazılmış kodların da kütüphane biçimine getirilmesinde farklı bir durum yoktur. Sınıfların bildirimleri başlık 
    dosyalarında bulundurulur. Bunlar yine C++ derleyicisi ile (g++ ya da clang++) derlenir. Aynı biçimde kullanılır.

    Aşağıda C++'ta yazılmış olan bir sınıfın dinamik kütüphaneye yerleştirilmesi ve oradan kullanılmasına bir örnek verilmiştir. 
    Derleme işlemlerini şöyle yapabilirsiniz:

    $ g++ -shared -fPIC -Wl,-soname,libmyutil.so.1 -o libmyutil.so.1.0.0 libmyutil.cpp
    $ g++ -o app app.cpp libmyutil.so.1.0.0
---------------------------------------------------------------------------------------------------------------------------*/

/* util.hpp */

#ifndef UTIL_HPP_
#define UTIL_HPP_

/* Function prototypes */

namespace CSD {
    class Date {
    public:
        Date() = default;
        Date(int day, int month, int year);
        void disp() const;
    private:
        int m_day;
        int m_month;
        int m_year;
    };
}

#endif

/* libmyutil.cpp */

#include <iostream>
#include "util.hpp"

namespace CSD
{
    Date::Date(int day, int month, int year)
    {
        m_day = day;
        m_month = month;
        m_year = year;
    }

    void Date::disp() const
    {
        std::cout << m_day << '/' << m_month << '/' << m_year << std::endl;
    }
}

/* app.cpp */

#include <iostream>
#include "util.hpp"

using namespace CSD;

int main()
{
    Date d{10, 12, 2009};

    d.disp();

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir projeyi tek bir kaynak dosya biçiminde organize etmek iyi bir teknik değildir. Böylesi bir durumda dosyada küçük bir
    değişiklik yapıldığında bile tüm kaynak dosyanın yeniden derlenmesi gerekmektedir. Aynı zamanda bu biçim kodun güncellenmesini 
    de zorlaştırmaktadır. Proje tek bir kaynak dosyada olduğu için bu durum grup çalışmasını da olumsuz yönde etkilemektedir. 
    Bu nedenle projeler birden fazla "C ya da C++" kaynak dosyası biçiminde organize edilir. Örneğin 10000 satırlık bir proje
    app1.c, app2.c, app3.c, ..., app10.c biçiminde 10 farklı kaynak dosya biçiminde oluşturulmuş olsun. Pekiyi build işlemi bu 
    durumda nasıl yapılacaktır. Build işlemi için önce her dosya bağımsız olarak "-c" seçeneği ile derlenip ".o" uzantılı "amaç 
    dosya (object module)" haline getirilir. Sonra bu dosyalar link aşamasında birleştirilir. Örneğin:

    $ gcc -c app1.c
    $ gcc -c app2.c
    $ gcc -c app3.c
    ...
    $ gcc -c app10.c

    $ gcc -o app app1.o app2.o app3.o ... app10.o

    Bu çalışma biçiminde bir kaynak dosyada değişiklik yapıldığında yalnızca değişikliğin yapılmış olduğu kaynak dosya yeniden
    derlenir ancak link işlemine yine tüm amaç dosyalar dahil edilir. Örneğin app3.c üzerinde bir değişiklik yapmış olalım:

    $ gcc -c app3.c
    $ gcc -o app app1.o app2.o app3.o ... app10.o

    İşte bu sıkıcı işlemi ortadan kaldırmak ve build işlemini otomatize etmek için "build otomasyon araçları (build automation 
    tools)" denilen araçlar geliştirilmiştir. Bunların en eskisi ve yaygın olanı "make" isimli araçtır. make aracının yanı sıra 
    "cmake" gibi "qmake" gibi daha yüksek seviyeli build araçları da zamanla geliştirilmiştir. make aracı pek çok sistemde 
    benzer biçimde bulunmaktadır. Bugün UNIX/Linux sistemlerinde "GNU make" aracı kullanılmaktadır. Microsoft klasik make
    aracının "nmake" ismiyle başka versiyonunu geliştirmiştir. Ancak Microsoft uzun bir süredir "msbuild" denilen başka bir
    build sistemini kullanmaktadır. Örneğin Microsoft'un Visual Studio IDE'si arka planda bu "msbuild" aracını kullanmaktadır. 
    Qt Framework'ünde "qmake" isimli üst düzey make aracı kullanılmaktadır. Bazı IDE'ler "cmake" kullanmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                126. Ders 10/03/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    En fazla kullanılan build otomasyon aracı "make" isimli araçtır. make aracını kullanmak için ismine "make dosyası" denilen
    bir dosya oluşturulur. Sonra bu dosya "make" isimli program ile işletilir. Dolayısıyla make aracının kullanılması için make 
    dosyalarının nasıl oluşturulduğunun bilinmesi gerekir. Make dosyaları aslında kendine özgü bir dil ile oluşturulmaktadır. 
    Bu make dilinin kendi sentaksı ve semantiği vardır. make aracı için çeşitli kitaplar ve öğretici dokümanlar (tutorials)
    oluşturulmuştur. Orijinal dokümanlarına aşağıdaki bağlantıdan erişilebilir:

    https://www.gnu.org/software/make/manual/

    Yukarıda da belirttiğimiz gibi "make" aracı değişik sistemlerde birbirine benzer biçimde bulunmaktadır. Microsoft'un make
    aracına "nmake" denilmektedir. GNU Projesi kapsamında bu make aracı yeniden yazılmıştır. Bugün ağırlıklı olarak GNU projesindeki
    make aracı kullanılmaktadır. Bu araca "GNU Make" de denilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir make dosyası "kurallardan (rules)" oluşmaktadır. Bir kuralın (rule) genel biçimi şöyledir:

    hedef (target) : ön_koşullar (prerequisites)
        işlemler (recipes)

    Örneğin:

    app: a.o b.o c.o
        gcc -o app a.o b.o c.o

    Burada "app" hedefi, "a.o b.o c.o" ön koşulları ve "gcc -o app a.o b.o c.o" satırı da "işlemleri (recipes)" belirtmektedir. 
    Hedef genellikle bir tane olur. Ancak ön koşullar birden fazla olabilir. İşlemler tek bir satırdan oluşmak zorunda değildir. 
    Eğer birden fazla satırdan oluşacaksa satırlar alt alta yazılır. İşlemler belirtilirken yukarıdaki satırdan bir TAB içeriye
    girinti verilmek zorundadır. Örneğin:

    app: a.o b.o c.o
    <TAB>gcc -o app a.o b.o c.o

    Kuraldaki hedef ve ön koşullar tipik olarak birer dosyadır. Kuralın anlamı şöyledir: Ön koşullarda belirtilen dosyaların 
    herhangi birinin tarih ve zamanı, hedefte belirtilen dosyanın tarih ve zamanından ileri ise (yani bunlar güncellenmişse)
    bu durumda belirtilen işlemler yapılır. Yukarıdaki kuralı yeniden inceleyiniz:

    app: a.o b.o c.o
        gcc -o app a.o b.o c.o

    Burada eğer "a.o" ya da "b.o" ya da "c.o" dosyalarının tarih ve zamanı "app" dosyasının tarih ve zamanından ilerideyse
    aşağıdaki kabuk komutu çalıştırılacaktır:

    $ gcc -o app a.o b.o c.o

    Bu link işlemi anlamına gelir. Link işleminden sonra artık "app" dosyasının tarih ve zamanı ön koşul dosyalarından daha
    ileride olacağı için kural "güncel (up to date)" hale gelir. Artık bu kural işletildiğinde bu link işlemi yapılmayacaktır. 
    Bu link işleminin yeniden yapılabilmesi için "a.o" ya da "b.o" ya da "c.o" dosyalarında güncelleme yapılmış olması gerekir. 
    Bu dosyalar derleme işlem sonucunda oluşacağına göre bu dosyaların güncellenmesi aslında bunlara ilişkin ".c" dosyalarının 
    derlenmesiyle olabilir. Şimdi aşağıdaki kuralları yazalım:

    a.o: a.c
        gcc -c a.c

    b.o: b.c
        gcc -c b.c

    c.o: c.c
        gcc -c c.c

    Bu kurallar "ilgili .c dosyalarında bir değişiklik olduğunda onları yeniden derle" anlamına gelmektedir. Şimdi önceki kuralla
    bu kuralları bir araya getirelim:

    app: a.o b.o c.o
        gcc -o app a.o b.o c.o
    a.o: a.c
        gcc -c a.c
    b.o: b.c
        gcc -c b.c
    c.o: c.c
        gcc -c c.c

    make programı çalıştırıldığında önce program make dosyasından hareketle bir "bağımlılık grafı (dependency graph)" 
    oluşturmaktadır. Bağımlılık grafı "hangi dosya hangi dosyanın durumuna bağlı" biçiminde oluşturulan bir graftır. 
    Yukarıdaki örnekte "a.o", "b.o" ve "c.o" dosyaları aşağıdaki kurallara bağımlıdır. Daha sonra make programı sırasıyla 
    bu grafa uygun olarak aşağıdan yukarıya kuralları işletmektedir. Yukarıdaki örnekte birinci kural ikinci, üçüncü
    ve dördüncü kurallara bağımlıdır. Dolayısıyla önce bu kurallar işletilip daha sonra birinci kural işletilir. Böylece bu
    make dosyasından şöyle sonuç çıkmaktadır: "Herhangi bir .c dosya değiştirildiğinde onu derle ve hep birlikte link işlemi 
    yap".

    Kuralın hedefindeki dosya yoksa koşulun sağlandığı kabul edilmektedir. Yani bu durumda ilgili işlemler yapılacaktır. 
    Yukarıdaki örnekte "object dosyalarını silersek" bu durumda derleme işlemlerinin hepsi yapılacaktır. Normal olarak her 
    ön koşul dosyasının bir hedefle ilişkili olması beklenir. Yani ön koşulda belirtilen dosyaların var olması gerekmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    make dosyası hazırlandıktan sonra make programı ile dosya işletilir. make programı işletilecek dosyayı "-f" ya da "--file" 
    seçeneği ile komut satırı argümanından almaktadır. Örneğin:

    $ make -f project.mak

    Ancak -f seçeneği kullanılmazsa make programı sırasıyla "GNUmakefile", "makefile" ve "Makefile" dosyalarını aramaktadır. 
    GNU dünyasındaki genel eğilim projenin make dosyasının "Makefile" biçiminde isimlendirilmesidir. Açık kaynak kodlu bir 
    yazılımda projenin make dosyasının da verilmiş olması beklenir. Böylece kaynak kodları elde eden kişiler yeniden derlemeyi
    komut satırında "make" yazarak yapabilirler.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında make programı çalıştırılırken program belli bir hedefi gerçekleştirmek için işlem yapar. Gerçekleştirilecek 
    hedef make programında komut satırı argümanı olarak verilmektedir. Eğer hedef belirtilmezse ilk hedef gerçekleştirilmeye 
    çalıştırılır. Örneğin:

    # Makefile

    app: a.o b.o c.o
        gcc -o app a.o b.o c.o
    a.o: a.c
        gcc -c a.c
    b.o: b.c
        gcc -c b.c
    c.o: c.c
        gcc -c c.c

    project: project.c
        gcc -o project project.c

    Burada birbirinden bağımsız iki hedef vardır: app ve project. Biz make programını hedef belirtmeden çalıştırırsak ilk 
    hedef gerçekleştirilmeye çalışılır. Ancak belli bir hedefin de gerçekleştirilmesini sağlayabiliriz. Örneğin:

    $ make project
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir kuralda ön koşul yoksa kuralın sağlandığı varsayılmaktadır. Yani bu durumda doğrudan belirtilen işlemler (recipes) 
    yapılır. Örneğin:

    clean:
        rm -f *.o

    Burada make programını aşağıdaki gibi çalıştırmış olalım:

    $ make clean

    Bu durumda tüm ".o" dosyaları silinecektir. Örneğin:

    # Makefile

    app: a.o b.o c.o
        gcc -o app a.o b.o c.o
    a.o: a.c
        gcc -c a.c
    b.o: b.c
        gcc -c b.c
    c.o: c.c
        gcc -c c.c

    clean:
        rm -f *.o

    install:
        sudo cp app /usr/local/bin

    Burada "clean" hedefi rebuild işlemi için object dosyaları silmektedir. "install" hedefi ise elde edilen programı belli 
    bir yere kopyalamaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir kaynak dosya bir başlık dosyasını kullanıyorsa bağımlılıkta bu başlık dosyasının da belirtilmesi uygun olur. Çünkü
    bu başlık dosyasında bir güncelleme yapıldığında bu kaynak dosyanın da yeniden derlenmesi beklenir. Örneğin:

    a.o: a.c app.h
        gcc -c app.c

    Burada artık app.h dosyası üzerinde bir değişiklik yapıldığında derleme işlemi yeniden yapılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                127. Ders 15/03/2024 - Cuma
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    make dosyasına dışarıdan parametre aktarabiliriz. Bunun için komut satırında "değişken=değer" sentaksı kullanılmaktadır. 
    Burada geçirilen değer ${değişken} ifadesi ile make dosyasının içerisinden kullanılabilir. Örneğin:

    # Makefile

    ${executable}: a.o b.o c.o
        gcc -o app a.o b.o c.o
    a.o: a.c
        gcc -c a.c
    b.o: b.c
        gcc -c b.c
    c.o: c.c app.h
        gcc -c c.c

    clean:
        rm -f *.o

    install:
        sudo cp app /usr/local/bin

    Burada executable dosyanın hedefi komut satırından elde edilmektedir. Örneğin biz make programını şöyle çalıştırabiliriz:

    $ make executable=app

    Bu durumda "app" dosyası hedef olarak ele alınacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Make dosyası içerisinde değişkenler kullanılabilmektedir. Bir değişken "değişken = değer" sentaksıyla oluşturulur ve 
    make dosyasının herhangi bir yerinde ${değişken} biçiminde kullanılır. Örneğin:

    # Makefile

    CC = gcc
    OBJECTS = a.o b.o c.o
    INSTALL_DIR = /usr/local/bin
    APP_NAME = app

    ${APP_NAME}: ${OBJECTS}
        ${CC} -o app a.o b.o c.o
    a.o: a.c
        ${CC} -c a.c
    b.o: b.c
        ${CC} -c b.c
    c.o: c.c app.h
        gcc -c c.c

    clean:
        rm -f ${OBJECTS}
    install:
        sudo cp ${APP_NAME} ${INSTALL_DIR}
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir C programını derlediğimizde link işlemi için bir main fonksiyonunun bulunması gerekmektedir. Aslında GNU'nun linker
    programının ismi "ld" isimli programdır. gcc zaten bu ld linker'ını çalıştırmaktadır. Bir programın link edilebilmesi için 
    aslında main fonksiyonunun bulunması gerekmez. main fonksiyonu assembly düzeyinde anlamlı bir fonksiyon değildir. C için 
    anlamlı bir fonksiyondur. Yani örneğin biz bir assembly programı yazarsak onu istediğimiz yerden çalışmaya başlatabiliriz. 
    Bir dosya "executable" olarak link edilirken tek gerekli olan şey "entry point" denilen akışın başlatılacağı noktadır. Entry 
    point ld linker'ında "--entry" seçeneği ile belirtilmektedir. Biz bir C programını gcc ile derlediğimizde gcc aslında ld 
    linker'ını çağırırken ismine "start-up modüller" denilen bir grup modülü de link işlemine gizlice dahil etmektedir. Programın 
    gerçek entry point'i bu start-up modül içerisinde bir yerdedir. Aslında main fonksiyonunu bu start-up modül çağırmaktadır. 
    Bu start-up modülün görevi birtakım hazırlık işlemlerini yapıp komut satırı argümanlarıyla main fonksiyonunu çağırmaktır. 
    Zaten akış main fonksiyonunu bitirdiğinde yeniden start-up modüldeki koda döner orada exit işlemi yapılmıştır. Start-up modülün 
    kodlarını şöyle düşünebilirsiniz:

    ...
    ...
    ...
    call main
    call exit

    O halde link aşamasına bu start-up modül katıldığı için aslında main isimli bir fonksiyon aranmaktadır. Yani start-up modül 
    main fonksiyonunu çağırmasaydı linker onu aramayacaktı.

    Biz aslında hiçbir kütüphaneyi link aşamasına dahil etmeden programın entry-point'ini kendimiz belirleyerek akışı istediğimiz
    fonksiyondan başlatabiliriz. Tabii bu durumda sistem fonksiyonlarını bile sembolik makine dilinde ya da gcc'nin inline 
    sembolik makine dilinde kendimizin yazması gerekecektir. Aşağıda böyle bir örnek verilmiştir. Buradaki programın isminin 
    "x.c" olduğunu varsayalım. Bu programı aşağıdaki gibi derleyip link edebilirsiniz:

    $ gcc -c x.c
    $ ld -o x x.o --entry=foo
---------------------------------------------------------------------------------------------------------------------------*/

/* x.c */

#include <unistd.h>
#include <stdint.h>
#include <asm/unistd.h>

ssize_t my_write(int fd, const void *buf, size_t size)
{
    register int64_t rax __asm__ ("rax") = 1;
    register int rdi __asm__ ("rdi") = fd;
    register const void *rsi __asm__ ("rsi") = buf;
    register size_t rdx __asm__ ("rdx") = size;

    __asm__ __volatile__ (
        "syscall"
        : "+r" (rax)
        : "r" (rdi), "r" (rsi), "r" (rdx)
        : "rcx", "r11", "memory"
    );

    return rax;
}

void my_exit(int status)
{
    __asm__ __volatile__
     (
        "movl $60, %%eax\n\t"
        "movl %0, %%edi\n\t"
        "syscall"
        :
        : "g" (status)
        : "eax", "edi", "cc"
     );
}

void foo()
{
    my_write(1, "this is a test\n", 15);
    my_exit(0);
}

/*--------------------------------------------------------------------------------------------------------------------------
    O anda makinemizdeki işletim sistemi hakkındaki bilgi "uname" komutuyla elde edilebilir. Bu komut -r ile kullanılırsa o 
    makinede yüklü olan kernel versiyonu elde edilmektedir. Örneğin:

    $ uname -r
    4.15.0-20-generic
---------------------------------------------------------------------------------------------------------------------------*/

