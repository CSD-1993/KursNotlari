
/*-----------------------------------------------------------------------------------------------------------------------------
                                            C ve Sistem Programcıları Derneği

                                   Gömülü Linux Sistemleri - Geliştirme ve Uygulama Kursu

                                        Sınıfta Yapılan Örnekler ve Özet Notlar
                                                        3. Bölüm

                                                  Eğitmen: Kaan ASLAN

        Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.
        Kaynak belirtmek için aşağıdaki referansı kullanabilirsiniz:           

        Aslan, K. (2025), "Gömülü Linux Sistemleri - Geliştirme ve Uygulama Kursu", Sınıfta Yapılan Örnekler ve Özet Notlar, 
            C ve Sistem Programcıları Derneği, İstanbul.

                            (Notları sabit genişlikli font kullanan programlama editörleri ile açınız.)
                                    (Editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz.)

                                            Son Güncelleme: 20/08/2025 - Çarşamba

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                            129. Ders 23/09/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
  GPIO (General Purpose Input Output) sistemlerinin elektronik (yani donanımsal) kısmı Gürbüz Hoca (Gürbüz Aslan) tarafından 
    anlatılmıştı. Bu bölümde biz GPIO sisteminin gömülü Linux sistemlerindeki yazılımsal kullanımı üzerinde duracağız. Önce BBB 
    üzerinde sonra Raspberry Pi üzerinde çalışacağız. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    BBB'de her iki yanda iki GPIO soketi vardır. Bu soketlerde ikişer sütun bulunmaktadır. Her sütunda 23 GPIO pin vardır. 
    BBB'de GPIO sistemi için ilk öğrenilecek şey bu GPIO pinlerinin numaralandırılma biçimidir. Numaralandırma kartın "Ethernet 
    ve 5V girişinin bulunduğu ucu karşı tarafa bakacak biçimde konumlandırılmasıyla" yapılmıştır. Konumlandırma yapıldıktan 
    sonra sol taraftaki sokete P9, sağ taraftaki sokete ise P8 denilmektedir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kart konumlandırıldıktan sonra pin görümleri şöyle olmaktadır:

            P9 (solda)                        P8 (sağda)
    ┌─────────────┬──────────────┐   ┌─────────────┬──────────────┐
    │ P9_01  GND  │ P9_02  GND   │   │ P8_01  DGND │ P8_02  DGND  │
    │ P9_03  3.3V │ P9_04  3.3V  │   │ P8_03  03   │ P8_04  04    │
    │ P9_05  5V   │ P9_06  5V    │   │ P8_05  05   │ P8_06  06    │
    │ P9_07  SYS5V│ P9_08  SYS5V │   │ P8_07  07   │ P8_08  08    │
    │ P9_09 PWR_BT│ P9_10 SYS_RST│   │ P8_09  09   │ P8_10  10    │
    │ P9_11  11   │ P9_12  12    │   │ P8_11  11   │ P8_12  12    │
    │ P9_13  13   │ P9_14  14    │   │ P8_13  13   │ P8_14  14    │
    │ P9_15  15   │ P9_16  16    │   │ P8_15  15   │ P8_16  16    │
    │ P9_17  17   │ P9_18  18    │   │ P8_17  17   │ P8_18  18    │
    │ P9_19  19   │ P9_20  20    │   │ P8_19  19   │ P8_20  20    │
    │ P9_21  21   │ P9_22  22    │   │ P8_21  21   │ P8_22  22    │
    │ P9_23  23   │ P9_24  24    │   │ P8_23  23   │ P8_24  24    │
    │ P9_25  25   │ P9_26  26    │   │ P8_25  25   │ P8_26  26    │
    │ P9_27  27   │ P9_28  28    │   │ P8_27  27   │ P8_28  28    │
    │ P9_29  29   │ P9_30  30    │   │ P8_29  29   │ P8_30  30    │
    │ P9_31  31   │ P9_32  32    │   │ P8_31  31   │ P8_32  32    │
    │ P9_33  33   │ P9_34  34    │   │ P8_33  33   │ P8_34  34    │
    │ P9_35  35   │ P9_36  36    │   │ P8_35  35   │ P8_36  36    │
    │ P9_37  37   │ P9_38  38    │   │ P8_37  37   │ P8_38  38    │
    │ P9_39  39   │ P9_40  40    │   │ P8_39  39   │ P8_40  40    │
    │ P9_41  41   │ P9_42  42    │   │ P8_41  41   │ P8_42  42    │
    │ P9_43  43   │ P9_44  44    │   │ P8_43  43   │ P8_44  44    │
    │ P9_45  45   │ P9_46  46    │   │ P8_45  45   │ P8_46  46    │
    └─────────────┴──────────────┘   └─────────────┴──────────────┘

    Buradaki tüm pinler GPIO amacıyla kullanılmamaktadır. Bazı pinler başka işlemler için bulundurulmuştur. BBB'nin P9 ve P8
    soketi üzerindeki tüm pinleri işlevlerine göre bir liste biçiminde aşağıdaki tabloda veriyoruz:

    P9 HEADER (sol)

    P9_01 : GND
    P9_02 : GND
    P9_03 : 3.3V
    P9_04 : 3.3V
    P9_05 : 5V
    P9_06 : 5V
    P9_07 : SYS_5V
    P9_08 : SYS_5V
    P9_09 : PWR_BUT
    P9_10 : SYS_RESETn
    P9_11 : UART4_RXD
    P9_12 : GPIO / GPIO1_28
    P9_13 : UART4_TXD
    P9_14 : EHRPWM1A
    P9_15 : GPIO / GPIO1_16
    P9_16 : EHRPWM1B
    P9_17 : I2C1_SCL / SPI0_CS0
    P9_18 : I2C1_SDA / SPI0_MISO
    P9_19 : I2C2_SCL
    P9_20 : I2C2_SDA
    P9_21 : UART2_TXD / SPI0_D0
    P9_22 : UART2_RXD / SPI0_SCLK
    P9_23 : GPIO / GPIO1_17
    P9_24 : UART1_TXD
    P9_25 : GPIO / GPIO3_21
    P9_26 : UART1_RXD
    P9_27 : GPIO / GPIO3_19
    P9_28 : SPI1_CS0
    P9_29 : SPI1_D0
    P9_30 : SPI1_D1
    P9_31 : SPI1_SCLK
    P9_32 : VDD_ADC (1.8V)
    P9_33 : AIN4
    P9_34 : GND
    P9_35 : AIN6
    P9_36 : AIN5
    P9_37 : AIN2
    P9_38 : AIN3
    P9_39 : AIN0
    P9_40 : AIN1
    P9_41 : GPIO / CLKOUT2 / UART5_TXD
    P9_42 : GPIO / GPIO0_7 / UART5_RXD
    P9_43 : GND
    P9_44 : GND
    P9_45 : GND
    P9_46 : GND
        
    P8 HEADER (sağ)

    P8_01 : GND
    P8_02 : GND
    P8_03 : GPIO / LCD_DATA2
    P8_04 : GPIO / LCD_DATA3
    P8_05 : GPIO / LCD_DATA4
    P8_06 : GPIO / LCD_DATA5
    P8_07 : GPIO / LCD_DATA6
    P8_08 : GPIO / LCD_DATA7
    P8_09 : GPIO / LCD_DATA0
    P8_10 : GPIO / LCD_DATA1
    P8_11 : GPIO / GPIO1_13
    P8_12 : GPIO / GPIO1_12
    P8_13 : GPIO / EHRPWM2B
    P8_14 : GPIO / GPIO0_26
    P8_15 : GPIO / GPIO1_15
    P8_16 : GPIO / GPIO1_14
    P8_17 : GPIO / GPIO0_27
    P8_18 : GPIO / GPIO2_1
    P8_19 : GPIO / EHRPWM2A
    P8_20 : GPIO / GPIO1_31
    P8_21 : GPIO / GPIO1_30
    P8_22 : GPIO / GPIO1_5
    P8_23 : GPIO / GPIO1_4
    P8_24 : GPIO / GPIO1_1
    P8_25 : GPIO / GPIO1_0
    P8_26 : GPIO / GPIO1_29
    P8_27 : GPIO / GPIO2_22
    P8_28 : GPIO / GPIO2_24
    P8_29 : GPIO / GPIO2_23
    P8_30 : GPIO / GPIO2_25
    P8_31 : GPIO / UART5_CTSN
    P8_32 : GPIO / UART5_RTSN
    P8_33 : GPIO / UART4_RTSN
    P8_34 : GPIO / UART3_RTSN / PWM
    P8_35 : GPIO / UART4_CTSN
    P8_36 : GPIO / UART3_CTSN / PWM
    P8_37 : GPIO / UART5_TXD
    P8_38 : GPIO / UART5_RXD
    P8_39 : GPIO / GPIO2_12
    P8_40 : GPIO / GPIO2_13
    P8_41 : GPIO / GPIO2_10
    P8_42 : GPIO / GPIO2_11
    P8_43 : GPIO / GPIO2_8
    P8_44 : GPIO / GPIO2_9
    P8_45 : GPIO / GPIO2_6 / PWM
    P8_46 : GPIO / GPIO2_7 / PWM
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    BBB'de pin numaralandırması üç farklı biçimde yapılmaktadır. Birinci numaralandırma biçimi tamamen sokete göre yapılan 
    numaralandırmadır. Bu numaralandırmaya "fiziksel numaralandırma" diyeceğiz. Yukarıdaki ilk şekilde bu fiziksel numaralandırma 
    kullanılmıştır. Bu numaralandırma P9_XX ve P8_XX biçiminde yapılmaktadır. Buradaki P9 ve P8 soketin yerini belirtmektedir. 
    Bizim konumlandırmamıza göre P9 soldaki soket, P8 sağdaki sokettir. Bu soketlerin solundaki 23 pinlik sütun tek sayılarla, 
    sağındaki 23 pinlik sütun çift sayılarla numaralandırılmaktadır. Numaralandırma 1'den başlanarak aşağıdaki gibi yapılmıştır:

    1   2
    3   4
    5   6
    7   8
    9   10
    11  12
    13  14
    15  16
    17  18
    19  20
    21  22
    23  24
    25  26
    27  28
    29  30
    31  32
    33  34
    35  36
    37  38
    39  40
    41  42
    43  44
    45  46

    Örneğin P9_12 fiziksel pin numarası soldaki soketin 12 numaralı pini anlamına gelmektedir. Örneğin P8_07 sağdaki soketin 
    7 numaralı pini anlamına gelmektedir. 

    İkinci numaralandırma sistemi AM335x SoC tasarımında kullanılan içsel numaralandırma sistemidir. Buna "SoC numaralandırması" 
    diyeceğiz. Bu numaralandırma sisteminde bu GPIO pinlerini kontrol eden denetleyici temel alınmıştır. AM335x SoC tasarımında 
    aslında içsel olarak GPIO uçlarını kontrol eden 4 denetleyici vardır. Bu denetleyicilerin her biri 32 çıkışlıdır. Ancak bu 
    32 çıkışın hepsi P9 ve P8 soketlerine bağlanmamıştır. (Bağlanmayanların bazıları kart üzerindeki LED'leri yakmakta, bazıları 
    ise başka amaçlarla kullanılmaktadır. Bazıları da tamamen boş bırakılmıştır. Eğer sütunlarda 23'den daha fazla pin olsaydı 
    kartın boyutlarının da değiştirilmesi gerekebilirdi.) SoC içerisindeki denetleyicilerin uçları P9 ve P8 soketlerindeki pinlere 
    karışık dağıtılmıştır. Yani fiziksel numaradan hareketle SoC numaralandırması elde edilememektedir. SoC numaralandırılması 
    GPIOX_Y biçiminde yapılmaktadır. Buradaki X harfi SoC içerisindeki denetleyicinin numarasını belirtmektedir. Y harfi ise 
    denetleyicinin 32 ucundan hangisinin pine bağlandığını belirtmektedir. Aşağıda fiziksel pin numaralarına karşı gelen SoC 
    ve aygıt sürücü numaraları bir tablo halinde verilmiştir. Bu tabloda P9 ve P8 soketlerinde olmayan pinler de belirtilmiştir:

                             P9 Soketi
    ┌──────┬──────────┬─────────────────┬──────────────┬─────────────┐
    │ Pin  │ Proc Pin │  Ana Fonksiyon  │ GPIO Göst.   │ GPIO Sayısı │
    ├──────┼──────────┼─────────────────┼──────────────┼─────────────┤
    │ P9_1 │    -     │      GND        │      -       │      -      │
    │ P9_2 │    -     │      GND        │      -       │      -      │
    │ P9_3 │    -     │    DC_3.3V      │      -       │      -      │
    │ P9_4 │    -     │    DC_3.3V      │      -       │      -      │
    │ P9_5 │    -     │    VDD_5V       │      -       │      -      │
    │ P9_6 │    -     │    VDD_5V       │      -       │      -      │
    │ P9_7 │    -     │    SYS_5V       │      -       │      -      │
    │ P9_8 │    -     │    SYS_5V       │      -       │      -      │
    │ P9_9 │    -     │    PWR_BUT      │      -       │      -      │
    │P9_10 │   A10    │  SYS_RESETn     │      -       │      -      │
    │P9_11 │   T17    │  UART4_RXD      │   GPIO0_30   │     30      │
    │P9_12 │   U18    │   GPIO1_28      │   GPIO1_28   │     60      │
    │P9_13 │   U17    │  UART4_TXD      │   GPIO0_31   │     31      │
    │P9_14 │   U14    │   EHRPWM1A      │   GPIO1_18   │     50      │
    │P9_15 │   R13    │   GPIO1_16      │   GPIO1_16   │     48      │
    │P9_16 │   T14    │   EHRPWM1B      │   GPIO1_19   │     51      │
    │P9_17 │   A16    │   I2C1_SCL      │   GPIO0_5    │     5       │
    │P9_18 │   B16    │   I2C1_SDA      │   GPIO0_4    │     4       │
    │P9_19 │   D17    │   I2C2_SCL      │   GPIO0_13   │     13      │
    │P9_20 │   D18    │   I2C2_SDA      │   GPIO0_12   │     12      │
    │P9_21 │   B17    │  UART2_TXD      │   GPIO0_3    │     3       │
    │P9_22 │   A17    │  UART2_RXD      │   GPIO0_2    │     2       │
    │P9_23 │   V14    │   GPIO1_17      │   GPIO1_17   │     49      │
    │P9_24 │   D15    │  UART1_TXD      │   GPIO0_15   │     15      │
    │P9_25 │   A14    │   GPIO3_21      │   GPIO3_21   │    117      │
    │P9_26 │   D16    │  UART1_RXD      │   GPIO0_14   │     14      │
    │P9_27 │   C13    │   GPIO3_19      │   GPIO3_19   │    115      │
    │P9_28 │   C12    │   SPI1_CS0      │   GPIO3_17   │    113      │
    │P9_29 │   B13    │   SPI1_D0       │   GPIO3_15   │    111      │
    │P9_30 │   D12    │   SPI1_D1       │   GPIO3_16   │    112      │
    │P9_31 │   A13    │  SPI1_SCLK      │   GPIO3_14   │    110      │
    │P9_32 │    -     │     VADC        │      -       │      -      │
    │P9_33 │   C8     │     AIN4        │      -       │      -      │
    │P9_34 │    -     │     AGND        │      -       │      -      │
    │P9_35 │   A8     │     AIN6        │      -       │      -      │
    │P9_36 │   B8     │     AIN5        │      -       │      -      │
    │P9_37 │   B7     │     AIN2        │      -       │      -      │
    │P9_38 │   A7     │     AIN3        │      -       │      -      │
    │P9_39 │   B6     │     AIN0        │      -       │      -      │
    │P9_40 │   C7     │     AIN1        │      -       │      -      │
    │P9_41 │   D14    │   CLKOUT2       │   GPIO0_20   │     20      │
    │P9_41 │   D13    │   GPIO3_20      │   GPIO3_20   │    116      │
    │P9_42 │   C18    │   GPIO0_7       │   GPIO0_7    │     7       │
    │P9_42 │   B12    │   GPIO3_18      │   GPIO3_18   │    114      │
    │P9_43 │    -     │      GND        │      -       │      -      │
    │P9_44 │    -     │      GND        │      -       │      -      │
    │P9_45 │    -     │      GND        │      -       │      -      │
    │P9_46 │    -     │      GND        │      -       │      -      │
    └──────┴──────────┴─────────────────┴──────────────┴─────────────┘

                             P8 Soketi
    ┌──────┬──────────┬─────────────────┬──────────────┬─────────────┐
    │ Pin  │ Proc Pin │  Ana Fonksiyon  │ GPIO Göst.   │ GPIO Sayısı │
    ├──────┼──────────┼─────────────────┼──────────────┼─────────────┤
    │ P8_1 │    -     │      GND        │      -       │      -      │
    │ P8_2 │    -     │      GND        │      -       │      -      │
    │ P8_3 │    R9    │   GPIO1_6       │   GPIO1_6    │     38      │
    │ P8_4 │    T9    │   GPIO1_7       │   GPIO1_7    │     39      │
    │ P8_5 │    R8    │   GPIO1_2       │   GPIO1_2    │     34      │
    │ P8_6 │    T8    │   GPIO1_3       │   GPIO1_3    │     35      │
    │ P8_7 │    R7    │    TIMER4       │   GPIO2_2    │     66      │
    │ P8_8 │    T7    │    TIMER7       │   GPIO2_3    │     67      │
    │ P8_9 │    T6    │    TIMER5       │   GPIO2_5    │     69      │
    │P8_10 │    U6    │    TIMER6       │   GPIO2_4    │     68      │
    │P8_11 │   R12    │   GPIO1_13      │   GPIO1_13   │     45      │
    │P8_12 │   T12    │   GPIO1_12      │   GPIO1_12   │     44      │
    │P8_13 │   T10    │   EHRPWM2B      │   GPIO0_23   │     23      │
    │P8_14 │   T11    │   GPIO0_26      │   GPIO0_26   │     26      │
    │P8_15 │   U13    │   GPIO1_15      │   GPIO1_15   │     47      │
    │P8_16 │   V13    │   GPIO1_14      │   GPIO1_14   │     46      │
    │P8_17 │   U12    │   GPIO0_27      │   GPIO0_27   │     27      │
    │P8_18 │   V12    │   GPIO2_1       │   GPIO2_1    │     65      │
    │P8_19 │   U10    │   EHRPWM2A      │   GPIO0_22   │     22      │
    │P8_20 │    V9    │   GPIO1_31      │   GPIO1_31   │     63      │
    │P8_21 │    U9    │   GPIO1_30      │   GPIO1_30   │     62      │
    │P8_22 │    V8    │   GPIO1_5       │   GPIO1_5    │     37      │
    │P8_23 │    U8    │   GPIO1_4       │   GPIO1_4    │     36      │
    │P8_24 │    V7    │   GPIO1_1       │   GPIO1_1    │     33      │
    │P8_25 │    U7    │   GPIO1_0       │   GPIO1_0    │     32      │
    │P8_26 │    V6    │   GPIO1_29      │   GPIO1_29   │     61      │
    │P8_27 │    U5    │   GPIO2_22      │   GPIO2_22   │     86      │
    │P8_28 │    V5    │   GPIO2_24      │   GPIO2_24   │     88      │
    │P8_29 │    R5    │   GPIO2_23      │   GPIO2_23   │     87      │
    │P8_30 │    R6    │   GPIO2_25      │   GPIO2_25   │     89      │
    │P8_31 │    V4    │  UART5_CTSN     │   GPIO0_10   │     10      │
    │P8_32 │    T5    │  UART5_RTSN     │   GPIO0_11   │     11      │
    │P8_33 │    V3    │  UART4_RTSN     │   GPIO0_9    │     9       │
    │P8_34 │    U4    │  UART3_RTSN     │   GPIO2_17   │     81      │
    │P8_35 │    V2    │  UART4_CTSN     │   GPIO0_8    │     8       │
    │P8_36 │    U3    │  UART3_CTSN     │   GPIO2_16   │     80      │
    │P8_37 │    U1    │  UART5_TXD      │   GPIO2_14   │     78      │
    │P8_38 │    U2    │  UART5_RXD      │   GPIO2_15   │     79      │
    │P8_39 │    T3    │   GPIO2_12      │   GPIO2_12   │     76      │
    │P8_40 │    T4    │   GPIO2_13      │   GPIO2_13   │     77      │
    │P8_41 │    T1    │   GPIO2_10      │   GPIO2_10   │     74      │
    │P8_42 │    T2    │   GPIO2_11      │   GPIO2_11   │     75      │
    │P8_43 │    R3    │   GPIO2_8       │   GPIO2_8    │     72      │
    │P8_44 │    R4    │   GPIO2_9       │   GPIO2_9    │     73      │
    │P8_45 │    R1    │   GPIO2_6       │   GPIO2_6    │     70      │
    │P8_46 │    R2    │   GPIO2_7       │   GPIO2_7    │     71      │
    └──────┴──────────┴─────────────────┴──────────────┴─────────────┘

    Üçüncü numaralandırma sistemi de Linux aygıt sürücülerinin kullandığı numaralandırma sistemidir. Bu numaralandırma
    sistemine "aygıt sürücü numaralandırması" diyebiliriz. Bu numaralandırma sistemi Linux'un sysfs dosya sisteminde kullanılan 
    numaralandırma sistemidir. Aygıt sürücüler bu sistemi kullanmaktadır. Bu sistemdeki pin numaraları GPIOXX biçiminde 
    belirtilmektedir. Her pinin bir numarası vardır. GPIOX_Y SoC numarası Z = X * 32 + Y biçiminde aygıt sürücü GPIOZ numarasına 
    dönüştürülmektedir. Örneğin GPIO1_14 pininin aygıt sürücü numarası GPIO46'dır. Örneğin GPIO3_21 pininin aygıt sürücü numarası 
    GPIO117 biçimindedir. Yukarıdaki tablolarda her pinin üç numaralandırma sistemindeki karşılıkları tek tek verilmiştir. 

    Peki yukarıda üç numaralandırma biçimini gördük. Hangi numaralandırmalar hangi bağlamlarda kullanılmaktadır? Fiziksel 
    bağlantılar yapılırken genellikle fiziksel numaralandırma kullanılmaktadır. Aşağı seviyeli SoC denetleyicisi üzerinde 
    işlemler yapılacaksa (örneğin aygıt sürücüler yazılacaksa) mecburen SoC numaralandırılmasının kullanılması gerekmektedir. 
    Ancak Linux'un sys dosya sistemindeki dizin girişleri kullanılacaksa yani kullanıcı modunda programlar yazılacaksa bu 
    bağlamda aygıt sürücü numaralandırması kullanılmaktadır. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    GPIO devrelerinin donanımsal özelliklerini Gürbüz Hoca anlatmıştı. Peki biz gömülü sistem mühendisi olarak bu GPIO pinleriyle 
    ne yapabiliriz? Temelde bu GPIO pinleri üç amaçla kullanılabilmektedir:

    OUT 
    IN
    Interrupt

    Bu pinleri biz önce belli bir yön için programlarız. OUT işlemi ilgili pine elektriksel işaret uygulamak anlamına gelmektedir. 
    Dolayısıyla bir pin elektriksel olarak Lojik 1 seviyesine çekildiğinde o başka elektronik devreyi sürebilir. IN işlemi 
    ters işlemdir. Dış dünyadaki bir birimin o uca uyguladığı elektriksel işaretin okunması anlamına gelir. O halde kartımızdan 
    dış dünyaya elektriksel ileti göndermek için OUT işlemi, dış dünyadan bu iletileri almak için IN işlemi yapmak gerekir. 
    GPIO pinlerinin diğer bir özelliği de "kesme (interrupt)" oluşturabilmesidir. Biz bu pinleri başka aygıtlara bağladığımızda 
    onların bu uçlar yoluyla kesme oluşturmasını sağlayabilmekteyiz. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    GPIO pinleriyle OUT ve IN işlemlerinin testi için basit devreler kullanacağız. OUT testi için en basit devre şüphesiz bir 
    LED'in yakılıp söndürülmesini sağlayan devredir. LED'in yakılması için test devresi şöyle oluşturulabilir:

    GPIO pin
    │    
    ├───[R 470Ω]───|>|───⏚ GND
                   A K

    Bu devrede LED'in kısa ucu (katot) toprağa uzun ucu (anot) önce bir dirence sonra da GPIO uçlarından birine bağlanmıştır. 
    Burada 470Ω gibi küçük dirençler kullanabilirsiniz. Ancak dirençsiz bağlamayınız. Biz örneklerimizde bu amaçla P9_12 (GPIO1_28, 
    GPIO60) pinini kullanacağız. 

    IN testi için en basit devre bir düğme (button) devresidir. Bu devrede düğmeye basılmamışsa GPIO ucundan lojik 1 değeri 
    basılmışsa 0 değeri okunmaktadır. Protoborta yerleştirebileceğiniz çok küçük düğmeler (push buttons) bulunmaktadır. Bunlardan 
    satın alabilirsiniz. Devre şöyledir:

    +3.3V
    │
    [10kΩ]
    │
    ├─── GPIO
    │
    [ Buton ]
    │
    ⏚ GND

    Burada düğmenin bir ucunun toprağa bağlı, diğer ucunun GPIO pinlerinden birine bağlı olduğuna dikkat ediniz. GPIO pinine 
    bağlı olan uç aynı zamanda 10K gibi büyük bir dirençle soketteki 3.3V ucuna bağlanmıştır. Böylece düğmeye basılmamışsa 
    ilgili uçtan lojik 1 değeri, basılmışsa 0 değeri okunacaktır. Biz örneklerimizde bu amaçla P9_16 (GPIO1_19, GPIO51) pinini 
    kullanacağız. 

    P9 soketinde toprak (GND) uçlarının ve 3.3V ile 5V uçlarının bulunduğuna dikkat ediniz. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    GPIO programlaması için Linux'ta çeşitli seçenekler vardır:

    - sysfs dosya sistemini kullanarak programlama.
    - "/dev/gpiochipX" aygıt sürücüsünü kullanarak programlama.
    - "gpiod" kütüphanesini kullanarak programlama (zaten gpiod kütüphanesi /dev/gpiochipX" aygıt sürücüsünü kullanıyor). 
    - Aygıt sürücü yazıp, bellek tabanlı IO (memory-mapped IO) işlemleriyle AM335x SoC içerisindeki GPIO denetleyicisine 
    komutlar göndererek programlama.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                        130. Ders 25/09/2025 - Perşembe 
-----------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi bir aygıt sürücü class_create çekirdek fonksiyonu ile "/sys/class" dizininde bir giriş yaratabilmekteydi. 
    Daha sonra device_create fonksiyonuyla da bir device nesnesi yaratılıp bu sysfs dosya sistemi üzerinde işlemler yapılabilmektedir. 
    Yine anımsayacağınız gibi sysfs dosya sistemi amaç olarak proc dosya sistemine benzemekteydi. proc dosya sisteminin bazı 
    yetersizlikleri görüldüğü için o dosya sistemi muhafaza edilerek sysfs dosya sisteminin çekirdeğe eklendiğinden bahsetmiştik. 
    İşte çekirdek içerisindeki gpio aygıt sürücüsü dosya tabanlı erişimler için "/sys/class/gpio" dizinini kullanmaktadır. 

    "/sys/class/gpio" dizininde "export", "unexport" dosyalarının yanı sıra GPIO pinlerini temsil eden "gpioxx" isminde (buradaki 
    "xx" GPIO aygıt sürücü numaralandırmasına ilişkin sayıyı belirtmektedir) dizinler vardır. Örneğin BBB'deki Linux dağıtımında 
    bu dizini görüntülediğimizde aşağıdaki girişleri görmekteyiz:

    $ debian@BeagleBone:/sys/class/gpio$ ls
    export   gpio114  gpio15  gpio3   gpio36  gpio46  gpio60  gpio68  gpio74  gpio80  gpiochip0
    gpio10   gpio115  gpio2   gpio30  gpio37  gpio47  gpio61  gpio69  gpio75  gpio81  gpiochip32
    gpio11   gpio116  gpio20  gpio31  gpio38  gpio48  gpio62  gpio7   gpio76  gpio86  gpiochip64
    gpio110  gpio117  gpio22  gpio32  gpio39  gpio49  gpio63  gpio70  gpio77  gpio87  gpiochip96
    gpio111  gpio12   gpio23  gpio33  gpio4   gpio5   gpio65  gpio71  gpio78  gpio88  unexport
    gpio112  gpio13   gpio26  gpio34  gpio44  gpio50  gpio66  gpio72  gpio79  gpio89
    gpio113  gpio14   gpio27  gpio35  gpio45  gpio51  gpio67  gpio73  gpio8   gpio9

    Şimdi bu dizinlerden birine girelim. Örneğin LED'imizi bağladığımız gpio60 dizinine geçelim. Bu dizinin içeriği şöyledir:

    debian@BeagleBone:/sys/class/gpio/gpio60$ ls
    active_low  device  direction  edge  label  power  subsystem  uevent  value

    Burada üç dosya bizim için önemlidir. "direction" dosyası ilgili pini OUT ya da IN biçiminde konfigüre etmek için kullanılmaktadır. 
    Bu dosyaya biz "out" ya da "in" yazısını yazdırdığımızda ilgili pin bu amaçla konfigüre edilmiş olur. Örneğin biz GPIO60 
    pinini (P9_12, GPIO1_28 pinini) OUT biçiminde şöyle konfigüre edebiliriz:

    $ echo "out" | sudo tee direction

    Örneğin biz GPIO51 numaralı pini IN olarak konfigüre etmek için önce "gpio51" dizinine geçip aşağıdaki komutu uygulayabiliriz:

    $ echo "in" | sudo tee direction

    Artık sıra ilgili pin OUT olarak konfigüre edilmişse o pine lojik 1 ya da lojik 0 değerini göndermeye, IN olarak konfigüre
    edilmişse o pine uygulanan işareti okumaya gelmiştir. Bunun için "value" dosyası kullanılmaktadır. Örneğin LED'imizin bağlı 
    olduğu GPIO60 pinini lojik 1 seviyesine (3.3 volt) çekmek için aşağıdaki komutu kullanabiliriz:

    $ echo "1" | sudo tee value

    Tekrar 0'a çekmek için ise aşağıdaki komutu kullanabiliriz:

    $ echo "0" | sudo tee value

    Şimdi de düğmeyi bağladığımız GPIO51 numaralı pini okumak için "gpio51" dizinine geçelim. "value" dosyası zaten herkes 
    tarafından okunabilmektedir. (Bu dosyanın erişim hakları "-rw-rw-r--" biçimindedir.) O halde bu pini şöyle okuyabiliriz:

    $ cat value
    1

    Düğmeye basarak okuma yaparsak 0 okumamız gerekir. Şimdi aynı denemeyi düğmeye basarak yapalım:

    $ cat value
    0
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Tabii yukarıda açıkladığımız "direction" ve "value" dosyalarını bir C programıyla açıp oraya "1" ve "0" karakterlerini 
    de gönderebiliriz. Örneğin LED'imizi 1 saniye süreyle yakıp söndüren bir programı aşağıdaki gibi yazabiliriz:

    #include <stdio.h>
    #include <stdlib.h>
    #include <fcntl.h>
    #include <unistd.h>

    void write_file(const char *path, const char *cmd);
    void exit_sys(const char *msg);

    int main(void)
    {
        int fd;

        write_file("/sys/class/gpio/gpio60/direction", "out");

        if ((fd = open("/sys/class/gpio/gpio60/value", O_RDWR)) == -1) 
            exit_sys("open");
        
        for (;;) {
            lseek(fd, 0, 0);
            if (write(fd, "1", 1) == -1)
                exit_sys("write");
            sleep(1);
            lseek(fd, 0, 0);
            if (write(fd, "0", 1) == -1)
                exit_sys("write");
            sleep(1);
        }

        close(fd);      /* unreachable code */

        return 0;
    }

    void write_file(const char *path, const char *cmd)
    {
        int fd;

        if ((fd = open(path, O_WRONLY)) == -1) 
            exit_sys("open");

        if (write(fd, cmd, strlen(cmd)) == -1)
            exit_sys("write");

        close(fd);
    }

    void exit_sys(const char *msg)
    {
        perror(msg);

        exit(EXIT_FAILURE);
    }

    Programdaki for döngüsüne dikkat ediniz:

    for (;;) {
        if (write(fd, "1", 1) == -1)
            exit_sys("write");
        sleep(1);
        if (write(fd, "0", 1) == -1)
            exit_sys("write");
        sleep(1);
    }

    Aslında bildiğiniz gibi write işlemlerinde dosya göstericisi ilerletilmektedir. Yani yazma işlemlerinden önce bizim 
    dosya göstericisini lseek fonksiyonuyla başa çekmemiz gerekir. Ancak aygıt sürücüler konusunda da gördüğümüz gibi
    bazen aygıt sürücüleri yazanlar bu tür amaçlarla oluşturdukları küçük arayüz dosyalarında dosya göstericisinin konumunu 
    dikkate almadan okumayı ve yazmayı hep baştan itibaren yapabilmektedir. Tabii siz bu bilgiyi bilmek zorunda olmadığınız 
    için daha temkinli bir biçimde yazma işleminden önce dosya göstericisini dosyanın başına çekmelisiniz. (BBB'deki "value" 
    dosyasına dosya göstericisini başa çekmeden de "1" ve "0" yazılabilmektedir.)  

    Yukarıdaki programda sonsuz döngü oluşturulduğu için programı Ctrl+C tuşları ile sonlandırabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de bir döngü içerisinde GPIO51 pinini okumak isteyelim. Okumayı sonsuz bir döngü içerisinde "polling" yöntemiyle 
    yapıp yalnızca değişiklik oluştuğunda pinin değerini yazdıralım. Böyle bir C programını aşağıdaki gibi yazabiliriz:

    #include <stdio.h>
    #include <stdlib.h>
    #include <fcntl.h>
    #include <unistd.h>
    
    void write_file(const char *path, const char *cmd); 
    void exit_sys(const char *msg);  
    
    int main(void)
    {
        int fd;
        char status, prev_status = '1';

        write_file("/sys/class/gpio/gpio51/direction", "in");

        if ((fd = open("/sys/class/gpio/gpio51/value", O_RDONLY)) == -1) 
            exit_sys("open");
        
        for (;;) {
            lseek(fd, 0, 0);
            if (read(fd, &status, 1) == -1)
                exit_sys("read");
            if (status != prev_status) {
                printf("%c\r", status);
                fflush(stdout);
                prev_status = status;
            }
        }

        close(fd);      /* unreachable code */

        return 0;
    }

    void write_file(const char *path, const char *cmd)
    {
        int fd;

        if ((fd = open(path, O_WRONLY)) == -1) 
            exit_sys("open");

        if (write(fd, cmd, strlen(cmd)) == -1)
            exit_sys("write");

        close(fd);
    }

    void exit_sys(const char *msg)
    {
        perror(msg);

        exit(EXIT_FAILURE);
    }

    Burada da sonsuz döngü söz konusu olduğu için programı sonlandırmak için Ctrl+C tuşlarını kullanabilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Peki yukarıdaki programlarda POSIX fonksiyonları yerine C'nin standart dosya fonksiyonlarını kullanabilir miydik? Evet 
    kullanabilirdik. Ancak C'nin standart dosya fonksiyonlarının "tamponlu (buffered)" biçimde çalıştığını göz önünde bulundurmak
    gerekir. Biz standart C fonksiyonlarıyla bir dosyaya yazma yaptığımızda aslında yazılanlar önce bir tampona yazılıp 
    biriktirilmekte sonra hedefe aktarılmaktadır. Bu tür durumlarda yazma yaptıktan sonra fflush çağrısı yapmayı unutmayınız. 
    (C standartlarına göre fseek işlemi fflush işlemine de yol açmaktadır.) Örneğin:

    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>

    void write_file(const char *path, const char *cmd); 

    int main(void)
    {
        FILE *f;

        write_file("/sys/class/gpio/gpio60/direction", "out");

        if ((f = fopen("/sys/class/gpio/gpio60/value", "w")) == NULL) {
            fprintf(stderr, "cannot open file!..\n");
            exit(EXIT_FAILURE);
        }

        for (;;) {
            fseek(f, 0, 0);
            fprintf(f, "1");        /* fputc('1', f); */
            fflush(f);
            
            sleep(1);
            
            fseek(f, 0, 0);     
            fprintf(f, "0");        /* fputc('0', f); */
            fflush(f);

            sleep(1);
        }

        fclose(f);

        return 0;
    }

    void write_file(const char *path, const char *cmd)
    {
        FILE *f;

        if ((f = fopen(path, "w")) == NULL) {
            fprintf(stderr, "cannot open file: %s\n", path);
            exit(EXIT_FAILURE);
        }
        fprintf(f, "%s", cmd);
        fclose(f);
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Tabii aslında biz yukarıdaki programları başka dillerde de yazabiliriz. Örneğin LED yakma programı Python'da birkaç satırla 
    aşağıdaki gibi yazılabilir:
                                         
    import time

    with open('/sys/class/gpio/gpio60/value', 'w') as f:
        while True:
            f.write('1')
            f.flush()
            time.sleep(0.2)
            f.write('0')
            f.flush()
            time.sleep(0.2)
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                        131. Ders 30/09/2025 - Salı
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki programları biz doğrudan BBB üzerinde derleyerek çalıştırdık. Her ne kadar BBB ortamı zayıf bir geliştirme 
    ortamı sunuyor olsa da basit programların doğrudan BBB üzerinde derlenmesi performans bakımından bir sorun doğurmamaktadır. 
    Şimdi de yukarıdaki programlardan birini host sistem olarak kullandığımız Linux sistemlerinde çapraz derleyici ile derleyelim 
    ve çalıştırılabilen kodu BBB'ye aktaralım. Bunun için daha önce yaptığımız gibi önce PATH çevre değişkenine çapraz derleyicimizin 
    "bin" dizinini eklememiz gerekir:

    $ PATH=$PATH:/home/kaan/Study/EmbeddedLinux/DriverDevelopment/BBB/gcc-arm-9.2-2019.12-x86_64-arm-none-linux-gnueabihf/bin

    Daha sonra ARCH çevre değişkenini "arm" biçiminde oluşturmamız gerekir:

    $ export ARCH=arm

    Artık herhangi bir yerde çapraz derleyicimizi "arm-none-linux-gnueabihf-gcc" ismiyle çalıştırabiliriz. Ancak daha kısa 
    isim kullanmak istersek CC gibi bir çevre değişkenini de bu ismi belirtecek biçimde oluşturabiliriz:

    $ export CC=arm-none-linux-gnueabihf-gcc

    Derlemeyi şöyle yapabiliriz:

    $ $CC -o led-blink led-blink.c

    Elde edilen çalıştırılabilir dosyayı "scp" komutuyla BBB'ye aşağıdaki gibi aktarabiliriz:

    $ scp led-blink debian@192.168.7.2:
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de GPIO pinlerinde kesme mekanizmasının kullanılmasına bir örnek verelim. GPIO pinini "kesme (interrupt)" için 
    konfigüre etmeden önce IN biçiminde konumlandırmak gerekir. sysfs arayüzünde kesme mekanizması için "edge" isimli dosya 
    kullanılmaktadır. Bu dosyaya "rising" ya da "falling" yazısı yazdırılır. "rising" kesmenin pin değeri 0'dan 1'e geçerken 
    oluşacağını "falling" 1'den 0'a geçerken oluşacağını belirtmektedir. Biz düğme devremizde düğmeye bastığımızda kesme 
    oluşmasını istiyorsak bu dosyaya "falling" yazmalıyız. Çünkü anımsayacağınız gibi bizim devremizde düğmeye basılmadığı 
    sürece pinden 1 okunuyordu. Düğmeye basıldığında 0 okunuyordu. Bu durumda düğmeye bastığımızda 1'den 0'a geçiş oluşacak 
    bu da kesmeyi tetikleyecektir. Tabii tam ters biçimde kesmenin parmağımızı düğmeden çektiğimizde tetiklenmesini istiyorsak 
    bu durumda "edge" dosyasına "rising" yazmalıyız. Bu işlemler komut satırında yapılabileceği gibi bir C programıyla da 
    yapılabilir. 

    sysfs dosya sistemi ile GPIO kesme işlemlerinin ele alınması için "multiplexed IO" fonksiyonları denilen select, poll 
    ya da epoll fonksiyonlarının kullanılması gerekmektedir. Biz bir pini kesme olarak konfigüre ettiğimizde o pinin "value" 
    dosyasını okursak bloke olmayız. Bu value dosyasının select, poll ya da epoll fonksiyonlarıyla ele alınması gerekmektedir. 
    select ve poll fonksiyonları POSIX fonksiyonlarıdır. Ancak epoll fonksiyonu Linux sistemlerine özgüdür. epoll fonksiyonu 
    poll fonksiyonunun Linux sistemleri için iyileşirilmiş bir biçimi gibidir. select, poll ve epoll fonksiyonları çekirdek 
    içerisindeki sys_select, sys_poll ve sys_epoll sistem fonksiyonlarını çağırmaktadır. Bu fonksiyonlar aslında belli bir 
    noktadan sonra ortak kodları çalıştırmaktadır. Biz aygıt sürücüler konusunda aygıt sürücülerin bu fonksiyonlarla nasıl 
    kullanılacağı üzerinde durmadık. Ancak bu üç fonksiyon da en sonunda karakter aygıt sürücülerinin file_operations yapısının 
    poll elemanında adresi tutulan fonksiyonu çağırmaktadır. Çekirdeğe gömülmüş olan GPIO aygıt sürücüsü bu poll fonksiyonunu 
    uygun biçimde ele almıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi sysfs arayüzü ile GPIO pinlerindeki kesme işlemlerini select fonksiyonuyla ele alabilmek 
    için önce pinleri uygun biçimde konfigüre etmek gerekir. Bu işlemi şöyle yapabiliriz:

    write_file("/sys/class/gpio/gpio51/direction", "in");
    write_file("/sys/class/gpio/gpio51/edge", "falling");

    Buradaki write_file fonksiyonunu yukarıdaki örneklerde de kullanmıştık:

    void write_file(const char *path, const char *cmd)
    {
        int fd;

        if ((fd = open(path, O_WRONLY)) == -1) 
            exit_sys("open");

        if (write(fd, cmd, strlen(cmd)) == -1)
            exit_sys("write");

        close(fd);
    }

    Daha sonra "value" dosyasını open fonksiyonuyla açmak gerekir. Açma işlemini "read-only" biçimde O_RDONLY bayrağıyla 
    yapabilirsiniz:

    if ((fd = open("/sys/class/gpio/gpio51/value", O_RDONLY)) == -1)
        exit_sys("open");

    Kesme işlemleri select, poll ve epoll fonksiyonlarında aygıt sürücü tarafından "exceptional" işlem olarak ele alınmıştır. 
    Dolayısıyla select fonksiyonunda bizim fonksiyonun exceptfds parametresini kullanmamız gerekir. O halde tipik bir kesme
    döngüsü şöyle oluşturulabilir:

    fd_set se;  
    ...

    if (read(fd, &buf, 1) == -1) 
        exit_sys("read");

    for (;;) {
        printf("waiting for interrupt...\n");

        FD_ZERO(&se);
        FD_SET(fd, &se);

        if (select(fd + 1, NULL, NULL, &se, NULL) == -1) 
            exit_sys("select");

        if (FD_ISSET(fd, &se)) {  
            lseek(fd, 0, SEEK_SET);     
            if (read(fd, &buf, 1) == -1) 
                exit_sys("read");
            printf("interrupt occured...\n");
        }
    }

    Burada biz tek bir pin üzerinde kesme durumunu ele aldık. Aynı işlemi birden fazla pin üzerinde de yapabilirdik. Tabii
    bu durumda FD_SET ile izlenecek tüm pinlere ilişkin betimleyicileri FD_SET makrosuyla fd_set nesnesine set etmemiz 
    gerekir. Aslında tek bir betimleyici için FD_ISSET kontrolünü yapmaya gerek yoktur. Burada bir noktaya dikkatinizi çekmek 
    istiyoruz. Aygıt sürücünün poll desteğini yazanlar blokeli bir dosya semantiği uygulamışlardır. Dolayısıyla select blokeyi 
    çözdüğü zaman eğer "value" dosyasından değer okunmazsa sonraki select çağrıları dosyada bilgi olduğu gerekçesiyle artık 
    blokeye yol açmayacaktır. Bu nedenle select fonksiyonunun blokesi çözüldükten sonra "value" dosyasının okunması gerekmektedir.  
    Yukarıdaki kodda bir ayrıntı daha vardır. Aygıt sürücüyü yazanlar işlemlere başlarken "value" dosyasında bir değer oluşmuş 
    gibi bir semantik uygulamışlardır. Eğer dosya açıldıktan sonra "value" dosyasından değer okunmazsa sanki bir kez kesme 
    oluşmuş gibi durum oluşmaktadır. Bu nedenle biz yukarıdaki kodda döngüye girmeden önce bir kez "value" dosyasını read 
    fonksiyonuyla okuduk. 

    Aşağıda uygulamanın tüm kodlarını veriyoruz. Programı Ctrl+C tuşlarına basarak sonlandırabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-intr.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/select.h>

void exit_sys(const char *msg);
void write_file(const char *path, const char *cmd);

int main(void)
{
    int fd;
    fd_set se;
    char buf;
    
    write_file("/sys/class/gpio/gpio51/direction", "in");
    write_file("/sys/class/gpio/gpio51/edge", "falling");

    if ((fd = open("/sys/class/gpio/gpio51/value", O_RDONLY)) == -1)
        exit_sys("open");
    
    if (read(fd, &buf, 1) == -1) 
        exit_sys("read");

    for (;;) {
        printf("waiting for interrupt...\n");

        FD_ZERO(&se);
        FD_SET(fd, &se);

        if (select(fd + 1, NULL, NULL, &se, NULL) == -1) 
            exit_sys("select");

        if (FD_ISSET(fd, &se)) {  
            lseek(fd, 0, SEEK_SET);     
            if (read(fd, &buf, 1) == -1) 
                exit_sys("read");
            printf("interrupt occured...\n");
        }
    }

    close(fd);      /* unreachable code */

    return 0;
}

void write_file(const char *path, const char *cmd)
{
    int fd;

    if ((fd = open(path, O_WRONLY)) == -1) 
        exit_sys("open");

    if (write(fd, cmd, strlen(cmd)) == -1)
        exit_sys("write");

    close(fd);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte akış select fonksiyonunda bloke olmaktadır. (Zaten amacımız da bunu sağlamaktır.) Ancak bu tür durumlarda 
    eğer başka birtakım işlemler de yapmak istiyorsanız yukarıdaki kod parçasını bir thread'in çalıştırmasını sağlamalısınız.
    Aşağıda böyle bir örnek verdik. Programı Ctrl+C tuşlarına basarak sonlandırabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-intr.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/select.h>
#include <pthread.h>

void exit_sys(const char *msg);
void exit_sys_err(const char *msg, int err);

void write_file(const char *path, const char *cmd);
void *thread_proc(void *param);

int main(void)
{
    int fd;
    pthread_t tid;
    int result;
    
    write_file("/sys/class/gpio/gpio51/direction", "in");
    write_file("/sys/class/gpio/gpio51/edge", "falling");

    if ((fd = open("/sys/class/gpio/gpio51/value", O_RDONLY)) == -1)
        exit_sys("open");
    
    if ((result = pthread_create(&tid, NULL, thread_proc, (void *)fd)) != 0) 
        exit_sys_err("pthread_create", result);

    for (;;) {
        printf("main thread running...\n");
        sleep(1);
    }

    close(fd);  /* unreachable code */

    return 0;
}

void write_file(const char *path, const char *cmd)
{
    int fd;

    if ((fd = open(path, O_WRONLY)) == -1) 
        exit_sys("open");

    if (write(fd, cmd, strlen(cmd)) == -1)
        exit_sys("write");

    close(fd);
}

void *thread_proc(void *param)
{
    int fd = (int)param;
    fd_set se;
    char buf;

    if (read(fd, &buf, 1) == -1) 
        exit_sys("read");

    for (;;) {
        printf("waiting for interrupt...\n");

        FD_ZERO(&se);
        FD_SET(fd, &se);

        if (select(fd + 1, NULL, NULL, &se, NULL) == -1) 
            exit_sys("select");

        if (FD_ISSET(fd, &se)) {  
            lseek(fd, 0, SEEK_SET);     
            if (read(fd, &buf, 1) == -1) 
                exit_sys("read");
            printf("interrupt occured...\n");
        }
    }
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_err(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                            132. Ders 07/10/2025 - Salı
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de kesme olaylarını select yerine poll fonksiyonu ile ele alan bir örnek yapalım. Yukarıda da belirttiğimiz gibi
    GPIO uçlarında kesme olduğunda bu olay poll fonksiyonunda POLLPRI biçiminde ortaya çıkmaktadır. Programın poll çağrısını
    yapan kısmı şöyledir:

    if (read(fd, &buf, 1) == -1) 
        exit_sys("read");

    pollfds[0].fd = fd;
    pollfds[0].events = POLLPRI;

    for (;;) {
        printf("waiting for interrupt...\n");
        if (poll(pollfds, 1, -1) == -1) 
            exit_sys("poll");
        
        if (pollfds[0].revents & POLLPRI) {
            if (read(fd, &buf, 1) == -1) 
                exit_sys("read");
            printf("interrupt occured...\n");
        }
    }

    poll fonksiyonun ayrıntıları için "UNIX/Linux Sistem Programlama Kursunun" dokümanlarını inceleyebilirsiniz. Aşağıda 
    örneği bir bütün olarak veriyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-intr.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/poll.h>

void exit_sys(const char *msg);
void write_file(const char *path, const char *cmd);

int main(void)
{
    int fd;
    unsigned char buf;
    struct pollfd pollfds[1];
    
    write_file("/sys/class/gpio/gpio51/direction", "in");
    write_file("/sys/class/gpio/gpio51/edge", "falling");

    if ((fd = open("/sys/class/gpio/gpio51/value", O_RDONLY)) == -1)
        exit_sys("open");
    
    if (read(fd, &buf, 1) == -1) 
        exit_sys("read");

    pollfds[0].fd = fd;
    pollfds[0].events = POLLPRI;

    for (;;) {
        printf("waiting for interrupt...\n");
        if (poll(pollfds, 1, -1) == -1) 
            exit_sys("poll");
        
        if (pollfds[0].revents & POLLPRI) {
            if (read(fd, &buf, 1) == -1) 
                exit_sys("read");
            printf("interrupt occured...\n");
        }
    }

    close(fd);  /* unreachable code */

    return 0;
}

void write_file(const char *path, const char *cmd)
{
    int fd;

    if ((fd = open(path, O_WRONLY)) == -1) 
        exit_sys("open");

    if (write(fd, cmd, strlen(cmd)) == -1)
        exit_sys("write");

    close(fd);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    GPIO pinleri üzerinde işlem yapmanın diğer bir yolu da "gpiod" isimli kütüphaneyi kullanmaktır. Bu kütüphane artık bu 
    konuda en yaygın kullanılan kütüphane haline gelmiştir. Kütüphane "sysfs" dosya sistemini değil doğrudan çekirdeğe gömülmüş 
    olan "gpiochip" aygıt sürücüsünü kullanmaktadır. Yani bu kütüphane aslında arka planda bu aygıt sürücüyü açıp aygıt 
    sürücüye ioctl komutlarını göndermektedir. "gpiod" yüksek seviyeli bir kütüphanedir. Ancak gpiod kütüphanesinin bir 
    süredir 2'li yeni versiyonları oluşturulmuştur. Fakat bu versiyonlar yerine default kurulumda hala 1'li versiyonlar 
    kurulmaktadır. Maalesef 2'li versiyonlarla 1'li versiyonlar arasında bir API uyumu da yoktur. Çünkü kütüphanenin ikili 
    versiyonlarında işlemlerin akışı da değiştirilmiştir. Biz burada kütüphanenin halen default olarak kullanılan 1'li 
    versiyonlarını ele alacağız. Ancak 2'li versiyonlarındaki farklılıklar üzerinde de kısaca duracağız. 

    Kütüphanenin 1'li versiyonlarının dokümantasyonuna PDF dosyası olarak aşağıdaki bağlantıdan erişebilirsiniz: 
    
    http://phwl.org/assets/images/2021/02/libgpiod-ref.pdf
    
    Kütüphanenin 2'li versiyonlarının dokümantasyonuna da aşağıdaki bağlantıdan erişebilirsiniz:

    https://libgpiod.readthedocs.io/en/latest/

    Kütüphane default durumda yüklü değildir. Kütüphaneyi Debian tabanlı sistemlerde aşağıdaki gibi yükleyebilirsiniz:

    $ sudo apt install libgpiod-dev

    Yukarıda da belirttiğimiz gibi bu default yüklemede kütüphanenin 1'li versiyonu (1.6.3 versiyonu) yüklenmektedir. 

    gpiod kütüphanesini kullanan bir grup komut satırından çalışan utility programlar da vardır. Bu programlar sayesinde 
    tıpkı sysfs arayüzünde yaptığımız gibi komut satırından temel test işlemlerini yapabilirsiniz. Sözünü ettiğimiz bu 
    utility programları da aşağıdaki gibi kurabilirsiniz:

    $ sudo apt install gpiod

    Yukarıdaki kurulumları ARM işlemcili gömülü sisteminize yaparsanız ve kodu o sistemde derlerseniz bir sorun oluşmaz. Bu 
    kütüphaneyi ve utility programları Intel tabanlı bilgisayarlarınızdaki Linux sistemlerine kurmanızın uç bazı durumlar 
    dışında bir anlamı yoktur. 

    Biz BBB gibi bir ortam için geliştirmeyi genel olarak Intel tabanlı masaüstü Linux sistemlerindeki çapraz derleyicileri 
    kullanarak yapmaktayız. Ancak çapraz derleyicilerimizde gpiod kütüphanesi bulunmamaktadır. O zaman bizim bu kütüphanenin
    kaynak kodlarını indirip ARM çapraz derleyicimize ilişkin araç zincirini kullanarak kütüphaneyi host makinede derlemek gerekir. 
    (Maalesef bu kütüphanelerin ARM için derlenmiş binary dosyaları yoktur.) 

    gpiod kütüphanesini çapraz derleyici ile derleme işlemi şu adımlardan geçilerek yapılabilir:

    1) Kütüphanenin kaynak kodları indirilir. İndirme işlemini wget komutuyla aşağıdaki gibi yapabilirsiniz:

    $ wget https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/snapshot/libgpiod-1.6.3.tar.gz

    Buradan kaynak kodlar tar.gz formatında indirilmektedir. Açımı şöyle yapabilirziniz:

    $ tar -xzf libgpiod-1.6.3.tar.gz

    Artık kaynak kodlar "libgpiod-1.6.3" isimli bir dizine açılmıştır. 

    2) Derleme için host makinede bazı programların da bulunuyor olması gerekir. Bunların bazıları zaten sisteminizde muhtemelen 
    yüklü olacaktır. Ancak aşağıdaki komutla yüklü olmayan programları da yükleyebilirsiniz:

    3) sudo apt-get install -y autoconf-archive autoconf automake libtool pkg-config build-essential autotools-dev build-essential

    4) Çapraz derleyici ayarlarını yapmamız gerekir:

    $ PATH=$PATH:/home/kaan/Study/EmbeddedLinux/DriverDevelopment/BBB/gcc-arm-9.2-2019.12-x86_64-arm-none-linux-gnueabihf/bin
    $ export ARCH=arm
    $ export CC=arm-none-linux-gnueabihf-gcc

    Derleme işlemi için kaynak kod dizinine geçilip "autogen.sh" dosyası aşağıdaki komut satırı argümanlarıyla çalıştırılır:

    ./autogen.sh --host=arm-linux-gnueabihf --enable-tools=no --enable-bindings-cxx=no --prefix=/usr

    Bu program Makefile oluşturmaktadır. Makefile dosyası içerisinde derleyici $CC komutuyla çalıştırılmaktadır. 

    5) "autogen.sh" tarafından oluşturulan Makefile dosyası "make" programıyle işletilir:

    $ make

    6) Artık derleme sonrasında ARM işlemcileri için statik ve dinamik kütüphane dosyaları oluşturulmuştur. Bu dosyaların ve
    include dosyalarının araç zincirinin ilgili dizinlerine çekilmesi gerekir. Bu işlemler manuel olarak yapılabilir. Ancak 
    bu işlemleri kolaylaştırmak için "make install" komutu da bulundurulmuştur. Komutu şöyle kullanabilirsiniz:

    $ make install DESTDIR=$($CC --print-sysroot)

    Burada $($CC --print-sysroot) işlemi çapraz araç zincirinde ilgili dosyaların çekileceği kök dizini elde etmek için 
    kullanılmıştır. --print-sysroot masaüstü gcc derleyicilerinde bir çıktı vermemektedir. Bu seçenek çapraz derleyiciler 
    için kütüphanelerin ve include dosyalarının konuşlandırılacağı yerin kök dizinini vermektedir. 

    7) Artık uygulama programımızın derlenmesi işlemi çapraz derleyici ile aşağıdaki gibi yapılabilir:

    $ $CC -o gpiod-sample gpiod-sample.c -lgpiod

    Elde edilen çalıştırılabilir dosya BBB'ye kopyalanabilir.

    Burada bir noktaya dikkatinizi çekmek istiyoruz. Daha önceden de belirttiğimiz gibi gpiod kütüphanesi aslında "/dev/gpiochipN"
    aygıt dosyalarını kullanmaktadır. Bu aygıt dosyalarının erişim haklarına dikkat ediniz:

    crw-rw---- 1 root gpio 254, 0 Feb  4 22:05 /dev/gpiochip0
    crw-rw---- 1 root gpio 254, 1 Feb  4 22:05 /dev/gpiochip1
    crw-rw---- 1 root gpio 254, 2 Feb  4 22:05 /dev/gpiochip2
    crw-rw---- 1 root gpio 254, 3 Feb  4 22:05 /dev/gpiochip3

    Burada dosyanın sahibinin "root" olduğu ve grubunun da "gpio" olduğunu görüyorsunuz. Linux'un BBB için oluşturulmuş 
    orijinal imajındaki "debian" kullanıcısı "ek grup (supplementary groups)" olarak "gpio" grubunu da içermektedir. Yani 
    bu "debian" kullanıcısı aynı zamanda sanki "gpio" grubundaymış gibi de davranmaktadır. Dolayısıyla bizim bu aygıt 
    sürücü dosyalarını açıp, okuma yazma yapmak için sudo kullanmamıza gerek kalmamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                    133. Ders 09/10/2025 - Perşembe
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Burada önce gpiod kütüphanesinin utility programlarından da kısaca bahsetmek istiyoruz. 

    - gpiodetect isimli program GPIO aygıt sürücülerinin listesini bize vermektedir. Örneğin:

    $ gpiodetect
    gpiochip0 [gpio-0-31] (32 lines)
    gpiochip1 [gpio-32-63] (32 lines)
    gpiochip2 [gpio-64-95] (32 lines)
    gpiochip3 [gpio-96-127] (32 lines)

    - Kütüphanede pin yerine "hat (line)" sözcüğü kullanılmıştır. Belli bir GPIO aygıtındaki hatlar hakkında bilgiler şöyle
    edinilebilir:

    $ gpioinfo gpiochip0
    gpiochip0 - 32 lines:
        line   0: "[mdio_data]" unused input active-high 
        line   1: "[mdio_clk]"       unused   input  active-high 
        line   2: "P9_22 [spi0_sclk]" "P9_22" input active-high [used]
        line   3: "P9_21 [spi0_d0]" "P9_21" input active-high [used]
        line   4: "P9_18 [spi0_d1]" "P9_18" input active-high [used]
        line   5: "P9_17 [spi0_cs0]" "P9_17" input active-high [used]
        line   6:  "[mmc0_cd]"         "cd"   input   active-low [used]
        line   7: "P8_42A [ecappwm0]" "P9_42" input active-high [used]
        line   8: "P8_35 [lcd d12]" "P8_35" input active-high [used]
        line   9: "P8_33 [lcd d13]" "P8_33" input active-high [used]
        line  10: "P8_31 [lcd d14]" "P8_31" input active-high [used]
        line  11: "P8_32 [lcd d15]" "P8_32" input active-high [used]
        line  12: "P9_20 [i2c2_sda]" "P9_20" input active-high [used]
        line  13: "P9_19 [i2c2_scl]" "P9_19" input active-high [used]
        line  14: "P9_26 [uart1_rxd]" "P9_26" input active-high [used]
        line  15: "P9_24 [uart1_txd]" "P9_24" input active-high [used]
        line  16: "[rmii1_txd3]" unused input active-high 
        line  17: "[rmii1_txd2]" unused input active-high 
        line  18: "[usb0_drvvbus]" unused input active-high 
        line  19: "[hdmi cec]"       unused   input  active-high 
        line  20:     "P9_41B"      "P9_41"   input  active-high [used]
        line  21: "[rmii1_txd1]" unused input active-high 
        line  22: "P8_19 [ehrpwm2a]" "P8_19" input active-high [used]
        line  23: "P8_13 [ehrpwm2b]" "P8_13" input active-high [used]
        line  24:         "NC"       unused   input  active-high 
        line  25:         "NC"       unused   input  active-high 
        line  26:      "P8_14"      "P8_14"   input  active-high [used]
        line  27:      "P8_17"      "P8_17"   input  active-high [used]
        line  28: "[rmii1_txd0]" unused input active-high 
        line  29: "[rmii1_refclk]" unused input active-high 
        line  30: "P9_11 [uart4_rxd]" "P9_11" input active-high [used]
        line  31: "P9_13 [uart4_txd]" "P9_13" input active-high [used]

    Burada [used] belirteci ilgili GPIO ucunun pine bağlandığı anlamına gelmektedir. 

    - Belli bir pini (gpiod terminolojisi ile "hattı") çıkış olarak konfigüre etmek ve ilgili pini lojik 1 ya da lojik 0 
    seviyesine çekmek için "gpioset" komutu kullanılmaktadır. Komutun birinci parametresi gpio chip'inin ismini (yani "/dev" 
    dizinindeki aygıt sürücü ismini) almaktadır. Bunu "<numara>=1" ya da "<numara>=0" argümanları izler. Bu argümanlar birden 
    fazla girilebilmektedir. Buradaki <numara> daha önce görmüş olduğumuz GPIOX_Y SoC numaralandırmasındaki Y değeridir. 
    Örneğin biz LED'imizi GPIO1_28 SoC numarasına ilişkin pine bağlamıştık. Ancak gpioset programı sonlanırken ilgili pini 
    default duruma çekmektedir. Dolayısıyla örneğin bu programla bir LED'i yakmak istiyorsanız programın hemen sonlanmaması 
    gerekir. Bunu yapmanın tipik iki yolu vardır. Eğer --mode=wait kullanılırsa klavyeden CTRL+D (EOF) tuşlarına basılana 
    kadar program sonlanmaz. Eğer --mode=signal kullanılırsa bu durumda ancak bir sinyal oluştuğunda program sonlandırılır. 
    Tabii buradaki tipik sinyal Ctrl+C tuşlarıyla oluşturulan SIGINT sinyalidir. Örneğin GPIO60 (yani GPIO1_28) pinini OUT 
    olarak konfigüre edip onu lojik 1 seviyesine şöyle çekebiliriz:

    $ gpioset --mode=wait gpiochip1 28=1

    "gpioset" komutu her zaman ilgili pini önce OUT olarak konfigüre eder sonra da onu lojik 1 ya da lojik 0 düzeyine çeker. 
    
    Peki biz gpioset komutunu kullanarak LED'i 1 saniye yakıp bir saniye söndürmek istesek ve bunu bir döngü içerisinde 
    yapmak istesek bunu nasıl yapabiliriz? Bunun için --mode=time komut satırı argümanı ile -s <saniye_sayısı> ya da 
    --sec <saniye_sayısı> argümanının birlikte kullanılması gerekir. Örneğin:

    $ gpioset --mode=time --sec 1 gpiochip1 28=1

    Beklemeyi milisaniye cinsinden belirtmek için --usec <milisaniye_sayısı> argümanı kullanılmaktadır.

    Burada artık program 1 saniye sonra sonlanacaktır. 
    
    Aslında aynı işlemler timeout isimli kabuk komutuyla da yapılabilir. 
    Bu komut şöyle kullanılmaktadır:

    timeout <süre> <komut> [argümanlar...]

    Örneğin:

    timeout 1 gpioset --mode=wait gpiochip1 28=1

    Burada 1 saniye ilgili pin lojik 1 seviyesine çekilecektir. timeout programı default olarak çalıştırdığı programa SIGTERM 
    sinyalini göndermektedir. Başka sinyal göndermek isteniyorsa --signal=sinyal_numarası biçiminde komut satırı argümanı 
    kullanılmalıdır. 

    Tabii bu işlemlerin bir "kabuk betiği (shell script)" ile bir döngü içerisinde aşağıdaki gibi yapılması gerekir:

    #!/bin/bash
    while true; do
        gpioset --mode=time --sec 1 gpiochip1 28=1
        gpioset --mode=time --sec 1 gpiochip1 28=0
    done
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    - "gpioget" komutu ilgili pini IN biçiminde konfigüre edip o pindeki işareti okumaktadır. Komutun argümanları şöyledir:

    gpioget aygıt_ismi   pin_numarası
    
    Örneğin biz düğmemizi GPIO1_19 (GPIO51) pinine bağlamıştık. Bu pini IN durumuna çekip okuduğumuzda düğmeye basılmamışsa 1, 
    basılmışsa 0 okuduğumuzu anımsayınız. O halde okumayı şöyle yapabiliriz:

    $ gpioget gpiochip1 19

    - Belli pinlerdeki olayları izlemek için "gpiomon" komutu kullanılmaktadır. Bu komut ilgili pinleri kesme moduna sokar 
    ve ilgili olay olana kadar bekleme yapar. Kesmeyi çıkan kenar olarak konfigüre edip izlemek için --rising-edge argümanı, düşen
    kenar olarak konfigüre edip izlemek için --falling-edge argümanı kullanılmaktadır. Örneğin amacımız GPIO1_19 (GPIO51) 
    pinine basıldığında bunun anlaşılması olsun. Bizim devremizde bu uçtan default olarak lojik 1 okunuyordu. Biz düğmeye
    bastığımızda "düşen kenar tetiklemeli kesme" oluşacaktır. Bu izleme şöyle yapılabilir:

    $ gpiomon --falling-edge gpiochip1 19

    Bu komutla program sonsuz döngü oluşturacaktır. Her düğmeye bastığımızda oluşan kesmeyi yakalıp ekrana mesaj çıkartacaktır. 
    Sonsuz döngüden çıkmak için Ctrl+C tuşlarını kullanabilirsiniz. 
    
    Yukarıda açıkladığımız utility programların aslında bazı kullanım ayrıntıları da vardır. Bunları ilgili dokümanlardan 
    inceleyebilirsiniz. Ancak bu programlar kütüphane 2 versiyonları ile daha fazla komut argümanına sahip olmuştur. Bulduğunuz
    örneklerdeki komut satırı argümanlarının kendi makinenizde çalışmadığını görürseniz şaşırmayınız. 

    "gpiod" utility programları sysfs arayüzü ile uyumsuzluk oluşturabilmektedir. Bu komutları çalıştırdığınızda ilgili 
    pinin "/sys/class/gpio" dizininin silindiğini görürseniz şaşırmayınız. Bu durumda makineyi reset etmeden ilgili pin 
    dosyasını aşağıdaki gibi yeniden export edebilirsiniz:

    $ echo 60 | sudo tee /sys/class/gpio/export

    Bu örnek komut GPIO60 pinini yeniden export ederek dosya sisteminde görünür hale getirmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda "gpiod" kütüphanesinin komut satırından kullanılan utility programlarını (komutlarını da diyebiliriz) ele 
    aldık. Şimdi kütüphanenin C içerisinden nasıl kullanılacağı üzerinde duralım. Kütüphanedeki tüm fonksiyonların prototipleri, 
    sembolik sabitler ve yapı bildirimleri <gpiod.h> dosyası içerisindedir. Bu dosyayı programınızda include etmelisiniz. 
    Ayrıca kütüphanenin link aşamasında devreye girmesi için komut satırında -lgpiod seçeneğini kullanmayı unutmayınız. Örneğin:

    $ gcc -Wall -o gpio-sample gpio-sample.c -lgpiod
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    gpiod kütüphanesinin arka planda aslında "/dev/gpiochipN" aygıt dosyalarını açıp onlara ioctl komutlarını göndererek 
    yazılmış olduğunu belirtmiştik. Bu kütüphanede ilk yapılacak işlem ilgili GPIO chip'ini kütüphanedeki fonksiyonları 
    kullanarak açmaktır. Bunun için gpiod_chip_open_by_name fonksiyonu kullanılabilir. Bu fonksiyonun prototipi şöyledir:

    #include <gpiod.h>

    struct gpiod_chip *gpiod_chip_open_by_name(const char *name);

    Fonksiyon GPIO chip aygıt sürücüsünün ismini (yol ifadesini değil) alır. Başarı durumunda gpiod_chip yapısı türünden 
    bir nesnenin adresiyle geri döner. Bu nesne GPIO chip aygıt sürücüsü için bir handle niteliğindedir. Fonksiyon başarısızsa
    NULL adrese geri dönmektedir. Hata durumunda errno değişkeni set edilmektedir. Dolayısıyla hatanın nedenini perror 
    fonksiyonuyla yazdırabilirsiniz. Örneğin:

    struct gpiod_chip *chip;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
        
    İlgili chip aygıt sürücüsünü açmak için gpiod_chip_open_by_number fonksiyonu kullanılabilir. Bu fonksiyon yalnızca numara 
    almaktadır. (Örneğin bu fonksiyona 0 girilirse by "gpiochip0" anlamına gelmektedir.) gpiod_chip_open fonksiyonu ise aygıt
    sürücünün tam yol ifadesini almaktadır. Örneğin bu fonksiyona "/dev/gpiochipo" yol ifadesini girebiliriz. 

    Biz bu bölümde gpiod_chip nesnesine kısaca "chip nesnesi" de diyeceğiz. 

    Açılan bir chip aygıt sürücüsü gpiod_chip_close fonksiyonu ile kaynaklar serbest bırakılarak kapatılabilir. Fonksiyonun 
    prototipi şöyledir:

    #include <gpiod.h>

    void gpiod_chip_close(struct gpiod_chip *chip);

    Fonksiyon gpiod_chip nesnesinin adresini almaktadır. Örneğin:

    gpiod_chip_close(chip);

    Chip aygıt sürücüsünü açtıktan sonra üzerinde çalışacağımız pine ilişkin gpiod_line nesnesinin elde edilmesi gerekmektedir. 
    Bu işlem gpiod_chip_get_line fonksiyonuyla yapılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <gpiod.h>

    struct gpiod_line *gpiod_chip_get_line(struct gpiod_chip *chip, unsigned int offset);

    Fonksiyonun birinci parametresi chip nesnesinin adresini, ikinci parametresi ise o chip'teki pinin numarasını belirtmektedir. 
    Fonksiyon başarı durumunda gpiod_line isimli bir yapı türünden nesnenin adresine, başarısızlık durumunda ise NULL adrese 
    geri dönmektedir. Örneğin:

    struct gpiod_chip *chip;
    struct gpiod_line *line;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 28)) == NULL)
        exit_sys("gpiod_chip_get_line");

    Biz bu bölümde gpiod_line nesnesine hat nesnesi diyeceğiz. Anımsanacağı gibi bu kütüphanenin terminolojisinde "pin" yerine "hat 
    (line)" denilmektedir.)

    Açılan pinin  kapatılması için de gpiod_line_release fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir.

    #include <gpiod.h>

    int gpiod_line_release(struct gpiod_line *line);

    Fonksiyon hat nesnesinin adresini parametre olarak alır. Başarı durumunda 0 değerine başarısızlık durumunda -1 değerine 
    geri döner. Örneğin:

    struct gpiod_chip *chip;
    struct gpiod_line *line;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 28)) == NULL)
        exit_sys("gpiod_chip_get_line");

    printf("success...\n");

    gpiod_line_release(line);
    gpiod_chip_close(chip);

    İlgili GPIO pinini elde ettikten sonra onu IN ya da OUT biçiminde konfigüre etmek gerekir. Belli bir pin'i OUT olarak 
    konfigüre etmek için gpiod_line_request_output fonksiyonuyla yapılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <gpiod.h>

    int gpiod_line_request_output(struct gpiod_line *line, const char *consumer, int default_val);

    Fonksiyonun birinci parametresi hat nesnesinin adresini almaktadır. İkinci parametresi ise pin'i kullanan program 
    tarafından belirlenen bir ismi belirtmektedir.  Üçüncü parametre pine gönderilecek ilk işareti belirtir. Bu parametre 
    0 ya da 1 olabilir. Fonksiyon başarı durumunda 0, başarısızlık durumunda -1 değerine geri dönmektedir. Örneğin:

    struct gpiod_chip *chip;
    struct gpiod_line *line;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 28)) == NULL)
        exit_sys("gpiod_chip_get_line");

     if (gpiod_line_request_output(line, "myapp", 1) == -1)
        exit_sys("gpiod_line_request_output");

    printf("Press ENTER to exit...\n");
    getchar();

    gpiod_line_release(line);
    gpiod_chip_close(chip);

    Burada  LED'i bağladığımız pin'e 3.3V gönderdik. Dolayısıyla program sonlanana kadar LED'imiz yanacaktır. Peki biz 
    saniyede bir yanıp sönen LED uygulaması için döngü içerisinde her defasında gpiod_line_request_output fonksiyonunu mu 
    çağırmalıyız? Hayır, artık elimizde hat nesnesi varsa doğrudan ilgili pin'e lojik 0 ya da lojik 1 işaretini 
    gpiod_line_set_value fonksiyonuyla gönderebiliriz. Fonksiyonun prototipi şöyledir:

    #include <gpiod.h>

    int gpiod_line_set_value(struct gpiod_line *line, int value);

    Fonksiyonun birinci parametresi hat nesnesinin adresini, ikinci parametresi lojik işareti almaktadır. İkinci parametre 
    için girilecek değer 1 ya da 0 olabilir. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine
    geri dönmektedir. Örneğin:

    struct gpiod_chip *chip;
    struct gpiod_line *line;
    int out;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 28)) == NULL)
        exit_sys("gpiod_chip_get_line");
   
    if (gpiod_line_request_output(line, "myapp", 0) == -1)
        exit_sys("gpiod_line_request_output");

    out = 1;
    for (int i = 0; i < 30; ++i) {
        if (gpiod_line_set_value(line, out) == -1)
            exit_sys("gpiod_line_set_value");
        out = !out;
        sleep(1);
    }

    gpiod_line_release(line);
    gpiod_chip_close(chip);
---------------------------------------------------------------------------------------------------------------------------*/

/* gpiod-sample.c */

#include <stdio.h>
#include <unistd.h>
#include <gpiod.h>

void exit_sys(const char *msg);

int main(void)
{
    struct gpiod_chip *chip;
    struct gpiod_line *line;
    int out;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 28)) == NULL)
        exit_sys("gpiod_chip_get_line");
    
    if (gpiod_line_request_output(line, "myapp", 0) == -1)
        exit_sys("gpiod_line_request_output");

    out = 1;
    for (int i = 0; i < 30; ++i) {
        if (gpiod_line_set_value(line, out) == -1)
            exit_sys("gpiod_line_set_value");
        out = !out;
        sleep(1);
    }

    gpiod_line_release(line);
    gpiod_chip_close(chip);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                            134. Ders 14/10/2025 - Salı
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Belli bir hattı (yani pin'i) IN olarak konfigüre etmek için gpiod_line_request_input fonksiyonu kullanılmaktadır. Fonksiyonun
    prototipi şöyledir:

    #include <gpiod.h>

    int gpiod_line_request_input(struct gpiod_line *line, const char *consumer);

    Fonksiyonun birinci parametresi GPIO hattına ilişkin gpiod_line nesnesinin adresini almaktadır. İkinci parametre uygulamayı
    betimleyen herhangi bir isim olarak girilebilmektedir. Fonksiyon başarı durumunda 0, başarısızlık durumunda -1 değerine 
    geri dönmektedir. Belli bir hattı giriş olarak konfigüre ettikten sonra artık o hattan okuma yapılabilir. Bunun için 
    gpiod_line_get_value fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <gpiod.h>

    int gpiod_line_get_value(struct gpiod_line *line);

    Fonksiyon hat nesnesinin adresini parametre olarak alır ve hattaki giriş işaretini geri dönüş değeri olarak verir. Hata 
    durumunda fonksiyon -1 değerine geri dönmektedir. Örneğin:

    struct gpiod_chip *chip;
    struct gpiod_line *line;
    int result;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 19)) == NULL)
        exit_sys("gpiod_chip_get_line");
    
    if (gpiod_line_request_input(line, "myapp") == -1)
        exit_sys("gpiod_line_request_input");

    for (int i = 0; i < 10; ++i) {
        if ((result = gpiod_line_get_value(line)) == -1)
            exit_sys("gpiod_line_get_value");
        printf("%d\n", result);
        sleep(1);
    }

    gpiod_line_release(line);
    gpiod_chip_close(chip);

    Aşağıda programın tamamını veriyoruz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* gpiod-sample.c */

#include <stdio.h>
#include <unistd.h>
#include <gpiod.h>

void exit_sys(const char *msg);

int main(void)
{
    struct gpiod_chip *chip;
    struct gpiod_line *line;
    int result;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 19)) == NULL)
        exit_sys("gpiod_chip_get_line");
    
    if (gpiod_line_request_input(line, "myapp") == -1)
        exit_sys("gpiod_line_request_input");

    for (int i = 0; i < 10; ++i) {
        if ((result = gpiod_line_get_value(line)) == -1)
            exit_sys("gpiod_line_get_value");
        printf("%d\n", result);
        sleep(1);
    }

    gpiod_line_release(line);
    gpiod_chip_close(chip);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Tek hamlede birden fazla hattın değerini okumak ya da birden fazla hatta değişik değerleri tek hamlede yazmak isteyebiliriz. 
    Bu işlemlere gpiod kütüphanesinde "bulk işlemler" denilmektedir. Birden fazla hatta ilişkin gpiod_line nesnelerinin adreslerini 
    tutan gpiod_line_bulk isimli bir yapı vardır. Bu yapı şöyle bildirilmiştir:

    struct gpiod_line_bulk {
        unsigned int num_lines;
        struct gpiod_line *lines[GPIOD_LINE_BULK_MAX_LINES];
    };

    Birden fazla hattı almak için gpiod_chip_get_lines fonksiyonu kullanılmaktadır. Bu fonksiyonun prototipi şöyledir.

    #include <gpiod.h>

    int gpiod_chip_get_lines(struct gpiod_chip *chip, unsigned int *offsets, unsigned int num_offsets, struct gpiod_line_bulk *bulk);

    Fonksiyonun birinci parametresi gpiod_chip nesnesinin adresini, ikinci parametresi alınacak hatlara ilişkin numaraları, 
    üçüncü parametre ise ikinci parametrede belirtilen dizinin uzunluğunu belirtmektedir. Fonksiyon başarı durumunda 0 değerine, 
    başarısızlık durumunda -1 değerine geri dönmektedir. Burada elde edilen gpiod_line_bulk nesnesi gpiod_line_release_bulk 
    fonksiyonu ile serbest bırakılmaktadır. Bu fonksiyonun prototipi de şöyledir:

    void gpiod_line_release_bulk(struct gpiod_line_bulk *bulk);

    Fonksiyon gpiod_line_bulk nesnesini parametre olarak alıp oluşturduğu alanı serbest bırakır. Örneğin:

    struct gpiod_chip *chip;
    unsigned int offsets[] = {4, 17, 27};
    struct gpiod_line_bulk lb;

    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");

    if (gpiod_chip_get_lines(chip, offsets, 3, &lb) == -1)
        exit_sys("gpiod_chip_get_lines");
    
    /* ... */

    gpiod_line_release_bulk(&lb);

    Birden fazla hattı OUT olarak konfigüre etmek için gpiod_line_request_bulk_output fonksiyonu IN olarak konfigüre etmek 
    için gpiod_line_request_bulk_input fonksiyonu kullanılmaktadır. Bu fonksiyonların prototipileri şöyledir:

    #include <gpiod.h>

    int gpiod_line_request_bulk_output(struct gpiod_line_bulk *bulk, const char *consumer, const int *default_vals);
    int gpiod_line_request_bulk_input(struct gpiod_line_bulk *bulk, const char *consumer);

    birinci parametreleri gpiod_line_bulk nesnesinin adresini, ikinci parametreleri programcının vereceği uygulama ismini 
    almaktadır. default_vals parametresi OUT olarak konfigüre ederken verilecek ilk değerleri belirtir. Fonksiyonlar başarı 
    durumunda 0, başarısızlık durumunda -1 değerine geri dönmektedir. Örneğin:

    struct gpiod_chip *chip;
    unsigned int offsets[] = {4, 17, 27};
    unsigned int initial_values[] = {0, 0, 0};
    struct gpiod_line_bulk *lb;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if (gpiod_chip_get_lines(chip, offsets, 3, &lb) == -1)
        exit_sys("gpiod_chip_get_lines");

    if (gpiod_line_request_bulk_output(&lb, "myapp", initial_values) == -1)
        exit_sys("gpiod_line_request_bulk_output");

    /* ... */

    gpiod_line_release_bulk(&lb);
    gpiod_chip_close(chip);
    
    Birden fazla hattı tek hamlede set etmek için gpiod_line_set_value_bulk fonksiyonu kullanılmaktadır. Fonksiyonun prototipi 
    şöyledir:

    int gpiod_line_set_value_bulk(struct gpiod_line_bulk *bulk, const int *values);

    Fonksiyonun birinci parametresi gpiod_line_bulk nesnesinin adresini, ikinci parametresi hatlara set edilecek değerleri 
    almaktadır. Fonksiyon başarı durumunda 0 başarısızlık durumunda -1 değerine geri dönmektedir. Örneğin:

    struct gpiod_chip *chip;
    unsigned int offsets[] = {4, 19, 28};
    int initial_values[] = {0, 0, 0};
    int values[3];
    struct gpiod_line_bulk lb;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if (gpiod_chip_get_lines(chip, offsets, 3, &lb) == -1)
        exit_sys("gpiod_chip_get_lines");

    if (gpiod_line_request_bulk_output(&lb, "myapp", initial_values) == -1)
        exit_sys("gpiod_line_request_bulk_output");

    for (int i = 0; i < 10; ++i) {
        values[0] = 1;
        values[1] = 1;
        values[2] = 1;

        if (gpiod_line_set_value_bulk(&lb, values) == -1)
            exit_sys("gpiod_line_set_value_bulk");

        sleep(1);

        values[0] = 0;
        values[1] = 0;
        values[2] = 0;

        if (gpiod_line_set_value_bulk(&lb, values) == -1)
            exit_sys("gpiod_line_set_value_bulk");

        sleep(1);
    }

    gpiod_line_release_bulk(&lb);
    gpiod_chip_close(chip);

    Aşağıda örnek bir bütün olarak verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* gpiod-sample.c */

#include <stdio.h>
#include <unistd.h>
#include <gpiod.h>

void exit_sys(const char *msg);

int main(void)
{
    struct gpiod_chip *chip;
    unsigned int offsets[] = {4, 19, 28};
    int initial_values[] = {0, 0, 0};
    int values[3];
    struct gpiod_line_bulk lb;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if (gpiod_chip_get_lines(chip, offsets, 3, &lb) == -1)
        exit_sys("gpiod_chip_get_lines");

    if (gpiod_line_request_bulk_output(&lb, "myapp", initial_values) == -1)
        exit_sys("gpiod_line_request_bulk_output");

    for (int i = 0; i < 10; ++i) {
        values[0] = 1;
        values[1] = 1;
        values[2] = 1;

        if (gpiod_line_set_value_bulk(&lb, values) == -1)
            exit_sys("gpiod_line_set_value_bulk");

        sleep(1);

        values[0] = 0;
        values[1] = 0;
        values[2] = 0;

        if (gpiod_line_set_value_bulk(&lb, values) == -1)
            exit_sys("gpiod_line_set_value_bulk");

        sleep(1);
    }

    gpiod_line_release_bulk(&lb);
    gpiod_chip_close(chip);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aynı anda birden fazla hattın değerini okumak için de gpiod_line_get_value_bulk fonksiyonu kullanılmaktadır. Fonksiyonun
    prototipi şöyledir:

   int gpiod_line_get_value_bulk(struct gpiod_line_bulk *bulk, int *values);

   Fonksiyonun birinci parametresi gpiod_line_bulk nesnesinin adresini, ikinci parametresi hatlardan okunan değerlerin 
   yerleştirileceği int dizinin adresi belirtmektedir. Örneğin:

    struct gpiod_chip *chip;
    unsigned int offsets[] = {4, 19, 28};
    int values[3];
    struct gpiod_line_bulk lb;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if (gpiod_chip_get_lines(chip, offsets, 3, &lb) == -1)
        exit_sys("gpiod_chip_get_lines");

    if (gpiod_line_request_bulk_input(&lb, "myapp") == -1)
        exit_sys("gpiod_line_request_bulk_output");

    for (int i = 0; i < 10; ++i) {
        if (gpiod_line_get_value_bulk(&lb, values) == -1)
            exit_sys("gpiod_line_set_value_bulk");
        for (int k = 0; k < 3; ++k)
            printf("line %d: %d\n", offsets[k], values[k]);
        sleep(1);
    }

    gpiod_line_release_bulk(&lb);
    gpiod_chip_close(chip);

    Örnek bir bütün olarak aşağıda verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* gpiod-sample.c */

#include <stdio.h>
#include <unistd.h>
#include <gpiod.h>

void exit_sys(const char *msg);

int main(void)
{
    struct gpiod_chip *chip;
    unsigned int offsets[] = {4, 19, 28};
    int values[3];
    struct gpiod_line_bulk lb;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if (gpiod_chip_get_lines(chip, offsets, 3, &lb) == -1)
        exit_sys("gpiod_chip_get_lines");

    if (gpiod_line_request_bulk_input(&lb, "myapp") == -1)
        exit_sys("gpiod_line_request_bulk_output");

    for (int i = 0; i < 10; ++i) {
        if (gpiod_line_get_value_bulk(&lb, values) == -1)
            exit_sys("gpiod_line_set_value_bulk");
        for (int k = 0; k < 3; ++k)
            printf("line %d: %d\n", offsets[k], values[k]);
        sleep(1);
    }

    gpiod_line_release_bulk(&lb);
    gpiod_chip_close(chip);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de gpiod kütüphanesinde kesme işlemlerinin nasıl yapıldığı üzerinde duralım. Kesme işlemlerini yapabilmek için önce 
    ilgili hattın "çıkan kenar tetiklemeli mi", "düşen kenar tetiklemeli mi" kesme oluşturacağı ayarlanmalıdır. Bunun için 
    gpiod_line_request_rising_edge_events ve gpiod_line_request_falling_edge_events fonksiyonları kullanılmaktadır. Fonksiyonların 
    prototipleri şöyledir:
    
    #include <gpiod.h>
 
    int gpiod_line_request_rising_edge_events(struct gpiod_line *line, const char *consumer);
    int gpiod_line_request_falling_edge_events(struct gpiod_line *line, const char *consumer);

    Fonksiyonların birinci parametreleri gpiod_line nesnesinin adresini, ikinci parametreleri uygulamayı belirten bir yazıyı 
    almaktadır. Fonksiyonlar başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Bu fonksiyonlar 
    zaten hattı IN olarak konfigüre de etmektedir. Örneğin:

    struct gpiod_chip *chip;
    struct gpiod_line *line;
    int result;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 19)) == NULL)
        exit_sys("gpiod_chip_get_line");
    
    if (gpiod_line_request_falling_edge_events(line, "myapp") == -1)
        exit_sys("gpiod_line_request_falling_edge_events");

    /* ... */
        
    gpiod_line_release(line);
    gpiod_chip_close(chip);

    Bundan sonra artık gpiod_line_event_wait fonksiyonu ile kesme oluşana kadar bloke beklenir. Tabii bu fonksiyon 
    aslında kendi içerisinde select ve poll fonksiyonlarını kullanmaktadır. Fonksiyonun prototipi şöyledir:

    #include <gpiod.h>

    int gpiod_line_event_wait(struct gpiod_line *line, const struct timespec *timeout);

    Fonksiyonun birinci parametresi gpiod_line nesnesinin adresini, ikinci parametresi zaman aşımı değerini almaktadır. 
    Zaman aşımı POSIX'in timespec yapısıyla belirtilmektedir:

    #include <time.h>

    struct timespec {
        time_t      tv_sec;                 /* Seconds */
        long        tv_nsec;                /* Nanoseconds [0, 999'999'999] */
    };

    Zaman aşımı parametresi NULL geçilirse zaman aşımı uygulanmaz. Fonksiyon zaman aşımı oluşursa 0 değerine, kesme olayı 
    gerçekleşirse 1 değerine ve başarısızlık durumunda -1 değerine geri dönmektedir. İlgili olay gerçekleştikten sonra 
    olayın gerçekleştiği hattın gpiod_line_event_read fonksiyonuyla okunması gerekmektedir. Aksi takdirde fonksiyon sonraki 
    seferde bekleme yapmayacaktır. gpiod_line_event_read fonksiyonunun prototipi şöyledir:

    #include <gpiod.h> 

    int gpiod_line_event_read(struct gpiod_line *line, struct gpiod_line_event *event);

    Fonksiyonun birinci parametresi gpiod_line nesnesinin adresini, ikinci parametresi gpiod_line_event isimli bir yapı 
    nesnesinin adresini almaktadır. Fonksiyon olayla ilgili bazı bilgileri bu nesneye yazmaktadır. Yapı şöyle bildirilmiştir:

    struct gpiod_line_event {
        struct timespec ts;   /* Timestamp (CLOCK_REALTIME) */
        int event_type;       /* GPIOD_LINE_EVENT_RISING_EDGE veya GPIOD_LINE_EVENT_FALLING_EDGE */
    };

    Burada yapının ts elemanı olayın oluş zamanını, event_type elemanı olayın türünü belirtmektedir. Bu eleman şunlardan 
    biri olabilir:

    GPIOD_LINE_EVENT_RISING_EDGE
    GPIOD_LINE_EVENT_FALLING_EDGE

    Tabii biz bu yapı içerisindeki bilgileri hiç kullanmayabiliriz. Ancak bu ikinci parametre NULL geçilememektedir. 
    Örneğin:

    struct gpiod_chip *chip;
    struct gpiod_line *line;
    struct gpiod_line_event event;
        
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 19)) == NULL)
        exit_sys("gpiod_chip_get_line");
    
    if (gpiod_line_request_falling_edge_events(line, "myapp") == -1)
        exit_sys("gpiod_line_request_falling_edge_events");

    for (int i = 0; i < 10; ++i) {
        if (gpiod_line_event_wait(line, NULL) == -1)
            exit_sys("gpiod_line_event_wait");

        if (gpiod_line_event_read(line, &event) == -1)
            exit_sys("gpiod_line_get_value");
        
        printf("interrupt occurred...\n");
    }

    gpiod_line_release(line);
    gpiod_chip_close(chip);

    Aşağıda örnek bir bütün olarak verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* gpiod-sample.c */

#include <stdio.h>
#include <unistd.h>
#include <gpiod.h>

void exit_sys(const char *msg);

int main(void)
{
    struct gpiod_chip *chip;
    struct gpiod_line *line;
    struct gpiod_line_event event;
        
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 19)) == NULL)
        exit_sys("gpiod_chip_get_line");
    
    if (gpiod_line_request_falling_edge_events(line, "myapp") == -1)
        exit_sys("gpiod_line_request_falling_edge_events");

    for (int i = 0; i < 10; ++i) {
        if (gpiod_line_event_wait(line, NULL) == -1)
            exit_sys("gpiod_line_event_wait");

        if (gpiod_line_event_read(line, &event) == -1)
            exit_sys("gpiod_line_get_value");
        
        printf("interrupt occurred...\n");
    }

    gpiod_line_release(line);
    gpiod_chip_close(chip);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    gpiod kütüphanesi burada açıkladığımız fonksiyonlardan daha fazla fonksiyona sahiptir. Bunun için kütüphanenin orijinal
    dokümanlarına başvurabilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    gpiod kütüphanesinin aslında "/dev/gpiochipN" (buradaki N bir chip numarasını belirten bir sayıdır) aygıt sürücülerine 
    ioctl komutları göndererek yazıldığını belirtmiştik. Biz de aslında bu aygıt sürücüyü open fonksiyonuyla açıp ona 
    ioctl komutları göndererek de işlemlerimizi yapabiliriz. Tabii bunun için bu aygıt sürücünün dokümantasyonuna erişmemiz
    gerekir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                        135. Ders 16/10/2025 - Perşembe
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi biz çok ayrıntısına girmeden "/dev/gpiochipN" aygıt sürücülerinin nasıl kullanıldığını temel düzeyde açıklayalım. 
    BBB'de toplam GPIO aygıt sürücüsüne ilişkin dört aygıt dosyası bulunmaktadır:

    $ ls -l gpio*
    crw-rw---- 1 root gpio 254, 0 Feb  4 22:05 gpiochip0
    crw-rw---- 1 root gpio 254, 1 Feb  4 22:05 gpiochip1
    crw-rw---- 1 root gpio 254, 2 Feb  4 22:05 gpiochip2
    crw-rw---- 1 root gpio 254, 3 Feb  4 22:05 gpiochip3

    Görüldüğü gibi aygıt dosyalarının majör numaralarının aynıdır. Her bir minör numara bir GPIO denetleyicisini temsil 
    etmektedir. 

    GPIO aygıt sürücülerinin iki versiyonu çıkmıştır. Aygıt sürücünün 1 numaralı versiyonlarıyla 2 numaralı versiyonları 
    arasında uyumsuzluklar bulunmaktadır. Biz burada 1 numaralı versiyona ilişkin örnekler vereceğiz. 

    GPIO aygıt sürücücünün kullandığı bütün yapıların bildirimleri, sembolik sabit tanımlamaları <linux/gpio.h> dosyası 
    içerisindedir. Dolayısıyla bu dosya include etmelisiniz. 

    Bizim ilk yapacağımız şey ilgilendiğimiz aygıt dosyasını open POSIX fonksiyonuyla açıp bir dosya betimleyicisi elde 
    etmektedir:

    int fd;

    if ((fd = open("/dev/gpiochip1", O_RDWR)) == -1)
        exit_sys("open");

    GPIO chip'inin ismi ve hat sayısı aygıt sürücüye GPIO_GET_CHIPINFO_IOCTL ioctl komutu gönderilerek elde edilebilmektedir. 
    Aygıt sürücü chip'e ilişkin bilgileri adresini aldığı gpiochip_info isimli bir yapı nesnesinin içine yerleştirmektedir. 
    Bu yapı şöyle bildirilmiştir:

    struct gpiochip_info {
        char name[32];
        char label[32];
        __u32 lines;
    };

    Örneğin:

    int fd;
    struct gpiochip_info info;

    if ((fd = open("/dev/gpiochip1", O_RDWR)) == -1)
        exit_sys("open");

    if (ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, &info) == -1)
        exit_sys("ioctl");

    printf("Name: %s, Number of lines: %u\n", info.name, info.lines);

    Tıpkı gpiod kütüphanesinde olduğu gibi belli bir hat üzerinde işlem yapmadan önce o hattı elde etmek gerekir. OUT için 
    hat talep etme işlemi GPIO_GET_LINEHANDLE_IOCTL ioctl komutuyla yapılmaktadır. Bunun için gpiohandle_request yapısı 
    türünden bir nesne tanımlanır. Bu yapının içi memset fonksiyonuyla sıfırlanır. Sonra gpiohandle_request yapısının 
    lineoffsets elemanına OUT olarak konfigüre edeceğimiz hatların numaralarını yerleştiririz Yani örneğin bir 3 farklı hattı
    OUT olarak konfigüre edeceksek bu hat numaralarını lineoffsets[0], lineoffsets[1] ve lineoffsets[2] elemanlarına yerleştiririz. 
    Dizinin kaç elemanına yerleştirme yapmışsak yapının lines elemanına o sayı girilmelidir. Ayrıca bu OUT konfigürasyonunda 
    hattaki ilk değeri de yapının default_values dizisi yoluyla verebilmekteyiz. Ayrıca yapının consumer_label elemanına da 
    uygulamaya ilişkin bir isim iliştirilebilir. Aslında buraya kadar yapılan işlemler hattı IN olarak konfigüre etmek için 
    de kullanılmaktadır. Hattı OUT olarak konfigüre edilmesi için yapının flags elemanına GPIOHANDLE_REQUEST_OUTPUT değerinin 
    yerleştirilmesi gerekmektedir. 
    
    Örneğin biz gpiochip1 denetleyicisinin 28 numaralı ucunu OUT olarak aşağıdaki gibi konfigüre edebiliriz:

    int fd;
    struct gpiochip_info info;
    struct gpiohandle_request req;
    

    if ((fd = open("/dev/gpiochip1", O_RDWR)) == -1)
        exit_sys("open");

    if (ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, &info) == -1)
        exit_sys("ioctl");
    printf("Name: %s, Number of lines: %u\n", info.name, info.lines);

    memset(&req, 0, sizeof(req));
    req.lineoffsets[0] = 28;
    req.default_values[0] = 1;
    req.lines = 1;
    strcpy(req.consumer_label, "myapp");
    req.flags = GPIOHANDLE_REQUEST_OUTPUT;

    if (ioctl(fd, GPIO_GET_LINEHANDLE_IOCTL, &req) == -1)
        exit_sys("ioctl");

    OUT olarak konfigüre ettiğimiz hattı lojik 0 ve lojik 1 seviyesine çekmek için GPIOHANDLE_SET_LINE_VALUES_IOCTL ioctl komutu 
    gönderilmelidir. Burada bizim OUT olarak konfigüre ettiğimiz hatların işaretlerini gpiohandle_data isimli bir yapının values 
    dizisine kodlamamız gerekir. Ancak GPIOHANDLE_SET_LINE_VALUES_IOCTL komutunu artık yukarıdaki hat alma işlemi sonucunda 
    bize verilen gpiohandle_request yapısının fd elemanına ilişkin betimleyiciyi kullanarak uygulamamız gerekir. Bu ioctl komutunun 
    üçüncü parametresine gpiohandle_data yapı nesnesini adresi girilmelidir. Örneğin yukarıda OUT biçiminde konfigüre ettiğimiz hattı 
    şöyle 0'a çekebiliriz:

    int fd;
    struct gpiochip_info info;
    struct gpiohandle_request req;
    struct gpiohandle_data data;

    if ((fd = open("/dev/gpiochip1", O_RDWR)) == -1)
        exit_sys("open");

    if (ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, &info) == -1)
        exit_sys("ioctl");
    printf("Name: %s, Number of lines: %u\n", info.name, info.lines);

    memset(&req, 0, sizeof(req));
    req.lineoffsets[0] = 28;
    req.default_values[0] = 1;
    req.lines = 1;
    strcpy(req.consumer_label, "myapp");
    req.flags = GPIOHANDLE_REQUEST_OUTPUT;

    if (ioctl(fd, GPIO_GET_LINEHANDLE_IOCTL, &req) == -1)
        exit_sys("ioctl");

    sleep(5);

    data.values[0] = 0;
    if (ioctl(req.fd, GPIOHANDLE_SET_LINE_VALUES_IOCTL, &data) == -1)
        exit_sys("ioctl");

    Elde etmiş olduğumuz hatları geri bırakmak için tek yapılacak şey gpiohandle_request yapısının fd elemanı ile verilen 
    betimleyiciyi close etmektir. Yani programımızın sonunda iki betimleyiciyi de aşağıdaki gibi close etmeliyiz:

    close(req.fd);
    close(fd);

    Aşağıdaki örnekte 10 kez LED yakılıp söndürülmüştür.
---------------------------------------------------------------------------------------------------------------------------*/
<BURADA KALDIM>
/* gpio-driver-ioctl.c */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/gpio.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    struct gpiochip_info info;
    struct gpiohandle_request req;
    struct gpiohandle_data data;

    if ((fd = open("/dev/gpiochip1", O_RDWR)) == -1)
        exit_sys("open");

    if (ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, &info) == -1)
        exit_sys("ioctl");
    printf("Name: %s, Number of lines: %u\n", info.name, info.lines);

    memset(&req, 0, sizeof(req));
    req.lineoffsets[0] = 28;
    req.default_values[0] = 1;
    req.lines = 1;
    strcpy(req.consumer_label, "myapp");
    req.flags = GPIOHANDLE_REQUEST_OUTPUT;

    if (ioctl(fd, GPIO_GET_LINEHANDLE_IOCTL, &req) == -1)
        exit_sys("ioctl");

    for (int i = 0; i < 10; ++i) {
        data.values[0] = 0;
        if (ioctl(req.fd, GPIOHANDLE_SET_LINE_VALUES_IOCTL, &data) == -1)
            exit_sys("ioctl");
        sleep(1);
        data.values[0] = 1;
        if (ioctl(req.fd, GPIOHANDLE_SET_LINE_VALUES_IOCTL, &data) == -1)
            exit_sys("ioctl");
        sleep(1);
    }

    close(req.fd);
    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Hattan okuma yapmak da benzer biçimdedir. Önce hat talep edilir. Ancak talep edilirken gpiohandle_request yapısının flags 
    elemanı GPIOHANDLE_REQUEST_INPUT girilmelidir. Örneğin:

    int fd;
    struct gpiochip_info info;
    struct gpiohandle_request req;
    struct gpiohandle_data data;

    if ((fd = open("/dev/gpiochip1", O_RDWR)) == -1)
        exit_sys("open");

    if (ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, &info) == -1)
        exit_sys("ioctl");
    printf("Name: %s, Number of lines: %u\n", info.name, info.lines);

    memset(&req, 0, sizeof(req));
    req.lineoffsets[0] = 19;
    req.lines = 1;
    strcpy(req.consumer_label, "myapp");
    req.flags = GPIOHANDLE_REQUEST_INPUT;
    if (ioctl(fd, GPIO_GET_LINEHANDLE_IOCTL, &req) == -1)
        exit_sys("ioctl");

    Bundan sonra GPIOHANDLE_GET_LINE_VALUES_IOCTL ioctl komutu ile hatlardaki değerler okunabilir. Yine bu ioctl komutunda 
    da ioctl fonksiyonun üçüncü parametresine gpiohandle_data isimli yapı türünden bir nsnenin adresi girilmelidir. ioctl 
    uygulandıktan sonra yne bu nesnenin values dizisinde ilgili değer alınmaktadır. Örneğin:

    if (ioctl(req.fd, GPIOHANDLE_SET_LINE_VALUES_IOCTL, &data) == -1)
            exit_sys("ioctl");

    Aşağıdaki örnekte düğmeye basılıp basılmadığı bilgisi bir saniye periyotlarla kontrol edilerek yazdırılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-driver-ioctl.c */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/gpio.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    struct gpiochip_info info;
    struct gpiohandle_request req;
    struct gpiohandle_data data;

    if ((fd = open("/dev/gpiochip1", O_RDWR)) == -1)
        exit_sys("open");

    if (ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, &info) == -1)
        exit_sys("ioctl");
    printf("Name: %s, Number of lines: %u\n", info.name, info.lines);

    memset(&req, 0, sizeof(req));
    req.lineoffsets[0] = 19;
    req.lines = 1;
    strcpy(req.consumer_label, "myapp");
    req.flags = GPIOHANDLE_REQUEST_INPUT;
    if (ioctl(fd, GPIO_GET_LINEHANDLE_IOCTL, &req) == -1)
        exit_sys("ioctl");

    for (int i = 0; i < 10; ++i) {
        if (ioctl(req.fd, GPIOHANDLE_GET_LINE_VALUES_IOCTL, &data) == -1)
            exit_sys("ioctl");

        printf("%d\n", data.values[0]);
        sleep(1);
    }   

    close(req.fd);
    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Kesme işlemi yapmak için önce gpioevent_request isimli bir yapı türünden nesne yaratıp içi sıfırlanır. Yapının lineoffset 
    elemanına kesme için ilgilendiğimiz hattın numarası yerleştirilir. Sonra yapının aşağıdaki bayrak elemanına aşağıdaki 
    değerler verilir:

    event_req.handleflags = GPIOHANDLE_REQUEST_INPUT;
    event_req.eventflags = GPIOEVENT_REQUEST_FALLING_EDGE; 

    Sonra da GPIO_GET_LINEEVENT_IOCTL komutuyla hat kesme içn konfigüre edilir. Buradaki event_req ile temsil edilen yapı 
    nesnesinin adresi ioctl fonksiyonunun üçüncü parametresine geçirilmeliir. Bu ioctl komutu herhangi bir bloke oluşturmaz. 
    Kesmeyi beklemek için bu yapının fd elemanı ile verilen betimleyiciden read fonksiyonu ile okuma yapmak gerekir. Okuma 
    işlemi kesme oluşana kadar thread'i bloke bekletecektir. Örneğin:

    int fd;
    struct gpioevent_request event_req;
    struct gpioevent_data event;

    if ((fd = open("/dev/gpiochip1", O_RDWR)) == -1)
        exit_sys("open");

    memset(&event_req, 0, sizeof(event_req));
    event_req.lineoffset = 19;
    event_req.handleflags = GPIOHANDLE_REQUEST_INPUT;
    event_req.eventflags = GPIOEVENT_REQUEST_FALLING_EDGE; 

    strcpy(event_req.consumer_label, "myapp");
    if (ioctl(fd, GPIO_GET_LINEEVENT_IOCTL, &event_req) == -1)
        exit_sys("ioctl");

    for (int i = 0; i < 10; ++i) {
        if (read(event_req.fd, &event, sizeof(event)) == -1)
            exit_sys("read");
        
        printf("intterupt occured...\n");
    }

    close(event_req.fd);
    close(fd);

    Aşağıda örnek bütünsel biçimde verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-driver-ioctl.c */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/gpio.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    struct gpioevent_request event_req;
    struct gpioevent_data event;

    if ((fd = open("/dev/gpiochip1", O_RDWR)) == -1)
        exit_sys("open");

    memset(&event_req, 0, sizeof(event_req));
    event_req.lineoffset = 19;
    event_req.handleflags = GPIOHANDLE_REQUEST_INPUT;
    event_req.eventflags = GPIOEVENT_REQUEST_FALLING_EDGE; 

    strcpy(event_req.consumer_label, "myapp");
    if (ioctl(fd, GPIO_GET_LINEEVENT_IOCTL, &event_req) == -1)
        exit_sys("ioctl");

    for (int i = 0; i < 10; ++i) {
        if (read(event_req.fd, &event, sizeof(event)) == -1)
            exit_sys("read");
        
        printf("intterupt occured...\n");
    }

    close(event_req.fd);
    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                136. Ders 21/10/2025 - Salı 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de BBB içerisindeki GPIO denetleyicisine bellek tabanlı (memory-mapped) IO tekniği ile erişip doğrudan bu denetleyiciyi 
    programlayarak GPIO işlemlerini yapalım. Anımsanacağı gibi ARM mimarisinde zaten prt tabanlı (port-mapped) IO kullanılmıyordu. 
    Tüm denetleyicilerle adres ve veri yolu kullanılarak bellek erişim komutlarıyla haberleşme sağlanıyordu. Bu da bizim doğrudan 
    C'deki göstericilerle denetleyicinin yazmaçlarına erişebileceğimiz anlamına geliyordu. Bellek tabanlı IO işlemi yaparken 
    şunlara dikkat edilmesi gerektiğini anımsayınız:
    
    - Bellek tabanlı IO işlemeri için hangi fiziksel bellek adresinin denetleyicinin hangi yazmacına karşılık geldiğinin bilinmesi 
    gerekmektedir. Başka bir deyişle denetleyicinin hangi adresine hangi komut gönderildiğinde denetleyicinin ne yaptığının 
    baştan bilinmesi gerekmektedir. 

    - Denetleyicilereki bellek adresleri fiziksel adreslerdir. Programcının bu fiziksel adresler için sanal adresleri oluşturması
    gerekmektedir. 

    - Derleyiciler ve işlemciler birbirlerinden bağımsız komutların sırasını değiştirbiliyordu (instuction reordering). Bellek 
    tabanlı IO işlemlerinde bu durumun dikkate alınması gerekir. Bunun bellek bariyerleri (memory barriers) denilen mekanizmanın 
    kullanıldığını anımsayınız. 

    - Aynı bellek bölgesine farklı çekirdekler tarafından aynı anda yazma yapılırken ya da aynı bellek bölgesine bir çkirdek
    yazma yaparken aynı anda oradan başka bir çekirdek okuma yaparken bazı platformlarda bazı koşullarda bazulmalar olabileceğini 
    belirtmiştik. Bu nedenle okuma ve yazma işlemlerinin bu durum gözetilerek atomikbir biçimde yapılması tavsiye edilmektedir. 
    (Anımsanacağı gibi aygıt sürücüler konusunda görmüş olduğumuz ioreadxxx ve iowritexxx fonksiyonları bellek bariyerlerini 
    ve atomikliği kendi içlerinde oluşturmaktadır. Bu nedenle aygıt sürücüler içerisinde bu fonksiyonların kullanılması tavsiye 
    edilmektedir.)
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    BBB'de toplam dört adet GPIO denetleyicisi bulunduğunu anımsayınız. Bunların taban fiziksel adresleri şöyledir:

    #define GPIO_CHIP0_BASE  0x44E07000
    #define GPIO_CHIP1_BASE  0x4804C000
    #define GPIO_CHIP2_BASE  0x481AC000
    #define GPIO_CHIP3_BASE  0x481AE000

    Bu taban adreslerden itibaren her DWORD (4 byte) farklı bir anlama gelmektedir. Bunlara GPIO denetleyicisinin yazmaçları 
    diyebiliriz. Bizi ilgilendiren önemli yazmaçlar ve bunlar offste numaraları şöyledir:

    Yazmacın Sembolik İsimli                Offset Değeri

    #define GPIO_OE                             0x134
    #define GPIO_DATAIN                         0x138
    #define GPIO_DATAOUT                        0x13C
    #define GPIO_CLEARDATAOUT                   0x190
    #define GPIO_SETDATAOUT                     0x194

    BBB'deki diğer GPIO yazmaçları ve genel olarak GPIO denetleyicisi hakkında ayrıntılı açıklama için "AM335x and AMIC110 Sitara™ 
    Processors Technical Reference Manual" dokümanlarına başvurabilirsiniz. Aşağıdaki örneklerde gpio_base göstericisinin denetleyiciye 
    ilişkin taban sanal adresi gösterdiği varsayılacaktır. 

   -  GPIO_OE pinlerini (aslında denetleyicinin uçlarını) IN ya da OUT biçimide konfigüre etmek için kullanılmaktadır. Bu offset'ten 
   başlayan 4 byte'lık DWORD bilgi ger denetleyici ucunun konumunu bit bit temsil etmektedir. İlgili bit 0 yapıldığında o uç OUT 
   durumuna 1 yapıldığında IN durumuna konfigüre edilmektedir. O halde "pin" denetleyicinin uç numarasını belirtmek üzere o ucu 
   OUT olarak konfügüre etmek için şu işlem yapılmalıdır:

    volatile uint32_t *gpio_reg = (uint32_t *) (gpio_base + GPIO_OE);
    *gpio_reg &= ~(1 << pin);

    IN olarak konfigüre etme işlemi de şöyle yapılabilir:

    volatile uint32_t *gpio_reg = (uint32_t *) (gpio_base + GPIO_OE);
    *gpio_reg |= 1 << pin;
 
    - GPIO_DATAIN ile temsil edilen offset'teki 4 byte'lık DWORD değer denetleyicinin uçlarını tek hamlede okumak için kullanılmaktadır. 
    Tabii eğer biz "pin" numaralı ucun durumunu elde etmek istiyorsak şöyle yapmalıyız:

    volatile uint32_t *gpio_reg = (uint32_t *) (gpio_base + GPIO_DATAIN);
    result = *gpio_reg >> pin & 1;

    - GPIO_DATAOUT ile temsil edilen offset'teki 4 byte'lık DWORD değer denetleyicinin uçlarını lojik 0 ya da 1 çekmek için kullanılmaktadır. 
    Burada her bit bir ucu temsil etmektedir. Örneğin "pin" numaralı ucu diğer uçlardaki değerleri değiştirmeden şöyle 1 yapabiliriz:

    volatile uint32_t *gpio_reg = (uint32_t *) (gpio_base + GPIO_DATAOUT);
    *gpio_reg |= 1 << pin;

    Diğer uçlara dokunmadan ilgili uç şöyle 0'a çekilebilir:

    volatile uint32_t *gpio_reg = (uint32_t *) (gpio_base + GPIO_DATAOUT);
    *gpio_reg &= ~(1 << pin);

    - GPIO_CLEARDATAOUT ve GPIO_SETDATAOUT yazmaçları bit düzeyinde işlemleri elimine etmek için düşünülmüştür. Bu yazmaçlardaki 
    0 olan bitleer dikkate alınmaz. Yalnıca 1 olan bitler üzerinde işlem yapılmaktadır. GPIO_CLEARDATAOUT yalnızca 1 olan bitleri
    lojik 0 seviyesine, GPIO_SETDATAOUT ise yaşnızca 1 olan bitleri lojik 1 seviyesine çekmektedir. Örneğin biz "pin" numaralı 
    ucu lojik 1 seviyesine şöyle de çekebiliriz:

    volatile uint32_t *gpio_reg = (uint32_t *) (gpio_base + GPIO_SETDATAOUT);
    *gpio_reg = 1 << pin;
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de bellek tabanlı IO tekniğini kullanıcı modunda mmap fonksiyonuyla uygulayalım. Tabii aslında bu işlemler için 
    karakter aygıt sürücülerinin yazılması ve işlemlerin çekirdek modunda gerçekleştirilmesi tavsiye edilmektedir. 

    Kullanıcı modunda bellek tabanlı IO işlemleri için "/dev/mem" aygıt sürücüsü ve mmap POSIX fonksiyonu kullanılmaktadır. 
    mmap fonksiyonu "bellek tabanlı dosya (mempry-mapped file)" oluşturmak için kullanılabilmektedir. Bellek tabanlı dosyalar 
    sayesinde sanki bir dosya bellekteymiş de bellekte oraya yazma yapıldığında yazma doğrudan doğrudan dosyaya yapılıyormuş 
    gibi bir etki oluşturulmaktadır. "/dev/mem" aygıt sürücüsü fiziksel RAM'i sanki bir dosyaymış gibi göstermektedir. Örneğin
    biz bu dosyayı open fonksiyonu ile açıp dosya göstericisini belli bir offset'e konumlandırıp oraya yazma yaparsak fiziksel 
    RAM'e yazma yapımış oluruz. O halde "/dev/mem" dosyasını mmap ile belleğe çekerek bellekte yapacağımız yazma işlemi aslında 
    "/dev/mem" dosyasına yapılacaktır. Dolayısıyla biz fiziksel RAM'i kendi prosesimizin sanal adresl alanında bir yere çekip 
    onun üzerinde çalışabiliriz. mmap fonksiyonunun pek çok ayrıntısı vardır. Bu fonksiyonun çalışması "UNIX/Linux Sistem 
    Programlama" kurslarında ele alınmaktadır. mmap ile belleğe çekilen dosya munmap fonksiyonuyla boşaltılmaktadır. 
    Fonksiyonların prototipleri şöyledir:

    #include <sys/mman.h>

    void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t off);
    int munmap(void *addr, size_t len);

    mmap fonksiyonunun birinci parametresi programcınn arzu ettiği sanal bellek adresini belirtmektedir. Genellikle bu 
    parametre NULL geçilmektedir. Bu durumda map işlemi için uygun sanal adres fonksiyon tarafından tespit edilir. Fonksiyonun 
    ikinci parametresi mapping uzunluğunu belirtmektedir. Üçüncü parametre map edilen sayfaların koruma bilgilerini belirtiri. 
    Bu parametre için PROT_READ|PROT_WRITE değerini argüman olarak geçebilirsiniz. Dördüncü parametre tipik olarak MAP_SHARED
    biçiminde geçilmektedir. MAP_PRIVATE "copy-on-write" mekanizması için kullanılmaktadır. Fonksiyonun fd ile belirtilen 
    beşinci parametresi map edilecek dosyaya ilişkin dosya betimleyicisini belirtmektedir. Son parametre ise dosyanın hangi 
    offset'inden itibaren mapping yapılacağını belirtmektedir. Yani dosyanın belli bir offset'indne itibaren belli bir uzunluk 
    map edilebilmektedir. munmap fonksiyonun ise birinci parametresi mmap fonksiyonundan elde edilen adresi, ikinci parametresi 
    de unmap yapılacak uzunluğu belirtir. mmap fonksiyonu başarı durumunda map edilen dosyanın sanal bellek adresine, başarısızlık 
    durumunda ise MAP_FAILED özel değerine geri dönmektedir. munmap fonksiyonu ise başarı durumunda 0 değerine, başarısızlık 
    durumunda  -1 değerine geri dönmektedir. 

    mmap ve maunmap fonksiyonları sayfa tabanlı çalışmaktadır. Dolayısıyla bu fonksiyonlardaki uzunluk değerleri tipik 
    olarak 4096'nın katları olmalıdır. Bu fonksiyonlara uzun oolarak eğer sayfa katlarını vermezseniz, fonksiyonlar bunu 
    sayfa katlarına çekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    BBB'nin GPIO denetleyicileri için mapping işlemi tipik olarak şöyle yapılmaktadır:

    int fd;
    volatile uint8_t *gpio_base;

    if ((fd = open("/dev/mem", O_RDWR|O_SYNC)) == -1) 
       exit_sys("open");
        
    if ((gpio_base = (volatile uint8_t *)mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, GPIO_CHIP1_BASE)) == MAP_FAILED) 
        exit_sys("mmap");

    /* .... */

    munmap((void *)gpio_base, 4096);
    close(fd);

    Bu işlemi yaptıktan sonra atık GPIO denetleyicisinin yazmaçlarına bir gösterici yoluyla erişebilir hale gelmiş oluruz. 
    Bu durumda örneğin GPIO1_28 pinine bağladığımız LED'i 1 saniye arayla yakıp söndürme işlemi şöyle yapılabilir:

    gpio_reg = (uint32_t *) (gpio_base + GPIO_OE);
    clear_bit(gpio_reg, 28);
    gpio_reg = (uint32_t *) (gpio_base + GPIO_DATAOUT);

    for (int i = 0; i < 10; ++i) {
        set_bit(gpio_reg, 28);
        sleep(1);
        clear_bit(gpio_reg, 28)   ;
        sleep(1);
    }

    Buradaki clear_bit ve set_bit fonksiyonları uint32_t türünden bir değerin belli bir bitini diğer bitlerine dokunmadan 0 
    ve 1 yapmaktadır. Kodd önce ilgili pin OUT olarak konfigüe edilmiştir:

    gpio_reg = (uint32_t *) (gpio_base + GPIO_OE);
    clear_bit(gpio_reg, 28);

    Sonra ilgili pin 1'er saniye aralıklarla yakılıp södürülmüştür:

    gpio_reg = (uint32_t *) (gpio_base + GPIO_DATAOUT);

    for (int i = 0; i < 10; ++i) {
        set_bit(gpio_reg, 28);
        sleep(1);
        clear_bit(gpio_reg, 28);
        sleep(1);
    }

    Her okuma ve yazma işleminden sonra bellek bariyerlerini kullanmayı unutmayınız. Bu bariyerler hem derleyicinin hem de 
    işlemcinin komutları yeniden sıralamasını engelleyecektir. Ancak aygıt sürücü konusunda gördüğümüz bariyer fonksiyonlarını
    kullanıcı modunda doğrudan kullanamayız. Bu nedenle bu fonksiyonları gcc'nin eklentilerini kullanarak yenidne yazdık:

    #ifdef __arm__
        #define dmb()  __asm__ __volatile__ ("dmb" : : : "memory")
        #define rmb()  __asm__ __volatile__ ("dmb" : : : "memory")          
        #define wmb()  __asm__ __volatile__ ("dmb st" : : : "memory")  
    #elif defined(__aarch64__)
        #define dmb()  __asm__ __volatile__ ("dmb sy" : : : "memory")
        #define rmb()  __asm__ __volatile__ ("dmb ld" : : : "memory")
        #define wmb()  __asm__ __volatile__ ("dmb st" : : : "memory")
    #else
        #define dmb()  __sync_synchronize()
        #define rmb()  __sync_synchronize()
        #define wmb()  __sync_synchronize()
    #endif

    Program bir bütün olarak aşağıda verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-mmap.c */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>   

#define GPIO_CHIP0_BASE  0x44E07000
#define GPIO_CHIP1_BASE  0x4804C000
#define GPIO_CHIP2_BASE  0x481AC000
#define GPIO_CHIP3_BASE  0x481AE000

#define GPIO_OE                             0x134
#define GPIO_DATAIN                         0x138
#define GPIO_DATAOUT                        0x13C
#define GPIO_CLEARDATAOUT                   0x190
#define GPIO_SETDATAOUT                     0x194

#ifdef __arm__
    #define dmb()  __asm__ __volatile__ ("dmb" : : : "memory")
    #define rmb()  __asm__ __volatile__ ("dmb" : : : "memory")          
    #define wmb()  __asm__ __volatile__ ("dmb st" : : : "memory")  
#elif defined(__aarch64__)
    #define dmb()  __asm__ __volatile__ ("dmb sy" : : : "memory")
    #define rmb()  __asm__ __volatile__ ("dmb ld" : : : "memory")
    #define wmb()  __asm__ __volatile__ ("dmb st" : : : "memory")
#else
    #define dmb()  __sync_synchronize()
    #define rmb()  __sync_synchronize()
    #define wmb()  __sync_synchronize()
#endif

void exit_sys(const char *msg);

static inline void set_bit(volatile uint32_t *gpio_reg, int offset)
{
    *gpio_reg |= 1 << offset;  
    wmb();
}

static inline void clear_bit(volatile uint32_t *gpio_reg, int offset)
{
    *gpio_reg &= ~(1 << offset);
    wmb();
}

int main(void)
{
    int fd;
    volatile uint8_t *gpio_base;
    volatile uint32_t *gpio_reg;

    if ((fd = open("/dev/mem", O_RDWR|O_SYNC)) == -1) 
       exit_sys("open");
        
    if ((gpio_base = (volatile uint8_t *)mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, GPIO_CHIP1_BASE)) == MAP_FAILED) 
        exit_sys("mmap");

    gpio_reg = (uint32_t *) (gpio_base + GPIO_OE);
    clear_bit(gpio_reg, 28);
    gpio_reg = (uint32_t *) (gpio_base + GPIO_DATAOUT);

        for (int i = 0; i < 10; ++i) {
            set_bit(gpio_reg, 28);
            sleep(1);
            clear_bit(gpio_reg, 28)   ;
            sleep(1);
        }

    munmap((void *)gpio_base, 4096);
    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de GPIO denetleyicisinin GPIO_DATAIN yazmacını okuyarak belli bir pinin değerini elde edelim. Bunun için yine 
    aşağıdaki hazırlık işlemleri yapılır:

    if ((fd = open("/dev/mem", O_RDWR|O_SYNC)) == -1) 
       exit_sys("open");
        
    if ((gpio_base = (volatile uint8_t *)mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, GPIO_CHIP1_BASE)) == MAP_FAILED) 
        exit_sys("mmap");

    gpio_reg = (uint32_t *) (gpio_base + GPIO_OE);
    set_bit(gpio_reg, 19);
    gpio_reg = (uint32_t *) (gpio_base + GPIO_DATAIN);

    Pini okumak için read_bit isimli bir fonksiyon yazdık:

    
    static inline int read_bit(const volatile uint32_t *gpio_reg, int offset)
    {
        int first_val, second_val;

        for (int i = 0; i < TRYNUM; ++i) {
            first_val = *gpio_reg >> offset & 1;
            rmb();

            usleep(5000);

            second_val = *gpio_reg >> offset & 1;
            rmb();

            if (first_val == second_val)
                return second_val;
        }

        return second_val;
    }

    Burada "debouncing" sorununu çözmek için iki ardııl okumanın aynı değerde olup olmadığına baktık. Eğer az bir bekleme 
    ile iki okuma aynı değeri veriyorsa bir "debounce" durumu oluşmamıştır. Tüm denemeler sonucunda hala "debounce" oluşmuşsa
    artık yapılacak bir şey olmadığı için son değerle geri döndük.

    Programın tüm kodları aşağıda verilmiştir:
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-mmap-read.c */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>   

#define GPIO_CHIP0_BASE  0x44E07000
#define GPIO_CHIP1_BASE  0x4804C000
#define GPIO_CHIP2_BASE  0x481AC000
#define GPIO_CHIP3_BASE  0x481AE000

#define GPIO_OE                             0x134
#define GPIO_DATAIN                         0x138
#define GPIO_DATAOUT                        0x13C
#define GPIO_CLEARDATAOUT                   0x190
#define GPIO_SETDATAOUT                     0x194

#define TRYNUM                              10

#ifdef __arm__
    #define dmb()  __asm__ __volatile__ ("dmb" : : : "memory")
    #define rmb()  __asm__ __volatile__ ("dmb" : : : "memory")          
    #define wmb()  __asm__ __volatile__ ("dmb st" : : : "memory")  
#elif defined(__aarch64__)
    #define dmb()  __asm__ __volatile__ ("dmb sy" : : : "memory")
    #define rmb()  __asm__ __volatile__ ("dmb ld" : : : "memory")
    #define wmb()  __asm__ __volatile__ ("dmb st" : : : "memory")
#else
    #define dmb()  __sync_synchronize()
    #define rmb()  __sync_synchronize()
    #define wmb()  __sync_synchronize()
#endif

void exit_sys(const char *msg);

static inline void set_bit(volatile uint32_t *gpio_reg, int offset)
{
    *gpio_reg |= 1 << offset;  
    wmb();
}

static inline void clear_bit(volatile uint32_t *gpio_reg, int offset)
{
    *gpio_reg &= ~(1 << offset);
    wmb();
}

static inline int read_bit(const volatile uint32_t *gpio_reg, int offset)
{
    int first_val, second_val;

    for (int i = 0; i < TRYNUM; ++i) {
        first_val = *gpio_reg >> offset & 1;
        rmb();

        usleep(5000);

        second_val = *gpio_reg >> offset & 1;
        rmb();

        if (first_val == second_val)
            return second_val;
    }

    return second_val;
}

int main(void)
{
    int fd;
    volatile uint8_t *gpio_base;
    volatile uint32_t *gpio_reg;
    int bitval;

    if ((fd = open("/dev/mem", O_RDWR|O_SYNC)) == -1) 
       exit_sys("open");
        
    if ((gpio_base = (volatile uint8_t *)mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, GPIO_CHIP1_BASE)) == MAP_FAILED) 
        exit_sys("mmap");

    gpio_reg = (uint32_t *) (gpio_base + GPIO_OE);
    set_bit(gpio_reg, 19);
    gpio_reg = (uint32_t *) (gpio_base + GPIO_DATAIN);

    for (int i = 0; i < 10; ++i) {
        bitval = read_bit(gpio_reg, 19);
        printf("%d\n", bitval);
        sleep(1);
    }

    munmap((void *)gpio_base, 4096);
    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                    138. Ders 30/10/2025 - Perşembe
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de bellek tabanlı IO ile GPIO denetleyicisine erişerek okuma yazma yapan bir karakter aygıt sürücüsü yazalım. 
    Aygıt sürücümüzün init fonksiyonunda GPIO denetleyicilerinin fiziksel adresleri sanal adreslere dönüştürülmüşütür:

    for (i = 0; i < NGPIO_CHIPS; ++i) {
        g_gpio_base_addrs[i] = ioremap(gpio_physical_addrs[i], 4096);
        if (g_gpio_base_addrs[i] == NULL) {
            for (k = 0; k < i; ++k)
                iounmap(g_gpio_base_addrs[k]);
            return -ENOMEM;
        }
    }

    Buradaki gpio_physical_addrs denetleyicilerin taban adreslerini belirtmektedir. Bu taban adresler zaten üretici firma 
    tarafından verilmektedir:

    #define GPIO_CHIP0_BASE         0x44E07000
    #define GPIO_CHIP1_BASE         0x4804C000
    #define GPIO_CHIP2_BASE         0x481AC000
    #define GPIO_CHIP3_BASE         0x481AE000

    unsigned long gpio_physical_addrs[NGPIO_CHIPS] = {
        GPIO_CHIP0_BASE, 
        GPIO_CHIP1_BASE, 
        GPIO_CHIP2_BASE, 
        GPIO_CHIP3_BASE
    };

    Aygıt sürücümüzün read ve write fonksiyonlarında GPIO aygıt sürücü pin numaralarını chip numarakarına ve chip'teki 
    pin numaralarına dönüştürdük:

    chip = *off / PINS_PER_CHIP;
    pin = *off % PINS_PER_CHIP;

    Burada PINS_PER_CHIP sembolik sabiti 32 değerindedir. Okuma ve yazma işlemlerinde önce ilgili pin IN ya da OUT olarak 
    konfigüre edilmiş sonra okuma ve yazma yapılmıştır:

    static ssize_t gpio_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        int chip, pin, bitval;
        uint32_t *gpio_reg;

        if (size != 1)
            return -EINVAL;

        chip = *off / PINS_PER_CHIP;
        pin = *off % PINS_PER_CHIP;

        gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
        iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);
        gpio_reg = (uint32_t *) (g_gpio_base_addrs[chip] + GPIO_DATAIN);
        bitval = read_bit(gpio_reg, pin);

        if (copy_to_user(buf, &"01"[bitval] , size) != 0)
            return -EFAULT;

        /* put_user("01"[bitval], buf); */

        return size;
    }

    static ssize_t gpio_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        int chip, pin;
        uint32_t *gpio_reg;
        char ch;

        if (size != 1) 
            return -EINVAL;

        chip = *off / PINS_PER_CHIP;
        pin = *off % PINS_PER_CHIP;

        gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
        iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
        gpio_reg = (uint32_t *) (g_gpio_base_addrs[chip] + GPIO_DATAOUT);
        if (copy_from_user(&ch, buf, size) != 0)
            return -EFAULT;
        if (ch == '0')
            iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
        else if (ch == '1')
            iowrite32(ioread32(gpio_reg) | (1 << pin), gpio_reg);
        else 
            return -EINVAL;

        return size;
    }

    Okuma yazma işlemleri karakter düzeyinde yani '0' ve '1' biçiminde yapılmaktadır. Okuma yazma işlemlerinin dosya göstericisinin
    gösterdiği offset'e ilişkin pin numarsından yapıldığına dikkat ediniz. Ancak okuma yazma sonrasında aygıt sürücümüzün 
    read ve write fonksiyonları dosya göstericisinin konumunu değiştirmemektedir. Tabii bizim lseek işleminde offset'i de aygıt 
    sürücümüz içerisinde konumlandırmamız gerekmektedir:

    static loff_t gpio_llseek(struct file *filp, loff_t off, int whence)
    {
        loff_t newpos;

        switch (whence) {
            case 0:
                newpos = off;
                break;
            case 1:
                newpos = filp->f_pos + off;
                break;
            case 2:
                newpos = (4 * PINS_PER_CHIP) + off;
                break;
            default:
                return -EINVAL;
        }
        if (newpos < 0 || newpos >= 128)
            return -EINVAL;

        filp->f_pos = newpos;

        return newpos;
    }

    Aygıt sürücümüzde herhangi bir ioctl komutunu bulundurmadık. 
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/delay.h>
#include <asm/io.h>
#include "gpio-driver.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("gpio-driver");

#define GPIO_CHIP0_BASE         0x44E07000
#define GPIO_CHIP1_BASE         0x4804C000
#define GPIO_CHIP2_BASE         0x481AC000
#define GPIO_CHIP3_BASE         0x481AE000

#define NGPIO_CHIPS             4
#define PINS_PER_CHIP           32

#define GPIO_OE                 0x134
#define GPIO_DATAIN             0x138
#define GPIO_DATAOUT            0x13C
#define GPIO_CLEARDATAOUT       0x190
#define GPIO_SETDATAOUT         0x194

#define TRYNUM                  10

static int gpio_open(struct inode *inodep, struct file *filp);
static int gpio_release(struct inode *inodep, struct file *filp);
static ssize_t gpio_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t gpio_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static loff_t gpio_llseek(struct file *filp, loff_t off, int whence);
static long gpio_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static inline int read_bit(const uint32_t *gpio_reg, int offset);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = gpio_open,
	.read = gpio_read,
    .write = gpio_write,
	.llseek = gpio_llseek,
    .release = gpio_release,
    .unlocked_ioctl = gpio_driver_ioctl
};

uint8_t *g_gpio_base_addrs[NGPIO_CHIPS];

static int __init gpio_init(void)
{
	int result;
    int i, k;
    unsigned long gpio_physical_addrs[NGPIO_CHIPS] = {
        GPIO_CHIP0_BASE, 
        GPIO_CHIP1_BASE, 
        GPIO_CHIP2_BASE, 
        GPIO_CHIP3_BASE
    };

	if ((result = alloc_chrdev_region(&g_dev, 0, 1, "gpio-driver")) < 0) {
		printk(KERN_INFO "cannot alloc char driver!...\n");
		return result;
	}
	cdev_init(&g_cdev, &g_fops);
	if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
		unregister_chrdev_region(g_dev, 1);
		printk(KERN_ERR "cannot add device!...\n");
		return result;
	}

    for (i = 0; i < NGPIO_CHIPS; ++i) {
        g_gpio_base_addrs[i] = ioremap(gpio_physical_addrs[i], 4096);
        if (g_gpio_base_addrs[i] == NULL) {
            for (k = 0; k < i; ++k)
                iounmap(g_gpio_base_addrs[k]);
            return -ENOMEM;
        }
    }

    printk(KERN_INFO "gpio-driver module initialization...\n");

	return 0;
}

static void __exit gpio_exit(void)
{
    int i;

    for (i = 0; i < NGPIO_CHIPS; ++i)
        iounmap(g_gpio_base_addrs[i]);
	cdev_del(&g_cdev);
	unregister_chrdev_region(g_dev, 1);
    
	printk(KERN_INFO "gpio-driver module exit...\n");
}

static int gpio_open(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "gpio-driver opened...\n");

	return 0;
}

static int gpio_release(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "gpio-driver closed...\n");

	return 0;
}

static ssize_t gpio_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    int chip, pin, bitval;
    uint32_t *gpio_reg;

    if (size != 1)
        return -EINVAL;

    chip = *off / PINS_PER_CHIP;
    pin = *off % PINS_PER_CHIP;

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
    iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);
    gpio_reg = (uint32_t *) (g_gpio_base_addrs[chip] + GPIO_DATAIN);
    bitval = read_bit(gpio_reg, pin);

    if (copy_to_user(buf, &"01"[bitval] , size) != 0)
        return -EFAULT;

    /* put_user("01"[bitval], buf); */

	return size;
}

static ssize_t gpio_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    int chip, pin;
    uint32_t *gpio_reg;
    char ch;

    if (size != 1) 
        return -EINVAL;

    chip = *off / PINS_PER_CHIP;
    pin = *off % PINS_PER_CHIP;

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
    gpio_reg = (uint32_t *) (g_gpio_base_addrs[chip] + GPIO_DATAOUT);
    if (copy_from_user(&ch, buf, size) != 0)
        return -EFAULT;
    if (ch == '0')
        iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
    else if (ch == '1')
        iowrite32(ioread32(gpio_reg) | (1 << pin), gpio_reg);
    else 
        return -EINVAL;

	return size;
}

static loff_t gpio_llseek(struct file *filp, loff_t off, int whence)
{
    loff_t newpos;

    switch (whence) {
        case 0:
            newpos = off;
            break;
        case 1:
            newpos = filp->f_pos + off;
            break;
        case 2:
            newpos = (4 * PINS_PER_CHIP) + off;
            break;
        default:
            return -EINVAL;
    }
    if (newpos < 0 || newpos >= 128)
        return -EINVAL;

    filp->f_pos = newpos;

    return newpos;
}

static long gpio_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    long result;
 
    switch (cmd) {
        case IOC_GPIO_TEST:
            break;
        default:
            result = -ENOTTY;
    }

    return result;
}

static inline int read_bit(const uint32_t *gpio_reg, int offset)
{
    int i;
    int first_val, second_val;

    for (i = 0; i < TRYNUM; ++i) {
        first_val = ioread32(gpio_reg) >> offset & 1;
        msleep(5);
        second_val = ioread32(gpio_reg) >> offset & 1;
        if (first_val == second_val)
            return second_val;
    }

    return second_val;
}

module_init(gpio_init);
module_exit(gpio_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/* gpio-driver-test-read.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char ch;

    if ((fd = open("gpio-driver", O_RDWR)) == -1) 
        exit_sys("open");
    
    lseek(fd, 51, 0);
    for (int i = 0; i < 10; ++i) {
        if (read(fd, &ch, 1) == -1)
            exit_sys("read");
        printf("%c\n", ch);
        sleep(1);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* gpio-driver-test-write.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char ch;

    if ((fd = open("gpio-driver", O_RDWR)) == -1) 
        exit_sys("open");
    
    lseek(fd, 60, 0);
    for (int i = 0; i < 10; ++i) {
        ch = '1';
        if (write(fd, &ch, 1) == -1)
            exit_sys("write");
        sleep(1);

        ch = '0';
        if (write(fd, &ch, 1) == -1)
            exit_sys("write");
        sleep(1);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de yukarıdaki aygıt sürücümüze kesme özelliği ekleyelim. Anımsanacağı gibi aygıt sürücülerde kesme oluştuğunda 
    belirlenen fonksiyonun çağrılması için request_irq isimli bir çekirdek fonksiyonu kullanılıyordu. İşlem bittiğinde de 
    ele alınan kesme free_irq fonksiyonu ile geri bırkılıyordu. Peki BBB'nin GPIO denetleyicisi hangi IRQ numaralarını 
    kullanmaktadır? İşte BBB'deki dört adet GPII denetleyicisinin kullandığı IRQ numaraları baştan bellidir. Bazı kartlardaki
    IRQ hatları programlama yoluyla değiştirilebilmektedir. Dolayısıyla o kartlarda kartın kullandığı IRQ numaralarını 
    "aygıt ağacı (device tree)" üzeirnden değiştirmek mümkün olabilmektedir. Ancak BBB'deki AM335x SoC'undaki denetleyiciler 
    için bu mümkün değildir. GPIO denetleyicilerinin IRQ numaralarını elde etmek için çekirdek içerisinde gpio_to_irq 
    isimli bir fonksiyon bulundurulmuştur:

    #include <linux/gpio.h>

    static int gpio_to_irq(unsigned gpio);

    Fonksiyon parametre olarak aygıt sürücü formatındaki GPIO numarasını alır, geri dönüş değeri olarak GPIO pini için 
    kullanılan IRQ numarasını verir. Fonksiyon başarısız olursa negatif errno değerine geri dönmektedir. 

    Bu biçimdeki aygıt sürücülerde IRQ'nun set edilmesi bir ioctl koduna yaptırılmalıdır. Örneğin:

    static long gpio_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
    {
        long result;
    
        switch (cmd) {
            case IOC_GPIO_IRQ_SET:
                result = set_gpio_irq(arg);
                break;
            default:
                result = -ENOTTY;
        }

        return result;
    }

    Burada IOC_GPIO_IRQ_SET ioctl komutu oluştuğunda set_gpio_irq fonksiyonu çağrılacaktır. Tabii kullanıcı modundan IRQ'yu
    set etmek isteyen kişi irq numarasını ve irq türünü belirtmelidir. Bu bilgileri bir yapı biçiminde ifade edebiliriz:
    
    enum IRQ_TYPE {
        IRQ_EDGE_RISING,
        IRQ_EDGE_FALLING,
        IRQ_EDGE_BOTH,
        IRQ_LEVEL_HIGH,
        IRQ_LEVEL_LOW,
    };

    struct IRQ_INFO {
        int gpio_pin;
        enum IRQ_TYPE irq_type;       
    };

    İşte ioctl fonksiyonun üçüncü parametresine IRQ_INFO türünden bir yaı nesnesinin adresi geçirilmektedir. 

    BBB'nin GPIO denetleyicilerinde IRQ'nun set edilmesi için aşağıdaki yazmaçlar kullanılmaktadır:

    #define GPIO_IRQSTATUS_0        0x2C
    #define GPIO_IRQSTATUS_1        0x30
    #define GPIO_IRQSTATUS_SET_0    0x34
    #define GPIO_IRQSTATUS_SET_1    0x38
    #define GPIO_IRQSTATUS_CLR_0    0x3C
    #define GPIO_IRQSTATUS_CLR_1    0x40

    Burada _0 ve _1 sonekli sembolik sabitler görüyorsunuz. Yukarıda da belirttiğimiz gibi aslında her GPIO denetleyicisi 
    iki IRQ hattı kullanabilmektedir. _0 sonekli hat ilk hat, _1 sonekli hat ise diğer hattır. Tabii sistem programcısı 
    tipik olarak bunlardan birini kullanır. Biz de uygulamamızda _0'lı olanları kullanacağız. GPIO_IRQSTATUS_SET_0 ve 
    GPIO_IRQSTATUS_SET_1 yazmacının ilgili biti 1 yapılırsa o bite ilişkin kesme yazılımsal yolla oluşturulmaktadır. Bu 
    yazmaçlar okunduğunda ise o anda kesme oluşan pin'lerden 1 elde edilmektedir. GPIO_IRQSTATUS_CLR_0 ve GPIO_IRQSTATUS_CLR_1 
    yazmaçlarına yazma yapıldığında 1 olan bitlerdeki kesme olayı sonlandırılır. Okuma uyapıldığında ise 1 olan bitler 
    kesme durumunda olmayan pin'leri belirtmektedir. Burada isminde SET ya da CLR olmayan GPIO_IRQSTATUS_0 ve GPIO_IRQSTATUS_1 
    biçiminde iki yazmaç daha görüyorsunuz. Bu yazmaçlar okunduğunda ilgili pinlerde kesme oluşup oluşmadığı bilgisi elde edilir. 
    Bu yazmaçlara yazma yapıldığında ise 1 olan bitler programlama yoluyla kesme oluşturmakta 0 olan bitler ise kesmeyi ortadan
    kaldırmaktadır.
    
    Burada önemli bir noktayı belirtmek istiyoruz. Bir kesme donanımsal olarak gerçekleştiğinde ya da IRQSTATUS yazmaçları 
    ile programlama yoluyla gerçekleştirildiğinde eğer kesme bu STATUS yazmaçlarında ilgili bit set ya da reset edilerek ortadan 
    kaldırılmazsa sürekli kesme oluşturmaktadır. Bu duruma "IRQ fırtınası (IRQ storm)" da denilmektedir. Bu nedenle bir kesme
    oluştuğunda kesme kodu içerisinde ilgili STATUS yazmaçları yoluyla bu eksme durumunun ortadan kaldırılması gerekir.

    İlgili pini kesme türüne göre konfigüre edebilmek için şu yazmaçlar kullanılmaktadır:

    #define GPIO_LEVELDETECT0       0x140
    #define GPIO_LEVELDETECT1       0x144
    #define GPIO_RISINGDETECT       0x148
    #define GPIO_FALLINGDETECT      0x14C

    Bu yazmaçların ilgili bitler 1 yapıldığında pin ilgili türe konfigüre edilmiş olur. Örneğin bizim chpi1'in 19 numaralı 
    ucunı (yani GPIO51 pinini) düşen kenar tetiklemeli olarak konfigüre etmemiz için GPIO_FALLINGDETECT yazmacının 19 numaralı 
    bitini 1 yapmamız gerekir. Ancak set işlemlerinde güvenlik amacıyla bir yazmacın bir biti set edilirken diğer yazmaçların
    diğer bitlerinin clear edilmesi uygun olur. Çünkü aynı bit birden fazla yazmaçta set edilmişse birden fazla olay yüzüenden 
    kesme oluşur. Tabii bir ucu kesme olarak konfigüre etmedne önce onun aynı zamanda IN olarak konfigüre edilmesi de 
    gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/delay.h>
#include <asm/io.h>
#include "gpio-driver.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("gpio-driver");

#define GPIO_CHIP0_BASE         0x44E07000
#define GPIO_CHIP1_BASE         0x4804C000
#define GPIO_CHIP2_BASE         0x481AC000
#define GPIO_CHIP3_BASE         0x481AE000

#define NGPIO_CHIPS             4
#define PINS_PER_CHIP           32

#define GPIO_OE                 0x134
#define GPIO_DATAIN             0x138
#define GPIO_DATAOUT            0x13C
#define GPIO_CLEARDATAOUT       0x190
#define GPIO_SETDATAOUT         0x194

#define TRYNUM                  10

static int gpio_open(struct inode *inodep, struct file *filp);
static int gpio_release(struct inode *inodep, struct file *filp);
static ssize_t gpio_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t gpio_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static loff_t gpio_llseek(struct file *filp, loff_t off, int whence);
static long gpio_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static inline int read_bit(const uint32_t *gpio_reg, int offset);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = gpio_open,
	.read = gpio_read,
    .write = gpio_write,
	.llseek = gpio_llseek,
    .release = gpio_release,
    .unlocked_ioctl = gpio_driver_ioctl
};

uint8_t *g_gpio_base_addrs[NGPIO_CHIPS];

static int __init gpio_init(void)
{
	int result;
    int i, k;
    unsigned long gpio_physical_addrs[NGPIO_CHIPS] = {
        GPIO_CHIP0_BASE, 
        GPIO_CHIP1_BASE, 
        GPIO_CHIP2_BASE, 
        GPIO_CHIP3_BASE
    };

	if ((result = alloc_chrdev_region(&g_dev, 0, 1, "gpio-driver")) < 0) {
		printk(KERN_INFO "cannot alloc char driver!...\n");
		return result;
	}
	cdev_init(&g_cdev, &g_fops);
	if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
		unregister_chrdev_region(g_dev, 1);
		printk(KERN_ERR "cannot add device!...\n");
		return result;
	}

    for (i = 0; i < NGPIO_CHIPS; ++i) {
        g_gpio_base_addrs[i] = ioremap(gpio_physical_addrs[i], 4096);
        if (g_gpio_base_addrs[i] == NULL) {
            for (k = 0; k < i; ++k)
                iounmap(g_gpio_base_addrs[k]);
            return -ENOMEM;
        }
    }

    printk(KERN_INFO "gpio-driver module initialization...\n");

	return 0;
}

static void __exit gpio_exit(void)
{
    int i;

    for (i = 0; i < NGPIO_CHIPS; ++i)
        iounmap(g_gpio_base_addrs[i]);
	cdev_del(&g_cdev);
	unregister_chrdev_region(g_dev, 1);
    
	printk(KERN_INFO "gpio-driver module exit...\n");
}

static int gpio_open(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "gpio-driver opened...\n");

	return 0;
}

static int gpio_release(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "gpio-driver closed...\n");

	return 0;
}

static ssize_t gpio_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    int chip, pin, bitval;
    uint32_t *gpio_reg;

    if (size != 1)
        return -EINVAL;

    chip = *off / PINS_PER_CHIP;
    pin = *off % PINS_PER_CHIP;

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
    iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);
    gpio_reg = (uint32_t *) (g_gpio_base_addrs[chip] + GPIO_DATAIN);
    bitval = read_bit(gpio_reg, pin);

    if (copy_to_user(buf, &"01"[bitval] , size) != 0)
        return -EFAULT;

    /* put_user("01"[bitval], buf); */

	return size;
}

static ssize_t gpio_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    int chip, pin;
    uint32_t *gpio_reg;
    char ch;

    if (size != 1) 
        return -EINVAL;

    chip = *off / PINS_PER_CHIP;
    pin = *off % PINS_PER_CHIP;

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
    gpio_reg = (uint32_t *) (g_gpio_base_addrs[chip] + GPIO_DATAOUT);
    if (copy_from_user(&ch, buf, size) != 0)
        return -EFAULT;
    if (ch == '0')
        iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
    else if (ch == '1')
        iowrite32(ioread32(gpio_reg) | (1 << pin), gpio_reg);
    else 
        return -EINVAL;

	return size;
}

static loff_t gpio_llseek(struct file *filp, loff_t off, int whence)
{
    loff_t newpos;

    switch (whence) {
        case 0:
            newpos = off;
            break;
        case 1:
            newpos = filp->f_pos + off;
            break;
        case 2:
            newpos = (4 * PINS_PER_CHIP) + off;
            break;
        default:
            return -EINVAL;
    }
    if (newpos < 0 || newpos >= 128)
        return -EINVAL;

    filp->f_pos = newpos;

    return newpos;
}

static long gpio_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    long result;
 
    switch (cmd) {
        case IOC_GPIO_TEST:
            break;
        default:
            result = -ENOTTY;
    }

    return result;
}

static inline int read_bit(const uint32_t *gpio_reg, int offset)
{
    int i;
    int first_val, second_val;

    for (i = 0; i < TRYNUM; ++i) {
        first_val = ioread32(gpio_reg) >> offset & 1;
        msleep(5);
        second_val = ioread32(gpio_reg) >> offset & 1;
        if (first_val == second_val)
            return second_val;
    }

    return second_val;
}

module_init(gpio_init);
module_exit(gpio_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/* gpio-driver-test-read.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char ch;

    if ((fd = open("gpio-driver", O_RDWR)) == -1) 
        exit_sys("open");
    
    lseek(fd, 51, 0);
    for (int i = 0; i < 10; ++i) {
        if (read(fd, &ch, 1) == -1)
            exit_sys("read");
        printf("%c\n", ch);
        sleep(1);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* gpio-driver-test-write.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char ch;

    if ((fd = open("gpio-driver", O_RDWR)) == -1) 
        exit_sys("open");
    
    lseek(fd, 60, 0);
    for (int i = 0; i < 10; ++i) {
        ch = '1';
        if (write(fd, &ch, 1) == -1)
            exit_sys("write");
        sleep(1);

        ch = '0';
        if (write(fd, &ch, 1) == -1)
            exit_sys("write");
        sleep(1);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                            139. Ders 04/11/2025 - Salı
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de kesme oluşana kadar blokede bekleten bir aygıt sürücü yazalım. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            140. Ders 06/11/2025 - Perşembe
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Kesme gelene kadar bekleme yapan aygıt sürücümüzün init fonksiyonunda GPIO denetleyicilerinin taban adresleri bellek tabaklı 
    IO amacıyla bir göstericisi dizisinde saklanıp bunlar için sanal adresler oluşturulmuştur:

    static int __init gpio_init(void)
    {
        int result;
        int i, k;
        unsigned long gpio_physical_addrs[NGPIO_CHIPS] = {
            GPIO_CHIP0_BASE, 
            GPIO_CHIP1_BASE, 
            GPIO_CHIP2_BASE, 
            GPIO_CHIP3_BASE
        };

        if ((result = alloc_chrdev_region(&g_dev, 0, 1, "gpio-driver")) < 0) {
            printk(KERN_INFO "cannot alloc char driver!...\n");
            return result;
        }
        cdev_init(&g_cdev, &g_fops);
        if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
            unregister_chrdev_region(g_dev, 1);
            printk(KERN_ERR "cannot add device!...\n");
            return result;
        }

        for (i = 0; i < NGPIO_CHIPS; ++i) {
            g_gpio_base_addrs[i] = ioremap(gpio_physical_addrs[i], 4096);
            if (g_gpio_base_addrs[i] == NULL) {
                for (k = 0; k < i; ++k)
                    iounmap(g_gpio_base_addrs[k]);
                return -ENOMEM;
            }
        }

        printk(KERN_INFO "gpio-driver module initialization...\n");

        return 0;
    }

    GPIO denetleyicilerinin taban sanal adresleri g_gpio_base_addrs dizisine yerleştirilmiştir. Aygıt sürücümüzde read işleminde
    iki biçimde yapılabilmektedir: Blokeli ve blokesiz. Default mod blokeli moddur. Blokeli modda pin okunmak istediğinde 
    read fonksiyonu bloke olur. İlgili pin değeri lojik 0'a düşürüldüğünde bloke çözülür. Bunun için bir bekleme kuyruğu 
    oluşturulmuş ve GPIO IRQ'su işlenerek bu bekleme kuyruğunda bekleyen thread'ler çalışma kuyruğuna alınmıştır. read işleminde
    her zaman ilgili pin IN olarak konfigüre edilip eğer daha önce kesme konfigürasyonu yapılmamışsa kesme konfigürasyonu da
    düşüne kenar olarak yapılmıştır:

    static ssize_t gpio_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        int chip, pin, bitval;
        uint32_t *gpio_reg;
        unsigned long flags;
        struct IRQ_DATA *irq_data;
        int result;

        if (size != 1)
            return -EINVAL;

        if (*off < 0 || *off >= TOTAL_PINS)
            return -EINVAL;

        chip = *off / PINS_PER_CHIP;
        pin = *off % PINS_PER_CHIP;

        irq_data = &g_irq_data[*off];

        if (filp->f_flags & O_NONBLOCK) {
            spin_lock_irqsave(&g_spinlock, flags);

            gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
            iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);

            gpio_reg = (uint32_t *) (g_gpio_base_addrs[chip] + GPIO_DATAIN);
            bitval = read_bit(gpio_reg, pin);

            spin_unlock_irqrestore(&g_spinlock, flags);

            if (copy_to_user(buf, &"01"[bitval] , size) != 0)
                return -EFAULT;

            return size;
        }
                
        gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
        iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);
        
        if (!g_irq_data[*off].irq_flag)
            if ((result = set_gpio_irq(*off )) != 0)
                return result;

        if (wait_event_interruptible(irq_data->wq, atomic_read(&irq_data->wait_flag) != 0) != 0)
            return -ERESTARTSYS;
        atomic_set(&irq_data->wait_flag, 0);
    

        if (copy_to_user(buf, &"01"[bitval] , size) != 0)
            return -EFAULT;

        return size;
    }

    Eğer okuma işlemi dosya O_NONBLOCK ile açılığ yapılmışsa bu durumda hiç bloke oluşmamakta ve doğrudan pin'in değeri 
    okunmaktadır. 

    Kesme oluşturulduğunda çağrılacak kesme kodu da şöyle yazılmıştır:

    static irqreturn_t gpio_irq_handler(int irq, void *dev_id)
    {
        uint32_t *gpio_reg;
        struct IRQ_DATA *irq_data;

        irq_data = (struct IRQ_DATA *)dev_id;

        gpio_reg = (uint32_t *)(g_gpio_base_addrs[1] + GPIO_IRQSTATUS_0);
        iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);

        atomic_set(&irq_data->wait_flag, 1);
        wake_up_interruptible(&irq_data->wq);

        return IRQ_HANDLED;
    }

    Aygıt sürücümüzde her pin için ayrı bir bekleme kuyruğu bulunmaktadır. Pin'lere ilişkin bilgiler global bir dizide 
    tutulmaktadır:

    struct IRQ_DATA {
        int chip;
        int pin;
        int irq_flag;
        atomic_t wait_flag;
        wait_queue_head_t wq;
    };

    static struct IRQ_DATA g_irq_data[TOTAL_PINS];

    IRQ set edilirken request_şrq fonksiyonunda IRQ!nun düşen kenara ilişkin olduğu belirtilmelidir:

    static int set_gpio_irq(int gpio_pin)
    {
        int chip, pin;
        uint32_t *gpio_reg;
        int irqno;
        int result;
        unsigned long flags;

        if (gpio_pin < 0 || gpio_pin >= TOTAL_PINS)
            return -EINVAL;

        chip = gpio_pin / PINS_PER_CHIP;
        pin = gpio_pin % PINS_PER_CHIP;

        spin_lock_irqsave(&g_spinlock, flags);

        gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_LEVELDETECT0);
        iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);

        gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_LEVELDETECT1);
        iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);

        gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_RISINGDETECT);
        iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
        
        gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_FALLINGDETECT);
        iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);

        spin_unlock_irqrestore(&g_spinlock, flags);

        if (mutex_lock_interruptible(&g_mutex) != 0)
            return -ERESTARTSYS;

        g_irq_data[gpio_pin].chip = chip;
        g_irq_data[gpio_pin].pin = pin;
        g_irq_data[gpio_pin].irq_flag = 1;

        init_waitqueue_head(&g_irq_data[gpio_pin].wq);

        if ((irqno = gpio_to_irq(gpio_pin)) < 0) {
            printk(KERN_INFO "Cannot get IRQ number...\n");
            mutex_unlock(&g_mutex);
            return irqno;
        }

        if ((result = request_irq(irqno, gpio_irq_handler, IRQF_TRIGGER_FALLING|IRQF_SHARED, 
                    "irq-driver", &g_irq_data[gpio_pin])) != 0) {
            printk(KERN_INFO "Cannot set IRQ...\n");
            mutex_unlock(&g_mutex);
            return result;
        }

        mutex_unlock(&g_mutex);

        printk(KERN_INFO "IRQ successfully set...\n");

        return 0;
    }

    Aygıt sürücümüzde ioctil işlemi bulunmamaktadır. Ancak biz yine daha sonra eklenebilir diye ioctl işlemlerine yönelik 
    temel kodları da bulundurduk.

    Örneğin kodları bütün olarak aşağıda verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-deriver.h */

#ifndef HPET_DRIVER_H_
#define HPET_DRIVER_H_

#include <linux/stddef.h>
#include <linux/ioctl.h>

#define GPIO_DRIVER_MAGIC		    'g'

#define IOC_GPIO_IRQ_TEST	       _IO(GPIO_DRIVER_MAGIC, 1)

#endif

/* gpio-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/delay.h>
#include <linux/spinlock.h>
#include <linux/wait.h>
#include <asm/atomic.h>
#include <asm/io.h>
#include <linux/interrupt.h>
#include <linux/gpio.h>
#include "gpio-driver.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("gpio-driver");

#define GPIO_CHIP0_BASE         0x44E07000
#define GPIO_CHIP1_BASE         0x4804C000
#define GPIO_CHIP2_BASE         0x481AC000
#define GPIO_CHIP3_BASE         0x481AE000

#define NGPIO_CHIPS             4
#define PINS_PER_CHIP           32
#define TOTAL_PINS              (NGPIO_CHIPS * PINS_PER_CHIP)

#define GPIO_OE                 0x134
#define GPIO_DATAIN             0x138
#define GPIO_DATAOUT            0x13C
#define GPIO_CLEARDATAOUT       0x190
#define GPIO_SETDATAOUT         0x194

#define GPIO_IRQSTATUS_0        0x2C
#define GPIO_IRQSTATUS_1        0x30
#define GPIO_IRQSTATUS_SET_0    0x34
#define GPIO_IRQSTATUS_SET_1    0x38
#define GPIO_IRQSTATUS_CLR_0    0x3C
#define GPIO_IRQSTATUS_CLR_1    0x40

#define GPIO_LEVELDETECT0       0x140
#define GPIO_LEVELDETECT1       0x144
#define GPIO_RISINGDETECT       0x148
#define GPIO_FALLINGDETECT      0x14C

#define TRYNUM                  10

static int gpio_open(struct inode *inodep, struct file *filp);
static int gpio_release(struct inode *inodep, struct file *filp);
static ssize_t gpio_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t gpio_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static loff_t gpio_llseek(struct file *filp, loff_t off, int whence);
static long gpio_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
static irqreturn_t gpio_irq_handler(int irq, void *dev_id);

static int set_gpio_irq(int gpip_pin);
static int reset_gpio_irq(int gpip_pin);
static inline int read_bit(const uint32_t *gpio_reg, int offset);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = gpio_open,
	.read = gpio_read,
    .write = gpio_write,
	.llseek = gpio_llseek,
    .release = gpio_release,
    .unlocked_ioctl = gpio_driver_ioctl
};

enum IRQ_TYPE {
    IRQ_EDGE_RISING,
    IRQ_EDGE_FALLING,
    IRQ_EDGE_BOTH,
    IRQ_LEVEL_HIGH,
    IRQ_LEVEL_LOW,
};

struct IRQ_DATA {
    int chip;
    int pin;
    int irq_flag;
    atomic_t wait_flag;
    wait_queue_head_t wq;
};

static uint8_t *g_gpio_base_addrs[NGPIO_CHIPS];
static struct IRQ_DATA g_irq_data[TOTAL_PINS];

static DEFINE_SPINLOCK(g_spinlock);
static DEFINE_MUTEX(g_mutex);

static int __init gpio_init(void)
{
	int result;
    int i, k;
    unsigned long gpio_physical_addrs[NGPIO_CHIPS] = {
        GPIO_CHIP0_BASE, 
        GPIO_CHIP1_BASE, 
        GPIO_CHIP2_BASE, 
        GPIO_CHIP3_BASE
    };

	if ((result = alloc_chrdev_region(&g_dev, 0, 1, "gpio-driver")) < 0) {
		printk(KERN_INFO "cannot alloc char driver!...\n");
		return result;
	}
	cdev_init(&g_cdev, &g_fops);
	if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
		unregister_chrdev_region(g_dev, 1);
		printk(KERN_ERR "cannot add device!...\n");
		return result;
	}

    for (i = 0; i < NGPIO_CHIPS; ++i) {
        g_gpio_base_addrs[i] = ioremap(gpio_physical_addrs[i], 4096);
        if (g_gpio_base_addrs[i] == NULL) {
            for (k = 0; k < i; ++k)
                iounmap(g_gpio_base_addrs[k]);
            return -ENOMEM;
        }
    }

    printk(KERN_INFO "gpio-driver module initialization...\n");

	return 0;
}

static void __exit gpio_exit(void)
{
    int i;

    for (i = 0; i < NGPIO_CHIPS; ++i)
        iounmap(g_gpio_base_addrs[i]);
	cdev_del(&g_cdev);
	unregister_chrdev_region(g_dev, 1);
    
	printk(KERN_INFO "gpio-driver module exit...\n");
}

static int gpio_open(struct inode *inodep, struct file *filp)
{
	return 0;
}

static int gpio_release(struct inode *inodep, struct file *filp)
{
    int i;
    unsigned long flags;

   if (mutex_lock_interruptible(&g_mutex) != 0)
        return -ERESTARTSYS;
    for (i = 0; i < TOTAL_PINS; ++i) {
        if (g_irq_data[i].irq_flag)
            reset_gpio_irq(i);
            atomic_set(&g_irq_data[i].wait_flag, 0);
    }
    mutex_unlock(&g_mutex);

	printk(KERN_INFO "gpio-driver closed...\n");

	return 0;
}

static ssize_t gpio_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    int chip, pin, bitval;
    uint32_t *gpio_reg;
    unsigned long flags;
    struct IRQ_DATA *irq_data;
    int result;

    if (size != 1)
        return -EINVAL;

    if (*off < 0 || *off >= TOTAL_PINS)
        return -EINVAL;

    chip = *off / PINS_PER_CHIP;
    pin = *off % PINS_PER_CHIP;

    irq_data = &g_irq_data[*off];

    if (filp->f_flags & O_NONBLOCK) {
        spin_lock_irqsave(&g_spinlock, flags);

        gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
        iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);

        gpio_reg = (uint32_t *) (g_gpio_base_addrs[chip] + GPIO_DATAIN);
        bitval = read_bit(gpio_reg, pin);

        spin_unlock_irqrestore(&g_spinlock, flags);

        if (copy_to_user(buf, &"01"[bitval] , size) != 0)
            return -EFAULT;

        return size;
    }
            
    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
    iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);
    
    if (!g_irq_data[*off].irq_flag)
        if ((result = set_gpio_irq(*off )) != 0)
            return result;


    if (wait_event_interruptible(irq_data->wq, atomic_read(&irq_data->wait_flag) != 0) != 0)
        return -ERESTARTSYS;
    atomic_set(&irq_data->wait_flag, 0);
   
    if (copy_to_user(buf, &"01"[bitval] , size) != 0)
        return -EFAULT;

    return size;
}

static ssize_t gpio_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    int chip, pin;
    uint32_t *gpio_reg;
    char ch;
    unsigned long flags;

    if (size != 1) 
        return -EINVAL;

    chip = *off / PINS_PER_CHIP;
    pin = *off % PINS_PER_CHIP;

    spin_lock_irqsave(&g_spinlock, flags);

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
    gpio_reg = (uint32_t *) (g_gpio_base_addrs[chip] + GPIO_DATAOUT);

    spin_unlock_irqrestore(&g_spinlock, flags);

    if (copy_from_user(&ch, buf, size) != 0)
        return -EFAULT;
    if (ch == '0')
        iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
    else if (ch == '1')
        iowrite32(ioread32(gpio_reg) | (1 << pin), gpio_reg);
    else {
        return -EINVAL;
    }

	return size;
}

static loff_t gpio_llseek(struct file *filp, loff_t off, int whence)
{
    loff_t newpos;
 
    switch (whence) {
        case 0:
            newpos = off;
            break;
        case 1:
            newpos = filp->f_pos + off;
            break;
        case 2:
            newpos = (4 * PINS_PER_CHIP) + off;
            break;
        default:
            return -EINVAL;
    }
    if (newpos < 0 || newpos >= 128)
        return -EINVAL;

    filp->f_pos = newpos;

    return newpos;
}

static long gpio_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    long result;
 
    switch (cmd) {
        case IOC_GPIO_IRQ_TEST:
            break;
        default:
            result = -ENOTTY;
    }

    return result;
}

static irqreturn_t gpio_irq_handler(int irq, void *dev_id)
{
    uint32_t *gpio_reg;
    struct IRQ_DATA *irq_data;

    irq_data = (struct IRQ_DATA *)dev_id;

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[1] + GPIO_IRQSTATUS_0);
    iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);

    atomic_set(&irq_data->wait_flag, 1);
    wake_up_interruptible(&irq_data->wq);

    return IRQ_HANDLED;
}

static int set_gpio_irq(int gpio_pin)
{
    int chip, pin;
    uint32_t *gpio_reg;
    int irqno;
    int result;
    unsigned long flags;

    if (gpio_pin < 0 || gpio_pin >= TOTAL_PINS)
        return -EINVAL;

    chip = gpio_pin / PINS_PER_CHIP;
    pin = gpio_pin % PINS_PER_CHIP;

    spin_lock_irqsave(&g_spinlock, flags);

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_LEVELDETECT0);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_LEVELDETECT1);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_RISINGDETECT);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
    
    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_FALLINGDETECT);
    iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);

    spin_unlock_irqrestore(&g_spinlock, flags);

    if (mutex_lock_interruptible(&g_mutex) != 0)
        return -ERESTARTSYS;

    g_irq_data[gpio_pin].chip = chip;
    g_irq_data[gpio_pin].pin = pin;
    g_irq_data[gpio_pin].irq_flag = 1;

    init_waitqueue_head(&g_irq_data[gpio_pin].wq);

    if ((irqno = gpio_to_irq(gpio_pin)) < 0) {
        printk(KERN_INFO "Cannot get IRQ number...\n");
        mutex_unlock(&g_mutex);
        return irqno;
    }

    if ((result = request_irq(irqno, gpio_irq_handler, IRQF_TRIGGER_FALLING|IRQF_SHARED, 
                "irq-driver", &g_irq_data[gpio_pin])) != 0) {
        printk(KERN_INFO "Cannot set IRQ...\n");
        mutex_unlock(&g_mutex);
        return result;
    }

    mutex_unlock(&g_mutex);

    printk(KERN_INFO "IRQ successfully set...\n");

    return 0;
}

static int reset_gpio_irq(int gpio_pin)
{
    int chip, pin;
    uint32_t *gpio_reg;
    int irqno;
    unsigned long flags;

    chip = gpio_pin / PINS_PER_CHIP;
    pin = gpio_pin % PINS_PER_CHIP;

    spin_lock_irqsave(&g_spinlock, flags);

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_LEVELDETECT0);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_LEVELDETECT1);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_RISINGDETECT);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
    
    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_FALLINGDETECT);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_IRQSTATUS_SET_0);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
    
    if ((irqno = gpio_to_irq(gpio_pin)) < 0) {
        printk(KERN_INFO "Cannot get IRQ number...\n");
        return irqno;
    }
    g_irq_data[gpio_pin].irq_flag = 0;

    spin_unlock_irqrestore(&g_spinlock, flags);

    free_irq(irqno, &g_irq_data[gpio_pin]);

    return 0;
}

static inline int read_bit(const uint32_t *gpio_reg, int offset)
{
    int i;
    int first_val, second_val;

    for (i = 0; i < TRYNUM; ++i) {
        first_val = ioread32(gpio_reg) >> offset & 1;
        msleep(5);
        second_val = ioread32(gpio_reg) >> offset & 1;
        if (first_val == second_val)
            return second_val;
    }

    return second_val;
}

module_init(gpio_init);
module_exit(gpio_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/* gpio-driver-irq-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include "gpio-driver.h"

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char ch;

    if ((fd = open("gpio-driver", O_RDWR)) == -1) 
        exit_sys("open");

    lseek(fd, 51, 0);

    ch = '1';
    write(fd, &ch, 1);

    for (int i = 0; i < 10; ++i) {
        printf("waiting for pressing button...\n");
        if (read(fd, &ch, 1) == -1)
            exit_sys("read");
        printf("%c\n", ch);
    }
       
    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                        141. Ders 11/11/2025 - Salı
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de Raspberry Pi'daki GPIO kullanımı üzerinde duralım. Anımsanacağı gibi Raspberry Pi'da iki sütun haline toplam 
    40 tane IP pin'i vardır. Bu pinlerin bazıları çok işlevlidir. Bazıları ise belirli amaca yöneliktir. Pin numaralandırmaları
    yine soldaki sütun tek numaralar sağdaki sütun çüft numaralar olacak biçimde yapılmıştır:

    1   2
    3   4
    5   6
    7   8
    9   10
    11  12
    13  14
    15  16
    17  18
    19  20
    21  22
    23  24
    25  26
    27  28
    29  30
    31  32
    23  34
    35  36
    37  38
    39  40

    Aşağıda tabloda aygıt pin'lerin sürücü numralandırması ile işlevleri belirtilmektedir. 

    ╔═════╦═══════════╦═══════════════╦════════════════════════════╗
    ║  #  ║ BCM GPIO  ║ Fiziksel Pin  ║   Alternatif Fonksiyon     ║
    ╠═════╬═══════════╬═══════════════╬════════════════════════════╣
    ║  1  ║  GPIO0    ║    Pin 27     ║ ID_SD (I2C0 SDA - EEPROM)  ║
    ║  2  ║  GPIO1    ║    Pin 28     ║ ID_SC (I2C0 SCL - EEPROM)  ║
    ║  3  ║  GPIO2    ║    Pin 3      ║ I2C1 SDA                   ║
    ║  4  ║  GPIO3    ║    Pin 5      ║ I2C1 SCL                   ║
    ║  5  ║  GPIO4    ║    Pin 7      ║ GPCLK0                     ║
    ║  6  ║  GPIO5    ║    Pin 29     ║ GPIO                       ║
    ║  7  ║  GPIO6    ║    Pin 31     ║ GPIO                       ║
    ║  8  ║  GPIO7    ║    Pin 26     ║ SPI0 CE1                   ║
    ║  9  ║  GPIO8    ║    Pin 24     ║ SPI0 CE0                   ║
    ║ 10  ║  GPIO9    ║    Pin 21     ║ SPI0 MISO                  ║
    ║ 11  ║  GPIO10   ║    Pin 19     ║ SPI0 MOSI                  ║
    ║ 12  ║  GPIO11   ║    Pin 23     ║ SPI0 SCLK                  ║
    ║ 13  ║  GPIO12   ║    Pin 32     ║ PWM0                       ║
    ║ 14  ║  GPIO13   ║    Pin 33     ║ PWM1                       ║
    ║ 15  ║  GPIO14   ║    Pin 8      ║ UART0 TXD                  ║
    ║ 16  ║  GPIO15   ║    Pin 10     ║ UART0 RXD                  ║
    ║ 17  ║  GPIO16   ║    Pin 36     ║ GPIO                       ║
    ║ 18  ║  GPIO17   ║    Pin 11     ║ GPIO                       ║
    ║ 19  ║  GPIO18   ║    Pin 12     ║ PWM0 / PCM CLK             ║
    ║ 20  ║  GPIO19   ║    Pin 35     ║ PWM1 / PCM FS              ║
    ║ 21  ║  GPIO20   ║    Pin 38     ║ PCM DIN                    ║
    ║ 22  ║  GPIO21   ║    Pin 40     ║ PCM DOUT                   ║
    ║ 23  ║  GPIO22   ║    Pin 15     ║ GPIO                       ║
    ║ 24  ║  GPIO23   ║    Pin 16     ║ GPIO                       ║
    ║ 25  ║  GPIO24   ║    Pin 18     ║ GPIO                       ║
    ║ 26  ║  GPIO25   ║    Pin 22     ║ GPIO                       ║
    ║ 27  ║  GPIO26   ║    Pin 37     ║ GPIO                       ║
    ║ 28  ║  GPIO27   ║    Pin 13     ║ GPIO                       ║
    ╚═════╩═══════════╩═══════════════╩════════════════════════════╝

    Aşağıdaki şekilde ise pin'lerin başlık üzerinde konumları ve işlevleri gösterilmektedir:

       ┌─────────────────────────────────────────────────┐
    1  │ •  3.3V Power              5V Power  •          │ 2
    3  │ •  GPIO2   (I2C1 SDA)      5V Power  •          │ 4
    5  │ •  GPIO3   (I2C1 SCL)      Ground               │ 6
    7  │ •  GPIO4   (GPCLK0)        GPIO14    •  (TX)    │ 8
    9  │    Ground                  GPIO15    •  (RX)    │ 10
    11 │ •  GPIO17                  GPIO18    •  (PWM)   │ 12
    13 │ •  GPIO27                  Ground               │ 14
    15 │ •  GPIO22                  GPIO23    •          │ 16
    17 │ •  3.3V Power              GPIO24    •          │ 18
    19 │ •  GPIO10  (MOSI)          Ground               │ 20
    21 │ •  GPIO9   (MISO)          GPIO25    •          │ 22
    23 │ •  GPIO11  (SCLK)          GPIO8     •  (CE0)   │ 24
    25 │    Ground                  GPIO7     •  (CE1)   │ 26
    27 │ •  GPIO0   (ID_SD)         GPIO1     •  (ID)    │ 28
    29 │ •  GPIO5                   Ground               │ 30
    31 │ •  GPIO6                   GPIO12    •  (PWM)   │ 32
    33 │ •  GPIO13  (PWM)           Ground               │ 34
    35 │ •  GPIO19  (PWM)           GPIO16    •          │ 36
    37 │ •  GPIO26                  GPIO20    •  (PCM)   │ 38
    39 │    Ground                  GPIO21    •  (PCM)   │ 40
       └─────────────────────────────────────────────────┘
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aslında Raspberry Pi ile BBB GPIO pin'lerinin kullanılması konusunda oldukça benzemektedir. Raspberry PI'da da GPIO 
    denetleyicisi Broadcom'un SoC çipi içerisindedir ve GPIO denetleyicisine yine bellek tabanlı IO (memory-mapped IO) 
    tekniğiyle erişilmektedir. Yine Raspberry Pi'da da GPIO uçları için sysfs arayüzü BBB'de olduğu gibi kullanılmaktadır. 
    Yine "/sys/class/gpio" dizinine geçilerek ilgili pin'lere ilişkin export edilmiş dizin girişleri yoluyla IO işlemleri 
    komut satırından yapılabilmektedir. Bu dizinin içeriği aşağıdakine benzer olacaktır:

    export  gpiochip512  gpiochip529  gpiochip535  gpiochip567  gpiochip571  unexport

    Burada gpiochipXXX dizinleri GPIO denetleyicilerini belirtmektedir. gpiochip512 denetleyicisi GPIO pinlerini kontrol eden 
    denetleyicidir. Aslında BCM SoC çiplerinde toplamda bir tane GPIO denetleyicisi vardır. Ancak Linux çekirdeği bize sanki 
    birden fazla GPIO denetleyicisi varmış gibi bir görünüm sunmaktadır. SoC içerisinde 54 GPIO ucunun yalnızca 26 tanesi 
    pinlere verilmiş durumdadır. GPIO pin'leri üzerinde işlem yapabilmek için global GPIO numarasının elde edilmesi gerekir. 
    Bu numarada bir taban numaraya GPIO aygıt sürücü numarasının eklenmesiyle elde edilmektedir. Linux çekirdeği GPIO pin'lerini
    gpiochip512 çip diziniyle göstermektedir. Bu bu çip dizinin taban değeri 512'dir. Bu taban değer ilgili dizindeki "base" 
    elde edilebilir:

    $ cat /sys/class/gpio/gpiochip512/base
    512

    Biz hangi aygıt sürücü numarasına ilişkin GPIO pin'ini kullanacaksak o değeri bu numaraya ekleyerek global GPIO numarasını
    elde ederiz. Örneğin GPIO6 pin'ini kullanmak isteyelim. Bu durumda global GPIO pin numarası 512 + 6 = 518 olacaktır. 
    Default durumda herhangi bir pin export edilmemiştir. Export işlemi global pin numarasına göre yapılmaktadır. Export işlemi 
    için BBB'de olduğu gibi  "/sys/class/gpio" dizinindeki "export" dosyası kullanılmaktadır. Örneğin:

    $ echo 518 > /sys/class/gpio/export

    Artık export ettiğimiz pin "/sys/class/gpio" dizininde gözükecektir:

    $ ls /sys/class/gpio
    export  gpio518  gpiochip512  gpiochip529  gpiochip535  gpiochip567  gpiochip571  unexport

    Bu dizine geçildiğinde tıpkı BBB'de olduğu gibi ilgili pin'e erişmek için dosyalar görülecektir:

    $ ls ls /sys/class/gpio/gpio518
    active_low  device  direction  power  subsystem  uevent  value

    Burada yine direction dosyasıyla BBB'de olduğu gibi pin IN ya da OUT olarka konfigüre edilir. value dosyası yoluyla da
    pin'deki değer elde edilip pin'e yeni değer set edilebilmektedir. Dolayısıyla aslında pin export edildikten sonra 
    yapılacak her şey BBB'de olduğu gibidir. 

    Aslında BBB'de belirttiğimiz gibi GPIO pin'leri için sysfs dosya sisteminin kullanılması "deprecated" yapılmıştır. Tıpkı
    BBB'de olduğu gibi Raspberry Pi'da "libgpiod" kütüphanesi benzer biçimde kullanılabilmektedir. Bu kütüphane kullanılırken 
    gpiod_chip_open_by_name fonksiyonunda çip ismi "gpiochip512" biçiminde girilmelidir. Hat numarası da aygıt sürücü GPIO 
    numarası olarak girilmelidir. Örneğin GPIO6 numaralı pin'deki LED şöyle yapılabilir:

    #include <gpiod.h>
    #include <stdio.h>
    #include <unistd.h>

    #define CHIP_NAME       "gpiochip512"
    #define LINE_OFFSET     6
    #define CONSUMER        "led_test"

    int main(void)
    {
        struct gpiod_chip *chip;
        struct gpiod_line *line;
        int ret;

        chip = gpiod_chip_open_by_name(CHIP_NAME);
        if (!chip) {
            perror("gpiod_chip_open_by_name");
            return 1;
        }

        line = gpiod_chip_get_line(chip, LINE_OFFSET);
        if (!line) {
            perror("gpiod_chip_get_line");
            gpiod_chip_close(chip);
            return 1;
        }

        ret = gpiod_line_request_output(line, CONSUMER, 0);
        if (ret < 0) {
            perror("gpiod_line_request_output");
            gpiod_chip_close(chip);
            return 1;
        }

        printf("LED ON\n");
        gpiod_line_set_value(line, 1);
        sleep(1);
        printf("LED OFF\n");
        gpiod_line_set_value(line, 0);

        gpiod_line_release(line);
        gpiod_chip_close(chip);
        return 0;
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Raspbeery PI'daki GPIO denetleyicisinin fiziksel taban adresleri şöyledir:

    #define BCM2835_PERI_BASE   0x20000000  // Pi 1
    #define BCM2836_PERI_BASE   0x3F000000  // Pi 2/3
    #define BCM2711_PERI_BASE   0xFE000000  // Pi 4
    #define BCM2712_PERI_BASE   0x1F00000000  // Pi 5 (64-bit!)

    #define GPIO_OFFSET         0x00200000
    #define GPIO_BASE          (PERI_BASE + GPIO_OFFSET)

    Burada taban fiziksel adres GPIO_BASE sembolik sabiti ile temsil edilmiştir. Bu taban adresten itibaren toplam 41 tane
    32 bitlik bellek tabanlı erişilen yazmaç vardır.

    // Function Select (Her GPIO için 3-bit fonksiyon kodu)
    #define GPFSEL0   0x00  // GPIO 0-9
    #define GPFSEL1   0x04  // GPIO 10-19
    #define GPFSEL2   0x08  // GPIO 20-29
    #define GPFSEL3   0x0C  // GPIO 30-39
    #define GPFSEL4   0x10  // GPIO 40-49
    #define GPFSEL5   0x14  // GPIO 50-53

    // Output Set (Write 1 to set)
    #define GPSET0    0x1C  // GPIO 0-31
    #define GPSET1    0x20  // GPIO 32-53

    // Output Clear (Write 1 to clear)
    #define GPCLR0    0x28  // GPIO 0-31
    #define GPCLR1    0x2C  // GPIO 32-53

    // Pin Level (Read only)
    #define GPLEV0    0x34  // GPIO 0-31
    #define GPLEV1    0x38  // GPIO 32-53

    // Event Detect Status
    #define GPEDS0    0x40
    #define GPEDS1    0x44

    // Rising/Falling Edge Detect
    #define GPREN0    0x4C
    #define GPFEN0    0x58

    // Pull-up/Pull-down
    #define GPPUD     0x94  // Control
    #define GPPUDCLK0 0x98  // Clock 0-31
    #define GPPUDCLK1 0x9C  // Clock 32-53

    Buradaki GPFSELN yazmaçları belli bir pin'i IN, OUT ve diğer bazı biçimlerde konfigüre  etmek için kullanılmaktadır. 
    Her yazmaç 32 bit olmasına karşın yalnızca 10 tane GPIO pin'ini konfigüre edebilmektedir. Bu yazmaçlardaki her 3 bit 
    bir pin'in konfigürasyonunu belirtmektedir:

    000 = Input
    001 = Output  
    010-111 = Alternate Functions (ALT0-ALT5)

    Örneğin GPIO17 pin'ini OUT olarak şöyle konfigüre edebiliriz:

    volatile uint32_t *gpio = (uint32_t*)GPIO_BASE;
    volatile uint32_t *gpfsel1 = gpio + (GPFSEL1 / 4);

    int pin = 17;
    int reg_idx = pin / 10;       // = 1 (GPFSEL1)
    int bit_offset = (pin % 10) * 3;  // = 21

    *gpfsel1 = (*gpfsel1 & ~(7 << bit_offset)) | (1 << bit_offset);

    Tabii bu işlemler aslında aygıt sürücü içerisinde daha güvenli bir biçimde yapılmalıdır. Yukarıda her pin için 3 bitlik 
    bir konfigürasyon bilgisinin bulundurulduğunu belirtmiştik. Oradaki 010 ile 111 arasındaki bitler alternatif konfigürasyon
    numarasını belirtmektedir. Bu alternatif konfigürasyonlar şöyledir:

    BCM  Board  Fonksiyon           ALT0      ALT1    ALT2    ALT3    ALT4    ALT5
    ───────────────────────────────────────────────────────────────────────────────
    0    27     ID_SD (EEPROM)      I2C0_SDA   -       -       -       -       -
    1    28     ID_SC (EEPROM)      I2C0_SCL   -       -       -       -       -
    2    3      I2C1 SDA            I2C1_SDA   -       -       -       -       -
    3    5      I2C1 SCL            I2C1_SCL   -       -       -       -       -
    4    7      GPCLK0              GPCLK0     -       -       -       -       -
    7    26     SPI0 CE1            SPI0_CE1_N -       -       -       -       -
    8    24     SPI0 CE0            SPI0_CE0_N -       -       -       -       -
    9    21     SPI0 MISO           SPI0_MISO  -       -       -       -       -
    10   19     SPI0 MOSI           SPI0_MOSI  -       -       -       -       -
    11   23     SPI0 SCLK           SPI0_SCLK  -       -       -       -       -
    12   32     PWM0                PWM0       -       -       -       -       -
    13   33     PWM1                PWM1       -       -       -       -       -
    14   8      UART0 TXD           UART0_TXD  -       -       -       UART1_TX -
    15   10     UART0 RXD           UART0_RXD  -       -       -       UART1_RX -
    17   11     GPIO                -          -       -       -       -       -
    18   12     PWM0/PCM_CLK        PCM_CLK    -       PWM0    -       -       -
    22   15     GPIO                -          -       -       -       -       -
    23   16     GPIO                -          -       -       -       -       -
    24   18     GPIO                -          -       -       -       -       -
    25   22     GPIO                -          -       -       -       -       -
    27   13     GPIO                -          -       -       -       -       -

    İlgili pin'i alternatif konfigürasyon moduna sokma işlemi şöyle yapılabilir:

    typedef enum {
        GPIO_FUNC_INPUT  = 0b000,
        GPIO_FUNC_OUTPUT = 0b001,
        GPIO_FUNC_ALT0   = 0b100,
        GPIO_FUNC_ALT1   = 0b101,
        GPIO_FUNC_ALT2   = 0b110,
        GPIO_FUNC_ALT3   = 0b111,
        GPIO_FUNC_ALT4   = 0b011,
        GPIO_FUNC_ALT5   = 0b010
    } GPIO_ALT_MODES;

    void gpio_set_function(int pin, GPIO_ALT_MODES alt) 
    {
        int reg = pin / 10;
        int shift = (pin % 10) * 3;
         volatile uint32_t *fsel = gpio_map + reg;
        uint32_t value = *fsel;

        value &= ~(7 << shift);
        value |= (alt << shift);
        *fsel = value;
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    "libgpiod" kütüphanesine alternatif olarak Raspberry Pi için "pigpio" isimli ayrı kütüphane de bulundurulmuştur. Kütüphane 
    indirilebilir:

    $ sudo apt-get install pigpio 

    Aslında zaten Raspberri OS içerisinde bu kütüphane yüklü durumdadır. Kütüphanedeki fonksiyon prototipleri ve diğer 
    birtakım bildrimler <pigpio.h> başlık dosyasında bulunmaktadır. Kütüphane genel değil Raspberry Pi için yazıldığından 
    dolayı kullanımı da oldukça kolaydır. Önce gpioInitialise fonksiyonu çağrılır. Sonra ilgili pin gpioSetMode fonksiyonuyla 
    IN ya da OUT biçiminde konfigüre edilir. Pin'e değer yazmak için gpioWrite fonls,yonu pin'den değer okumak için gpioRead 
    fonksiyonu kullanılmaktadır. İşlemler bittiğinde gpioTerminate fonksiyonu çağrılır. Derleme işlemini yaparken -lpigpio" 
    seçeneği ile bağlama aşamasında kütüphanenin kullanılmasının sağlanması gerekir. Örneğin:

    $ gcc -o sample sample.c -lpigpio 

    Aşağıda GPIO6 numaralı pin'e bağlı LED'i yakıp söndüren bir örnek verilmiştir:

    #include <pigpio.h>

    int main(void) {
        if(gpioInitialise() < 0) return 1;
        
        gpioSetMode(17, PI_OUTPUT);
        
        for(int i = 0; i < 10; i++) {
            gpioWrite(17, 1);
            gpioDelay(500000);
            gpioWrite(17, 0);
            gpioDelay(500000);
        }
        
        gpioTerminate();
        return 0;
    }

    Kütüphanenin daha pek çok özelliği vardır. Ancak yukarıda da belirttiğimiz gibi kullanımı oldukça kolaydır. Kütüphanenin
    dokğmantasytonuna aşağıdaki bağlantıdan erişebilirsiniz:

    https://abyz.me.uk/rpi/pigpio/download.html
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                        142. Ders 13/11/2025 - Perşembe
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bu bölümde UNIX/Linux sistemlerinde seri port haberleşmesi üzerinde duracağız. Bu haberleşmeyi BBB ve Raspberry Pi üzerinde 
    uygulayacağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Seri port haberleşmesi oldukça eskilere dayanmaktadır. Ancak hala bu haberleşme yöntemi geçerliliğini korumaktadır. 
    Seri port haberleşmesi 80 yılların başlarında PC'lere bilgisayar-modem ve bilgisayar-yazıcı haberleşmesi için standart 
    bir biçimde eklenmiştir. Ancak zamanla USB haberleşmesi yaygınlaşınca seri portlar masaüstü bilgisayarlardan ve notebook'lardan
    kaldırılmıştır. Bu kursta da gördüğümüz gibi özel çeviricilerle seri port haberleşmesi USB yoluyla da sağlanmaktadır. 
    Eskiden PC'lerde seri port'lar 9 pin'li erkek konnektörler biçiminde (bunlara DB-9 portu da denilmektedir) bulunduruluyordu. 
    Bu 9 pin'in anlamları şöyledi:

    ╭─────────────╮
    │ ○ ○ ○ ○ ○   │  (pinler dışarı çıkıntılı)
    │  ○ ○ ○ ○    │
    ╰─────────────╯

    Pin 1: DCD (Data Carrier Detect)
    Pin 2: RxD (Receive Data)
    Pin 3: TxD (Transmit Data)
    Pin 4: DTR (Data Terminal Ready)
    Pin 5: GND (Ground/Toprak)
    Pin 6: DSR (Data Set Ready)
    Pin 7: RTS (Request to Send)
    Pin 8: CTS (Clear to Send)
    Pin 9: RI (Ring Indicator)

    Buradaki isimler "bilgisayar-modem haberleşmesi" dikkate alınarak verilmiştir. Haberleşme için minimum kullanılacak
    uçlar şunlardır:

    RxD: Receive Data
    TxD: Transmit Data
    GND: Toprak

    Minimal bağlantıda iki tarafın RxD uçları karşı tarafın TxD uçlarına bağlanmaktadır. Toprak uçları da katşılıklı 
    bağlanmaktadır:

      PC 1 (DTE)                    PC 2 (DTE)
        Erkek                         Erkek
    ╭───────────╮                 ╭───────────╮
    │ ○ ○ ○ ○ ○ │                 │ ○ ○ ○ ○ ○ │
    │  ○ ○ ○ ○  │                 │  ○ ○ ○ ○  │
    ╰───────────╯                 ╰───────────╯
      1 2 3 4 5                     1 2 3 4 5
      6 7 8 9                        6 7 8 9

    Pin 2 (RxD) ─────────────────────────── Pin 3 (TxD)
                    çapraz
    Pin 3 (TxD) ─────────────────────────── Pin 2 (RxD)

    Pin 5 (GND)─────────────────────────── Pin 5 (GND)

    PC'lerdeki seri port'lar RS-232 denilen voltaj standartlarına uygun biçimde üretilmektedir. RS-232 standardında lojik 1 
    lojik 0 için şu gerilim seviyeleri kullanılmaktadır:

    Lojik 0: +3V ile +15V arası, tipik olarak +5V ile +12V
    Lojik 1: -3V ile -15V arası, tipik olarak -5V ile -12V

    Bu yüksek gerilim seviyeleri iki bilgisayar arasında uzun kablolarla (örneğin 20 metre) bağlantı yapılabilmesini 
    sağlamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Seri haberlşme aslında "UART (Universial Asynchronous Receiver and Transmitter)" denilen denetleyicilerle yapılmaktadır.
    Eski PC'lerde UART denetleyicisi olarak "Intel 8250" kullanılıyordu. Sonra "NS 16550" denetleyicileri kullanılmaya başlandı. 
    Artık UART denetleyicileri SoC'ların ya da chipset'lerin içerisinde bulunmaktadır. Klasik UART denetleyicilerinin 
    uçları eskiden RS-232 voltaj seviyelerine yükseltilerek seri port'un pin'lerine veriliyordu. UART denetleyicileri TTL 
    düzeyinde çık veriyordu. TTL çıkışları mikro elektronik uygulamalarında kullanılmaktadır. TTL voltaj seviyeleri tipik 
    olarak şöyledir:

    Lojik 0: 0V - 0.8V 
    Lojik 1: 2V - 5V

    RS-232 çıkışlarını doğrudan TTL düzeyinde çalışan UART denetleyicilerinin uçlarına bağlamayınız. Bunun için RS-232'den 
    TTL'e dönüştürme yapan dönüştürücüler bulunmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Seri port haberleşmesi oldukça yalındır. Haberleşme için iki tarafın UART denetleyicisi eşit hızlarda ve aynı biçimde 
    konfigüre edilir. Sistem programcısı UART denetleyicisine bilgileri byte düzeyinde verir. UART denetleyicisi bu bilgiyi 
    bitlerine ayırır ve TxD ucundan belirlenen hızda kodlar. Gönderici tarafın TxD uzu alıcı tarafında RxD ucuba bağlı olduğu 
    için gönderilen bitler alıcı taraftaki UART tarafından alınmaktadır. Alıcı taraftaki UART bu bitleri birleştirir, byte
    biçimine getirir. Sistem programcısı onu byte olarak alır. Bu haberleşmeye "asenkron (asynchronous)" denmesinin nedeni
    byte'lar arasındaki sürenin değişebilmesindendir. Ancak byte'ların bitleri aynı hızda kodlanıp alınmaktadır. 

    Peki UART haberleşmesinde alıcı taraftaki UART bilginin gönderilmeye başlandığını nasıl anlamaktadır? İşte bilgi 
    gönderilmiyorken TxD hattı lojik 1 seviyesinde tutulur. Bit'ler gönderilme başlanmadan önce hat bir periyot lojik 0'a 
    çekilir. Buna "start bit" denilmektedir. Böylece karşı taraftaki UART bilginin gönderilmeye başlandığını anlar. Sonra 
    iki taraf aynı frekansta bit'leri gönderip alırlar. Ancak hattın yeniden lojik 1 seviyesine çekilerek bırakılması 
    gerekmektedir. İşte en sonunda hattın yeniden lojik 1 seviyesine çekilmesine "stop bit" denilmektedir. Hat lojik 1 
    seviyesine bir periyot değil iki periyot da çekilebilir. Buna da stop bit sayısı denilmektedir. Genellikle 1 stop bit 
    kullanılmaktadır. Ancak alıcının yavaş olduğu durumlarda artık çok seyrek de olsa 2 stop bit kullanılabilmektedir. UART 
    haberleşmesinde gönderen tarafın gönderdiği bitleri alan tarafın düzgün alıp almadığını belirlemek için "parity" hata 
    kontrol biti de data bitlerinden sonra isteğe bağlı gönderilip alınabilmektedir. Parity kullanılmayabilir. Bu durumda 
    data bitlerinden sonra hemen stop bit gönderilir. Parity kullanılacaksa "tek parity (odd parity)" ya da "çift parity 
    (even parity)" biçiminde iki seçenek söz konusudur. Tek parity "data bitlerindeki 1'lerin sayısını tek yapmak için geçerken
    biti", çift parity ise "data bitlerindeki 1'lerin sayısını çift yapmak için gereken biti" belirtmektedir. Örneğin:

    0100 0011 

    Buradaki 8 bitin tek parity'si 0, çift parity'si ise 1'dir. Artık parity kullanımı hemen hemen ortadan kalkmıştır. 

    UART haberleşmesi "full duplex" bir haberleşmedir. Yani UART haberleşmesinde iki taraf da birbirlerine aynı anda bilgi 
    gönderip bilgi alabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Haberleşmenin türü ne olursa olsun hepsinde "akış kontolü (flow control)" denilen bir olgu vardır. Akış kontrolü "alan 
    tarafın gönderen tarafı geçici olarak durdurmasını ve sonra yeniden göndermeye devam ettirmesini sağlayan" bir mekanizmadır. 
    Gönderen tarafın gönderdiği bilgiler alan taraf tarafından hemen işlenemeyebilir. Bazen alan taraf bunları işlemekte 
    yavaş kalabilir. Bu tür durumlarda gönderen tarafın gönderdiği bilgiler bir tamponda bekletilir. Alan taraf bilgileri 
    bu tapon alarak işler. Ancak alan taraf gecikirse bu tampon da taşabilmektedir. O halde alan tarafın gönderen tarafı geçici 
    olarak durdurması gerekmektedir. Tabii alıcı taraf önceden belirlenen hızda bilgiyi alıp işleyebiliyorsa bir sorun oluşmaz. 
    Ancak iletimin güvenli hale getirilmesi için akış kontrolü önerilmektedir. 

    UART haberleşmesinde iki tür akış kontrolü uygulanabilmektedir:

    1) Donanımsal akış kontrolü
    2) Yazılımsal akış kontrolü

    Donanımsal akış kontrolü tipik olarak UART'ın iki ucundan sağlanmaktadır. Bunun için tipik olarak olarak RTS (request to 
    Send) ve CTS (Clear to Send) uçları kullanılmaktadır. Bir RTS ucu diğer tarafın CTS ucuna bağlanmaktadır. Böylece bir 
    taraf RTS ucuna bir işaret gönderdiğinde diğeri bunu CTS ucundan okuyabilmektedir. Yukarıda da belirttiğimiz gibi 
    pin'lere RTS ve CTS isimleri geleneksel bilgisayar-modem haberlemesi dikkate alınarak verilmiştir. Tipik akış kontrolü 
    kontolü şöyle yapılmaktadır: Alan taraf tipik olarak RTS ucunu lojik 1 seviyesinde tutar. Gönderen taraf da CTS ucuyla 
    bu değeri okur. Bu değer lojik 1 olduğu sürece gönderen taraf göndermeye devam eder. Eğer alıcı taraf CTS ucunu lojik 0 
    değerine çekerse gönderen taraf artık bu uç lojik 1 seviyesine  çekilene kadar bekler. Tabii diğer taraf da karşı tarafa 
    aynı biçimde akış kontrolü uygulamaktadır. RTS/CTS akış kontrolü farklı biçimlerde de uygulanabilmektedir. Eski UART 
    denetleyicileri bu RTS/CTS akış kontrolünü donanımsal düzeyde yapmıyordu. Ancak daha sonra pek çok UART devresi bunu 
    donanımsal biçimde de yapar hale gelmiştir. 

    Yazılımsal akış kontrolünde yukarıdaki senaryo elektriksel olarak değil alan tarafın gönderen tarafa özel karakterler
    göndermesiyle sağlanmaktadır. Bunun için kullanılan tipik yazılımsal protokole XON/XOFF protokolü denilmektedir. Alıcı 
    taraf gönderici tarafı durdurmak için XOFF özel karakterini gönderir. Gönderen taraf bu karakteri aldığında göndermeyi 
    durdurur. Alıcı taraf gönderici tarafın devam etmesini sağlamak için XON özel karakterini göndermektedir. XON ve XOFF
    karakteri olarak aşağıdaki karakterler kullanılmaktadır:

    Dec  Hex  Oct  Ctrl   Açıklama
    ───────────────────────────────────────
    17  0x11 021  ^Q     XON  (Devam)
    19  0x13 023  ^S     XOFF (Dur)

    XON/XOFF protokolü tamamen programlama yoluyla oluşturulmaktadır. 

    Peki akış kontrolünde karşı taraf ne zaman durdurulup ne zaman devam ettirilmelidir? Tipik olarak sistem programcıları 
    tahsis ettikleri tampon %70 ile %90 arasında bir doluluk seviyesine geldiğinde karşı tarafı durdurmakta tampon %10 ile 
    %30 civarında bir doluluk seviyesine düştüğünde ise karşı tarafı devam ettirmektedir. 

    Peki sistem programcısı UART'ta çok hızlı veri gönderirse ne olur? İşte UART denetleyicilerinin içerisinde de donanımsal 
    biçimde organize edilmiş bir FIFO tampon vardır. Tabii tampon da dolarsa gönderen taraf UART'a bilgiyi gönderdiği halde 
    UART bunu tamponunda saklayamaz ve bilgi kaçırılabilir. Ancak gönderen taraf zaten UART'ın bunu aldığını anlayabilmektedir. 
    Eski Intel 8250 UART denetleyicilerinde böyle bir donanımsal tampon yoktu. Daha sonra NS 16550 modellerine 16 byte'lık 
    gönderme ve alma tamponları eklendi. Bugünkü SoC içerisindeki UART denetleyicilerinde genel olarak 64'lük ya da 32'lik 
    donanımsal tamponlar bulunmaktadur. USB seri dönüştürücülerde bu tamponların uzunlukları 256 gibi yüksek değerlerdedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda programcının UART denetleyicisine byte verdiğini ondan byte aldığını belirttik. Byte'ın bitlere dönüştürülerek 
    gönderilip alınmasını AURT denetleyicisi yapıyordu. İşte UART terminolojisinde gönderilecek bit öbeğine "data bitleri" 
    denilmektedir. UART denetleyicileri 5, 6, 7, 8 data bitlerini desteklemektedir. Örneğin biz UART denetleyicisini 5 data 
    bit olarak konfigüre edersek ancak ona 0 ile 31 arasında bir değer gönderebiliriz. Peki neden gönderilecek bilgi standart 
    8 bit değil de duruma göre ayarlanabilen bir değerdedir? İşte bunun amacı özel durumlarda hız kanacı sağlamaktır. Örneğin 
    kişi düz metin göndermek isteyebilir. Bu durumda 5 bit yetebilir. Daha az bit gönderildiği için daha hızlı bir iletişim 
    sağlanır. Ancak tabii günümüzde UART data bitlerinin sayısı 8 olacak biçimde konfigüre edilmektedir. 
    Bu durumda temel UART ayarları şunlardan olulmaktadır:

    - Data bitlerinin sayısı
    - Stop bitlerinin sayısı (1 ya da 2)
    - Parity kullanılacak mı? Kullanılacaksa tek parity mi çift parity mi?
    - Gönderim alma hızı (saniyedeki bit sayısı)

    UART'ın gönderim alma hızı "baud" terimiyle ifade edilmektedir. Tabii bunun içerisine start bit ve stop bit varsa parity 
    biti de dahildir. Yani örneğin data bitlerinin sayısı 8 ise aslında byte'lar arasında boşluk olmasa bile 10 bit ya da 11
    ya da 12 bit iletim yapılmaktadır. Haberleşmede iletimi hedeflenen bilginin kendisine İngilizce "payload" da denilmektedir. 
    Örneğin data bitlerinin sayısı 8 ise payload 8 bittir. Ancak aslında daha fazla bit karşı tarafa gönderilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde seri port programlaması üç biçimde yapılabilmektedir:

    1) Aygıt sürücü yazmak yoluyla ya da mevcut aygıt sürücüleri doğrudan kullanmak yoluyla
    2) Standart POSIX termios kütüphanesini kullanmak 
    3) Özel kütüphaneleri kullanmak
 
    Linux sistemlerinde seri port üzerinde işlemler yapan aygıt sürücüler zaten çekirdekte bulunmaktadır. Bunlara "tty" 
    aygıt sürücüleri denilmektedir. Eskiden aptal terminaller (dummy terminals) seri port'larla ana bilgisayara bağlanıyordu. 
    Dolayısıyla UNIX/Linux sistemlerinde terminal aygıt sürücülerle seri port'u kontrol eden aygıt sürücülerin isimleri 
    tty (teletype terminal) ile başlatılarak verilmiştir. Seri port'u kontrol eden aygıt sürücülere ilişkin aygıt dosyaları 
    "/dev" dizinin altında "ttySN" (burada N bir sayı belirtmektedir) ismiyle ya da "ttyUSBN" ismiyle bulunmaktadır. "ttyUSB" 
    aygıt dosyaları USB-Seri port dönüştürücülerini kullanan aygıt sürücülere ilişkin aygıt dosyalarıdır. BBB'de ve Raspberry 
    Pi'da seri port'a ilişkin aygıt dosyaları "ttySN" biçimindedir. BBB'deki "tty" ile başlayan aygıt sürücülere dikkat ediniz:

    $ ls /dev/tty*

    /dev/tty    /dev/tty15  /dev/tty22  /dev/tty3   /dev/tty37  /dev/tty44  /dev/tty51  /dev/tty59  /dev/tty9
    /dev/tty0   /dev/tty16  /dev/tty23  /dev/tty30  /dev/tty38  /dev/tty45  /dev/tty52  /dev/tty6   /dev/ttyGS0
    /dev/tty1   /dev/tty17  /dev/tty24  /dev/tty31  /dev/tty39  /dev/tty46  /dev/tty53  /dev/tty60  /dev/ttyS0
    /dev/tty10  /dev/tty18  /dev/tty25  /dev/tty32  /dev/tty4   /dev/tty47  /dev/tty54  /dev/tty61  /dev/ttyS1
    /dev/tty11  /dev/tty19  /dev/tty26  /dev/tty33  /dev/tty40  /dev/tty48  /dev/tty55  /dev/tty62  /dev/ttyS2
    /dev/tty12  /dev/tty2   /dev/tty27  /dev/tty34  /dev/tty41  /dev/tty49  /dev/tty56  /dev/tty63  /dev/ttyS3
    /dev/tty13  /dev/tty20  /dev/tty28  /dev/tty35  /dev/tty42  /dev/tty5   /dev/tty57  /dev/tty7   /dev/ttyS4
    /dev/tty14  /dev/tty21  /dev/tty29  /dev/tty36  /dev/tty43  /dev/tty50  /dev/tty58  /dev/tty8   /dev/ttyS5

    Burada ttyS0, ttyS1, ttyS2, ttyS3, ttyS4 ve ttyS5 seri port'ları yöneten aygıt sürücüye ilişkin aygıt dosyalarıdır:

    $ ls /dev/ttyS* -l
    crw--w---- 1 root tty     4, 64 Feb  4 22:05 /dev/ttyS0
    crw-rw---- 1 root dialout 4, 65 Feb  4 22:05 /dev/ttyS1
    crw-rw---- 1 root dialout 4, 66 Feb  4 23:00 /dev/ttyS2
    crw-rw---- 1 root dialout 4, 67 Feb  4 22:05 /dev/ttyS3
    crw-rw---- 1 root dialout 4, 68 Feb  4 22:05 /dev/ttyS4
    crw-rw---- 1 root dialout 4, 69 Feb  4 22:05 /dev/ttyS5

    Bu aygıt dosyalarının hepsinin majör numaralarının aynı olduğuna dikkat ediniz. Yani toplamda bir tane seri port aygıt 
    sürücüsü vardır. Aynı sürücü bireden fazla seri port'u yönebilmektedir. Aslında terminalleri kontrol eden aygıt dosyalarının 
    da majör numaraları aynıdır. Yani söz konusu aygıt sürücü hem terminalleri hem de seri port'ları yönetmektedir. 

    Seri port'a ilişkin aygıt sürücülerin yukarıda belirttiğimiz aygıt dosyaları open fonksiyonuyla açılıp read fonksiyonuyla 
    okunduğunda seri port'taki RxD ucundan gelen bilgiler okunmuş olur. Benzer biçimde aygıt dosyalarına write fonksiyonula 
    yazma yapıldığında aslında yazılanlar seri port'un TxD uçlarından gönderilmektedir. 

    Seri port'u set etmek için "ttySN" aygıt sürücüsüne ioctl komutlarının gönderilmesi gerekir. Yani bu aygıt sürücüler 
    yoluyla seri port'a okuma yazma yapmak kolay olsa da diğer işlemleri yapmak oldukça zahmetlidir. İşte bunun için bu 
    sürücüleri kullanan daha yüksek seviyeli "termios" denilen standart kütüphane de bulundurulmuştur. termios kütüphanesindeki 
    fonksiyonlar aslında arka planda ioctl koutları göndererek birtakım işlemleri seri port'u kontrol eden aygıt sürücülere 
    yaptırmaktadır. Uygulama programcılar "taşınabilir olduğu gerekçesiyle" bu "termios" kütüphanesini tercih etmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    BBB'lerde toplam 6 tane UART denetleyicisi ve uç takımı vardır. Bunlardan biri (sistem boot edilmeden önce terminal 
    olarak kullanılan çıkış) 6 pinli GPIO P9 başlığının yanında bulunmaktadır. Geri kalan 5 tanesi GPIO pin'lerinin içerisinde 
    multiplexed edilmiştir. Yani bu 5 UART uçları GPIO olarak da UART olarak da konfigüre edilebilmektedir. Dolayısıyla GPIO 
    soketlerindeki UART uçlarını kullanmadan önce bu uçların GPIO olarak değil de UART olarak konfigüre edilmesi gerekir. 
    
    Biz kursumuzda teme denemeleri UART2 ile UART4 uçlarını karşılıklı bağlayarak yapacağız. Dolayısıyla örneğin UART2'den
    bilgi gönderdiğimizde onu UART4'ten, UART4'ten bilgi gönderidğimizde ise onu UART2'den okuyabileceğiz.  
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                        143. Ders 18/11/2025 - Salı
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    BBB'deki UART ile ilgili uçlar şunlardır:

    ┌───────┬─────────┬─────────┬─────────┬─────────┐
    │ UART  │ RXD pin │ TXD pin │ CTS pin │ RTS pin │
    ├───────┼─────────┼─────────┼─────────┼─────────┤
    │ UART1 │ P9_26   │ P9_24   │ P9_20   │ P9_19   │
    │ UART2 │ P9_22   │ P9_21   │ P8_37   │ P8_38   │
    │ UART3 │ —       │ P9_42   │ —       │ —       │
    │ UART4 │ P9_11   │ P9_13   │ P8_35   │ P8_33   │
    │ UART5 │ P8_38   │ P8_37   │ P8_31   │ P8_32   │
    └───────┴─────────┴─────────┴─────────┴─────────┘

    UART3 yalnızca TxD uçlarına sahiptir. 

    BBB^'deki UART uçları multiplexed edildiği için önce onları UART biçiminde konfigüre etmek gerekir. Bu konfigürasyon 
    aygıt ağacı dosyası üzerinden kalıcı biçimde yapılabilir. Programlama yoluyla GPIO konusunda da bahsettiğimiz gibi 
    GPIO denetleyicisinin ilgi yazmaçları set edilerek de yapılabilir. Aslında BBB'lerin orijinal imajlarında (sonradan da 
    yüklenebilir) "config-pin" isimli programla bu konfigürasyon kolay biçimde yapılabilmektedir. Biz burada "config-pin" 
    programından faydalanacağız. Tabii bunu kalıcı hale getirmek için bu programı "systemd" ile otomatik çalışacak hale 
    de getirebilirsiniz. 

    Belli bir pin'i belli amaçlarla konfigüre etmek için "config-pin" programı şöyle kullanılır:

    config-pin <pinin_başlık_numarası> <yeni_işlevi>

    Örneğin biz UART2 ve UART3 kullanacak olalım. Bunlara ilişkin uçları UART biçiminde aşağıdaki gibi konfigüre ederiz:

    $ config-pin P9_22 uart
    $ config-pin P9_21 uart
    $ config-pin P9_11 uart
    $ config-pin P9_13 uart

    Bağlantınızın doğru yapıldığını ve GPIO uçlarının doğru konfigüre edildiğini test etmek için BBB'ye "picocom" gibi 
    "minicom" gibi seri port üzerinde işlemler yapan programları yükleyebilirsiniz. Default durumda zaten BBB'deki tüm 
    UART'ların ayarları aşağıdaki gibidir:

    Baud rate: 115200 
    Veri bitleri: 8 bit 
    Parity: Yok (None) 
    Stop bit: 1 bit 

    Testi aslında hiç seri port programı kullanmadan terminalden de yapabiliriz. BBB üzerinde iki terminal açıp birinci 
    terminalden okuma yaparsak ikinci terminalden de yazma yaparsak yazılanlar okunacaktır:

    Birinci terminal:

    $ cat /dev/ttyS4
    
    İkinci terminal:
    
    $ echo "test" > /dev/ttyS2

    Biz kurusumuzda taşınabilir POSIX standartlarında tanımlanmış olan "termios" arayüzünü kullamacağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    termios arayüzü ile seri port işlemleri yapmak için ilk yapılacak şey seri port aygıt sürücüsünü open fonksiyonu ile 
    açmaktır. UNIX/Linux sistemlerinde seri port'lar bir çeşit terminal gibi ele alındığı için aygıt dosyası açılırken 
    O_NOCTTY bayrağının açış moduna eklenmesi gerekmektedir. Seri port blokeli modda ya da blokesiz modda açılabilmektedir. 
    Default mod blokeli moddur. Eğer seri port'u blokesiz modda açmak istiyorsanız ayrıca O_NONBLOCK bayrağını da açış modunda 
    bulundurmalısınız. Blokeli modda read işlemi sırasında seri port'a bilgi gelene kadar read fonksiyonu blokede beklemeye 
    yol açmaktadır. Ancak seri port'tan blokelei okumalarda read fonksiyonunda talep edilen byte miktarının tamamı okunana 
    kadar değil en az 1 byte okunana kadar bloke oluşmaktadır. Seri port'a write fonksiyonuyla yazılanlar aygıt sürücü 
    tarafından bitlerine ayrıştırılarak TxD ucundan gönderilmektedir. Gönderen taraf karşı tarafta alıcı olup olmadığını 
    bilemez. Blokeli modda write fonksiyonu için herhangi bir bloke söz konusu olmamaktadır. 
    
    Örneğin açış şöyle yapılabilir:

    if ((fd = open("/dev/ttyS2", O_RDWR|O_NOCTTY)) == -1) 
        exit_sys("open");

    Burada biz read fonksiyonu ile okuma yapmak istediğimizde artık seri port'a en az 1 byte yazılana kadar bloke oluşacaktır:
    
    if ((result = read(fd, buf, 4)) == -1)
        exit_sys("read");

    Peki yazan taraf seri port'a yazma yaptığında okuyan taraf o anda read fonksiyonuyla okuma yapmazsa gönderilmiş olan 
    bilgiler kaybedilir mi? Saf bir seri port haberleşmesinde karşı taraf bilgiyi almazsa bilgi kaybolur. Ancak UNIX/Linux 
    sistemlerindeki aygıt sürücüler karşı tarafın gönderdiği bilgileri okuyan taraf için tamponlamaktadır. Yani okuyan 
    taraf aslında pin'i değil tamponlanmış olan bilgileri okumaktadır. Zaten zaman paylaşımlı çalışmanın yapıldığı Linux 
    gibi Windows gibi işletim sistemlerinde başka bir çalışma modelini uygulamak da mümkün değildir. Çünkü seri port'u okuyan 
    program aslında sürekli çalışır durumda olamaz. İşletim sistemi onu zaman pyalaşımlı biçimde parçalı olarak çalıştırmaktadır. 
    Yani aslında bu sistemlerde sürekli bir izleme de mümkün olamamaktadır. Burada aklınza şu soru gelecektir: "Peki aynı 
    durum seri port'u kontrol edem aygıt sürücü için de geçerli değil midir? Aygıt sürücüler nasıl gelenleri kaçırmadan 
    okuyabiliyor?". İşte aslında seri haberleşmede sıklıkla kesme yöntemi kullanılmaktadır. UART denetleyicileri byte'ı 
    aldıktan sonra onu kendi içerisindeki FIFO tampona yerleştirip kesme oluşturabilmektedir. Böylece aygıt sürücünün kesme 
    kodu devreye girip gönderilen byte'ı kaçırmadan alabilmektedir. 
    
    Burada alıcı tarafın tampon sistemi hakkında bir açıklama yapmak istiyoruz. Burada bahsettiğimiz tampon UART işlemcisinin 
    içinde bulunan FIFO tampon değildir. O tampon elektiriksel olarak gelenlerin kaçırılmaması için oluşturulmuş olan mini 
    bir tampondur. Burada asıl tamponlama sürücü tarafındna oluşturulan UART'tan alınan byte'ların yerleştirildiği tampondur. 
    Bu tampon Linux'ta kullanılan seri port aygıt sürücülerinde genellikle 4K büyüklüktedir. Eğer bu 4K büyüklük dolduğu halde
    alıcı taraf okuma yapmazsa "overrun" durumu oluşur. Yeni gelenler kaynedilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Seri port aygıt dosyasını açıp hemen okuma ve yazma yapmaya çalışmak doğru teknik değildir. Çünkü seri port'un ayarları 
    default durumda olabilir ya da ayarlar daha önce çalıştırılmış olan başka bir program tarafından değiştirilmiş olabilir. 
    O halde programcının ilk yapacağı şey seri port'u uygun değerlerle set etmektir. Peki seri port nasıl ayarlanmaktadır?

    termios arayüzünde bütün ayar bilgileri tcgetattr fonksiyonuyla elde edilip tcsetattr fonksiyonuyla set edilmektedir. 
    Ancak termios arayüzünde seri port'un ayarları yalnızca "data bitlerinin sayısından, hızından, stop bit sayısından, 
    parity durumundan" oluşmamaktadır. Bu arayüzde seri port ayarları aygıt sürücüye özgü pek çok başka unsurları da 
    içermektedir. Bu nedenle termios arayüzünde ayar bilgisini sıfırdan oluşturmak zahmetli olduğu için programcılar önce 
    mevcut ayar bilgilerini tcgetattr fonksiyonu ile alıp o ayar bilgilerinden dilediklerini değiştirip yeni ayar bilgilerini
    tcsetattr fonksiyonuyla set etmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                        144. Ders 20/11/2025 - Perşembe
---------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    tcgetattr ve tcsetattr fonksiyonlarının prototipleri şöyledir:

    #include <termios.h>

    int tcgetattr(int fd, struct termios *termios_p);
    int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);

    tcgetattr fonksiyonu aygıt sürücünün kullanacağı tüm ayar bilgilerini termios isimli bir yapı nesnesinin içerisine 
    yerleştirmektedir. Fonksiyonun birinci parametre aygıt dosyasına ilişkin dosya betimleyicisini ikinci parametresi ise 
    yerleştirme işleminin yapılacağı termios yapısı türünden nesnenin adresini almaktadır. Fonksiyon başarı durumunda 0 
    değerine başarısızlık durumunda -1 değerine geri dönmektedir. 

    tcsetattr fonksiyonu da termios isimli yapı türünden nesnenin içinde bulunan ayar bilgileri ile aygıt sürücü ayarlarını 
    set etmektedir. Fonksiyonun birinci parametresi aygıt dosyasına ilişkin dosya betimelyeicisini belirtmektedir. İkinci 
    parametre TCSANOW geçilirse ayar o anda hemen değiştirlir. Bu parametreye TCSADRAIN değeri geçilirse gönderilmek üzere 
    beklenen byte'lar varsa önce onlar gönderilir, ayarlar bekleyen gönderilerin hepsi yapıldıktan sonra devreye girer. 
    Eğer bir gönderim varsa bu seçenğin kullanılması daha uygundur. Bu parametreye girilecek diğer bir değer de TCSAFLUSH 
    değeridir. Bu değer "gönderilmek üzere beklenen byte'ların hepsi gönderildikten sonra ayarın set edeilmesini sağlar. 
    Ancak gelmiş fakat henüz read fonksiyonu ile okunmamış bilgilerin de tamamen tampondan atılmasına yol açar. Tabii eğer 
    seri port daha iletişime başlanmadan set ediliyorsa (zaten tipik olarak böyledir) bu değerlerden herhangi biri kullanılabilir. 
    Fonksiyonun son parametresi set edilecek ayr bilgilerinin bulunduğu termios türünden yapı nesnesinin adresini belirtmektedir. 

    termios yapısı GNU libc kütüphanesinde şöyle bildirilmiştir:

    struct termios
    {
        tcflag_t c_iflag;		/* input mode flags */
        tcflag_t c_oflag;		/* output mode flags */
        tcflag_t c_cflag;		/* control mode flags */
        tcflag_t c_lflag;		/* local mode flags */
        cc_t c_line;			/* line discipline */
        cc_t c_cc[NCCS];		/* control characters */
        speed_t c_ispeed;		/* input speed */
        speed_t c_ospeed;		/* output speed */
    };

    Yaının c_iflag elemanı gelen bilgilere ilişkin ayarlamalar için, c_oflag elemanı gönderilen bilgilere ilişkin ayarlamar 
    için, c_cflag elemanı ise genel kontrol bilgilerine ilişkin ayaralamalar için kullanışmaktadır. Yapının programcı 
    tarafından dolsurulması gereken elemanları şunlardır:

    tcflag_t  c_iflag       Input modes
    tcflag_t  c_oflag       Output modes
    tcflag_t  c_cflag       Control modes
    tcflag_t c_lflag;		local mode flags 
    cc_t      c_cc[NCCS]    Control characters

    Tabii yukarıda da belirttiğimiz gibi aslında bu elemanların sıfırdan doldurulması yerine önce tcgetattr fonskiyonu ile
    mevcut ayarları elde edip onun üzerinde bazı değişiklkleri yapılması tercih edilmektedir. Örneğin:

    struct termios tios;
    ...

    if (tcgetattr(fd, &tios) == -1)
        exit_sys("tcgetattr");

    /* değişiklikler */

    if (tcsetattr(fd, TCSANOW, &tios) == -1)
        exit_sys("tcsetattr");
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    termios yapısındaki c_iflag, c_oflag ve c_cflag elemanları bitsel düzeyde anlamlı olan bayraklar içermektedir Yani bu 
    elemanlara tüm bitleri 0 olan tek biti 1 olan sembolik sabitler bit düzeyinde OR işlemine sokularak girilmektedir. 
    Bayrakları belirten tcflag_t türü işaretsiz bir tamsayı türü biçiminde typedef olmalıdır. 

    Seri port'un hızının ayarlanması için termios yapısının ilgili elemanlarına set işlemi yapan cfsetispeed ve cfsetospeed 
    fonksiyonları kullanılmaktadır. Bu fonksiyonlar seri port'un hızını set etmemektedir. Bu bilgiyi termios yapı nesnesinin 
    içerisine yerleştirmektedir. Ser port'ın hızının termios yapısının elemanlarına manuel yerleştirilmediğine bu fonksiyonlar 
    yoluyla yerleştirildiğine dikkat ediniz. Fonksiyonların prototipleri şöyledir:

     #include <termios.h>

    int cfsetispeed(struct termios *termios_p, speed_t speed);
    int cfsetospeed(struct termios *termios_p, speed_t speed);

    Fonksiyonların birinci parametreleri yerleştirme işleminin yapılacağı termios yapı nesnesinin adresini, ikinci parametreleri 
    de hız değerlerini almaktadır. Bu fonksiyonlara hız değerleri sembolik sabit biçiminde geçirilmektedir. Bu sembolik sabitler 
    şunlardır:

    B0
    B50
    B75
    B110
    B134
    B150
    B200
    B300
    B600
    B1200
    B1800
    B2400
    B4800
    B9600
    B19200
    B38400
    B57600
    B115200
    B230400
    B460800
    B500000
    B576000
    B921600
    B1000000
    B1152000
    B1500000
    B2000000
    B76800
    B153600
    B307200
    B614400
    B2500000
    B3000000
    B3500000
    B4000000

    BBB içerisindeki seri port'lar 3.6864 MBPS hızlarını desteklemektedir.   
    
    Fonksiyonlar başarı durumunda 0 değerine başarısızlık durumunda -1 değerine geri dönmektedir. Hız ayarlamasını şöyle 
    yapabiliriz:

    if (cfsetispeed(&tios, B115200) == -1)
        exit_sys("tcgetattr");

    if (cfsetospeed(&tios, B115200) == -1)
        exit_sys("tcgetattr");

    Şimdi de data bitlerinin sayısı, stop bit sayısı, parity kontrolünün yapılıp yapılmayacağı gibi temel ayarları oluşturalım.
    Bu temel ayarlar termios yapısının c_cflag elemanı set edilerek yapılmaktadır. Parity için PARENB (parity enable) isimli 
    sembolik sabit kullanılmaktadır. Biz parity gönderilmesini ve alınmasını istemiyorsak (artık parity kontrolü neredeyse 
    hiç uygulanmamaktadır) c_cflag içerisindeki ilgili biti aşağıdaki gibi sıfırlamalıyız:

    tios.c_cflag &= ~PARENB;

    Anımsacağı gibi stop bit sayısı 1 ya da 2 olabilir. Ayarlamayı basitleştirmek için CSTOPB bayrağı bulundurulmuştur. Bu 
    bayrak set edilirse 2 stop bit clear edilirse 1 stop bit kullnılır. Artık hemen her zaman 1 stop bit kullanılmaktadır. 
    1 stop bit için ilgili bayrağı şöyle sıfırlayabiliriz:

    tios.c_cflag &= ~CSTOPB;

    Data bitlerinin sayısı anımsanacağı gibi 5, 6, 7 ya da 8 bit olabiliyordu. Data bitlerinin sayısını belirlemek için c_cflag 
    elemanında birden fazla bit bulunduurlmuştur. Bu nedenle önce o birden fazla bitin sıfırlanması sonra onların set edilmesi 
    gerekir. Bu işlem de şöyle yapılabilir:

    tios.c_cflag &= ~CSIZE;     
    tios.c_cflag |= CS8;     

    Buradaki CSIZE data bitleri için ayrılan alanın bit uzunluğu kadar bitin 1 olduğu diğer bitlerin 0 olduğu bir sembolik 
    sabittir. Böylece ilk satır ile o bitler sıfırlanmıştır. Sonra da CS8 sembolik sabiti ile bit OR işlemi yapılarak o 
    bitler uygun biçimde set edilmiştir. Data bitleri için kullanılan sembolik sabitler şunlardır:

    CS5
    CS6
    CS7
    CS8

    Biz yalnızca temel ayarlamaları yapmış olduk. Şimdi termios için gerekebilecek diğer ayarların nasıl yazıldığını görelim.

    Öncelikle RTS/CTS akış kontrolü uygulanmayacaksa (genellikle uygulanmaz) bu durum c_cflag değişkeninde belirtilmelidir. 
    Bu akış kontrolü için CRTSCTS sembolik sabiti kullanılmaktadır. O halde bunun kapatrılması işlemi şöyle yapılabilir:
    
    tios.c_cflag &= ~CRTSCTS;

    Anımsanacağı gibi akış kontrolü RTS/CTS uçlarından donanımsal biçimde yapılabileceği gibi XON/XOFF denilen yöntemle yazılımsal
    bir biçimde de yapılabilmektedir. Peki akış kontrolü uygulandığında alıcı tarafın aygıt sürücü tamponu dolduğunda alıcı 
    taraf gönderen tarafı durduracağına göre gönderen tarafta write fonksiyonları çağrıldığında ne olacaktır? İşte yalnızca
    alım işlemi için değil gönderim işlemi için de bir tampon kullanılmaktadır. Linux sistemlerinde bu gönderim tamponu da 
    4096 byte uzunluktadır. Gönderen taraf durdurulduğunda gönderen tarafın write ile gönderdikleri gönderen taraftaki gönderme 
    tamponunda biriktirilir. Gönderme akış kontrolğnde devam ettrildiğinde bu tampondakiler öncelikle gönderilir. Peki gönderim 
    tamponu dolarsa ne olur? İşte bu durumda Linux terminal aygıt sürücüleri eğer blokeli işlem yapılıyorsa write fonksiyonunda 
    bloke oluşturmaktadır. Ta ki gönderme tamponun yer açılana kadar.

    XON/XOFF protokolünün açılması ya da kapatılması c_cflag elemanıyla yapılmamaktadır. termios tasarımında XON/XOFF gönderme
    ve almayla ilgili olduğu için bu akış kontrolü c_iflag elemanıyla kontrol edilmek istenmiştir. XON/XOFF akış kontrolü için
    üç sembolik sabit bulunmaktadır: IXON, IXOFF ve IXANY. Maalesef burada yanlış anlaşılmalara izin verecek hatalı bir isimlendirme
    kullanılmıştır. IXON bayrağı set edilirse gönderim sırasında karşı taraftan XOFF karakteri gönderildiğinde gönderme durdurulur,
    karşı taraftan XON karakteri geldiğinde gönderme devam ettirilir. Yani IXON bayrağı gönderim sırasında karşı tarafın gönderdiği 
    XON/XOFF karakterlerinin dikkate alınmasını sağlamaktadır. IXOFF bayrağı ise bunun tam tersidir. Yani alım yapılırken alım 
    yapanın tamponu dolduğunda karşı tarafa XOFF ve XON karakterlerinin gönderilmesini sağlamaktadır. Zaten genellikle XON/XOFF 
    protokolü kullanılacaksa bu iki bayrak veraber açılır. Tabii tek yönlü haberleşmede bu ikisinin de set edilmesine gerek yoktur. 
    IXANY bayrağı XON ve XOFF özel karakterleri yerine herhangi bir karakterle durdurma ve devam etmenin sağlanması için kullanılmaktadır. 
    Burada bir noktaya dikkatinizi çekmek istiyoruz. XON/XOFF protokolündeki XON ve XOFF karakterleri ASCII tablosundaki kontrol 
    karakterleridir. Dolayısıyla bunlar görüntülenebilir (printable) değildir. Binary haberleşme söz konusu olduğunda XON ve XOFF 
    karakterleri gönderilecek byte'ın içinde bulunuyor olabilir. Aygıt sürücüler bu byte'ları aldıklarında protokol işlemi 
    yaptıklarından dolayı ancak bu sorun escape'lemekle çözülebilir. Ya da binary haberleşmelerde XON/XOFF akış kontrolü hiç 
    kullanılmaya da bilir. IXANY bayrağı yalnızca IXON kullanıldığında anlam kazanmaktadır. Bu durumda gönderen taraf XOFF 
    karakterini aldığında göndermeyi durdurur. Ancak gönderimin yeniden başlaması için XON karakteri değil karşı taraftan 
    herhangi bir karakterin alınması yeterli olmaktadır. 

    tios.c_iflag &= ~(IXON | IXOFF | IXANY); 

    Buradaki elemanın c_cflag elemanı olmadığına c_iflag elemanı olduğuna dikkat ediniz. 

    Terminal aygıt sürücüsü bazı karakterler gönderildiğinde onları karşı tarafa bazı dönüştürmeler yaparak gönderebilmektedir. 
    Bunun yapılıp yapılmayacağı termios yapısının c_oflag değişkenindeki OPOST biti ile ayarlanmaktadır. Eğer bu bit 0 ise 
    aygıt sürücü böyle bir dönüştürme yapmaz, eğer bu bit 1 ise bu dönüştürme yapılmaktadır. Genellikle seri port haberleşmesinde 
    böyle bir dönüştürmenin yapılması istenmez. Biti aşağıdaki gibi sıfırlayabilirziniz:

    tios.c_oflag &= ~OPOST;  
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                            145. Ders 25/11/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Seri port "kanonik mod (canonical mode)" denilen bir mod etkin hale geitirilirse alma sırasında karşı taraf '\n' karakterini 
    göndere kadar read fonksiyonu geri dönmez.Yani kanonik mod "en az bir satır okuyana kadar bekle" anlamına gelmektedir. 
    Kanonik mod terminaller de sıkça kullanılmaktadır. Ancak seri port haberleşmesinde fazlaca kullanılmamaktadır. Kanonik 
    modun göndermeyle bir ilgisi yoktur. Yalnızca almayla ilgisi vardır. Yani kononik mod açık olsa bile gönderme sırasında 
    '\n' karakteri beklenmez. Yukarıda da belirttiğimiz gibi genellikle seri haberleşmede bu kanonik mod "belki açıktır" diye 
    kapatılmaktadır. Kanonik c_lflag elemaının ICANON bitiyle kontrol edilmektedir. Dolayısıyla kanonik modun kapanması şöyle
    yapılabilir:

    tios.c_lflag &= ~ICANON;

    Kanonik modun etkin olduğu durumda read fonksiyonunda az sayıda byte'ın okunmak istendiği durumda bile fonksiyonun blokesinin
    çözülmesi için '\n' karakterinin alınmış olması gerekir. Örneğin kanonik modda aşağıdaki gibi bir read çağrısı yapılmışolsun:

    result = read(fd, buf, 10);

    Burada karşı taraf 20 byte göndermişolsun ancak bu 20 byte'ın içerisinde '\n' karakteri bulunmasın. İşte yine read fonksiyonu 
    blokede beklemeye devam edecektir. Karşı taraf '\n' karakterini gönderdiğinde read fonksiyonunun blokesi çözülecek ve 
    fonksiyon 10 byte'ı okuyup geri dönecektir. Tabii bu durumda read fonksiyonunun okuduğu byte'ların sonunda '\n' karakteri 
    bulunmayacaktır. 

    termios yapısının c_lflag elemanının ECHO isimli biti gönderilen karakterlerin aynı zamanda ekranda da görüntülenip 
    görüntülenmeyeceğini belirtmektedir. Eğer bu bit 1 yapılırsa seri port'a gönderilen karakter aynı zamanda ekranda da 
    görüntülenir. Eğer bu 0 yapılırsa seri porta gönderilen karakterler ekran görüntülenmez. Terminal haberleşmesinde için 
    ECHO anlamlı olsa da seri port haberleşmesinde gönderilen karakterlerin echo yapılması tercih edilmez. Bu nedenle programcılar
    bu ECHO bayrağını da resetlemektedir. Echo işlemleriyle ilgili diğer bir bit de ECHOE isimli bittir. Eğer bu bir 1 
    yapılmışsa bu durumda gönderilen karakterleri içerisinde "backspace karakteri" varsa bu karakter karşı tarafa gönderilmez. 
    Sanki backspace tuluna basılmış gbi ondan önceki karakter silinmesine yol açar. Genellikle seri port haberleşmesinde bu 
    bit de reset edilmektedir:

    tios.c_lflag &= ~(ECHO|ECHOE);

    Tabii aslında ICANON biti de bu işleme dahil edilerek bunların hepsi tek hamlede de yapılabilir:

    tios.c_lflag &= ~(ICANON|ECHO|ECHOE);
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    c_flag elemanının CREAD biti eğer 0'lanırsa bu durumda UART'a RxD ucundan gelen bilgiler dikkate alınmaz. Dolayısıyla 
    reda yapılsa bile bir şey okunamaz. Tek yönl haberleşmelerde CREAD biti çok seyrek de olsa sıfırlanabilmektedir. Ancak 
    genel uygulamalarda böyle bir şey istenmez. Dolayısıyla bu CREAD biti 1'lenir. CREAD biti olduğuna göre CWRITE isimli 
    bir bitin de olnası gerektiğini düşünebilirsiniz. Ancak böyle bir bit yoktur. Yani TxD ucunun pasif hale getirilmesi 
    mümkün değildir. Bu bti aşağıdaki gibi 1'leyebiliriz:

    tios.c_flag |= CREAD;

    c_flag elemanındaki diğer önemli bir bit de CLOCAL bitidir. Bu bit 0 ise aygıt sürücü modem haberleşmesi yapıldığını 
    varsaymaktadır. Modem haberleşmesinde başka uçlar da devreye girmektedir ve bit 1'lenirse o uçlar da kullanılıyormuş 
    gibi bir etki oluşur. Burada "local" sözcüğü "modem değil seri port haberleşmesi" anlamına gelmektedir. Dolayısıyla 
    kesinlikle bu bitin de 1'lenmesi gerekmektedir:

    tios.c_flag |= CLOCAL;

    Tabii genellikle programcılar CREAD ve CLOCAL bitlerini tek bir deyiöle birlikte 1'lerler:

    tios.c_flag |= CREAD|CLOCAL;
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Termios arayüzünde seri port'un set edilmesinde VMIN ve VTIME denilen iki değer de kullanılmaktadır. VMIN ve VTIME sembolik 
    sabitleri aslında termios yapısının c_cc dizisi için indeks belirtmektedir. Yani bu değerler aşağıdaki gibi set edilmelidir:

    tios.c_cc[VMIN] = val1;
    tins.c_cc[VTIME] = val2;

    c_cc dizisinin VMIN elemanı read ile blokeli modda port'un okunması durumunda "en az kaç byte geldiğinde bloke çözülsün" 
    sorusunun yanıtı için kullanılmaktadır. Örneğin

    tios.c_cc[VMIN] = 5;

    Böyle ayrlamada biz read fonksiyonu ile seri port'tan 10 byte okumak isteyelim. Karşı taraf seri port'a 2 byte göndermiş
    olsun. İşte bizim read fonksiyonumuz henüz geri dönmez. En az 5 byte geldiğinde geri döner. (Tabii zaman paylaşımlı bir 
    çalışma söz konusu olduğuna göre ve aygıt sürücü seri port'u byte geldiğinde kesme tekniği ile okuduğuna göre read 
    fonksiyonu 5'ten daha fazla byte'ı da okuaybilir.) Eğer bu örnekte okuyan taraf 3 byte okumak isteseydi tabii üç byte 
    geldiğinde read fonksiyonun blokesi çözülecekti. Yani bu durumda talep edilen miktar buradaki VMIN değerinden küçükse 
    VMIN kadar byte'ın gelmesi beklenmemektedir. Anımsanacağı gibi borulardan ve soketlerden blokeli okuma sırasında bloke 
    "en az 1 byte geldiğinde" sonlanmaktadır. İşte programcılar seri port söz konusu olduğunda genellikle VMIN değerini 1 
    olarak belirlemektedir. Bu durumda port'ta hiç bilgi gelmezse bloke devam edecek, en az 1 byte gelirse bloke sonlanacaktır. 
    Bu değer 0 yapılırsa adeta blokesiz okuma gibi bir durum oluşmaktadır. Bu değerin 0 olmasının anlamı VTIME değerine bağlı 
    olarak değişebilmektedir. 

    VTIME değeri "eğer VMIN koşulu sağlanmamışsa read fonksiyonu en fazla kaç milisaniye blokede beklesin?" sorusunun yanıtını 
    oluşturmaktadır. Bu tür zamansal değerlere "zaman aşımı (timeout)" denildiğini anımsayınız. Örneğin VMIN değeri 5, VTIME 
    değer 5000 olsun. Seri porta da 2 byte gelmiş olsun. Normalde read fonksiyonun en az 5 byte okuyana kadar bloke olması 
    gerekirdi. Ancakl VTIME değeri 5000 girildiği için 5 byte okunmasa bile en fazla 5 saniye sonra bloke çözülecektir. VTIME 
    için 0 değeri özel bir değerdir. VMIN değeri ile VTIME değerinin kombinasyonları aşağıdaki anlamlara gelmektedir:

    ┌────────┬────────┬──────────────────────────────────────────────┐
    │ VMIN   │ VTIME  │ Davranış                                     │
    ├────────┼────────┼──────────────────────────────────────────────┤
    │ 0      │ 0      │ Tam non-blocking, hemen dön                  │
    ├────────┼────────┼──────────────────────────────────────────────┤
    │ > 0    │ 0      │ VMIN karakter gelene kadar bekle             │
    ├────────┼────────┼──────────────────────────────────────────────┤
    │ 0      │ > 0    │ Timeout ile bekle, herhangi bir veri         │
    ├────────┼────────┼──────────────────────────────────────────────┤
    │ > 0    │ > 0    │ VMIN karakter veya timeout                   │
    └────────┴────────┴──────────────────────────────────────────────┘

    Görüldüğü gibi VTIME için 0 değeri VMIN değerine göre farklı anlama gelmektedir. Burada VMIN = 0, VTIME = 0 satırına dikkat
    ediniz. Burada read fonksiyonu çağrıldığında eğer okuma tamponunda hiç bilgi yoksa read fonksiyonu hemen 0 ile geri döner.
    Ancak okuma tamponunda bilgi varsa okuyabildiği kadarını okuyup geri döner. 

    Kananik modda VMIN ve VTIME değerleri tamamen etkisizdir. Yani aygıt sürücü bu değerlere bakmamaktadır. Çünkü kanonik modda
    her zaman '\n' karakteri okunana kadar bloke oluşmaktadır. 

    Seri port'a ilişkin aygıt dosyasını O_NONBLOCK kullarak blokesiz modda açtığımızda artık VMIN ve VTIME değerlerine hiç 
    bakılmamaktadır. VMIN ve VTIME değerleri yalnızca blokeli okumada dikkate alınmaktadır. Anımsanacağı gibi O_NONBLOCK 
    bayrağı ile blokesiz okuma yapıldığında eğer okuma tamponunda hiç bilgi yoksa read fonksiyonu 0'la değil başarısızlık 
    belirten -1 değeri ile geri dönmektedir ve errno değişkeni EAGAIN özel değeir ile set edilmektedir. Yani bu durumun VMIN = 0, 
    VTIME = 0 durumundan farklı olduğuna dikkat ediniz. Genellikle seri port'u okuyan programcılar VMIN = 1, VTIME = 0 uygulamaktadır. 
    VMIN ve VTIME değerleri okuma davranışı ile ilgilidir, bu değerlerin yazma davranışı üzerinde hiçbir etkisi yoktur.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki anlatılan ışığı altında termios için tipik bir ayarlama aşağıdaki gibi yapılabilir:

    struct termios tios;
    /* ... */

    if (tcgetattr(fd, &tios) == -1)
        exit_sys("tcgetattr");

    if (cfsetispeed(&tios, B115200) == -1)
        exit_sys("tcgetattr");

    if (cfsetospeed(&tios, B115200) == -1)
        exit_sys("tcgetattr");

    tios.c_cflag &= ~PARENB;                        /* no parity */
    tios.c_cflag &= ~CSTOPB;                        /* 1 stop bit */
    tios.c_cflag &= ~CSIZE;     
    tios.c_cflag |= CS8;                            /* 8 data bit */
    tios.c_cflag &= ~CRTSCTS;                       /* RTS/CTS flow control off */
    tios.c_iflag &= ~(IXON | IXOFF | IXANY);        /* XON/XOFF flow control off */
    tios.c_oflag &= ~OPOST;                         /* special conversion disable */
    tios.c_lflag &= ~(ICANON|ECHO|ECHOE);           /* Canonical mode off, echo off, backspace off */
    tios.c_cflag |= CREAD|CLOCAL;                   /* RxD enable, modem disable */
    tios.c_cc[VMIN] = 1;                            /* blocks at least one byte comes */ 
    tios.c_cc[VTIME] = 0;                           /* no timeout specified */ 

    if (tcsetattr(fd, TCSANOW, &tios) == -1)
        exit_sys("tcsetattr");
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                            146. Ders 02/12/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi seri port'a bilgi gönderen ve seri port'an bilgi alan iki program yazılım. Bizin deney ortamımızda BBB'nin 2 ve 4 
    numalarlı seri port'larını birbirine bağlamıştık. Dolayısıyla bir taraf seri port'a yazma yaptığında diğer taraf yazılanları 
    okuyabilmektedir. Tabii yaptığımız bağlantı çift yönlüdür. İki taraf da karşıya bilgi göndip karşıdan bilgi alabilmektedir. 

    Örneğimizde "serial-write.c" programında önce eri port açılmıştır:

     if ((fd = open("/dev/ttyS4", O_RDWR|O_NOCTTY)) == -1) 
        exit_sys("open");

    Sonra yukarıda açıkladığımız biçimde seri port set edilmiştir:

    if (tcgetattr(fd, &tios) == -1)
        exit_sys("tcgetattr");

    if (cfsetispeed(&tios, B115200) == -1)
        exit_sys("tcgetattr");

    if (cfsetospeed(&tios, B115200) == -1)
        exit_sys("tcgetattr");

    tios.c_cflag &= ~PARENB;                        /* no parity */
    tios.c_cflag &= ~CSTOPB;                        /* 1 stop bit */
    tios.c_cflag &= ~CSIZE;     
    tios.c_cflag |= CS8;                            /* 8 data bit */
    tios.c_cflag &= ~CRTSCTS;                       /* RTS/CTS flow control off */
    tios.c_iflag &= ~(IXON | IXOFF | IXANY);        /* XON/XOFF flow control off */
    tios.c_oflag &= ~OPOST;                         /* special conversion disable */
    tios.c_lflag &= ~(ICANON|ECHO|ECHOE);           /* Canonical mode off, echo off, backspace off */
    tios.c_cflag |= CREAD|CLOCAL;                   /* RxD enable, modem diable */
    tios.c_cc[VMIN] = 1;                            /* blocks at least one byte comes */ 
    tios.c_cc[VTIME] = 0;                           /* no timeout specified */ 

    if (tcsetattr(fd, TCSANOW, &tios) == -1)
        exit_sys("tcsetattr");

    Sonra da bu programda bir döngü içerisinde klavyeden (stdin dosyasından) bir yazı okunarak bu yazının tüm karakterleri 
    seri port'tan karşı tarafa gönderilmektedir:

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if (write(fd, buf, strlen(buf)) == -1)
            exit_sys("write");
        if (!strcmp(buf, "quit\n"))
            break;
    }
       
    Burada null karakterin gönderilmediğine dikkat ediniz. fgets fonksiyonu yazının sonunda '\n' bırakmaktadır. Dolayısıyla 
    örneğimizde gönderilen yazının sonunda '\n' karakteri vardır. En son karşı tarafa "quit\n" yazısı gönderildiğinde döngüden
    çıkılmıştır. 

    "serial-write.c" programının seri port'la gönderdiği karakterler karşı taraftaki "serial-read.c" programıyla okunmaktadır.
    Bu programda da önce seri port aşağıdaki açılmıştır:

     if ((fd = open("/dev/ttyS2", O_RDWR|O_NOCTTY)) == -1) 
        exit_sys("open");

    Sonra seri port aynı biçimde set edilmiştir:

    if (tcgetattr(fd, &tios) == -1)
        exit_sys("tcgetattr");

    if (cfsetispeed(&tios, B115200) == -1)
        exit_sys("tcgetattr");

    if (cfsetospeed(&tios, B115200) == -1)
        exit_sys("tcgetattr");

    tios.c_cflag &= ~PARENB;                        /* no parity */
    tios.c_cflag &= ~CSTOPB;                        /* 1 stop bit */
    tios.c_cflag &= ~CSIZE;     
    tios.c_cflag |= CS8;                            /* 8 data bit */
    tios.c_cflag &= ~CRTSCTS;                       /* RTS/CTS flow control off */
    tios.c_iflag &= ~(IXON | IXOFF | IXANY);        /* XON/XOFF flow control off */
    tios.c_oflag &= ~OPOST;                         /* special conversion disable */
    tios.c_lflag &= ~(ICANON|ECHO|ECHOE);           /* Canonical mode off, echo off, backspace off */
    tios.c_cflag |= CREAD|CLOCAL;                   /* RxD enable, modem diable */
    tios.c_cc[VMIN] = 1;                            /* blocks at least one byte comes */ 
    tios.c_cc[VTIME] = 0;                           /* no timeout specified */ 
    
    if (tcsetattr(fd, TCSANOW, &tios) == -1)
        exit_sys("tcsetattr");

    Seri port'tan okuma işlemi de aşağıdaki gibi bir döngüyle yapılmıştır:

    for (;;) {
        if ((result = read(fd, buf, BUFFER_SIZE)) == -1) 
            exit_sys("read");
        buf[result] = '\0';
        if (!strcmp(buf, "quit\n"))
            break;
        printf("%s", buf);
    }

    Burada VMIN = 1, VTIME = 0 olduğuna dikkat ediniz. Yani read fonksiyonu en az 1 byte okuyana kadar blokede bekleyecektir. 
    Gönderen taraf bir grup karakteri gönderdiğinde alan taraf bunu tek bir read çağrısı ile alamayabilir. Kononik olmayan 
    modda aslında alan tarafa 1 byte gelir gelmez VMIN = 1, VTIME = 0 durumunda blokeyi çözmektedir. Ancak bloke çözüldüğünde 
    akış aygıt sürücüden okumanın yapıldığı noktaya gelene kadar port'a gelen karakterler de okuma tamponunda biriktirilmektedir. 
    Böylece okuyan taraf 1 karakter değil daha fazla karakter de okuyabilmektedir. Örneğimizde printf fonksiyonunda '\n' 
    karakterini kullanmadığımıza dikkat ediniz. Linux sistemlerinde stdout default durumda "satır tamponlamalı (line buffered)" 
    moddadır. Yani printf henüz '\n' karakterini göndermediyse bunlar stdout tamponunda birikecek ancak henüz termial aygıt 
    sürücüsüne iletilmeyecektir. Dolayısıyla biz kanonik modda olmadığımız halde adeta kanonik mod etkisi yaratmış olmaktayız.
-----------------------------------------------------------------------------------------------------------------------------*/

/* serial-write.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <termios.h>

#define BUFFER_SIZE     1024

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE];
    struct termios tios;

    if ((fd = open("/dev/ttyS4", O_RDWR|O_NOCTTY)) == -1) 
        exit_sys("open");

    if (tcgetattr(fd, &tios) == -1)
        exit_sys("tcgetattr");

    if (cfsetispeed(&tios, B115200) == -1)
        exit_sys("tcgetattr");

    if (cfsetospeed(&tios, B115200) == -1)
        exit_sys("tcgetattr");

    tios.c_cflag &= ~PARENB;                        /* no parity */
    tios.c_cflag &= ~CSTOPB;                        /* 1 stop bit */
    tios.c_cflag &= ~CSIZE;     
    tios.c_cflag |= CS8;                            /* 8 data bit */
    tios.c_cflag &= ~CRTSCTS;                       /* RTS/CTS flow control off */
    tios.c_iflag &= ~(IXON | IXOFF | IXANY);        /* XON/XOFF flow control off */
    tios.c_oflag &= ~OPOST;                         /* special conversion disable */
    tios.c_lflag &= ~(ICANON|ECHO|ECHOE);           /* Canonical mode off, echo off, backspace off */
    tios.c_cflag |= CREAD|CLOCAL;                   /* RxD enable, modem disable */
    tios.c_cc[VMIN] = 1;                            /* blocks at least one byte comes */ 
    tios.c_cc[VTIME] = 0;                           /* no timeout specified */ 

    if (tcsetattr(fd, TCSANOW, &tios) == -1)
        exit_sys("tcsetattr");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if (write(fd, buf, strlen(buf)) == -1)
            exit_sys("write");
        if (!strcmp(buf, "quit\n"))
            break;
    }
        
    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* serial-read.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <termios.h>

#define BUFFER_SIZE     1024

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;
    struct termios tios;

    if ((fd = open("/dev/ttyS2", O_RDWR|O_NOCTTY)) == -1) 
        exit_sys("open");

    if (tcgetattr(fd, &tios) == -1)
        exit_sys("tcgetattr");

    if (cfsetispeed(&tios, B115200) == -1)
        exit_sys("tcgetattr");

    if (cfsetospeed(&tios, B115200) == -1)
        exit_sys("tcgetattr");

    tios.c_cflag &= ~PARENB;                        /* no parity */
    tios.c_cflag &= ~CSTOPB;                        /* 1 stop bit */
    tios.c_cflag &= ~CSIZE;     
    tios.c_cflag |= CS8;                            /* 8 data bit */
    tios.c_cflag &= ~CRTSCTS;                       /* RTS/CTS flow control off */
    tios.c_iflag &= ~(IXON | IXOFF | IXANY);        /* XON/XOFF flow control off */
    tios.c_oflag &= ~OPOST;                         /* special conversion disable */
    tios.c_lflag &= ~(ICANON|ECHO|ECHOE);           /* Canonical mode off, echo off, backspace off */
    tios.c_cflag |= CREAD|CLOCAL;                   /* RxD enable, modem disable */
    tios.c_cc[VMIN] = 1;                            /* blocks at least one byte comes */ 
    tios.c_cc[VTIME] = 0;                           /* no timeout specified */ 

    for (;;) {
        if ((result = read(fd, buf, BUFFER_SIZE)) == -1) 
            exit_sys("read");
        buf[result] = '\0';
        if (!strcmp(buf, "quit\n"))
            break;
        printf("%s", buf);
    }
        
    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi de iki taraflı bir haberleşme örneği verelim. Bu örnekte kanonik mod kullanacağız. Anımsayacağınız gibi kanonik 
    modda read fonksiyonu '\n' karakterini okuyana kadar blokede beklemektedir. Örneğimizde alan taraf yazıyı alıp ters 
    çevirip bunu karşı tarafa geri göndermektedir. Gönderen tarafın döngüsüne dikkat ediniz:

     for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if (write(fd, buf, strlen(buf)) == -1)
            exit_sys("write");
        if (!strcmp(buf, "quit\n"))
            break;
        if ((result = read(fd, buf, BUFFER_SIZE)) == -1)
            exit_sys("read");
        buf[result] = '\0';
        printf("%s", buf);
    }
       
    Burada yazı sonunda '\n' karakteri olacak biçimde karşı tarafa gönderilmiştir. Sonra karşı tarafın gönderdiği bilgi 
    okunmuştur. Alıcı tarafın döngüsü de şöyledir:

     for (;;) {
        if ((result = read(fd, buf, BUFFER_SIZE)) == -1) 
            exit_sys("read");
        buf[result] = '\0';
        if (!strcmp(buf, "quit\n"))
            break;
        printf("%s", buf);
        str_reverse(buf);
        if (write(fd, buf, result) == -1) 
            exit_sys("write");
    }

    Burada alıcı taraf gönderenin yazısını alıp onu ters çevirip gönderene geri yollamaktadır. Bir yazıyı ters çevirmek için
    standart bir C fonksiyonu yoktur. Micrsoft derleyicilerinde strrev isimli bir fonksiyon bulunyor olsa da bu fonksiyon 
    standart değildir ve GNU C kütüphanesinde bulunmamaktadır. str_reverse fonksiyonu şöyle yazılmıştır:

    char *str_reverse(char *str)
    {
        char *ret = str;
        char *end;
        char temp;

        if ((end = strchr(str, '\n')) == NULL)
            return NULL;
        --end;

        while (str < end) {
            temp = *str;
            *str = *end;
            *end = temp;

            ++str;
            --end;
        }

        return ret;
    }

    Burada yazının sonundaki '\n' karakterinin orada değştirilmeden bırakıldığına dikkat ediniz. Çünkü alan taraf yazıyı ters 
    çevirince gönderen taraf da kanonik modda olduğu için '\n' karakterini yazının sonunda muhafaza etmelidir. 
    
    Programlar aşağıda verilmiştir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/* serial-write.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <termios.h>

#define BUFFER_SIZE     8192

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE + 1];
    struct termios tios;
    ssize_t result;

    if ((fd = open("/dev/ttyS4", O_RDWR|O_NOCTTY)) == -1) 
        exit_sys("open");

    if (tcgetattr(fd, &tios) == -1)
        exit_sys("tcgetattr");

    if (cfsetispeed(&tios, B115200) == -1)
        exit_sys("tcgetattr");

    if (cfsetospeed(&tios, B115200) == -1)
        exit_sys("tcgetattr");

    tios.c_cflag &= ~PARENB;                        /* no parity */
    tios.c_cflag &= ~CSTOPB;                        /* 1 stop bit */
    tios.c_cflag &= ~CSIZE;     
    tios.c_cflag |= CS8;                            /* 8 data bit */
    tios.c_cflag &= ~CRTSCTS;                       /* RTS/CTS flow control off */
    tios.c_iflag &= ~(IXON | IXOFF | IXANY);        /* XON/XOFF flow control off */
    tios.c_oflag &= ~OPOST;                         /* special conversion disable */
    tios.c_lflag &= ~(ECHO|ECHOE);                  /* Canonical mode off, echo off, backspace off */
    tios.c_lflag |= ICANON;                         /* Canonical mode on, echo off, backspace off */
    tios.c_cflag |= CREAD|CLOCAL;                   /* RxD enable, modem disable */
   
    if (tcsetattr(fd, TCSANOW, &tios) == -1)
        exit_sys("tcsetattr");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            continue;
        if (write(fd, buf, strlen(buf)) == -1)
            exit_sys("write");
        if (!strcmp(buf, "quit\n"))
            break;
        if ((result = read(fd, buf, BUFFER_SIZE)) == -1)
            exit_sys("read");
        buf[result] = '\0';
        printf("%s", buf);
    }
        
    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* serial-read.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <termios.h>

#define BUFFER_SIZE     8192

char *str_reverse(char *str);
void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;
    struct termios tios;

    if ((fd = open("/dev/ttyS2", O_RDWR|O_NOCTTY)) == -1) 
        exit_sys("open");

    if (tcgetattr(fd, &tios) == -1)
        exit_sys("tcgetattr");

    if (cfsetispeed(&tios, B115200) == -1)
        exit_sys("tcgetattr");

    if (cfsetospeed(&tios, B115200) == -1)
        exit_sys("tcgetattr");

    tios.c_cflag &= ~PARENB;                        /* no parity */
    tios.c_cflag &= ~CSTOPB;                        /* 1 stop bit */
    tios.c_cflag &= ~CSIZE;     
    tios.c_cflag |= CS8;                            /* 8 data bit */
    tios.c_cflag &= ~CRTSCTS;                       /* RTS/CTS flow control off */
    tios.c_iflag &= ~(IXON | IXOFF | IXANY);        /* XON/XOFF flow control off */
    tios.c_oflag &= ~OPOST;                         /* special conversion disable */
    tios.c_lflag &= ~(ECHO|ECHOE);                  /* Canonical mode off, echo off, backspace off */
    tios.c_lflag |= ICANON;                         /* Canonical mode on */
    tios.c_cflag |= CREAD|CLOCAL;                   /* RxD enable, modem disable */
   
    if (tcsetattr(fd, TCSANOW, &tios) == -1)
        exit_sys("tcsetattr");

    for (;;) {
        if ((result = read(fd, buf, BUFFER_SIZE)) == -1) 
            exit_sys("read");
        buf[result] = '\0';
        if (!strcmp(buf, "quit\n"))
            break;
        printf("%s", buf);
        str_reverse(buf);
        if (write(fd, buf, result) == -1) 
            exit_sys("write");
    }
        
    close(fd);

    return 0;
}

char *str_reverse(char *str)
{
    char *ret = str;
    char *end;
    char temp;


    if ((end = strchr(str, '\n')) == NULL)
        return NULL;
    --end;

    while (str < end) {
        temp = *str;
        *str = *end;
        *end = temp;

        ++str;
        --end;
    }

    return ret;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
    Linux'un seri port'a ilişkin tty aygıt sürücüleri içsel olarak kesme tekniği ile çalışmaktadır. Bu teknikte aygıt sürücü 
    şöyle yazılmıştır:

    1) UART'a bilgi gelince UART bu bilgiyi kendi içerisinde yazmaçlarda saklar ve CPU'da kesme oluşturur.
    2) Aygıt sürücü UART'ın oluşturduğu kesmeyi işler, UART'ın yazmaçlarından gelen bilgiyi alır ve okuma tamponuna yerleştirir.
    3) Kononk modda okuma bekleyen bir thread varsa okuma tamponuna '\n' karakteri geldiğinde thread uyandılır. Eğer kanonik
    olmayan modda okuma bekleyen bir thread varsa VMIN ve VTIME değerlerini dikkate alarak bekleyen thread'i uyandırır.
    4) Uyanan thread'teki read fonksiyonu aygıt sürücünün okuma tamponundan bilgiyi okuyup geri döner.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Peki bir seri port'a ilişkin bir aygıt dosyası birden fazla proses tarafından açılıp okuma yazma yapılabilir mi? Bu durum
    aslında eğer istenseydi aygıt sürücü tarafından engellenebilirdi. Ancak Linux tty aygıt sürücüleri bu durumu kasten engellememiştir. 
    Bu durumda Linux'ta birden fazla proses aynı seri port'u açıp işlem yapabilir. Tabii bu durumda çok muhtemelen gönderilen 
    ve alınan bilgiler karmakarışık hale gelecektir. Tabii bu prosesler prosesler arası senkronizasyon nesneleriyle Gönderim
    ve alma işlemlerini senkronize edebilir. Ancak genel olarak seri port'ların bu biçimde aynı anda birden fazla proses 
    tarafından açılıp kullanılması istenen bir durum değildir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bazı endüstriyel uygulamalarda kullanılan gömülü aygıtların onlarca UART devresi bulunabilmektedir. İşte bazı uygulamalarda 
    birden fazla seri port'un okunması gerekebilmektedir. Bu tür durumlarda her seri port için bir thread yaratılabilir. Ya da 
    select, poll, epoll modelleri kullanılabilir. Bu modellere alternatif olarak sinyal tabanlı asenkron IO modelleri de bazen
    tercih edilebilmektedir. Tek bir seri port okunurken genel olarak select, poll ve epoll modellerinin kullanılmasına gerek 
    kalmamaktadır. Çünkü zaten aygıt sürücü VMIN ve VTIME parametreleriyle select, poll ve epoll benzeri etki oluşturabilmektedir.
    Tek bir seri port okumsı için select, poll ve epoll modelinni tercih edilmesinin tek mantıklı gerekçesi daha çözünürlüklü 
    bir zaman aşımı (timeout) kullanmak olabilir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Seri port okumaları "sinyal tabanlı asenkron IO" denilen bir teknikle de yapılabilir. UNIX/Linux sistemlerindeki sinyal 
    tabanlı asenkron IO tekniğinde bir IO olayı gerçekleştiğinde çekirdek SIGIO isimli bir sinyal oluşturur. Programcı da 
    bu sinyal için bir sinyal fonksiyonu set eder, böylece program kendi yoluna devam ederken aynı zamanda IO işlemleri 
    gerçekleştirilmiş olur. Bu aslında "kesme (interrupt)" çağrışımı yapan bir tekniktir. Bu teknikte "seri port'a bilgi 
    geldiğinde bana haber ver, ben de bloke olmadan okumayı yapayım" durumu söz konusudur. Sewri port'lar için sinyal tabanlı 
    asenkron IO tekniği şöyle uygulanmaktadır:

    1) Aygıt dosyası kesinlikle O_NONBLOCK bayrağı ile "blokesiz modda" açılmalıdır. Anımsanacağı gibi blokesiz modda işlem 
    yapılırken artık aygıt sürücüsünün VMIN ve VTIME parametrelerini bir etkisi kalmamaktadır. 

    2) SIGIO sinyalinin sigaction fonksiyonu ile set edilmesi gerekir. Bir sinyalin set edilmesi o sinyal oluştuğunda bizim 
    belirlediğimiz fonksiyonun çağrılması anlamına gelmektedir. Bu set işlemi şöyle yapılabilir:

    #include <signal.h>

    struct sigaction sa;

    sa.sa_flags = SA_RESTART;  
    sigemptyset(&sa.sa_mask);  
    sa.sa_handler = sigio_handler;  

    if (sigaction(SIGIO, &sa, NULL) == -1) 
        exit_sys("sigaction");
    
    Burada yapının sa_handler elemanına girilen fonksiyonun (örneğimizdeki sigio_handler) aşağıdaki parametrik yapıya sahip olması 
    gerekmektedir:

    void sigio_handler(int signo) 
    {
        /* ... */
    }

    3) IO olayı gerçekleştiğinde çekirdeğin (aygıt sürücü de burada etkili olmaktadır) SIGIO sinyalini hangi prosese göndericeğinin
    belirlenmesi gerekir. Bu işlem fcntl fonksiyonu kullanılarak aşağıdaki gibi yapılmalıdır:

    fcntl(fd, F_SETOWN, getpid());

    Burada SIGIO sinyali artık bizim prosesimize gönderilecektir. 

    4) Asenkron IO için dosyanın açış bayraklarına O_ASYNC eklenmelidir. Ancak bu bayrak open fonksiyonunda eklenen bir bayrak 
    değildir. open fonksiyonuyla dosya açıldıktan sonra bu bayrak set edilmelidir. Bu bayrağın daha sonra set edilmesi işlemi 
    fcntl fonksiyonu ile aşağıdaki gibi yapılabilir:

    fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_ASYNC);
    
    Burada önce fcntl fonksiyonu ile dosyanın açış bayrakları elde edilmiş sonra bu bayraklara O_ASYNC bayrağı eklennerek geri 
    set edilmiştir.  

    Burada bir nooktaya değinmek istiyoruz. Biz SIGIO sinyalini set edip asenkron işlem yaparken seri port'a her gelen byte 
    için bu fonksiyon çağrılmamaktadır. Aygıt sürücü port'a bilgi geldiğinde eğer girdi tamponu boş değilse SIGIO sinyalini 
    oluşturmamaktadır. Yalnızca girdi tamponu boşsa bu sinyali oluşturmaktadır. Yani örneğin karşı taraf write fonksiyonu ile 
    "ankara" karakterlerini seri port'tan göndermiş olsun. Alıcı tarafta için 6 tane değil yalnızca 1 tane SIGIO sinyali 
    oluşabilir. Bu durumda sinyal geldiğinde bir döngü içerisinde girdi tamponun tamamne tüketilmesi gerekmektedir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                        147. Ders 04/12/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi yukarıda açıkladığımız adımları tek tek uygulayan bir program yazalım. Programımız da önce dosyayı aşağıdaki gibi 
    blokesiz modda açabiliriz:

    int fd;
    struct termios tios;
    struct sigaction sa;
    ...

    if ((fd = open("/dev/ttyS2", O_RDWR|O_NOCTTY|O_NONBLOCK)) == -1) 
        exit_sys("open");

    Sonra yine seri port'u aşağıdaki gibi set edebiliriz:

    if (tcgetattr(fd, &tios) == -1)
        exit_sys("tcgetattr");

    if (cfsetispeed(&tios, B115200) == -1)
        exit_sys("tcgetattr");

    if (cfsetospeed(&tios, B115200) == -1)
        exit_sys("tcgetattr");

    tios.c_cflag &= ~PARENB;                        /* no parity */
    tios.c_cflag &= ~CSTOPB;                        /* 1 stop bit */
    tios.c_cflag &= ~CSIZE;     
    tios.c_cflag |= CS8;                            /* 8 data bit */
    tios.c_cflag &= ~CRTSCTS;                       /* RTS/CTS flow control off */
    tios.c_iflag &= ~(IXON | IXOFF | IXANY);        /* XON/XOFF flow control off */
    tios.c_oflag &= ~OPOST;                         /* special conversion disable */
    tios.c_lflag &= ~(ICANON|ECHO|ECHOE);           /* Canonical mode off, echo off, backspace off */
    tios.c_cflag |= CREAD|CLOCAL;                   /* RxD enable, modem disable */

    if (tcsetattr(fd, TCSANOW, &tios) == -1)
        exit_sys("tcsetattr");

    Artık SIGIO sinyali için sinyal fonksiyonunu aşağıdaki gibi set edebiliriz:

     sa.sa_flags = SA_RESTART;  
    sigemptyset(&sa.sa_mask);  
    sa.sa_handler = sigio_handler;  

    if (sigaction(SIGIO, &sa, NULL) == -1) 
        exit_sys("sigaction");

    Yukarıda belirttiğimiz gibi SIGIO sinyalinin bizim prosesimize gönderilmesi gerektiğini çekirdeğe söylemeliyiz:

    if (fcntl(fd, F_SETOWN, getpid()) == -1)
        exit_sys("fcntl");

    Dosya betimleyici açış bayraklarına kesinlikle O_ASYNC bayrağnın eklenmesi gerekmektedir:

    if (fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_ASYNC) == -1)
        exit_sys("facntl");

    Artık karşı taraf seri port'a yazma yaptığında bizim sinyal fonksiyonumuz çağrılacaktır. Sinyal fonksiyonun çağrılması 
    bir thread yoluyla yapılmamaktadır. Akış çekirdek tarafından geçici süre durdurulup sinyal fonksiyonu çağrılmaktadır. Peki 
    bu durumda ana akış ne yapmalıdır? Biz ana akışı bırakırsak main fonksiyonu biter tüm proses sonanır. getchar gibi bir 
    fonksiyonla ana akışı bekletmek de uygun değildir. Bu durumda bir sinyal oluştuğunda getchar fonksiyonundan çıkılabilir. 
    Ana akışın bir şey yapması isteniyorsa aşağıdaki gibi bir döngü kullanılabilir:

    for (;;)
        pause();

    pause fonksiyonu bir sinyal gelene kadar bloke oluşturan, sinyal geldiğinde sonlanan bir POSIX fonksiyonudur. 

    Sinyal tabanlı assenkron IO işlemlerinde önemli bir problem vardır. Sinyal fonksiyonu içerisinde yalnızca "sinyal güvenli"
    Şngilizcesiyle "async-signal-safe" fonksiyonların çağrılması gerekir. Aksi takdirede tanımsız davranış oluşabilmektedir. 
    Öreğin printf sinyal güvenli bir fonksiyon değildir. Bu nedenle pek çok sistem programcısı sinyal geldiğinde yapılacak şeyleri 
    sinyal fonksiyonun içerisinde değil dışarıda yapmayı tercih etmektedir. Örneğin tipik olarak sinyal fonksiyonunda global 
    atomik bir bayrak nesnesi set edilebilir. Ana bakış buna bakarak işlemini yapabilir. Örneğin:

    volatile sig_atomic_t g_signal_flag;
    ...
     for (;;) {
        pause();
        if (g_signal_flag) {
            /* ... */
            g_signal_flag = 0;
        }
    }
    ...

    void sigio_handler(int signo) 
    {
        g_signal_flag = 1;
    }

    POSIX standartlarına göre sinyal geldiğinde pause fonksiyonundan sinyal fonksiyonu çalıştırıldıktan sonra çıkılmaktadır. 
    Tabii burada aynı global değişkene yazma okuma işleminin senkronize edilmesi gerekir. Anımsanacağı gibi bu tür basit 
    senkronizasyonla riçin gcc'nin built-in atomic fonksiyonları kullanılabileceği gibi sig_atomic_t ya da atomic_t türleri 
    de kullanılabilir. sig_atomic_t ve atomic_t türleri üzerinde get ve set işlemleri yapıldığında zaten derleyici bu senkronizasyonu
    kendisi yapmaktadır. atomic_t türü çok işlemcili ya da çekirdekli sistemler için aynı belleğe erişimlerde CPU lock mekanizmasını
    devreye sokmaktadır. Halbuki yukarıdaki gibi sinyal işlemlerinde zaten thread tek bir CPU ya da çekirdekte çalışıyor olacaktır. 
    (Başhka bir deyişle derleyici sig_atomic_t türünü gördüğünde buna yapılacak get ve set işlemlerini tek CPU ya da çekirdek 
    için senkronize etmektedir.) Dolayısıyla atomic_t yerine sig_atomic_t türü bu tür kullanımlarda daha az maliyetli kod 
    üretimine yol açma potansiyeline sahiptir. Dolayısıyla sig_atomic_t türünü tercih edebilirsiniz. 

    Burada önemli bir nokta sinyal fonksiyonu içerisinde ya da yukarıdaki örnekte olduğu gibi dışarıda tüketici okumanın 
    yapılmasıdır. Aygıt sürücü okuma tamponunda hala bilgi varsa yeni bir SIGIO sinyali göndermediği için programcının bu 
    tamponu boşaltana kadar döngü içerisinde sürekli okuma yapması gerekir. Bu işlem şöyle yapılabilir:

    for (;;) {
            pause();
            if (g_signal_flag) {
                g_signal_flag = 0;
                while ((result = read(fd, buf, BUFFER_SIZE)) > 0) {
                    if (result == -1) {
                        if (errno == EAGAIN)
                            break;
                        exit_sys("read");
                    }
                    buf[result] = '\0';
                    
                    if (!strcmp(buf, "quit\n"))
                        goto EXIT;
                    printf("%s", buf);
                }
            }
        }
    EXIT:

    Burada artık g_signal_flag 1 yapıldıktan sonra ne kadar seri port'a gelirse gelsin onların hepsi tüketilmektedir. Siz de
    gerek sinyal fonksiyonunun içerisinde gerekse bayrak set ederek dışarıda yukarıdaki uygulamalısınız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi de kursumuzda "I2C (Inter-Integrated Circuit)" haberleşme protokolüne ilişkin programların Linux sistemlerinde nasıl 
    yazılacağı üzerinde duracağız. I2C haberleşmesinin donanımsal tarafı Gürbüz Hoca tarafından anlatılmıştı. Biz burada önce 
    yeniden bu haberleşmenin temelleri üzerinde durup sonra programlanmasını inceleyeceğiz. Kurusumuzda konunun uygulamasını 
    BBB'de Dallas firmasının "DS3231 RTC Modülü" üzerinde yapacağız. DS3231 RTC Modülü gerçek zamanlı bir saat işlevini 
    görmektedir. Modül üzerinde pek hasas olmasa da bir termometre sensörü de bulunmaktadır. Bu modül konunun anlatıldığı 
    zaman diliminde 75 TL civarındadır. Modül üzerinde gerçek zaman saatini besleyen bir pil de vardır. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    I2C haberleşmesi iki uçla yürütülmektedir: Clock ve Data uçları. Clock ucuna genellikle "SCL (serial clock line)" ve data 
    ucuna da "SDA (serial data line)" denişmektedir. I2C aygıtları birbirlerine toplamda üç uçtan bağlanmaktadır:

    Master       Slave
    SCL --------> SCL
    SDA <-------> SDA
    GND --------- GND

    I2C haberleşmesinde genellikle hizmet alan tarafa "efendi (master)", hizmet veren tarafa ise "köle (slave)" denilmektedir. 
    Bunu client/server terminolojisine çevirirsek buradaki efendi client, köle ise server olmaktadır. Ancak elektronikte 
    client/server terimleri yerine genellikle master/slave terimleri kullanılmaktadır. Biz kursumuzda genel olarak İngilizce 
    "master" ve "slave" sözcüklerini kullanacağız. 

    Master hizmet alan taraftır ve genellikle bir aygıt ile konulur. Master tarafın konuştuğu aygıt slave aygıttır. Örneğin 
    biz yukarıda açıkladığımız DS3231 RTC modülünü BBB'ye bağladığımızda burada BBB master durumundada DS3231 modülü de slave 
    durumunda olur. I2C haberleşmesi bazı bakımlardan UART haberleşmesine benzemektedir. Ancak bazı bakımlardan oldukça farklıdır. 
    
    I2C'de haberleşme bir "saat (clock)" eşliğinde yapılmaktadır. Clock her zaman master tarafından uygulanmaktadır. I2C 
    haberleşmesinde okuma clock sinyalinin çıkan kenarında data hattının örneklenmesiyle yapılmaktadır. Yani clock sinyalinin 
    lojik 1 seviyesinde okuma data hattı okunmaktadır. Bu durumda bitleri kodlayan taraf clock sinyalinin düşen kenraında yani 
    clock sinyali lojik 0 seviyesindeyken kodlamayı yapmaktadır. Başka bir deyişle okuyan taraf clock sinyali lojik 1 
    seviyesindeyken data hattına bakar, yazan taraf da clock siyali lojik 0'dayken bilgiyi data hattına bırakır. 

    I2C haberleşmesinde bir hatta (SCL, SDA ve GND'yi kastediyoruz) birden fazla slave cihaz bağlanabilmektedir. Bu yönüyle
    haberleşme UART haberleşmesinden farklılaşmaktadır. Yani bu haberleşme protokolünde aynı hatta birden fazla slave cihaz 
    bağlanabilmekte ve master taraf birden fazla cihazla iki uçtan haberleşebilmektedir. Genellikle master taraf bir tane 
    olsa da genel olarka master taraf da birden fazla olabilmektedir. 
    
    Her slave aygıtın üretici firma tarafından belirlenmiş olan bir aygıt adresi bulunmaktadır. Hatta birden fazla cihaz 
    bağlanabildiği için haberleşme sırasında mecburen aygıt adresi yoluyla haberleşilecek aygıtın bir biçimde seçilmesi 
    gerekmektedir. I2C prtokolü "half-duplex" bir haberleşmeye olanak vermektedir. Yani master slave'e slave de master'a 
    bilgi gönderebilir. Ancak bunu aynı anda yapamamaktadır. Örneğin biz RTC'deki saat bilgisini almak isteyelim. Önce 
    bizim RTC'ye bir komut göndermemiz gerekir (biz yazıyoruz RTC okuyor), bunun üzerinde RTC'nin de bize saati bilgisini 
    göndermesi gerekie (RTC yazıyor, biz okuyoruz.)
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                            148. Ders 09/12/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi haberleşme protokolünün biraz daha ayrıntısına girelim. Haberleşme master tarafın START işlemiyle başlatılmaktadır. 
    START SCL lojik 1 durumundayken SDA'nın lojik 0'a düşürülmesiyle oluşturulmaktadır. 

    SDA: ──────┐      
               └─────────
               ↓
    SCL: ──────────────── (1)
        START

    Böylece slave taraf iletişimin başlatıldığını anlamaktadır. Bu işlemin sembolik kodunu (pseudo code) şöyle ifade edebiliriz:

    void i2c_start(void) 
    {
        SDA = HIGH;
        SCL = HIGH;
        delay_us(5);
        SDA = LOW;      // SDA HIGH'dan LOW'a
        delay_us(5);
        SCL = LOW;      // SCL LOW'a çekilerek veri transfer modu
    }

    Bu sembolik kodda SCL hattı lojik 1 iken SDA da lojik 0'a çekilerek START durumu oluşturulmuştur. Daha sonra SCL 0'a 
    düştüğünde artık yazan taraf yazmayı yapacaktır. 

    Bilgi iletildikten sonra iletimin sonlandırılması için STOP işlemi yapılmaktadır. STOP işlemi SCL lojik 1 durumundayken
    SDA hattının lojik 0'dan lojik 1 seviyesine geçirilmesiyle yapılmaktadır. Bunun sembolik kodunu da şöyle belirtebiliriz:

    void i2c_stop(void) 
    {
        SDA = LOW;
        SCL = HIGH;
        delay_us(5);
        SDA = HIGH;     // SDA LOW'dan HIGH'a
        delay_us(5);
    }

    I2C haberleşmesinde bit'ler önce yüksek anlamlı sonra düşük anlamlı olacak biçimde SDA hattına kodlanmaktadır:

             B7   B6 B5  B4  B3   B2 B1  B0
    SDA: ───┐  ┌────────┐  ┌────┐  ┌─────────
            └──┘        └──┘    └──┘                    


    İekilden de görüldüğü gibi bitler yüksek anlamlıdan düşük anlamlıya doğru SDA hattına kdlanmaktadır. Gönderen taraf SCL 
    lojik 0'dayken kodlamayı yapar okuyan taraf ise SLCL 1 iken okumayı yapar. 

    Gönderen taraf 8 biti SDA hattına kodladıktan sonra hemen sonraki clock sinyalinde okuma moduna geçerek alan tarafın 
    ACK bitini okumaya çalışır. Alan taraf bu 8 biti aldıysa ACK bitini alamadıysa NACK SDA hattına kodlamaktadır. Gönderen 
    taraf alan taraftan ACK yerine NACK alırsa iletişimi sonlandırabilmektedir. ACK biti lojik 0, NACK biti ise lojik 1'dir. 
    (SDA hattı zaten default durumda lojik 1 seviyesinde olduğu için karşı tarafta hiç slave yoksa NACK olarak zaten 1 
    okunacaktır.) Bu durumu şekilsel olarak şöyle ifade edebiliriz:

    Bit 7 ... Bit 0    ACK
    SDA: ──...────────┐  ┌──
                      └──┘
      
    Bit 7 ... Bit 0   NACK
    SDA: ─────...────────────
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    I2C protokolünde her slave aygıtın 7 bitlik (0-128) bir aygıt adresi vardır. Her gönderme ve almada slave aygıtın aygıt 
    numarasının da hatta kodlanması gerekmektedir. Çünkü I2C protokolünde hatta birden fazla slave aygıt (hatta master aygıt da)
    bağlanabilmektedir. Dolayısıyla hatta kodlanan bilgilerin hangi slave tarafından alınacağı mecburen slave aygıt adresiyle 
    belirlenmektedir. Aygıt adreslerinin 7 bit olduğunu belirtmişik. İşte iletimde aygıt adresinden hemen sonra 8'inci bit 
    olarak R/W biti gönderilmektedir. Eğer bu 8'inci bit 0 ise master yazmak sityordur, 0 ise okumak istiyordur. İletimde 
    aygıt adresi ve R/W biti gönderildikten sonra da karşı taraftan ACK ya da NACK biti beklenmektedir. (Yani aygıtın seçilmesi 
    aşamasında da ACK gerekmektedir.)

    Prtokolde master taraftan slave tarafa 1 byte bilgi gönderme tipik olarak şu adımlardan geçilerek yapılmaktadır:

    1) Master START koşulunu kodlar.
    2) Master slave adresini (7 bit) + Write bit (0) gönderir.
    3) Master slave’den ACK bekler.
    4) Master data bitlerini yüksekten düşüğe doğru gönderir.
    5) Master slave’den ACK bekler.
    6) Master STOP koşulunu kodlar.

    Burada 1 byte'lık gönderimin START ile başlayıp STOP ile bittiğine dikkat ediniz. Eğer master slave'e birden fazla byte 
    gönderecekse her defasında START ve STOP koşulunu kodlamaz. İşlemleri bir döngü içerisinde yapar:

    1) Master START koşulunu kodlar.
    DÖNGÜ
        2) Master slave adresini (7 bit) + Write bit (0) gönderir.
        3) Master slave’den ACK bekler.
        4) Master data bitlerini yüksekten düşüğe doğru gönderir.
        5) Master slave’den ACK bekler.
    DÖNGÜ_SONU
    6) Master STOP koşulunu kodlar.

    Çoklu byte yazmayı şöyle de gösterebiliriz:

    START│ADDR+W│ACK│DATA1│ACK│DATA2│ACK│DATA3│ACK│STOP

    Şimdi de okuma işleminin nasıl yapıldığına bakalım. 1 byte okuma için master sırasıyla şunları yapmaktadır:

    1) Master START koşulunu kodlar.
    2) Master slave adresini + Read bit (1) gönder
    3) Master slave’den ACK bekler.
    4) Master data bitlerini yüksekten düşüğe doğru okur.
    5) Master NACK gönderir (son byte olduğunu belirtmek için)
    6) Master STOP koşulunu kodlar.

    Burada bir noktaya dikkat ediniz. Master 8 data bitini okudaktan sonra ACK yerine NACK göndermektedir. Çünkü izleyen
    paragrafta da göreceğimiz gibi master ACK gönderirse bu durum byte okumanın devam etmesi anlamına gelmektedir. Master 
    birden fazla byte'ı da şöyle okumaktadır:

    1) Master START koşulunu kodlar.
     2) Master slave adresini + Read bit (1) gönder
    3) Master slave’den ACK bekler.
    DÖNGÜ
        4) Master data bitlerini yüksekten düşüğe doğru okur.
        5) Master döngü yinelenecekse ACK, sonlandırılacaksa NACK gönderir.
    DÖNGÜ_SONU
    6) Master STOP koşulunu kodlar.

    Birden fazla byte okuma işlemini aşağıdaki gibi de gösterebilşriz:

    START│ADDR+R│ACK│DATA1│ACK│DATA2│ACK│DATA3│NACK│STOP
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    I2C haberleşmesinde çoğu kez master önce slave'e bilgi gönderir. (Örneğin slave aygıttaki bir yazmacı seçer) sonra ondan 
    okuma yapar. Önce yazma yapıp sonra okumaya geçerken START olmaksızın yeniden START kodlamaya "restart" işlemi denilmektedir. 
    Tipk olarak önce byte gönderip sonra byte okuma işlemi aşağıdaki gibi yapılmaktadır:

    START│ADDR+W│ACK│SOME_ADDR│ACK│RE-START│ADDR+R│ACK│DATA1│ACK│DATA2│ACK│DATA3│NACK│STOP
    └────────────────┬────────────┘        └──────────────────┬──────────────────────┘
              Adres Belirleme                        Ardışıl Veri Okuma

    Bu şeklin anlattığı şey şudur: Master önce aygıtı seçip ona 1 byte göndermektedir. Bu gönderilen 1 byte muhtemelen slave
    aygıttan ne istendiği bilgisidir. Sonra slave aygıt istenenleri vereceği için master bu sefer okuma işlemi başlatmaktadır. 
    Ancak yazmadan okumaya dönerken STOP kodlamasına gerek yoktur. Yeniden START kodlaması yapılmaktadır. Önce read sonra write 
    işlemi de benzer biçimde yapılmaktadır. Tabii genellikle önce write sonra read işlemi yapılmaktadır. Benzer biçimde 
    master birden fazla slave'e bilgi gönderecekse yine STOP olmadan START kullanabilmektedir. 

    STOP'tan sonra yeniden START kodlamak ile STOP kodlamadan yeniden START (restart) kodlamak arasındaki en önemli farklılık 
    STOP işleminden sonra birden fazla master carsa hattın o sırada başka bir master tarafından alınabilmesidir. Restart işlemi
    bunu engellemektedir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi de Linux ortamında I2C haberleşmesinin nasıl yapıldığı üzerinde duralım. Kursumuzun bu bölümünde kodlarımızı 
    test etmek için matser aygıt olarak BBB'yi slave aygıt olarak da DS3231 RTC modülünü kullanacağız. DS3231 RTC modülününün
    6 ucu bulunmaktadır:

    ┌────────────────────────────────────────┐
    │   DS3231 RTC MODULE                    │
    │                                        │
    │   [CR2032 Battery Holder]              │
    │                                        │
    │   SQW/INTR  •─────┐                    │
    │   32K       •─────┤ Bu tarafta pinler  │
    │   SCL       •─────┤                    │
    │   SDA       •─────┤                    │
    │   VCC       •─────┤                    │
    │   GND       •─────┘                    │
    └────────────────────────────────────────┘

    BBB'de 3 tane I2C denetleyici vardır. I2C0 pinlere verilmemiştir. Kart tarafından içsel olarak kullanılmaktadır. I2C1 
    pinleri P9_17 (SCL), P9_18 (SDA), I2C2 ise P9_19 (SCL) ve P9_20 (SDA) GPIO uçlarındadır. Biz kurusumuzda I2C2'yi kullanacağız. 
    Tabii bu pinler birden çok amaçla muplixed edildiği için bizim bu pinleri kullanmadan önce aygıt ağacından ya da "config-pin"
    programıyla I2C moduna geçirmemiz gerekir. Örneğin:

    $ config-pin P9_19 i2c
    Current mode for P9_19 is:     i2c

    $ config-pin P9_20 i2c
    Current mode for P9_20 is:     i2c

    DS3231 RTC modülü ile BBB arasındaki bağlantı şöyledir:

    BBB                   DS3231 RTC Modülü

    GND  (P9_1)  ------       GND (1)
    VCC  (P9_3)  ------       GND (2)
    SCL2 (P9_19) ------>      SCL (4)
    SDA2 (P9_20) <------>     SDA (3)
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Linux'ta I2C protokolünü uygulayan çekirdek kdoalrına dahil edilmiş hazır bir aygıt sürücü bulunmaktadır. Gömülü Linux 
    sistemlerinde genellikle çekirdek konfigürasyon parametrelerinde bu aygıt sürücü zaten seçilmiş durumdadır. Ancak masaüstü 
    sistemlerde böyle bir donanımsal arayüz olmadığı için dağıtımşar I2C aygıt sürücüsünü gereksiz olduğu gerekçesiyle çekirdek 
    kodlarına dahil etmemektedir. 
    
    BBB'deki üç I2C denetleyicisi aynı majör numaraya sahip olan aygıt sürücü tarafından yönetilmektedir. Tabii her denetleyicinin
    ayrı bir minör dumarası vardır:

    $ ls /dev/i2c* -l
    crw-rw---- 1 root gpio 89, 0 Feb  4 22:05 /dev/i2c-0
    crw-rw---- 1 root gpio 89, 1 Feb  4 22:05 /dev/i2c-1
    crw-rw---- 1 root gpio 89, 2 Feb  4 22:05 /dev/i2c-2

    BBB'deki I2C2 denetleyicisinin aygıt doasyasının isminin "/dev/i2c-2" biçiminde olduğuna dikkat ediniz. 

    BBB ve Raspberry Pi gibi SBC'lerde I2C işlemleri tığkı UART gibi SoC içerisinde bulunan denetleyiciler tarafından yapılmaktadır. 
    (Bu işlemler aslında GPIO uçlarıyla da manuel bir biçimde yapılabilir. Ancak böylesi manuel işlemlerin uygulaması çok zordur.)
    Aygıt sürücüler bu SoC içerisindeki I2C denetleyicilerine bellek tabanlı IO modeli ile erişip onlara komutlar göndermektedir. 
    Nihayet kullanıcı modundaki programlar da open fonksiyonuyla aygıt sürücüyü açıp, read/write ve ioctl işlemleriyle daha 
    yüksek seviyeli biçimde işlemleri yürütmektedir:

    Kullanıcı Modu programlar (open, read, write, ioctl, close) ---> Çekirdek içerisindeki aygıt sürücü ---> Çekirdek içerisindeki 
    aşağı seviyeli "core" fonksiyonlar ---> SoC içerisindeki I2C denetleyicisine bellek tabanlı IO ile erişip komutlar gönderiliyor 
    ---> Bilginin bitlerine ayrıştırılması, clock oluşturulması, bunların gönderilip alınması SoC içerisindeki denetleyici 
    tarafından yapılıyor.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Linux'ta kullanıcı modunda I2C programalaması için ilk yapılacak şey open fonksiyonuyla aygıt dosyasının açılmasıdır. 
    Örneğin:

    int i2c_fd;

    if ((i2c_fd = open("/dev/i2c-2", O_RDWR)) == -1) 
        exit_sys("open");

    Artık biz bu dosya betimelyicisi ile write işlemi yaparsak aygıt sürücünün write fonksiyonu çağrılacak o da SoC içerisindeki 
    I2C denetleyicisine komut gönderek bilgilerin bitlerine ayrıştırılıp I2C protokolüne uygun bir biçimde gönderilmesini 
    sağlayacaktır. Aynı durum read fonksiyonu için de geçerlidir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                        149. Ders 11/12/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Linux'taki I2C aygıt sürücüsü ikide bir her okuma ve yazmada aygıt adresini kullanıcının göndermesini elimine ederek
    işlemleri basitleştirmek için aygıt numarasını bir kez programcıdan alarak onu kendisi gönderme yöntemini uygulamaktadır. 
    Bu nedenle işin başında bizim aygıt sürücüye slave adresini bir kez iletmemiz gerekir. Bu işlem aşağıdaki ioctl komutunun 
    gönderilmesiyle yapılmaktadır:

    #define DS3231_ADDR 0x68
    /* ... */

    if (ioctl(i2c_fd, I2C_SLAVE, DS3231_ADDR) == -1) 
        exit_sys("ioctl");

    Buradaki I2C_SLAVE ioctl kodu <linux/i2c-dev.h> dosyasında define edilmiştir. DS3231_ADDR ise bizim kullandığımız RTC 
    modülünün slave adressidir. 

    Artık slave aygıta bilgi gönderip ondan bilgi okuyabiliriz. Tabii bu noktada bizim slave aygıtın (örneğimizde DS3231 RTC 
    modümü) nasıl programlanacağını biliyor olmamız gerekir. 

    DS3231'in yazmaç haritası aşağıdai gibidir:

    ╔═══════╦═════════════════════╦══════════════════════════════════════╦════════╗
    ║ Adres ║   Yazmaç Adı        ║ Açıklama                             ║ Format ║
    ╠═══════╬═════════════════════╬══════════════════════════════════════╬════════╣
    ║ 0x00  ║ Seconds             ║ Saniye (00-59)                       ║ BCD    ║
    ╟───────╫─────────────────────╫──────────────────────────────────────╫────────╢
    ║ 0x01  ║ Minutes             ║ Dakika (00-59)                       ║ BCD    ║
    ╟───────╫─────────────────────╫──────────────────────────────────────╫────────╢
    ║ 0x02  ║ Hours               ║ Saat (1-12+AM/PM veya 00-23)         ║ BCD    ║
    ╟───────╫─────────────────────╫──────────────────────────────────────╫────────╢
    ║ 0x03  ║ Day                 ║ Haftanın günü (1-7)                  ║ BCD    ║
    ╟───────╫─────────────────────╫──────────────────────────────────────╫────────╢
    ║ 0x04  ║ Date                ║ Ayın günü (01-31)                    ║ BCD    ║
    ╟───────╫─────────────────────╫──────────────────────────────────────╫────────╢
    ║ 0x05  ║ Month/Century       ║ Ay (01-12) + Yüzyıl biti             ║ BCD    ║
    ╟───────╫─────────────────────╫──────────────────────────────────────╫────────╢
    ║ 0x06  ║ Year                ║ Yıl (00-99)                          ║ BCD    ║
    ╠═══════╬═════════════════════╬══════════════════════════════════════╬════════╣
    ║ 0x07  ║ Alarm 1 Seconds     ║ Alarm 1 saniye                       ║ BCD    ║
    ╟───────╫─────────────────────╫──────────────────────────────────────╫────────╢
    ║ 0x08  ║ Alarm 1 Minutes     ║ Alarm 1 dakika                       ║ BCD    ║
    ╟───────╫─────────────────────╫──────────────────────────────────────╫────────╢
    ║ 0x09  ║ Alarm 1 Hours       ║ Alarm 1 saat                         ║ BCD    ║
    ╟───────╫─────────────────────╫──────────────────────────────────────╫────────╢
    ║ 0x0A  ║ Alarm 1 Day/Date    ║ Alarm 1 gün/tarih                    ║ BCD    ║
    ╠═══════╬═════════════════════╬══════════════════════════════════════╬════════╣
    ║ 0x0B  ║ Alarm 2 Minutes     ║ Alarm 2 dakika                       ║ BCD    ║
    ╟───────╫─────────────────────╫──────────────────────────────────────╫────────╢
    ║ 0x0C  ║ Alarm 2 Hours       ║ Alarm 2 saat                         ║ BCD    ║
    ╟───────╫─────────────────────╫──────────────────────────────────────╫────────╢
    ║ 0x0D  ║ Alarm 2 Day/Date    ║ Alarm 2 gün/tarih                    ║ BCD    ║
    ╠═══════╬═════════════════════╬══════════════════════════════════════╬════════╣
    ║ 0x0E  ║ Control             ║ Kontrol register                     ║ Binary ║
    ╟───────╫─────────────────────╫──────────────────────────────────────╫────────╢
    ║ 0x0F  ║ Control/Status      ║ Durum register                       ║ Binary ║
    ╟───────╫─────────────────────╫──────────────────────────────────────╫────────╢
    ║ 0x10  ║ Aging Offset        ║ Yaşlanma offset                      ║ Binary ║
    ╟───────╫─────────────────────╫──────────────────────────────────────╫────────╢
    ║ 0x11  ║ Temp MSB            ║ Sıcaklık (üst byte)                  ║ Binary ║
    ╟───────╫─────────────────────╫──────────────────────────────────────╫────────╢
    ║ 0x12  ║ Temp LSB            ║ Sıcaklık (alt byte)                  ║ Binary ║
    ╚═══════╩═════════════════════╩══════════════════════════════════════╩════════╝

    Yukarıdaki yazmaç değerlerini isterseniz sembolik sabirlerle define edebilirsiniz:

    #define DS3231_REG_SECOND       0x00
    #define DS3231_REG_MINUTE       0x01
    #define DS3231_REG_HOUR        0x02
    #define DS3231_REG_DAY          0x03
    #define DS3231_REG_DATE         0x04
    #define DS3231_REG_MONTH        0x05
    #define DS3231_REG_YEAR         0x06
    #define DS3231_REG_ALARM1_SEC   0x07
    #define DS3231_REG_ALARM1_MIN   0x08
    #define DS3231_REG_ALARM1_HR    0x09
    #define DS3231_REG_ALARM1_DAY   0x0A
    #define DS3231_REG_ALARM2_MIN   0x0B
    #define DS3231_REG_ALARM2_HR    0x0C
    #define DS3231_REG_ALARM2_DAY   0x0D
    #define DS3231_REG_CONTROL      0x0E
    #define DS3231_REG_STATUS       0x0F
    #define DS3231_REG_AGING        0x10
    #define DS3231_REG_TEMP_MSB     0x11
    #define DS3231_REG_TEMP_LSB     0x12

    DS3231'in yazmaçlarını kullanmak için önce ilgili yazmacı seçmek gerekir. Yazmacı seçmek demek yazmacın numarasını 
    denetleyiciye göndermek demektir. Yazmaç seçildikten sonra hemen okuma yapılırsa DS3231 bize o yazmacın değerini vermektedir. 
    Yazmaç seçildikten sonra hemen yazma yapılırsa yazılan değer o yazmaca aktarılmaktadır. Örneğin biz DS3231'den saat bilgisini
    almak siteyelim. Önce DS3231'e 0x02 byte göndererek saat yazmacını seçeriz. Sonra aygıttan 1 byte okuduğumuzda saat bilgisini 
    elde etmiş oluruz. O halde DS3231'den belli bir bilginin elde edilmesi önce "önce yazma sonra okuma" yapılması gerekmektedir. 
    DS3231'in şöyle de bir özelliği vardır: Belli bir yazmaç seçilip bir byte değil birden fazla byte okunursa yalnızca o yazmacın
    değeri değil onu izleyen yazmaçların değerleri de elde edilmektedir. Örneğin biz 0x00 (saniye) yazmacını seçmek için write
    işlemi yapalım. Şimdi biz DS3231'den 1 byte okursak saniye bilgisini okumuş oluruz. Ancak 7 byte okursak yalnızca saniyeyi 
    değil izleyen yazmaçların değerlerini de okumuş oluruz. Aynı durum yazma için de söz konusudur. Bir yazmaç seçildikten 
    sonra DS3231'e yazma yapıldığında ilgili yazmaç değeri değiştirilmiş olur. Örneğin biz RTC'yi yeniden istediğimiz zaman 
    blgisiyle kurabiliriz. 

    I2C aygıt dosyasını açıp read/write yaptığımızda dosya betimleyicisine ilişkin dosya gstericisi aygıt sürücü tarafından 
    dikkate alınmamaktadır, yani ilerletilmemektedir. Başka bir deyişle bu aygıt sürücüde aygıt dosyasına ilişkin betimleleyicinin
    dosya göstericisi herhangi bir biçimde kullanılmamaktadır. 

    DS3231'e önce yazmaç seçmek için write ile yazma yapıp sonra read ile yazmaç okuma işlemlerini çok sık yaparız. Bu iki 
    işlemi bir arada yapmak için ioctl kodları bulundurulmuştur. 

    DS3231'in bir yazmacını okumak için aşağıdaki gibi bir fonksiyonu kullanabiliriz:

    int ds3231_read_register(int i2c_fd, uint8_t reg_addr) 
    {
        uint8_t data;
        
        if (write(i2c_fd, &reg_addr, 1) != 1) 
            return -1; 
        if (read(i2c_fd, &data, 1) != 1) 
            return -1;
        
        return data;
    }

    Fonksiyon önce yazmaç adresini DS3231'e gönderip yazmacı seçmiştir. Sonra okuma yaptığında DS3231 yazmaç değerini verecektir. 
    Fonksiyonun geri dönüş değerinin int olduğuna dikkat ediniz. Tıpkı fgetc fonksiyonunda olduğu gibi fonksiyon başarısızsa 
    -1 değerine, başarılıysa okunan byte değerine geri dönmektedir. Burada write ile read arasında geçen zamanın önemli olabileceğini
    düşünebilirsiniz. Ancak bunun bir önemi yoktur. Aygıt sürücü write işleminden sonra hatta STOP kodlamaktadır. read işleminde 
    de yeniden START oluşturmaktadır. DS3231 bakış açısıyla durumu yorumlarsak DS3231 önce gelen byte'ı okuyup yazmacı seçmekte 
    sonra ilk okumada yazmacın değerini vermektedir. Önce yazıp sonra okumak için STOP yapmadan RESTART yapılabildiğini anımsayınız.
    Ancak aygıt sürücü write ile read arasında zaman farkı olduğu için RESTART yapamamaktadır. RESTART işlemi ile önce yazma, 
    sonra okuma I2C_RDWR ioctl komutu ile yapılmaktadır. 

    Yazmaç seçip oradan itibaren birden fazla yazmacı okuyabilmek için de şöyle bir fonksiyon yazabiliriz:

    int ds3231_read_registers(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length) 
    {    
        if (write(i2c_fd, &reg_addr, 1) != 1) 
            return -1;
        if (read(i2c_fd, buffer, length) != (ssize_t)length) 
            return -1;
        
        return 0;
    }

    Bırada fonksiyon başarılıysa 0 değerine başarısızsa -1 değerine geri dönmektedir. 

    Yukarıda da belirttiğimiz gibi RESTART ile bir grup işlemi tek hamlede yaptırmak için I2C_RDRW ioctl komutu kullanılmaktadır. 
    Bunu yapan bir fonksiyon aşağıdaki gibi yazılabilir:

    int ds3231_read_reg_msg(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length) 
    {
        struct i2c_msg messages[2];
        struct i2c_rdwr_ioctl_data msgset;
        
        messages[0].addr = DS3231_ADDR;
        messages[0].flags = 0;              // Write, register selection
        messages[0].len = 1;
        messages[0].buf = &reg_addr;   

        messages[1].addr = DS3231_ADDR;
        messages[1].flags = 1;              // Read multi byte
        messages[1].len = length;
        messages[1].buf = buffer;
        
        msgset.msgs = messages;
        msgset.nmsgs = 2;
        
        if (ioctl(i2c_fd, I2C_RDWR, &msgset) < 0) 
            return -1;
            
        return 0;
    }

    Burada I2C_RDWR ioctl komutu i2c_rdwr_ioctl_data isimli bir yapı nesnesinin adresini almaktadır. Bu yapı nesnesi de 
    programcı tarafındna doldurulmaktadır. Yukarıdaki fonksiyonda önce slave'e yazmaç değeri gönderilmiş sonra da length 
    parametresiyle belirtilen miktarda byte okunmuştur. Bu fonksiyonun aslında ds3231_read_registers fonksiyonu ile aynı 
    şeyleri yaptığına dikkat ediniz. Ancak bu fonksiyon STOP ve yeniden START yerine RESTART yapmaktadır. 

    Bir yazmaca değer yazan fonksiyunu şöyle yazabiliriz:

    int ds3231_write_register(int fd, uint8_t reg, uint8_t value) 
    {
        uint8_t buffer[2] = {reg, value};
        
        if (write(fd, buffer, 2) != 2) 
            return -1;
        
        return 0;
    }
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    DS3231'deki yazmaç değerlerinin çoğu "binary" değil "BCD (Binary Coded Decimal)" biçimindedir. Anımsanacağı gibi bir hex 
    digit 4 bitle ifade edilmektedir. Bu durum 2'lik sistem ile 16'lık sistem arasında dönüştürmenin çok kolay yapılmasına 
    yol açmaktadır. Örneğin 3F1C gibi hex bir sayı her digit için 4 bit yazılarak 2'lik sisteme dönüştürülebilir:

     3        F      1        C
    0011    1111    0011    1100

    2'lik sistem ile 16'lık sistem arasında dönüştürme çok kolay olamsına karşın 2'lik sistemden 10'luk siseme dönüştürme 
    oldukça zordur. İşte BCD kodlaması bu dönüştürmeti kolaylaştırmak için düşünülmüştür. BCD kodlamasında her 4 bit bir hex
    digit'e değil decimal digit'e karşılık gelmektedir. Örneğin 10'luk sistemdeki 3892 sayısını biz 2'lik sisteme zor dönüştürürüz.
    Ancak BCD sisteme dönüştürmek çok kolaydır. Tek yapılacak şey her decimal digit için 4 bit kodlamaktır:

     3        8       9       2
    0011    1000    1001    0010

    Tabii BCD kodlalası aslında verimli bir kodlama değildir. Çünkü 4 bitte kullanılmayan bitler boşa gitmektedir. 

    Biz de istersek BCD kodlanmış 1 byte değeri 10'luk sisteme dönüştüren, 10'luk sistemde binary kodlanmış bilgiyi de BCD'ye 
    dönüştüren makrolar yazabiliriz:

    #define BCD_TO_DEC(val)     ((((val) >> 4) * 10) + ((val) & 0x0F))
    #define DEC_TO_BCD(val)     ((((val) / 10) << 4) | ((val) % 10))

    Elimizde BCD kodlanmış bir sayı olsun. Bunu 10'luk sistemde printf ile nasıl yazdırırız? "%d" format karakterlerini 
    kullanırsak BCD değer binary değermiş gibi yazdırılır. Bizim "%X" format karakterlerini kullanmamız gerekir. Çünkü "%X" 
    aslında "her 4 bit için bir hex digit" yazmaktadır. Zaten sayımız BCD kodlandığında göre 4 bitteki değerler 0 ile 9 
    arasında olacaktır. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    DS3231 RTC modülünden saat, dakika ve saniyeyi alıp ekrana basan programı da şöyle yazabiliriz:

    int main(void)
    {
        int i2c_fd;
        int hour, minute, second;

        if ((i2c_fd = open("/dev/i2c-2", O_RDWR)) == -1) 
            exit_sys("open");

        if (ioctl(i2c_fd, I2C_SLAVE, DS3231_ADDR) == -1) 
            exit_sys("ioctl");

        second = ds3231_read_register(i2c_fd, DS3231_REG_SECOND);
        minute = ds3231_read_register(i2c_fd, DS3231_REG_MINUTE);
        hour = ds3231_read_register(i2c_fd, DS3231_REG_HOUR);

        printf("%02X:%02X:%02X\n", hour, minute, second);

        close(i2c_fd);

        return 0;
    }

    Tabii aslında biz ds3231_read_register fonksiyonu yerine ds3231_read_registers fonksiyonu ile tek hamlede de bu bilgileri
    alabilirdik:

    int main(void)
    {
        int i2c_fd;
        uint8_t current_time[3];

        if ((i2c_fd = open("/dev/i2c-2", O_RDWR)) == -1) 
            exit_sys("open");

        if (ioctl(i2c_fd, I2C_SLAVE, DS3231_ADDR) == -1) 
            exit_sys("ioctl");

        ds3231_read_registers(i2c_fd, DS3231_REG_SECOND, current_time, 3);
        
        printf("%02X:%02X:%02X\n", current_time[2], current_time[1], current_time[0]);

        close(i2c_fd);

        return 0;
    }

    Aşağıda programın tamamını veriyoruz. BBB'nin iligili pinlerini konfigüre etmeyi unutmayınız:

    $ config-pin P9_19 i2c
    Current mode for P9_19 is:     i2c

    $ config-pin P9_20 i2c
    Current mode for P9_20 is:     i2c
-----------------------------------------------------------------------------------------------------------------------------*/

/* rtc-read.c */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/i2c.h>
#include <linux/i2c-dev.h>

#define DS3231_ADDR             0x68

#define DS3231_REG_SECOND       0x00
#define DS3231_REG_MINUTE       0x01
#define DS3231_REG_HOUR         0x02
#define DS3231_REG_DAY          0x03
#define DS3231_REG_DATE         0x04
#define DS3231_REG_MONTH        0x05
#define DS3231_REG_YEAR         0x06
#define DS3231_REG_ALARM1_SEC   0x07
#define DS3231_REG_ALARM1_MIN   0x08
#define DS3231_REG_ALARM1_HR    0x09
#define DS3231_REG_ALARM1_DAY   0x0A
#define DS3231_REG_ALARM2_MIN   0x0B
#define DS3231_REG_ALARM2_HR    0x0C
#define DS3231_REG_ALARM2_DAY   0x0D
#define DS3231_REG_CONTROL      0x0E
#define DS3231_REG_STATUS       0x0F
#define DS3231_REG_AGING        0x10
#define DS3231_REG_TEMP_MSB     0x11
#define DS3231_REG_TEMP_LSB     0x12

#define BCD_TO_DEC(val)     ((((val) >> 4) * 10) + ((val) & 0x0F))
#define DEC_TO_BCD(val)     ((((val) / 10) << 4) | ((val) % 10))

int ds3231_read_register(int i2c_fd, uint8_t reg_addr);
int ds3231_read_registers(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length);
int ds3231_read_reg_msg(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length);
int ds3231_write_register(int fd, uint8_t reg, uint8_t value);

void exit_sys(const char *msg);    

int main(void)
{
    int i2c_fd;
    uint8_t current_time[3];

    if ((i2c_fd = open("/dev/i2c-2", O_RDWR)) == -1) 
        exit_sys("open");

    if (ioctl(i2c_fd, I2C_SLAVE, DS3231_ADDR) == -1) 
        exit_sys("ioctl");

    ds3231_read_registers(i2c_fd, DS3231_REG_SECOND, current_time, 3);
    
    printf("%02X:%02X:%02X\n", current_time[2], current_time[1], current_time[0]);

    close(i2c_fd);

    return 0;
}

int ds3231_read_register(int i2c_fd, uint8_t reg_addr) 
{
    uint8_t data;
    
    if (write(i2c_fd, &reg_addr, 1) != 1) 
        return -1;
    if (read(i2c_fd, &data, 1) != 1) 
        return -1;
    
    return data;
}

int ds3231_read_registers(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length) 
{    
    if (write(i2c_fd, &reg_addr, 1) != 1) 
        return -1;
    if (read(i2c_fd, buffer, length) != (ssize_t)length) 
        return -1;
    
    return 0;
}

int ds3231_read_reg_msg(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length) 
{
    struct i2c_msg messages[2];
    struct i2c_rdwr_ioctl_data msgset;
    
    messages[0].addr = DS3231_ADDR;
    messages[0].flags = 0;              // Write, register selection
    messages[0].len = 1;
    messages[0].buf = &reg_addr;   

    messages[1].addr = DS3231_ADDR;
    messages[1].flags = 1;              // Read multi byte
    messages[1].len = length;
    messages[1].buf = buffer;
    
    msgset.msgs = messages;
    msgset.nmsgs = 2;
    
    if (ioctl(i2c_fd, I2C_RDWR, &msgset) < 0) 
        return -1;
        
    return 0;
}

int ds3231_write_register(int i2c_fd, uint8_t reg, uint8_t value) 
{
    uint8_t buffer[2] = {reg, value};
    
    if (write(i2c_fd, buffer, 2) != 2) 
        return -1;
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
                                                150. Ders 16/12/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte klavyeden (stdin dosyasından) alınan saat, dakika, saniye bilgileriyle RTC set edilmektedir. Programı 
    aşağıdaki gibi çalıştırabilirsiniz:

    $ ./rtc-set saat dakika saniye

    BBB'nin ilgili pinlerini konfigüre etmeyi unutmayınız:

    $ config-pin P9_19 i2c
    Current mode for P9_19 is:     i2c

    $ config-pin P9_20 i2c
    Current mode for P9_20 is:     i2c
-----------------------------------------------------------------------------------------------------------------------------*/

/* rtc-set */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/i2c.h>
#include <linux/i2c-dev.h>

#define DS3231_ADDR             0x68

#define DS3231_REG_SECOND       0x00
#define DS3231_REG_MINUTE       0x01
#define DS3231_REG_HOUR         0x02
#define DS3231_REG_DAY          0x03
#define DS3231_REG_DATE         0x04
#define DS3231_REG_MONTH        0x05
#define DS3231_REG_YEAR         0x06
#define DS3231_REG_ALARM1_SEC   0x07
#define DS3231_REG_ALARM1_MIN   0x08
#define DS3231_REG_ALARM1_HR    0x09
#define DS3231_REG_ALARM1_DAY   0x0A
#define DS3231_REG_ALARM2_MIN   0x0B
#define DS3231_REG_ALARM2_HR    0x0C
#define DS3231_REG_ALARM2_DAY   0x0D
#define DS3231_REG_CONTROL      0x0E
#define DS3231_REG_STATUS       0x0F
#define DS3231_REG_AGING        0x10
#define DS3231_REG_TEMP_MSB     0x11
#define DS3231_REG_TEMP_LSB     0x12

#define BCD_TO_DEC(val)     ((((val) >> 4) * 10) + ((val) & 0x0F))
#define DEC_TO_BCD(val)     ((((val) / 10) << 4) | ((val) % 10))

int ds3231_read_register(int i2c_fd, uint8_t reg_addr);
int ds3231_read_registers(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length);
int ds3231_read_reg_msg(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length);
int ds3231_write_register(int fd, uint8_t reg, uint8_t value);

void exit_sys(const char *msg);    

int main(int argc, char *argv[])
{
    int i2c_fd;
    uint8_t hour, minute, second;

    if (argc != 4) {
        fprintf(stderr, "wrong number of arguments!..\n");
        fprintf(stderr, "usage: rtc-set hour minute second\n");
        exit(EXIT_FAILURE);
    }

    hour = DEC_TO_BCD(atoi(argv[1]));
    minute = DEC_TO_BCD(atoi(argv[2]));
    second = DEC_TO_BCD(atoi(argv[3]));
    
    if ((i2c_fd = open("/dev/i2c-2", O_RDWR)) == -1) 
        exit_sys("open");

    if (ioctl(i2c_fd, I2C_SLAVE, DS3231_ADDR) == -1) 
        exit_sys("ioctl");

    if (ds3231_write_register(i2c_fd, DS3231_REG_HOUR, hour) == -1)
        exit_sys("ds3231_write_register");
    if (ds3231_write_register(i2c_fd, DS3231_REG_MINUTE, minute) == -1)
        exit_sys("ds3231_write_register");
    if (ds3231_write_register(i2c_fd, DS3231_REG_SECOND, second) == -1)
        exit_sys("ds3231_write_register");
    
    close(i2c_fd);

    return 0;
}

int ds3231_read_register(int i2c_fd, uint8_t reg_addr) 
{
    uint8_t data;
    
    if (write(i2c_fd, &reg_addr, 1) != 1) 
        return -1;
    if (read(i2c_fd, &data, 1) != 1) 
        return -1;
    
    return data;
}

int ds3231_read_registers(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length) 
{    
    if (write(i2c_fd, &reg_addr, 1) != 1) 
        return -1;
    if (read(i2c_fd, buffer, length) != (ssize_t)length) 
        return -1;
    
    return 0;
}

int ds3231_read_reg_msg(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length) 
{
    struct i2c_msg messages[2];
    struct i2c_rdwr_ioctl_data msgset;
    
    messages[0].addr = DS3231_ADDR;
    messages[0].flags = 0;              // Write, register selection
    messages[0].len = 1;
    messages[0].buf = &reg_addr;   

    messages[1].addr = DS3231_ADDR;
    messages[1].flags = 1;              // Read multi byte
    messages[1].len = length;
    messages[1].buf = buffer;
    
    msgset.msgs = messages;
    msgset.nmsgs = 2;
    
    if (ioctl(i2c_fd, I2C_RDWR, &msgset) < 0) 
        return -1;
        
    return 0;
}

int ds3231_write_register(int i2c_fd, uint8_t reg, uint8_t value) 
{
    uint8_t buffer[2] = {reg, value};
    
    if (write(i2c_fd, buffer, 2) != 2) 
        return -1;
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
    I2C protokolünü kullanarak DS3231 RTC modülü üzerinde daha özel işlemler yapan yüksek seviyeli fonksiyonlar da yazılabilir:
    
    typedef struct {
        uint8_t second;   // 0-59
        uint8_t minute;   // 0-59
        uint8_t hour;     // 0-23
        uint8_t weekday;  // 1-7 (Pazartesi=1)
        uint8_t day;      // 1-31
        uint8_t month;    // 1-12
        uint16_t year;    // 2000-2099
    } DS3231_TIME;


    int ds3231_gettime(int i2c_fd, DS3231_TIME *dstime)
    {
        uint8_t buf[7];

        if (ds3231_read_registers(i2c_fd, 0, buf, 7) == -1)
            return -1;
        
        dstime->second = BCD_TO_DEC(buf[0]);
        dstime->minute = BCD_TO_DEC(buf[1]);
        dstime->hour = BCD_TO_DEC(buf[2]);
        dstime->weekday = BCD_TO_DEC(buf[3]);
        dstime->day = BCD_TO_DEC(buf[4]);
        dstime->month = BCD_TO_DEC(buf[5]);
        dstime->year = BCD_TO_DEC(buf[6]) + 2000;

        return 0;
    }

    Bu fonksiyon DS3231 RTC modülündeki tarih zaman bilgisini alarak bizim bildiridğimiz yapı nesnesinin içini doldurmaktadır. 
    Bu işlemin tersini yapan fonksiyon da şöyle yazılabilir:

    int ds3231_settime(int i2c_fd, const DS3231_TIME *dstime)
    {
        uint8_t buf[7];

        buf[0] = DEC_TO_BCD(dstime->second);
        buf[1] = DEC_TO_BCD(dstime->minute);
        buf[2] = DEC_TO_BCD(dstime->hour);
        buf[3] = DEC_TO_BCD(dstime->weekday);
        buf[4] = DEC_TO_BCD(dstime->day);
        buf[5] = DEC_TO_BCD(dstime->month);
        buf[6] = DEC_TO_BCD(dstime->year);
        
        if (ds3231_write_registers(i2c_fd, 0, buf, 7) == -1)
            return -1;

        return 0;
    }

    Bu fonksiyonları kullanarak host sistemdeki andaki tarih ve zamanla DS3231 RTC modülündeki tarih ve zamanı set eden 
    fonksiyon şöyle yazılabilir:

    int ds3231_settime_host2rtc(int i2c_fd)
    {
        time_t t;
        struct tm *ptm;
        DS3231_TIME dstime;
        
        t = time(NULL);
        ptm = localtime(&t);

        dstime.second = ptm->tm_sec;
        dstime.minute = ptm->tm_min;
        dstime.hour = ptm->tm_hour;
        dstime.weekday = ptm->tm_wday == 0 ? 7 : ptm->tm_wday;
        dstime.day = ptm->tm_mday;
        dstime.month = ptm->tm_mon + 1;
        dstime.year = ptm->tm_year - 100;

        if (ds3231_settime(i2c_fd, &dstime) == -1)
            return -1;

        return 0;
    }

    Bu işlemin tersini yapan fonksiyon da şöyle yazılabilir:

    void ds3231_time2tm(const DS3231_TIME *dstime, struct tm *ptm)
    {
        ptm->tm_sec  = dstime->second;
        ptm->tm_min  = dstime->minute;
        ptm->tm_hour = dstime->hour;
        ptm->tm_mday = dstime->day;
        ptm->tm_mon  = dstime->month - 1;    
        ptm->tm_year = dstime->year - 1900;
        ptm->tm_wday = dstime->weekday == 7 ? 0 : dstime->weekday;
        ptm->tm_yday = 0;
        ptm->tm_isdst = -1;
    }

    int ds3231_settime_rtc2host(int i2c_fd)
    {
        DS3231_TIME dstime;
        struct timeval tv;
        struct tm tm;
        
        if (ds3231_gettime(i2c_fd, &dstime) == -1)
            return -1;

        ds3231_time2tm(&dstime, &tm);
        tv.tv_sec = mktime(&tm);
        tv.tv_usec = 0;
        if (settimeofday(&tv, NULL) == -1)
            return -1;
        
        return 0;
    }

    Linux'ta sistem zamanını set eden settimeofday isimli bir POSIX fonksiyonu vardır. Ancak bu fonksiyon 01/01/1970'ten 
    geçen saniye ve nanosaniye değerini timevaş yapısıyla almaktadır. O halde bizim önce DS3231 RTC modülünden tarih zaman
    bilgisini alıp bunu 01/01/1970'ten geçen saniye sayısına dönüştürmemiz gerekir. Bunun için struct tm alıp time_t veren 
    mktime fonksiyonundan faydalandık.
-----------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <linux/i2c.h>
#include <linux/i2c-dev.h>

#define DS3231_ADDR             0x68

#define DS3231_REG_SECOND       0x00
#define DS3231_REG_MINUTE       0x01
#define DS3231_REG_HOUR         0x02
#define DS3231_REG_DAY          0x03
#define DS3231_REG_DATE         0x04
#define DS3231_REG_MONTH        0x05
#define DS3231_REG_YEAR         0x06
#define DS3231_REG_ALARM1_SEC   0x07
#define DS3231_REG_ALARM1_MIN   0x08
#define DS3231_REG_ALARM1_HR    0x09
#define DS3231_REG_ALARM1_DAY   0x0A
#define DS3231_REG_ALARM2_MIN   0x0B
#define DS3231_REG_ALARM2_HR    0x0C
#define DS3231_REG_ALARM2_DAY   0x0D
#define DS3231_REG_CONTROL      0x0E
#define DS3231_REG_STATUS       0x0F
#define DS3231_REG_AGING        0x10
#define DS3231_REG_TEMP_MSB     0x11
#define DS3231_REG_TEMP_LSB     0x12

#define BCD_TO_DEC(val)     ((((val) >> 4) * 10) + ((val) & 0x0F))
#define DEC_TO_BCD(val)     ((((val) / 10) << 4) | ((val) % 10))

typedef struct {
    uint8_t second;   // 0-59
    uint8_t minute;   // 0-59
    uint8_t hour;     // 0-23
    uint8_t weekday;  // 1-7 (Pazartesi=1)
    uint8_t day;      // 1-31
    uint8_t month;    // 1-12
    uint16_t year;    // 2000-2099
} DS3231_TIME;

int ds3231_read_register(int i2c_fd, uint8_t reg_addr);
int ds3231_read_registers(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length);
int ds3231_read_reg_msg(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length);
int ds3231_write_register(int i2c_fd, uint8_t reg, uint8_t value);
int ds3231_write_registers(int i2c_fd, uint8_t reg_addr, const uint8_t *buffer, size_t length);

int ds3231_gettime(int i2c_fd, DS3231_TIME *dstime);
int ds3231_settime(int i2c_fd, const DS3231_TIME *dstime);
int ds3231_settime_host2rtc(int i2c_fd);
int ds3231_settime_rtc2host(int i2c_fd);

void exit_sys(const char *msg);    

int main(void)
{
    int i2c_fd;
    DS3231_TIME dstime;
    
    if ((i2c_fd = open("/dev/i2c-2", O_RDWR)) == -1) 
        exit_sys("open");

    if (ioctl(i2c_fd, I2C_SLAVE, DS3231_ADDR) == -1) 
        exit_sys("ioctl");
    
    if (ds3231_gettime(i2c_fd, &dstime) == -1)
        exit_sys("ds3231_gettime");

    printf("%02d/%02d/%04d %02d:%02d:%02d\n", dstime.day, dstime.month, dstime.year, 
            dstime.hour, dstime.minute, dstime.second);

    dstime.day = 1;
    dstime.month = 1;
    dstime.year = 1;
    dstime.hour = 23;
    dstime.minute = 59;
    dstime.second = 59;

    if (ds3231_settime(i2c_fd, &dstime) == -1)
        exit_sys("ds3231_gettime");

    if (ds3231_gettime(i2c_fd, &dstime) == -1)
        exit_sys("ds3231_gettime");

    printf("%02d/%02d/%04d %02d:%02d:%02d\n", dstime.day, dstime.month, dstime.year, 
            dstime.hour, dstime.minute, dstime.second);

    ds3231_settime_host2rtc(i2c_fd);

    if (ds3231_gettime(i2c_fd, &dstime) == -1)
        exit_sys("ds3231_gettime");

    printf("%02d/%02d/%04d %02d:%02d:%02d\n", dstime.day, dstime.month, dstime.year, 
            dstime.hour, dstime.minute, dstime.second);

    dstime.day = 1;
    dstime.month = 1;
    dstime.year = 1;
    dstime.hour = 23;
    dstime.minute = 59;
    dstime.second = 59;

    if (ds3231_settime(i2c_fd, &dstime) == -1)
        exit_sys("ds3231_gettime");

    if (ds3231_settime_rtc2host(i2c_fd) == -1)
        exit_sys("ds3231_settime_rtc2host");

    close(i2c_fd);

    return 0;
}

int ds3231_read_register(int i2c_fd, uint8_t reg_addr) 
{
    uint8_t data;
    
    if (write(i2c_fd, &reg_addr, 1) != 1) 
        return -1;
    if (read(i2c_fd, &data, 1) != 1) 
        return -1;
    
    return data;
}

int ds3231_read_registers(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length) 
{    
    if (write(i2c_fd, &reg_addr, 1) != 1) 
        return -1;
    if (read(i2c_fd, buffer, length) != (ssize_t)length) 
        return -1;
    
    return 0;
}

int ds3231_read_reg_msg(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length) 
{
    struct i2c_msg messages[2];
    struct i2c_rdwr_ioctl_data msgset;
    
    messages[0].addr = DS3231_ADDR;
    messages[0].flags = 0;              // Write, register selection
    messages[0].len = 1;
    messages[0].buf = &reg_addr;   

    messages[1].addr = DS3231_ADDR;
    messages[1].flags = 1;              // Read multi byte
    messages[1].len = length;
    messages[1].buf = buffer;
    
    msgset.msgs = messages;
    msgset.nmsgs = 2;
    
    if (ioctl(i2c_fd, I2C_RDWR, &msgset) < 0) 
        return -1;
        
    return 0;
}

int ds3231_write_register(int i2c_fd, uint8_t reg, uint8_t value) 
{
    uint8_t buffer[2] = {reg, value};
    
    if (write(i2c_fd, buffer, 2) != 2) 
        return -1;
    
    return 0;
}

int ds3231_write_registers(int i2c_fd, uint8_t reg_addr, const uint8_t *buffer, size_t length)
{
    uint8_t tmp[1 + 18];

    if (length > 18) {
        errno = EINVAL;
        return -1;
    }

    tmp[0] = reg_addr;
    memcpy(&tmp[1], buffer, length);

    if (write(i2c_fd, tmp, sizeof(tmp)) != (ssize_t)sizeof(tmp))
        return -1;

    return 0;
}

int ds3231_gettime(int i2c_fd, DS3231_TIME *dstime)
{
    uint8_t buf[7];

    if (ds3231_read_registers(i2c_fd, 0, buf, 7) == -1)
        return -1;
    
    dstime->second = BCD_TO_DEC(buf[0]);
    dstime->minute = BCD_TO_DEC(buf[1]);
    dstime->hour = BCD_TO_DEC(buf[2]);
    dstime->weekday = BCD_TO_DEC(buf[3]);
    dstime->day = BCD_TO_DEC(buf[4]);
    dstime->month = BCD_TO_DEC(buf[5]);
    dstime->year = BCD_TO_DEC(buf[6]) + 2000;

    return 0;
}

int ds3231_settime(int i2c_fd, const DS3231_TIME *dstime)
{
    uint8_t buf[7];

    buf[0] = DEC_TO_BCD(dstime->second);
    buf[1] = DEC_TO_BCD(dstime->minute);
    buf[2] = DEC_TO_BCD(dstime->hour);
    buf[3] = DEC_TO_BCD(dstime->weekday);
    buf[4] = DEC_TO_BCD(dstime->day);
    buf[5] = DEC_TO_BCD(dstime->month);
    buf[6] = DEC_TO_BCD(dstime->year);
    
    if (ds3231_write_registers(i2c_fd, 0, buf, 7) == -1)
        return -1;

    return 0;
}

int ds3231_settime_host2rtc(int i2c_fd)
{
    time_t t;
    struct tm *ptm;
    DS3231_TIME dstime;
    
    t = time(NULL);
    ptm = localtime(&t);

    dstime.second = ptm->tm_sec;
    dstime.minute = ptm->tm_min;
    dstime.hour = ptm->tm_hour;
    dstime.weekday = ptm->tm_wday == 0 ? 7 : ptm->tm_wday;
    dstime.day = ptm->tm_mday;
    dstime.month = ptm->tm_mon + 1;
    dstime.year = ptm->tm_year - 100;

    if (ds3231_settime(i2c_fd, &dstime) == -1)
        return -1;

    return 0;
}

void ds3231_time2tm(const DS3231_TIME *dstime, struct tm *ptm)
{
    ptm->tm_sec  = dstime->second;
    ptm->tm_min  = dstime->minute;
    ptm->tm_hour = dstime->hour;
    ptm->tm_mday = dstime->day;
    ptm->tm_mon  = dstime->month - 1;    
    ptm->tm_year = dstime->year - 1900;
    ptm->tm_wday = dstime->weekday == 7 ? 0 : dstime->weekday;
    ptm->tm_yday = 0;
    ptm->tm_isdst = -1;
}

int ds3231_settime_rtc2host(int i2c_fd)
{
    DS3231_TIME dstime;
    struct timeval tv;
    struct tm tm;
    
    if (ds3231_gettime(i2c_fd, &dstime) == -1)
        return -1;

    ds3231_time2tm(&dstime, &tm);
    tv.tv_sec = mktime(&tm);
    tv.tv_usec = 0;
    if (settimeofday(&tv, NULL) == -1)
        return -1;
    
    return 0;
}


void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
    DS3231 denetleyicisinde alarm mekanizması da vardır. Bunun iki alarm bulundurulmuştur. Bunlara "Alarm 1" ve "Alarm 2" 
    denilmektedir. Alarmları kurmak için yine yazmaç kullanılmaktadır. Bu yazmaçlar hakkındaki bilgiler aşağıdaki tabloda 
    özetlenmektedir:

    ╔═══════════════════════════════════════════════════════════════════════════════════════════╗
    ║                           DS3231 ALARM YAZMAÇLARI                                         ║
    ╠═══════════╦═══════════╦═══════════════════════════════════════════════════════════════════╣
    ║  YAZMAC   ║   ADRES   ║                         BİT YAPISI                                ║
    ╠═══════════╬═══════════╬═══════════════════════════════════════════════════════════════════╣
    ║           ║           ║  Bit 7  │  Bit 6  │  Bit 5  │  Bit 4  │  Bit 3-0                  ║
    ╠═══════════╬═══════════╬═════════╪═════════╪═════════╪═════════╪═══════════════════════════╣
    ║ ALARM 1   ║           ║         │         │         │         │                           ║
    ╠═══════════╬═══════════╬═════════╪═════════╪═════════╪═════════╪═══════════════════════════╣
    ║ A1M1      ║   0x07    ║   A1M1  │    -    │         10s       │        1s                 ║
    ║ Saniye    ║           ║  (Mask) │    0    │      (0-5)        │      (0-9)                ║
    ╠═══════════╬═══════════╬═════════╪═════════╪═════════╪═════════╪═══════════════════════════╣
    ║ A1M2      ║   0x08    ║   A1M2  │    -    │         10dk      │        1dk                ║
    ║ Dakika    ║           ║  (Mask) │    0    │      (0-5)        │      (0-9)                ║
    ╠═══════════╬═══════════╬═════════╪═════════╪═════════╪═════════╪═══════════════════════════╣
    ║ A1M3      ║   0x09    ║   A1M3  │    -    │ 12/24   │  10sa   │        1sa                ║
    ║ Saat      ║           ║  (Mask) │    0    │  (AM/PM)│  (0-2)  │      (0-9)                ║
    ╠═══════════╬═══════════╬═════════╪═════════╪═════════╪═════════╪═══════════════════════════╣
    ║ A1M4      ║   0x0A    ║   A1M4  │  DY/DT  │    -    │  10gün  │       1gün                ║
    ║ Gün/Tarih ║           ║  (Mask) │(Gün/Tar)│    0    │  (0-3)  │      (0-9)                ║
    ╠═══════════╩═══════════╩═════════╧═════════╧═════════╧═════════╧═══════════════════════════╣
    ║ ALARM 2   ║           ║         │         │         │         │                           ║
    ╠═══════════╬═══════════╬═════════╪═════════╪═════════╪═════════╪═══════════════════════════╣
    ║ A2M2      ║   0x0B    ║   A2M2  │    -    │         10dk      │        1dk                ║
    ║ Dakika    ║           ║  (Mask) │    0    │      (0-5)        │      (0-9)                ║
    ╠═══════════╬═══════════╬═════════╪═════════╪═════════╪═════════╪═══════════════════════════╣
    ║ A2M3      ║   0x0C    ║   A2M3  │    -    │ 12/24   │  10sa   │        1sa                ║
    ║ Saat      ║           ║  (Mask) │    0    │  (AM/PM)│  (0-2)  │      (0-9)                ║
    ╠═══════════╬═══════════╬═════════╪═════════╪═════════╪═════════╪═══════════════════════════╣
    ║ A2M4      ║   0x0D    ║   A2M4  │  DY/DT  │    -    │  10gün  │       1gün                ║
    ║ Gün/Tarih ║           ║  (Mask) │(Gün/Tar)│    0    │  (0-3)  │      (0-9)                ║
    ╚═══════════╩═══════════╩═════════╧═════════╧═════════╧═════════╧═══════════════════════════╝

    ╔════════════════════════════════════════════════════════════════════════════════════════════╗
    ║                         ALARM MASKELEME (AxMy) BİTLERİ                                     ║
    ╠════════════════════════════════════════════════════════════════════════════════════════════╣
    ║  • AxMy = 1 ise o alan alarm eşleşmesinde GÖRMEZDEN GELİNİR                                ║
    ║  • AxMy = 0 ise o alan alarm eşleşmesinde KONTROL EDİLİR                                   ║
    ╠════════════════════════════════════════════════════════════════════════════════════════════╣
    ║                            ALARM 1 MASKELEME MODLARI                                       ║
    ╠═══════╦═══════╦═══════╦═══════╦════════════════════════════════════════════════════════════╣
    ║  A1M4 ║  A1M3 ║  A1M2 ║  A1M1 ║              ALARM KOŞULU                                  ║
    ╠═══════╬═══════╬═══════╬═══════╬════════════════════════════════════════════════════════════╣
    ║   1   ║   1   ║   1   ║   1   ║  Her saniye                                                ║
    ║   1   ║   1   ║   1   ║   0   ║  Saniyeler eşleştiğinde                                    ║
    ║   1   ║   1   ║   0   ║   0   ║  Dakika ve saniye eşleştiğinde                             ║
    ║   1   ║   0   ║   0   ║   0   ║  Saat, dakika ve saniye eşleştiğinde                       ║
    ║   0   ║   0   ║   0   ║   0   ║  Tarih, saat, dakika ve saniye eşleştiğinde                ║
    ║   0   ║   0   ║   0   ║   0   ║  Gün, saat, dakika ve saniye eşleştiğinde (DY/DT=1 ise)    ║
    ╠════════════════════════════════════════════════════════════════════════════════════════════╣
    ║                            ALARM 2 MASKELEME MODLARI                                       ║
    ╠═══════╦═══════╦═══════╦════════════════════════════════════════════════════════════════════╣
    ║  A2M4 ║  A2M3 ║  A2M2 ║              ALARM KOŞULU                                          ║
    ╠═══════╬═══════╬═══════╬════════════════════════════════════════════════════════════════════╣
    ║   1   ║   1   ║   1   ║  Her dakika (00. saniyede)                                         ║
    ║   1   ║   1   ║   0   ║  Dakikalar eşleştiğinde                                            ║
    ║   1   ║   0   ║   0   ║  Saat ve dakika eşleştiğinde                                       ║
    ║   0   ║   0   ║   0   ║  Tarih, saat ve dakika eşleştiğinde                                ║
    ║   0   ║   0   ║   0   ║  Gün, saat ve dakika eşleştiğinde (DY/DT=1 ise)                    ║
    ╚═══════╩═══════╩═══════╩════════════════════════════════════════════════════════════════════╝

    ╔════════════════════════════════════════════════════════════════════════════════════════════╗
    ║                              ÖNEMLİ NOTLAR                                                 ║
    ╠════════════════════════════════════════════════════════════════════════════════════════════╣
    ║  • Tüm değerler BCD (Binary Coded Decimal) formatındadır                                   ║
    ║  • DY/DT biti: 0=Tarih (1-31), 1=Gün (1-7, Pazartesi=1)                                    ║
    ║  • Alarm 1 saniye çözünürlüğüne sahiptir                                                   ║
    ║  • Alarm 2 dakika çözünürlüğüne sahiptir (saniye yok)                                      ║
    ╚════════════════════════════════════════════════════════════════════════════════════════════╝

    Yukarıdaki tabloya bakıldığında şunlar görülmektedir: Alarmların oluşacağı saniye, dakika, saat ve gün bilgisi DS3231
    yazmaçlarına BCD olarak yazılmak suretiyle alarm set edilmektedir. (Ancak Alarm 2'de saniye set edileemektedir.) Alarmların
    ne zaman oluşacağına ilişkin "alarm koşulları" vardır. Alarm 1 için bu koşullar şöyle bir tabloyla gösterilmiştir:

    ╔════════════════════════════════════════════════════════════════════════════════════════════╗
    ║  A1M4 ║  A1M3 ║  A1M2 ║  A1M1 ║              ALARM KOŞULU                                  ║
    ╠═══════╬═══════╬═══════╬═══════╬════════════════════════════════════════════════════════════╣
    ║   1   ║   1   ║   1   ║   1   ║  Her saniye                                                ║
    ║   1   ║   1   ║   1   ║   0   ║  Saniyeler eşleştiğinde                                    ║
    ║   1   ║   1   ║   0   ║   0   ║  Dakika ve saniye eşleştiğinde                             ║
    ║   1   ║   0   ║   0   ║   0   ║  Saat, dakika ve saniye eşleştiğinde                       ║
    ║   0   ║   0   ║   0   ║   0   ║  Tarih, saat, dakika ve saniye eşleştiğinde                ║
    ║   0   ║   0   ║   0   ║   0   ║  Gün, saat, dakika ve saniye eşleştiğinde (DY/DT=1 ise)    ║
    ╚═══════╩═══════╩═══════╩════════════════════════════════════════════════════════════════════╝

    Burada 4 bitin çeşitli değerlerine yönelik durumlar belirtilmiştir. Burada en fazla kullanılan seçenek 1000 ile belirtilen 
    "Saat, dakika ve saniye eşleştiğinde" oluşan alarm seçeneğidir. Alarmı böyle kurduğumuzda her gün o saat burada belirtilen 
    zamanı gösterdiğinde yeniden alarm çalar. Buradaki A1M4, A1M3, A1M2 ve A1M1 bitleri aslında alarmı kurmakta kullandığımız
    yazmaçların en yüksek anlamlı (7'inci bit) bitleridir. A1M1 Saniye yazmacının, A1M2 dakika yazmacının, A1M3 saat yazmacının 
    ve A1M4 gün yazmacının 7'inci bitini belirtmektedir. Alarmın gün değeri iki biçimde set edilebilmektedir: Ayın günü ve 
    haftanın günü. İşte gün yazmacının 6'ıncı biti (DY/DT biti) 0 ise ayın günü, 1 ise haftanın günü anlamına gelmektedir. 
    Alarm 2'de benzer biçimde yazmaçlara sahiptir. Ancak yukarıda da belirttiğimiz gibi Alarm 2'de saniye duyarlılığı yoktur. 
    Peki akarm koşulu sağlandığında ne olmaktadır?
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                        151. Ders 18/12/2025 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Alarm koşulu sağlandığında (başka bir deyişle alarm çaldığında) DS3231'in durum yazmacının ilgili bitleri set edilmektedir. 
    Bu durumda sistem programcısı ya bu durum yazmacının ilgili bitlerine bir döngü içeirisinde bakarak alarmın oluşup oluşmadığını
    anlamalı (buna "polling" yöntemi dendiğini anımsayınız) ya da kesme özelleğini kullanmalıdır. Yani sistem programcısının 
    önümde iki seçenek vardır:

    1) Sürekli yoklama (polling) yöntemi
    2) Kesme (interrupt) yöntemi

    Her iki durumda da durum yazmacının ilgili biti denetleyici tarafından 1 yapılmaktadır. Bu bitin sistem programcısı tarafından
    yeniden 0'lanması gerekmektedir. Aksi takdirde her iki yöntemde de bir daha alarm oluşmayacaktır. DS3231'in durum 
    yazmacının bitleri şöyledir:

    ┌─────┬─────────────────────────────────────────┐
    │ Bit │ Açıklama                                │
    ├─────┼─────────────────────────────────────────┤
    │  7  │ OSF (Oscillator Stop Flag)              │
    ├─────┼─────────────────────────────────────────┤
    │ 6-4 │ (0)                                     │
    ├─────┼─────────────────────────────────────────┤
    │  3  │ EN32kHz (Enable 32kHz Output)           │
    ├─────┼─────────────────────────────────────────┤
    │  2  │ BSY (Busy - sıcaklık dönüşümü)          │
    ├─────┼─────────────────────────────────────────┤
    │  1  │ A2F (Alarm 2 Flag)                      │
    ├─────┼─────────────────────────────────────────┤
    │  0  │ A1F (Alarm 1 Flag)                      │
    └─────┴─────────────────────────────────────────┘

    Görüldüğü gibi durum yazmacının 0'ıncı biti Alaram 1'in oluşup olmadığını 1'innci biti ise ALarm 2'nin oluşup oluşmadığını 
    belirtmektedir. Yukarıda da belirttiğimiz gibi bu alarm bitleri 1 olduğunda bizim bunları programlama yoluyla 0'lamamız 
    gerekir. Aksi takdirde bir daha alarm ve kesme oluşmayacaktır. 

    Kesme tekniği kullanılacaksa DS3231 RTC modülünün SQW/INTR ucunun kesme oluşturacak kaynağa bağlanmaıs gerekemektedir. 
    DS3231'in SQW/INTR pini "open-drain" durumdadır. Dolayısıyla normal olarak araya bir 10K civarında bir pull-up direncinin 
    eklenmesi gerekir:

                   3.3V
                    │
                   ┌┴┐
                   │ │  10kΩ Pull-up
                   └┬┘
                    │
    DS3231      BBB │
    SQW/INTR ───────┴─── P9_16 (GPIO51)

    Fakat DS3231 RTC modülünündeki kart üzerinde zaten bu pull-up direnci yerleştirilmiştir. Dolayısıyla bizim uygulamamızda
    buna gereksinim duyulmayacaktır. 
    
    Kesme mekanizmasının devreye girmesi için aynı zamanda DS3231'in kontol yazmacında da ayarlamnın yapılması gerekmektedir. 
    Kontrol yazmacının bitleri şu anlamlardadır:

    ┌─────┬─────────────────────────────────────────────┐
    │ Bit │ Açıklama                                    │
    ├─────┼─────────────────────────────────────────────┤
    │  7  │ EOSC (Enable Oscillator)                    │
    ├─────┼─────────────────────────────────────────────┤
    │  6  │ BBSQW (Battery-Backed Square Wave)          │
    ├─────┼─────────────────────────────────────────────┤
    │  5  │ CONV (Convert Temperature)                  │
    ├─────┼─────────────────────────────────────────────┤
    │ 4-3 │ RS2, RS1 (Rate Select - SQW frekansı)       │
    ├─────┼─────────────────────────────────────────────┤
    │  2  │ INTCN (Interrupt Control)                   │
    ├─────┼─────────────────────────────────────────────┤
    │  1  │ A2IE (Alarm 2 Interrupt Enable)             │
    ├─────┼─────────────────────────────────────────────┤
    │  0  │ A1IE (Alarm 1 Interrupt Enable)             │
    └─────┴─────────────────────────────────────────────┘

    Bu yazamacın 0'ınci biti Alarm 1'i kesme moduna geöirmekte, 1'inci biti ise Alaram 2'yi kesme modunda geçirmektedir. Bunun 
    dışında bizim aynı zamanda bu yazmacın 2'inci bitini 1 yapmamaız gerekir. Çünkü bu INTCN biti SQW/INTR ucunun SQW (kare 
    dalga) amacıyla mı kesme amacıyla mı kullanılacağını belirtmektedir. Bu bit 1 yapılırsa bu uç kesme amacıyla 0 yapılırsa 
    SQW amacıyla kullanılmaktadır. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bizim sistem programcısı olarak alarm mekanizması için birkaç yüksek seviyeli fonksiyonu yazmamız uygun olur. Alarmı kuran
    set_alarm1 fonksiyonunun paramtrik yapısı şöyle olabilir:

    int set_alarm1(int fd, uint8_t hour, uint8_t minute, uint8_t second, int polling) 
    {
        /* ... */
    }

    Bu fonksiyona Alarm 1'i kurduğu için set_alarm1 ismini verdik. Fonksiyon aygıt dısyasının betimelyicisini ve alarımın 
    çalacağı saat, dakika ve saniyeyi parametre olarak almaktadır. Fonksiyon başarı durumunda 0 değerine başarısızlık durumudna 
    -1 değerine geri dönmektedir. Fonksiyon saat, dakika, saniye eşleştiğinde alarmın oluşmasını sağlayacağı için A1M4, A1M3, 
    A1M2, A1M1 bitleri 1000 biçiminde olmalıdır. Fonksiyonun son parametresi sıfır dışı bir değer olarak girilirse alarm "polling"
    modunda, o girilirse "kesme" modunda işlev görecektir. 
    
    Fonksiyon şöyle yazılabilir:

    int set_alarm1(int i2c_fd, uint8_t hour, uint8_t minute, uint8_t second, int polling) 
    {
        uint8_t reg;

        if (ds3231_write_register(i2c_fd, DS3231_REG_ALARM1_SEC, DEC_TO_BCD(second) & 0x7F) == -1) 
            return -1;
        if (ds3231_write_register(i2c_fd, DS3231_REG_ALARM1_MIN, DEC_TO_BCD(minute) & 0x7F) == -1) 
            return -1;
        if (ds3231_write_register(i2c_fd, DS3231_REG_ALARM1_HR, DEC_TO_BCD(hour) & 0x7F) == -1) 
            return -1;
        if (ds3231_write_register(i2c_fd, DS3231_REG_ALARM1_DAY, 0x80) == -1) 
            return -1;

        if ((reg = ds3231_read_register(i2c_fd, DS3231_REG_STATUS)) == -1) 
            return -1;
        if (ds3231_write_register(i2c_fd, DS3231_REG_STATUS, reg & ~0x01) == -1) 
            return -1;

        if ((reg = ds3231_read_register(i2c_fd, DS3231_REG_CONTROL)) == -1) 
            return -1;
        if (ds3231_write_register(i2c_fd, DS3231_REG_CONTROL, polling ? (reg & ~0x05) : (reg | 0x05))  == -1) 
            return -1;

        return 0;
    }
        
    Fonksiyonda biz yazmaçlara değerlerini yazdık. Duurm yazmacının 0'ıncı bitini her ihtimalae karşı sıfırladık. Sonra da
    alarm mekanizmasını polling ya da kesme moduna soktuk. Alarmı polling modunda test etmek iin aşağıdaki gibi bir 
    program kullanılabilir:

    int main(int argc, char *argv[])
    {
        int i2c_fd;
        uint8_t hour, minute, second;
        DS3231_TIME dstime;
        int result;
        
        if (argc != 4 && argc != 1) {
            fprintf(stderr, "wrong number of arguments!..\n");
            fprintf(stderr, "usage: rtc-alarm hour minute second\n");
            exit(EXIT_FAILURE);
        }

        if ((i2c_fd = open("/dev/i2c-2", O_RDWR)) == -1) 
            exit_sys("open");

        if (ioctl(i2c_fd, I2C_SLAVE, DS3231_ADDR) == -1) 
            exit_sys("ioctl");

        if (argc == 4) {
            hour = atoi(argv[1]);
            minute = atoi(argv[2]);
            second = atoi(argv[3]);
        }
        else {
            if (ds3231_gettime(i2c_fd, &dstime) == -1)
                exit_sys("ds3231_gettime");
            hour = dstime.hour;
            minute = (dstime.minute + 1);
            if (minute >= 60) {
                minute = 0;
                hour = (hour + 1) % 24;
            }
            second = dstime.second;
        }
        
        if (set_alarm1(i2c_fd, hour, minute, second, 1) == -1)
            exit_sys("set_alarm1");

        for (;;) {
            result = check_alarm1(i2c_fd);
            if (result == -1) 
                exit_sys("check_alarm");
            if (result) {
                printf("ALARM ALARM ALARM....\n");
                break;
            }
        usleep(100000);
        }

        close(i2c_fd);

        return 0;
    }
        
    Burada program ya komut satırı argümansız ya da program ismi dışında 3 komut satırı argümanıyla çalıştırılabilmektedir. 
    Eğer progra komut satırı argümanı girilmedne çalıştırılırsa alarm 1 dakşka sonraya kurulmaktadır. Eğer program üç komut 
    satırı argümanı girilerek çalıştırılırsa saat, dakika ve saniye dolduğunda alarm oluşmaktadır. Programda daha sonra döngü 
    içerisinde aşağıdaki gibi polling yapılmıştır:

     for (;;) {
        result = check_alarm1(i2c_fd);
        if (result == -1) 
            exit_sys("check_alarm");
        if (result) {
            printf("ALARM ALARM ALARM....\n");
            break;
        }
        usleep(100000);
    }

    Buradaki check_alarm1 fonksiyonu durum yazmacına bakarak alarmın oluşup oluşmadığını kontrol etmektedir. Bu tür polling 
    işlemlerinde mutlaka küçük de olsa bir bekleme uygulamalısınız. Burada saniyenin 1/10'u kadar beklemeler yapılmıştır. 
    Aşağıda tüm kodu veriyoruz. BBB'nin ilgili pinlerini konfigüre etmeyi unutmayınız:
        
    $ config-pin P9_19 i2c
    Current mode for P9_19 is:     i2c

    $ config-pin P9_20 i2c
    Current mode for P9_20 is:     i2c
-----------------------------------------------------------------------------------------------------------------------------*/
 
 /* rtc-alarm.c */

 #include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <linux/i2c.h>
#include <linux/i2c-dev.h>

#define DS3231_ADDR             0x68

#define DS3231_REG_SECOND       0x00
#define DS3231_REG_MINUTE       0x01
#define DS3231_REG_HOUR         0x02
#define DS3231_REG_DAY          0x03
#define DS3231_REG_DATE         0x04
#define DS3231_REG_MONTH        0x05
#define DS3231_REG_YEAR         0x06
#define DS3231_REG_ALARM1_SEC   0x07
#define DS3231_REG_ALARM1_MIN   0x08
#define DS3231_REG_ALARM1_HR    0x09
#define DS3231_REG_ALARM1_DAY   0x0A
#define DS3231_REG_ALARM2_MIN   0x0B
#define DS3231_REG_ALARM2_HR    0x0C
#define DS3231_REG_ALARM2_DAY   0x0D
#define DS3231_REG_CONTROL      0x0E
#define DS3231_REG_STATUS       0x0F
#define DS3231_REG_AGING        0x10
#define DS3231_REG_TEMP_MSB     0x11
#define DS3231_REG_TEMP_LSB     0x12

#define BCD_TO_DEC(val)     ((((val) >> 4) * 10) + ((val) & 0x0F))
#define DEC_TO_BCD(val)     ((((val) / 10) << 4) | ((val) % 10))

typedef struct {
    uint8_t second;   // 0-59
    uint8_t minute;   // 0-59
    uint8_t hour;     // 0-23
    uint8_t weekday;  // 1-7 (Pazartesi=1)
    uint8_t day;      // 1-31
    uint8_t month;    // 1-12
    uint16_t year;    // 2000-2099
} DS3231_TIME;

int ds3231_read_register(int i2c_fd, uint8_t reg_addr);
int ds3231_read_registers(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length);
int ds3231_read_reg_msg(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length);
int ds3231_write_register(int i2c_fd, uint8_t reg, uint8_t value);
int ds3231_write_registers(int i2c_fd, uint8_t reg_addr, const uint8_t *buffer, size_t length);

int ds3231_gettime(int i2c_fd, DS3231_TIME *dstime);
int ds3231_settime(int i2c_fd, const DS3231_TIME *dstime);
int ds3231_settime_host2rtc(int i2c_fd);
int ds3231_settime_rtc2host(int i2c_fd);
int set_alarm1(int i2c_fd, uint8_t hour, uint8_t minute, uint8_t second, int polling);   
int check_alarm1(int i2c_fd);

void exit_sys(const char *msg);    

int main(int argc, char *argv[])
{
    int i2c_fd;
    uint8_t hour, minute, second;
    DS3231_TIME dstime;
    int result;
    
    if (argc != 4 && argc != 1) {
        fprintf(stderr, "wrong number of arguments!..\n");
        fprintf(stderr, "usage: rtc-alarm hour minute second\n");
        exit(EXIT_FAILURE);
    }

    if ((i2c_fd = open("/dev/i2c-2", O_RDWR)) == -1) 
        exit_sys("open");

    if (ioctl(i2c_fd, I2C_SLAVE, DS3231_ADDR) == -1) 
        exit_sys("ioctl");

     if (argc == 4) {
        hour = atoi(argv[1]);
        minute = atoi(argv[2]);
        second = atoi(argv[3]);
    }
    else {
        if (ds3231_gettime(i2c_fd, &dstime) == -1)
            exit_sys("ds3231_gettime");
        hour = dstime.hour;
        minute = (dstime.minute + 1);
        if (minute >= 60) {
            minute = 0;
            hour = (hour + 1) % 24;
        }
        second = dstime.second;
    }
    
    if (set_alarm1(i2c_fd, hour, minute, second, 1) == -1)
        exit_sys("set_alarm1");

    for (;;) {
        result = check_alarm1(i2c_fd);
        if (result == -1) 
            exit_sys("check_alarm1");
        if (result) {
            printf("ALARM ALARM ALARM....\n");
            break;
        }
      usleep(100000);
    }

    close(i2c_fd);

    return 0;
}

int ds3231_read_register(int i2c_fd, uint8_t reg_addr) 
{
    uint8_t data;
    
    if (write(i2c_fd, &reg_addr, 1) != 1) 
        return -1;
    if (read(i2c_fd, &data, 1) != 1) 
        return -1;
    
    return data;
}

int ds3231_read_registers(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length) 
{    
    if (write(i2c_fd, &reg_addr, 1) != 1) 
        return -1;
    if (read(i2c_fd, buffer, length) != (ssize_t)length) 
        return -1;
    
    return 0;
}

int ds3231_read_reg_msg(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length) 
{
    struct i2c_msg messages[2];
    struct i2c_rdwr_ioctl_data msgset;
    
    messages[0].addr = DS3231_ADDR;
    messages[0].flags = 0;              // Write, register selection
    messages[0].len = 1;
    messages[0].buf = &reg_addr;   

    messages[1].addr = DS3231_ADDR;
    messages[1].flags = 1;              // Read multi byte
    messages[1].len = length;
    messages[1].buf = buffer;
    
    msgset.msgs = messages;
    msgset.nmsgs = 2;
    
    if (ioctl(i2c_fd, I2C_RDWR, &msgset) < 0) 
        return -1;
        
    return 0;
}

int ds3231_write_register(int i2c_fd, uint8_t reg, uint8_t value) 
{
    uint8_t buffer[2] = {reg, value};
    
    if (write(i2c_fd, buffer, 2) != 2) 
        return -1;
    
    return 0;
}

int ds3231_write_registers(int i2c_fd, uint8_t reg_addr, const uint8_t *buffer, size_t length)
{
    uint8_t tmp[1 + 18];

    if (length > 18) {
        errno = EINVAL;
        return -1;
    }

    tmp[0] = reg_addr;
    memcpy(&tmp[1], buffer, length);

    if (write(i2c_fd, tmp, sizeof(tmp)) != (ssize_t)sizeof(tmp))
        return -1;

    return 0;
}

int ds3231_gettime(int i2c_fd, DS3231_TIME *dstime)
{
    uint8_t buf[7];

    if (ds3231_read_registers(i2c_fd, 0, buf, 7) == -1)
        return -1;
    
    dstime->second = BCD_TO_DEC(buf[0]);
    dstime->minute = BCD_TO_DEC(buf[1]);
    dstime->hour = BCD_TO_DEC(buf[2]);
    dstime->weekday = BCD_TO_DEC(buf[3]);
    dstime->day = BCD_TO_DEC(buf[4]);
    dstime->month = BCD_TO_DEC(buf[5]);
    dstime->year = BCD_TO_DEC(buf[6]) + 2000;

    return 0;
}

int ds3231_settime(int i2c_fd, const DS3231_TIME *dstime)
{
    uint8_t buf[7];

    buf[0] = DEC_TO_BCD(dstime->second);
    buf[1] = DEC_TO_BCD(dstime->minute);
    buf[2] = DEC_TO_BCD(dstime->hour);
    buf[3] = DEC_TO_BCD(dstime->weekday);
    buf[4] = DEC_TO_BCD(dstime->day);
    buf[5] = DEC_TO_BCD(dstime->month);
    buf[6] = DEC_TO_BCD(dstime->year);
    
    if (ds3231_write_registers(i2c_fd, 0, buf, 7) == -1)
        return -1;

    return 0;
}

int ds3231_settime_host2rtc(int i2c_fd)
{
    time_t t;
    struct tm *ptm;
    DS3231_TIME dstime;
    
    t = time(NULL);
    ptm = localtime(&t);

    dstime.second = ptm->tm_sec;
    dstime.minute = ptm->tm_min;
    dstime.hour = ptm->tm_hour;
    dstime.weekday = ptm->tm_wday == 0 ? 7 : ptm->tm_wday;
    dstime.day = ptm->tm_mday;
    dstime.month = ptm->tm_mon + 1;
    dstime.year = ptm->tm_year - 100;

    if (ds3231_settime(i2c_fd, &dstime) == -1)
        return -1;

    return 0;
}

void ds3231_time2tm(const DS3231_TIME *dstime, struct tm *ptm)
{
    ptm->tm_sec  = dstime->second;
    ptm->tm_min  = dstime->minute;
    ptm->tm_hour = dstime->hour;
    ptm->tm_mday = dstime->day;
    ptm->tm_mon  = dstime->month - 1;    
    ptm->tm_year = dstime->year - 1900;
    ptm->tm_wday = dstime->weekday == 7 ? 0 : dstime->weekday;
    ptm->tm_yday = 0;
    ptm->tm_isdst = -1;
}

int ds3231_settime_rtc2host(int i2c_fd)
{
    DS3231_TIME dstime;
    struct timeval tv;
    struct tm tm;
    
    if (ds3231_gettime(i2c_fd, &dstime) == -1)
        return -1;

    ds3231_time2tm(&dstime, &tm);
    tv.tv_sec = mktime(&tm);
    tv.tv_usec = 0;
    if (settimeofday(&tv, NULL) == -1)
        return -1;
    
    return 0;
}

int set_alarm1(int i2c_fd, uint8_t hour, uint8_t minute, uint8_t second, int polling) 
{
    uint8_t reg;

    if (ds3231_write_register(i2c_fd, DS3231_REG_ALARM1_SEC, DEC_TO_BCD(second) & 0x7F) == -1) 
        return -1;
    if (ds3231_write_register(i2c_fd, DS3231_REG_ALARM1_MIN, DEC_TO_BCD(minute) & 0x7F) == -1) 
        return -1;
    if (ds3231_write_register(i2c_fd, DS3231_REG_ALARM1_HR, DEC_TO_BCD(hour) & 0x7F) == -1) 
        return -1;
    if (ds3231_write_register(i2c_fd, DS3231_REG_ALARM1_DAY, 0x80) == -1) 
        return -1;

    if ((reg = ds3231_read_register(i2c_fd, DS3231_REG_STATUS)) == -1) 
        return -1;
    if (ds3231_write_register(i2c_fd, DS3231_REG_STATUS, reg & ~0x01) == -1) 
        return -1;

    if ((reg = ds3231_read_register(i2c_fd, DS3231_REG_CONTROL)) == -1) 
        return -1;
    if (ds3231_write_register(i2c_fd, DS3231_REG_CONTROL, polling ? (reg & ~0x05) : (reg | 0x05))  == -1) 
        return -1;

    return 0;
}

int check_alarm1(int i2c_fd)
{
    uint8_t status;

    if ((status = ds3231_read_register(i2c_fd, DS3231_REG_STATUS)) == -1)
        return -1;
    if (status & 1) {
        if (ds3231_write_register(i2c_fd, DS3231_REG_STATUS, status & ~0x01) == -1)
            return -1;
        return 1;
    }
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
                                            152. Ders 06/01/2026 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi de kesme yöntemine örnek verelim. Bunun için daha önceden de belirttiğimiz gibi DS3231 RTC modülünün SQW/INTR ucunu
    P9_16 pinine bağlamıştık. Böylece alarm oluştuğunda P9_16 (GPIO51) lojik 0 seviyesine çekilecektir. 

                   3.3V
                    │
                   ┌┴┐
                   │ │  10kΩ Pull-up
                   └┬┘
                    │
    DS3231      BBB │
    SQW/INTR ───────┴─── P9_16 (GPIO51)
    
    Biz de zaten daha önce bu pin üzerinde kesme denemeleri yapmıştık. Burada bu uygulamanın bazı noktaları üzerinde durmak
    istiyoruz. Bizim bu için öncelikle DS3231'i kesme moduna geçirmemiz gerekir. Biz zaten setalarm1 fonksiyonunda polling 
    parametresi ile bunu ayarlamıştık. Anımsanacağı gibi bu parametre eğer 0 geçilirse DS3231'in birinci alarmı kesme için, 
    sıfır dışı bir değer geçirilirse polling için konfigüre ediliyordu:

    int set_alarm1(int i2c_fd, uint8_t hour, uint8_t minute, uint8_t second, int polling)
    {
        /* ... */
    }

    Uygulamadaki diğer bir nokta da kesmenin gelebilmesi için durum yazmacının ilgili bitlerinin 0'lanması gerektiğidir. DS3231
    modülünde her iki alarm aynı SQW/INTR ucuyla ilişkilendirilmiştir. Biz yalnızca ALRM1 ile ilgileniyor olsak bile o anda 
    ALARM2 için ilgili bit 1 ise bu da kesme oluşumunu engellemektedir. Dolayısıyla kesmenin oluşabilmesi için en garanti 
    yaklaşım her iki alarm için de ilgili bitleri 0'lamaktır. Bu işlemi yapan fonksiyon aşağıdaki gibi yazılabilir:

    int reset_intr_stat(int i2c_fd)
    {
        int reg;

        if ((reg = ds3231_read_register(i2c_fd, DS3231_REG_STATUS)) == -1) 
            return -1;
        if (ds3231_write_register(i2c_fd, DS3231_REG_STATUS, reg & ~0x03) == -1) 
            return -1;

        return 0;
    }

    Bu uygulamada biz P9_16 (GPIO51) pini için "kesme oluşana kadar select fonksiyonuyla bekleme" tekniğini kullandık.
    Aşağıda uygulamanın kodları verilmiştir. Test işleminden önce pinleri I2C olarak konfigüre etmeyi unutmayınız:

    $ config-pin P9_19 i2c
    Current mode for P9_19 is:     i2c

    $ config-pin P9_20 i2c
    Current mode for P9_20 is:     i2c
-----------------------------------------------------------------------------------------------------------------------------*/

/* rtc-alarm-intr.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdint.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/select.h>
#include <linux/i2c.h>
#include <linux/i2c-dev.h>

#define DS3231_ADDR             0x68

#define DS3231_REG_SECOND       0x00
#define DS3231_REG_MINUTE       0x01
#define DS3231_REG_HOUR         0x02
#define DS3231_REG_DAY          0x03
#define DS3231_REG_DATE         0x04
#define DS3231_REG_MONTH        0x05
#define DS3231_REG_YEAR         0x06
#define DS3231_REG_ALARM1_SEC   0x07
#define DS3231_REG_ALARM1_MIN   0x08
#define DS3231_REG_ALARM1_HR    0x09
#define DS3231_REG_ALARM1_DAY   0x0A
#define DS3231_REG_ALARM2_MIN   0x0B
#define DS3231_REG_ALARM2_HR    0x0C
#define DS3231_REG_ALARM2_DAY   0x0D
#define DS3231_REG_CONTROL      0x0E
#define DS3231_REG_STATUS       0x0F
#define DS3231_REG_AGING        0x10
#define DS3231_REG_TEMP_MSB     0x11
#define DS3231_REG_TEMP_LSB     0x12

#define BCD_TO_DEC(val)     ((((val) >> 4) * 10) + ((val) & 0x0F))
#define DEC_TO_BCD(val)     ((((val) / 10) << 4) | ((val) % 10))

typedef struct {
    uint8_t second;   // 0-59
    uint8_t minute;   // 0-59
    uint8_t hour;     // 0-23
    uint8_t weekday;  // 1-7 (Pazartesi=1)
    uint8_t day;      // 1-31
    uint8_t month;    // 1-12
    uint16_t year;    // 2000-2099
} DS3231_TIME;

int write_file(const char *path, const char *cmd);
int ds3231_read_register(int i2c_fd, uint8_t reg_addr);
int ds3231_read_registers(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length);
int ds3231_read_reg_msg(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length);
int ds3231_write_register(int i2c_fd, uint8_t reg, uint8_t value);
int ds3231_write_registers(int i2c_fd, uint8_t reg_addr, const uint8_t *buffer, size_t length);

int ds3231_gettime(int i2c_fd, DS3231_TIME *dstime);
int ds3231_settime(int i2c_fd, const DS3231_TIME *dstime);
int ds3231_settime_host2rtc(int i2c_fd);
int ds3231_settime_rtc2host(int i2c_fd);
int set_alarm1(int i2c_fd, uint8_t hour, uint8_t minute, uint8_t second, int polling);   
int reset_intr_stat(int i2c_fd);
int check_alarm1(int i2c_fd);

void exit_sys(const char *msg);    

int main(int argc, char *argv[])
{
    int i2c_fd, gpio_fd;
    uint8_t hour, minute, second;
    DS3231_TIME dstime;
    fd_set se;
    char buf;
    
    if (argc != 4 && argc != 1) {
        fprintf(stderr, "wrong number of arguments!..\n");
        fprintf(stderr, "usage: rtc-alarm hour minute second\n");
        exit(EXIT_FAILURE);
    }

    if (write_file("/sys/class/gpio/gpio51/direction", "in") == -1)
        exit_sys("write_file");
    if (write_file("/sys/class/gpio/gpio51/edge", "falling") == -1)
        exit_sys("write_file");

    if ((gpio_fd = open("/sys/class/gpio/gpio51/value", O_RDONLY)) == -1)
        exit_sys("open");
    
    if ((i2c_fd = open("/dev/i2c-2", O_RDWR)) == -1) 
        exit_sys("open");

    if (ioctl(i2c_fd, I2C_SLAVE, DS3231_ADDR) == -1) 
        exit_sys("ioctl");

     if (argc == 4) {
        hour = atoi(argv[1]);
        minute = atoi(argv[2]);
        second = atoi(argv[3]);
    }
    else {
        if (ds3231_gettime(i2c_fd, &dstime) == -1)
            exit_sys("ds3231_gettime");
        hour = dstime.hour;
        minute = (dstime.minute + 1);
        if (minute >= 60) {
            minute = 0;
            hour = (hour + 1) % 24;
        }
        second = dstime.second;
    }
    
    if (set_alarm1(i2c_fd, hour, minute, second, 0) == -1)
        exit_sys("set_alarm1");

    
    if (read(gpio_fd, &buf, 1) == -1) 
        exit_sys("read");
    

    printf("waiting for alarm...\n");

    FD_ZERO(&se);
    FD_SET(gpio_fd, &se);

    if (select(gpio_fd + 1, NULL, NULL, &se, NULL) == -1) 
        exit_sys("select");

    if (FD_ISSET(gpio_fd, &se)) {  
        lseek(gpio_fd, 0, SEEK_SET);     
        if (read(gpio_fd, &buf, 1) == -1) 
            exit_sys("read");
        printf("ALARM ALARM ALARM...\n");
        reset_intr_stat(gpio_fd);
    }

    close(i2c_fd);
    close(gpio_fd);

    return 0;
}

int write_file(const char *path, const char *cmd)
{
    int fd;

    if ((fd = open(path, O_WRONLY)) == -1) 
        return -1;

    if (write(fd, cmd, strlen(cmd)) == -1)
        return -1;

    close(fd);

    return 0;
}

int ds3231_read_register(int i2c_fd, uint8_t reg_addr) 
{
    uint8_t data;
    
    if (write(i2c_fd, &reg_addr, 1) != 1) 
        return -1;
    if (read(i2c_fd, &data, 1) != 1) 
        return -1;
    
    return data;
}

int ds3231_read_registers(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length) 
{    
    if (write(i2c_fd, &reg_addr, 1) != 1) 
        return -1;
    if (read(i2c_fd, buffer, length) != (ssize_t)length) 
        return -1;
    
    return 0;
}

int ds3231_read_reg_msg(int i2c_fd, uint8_t reg_addr, uint8_t *buffer, size_t length) 
{
    struct i2c_msg messages[2];
    struct i2c_rdwr_ioctl_data msgset;
    
    messages[0].addr = DS3231_ADDR;
    messages[0].flags = 0;              // Write, register selection
    messages[0].len = 1;
    messages[0].buf = &reg_addr;   

    messages[1].addr = DS3231_ADDR;
    messages[1].flags = 1;              // Read multi byte
    messages[1].len = length;
    messages[1].buf = buffer;
    
    msgset.msgs = messages;
    msgset.nmsgs = 2;
    
    if (ioctl(i2c_fd, I2C_RDWR, &msgset) < 0) 
        return -1;
        
    return 0;
}

int ds3231_write_register(int i2c_fd, uint8_t reg, uint8_t value) 
{
    uint8_t buffer[2] = {reg, value};
    
    if (write(i2c_fd, buffer, 2) != 2) 
        return -1;
    
    return 0;
}

int ds3231_write_registers(int i2c_fd, uint8_t reg_addr, const uint8_t *buffer, size_t length)
{
    uint8_t tmp[1 + 18];

    if (length > 18) {
        errno = EINVAL;
        return -1;
    }

    tmp[0] = reg_addr;
    memcpy(&tmp[1], buffer, length);

    if (write(i2c_fd, tmp, sizeof(tmp)) != (ssize_t)sizeof(tmp))
        return -1;

    return 0;
}


int ds3231_gettime(int i2c_fd, DS3231_TIME *dstime)
{
    uint8_t buf[7];

    if (ds3231_read_registers(i2c_fd, 0, buf, 7) == -1)
        return -1;
    
    dstime->second = BCD_TO_DEC(buf[0]);
    dstime->minute = BCD_TO_DEC(buf[1]);
    dstime->hour = BCD_TO_DEC(buf[2]);
    dstime->weekday = BCD_TO_DEC(buf[3]);
    dstime->day = BCD_TO_DEC(buf[4]);
    dstime->month = BCD_TO_DEC(buf[5]);
    dstime->year = BCD_TO_DEC(buf[6]) + 2000;

    return 0;
}

int ds3231_settime(int i2c_fd, const DS3231_TIME *dstime)
{
    uint8_t buf[7];

    buf[0] = DEC_TO_BCD(dstime->second);
    buf[1] = DEC_TO_BCD(dstime->minute);
    buf[2] = DEC_TO_BCD(dstime->hour);
    buf[3] = DEC_TO_BCD(dstime->weekday);
    buf[4] = DEC_TO_BCD(dstime->day);
    buf[5] = DEC_TO_BCD(dstime->month);
    buf[6] = DEC_TO_BCD(dstime->year);
    
    if (ds3231_write_registers(i2c_fd, 0, buf, 7) == -1)
        return -1;

    return 0;
}

int ds3231_settime_host2rtc(int i2c_fd)
{
    time_t t;
    struct tm *ptm;
    DS3231_TIME dstime;
    
    t = time(NULL);
    ptm = localtime(&t);

    dstime.second = ptm->tm_sec;
    dstime.minute = ptm->tm_min;
    dstime.hour = ptm->tm_hour;
    dstime.weekday = ptm->tm_wday == 0 ? 7 : ptm->tm_wday;
    dstime.day = ptm->tm_mday;
    dstime.month = ptm->tm_mon + 1;
    dstime.year = ptm->tm_year - 100;

    if (ds3231_settime(i2c_fd, &dstime) == -1)
        return -1;

    return 0;
}

void ds3231_time2tm(const DS3231_TIME *dstime, struct tm *ptm)
{
    ptm->tm_sec  = dstime->second;
    ptm->tm_min  = dstime->minute;
    ptm->tm_hour = dstime->hour;
    ptm->tm_mday = dstime->day;
    ptm->tm_mon  = dstime->month - 1;    
    ptm->tm_year = dstime->year - 1900;
    ptm->tm_wday = dstime->weekday == 7 ? 0 : dstime->weekday;
    ptm->tm_yday = 0;
    ptm->tm_isdst = -1;
}

int ds3231_settime_rtc2host(int i2c_fd)
{
    DS3231_TIME dstime;
    struct timeval tv;
    struct tm tm;
    
    if (ds3231_gettime(i2c_fd, &dstime) == -1)
        return -1;

    ds3231_time2tm(&dstime, &tm);
    tv.tv_sec = mktime(&tm);
    tv.tv_usec = 0;
    if (settimeofday(&tv, NULL) == -1)
        return -1;
    
    return 0;
}

int set_alarm1(int i2c_fd, uint8_t hour, uint8_t minute, uint8_t second, int polling) 
{
    uint8_t reg;

    if (ds3231_write_register(i2c_fd, DS3231_REG_ALARM1_SEC, DEC_TO_BCD(second) & 0x7F) == -1) 
        return -1;
    if (ds3231_write_register(i2c_fd, DS3231_REG_ALARM1_MIN, DEC_TO_BCD(minute) & 0x7F) == -1) 
        return -1;
    if (ds3231_write_register(i2c_fd, DS3231_REG_ALARM1_HR, DEC_TO_BCD(hour) & 0x7F) == -1) 
        return -1;
    if (ds3231_write_register(i2c_fd, DS3231_REG_ALARM1_DAY, 0x80) == -1) 
        return -1;

    reset_intr_stat(i2c_fd);
    
    if ((reg = ds3231_read_register(i2c_fd, DS3231_REG_CONTROL)) == -1) 
        return -1;
    if (ds3231_write_register(i2c_fd, DS3231_REG_CONTROL, polling ? (reg & ~0x05) : (reg | 0x05))  == -1) 
        return -1;

    return 0;
}

int reset_intr_stat(int i2c_fd)
{
    int reg;

    if ((reg = ds3231_read_register(i2c_fd, DS3231_REG_STATUS)) == -1) 
        return -1;
    if (ds3231_write_register(i2c_fd, DS3231_REG_STATUS, reg & ~0x03) == -1) 
        return -1;

    return 0;
}

int check_alarm1(int i2c_fd)
{
    uint8_t status;

    if ((status = ds3231_read_register(i2c_fd, DS3231_REG_STATUS)) == -1)
        return -1;
    if (status & 1) {
        if (ds3231_write_register(i2c_fd, DS3231_REG_STATUS, status & ~0x01) == -1)
            return -1;
        return 1;
    }
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Gömülü sistemlerde çok kullanılan diğer bir haberleşme protokolü de SPI (Serial Peripheral Interface) denilen protokoldür. 
    SPI haberleşmesi 4 uçtan yapılmaktadır:

    Master                         Slave
    │                              │
    ├────────> SCLK ───────────────>  (Serial Clock)
    │                              │
    ├────────> MOSI ───────────────>  (Master Out Slave In)
    │                              │
    <──────── MISO <───────────────┤  (Master In Slave Out)
    │                              │
    └────────> CS/SS ──────────────>  (Chip Select / Slave Select)

    Bu haberleşme protokülünde de yine iki taraf için "master" ve "slave" terimleri kullanılmaktadır. Burada SCLK clock 
    sinyaline ilişkin uçtur. Clock sinyali her zaman master tarafından üretilmektedir. Kullanılan clock frekansları tipik 
    olarak 100 kHz ile 50 MHz arasında değişebilmektedir. MOSI (Master Out Slave In) ucu master taraftan slave tarafa veri 
    aktarmak için MISO (Master In Slave Out) ucu ise slave taraftan master tarafa veri aktarmak için kullanılmaktadır. Bu 
    uçları UART haberleşmesindeki TxD ve RxD uçlarına benzetebiliriz. CS/SS (Chip Select / Slave Select) ucu ise slave 
    aygıtı seçmek için kullanılmaktadır. Genellikle bu uç lojik 1 seviyesinde ise slave aygıt seçilmemiş durumdadır. Seçim 
    için master bu ucu lojik 0 seviyesine çeker. Bir slave aygıt birden fazla master tarafındna kullanılıyor olabilir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    SPI’ın en önemli konfigürasyon parametreleri clock polaritesi (CPOL) ve clock fazıdır (CPHA). Bu iki parametre dört farklı 
    SPI modu oluşturmaktadır. CPOL = 0 ise clock "idle" durumda "low", CPOL = 1 ise clock idle durumda "high" seviyesindedir. 
    CPHA = 0 ise veri ilk clock kenarında örneklenir, CPHA = 1 ise veri ikinci clock kenarında örneklenir.

    Yukarıda da belirttiğimiz gibi CPOL = 0 (Clock Idle Low) durumunda transfer yoksa clock 0 durumundadır:

         TRANSFER            IDLE         TRANSFER
    SCLK  ┌─┐ ┌─┐ ┌─┐ ┌─┐              ┌─┐ ┌─┐ ┌─┐ ┌─┐
          │ │ │ │ │ │ │ │              │ │ │ │ │ │ │ │
       ___┘ └─┘ └─┘ └─┘ └______________┘ └─┘ └─┘ └─┘ └_____
      LOW ←─ Transfer ─→ LOW (Idle)    ←── Transfer ──→ LOW
   
   ↑                     ↑                              ↑
   Idle durumda          Idle'a döndü                   Idle
   LOW (0V)              LOW (0V)                       LOW (0V)

    CPOL = 1 (Clock Idle Low)  durumunda transfer yoksa clock 1 durumundadır:

        HIGH ←─ Transfer ─→ HIGH (Idle)  ←── Transfer ──→ HIGH
    ───┐ ┌─┐ ┌─┐ ┌─┐ ┌───────────────┐ ┌─┐ ┌─┐ ┌─┐ ┌─────
       │ │ │ │ │ │ │ │               │ │ │ │ │ │ │ │
       └─┘ └─┘ └─┘ └─┘               └─┘ └─┘ └─┘ └─┘
           TRANSFER        IDLE        TRANSFER
    
    CPOL ve CPHA parametreleri toplam dört farklı durum oluşturmaktadır:

    ┏━━━━━━┳━━━━━━┳━━━━━━┳━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┓
    ┃ Mod  ┃ CPOL ┃ CPHA ┃ Clock Idle ┃ Veri Örnekleme    ┃ Veri Değişimi     ┃
    ┡━━━━━━╇━━━━━━╇━━━━━━╇━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━┩
    │  0   │  0   │  0   │    LOW     │ Rising (yükselen) │ Falling (düşen)   │
    ├──────┼──────┼──────┼────────────┼───────────────────┼───────────────────┤
    │  1   │  0   │  1   │    LOW     │ Falling (düşen)   │ Rising (yükselen) │
    ├──────┼──────┼──────┼────────────┼───────────────────┼───────────────────┤
    │  2   │  1   │  0   │    HIGH    │ Falling (düşen)   │ Rising (yükselen) │
    ├──────┼──────┼──────┼────────────┼───────────────────┼───────────────────┤
    │  3   │  1   │  1   │    HIGH    │ Rising (yükselen) │ Falling (düşen)   │
    └──────┴──────┴──────┴────────────┴───────────────────┴───────────────────┘ 

    En çok kullanılan mod 0'ıncı moddur:

    Yaygınlık Sıralaması:
    ┌────────────────────────────────────────────┐
    │ Mode 0: ████████████████████ (~60-70%)     │
    │ Mode 3: ██████████ (~20-25%)               │
    │ Mode 1: ███ (~5-10%)                       │
    │ Mode 2: ██ (~5%)                           │
    └────────────────────────────────────────────┘

    UART haberleşmesi Mod 3'e benzemektedir.

    SPI haberleşmesinde tipik kullanılan slave aygıtlar şunlardır:
    
    - Flash bellek, EEPROM
    - SD kartlar
    - ADC/DAC çipleri
    - LCD/OLED ekranlar
    - Sensörler (IMU, basınç, sıcaklık)
    - RF modülleri
    - Kısa mesafe, yüksek hız gerektiren uygulamalar
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    SPI haberleşmesi ile UART haberleşmesi arasında bazı benzerlikler dikkatiniz çekmiştir. Bu iki haberşeme modelinin önemli 
    farklılıklarını şöyle özetleyebiliriz:

    - SPI için minimum 4 uç gerekmektedir. (Master ve slave aygıtlarda birden fazla CS/SS uzu bulunabilmektedir.) Oysa UART 
    haberleşmesinde iki uç kullanılmaktadır. (UART haberleşmesinde iki tarafın ayrı zamanlayıcı devresine sahip olduğunu 
    anımsayınız. Halbuki SPI haberlemesinde master clock uygulamaktadır, slave de bu clock sinyalini kullanmaktadır.)

    - Hem SPI hem de UART haberleşmesi full duplex ve asenkron biçimdedir. 

    - SPI haberleşmesinde her slave için ayrı CS hattı gerekebilir. 

    - SPI haberleşmesinde çok yüksek hızlara çıkılabilmektedir (10 MHz - 100+ MHz).

    - SPI haberleşmesinde clock hattı olduğu için zamanlama hata olasılığı daha düşüktür. Halbuki UART haberleşmesinde iki 
    tarafın ayrı zamanlayıcısı olduğu için bu olasılık daha yüksektir. 

    - SPI haberleşmesi çok kısa mesafe için düşünülmüştür (genelde birkaç santimetre). Ancak UART haberlşemesi RS232 yükseltmesi 
    de uygulanrısa 20 30 metre mesafeden yapılabilmektedir. 

    - SPI haberleşmesinde bir master birden fazla slave ile haberleşebilmektedir. Ancak UART haberleşmesi bire birdir (peer-to-peer).

    - SPI'da start/stop biti yok, yalnızca veri bitleri aktarılır. Parity kontrolü yoktur, veri boyutu esnektir (8, 16, 32 bit)
    UART'ta start bit stop bit kullanılmaktadır. Parity kontrolü uygulanabilmektedir, ver boyutu 5, 7, 8 bit olabilmektedir. 

    - SPI yüksek hızda bir haberleşme sunduğu için DMA kullanımı yaygındır. UART haberşlemesinde ise DMA kullanımı seyrektir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    BBB'de iki bağımsız SPI denetleyicisi vardır. Bunlara SP= ve SP1 deneilmektedir. Her iki SPI denetleyicisinin uçları da P9 
    başlığını kullanmaktadır. SPI0 pinleri şöyledir:

    ┌─────────────┬──────────┬─────────────────┬───────────┬───────────────────┐
    │ Sinyal      │ BBB Pin  │ Alternatif İsim │ GPIO      │ Fonksiyon         │
    ├─────────────┼──────────┼─────────────────┼───────────┼───────────────────┤
    │ SPI0_SCLK   │ P9_22    │ UART2_RXD       │ gpio0[2]  │ SPI Clock         │
    ├─────────────┼──────────┼─────────────────┼───────────┼───────────────────┤
    │ SPI0_D0     │ P9_21    │ UART2_TXD       │ gpio0[3]  │ MISO (Master In)  │
    ├─────────────┼──────────┼─────────────────┼───────────┼───────────────────┤
    │ SPI0_D1     │ P9_18    │ I2C1_SDA        │ gpio0[4]  │ MOSI (Master Out) │
    ├─────────────┼──────────┼─────────────────┼───────────┼───────────────────┤
    │ SPI0_CS0    │ P9_17    │ I2C1_SCL        │ gpio0[5]  │ Chip Select 0     │
    └─────────────┴──────────┴─────────────────┴───────────┴───────────────────┘

    SPI1 pinleri ise şöyledir:

    ┌─────────────┬──────────┬───────────────────┬───────────┬──────────────────────┐
    │ Sinyal      │ BBB Pin  │ Alternatif İsim   │ GPIO      │ Fonksiyon            │
    ├─────────────┼──────────┼───────────────────┼───────────┼──────────────────────┤
    │ SPI1_SCLK   │ P9_31    │ MCASP0_ACLKX      │ gpio3[14] │ SPI Clock            │
    ├─────────────┼──────────┼───────────────────┼───────────┼──────────────────────┤
    │ SPI1_D0     │ P9_29    │ MCASP0_FSX        │ gpio3[15] │ MISO (Master In)     │
    ├─────────────┼──────────┼───────────────────┼───────────┼──────────────────────┤
    │ SPI1_D1     │ P9_30    │ MCASP0_AXR0       │ gpio3[16] │ MOSI (Master Out)    │
    ├─────────────┼──────────┼───────────────────┼───────────┼──────────────────────┤
    │ SPI1_CS0    │ P9_28    │ MCASP0_AHCLKR     │ gpio3[17] │ Chip Select 0        │
    ├─────────────┼──────────┼───────────────────┼───────────┼──────────────────────┤
    │ SPI1_CS1    │ P9_42    │ eCAP0_in_PWM0_out │ gpio0[7]  │ Chip Select 1 (opt.) │
    └─────────────┴──────────┴───────────────────┴───────────┴──────────────────────┘

    Bu pinlerin multiplexed olduğuna dikkat ediniz. Yani bu pinlerin bazıları UART ve I2C pinleri ile çakışmaktadır. 
    
    Test işlemi için loopback bağlantı kullanılabilir. Eğer SPI0 üzerinden test yapılacaksa bu duurmda P9_18 ile P9_21
    uçları bir jumper kabloyla bağlanabilir. Eğer SPI1 üzerinden test yapılacaksa P9_29 ile P9_30 uçlarının bağlanması gerekir. 
    Tabii BBB için denemeler yaparken aygıt ağacı üzerinden ilgili pinler konfigüre edilebilir. Ya da bu işlem "config-pin"
    programı ile de yapılabilir. SPI0 için "config-pin" programı ile ayarlamalar şöyle yapılabilir:

    $ config-pin P9_17 spi_cs
    $ config-pin P9_18 spi
    $ config-pin P9_21 spi
    $ config-pin P9_22 spi_sclk

    Aynı işlem SPI1 için de şöyle yapılabilir:

    config-pin P9_28 spi_cs
    config-pin P9_29 spi
    config-pin P9_30 spi
    config-pin P9_31 spi_sclk
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Linux'ta SPI protokolüne ilişkin programları yazmanın üç yolu bulunmaktadır:

    1) SPI aygıt sürücüsü yazarak çekirdek modunda haberleşme uygulamak. Çekirdeğin içerisinde SPI protokolü ile ilgili 
    yardımcı fonksiyonlar da bulunmaktadır. Aygıt sürücü yazarken bu fonksiyonlardan da faydalanılabilmektedir. 

    2) Linux'taki hazır SPI aygıt sürücülerini kullanmak. Bunun için yine SPI aygıt sürücüsüne ilişkin aygıt dosyası open
    fonksiyonu ile açılır. Sonra ioctl çağrıları ile konfigürasyon ve transfer işlemleri yapılır. En çok kullanılan yöntem 
    budur.

    3) Linux'taki hazır SPI aygıt sürücülerini kullanarak yazılmış olan yüksek seviyeli kütüphanelerden de faydalanılabilir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    BBB'de SPI denetleyicileri AM335X SoC içerisindedir. Buradaki SPI denetleyicilerinin temel özellikleri şöyledir:

    - 2 adet SPI denetleyici: SPI0 ve SPI1
    - Her denetleyici 4 kanal (CS). (Yani toplamda 8 slave aygıt bağlanabiliyor.)
    - Maksimum hız: 48 MHz
    - Veri genişliği: 4-32 bit arası programlanabilir
    - FIFO desteği: 64 bayt TX FIFO, 64 bayt RX FIFO
    - DMA desteği: Yüksek hızlı veri transferi için (BBB'de SPI'in ayrı DMA'sı yoktur. Tek bir merkezi DMA vardır.)
    - Çoklu mod desteği: Master ve Slave modları (Ancal Slave mod kullanımı aygıt yazımını gerektirmektedir.)

    BBB'de SPI denetleyicilerinin taban bellek adresleri şöyledir:

    #define SPI0_BASE_ADDR      0x48030000
    #define SPI1_BASE_ADDR      0x481A0000

    SPI denetleyecilerinin içerisindeki yazmaçların taban adreslerden itibaren offset'leri de şöyledir:

    #define MCSPI_SYSCONFIG     0x110
    #define MCSPI_SYSSTATUS     0x114
    #define MCSPI_IRQSTATUS     0x118
    #define MCSPI_IRQENABLE     0x11C
    #define MCSPI_MODULCTRL     0x128
    #define MCSPI_CH0CONF       0x12C
    #define MCSPI_CH0STAT       0x130
    #define MCSPI_CH0CTRL       0x134
    #define MCSPI_TX0           0x138
    #define MCSPI_RX0           0x13C

    /* Örnek kullanım */

    #define SPI0_CH0CONF        (SPI0_BASE_ADDR + MCSPI_CH0CONF)

    Tabii AM335X içerisindeki bu SPI denetleyicilerinin yazmaç bilgileri ancak aygıt sürücü yazacaklar için gerekmektedir. 
    (Tabii kullanıcı modunda "/dev/mem" aygıtı mmap yapılabilir. Ancak bu kullanım SPI için pek tavsiye edilmemektedir.)
    Zaten Linux içerisinde SPI işlemlerini taşınabilir bir biçimde yapan hazır aygıt sürücü ("spidev" aygıt sürücüsü) 
    bulunmaktadır. 

    Biz kursumuzda AM335X için SPI aygıt sürücüsü yazmayacağız. Linux'un hazır "spidev" aygıt sürücüsünü kullanacağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Linux'taki hazır SPI aygıt sürücülerini kullanıcı modundan kullanabilmek için yine open POSIX fonksiyonu ile ilgili 
    aygıt dosyalarının açılmış gerekir. Bu aygıt dosyaları "/dev" dizini içerisinde aşağıdaki isimlerle bulunmaktadır:

    crw------- 1 root root 153, 0 Feb  4 22:05 /dev/spidev0.0
    crw------- 1 root root 153, 1 Feb  4 22:05 /dev/spidev0.1
    crw------- 1 root root 153, 2 Feb  4 22:05 /dev/spidev1.0
    crw------- 1 root root 153, 3 Feb  4 22:05 /dev/spidev1.1
    
    İsimlendirmelerin "spidevX.Y" biçiminde olduğuna dikkat ediniz. Burada X ve Y birer numara belirtmekteir. X numarası 
    denetleyiciyi Y ise seçilen slave'i temsil edtmektedir. BBB'de pin'lere verilen 2 denetleyici olduğu için burada spidev0 
    SPI0 denetleyicisini, spidev1 ise SPI1 denetleyicisini belirtmektedir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                            153. Ders 13/01/2026 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    BBB'de SPI programlaması üzerinde deneme yapmak için şu yöntemler kullanılabilir:

    1) SP0 ye da SPI1'i kendi içerisinde loopback bağlantı yaparak kullanmak.
    2) SP0 ile SP1'i karşılıklı bağlayıp kullanmak.
    3) SPI0'ı ya da SPI1'i başka bir slave aygıt'a bağlayarak kullanmak. 

    Deneme için en basit yöntem tek bir SPI denetleycisinin uçlarını biribirine bağlamaktır. Biz kursumuzda programlama denemesini
    böyle yapacağız. İki SPI aygıtını birbirine bağlamak için birinin "master" diğerinin "slave" olması gerekmektedir. Linux 
    çekirdek olarak slave desteğini 4.12 çekirdeğinde eklemiştir. BBB'lerde de SP0 ya da SPI1'i slave yapmak mümkünse de 
    maalesef bunun için aygıt sürücü yazılması gerekmektedir. 

    İki SPI aygıtını birbirine bağlarken seri port'larda olduğu gibi uçlar karşılıklı bağlanmamaktadır. Bir tarafın MOSI ucu
    diğer tarafın MISO ucuna değil yine MOSI bağlanmaktadır. Benzer biçimde bir tarafın MISO ucu da diğer tarafın MISO ucuna 
    bağlanmaktadır. Çünkü SPI'da MOSI "Master Out Slave In" anlamına gelmektedir. Bu da her zaman "bu uca master yazar slave 
    okur" anlamına gelir. Bnezer biçimde MISO da "Master In Slave Out" anlamına gelmektedir. Bu her zaman "bu uca slave yazar
    master okur" anlamına gelir. Bağlantı aşağıdaki gibi yapılmalıdır:

    ╔══════════════════════════════════════════════════════════════════════╗
    ║           SPI MASTER - SLAVE BAĞLANTISI (4 HAT)                      ║
    ╚══════════════════════════════════════════════════════════════════════╝

    ┌─────────────────┐                            ┌─────────────────┐
    │                 │                            │                 │
    │   SPI MASTER    │                            │   SPI SLAVE     │
    │                 │                            │                 │
    │                 │                            │                 │
    │            SCLK ●────────────────────────────● SCLK            │
    │                 │    (Saat Sinyali)          │                 │
    │                 │         ──────►            │                 │
    │                 │                            │                 │
    │            MOSI ●────────────────────────────● MOSI            │
    │                 │    (Master → Slave)        │                 │
    │                 │         ──────►            │                 │
    │                 │                            │                 │
    │            MISO ●────────────────────────────● MISO            │
    │                 │    (Slave → Master)        │                 │
    │                 │         ◄──────            │                 │
    │                 │                            │                 │
    │          SS/CS  ●────────────────────────────● SS/CS           │
    │                 │    (Chip Select)           │                 │
    │                 │         ──────►            │                 │
    │                 │                            │                 │
    └─────────────────┘                            └─────────────────┘

    Ancak bizim kurusmuzda yapacağımız gibi eğer tek bir SPI denetleyicsi kullanarak loopback bağlantı yapılacaksa bu durumda
    Bu durumda MOSI ile MISO karşılıklı bağlanmalıdır. 

    Biz kursumuzda BBB'deki SPI0 denetleyicisinin MOSI ve MISO uçlarını tek bir telle karşılıklı bağlarsak başka bir bağlantı 
    yapmamıza gerek kalmaz. Bağlantı şeması şöyle olacaktır:

    P9_18 <--------------------> P9_21

    Tabii bu bağlantıyı yaptıktan sonra ya aygıt ağacı yolu ile ya da "config-pin" programı ile pin'ler spi olarak aşağıdaki
    gibikonfigüre edilmelidir:

    config-pin P9_17 spi_cs
    config-pin P9_18 spi
    config-pin P9_21 spi
    config-pin P9_22 spi_sclk
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Linux'ta SPI protokolü ile veri transfer edebilmek için öncelikle open fonksiyonu ile ilgili SPI aygıt dosyası açılmalıdır.
    Örneğin:

    int fd_spi;

    if ((fd_spi = open("/dev/spidev0.0", O_RDWR)) == -1)
        exit_sys("open");

    Aygıt dosyası açıldıktan sonra SPI denetleyicisi konfigüre edilmelidir. Konfigürasyon işlemleri aygıt sürücüye ioctl 
    komutları gönderilerek yapılmaktadır. ioctl işlemleri için aşağıdaki başlık dosyasının include edilmesi gerekmektedir:

    #include <linux/spi/spidev.h>

    ioctl komutları her zaman parametre olarak adres almaktadır. Dolayısıyla ioctl fonksiyonun üçüncü parametresine biz 
    hep adres geçeceğiz. 

    SPI denetleyicisini konfigüre etmek için tipik olarak şu ioctl kodları kullanılmaktadır:

    // SPI mode ayarlama
    
    ioctl(fd, SPI_IOC_WR_MODE, &mode);
    ioctl(fd, SPI_IOC_RD_MODE, &mode);    

    // Bits per word ayarlama

    ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &bits);
    ioctl(fd, SPI_IOC_RD_BITS_PER_WORD, &bits);

    // Max speed ayarlama

    ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed);
    ioctl(fd, SPI_IOC_RD_MAX_SPEED_HZ, &speed);

    Burada içerisinde WR geçen ioctl kodları konfigürasyon bilgisini set etmek için, RD geçenler ise elde etmek için 
    kullanılmaktadır. Burada mode ve bits uint_t türünden nesneleri, speed ise uint32_t türünden nesneyi temsil etmektedir. 
    SPI_IOC_WR_MODE ioctl kodu CPOL/CPHA modunu ayarlamak için, SPI_IOC_WR_BITS_PER_WORD kodu bir word bilginin kaç bit 
    olduğunu ayarlamak için, SPI_IOC_WR_MAX_SPEED_HZ kodu ise kullanılacak maksimum hızı belirtmektedir. Mod için SPI_MODE_0, 
    SPI_MODE_1, SPI_MODE_2 ve SPI_MODE_3 sembolik sabitleri kullanılabilir. Örneğin biz SPI denetleyicisini konfigüre eden 
    şöyle bir fonksiyon yazabiliriz:

    int init_spi(int fd, uint8_t mode, uint8_t bits, uint32_t speed)
    {
        if (ioctl(fd, SPI_IOC_WR_MODE, &mode) == -1) 
            return -1;

        if (ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &bits) == -1)
            return -1;

        if (ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed) == -1)
            return -1;

        return 0;
    }

    Ayrıca transfer sırasında hangi bitin önce gönderilip alınacağı için de  SPI_IOC_RD_LSB_FIRST, SPI_IOC_WR_LSB_FIRST 
    biçiminde iki ioctl kodu vardır. Ancak SPI protokolünde default durum her zaman önce yükske anlamlı bitin gönderilip 
    alınmasıdır. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi sıra transfer işlemine glmiştir. SPI aygıtları "full duplex" bir haberleşme sunmaktadır. Master taraf clock uygularken
    hem gönderim hem de alım yapmaktadır. Yani her clock darbesinde bitleri gönderirken MOSI ucundan göndeirken aynı zamanda
    MISO ucundan da almaktadır. Transfer işlemi için SPI_IOC_MESSAGE(N) ioctl kodu kullanılmaktadır. SPI_IOC_MESSAGE aslında 
    aşağıdaki gibi bildirilmiş olan bir makrodur:

    #define SPI_IOC_MESSAGE(N) \
        _IOW(SPI_IOC_MAGIC, 0, char[SPI_MSGSIZE(N)])

    Burada SPI_IOC_MESSAGE makrosunun parametresi aslında kaç transfer mesajının yapılacağını belirtmektedir. Transfer için 
    iotctl fonksiyonunun üçüncü parametresine spi_ioc_transfer isimli bir yapı nesnesin adresi geçirilir. Eğer birden fazla
    transfer mesajı kullanılacaksa bu parametreye N uzunluğunda (buradaki N SPI_IOC_MESSAGE makrosunun parametresini belirtiyor)
    spi_ioc_transfer türünden dizinin adresi geçirilir. Bu yapı şöyle bildirilmiştir:

    struct spi_ioc_transfer {
        __u64 tx_buf;
        __u64 rx_buf;

        __u32 len;
        __u32 speed_hz;

        __u16 delay_usecs;
        __u8  bits_per_word;
        __u8  cs_change;
        __u8  tx_nbits;
        __u8  rx_nbits;
        __u16 word_delay_usecs;
        __u8  pad;

        /* If the contents of 'struct spi_ioc_transfer' ever change
        * incompatibly, then the ioctl number (currently 0) must change;
        * ioctls with constant size fields get a bit more in the way of
        * error checking than ones (like this) where that field varies.
        *
        * NOTE: struct layout is the same in 64bit and 32bit userspace.
        */
    };

    Sistem programcısı bu yapı türündne bir nesne yaratıp, onun içini doldurur, bu yapıs nesnesinin adresini de ioctl 
    fonksiyonunun üçüncü parametresine geçer. Yapının elemanlarının anlamları şöyledir:

    - tx_buf (__u64): Gönderilecek verinin bulunduğu bellek adresi. NULL olabilir. Ancak unsignd long türüne dönüştürülmelidir. 

    - rx_buf (__u64): Alınacak verinin yazılacağı bellek adresi. NULL olabilir. Ancak unsignd long türüne dönüştürülmelidir. 

    - len (__u32): Transfer edilecek veri uzunluğu (byte cinsinden). tx_buf ve rx_buf için aynı uzunluk kullanılır.

    - speed_hz (__u32): Bu transfer için kullanılacak clock hızı (Hz cinsinden). 0 ise cihazın varsayılan hızı kullanılır.

    - delay_usecs (__u16): Transfer tamamlandıktan sonra CS değişmeden önce beklenecek süre (mikrosaniye). Sonraki transfer öncesi 
    gecikme sağlar.

    - bits_per_word (__u8): Word başına bit sayısı (genellikle 8). 0 ise cihazın varsayılan değeri kullanılır.

    - cs_change (__u8): Chip Select davranışı kontrolü. 1 ise transfer sonrası CS geçici olarak deaktive edilir. 0 ise CS aktif 
    kalır.

    - tx_nbits (__u8): Gönderim için kullanılacak data line sayısı. 0 = standart (1 hat), 2 = Dual SPI, 4 = Quad SPI

    - rx_nbits (__u8): Alım için kullanılacak data line sayısı. 0 = standart (1 hat), 2 = Dual SPI, 4 = Quad SPI

    - word_delay_usecs (__u16): Her word arasında beklenecek gecikme süresi (mikrosaniye). Yavaş slave cihazlar için düşünülmüştür.

    - pad (__u8) Hizalama için kullanılan dolgu byte'ı. Kullanılmaz, yapıyı 64-bit sınırına hizalar.


    Yapının cs_change elemanı transfer işlemi bittikten sonra chip select ucunun deaktive edilip edilmeyeceğini belirtmektedir. 
    Eğer bu eleman 0 yapılırsa tarnsfer sonrası aygıt seçili durumda kalır yani chip select ucu aktif bırakılır. Ancak bu eleman
    1 yapılırsa transfer sonrasında chip select ucu deaktive edilmektedir. 

    SPI haberleşmesinde zaman gönderme ve alma eşzamanlı yürütülmektedir. Bu nedenle yapıya iki tampon adresi girilmektedir. 
    Ancak bu tampon adreslerinin bii NULL ise o işlem dikkate alınmaz. Örneğin biz slave aygıta yalnızca bilgi göndereceksek, 
    yani gönderinm sırasında alınanları göz ardı edeceksek yapının rx_buf göstericisne NULL adres yerleştirebiliriz. Benzer 
    biçimde yalnızca alım yapacaksak tx_buf göstericisine NULL adres yerleştirebiliriz. Yapı nenesinin doldurulmasına ilişkin 
    şöyle bir örnek verebiliriz:

    struct spi_ioc_transfer tr = {
        .tx_buf = (unsigned long)tx_data,
        .rx_buf = (unsigned long)rx_data,
        .len = 32,
        .speed_hz = 1000000,        // 1 MHz
        .delay_usecs = 10,          // 10 μs gecikme
        .bits_per_word = 8,
        .cs_change = 0,             // CS aktif kalsın
    };
    
    Gönderme ve alma için ayrı uzunlukların girilmediğine dikkat ediniz. Zaten SPI protokülünde her zaman iki işlem birlikte
    yapılmaktadır. 

    Transfer hakkında bir nokta üzerinde durmak istiyoruz. Slave aygıt bize yüklü miktarda bilgi gönderecek olsun. Peki 
    slave gönderirken thread'ler arası geçiş oluşup biz transfer işlemini yapamazsak ne olur? Bilgi kaybedilir mi? İşte SPI 
    haberleşmesinde master clock üretmezse zaten slave'in gönderim yapması mümkün değildir. Transfer bitince master clock 
    üretmeyi durduracağı için böyle bir bilgi kaçırma da mümkün olmayacaktır. UART haberleşmesindeki durumun böyle olmadığına
    dikkat ediniz. UART haberleşmesinde iki UART'ın içerisinde ayrı zamanlayıcı devreler vardır. Bu nedenle bir UART bilgi 
    göndermeyi kesse bile karşı taraf bilgi göndermeye devam edebilmektedir. Halbuki SPI haberleşmesinde senkronizasyon 
    master tarafın sağladığı clock sinyaliyle yapılmaktadır. Master taraf clock sinyalini kestiği anda zaten transfer durmaktadır.
    Peki transfer sonrasında zaten clock kesileceğine göre chip select ucunun (yapının cs_change elemanını anımsayınız) aktif 
    ya da pasif olmasının ne anlamı olabilir? İşte slave aygıtların çoğunda chip select ucu pasif hale geldiğinde aygıt bundan 
    birt sonuç çıkartmektadır. Örneğin transfer döngüsünü reset'leyebilmektedir. Dolayısıyla transfer sonrasında chip select 
    ucunun nasıl bırakılması gerektiği tamamen slave aygıtın tasarımıyla ilgilidir. 
    
    Peki biz ioctl işlemiyle transferi başlattığımızda neler olmaktadır? İşte tipik olarak Linux'taki "spidev" aygıt sürücüsü
    transfer işlemini başlatan thread'i CPU'nun çalışma kuyruğundan çıkartarak bekleme kuyruklarına alır ve transferi başlatır. 
    Transfer tipik olarak DMA yoluyla yapılmaktadır. DMA çevre birimlerden gelen bilgilerin bellekte bir adrese yerleştirilmesini
    sağlayan böylece CPU'u aradan çıkartan bir denetleyicidir. Linux'taki "spidev" aygıt sürücüsü DMA tamponunu çekirdek alanında
    kendisi oluşturmaktadır. Transfer tamamlanınca bu çekirdek alanındaki bilgileri kullanıcının belirlediği tampona kopyalamaktadır. 
    Transfer bittiğinde DMA CPU'da kesme oluşturmaktadır. İşletim sistemi de kesme kodunda (interrupt handler) DMA tamponundan 
    bilgileri alarak kullanıcı alanına kopyalamaktadır. BBB'de gerçekleşen tüm olayları aşağıdaki şekille betimleyebiliriz:

        USER SPACE
    ═══════════════════════════════════════════════════════════════════════
    
    [Uygulama Thread'i]
            │
            │ ioctl(fd, SPI_IOC_MESSAGE(1), &xfer)
            │ xfer.rx_buf = user_buffer (0x7fff1234)
            │ xfer.len = 4096 bytes
            ▼
    ┌──────────────────┐
    │  BLOKE EDİLDİ    │ ◄─── Context switch olabilir
    │  (TASK_SLEEPING) │      (thread beklemede)
    └──────────────────┘
            ▲
            │ Transfer tamamlandı! (wake_up)
            │ copy_to_user() yapıldı
            │
    ═══════════════════════════════════════════════════════════════════════
    KERNEL SPACE
    ───────────────────────────────────────────────────────────────────────

    [spidev sürücüsü]
            │
            │ 1) Kernel buffer ayır
            ▼
    ┌─────────────────────────────────────┐
    │ k_rx_buf = kzalloc(4096, GFP_KERNEL)│
    │ Kernel Heap: 0xc8a45000             │
    └─────────────────────────────────────┘
            │
            │ 2) SPI controller sürücüsüne ilet
            ▼
    [spi-omap2-mcspi sürücüsü]
            │
            │ 3) DMA ayarla
            ▼
    ┌──────────────────────────────────────┐
    │ EDMA3 PaRAM Set Ayarları             │
    ├──────────────────────────────────────┤
    │ • Kaynak: SPI_RX FIFO (0x481A0000)   │
    │ • Hedef: k_rx_buf (0xc8a45000)       │
    │ • aCnt: 4096 bytes                   │
    │ • bCnt: 1                            │
    │ • cCnt: 1                            │
    │ • Kanal: #17 (SPI0_RX)               │
    └──────────────────────────────────────┘
            │
            │ 4) SPI ve DMA başlat
            ▼
    ═══════════════════════════════════════════════════════════════════════
    DONANIM SEVİYESİ
    ───────────────────────────────────────────────────────────────────────

    [SPI Master - AM335x McSPI0]          [SPI Slave Aygıt]
            │                                      │
            │ ─── SCLK ──────────────────────────▶│
            │ ◀── MISO (veri) ────────────────────│
            │ ─── MOSI ──────────────────────────▶│
            │ ─── CS# ───────────────────────────▶│
            │                                      │
            ▼                                      
    ┌─────────────────┐
    │  RX FIFO (64B)  │  ◄── Slave'den gelen her byte
    │  ┌───┬───┬───┐  │      buraya önce gelir
    │  │ A │ B │ C │  │
    │  └───┴───┴───┘  │
    └────────┬────────┘
            │ FIFO → Memory DMA isteği
            ▼
    ┌──────────────────────────────────┐
    │   EDMA3 Controller (64 kanal)    │
    │                                  │
    │   Kanal #17 Aktif ●              │
    │   ┌─────────────────────┐        │
    │   │ Transfer Progress:  │        │
    │   │ ████████░░░░ 2048/4096       │
    │   └─────────────────────┘        │
    └──────────┬───────────────────────┘
                │ DMA yazıyor...
                ▼
    ═══════════════════════════════════════════════════════════════════════
    FİZİKSEL BELLEK (DDR3 RAM)
    ───────────────────────────────────────────────────────────────────────

    Adres: 0xc8a45000 (Kernel buffer - DMA hedefi)
    ┌────────────────────────────────────────────┐
    │ 0xc8a45000: [A][B][C][D][E][F][G][H]...    │ ◄─ DMA buraya yazıyor
    │ 0xc8a45008: [I][J][K][L][M][N][O][P]...    │    (CPU karışmıyor!)
    │ 0xc8a45010: [Q][R][S][T][U][V][W][X]...    │
    │            ...                             │
    │ 0xc8a45FF8: [...4088 byte sonra...]        │
    └────────────────────────────────────────────┘
                │
                │ Transfer tamamlandı!
                ▼
    ┌──────────────────────────────────┐
    │  EDMA3 Interrupt (IRQ #13)       │
    │  "Transfer complete!"            │
    └──────────┬───────────────────────┘
                │
    ═══════════════════════════════════════════════════════════════════════
    KERNEL SPACE (Interrupt Handler)
    ───────────────────────────────────────────────────────────────────────
                │
                ▼
    [SPI Interrupt Handler]
            │
            │ 5) DMA transfer tamam, şimdi user'a kopyala
            ▼
    ┌──────────────────────────────────────────┐
    │ copy_to_user(user_buffer,                │
    │              k_rx_buf,                   │
    │              4096)                       │
    │                                          │
    │ Kaynak: 0xc8a45000 (kernel)              │
    │ Hedef:  0x7fff1234 (user space)          │
    └──────────────────────────────────────────┘
            │
            │ 6) Thread'i uyandır
            ▼
    wake_up_interruptible(&wait_queue)
            │
    ═══════════════════════════════════════════════════════════════════════
    USER SPACE (Thread Uyandı)
    ───────────────────────────────────────────────────────────────────────
            │
            ▼
    [Uygulama Thread'i - RUNNING]
    ┌──────────────────────────────────┐
    │ ioctl() return 4096              │
    │                                  │
    │ user_buffer artık dolu:          │
    │ [A][B][C][D]...[4096 byte]       │
    └──────────────────────────────────┘
            │
            ▼
    printf("Transfer başarılı!\n");


    ZAMAN ÇİZELGESİ:
    ═════════════════════════════════════════════════════════════════════

    t=0ms    │ ioctl() çağrısı
            │ ├─ Kernel buffer ayır (kzalloc)
            │ └─ DMA ayarla
    ─────────┼──────────────────────────────────────
    t=1ms    │ ◆ SPI + DMA başladı
            │ ◆ Thread BLOKE edildi
            │ 
            │ [Bu sırada context switch olabilir!]
            │ [Başka thread'ler çalışabilir]
            │ [DMA arka planda çalışmaya devam eder]
            │
    ─────────┼──────────────────────────────────────
    t=5ms    │ ◆ DMA transfer bitti (4KB @ 1MHz SPI)
            │ ├─ Interrupt geldi
            │ ├─ copy_to_user() yapıldı
            │ └─ Thread uyandırıldı
    ─────────┼──────────────────────────────────────
    t=6ms    │ ioctl() return etti
            │ Program devam ediyor
    ─────────┴──────────────────────────────────────   

/*-----------------------------------------------------------------------------------------------------------------------------
                                            154. Ders 15/01/2026 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/
    Transfer işlemini yapan fonksiyonu şöyle yazabiliriz:

    int spi_transfer(int fd, uint8_t *tx_buf, uint8_t *rx_buf, int len)
    {
        struct spi_ioc_transfer tr = {
            .tx_buf = (unsigned long)tx_buf,
            .rx_buf = (unsigned long)rx_buf,
            .len = len,
            .speed_hz = 1000000,       // 1 MHz
            .delay_usecs = 10,          // 10 μs gecikme
            .bits_per_word = 8,
            .cs_change = 0,             // CS aktif kalsın
        };

        if (ioctl(fd, SPI_IOC_MESSAGE(1), &tr) == -1)
            return -1;

        return 0;
    }

    Aşağıdaki örnekte BBB'nin SPI0 denetleyicisindeki loopback bağlantı ile transfer yapılmıştır. Programda bir döngü içerisinde
    klavyeden (stdin dosyasında) bir yazı alınmış o yazı SPI ile karşı tarafa gönderilirken aynı zamanda da karşı taraftan 
    okuma yapılmıştır. 
-----------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/spi/spidev.h>

int init_spi(int fd, uint8_t mode, uint8_t bits, uint32_t speed);
int spi_transfer(int fd, uint8_t *tx_buf, uint8_t *rx_buf, int len);
char *fgets_s(char *buf, size_t size);
void exit_sys(const char *msg);

int main(void)
{
    int fd_spi;
    uint8_t tx_buf[4096];
    uint8_t rx_buf[4096];

    if ((fd_spi = open("/dev/spidev0.0", O_RDWR)) == -1)
        exit_sys("open");

    if (init_spi(fd_spi, SPI_MODE_1, 8, 100000) == -1)
        exit_sys("init_spi");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        if (!strcmp((char *)tx_buf, "quit"))
            break;
        if (fgets_s((char *)tx_buf, 4096) == NULL) {
            fprintf(stderr, "cannot read!..\n");
            continue;
        }
        if (spi_transfer(fd_spi, tx_buf, rx_buf, strlen((char *)tx_buf) + 1) == -1)
            exit_sys("spi_transfer");
        printf("Received text: %s\n", rx_buf);
    }
    putchar('\n');

    close(fd_spi);

    return 0;
}

int init_spi(int fd, uint8_t mode, uint8_t bits, uint32_t speed)
{
    if (ioctl(fd, SPI_IOC_WR_MODE, &mode) == -1) 
        return -1;

    if (ioctl(fd, SPI_IOC_WR_BITS_PER_WORD, &bits) == -1)
        return -1;

    if (ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed) == -1)
        return -1;

    return 0;
}

int spi_transfer(int fd, uint8_t *tx_buf, uint8_t *rx_buf, int len)
{
    struct spi_ioc_transfer tr = {
        .tx_buf = (unsigned long)tx_buf,
        .rx_buf = (unsigned long)rx_buf,
        .len = len,
        .speed_hz = 1000000,       // 1 MHz
        .delay_usecs = 10,          // 10 μs gecikme
        .bits_per_word = 8,
        .cs_change = 0,             // CS aktif kalsın
    };

    if (ioctl(fd, SPI_IOC_MESSAGE(1), &tr) == -1)
        return -1;

    return 0;
}

char *fgets_s(char *buf, size_t size)
{
    char *str;

    if (fgets(buf, size, stdin) == NULL)
        return NULL;

    if ((str = strchr(buf, '\n')) != NULL)
        *str = '\0';

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*-----------------------------------------------------------------------------------------------------------------------------
    Konun başında da belirttiğimiz gibi gömülü sistemlerde SPI protokolü yoluyla haberşelen pek çok slave aygıt bulunmaktadır. 
    Biz yukarıda BBB'nin SPI0 denetleyicisini loopback yapıp örnek programımızı test ettik. Siz gerçek bir slave aygıt üzerinde 
    denemeler yapabilirsiniz. Dot Matrix LCD'ler, EEPROM bellekler genellikle SPI yoluyla kullanılmaktadır. En basit bir 
    deneme için "7 Segment" tabir edilen eskidne çok yaygın kullanılan display birimini kullanabilirsiniz. 8 tane digit içeren 
    MAX7219 modülü oldukça makul fiyatla tedarik edilebilmektedir. 

    MAX7219 modülünün 5 ucu vardır. BBB'nin SPI0 pin'leri ile bağlantı şeması şöyledir:

    ┌──────────────────────┐              ┌──────────────────────┐
    │  BeagleBone Black    │              │      MAX7219         │
    │       (BBB)          │              │                      │
    │  ┌────────────────┐  │              │  ┌────────────────┐  │
    │  │                │  │              │  │                │  │
    │  │    SPI0        │  │              │  │   7-Segment    │  │
    │  │   P9 Header    │  │              │  │    Display     │  │
    │  └────────────────┘  │              │  └────────────────┘  │
    │                      │              │                      │
    │   P9_5  (VDD_5V) ●───┼──────────────┼────● VCC             │
    │                      │    ═════     │                      │
    │   P9_1  (GND)    ●───┼──────────────┼────● GND             │
    │                      │    ═════     │                      │
    │   P9_18 (SPI0_D1)●───┼──────────────┼────● DIN             │
    │   MOSI               │    ─────>    │                      │
    │                      │              │                      │
    │   P9_17 (SPI0_CS0)●──┼──────────────┼────● CS              │
    │   Chip Select        │    ─────>    │                      │
    │                      │              │                      │
    │   P9_22 (SPI0_SCLK)●─┼──────────────┼────● CLK             │
    │   Clock              │    ─────>    │                      │
    │                      │              │                      │
    └──────────────────────┘              └──────────────────────┘
            [BBB]                           [MAX7219 LED Modülü]

    ╔═══════════╦═══════════╦═══════════╦════════════════════════╗
    ║ BBB Pin   ║  Sinyal   ║  SPI0     ║      MAX7219           ║
    ╠═══════════╬═══════════╬═══════════╬════════════════════════╣
    ║  P9_5     ║  VDD_5V   ║     -     ║  VCC (Güç +5V)         ║
    ║  P9_1     ║   GND     ║     -     ║  GND (Toprak)          ║
    ║  P9_18    ║  SPI0_D1  ║   MOSI    ║  DIN (Veri Girişi)     ║
    ║  P9_17    ║  SPI0_CS0 ║    CS     ║  CS  (Chip Select)     ║
    ║  P9_22    ║ SPI0_SCLK ║   SCLK    ║  CLK (Saat Sinyali)    ║
    ╚═══════════╩═══════════╩═══════════╩════════════════════════╝

    Buradaki MAX7219 modülünün bir digiti toplam 7 segment'ten oluşmaktadır. (Zaten "seven segment display" ismi de buradan 
    gelmektedir.) Segment'lerin programlamada kullanılacak bit numaraları şöyledir:

          ████████  ← Bit 6 (A)
         █        █
    Bit 1│        │Bit 5
    (F)  │        │(B)
         █        █
          ████████  ← Bit 0 (G)
         █        █
    Bit 2│        │Bit 4
    (E)  │        │(C)
         █        █
          ████████  ← Bit 3 (D)
                  ● ← Bit 7 (DP)

    Byte: 0bDP_A_B_C_D_E_F_G
    Bit:    7  6 5 4 3 2 1 0    

    Programala oldukça kolaydır. Bir digit'te ilgili rakamı yazdırmak için iki byte'tan oluşan transfer kullanılmaktadır. 
    Bu byte'ların ilki digitin 1'den başlayan sıra numarasını ikincisi ise digit'te gösterilecek rakımı belirtmektedir. 
    Rakamları oluşturan bir dizilimleri şöyledir:

    # Raw mode için segment haritası
    # Bit:  7  6  5  4  3  2  1  0
    # Seg: DP  A  B  C  D  E  F  G

    CHARS = {
        '0': 0b01111110,  # A,B,C,D,E,F
        '1': 0b00110000,  # B,C
        '2': 0b01101101,  # A,B,D,E,G
        '3': 0b01111001,  # A,B,C,D,G
        '4': 0b00110011,  # B,C,F,G
        '5': 0b01011011,  # A,C,D,F,G
        '6': 0b01011111,  # A,C,D,E,F,G
        '7': 0b01110000,  # A,B,C
        '8': 0b01111111,  # Tüm segmentler
        '9': 0b01111011,  # A,B,C,D,F,G
        'A': 0b01110111,  # A,B,C,E,F,G
        'b': 0b00011111,  # C,D,E,F,G
        'C': 0b01001110,  # A,D,E,F
        'd': 0b00111101,  # B,C,D,E,G
        'E': 0b01001111,  # A,D,E,F,G
        'F': 0b01000111,  # A,E,F,G
        'H': 0b00110111,  # B,C,E,F,G
        'L': 0b00001110,  # D,E,F
        'P': 0b01100111,  # A,B,E,F,G
        'U': 0b00111110,  # B,C,D,E,F
        '-': 0b00000001,  # G
        ' ': 0b00000000,  # Boş
    }"

    SPI transfer fonksiyonu da şöyle yazılabilir:

    int max7219_write(uint8_t address, uint8_t data) 
    {
        uint8_t tx[2] = {address, data};
        
        struct spi_ioc_transfer tr = {
            .tx_buf = (unsigned long)tx,
            .rx_buf = 0,
            .len = 2,
            .speed_hz = SPI_SPEED,
            .bits_per_word = 8,
        };
        
        if (ioctl(spi_fd, SPI_IOC_MESSAGE(1), &tr) == -1) 
            return -1;

        return 0;
    }
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                155. Ders 20/01/2026 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kursumuzun bu bölümünde "Buildroot" aracının kullanımını ele alacağız. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Buildroot, gömülü sistemler için özelleştirilmiş, hafif (light) Linux dağıtımları oluşturmakta kullanılan açık kaynak kodlu    
    bir araçtır. Buildroot gereksiz paketlerden arındırılmış minimalistik Linux sistemleri oluşturmak için yaygın biçimde
    kullanılmaktadır. Özellikle RAM ve Flash ROM kısıtı olan sistemlerde iyi bir çözüm oluşturmaktadır. Buildroot Linux sistemleri
    şu bileşenlerini ıluşturmaktadır:

    - Araç zinciri (toochain)
    - Önyükleyici (bootloader)
    - Derlenmiş Linux çekirdeği (Linux kernel)
    - Kök dosya sistemi (root file system) ve geçici kök dosya sistemi
    - Kabuk programı, init sistemi, temel utility programlar, temel kütüphaneeler, sistem servisleri (daemons), grafik arayüz
    - Ağ bileşenleri
    - Uygulama programları (Python, PHP, Ruby, ...)

    Biz zaten kursumuzda buradaki bileşenlerin bazılarını oluşturan başka araçlarda görmüştük. Örneğin "crosstool-NG" ile 
    araç zinciri oluşturmuştuk. U-Booot önyükleyicisini derleyip kullanmıştık. Linux çekirdeğini derlemiştik. BusyBox ile 
    kök dosya sistemini ve oradan da geçici kök dosya sistemini oluşturmuştuk. İşte Buildroot bütün bunları bileşik bir biçimde 
    yapabilen bir araçtır. Kolay kullanımından dolayı çokça tercih edilmektedir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Buildroot çalışmasının ayrıntılar göz ardı edildiğinde tipik aşamaları şöyledir:
    
    1) Buildroot ile çalışmadan önce aşağıdaki paaketlerin kurulması gerekmektedir. Tabii bunların çoğu zaten sisteminizde 
    kurulmuş durumda da olabilir:

    $ sudo apt-get install -y \
    sed make binutils build-essential gcc g++ bash patch gzip \
    bzip2 perl tar cpio unzip rsync file bc wget python3 \
    git cvs mercurial subversion \
    libncurses5-dev libncursesw5-dev libssl-dev \
    device-tree-compiler u-boot-tools

    2) Buildroot kaynak kodları indirilir. Kaynak kodları https://buildroot.org/download.html sitesinden manuel olarak 
    ya da wget programıyla aşağıdaki gibi indirebilirsiniz:

    $ wget https://buildroot.org/downloads/buildroot-2025.11.tar.gz

    Buildroot'un son kararlı sürümü "buildroot-2025.11.tar.gz" sürümüdür. "tar.gz" dosyanın açımını şöyle yapabilirsiniz:

    $ tar -xvzf buildroot-2025.11.tar.gz

    Buildroot kaynak dosyalarının dizin yapısı şöyledir:

    buildroot-2025.11/
    ├── arch/              # Architecture tanımları (arm, arm64, x86 vb.)
    ├── board/             # Board-specific dosyalar
    ├── boot/              # Bootloader paketleri (u-boot, grub vb.)
    ├── configs/           # Hazır defconfig dosyaları
    ├── docs/              # Dokümantasyon
    ├── fs/                # Filesystem image oluşturucular
    ├── linux/             # Linux kernel paketi
    ├── package/           # 2000+ paket tanımları
    ├── system/            # System skeleton ve device tables
    ├── toolchain/         # Toolchain build infrastructure
    ├── support/           # Yardımcı scriptler
    ├── utils/             # Utility'ler
    ├── Makefile           # Ana makefile
    ├── Config.in          # Ana konfigürasyon dosyası
    └── README             # Genel bilgi

    Biz diğer maddelerde açmış olduğumuz bu kaynak kodların kök dizninde bulunduğumuzu varsayacağız.

    3) Diğer araçlarda olduğu gibi yine bir konfigürasyon dosyasının hazırlanıp ".config" biçiminde save edilmesi gerekir. 
    Konfigürasyon dosyasını sıfırdan oluşturmak yerine yine uygun bir tanesini alarak ".config" biçiminde save edebiliriz. 
    Beagleboard ile ilgili konfigürasyon dosyaları şunlardır:

    $ ls configs/ | grep beagle
    beagleboneai64_defconfig
    beagleboneai_defconfig
    beaglebone_defconfig
    beaglebone_qt5_defconfig
    beagleplay_defconfig
    beaglev_fire_defconfig
    beagley_ai_defconfig

    Biz burada BBB için "beaglebone_defconfig" dosyasını kullanabiliriz:

    $ make beaglebone_defconfig

    Bu işlemle ".config" dosyası oluşturulmuş olacaktır. Tabii aslında bu işlem "cp" komutuyla da aşağıdaki gibi yapılabilirdi:

    $ cp configs/beaglebone_defconfig .config

    4) "make menuconfig" işlemi yapılarak konfigürasyon belirlenir.

    Buradaki belirlemeler üzerinde ayrıntılarıyla duracağız. Bu aşamada bu default belirlemeleri değiştirmeden kullanabilirsiniz.

    5) Derleme işlemi için yine "make" işlemi yapılabilir:

    $ make

    Birden fazla çekirdekle derleme yapmak için "-j" seçeneğini de kullanabilirsiniz:

    $ make -j$(nproc)

    Yalnızca araç zinciri derlemesi yapılmak isteniyorsa "make toolchain" işlemi yapılabilir:

    $ make toolchain

    make işlemi için bir çapraz derleyicinin ayarlanmadığına dikkat ediniz. Çapraz derleyicinin kendisi de zaten kaynak kod 
    olarak indirilip derlenmektedir. Buildroot önce çapraz derleyiciyi derleyerek oluşturmakta sonra onu kullanarak diğer 
    öğeleri derlemektedir. 

    "make menuconfig" aşamasında seçilen öğelere göre değişilik göstermekle birlikte derleme işlemi en az yarım saat bir zamanı 
    almaktadır. Sanal makinelerde daha fazla zamana gereksinim duyulmaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Build işlemi bittikten sonra "make menuconfig" ile belirlenen araçlar artık oluşturulmuş durumdadır. Şimdi seçtiğimiz 
    default konfigürasyon dosyası ile "make" yapıldığında oluşan bu araçlar ve onların yerleri hakkında bilgiler verelim:

    - Araçların derlenmesinde kullanılan çapraz derleyici ve binary utility araçları "output/host/bin" dizininde bulunmaktadır. 
    Tabii çapraz derleyici hedefe (yani BBB'ye) aktarılmayacaktır.  

    - Hedef sisteme ilişkin kök dosya sistemi "output/target" dizininde oluşturulmaktadır. Burada kök dosya sistemi sııştıtılmamş
    bir dizin biçiminde oluşturulmuştur. Buradan hareketle "chroot" işlemi ile denemeler yapılabilir. Bu zidinin içeriği şöyledir:

    $ ls output/target
    bin  dev  etc  lib  lib32  linuxrc  media  mnt  opt  proc  root  run  sbin  sys  THIS_IS_NOT_YOUR_ROOT_FILESYSTEM  tmp  usr  var

    - "output/images" dizinin içerisinde derlenmiş olan önemli dosyalar bulunmaktadır. Dizinin içeriği şöyledir:

    $ ls output/images
    am335x-boneblack.dtb           am335x-bone.dtb                am335x-evm.dtb    extlinux     rootfs.ext4  u-boot.img
    am335x-boneblack-wireless.dtb  am335x-bonegreen.dtb           am335x-evmsk.dtb  MLO          rootfs.tar   uEnv.txt
    am335x-boneblue.dtb            am335x-bonegreen-wireless.dtb  boot.vfat         rootfs.ext2  sdcard.img   zImage

    Buradaki dosyaların işlevlerini aşağıdaki tabloyla betimleyebiliriz:

    ┌───────────────────────────────┬────────────────────────────────────────┐
    │        Dosya Adı              │           Açıklama                     │
    ├───────────────────────────────┼────────────────────────────────────────┤
    │ am335x-boneblack.dtb          │ BeagleBone Black device tree           │
    ├───────────────────────────────┼────────────────────────────────────────┤
    │ am335x-boneblack-wireless.dtb │ BeagleBone Black Wireless device tree  │
    ├───────────────────────────────┼────────────────────────────────────────┤
    │ am335x-boneblue.dtb           │ BeagleBone Blue device tree            │
    ├───────────────────────────────┼────────────────────────────────────────┤
    │ am335x-bone.dtb               │ BeagleBone (orijinal) device tree      │
    ├───────────────────────────────┼────────────────────────────────────────┤
    │ am335x-bonegreen.dtb          │ BeagleBone Green device tree           │
    ├───────────────────────────────┼────────────────────────────────────────┤
    │ am335x-bonegreen-wireless.dtb │ BeagleBone Green Wireless device tree  │
    ├───────────────────────────────┼────────────────────────────────────────┤
    │ am335x-evm.dtb                │ AM335x EVM device tree                 │
    ├───────────────────────────────┼────────────────────────────────────────┤
    │ am335x-evmsk.dtb              │ AM335x EVM Starter Kit device tree     │
    ├───────────────────────────────┼────────────────────────────────────────┤
    │ extlinux                      │ Extlinux bootloader konfigürasyon diz. │
    ├───────────────────────────────┼────────────────────────────────────────┤
    │ boot.vfat                     │ FAT boot bölümü imajı                  │
    ├───────────────────────────────┼────────────────────────────────────────┤
    │ MLO                           │ First stage bootloader (BBB için)      │
    ├───────────────────────────────┼────────────────────────────────────────┤
    │ u-boot.img                    │ U-Boot bootloader                      │
    ├───────────────────────────────┼────────────────────────────────────────┤
    │ uEnv.txt                      │ U-Boot environment konfigürasyonu      │
    ├───────────────────────────────┼────────────────────────────────────────┤
    │ zImage                        │ Linux kernel (sıkıştırılmış)           │
    ├───────────────────────────────┼────────────────────────────────────────┤
    │ rootfs.ext2                   │ Root filesystem imajı (ext2)           │
    ├───────────────────────────────┼────────────────────────────────────────┤
    │ rootfs.ext4                   │ Root filesystem imajı (ext4)           │
    ├───────────────────────────────┼────────────────────────────────────────┤
    │ rootfs.tar                    │ Root filesystem arşivi (tar)           │
    ├───────────────────────────────┼────────────────────────────────────────┤
    │ sdcard.img                    │ SD karta yazılacak tam imaj            │
    └───────────────────────────────┴────────────────────────────────────────┘

    "sdcard.img" dosyası SD karta yazılacak tüm bilgileri içermektedir. Yani bu dosya SD karta kopyalanırsa her şey zaten 
    orada oluşturulmuş olacaktır. (Bazı hedeflerde bu dosya oluşturulmamktadır.) Anımsayacağınız gibi MLO dosyası U-Boot'un 
    "birinci düzey önyükleyici" dosyası, "boot.img" ise ikinci düzey önyükleyici dosyasıdır. Çekirdeğin gerçek imaj dosyası 
    "make menuconfig" seçeneğine göre "zImage" ya da "uImage" dosyaları biçimindedir. "am335x-boneblack.dtb" dosyası ise 
    aygıt dosyasıdır. "rootfs.tar" kök dosya sisteminin tar'lanmış halini belirtmektedir. Yani biz bu dosya açtığımızda 
    tüm kök dosya sistemi açılmış olacaktır. Aslında "make menuconfig" menüsünde kök dosya sistemine ilişkin bu tar dosyasının 
    sıkıştırılması da sağlanabilmektedir. "rootfs.cpio.gz" dosyası kök dosya sisteminin geçici kök dosya sistemi (initial 
    ramdisk) hale getirilmiş biçimidir. Anımsacağı gibi geçici kkö dosya sistemlerinin "cpio.gz" formatında bulunması 
    gerekmektedir. 

    Buradadaki "sdcard.img" dosyası tüm disk imajını tutmaktadır. Bu disk imajı içerisinde iki disk bölümü vardır. Bunlardan 
    biri FAT disk bölümü diğeri de ext4 disk bölümüdür. FAT disk bölümünün içerisinde boot dizininde boot işlemi için gerekli 
    olan tüm öğeler bulunmaktadır. İsterseniz bu imajın içini henüz hedefe yazmadan aşağıdaki adımlardan geçerek görüntüleyebilirsiniz.
    Biz bu işlemleri daha önce yapmıştık:

    $ sudo losetup -P /dev/loop0 output/images/sdcard.img 
    $ lsblk
    NAME      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
    loop0       7:0    0   76M  0 loop 
    ├─loop0p1 259:0    0   16M  0 part 
    └─loop0p2 259:1    0   60M  0 part 
    sda         8:0    0  100G  0 disk 
    ├─sda1      8:1    0    1M  0 part 
    ├─sda2      8:2    0  513M  0 part /boot/efi
    └─sda3      8:3    0 97,7G  0 part /
    sr0        11:0    1 1024M  0 rom  
    $ mkdir fat
    $ mkdir ext4
    $ sudo mount /dev/loop0p1 fat
    $ sudo mount /dev/loop0p2 ext4

    Şimdi artık "fat" ve "ext4" dizinlerinden bu disk bölümlerinin içeriğini inceleyebiliriz:

    $ ls fat
    35x-boneblack.dtb           am335x-bonegreen.dtb           am335x-evmsk.dtb  u-boot.img
    am335x-boneblack-wireless.dtb  am335x-bonegreen-wireless.dtb  extlinux          uEnv.txt
    am335x-bone.dtb                am335x-evm.dtb                 MLO               zImage
    $ ls ext4
    bin  dev  etc  lib  lib32  linuxrc  lost+found  media  mnt  opt  proc  root  run  sbin  sys  tmp  usr  var

    "uEnv.txt" dosyasının çeriği de şöyledir:

    bootpart=0:1
    devtype=mmc
    bootdir=
    bootfile=zImage
    bootpartition=mmcblk0p2
    console=ttyS0,115200n8
    loadaddr=0x82000000
    fdtaddr=0x88000000
    set_mmc1=if test $board_name = A33515BB; then setenv bootpartition mmcblk1p2; fi
    set_bootargs=setenv bootargs console=${console} root=/dev/${bootpartition} rw rootfstype=ext4 rootwait
    uenvcmd=run set_mmc1; run set_bootargs;run loadimage;run loadfdt;printenv bootargs;bootz ${loadaddr} - ${fdtaddr}

    Burada U-Boot dosyalarının ve diğer imaj dosyalarının FAT dosya sisteminin kök dizininde olduğuna dikkat ediniz. 
    Bu dosyalar ext dosya sisteminin "boot" dizininde de bulunabilmektedir. Zaten oluşturulan kök dosya sisteminde "boot" 
    dizini de yaratılmamıştır. 
    
    Yukarıdaki işlemleri şöyle geri alabilriz:

    $ sudo umount fat
    $ sudo umount ext4
    $ sudo losetup -d /dev/loop0
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/


