/*-----------------------------------------------------------------------------------------------------------------------------

                                            C ve Sistem Programcıları Derneği

                                   Gömülü Linux Sistemleri - Geliştirme ve Uygulama Kursu

                                        Sınıfta Yapılan Örnekler ve Özet Notlar
                                                        3. Bölüm

                                                  Eğitmen: Kaan ASLAN

        Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.
        Kaynak belirtmek için aşağıdaki referansı kullanabilirsiniz:           

        Aslan, K. (2025), "Gömülü Linux Sistemleri - Geliştirme ve Uygulama Kursu", Sınıfta Yapılan Örnekler ve Özet Notlar, 
            C ve Sistem Programcıları Derneği, İstanbul.

                            (Notları sabit genişlikli font kullanan programlama editörleri ile açınız.)
                                    (Editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz.)

                                            Son Güncelleme: 20/08/2025 - Çarşamba

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                            129. Ders 23/09/2025 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
  GPIO (General Purpose Input Output) sistemlerinin elektronik (yani donanımsal) kısmı Gürbüz Hoca (Gürbüz Aslan) tarafından 
    anlatılmıştı. Bu bölümde biz GPIO sisteminin gömülü Linux sistemlerindeki yazılımsal kullanımı üzerinde duracağız. Önce BBB 
    üzerinde sonra Raspberry Pi üzerinde çalışacağız. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    BBB'de her iki yanda iki GPIO soketi vardır. Bu soketlerde ikişer sütun bulunmaktadır. Her sütunda 23 GPIO pin vardır. 
    BBB'de GPIO sistemi için ilk öğrenilecek şey bu GPIO pinlerinin numaralandırılma biçimidir. Numaralandırma kartın "Ethernet 
    ve 5V girişinin bulunduğu ucu karşı tarafa bakacak biçimde konumlandırılmasıyla" yapılmıştır. Konumlandırma yapıldıktan 
    sonra sol taraftaki sokete P9, sağ taraftaki sokete ise P8 denilmektedir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kart konumlandırıldıktan sonra pin görümleri şöyle olmaktadır:

            P9 (solda)                        P8 (sağda)
    ┌─────────────┬──────────────┐   ┌─────────────┬──────────────┐
    │ P9_01  GND  │ P9_02  GND   │   │ P8_01  DGND │ P8_02  DGND  │
    │ P9_03  3.3V │ P9_04  3.3V  │   │ P8_03  03   │ P8_04  04    │
    │ P9_05  5V   │ P9_06  5V    │   │ P8_05  05   │ P8_06  06    │
    │ P9_07  SYS5V│ P9_08  SYS5V │   │ P8_07  07   │ P8_08  08    │
    │ P9_09 PWR_BT│ P9_10 SYS_RST│   │ P8_09  09   │ P8_10  10    │
    │ P9_11  11   │ P9_12  12    │   │ P8_11  11   │ P8_12  12    │
    │ P9_13  13   │ P9_14  14    │   │ P8_13  13   │ P8_14  14    │
    │ P9_15  15   │ P9_16  16    │   │ P8_15  15   │ P8_16  16    │
    │ P9_17  17   │ P9_18  18    │   │ P8_17  17   │ P8_18  18    │
    │ P9_19  19   │ P9_20  20    │   │ P8_19  19   │ P8_20  20    │
    │ P9_21  21   │ P9_22  22    │   │ P8_21  21   │ P8_22  22    │
    │ P9_23  23   │ P9_24  24    │   │ P8_23  23   │ P8_24  24    │
    │ P9_25  25   │ P9_26  26    │   │ P8_25  25   │ P8_26  26    │
    │ P9_27  27   │ P9_28  28    │   │ P8_27  27   │ P8_28  28    │
    │ P9_29  29   │ P9_30  30    │   │ P8_29  29   │ P8_30  30    │
    │ P9_31  31   │ P9_32  32    │   │ P8_31  31   │ P8_32  32    │
    │ P9_33  33   │ P9_34  34    │   │ P8_33  33   │ P8_34  34    │
    │ P9_35  35   │ P9_36  36    │   │ P8_35  35   │ P8_36  36    │
    │ P9_37  37   │ P9_38  38    │   │ P8_37  37   │ P8_38  38    │
    │ P9_39  39   │ P9_40  40    │   │ P8_39  39   │ P8_40  40    │
    │ P9_41  41   │ P9_42  42    │   │ P8_41  41   │ P8_42  42    │
    │ P9_43  43   │ P9_44  44    │   │ P8_43  43   │ P8_44  44    │
    │ P9_45  45   │ P9_46  46    │   │ P8_45  45   │ P8_46  46    │
    └─────────────┴──────────────┘   └─────────────┴──────────────┘

    Buradaki tüm pinler GPIO amacıyla kullanılmamaktadır. Bazı pinler başka işlemler için bulundurulmuştur. BBB'nin P9 ve P8
    soketi üzerindeki tüm pinleri işlevlerine göre bir liste biçiminde aşağıdaki tabloda veriyoruz:

    P9 HEADER (sol)

    P9_01 : GND
    P9_02 : GND
    P9_03 : 3.3V
    P9_04 : 3.3V
    P9_05 : 5V
    P9_06 : 5V
    P9_07 : SYS_5V
    P9_08 : SYS_5V
    P9_09 : PWR_BUT
    P9_10 : SYS_RESETn
    P9_11 : UART4_RXD
    P9_12 : GPIO / GPIO1_28
    P9_13 : UART4_TXD
    P9_14 : EHRPWM1A
    P9_15 : GPIO / GPIO1_16
    P9_16 : EHRPWM1B
    P9_17 : I2C1_SCL / SPI0_CS0
    P9_18 : I2C1_SDA / SPI0_MISO
    P9_19 : I2C2_SCL
    P9_20 : I2C2_SDA
    P9_21 : UART2_TXD / SPI0_D0
    P9_22 : UART2_RXD / SPI0_SCLK
    P9_23 : GPIO / GPIO1_17
    P9_24 : UART1_TXD
    P9_25 : GPIO / GPIO3_21
    P9_26 : UART1_RXD
    P9_27 : GPIO / GPIO3_19
    P9_28 : SPI1_CS0
    P9_29 : SPI1_D0
    P9_30 : SPI1_D1
    P9_31 : SPI1_SCLK
    P9_32 : VDD_ADC (1.8V)
    P9_33 : AIN4
    P9_34 : GND
    P9_35 : AIN6
    P9_36 : AIN5
    P9_37 : AIN2
    P9_38 : AIN3
    P9_39 : AIN0
    P9_40 : AIN1
    P9_41 : GPIO / CLKOUT2 / UART5_TXD
    P9_42 : GPIO / GPIO0_7 / UART5_RXD
    P9_43 : GND
    P9_44 : GND
    P9_45 : GND
    P9_46 : GND
        
    P8 HEADER (sağ)

    P8_01 : GND
    P8_02 : GND
    P8_03 : GPIO / LCD_DATA2
    P8_04 : GPIO / LCD_DATA3
    P8_05 : GPIO / LCD_DATA4
    P8_06 : GPIO / LCD_DATA5
    P8_07 : GPIO / LCD_DATA6
    P8_08 : GPIO / LCD_DATA7
    P8_09 : GPIO / LCD_DATA0
    P8_10 : GPIO / LCD_DATA1
    P8_11 : GPIO / GPIO1_13
    P8_12 : GPIO / GPIO1_12
    P8_13 : GPIO / EHRPWM2B
    P8_14 : GPIO / GPIO0_26
    P8_15 : GPIO / GPIO1_15
    P8_16 : GPIO / GPIO1_14
    P8_17 : GPIO / GPIO0_27
    P8_18 : GPIO / GPIO2_1
    P8_19 : GPIO / EHRPWM2A
    P8_20 : GPIO / GPIO1_31
    P8_21 : GPIO / GPIO1_30
    P8_22 : GPIO / GPIO1_5
    P8_23 : GPIO / GPIO1_4
    P8_24 : GPIO / GPIO1_1
    P8_25 : GPIO / GPIO1_0
    P8_26 : GPIO / GPIO1_29
    P8_27 : GPIO / GPIO2_22
    P8_28 : GPIO / GPIO2_24
    P8_29 : GPIO / GPIO2_23
    P8_30 : GPIO / GPIO2_25
    P8_31 : GPIO / UART5_CTSN
    P8_32 : GPIO / UART5_RTSN
    P8_33 : GPIO / UART4_RTSN
    P8_34 : GPIO / UART3_RTSN / PWM
    P8_35 : GPIO / UART4_CTSN
    P8_36 : GPIO / UART3_CTSN / PWM
    P8_37 : GPIO / UART5_TXD
    P8_38 : GPIO / UART5_RXD
    P8_39 : GPIO / GPIO2_12
    P8_40 : GPIO / GPIO2_13
    P8_41 : GPIO / GPIO2_10
    P8_42 : GPIO / GPIO2_11
    P8_43 : GPIO / GPIO2_8
    P8_44 : GPIO / GPIO2_9
    P8_45 : GPIO / GPIO2_6 / PWM
    P8_46 : GPIO / GPIO2_7 / PWM
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    BBB'de pin numaralandırması üç farklı biçimde yapılmaktadır. Birinci numaralandırma biçimi tamamen sokete göre yapılan 
    numaralandırmadır. Bu numaralandırmaya "fiziksel numaralandırma" diyeceğiz. Yukarıdaki ilk şekilde bu fiziksel numaralandırma 
    kullanılmıştır. Bu numaralandırma P9_XX ve P8_XX biçiminde yapılmaktadır. Buradaki P9 ve P8 soketin yerini belirtmektedir. 
    Bizim konumlandırmamıza göre P9 soldaki soket, P8 sağdaki sokettir. Bu soketlerin solundaki 23 pinlik sütun tek sayılarla, 
    sağındaki 23 pinlik sütun çift sayılarla numaralandırılmaktadır. Numaralandırma 1'den başlanarak aşağıdaki gibi yapılmıştır:

    1   2
    3   4
    5   6
    7   8
    9   10
    11  12
    13  14
    15  16
    17  18
    19  20
    21  22
    23  24
    25  26
    27  28
    29  30
    31  32
    33  34
    35  36
    37  38
    39  40
    41  42
    43  44
    45  46

    Örneğin P9_12 fiziksel pin numarası soldaki soketin 12 numaralı pini anlamına gelmektedir. Örneğin P8_07 sağdaki soketin 
    7 numaralı pini anlamına gelmektedir. 

    İkinci numaralandırma sistemi AM335x SoC tasarımında kullanılan içsel numaralandırma sistemidir. Buna "SoC numaralandırması" 
    diyeceğiz. Bu numaralandırma sisteminde bu GPIO pinlerini kontrol eden denetleyici temel alınmıştır. AM335x SoC tasarımında 
    aslında içsel olarak GPIO uçlarını kontrol eden 4 denetleyici vardır. Bu denetleyicilerin her biri 32 çıkışlıdır. Ancak bu 
    32 çıkışın hepsi P9 ve P8 soketlerine bağlanmamıştır. (Bağlanmayanların bazıları kart üzerindeki LED'leri yakmakta, bazıları 
    ise başka amaçlarla kullanılmaktadır. Bazıları da tamamen boş bırakılmıştır. Eğer sütunlarda 23'den daha fazla pin olsaydı 
    kartın boyutlarının da değiştirilmesi gerekebilirdi.) SoC içerisindeki denetleyicilerin uçları P9 ve P8 soketlerindeki pinlere 
    karışık dağıtılmıştır. Yani fiziksel numaradan hareketle SoC numaralandırması elde edilememektedir. SoC numaralandırılması 
    GPIOX_Y biçiminde yapılmaktadır. Buradaki X harfi SoC içerisindeki denetleyicinin numarasını belirtmektedir. Y harfi ise 
    denetleyicinin 32 ucundan hangisinin pine bağlandığını belirtmektedir. Aşağıda fiziksel pin numaralarına karşı gelen SoC 
    ve aygıt sürücü numaraları bir tablo halinde verilmiştir. Bu tabloda P9 ve P8 soketlerinde olmayan pinler de belirtilmiştir:

                             P9 Soketi
    ┌──────┬──────────┬─────────────────┬──────────────┬─────────────┐
    │ Pin  │ Proc Pin │  Ana Fonksiyon  │ GPIO Göst.   │ GPIO Sayısı │
    ├──────┼──────────┼─────────────────┼──────────────┼─────────────┤
    │ P9_1 │    -     │      GND        │      -       │      -      │
    │ P9_2 │    -     │      GND        │      -       │      -      │
    │ P9_3 │    -     │    DC_3.3V      │      -       │      -      │
    │ P9_4 │    -     │    DC_3.3V      │      -       │      -      │
    │ P9_5 │    -     │    VDD_5V       │      -       │      -      │
    │ P9_6 │    -     │    VDD_5V       │      -       │      -      │
    │ P9_7 │    -     │    SYS_5V       │      -       │      -      │
    │ P9_8 │    -     │    SYS_5V       │      -       │      -      │
    │ P9_9 │    -     │    PWR_BUT      │      -       │      -      │
    │P9_10 │   A10    │  SYS_RESETn     │      -       │      -      │
    │P9_11 │   T17    │  UART4_RXD      │   GPIO0_30   │     30      │
    │P9_12 │   U18    │   GPIO1_28      │   GPIO1_28   │     60      │
    │P9_13 │   U17    │  UART4_TXD      │   GPIO0_31   │     31      │
    │P9_14 │   U14    │   EHRPWM1A      │   GPIO1_18   │     50      │
    │P9_15 │   R13    │   GPIO1_16      │   GPIO1_16   │     48      │
    │P9_16 │   T14    │   EHRPWM1B      │   GPIO1_19   │     51      │
    │P9_17 │   A16    │   I2C1_SCL      │   GPIO0_5    │     5       │
    │P9_18 │   B16    │   I2C1_SDA      │   GPIO0_4    │     4       │
    │P9_19 │   D17    │   I2C2_SCL      │   GPIO0_13   │     13      │
    │P9_20 │   D18    │   I2C2_SDA      │   GPIO0_12   │     12      │
    │P9_21 │   B17    │  UART2_TXD      │   GPIO0_3    │     3       │
    │P9_22 │   A17    │  UART2_RXD      │   GPIO0_2    │     2       │
    │P9_23 │   V14    │   GPIO1_17      │   GPIO1_17   │     49      │
    │P9_24 │   D15    │  UART1_TXD      │   GPIO0_15   │     15      │
    │P9_25 │   A14    │   GPIO3_21      │   GPIO3_21   │    117      │
    │P9_26 │   D16    │  UART1_RXD      │   GPIO0_14   │     14      │
    │P9_27 │   C13    │   GPIO3_19      │   GPIO3_19   │    115      │
    │P9_28 │   C12    │   SPI1_CS0      │   GPIO3_17   │    113      │
    │P9_29 │   B13    │   SPI1_D0       │   GPIO3_15   │    111      │
    │P9_30 │   D12    │   SPI1_D1       │   GPIO3_16   │    112      │
    │P9_31 │   A13    │  SPI1_SCLK      │   GPIO3_14   │    110      │
    │P9_32 │    -     │     VADC        │      -       │      -      │
    │P9_33 │   C8     │     AIN4        │      -       │      -      │
    │P9_34 │    -     │     AGND        │      -       │      -      │
    │P9_35 │   A8     │     AIN6        │      -       │      -      │
    │P9_36 │   B8     │     AIN5        │      -       │      -      │
    │P9_37 │   B7     │     AIN2        │      -       │      -      │
    │P9_38 │   A7     │     AIN3        │      -       │      -      │
    │P9_39 │   B6     │     AIN0        │      -       │      -      │
    │P9_40 │   C7     │     AIN1        │      -       │      -      │
    │P9_41 │   D14    │   CLKOUT2       │   GPIO0_20   │     20      │
    │P9_41 │   D13    │   GPIO3_20      │   GPIO3_20   │    116      │
    │P9_42 │   C18    │   GPIO0_7       │   GPIO0_7    │     7       │
    │P9_42 │   B12    │   GPIO3_18      │   GPIO3_18   │    114      │
    │P9_43 │    -     │      GND        │      -       │      -      │
    │P9_44 │    -     │      GND        │      -       │      -      │
    │P9_45 │    -     │      GND        │      -       │      -      │
    │P9_46 │    -     │      GND        │      -       │      -      │
    └──────┴──────────┴─────────────────┴──────────────┴─────────────┘

                             P8 Soketi
    ┌──────┬──────────┬─────────────────┬──────────────┬─────────────┐
    │ Pin  │ Proc Pin │  Ana Fonksiyon  │ GPIO Göst.   │ GPIO Sayısı │
    ├──────┼──────────┼─────────────────┼──────────────┼─────────────┤
    │ P8_1 │    -     │      GND        │      -       │      -      │
    │ P8_2 │    -     │      GND        │      -       │      -      │
    │ P8_3 │    R9    │   GPIO1_6       │   GPIO1_6    │     38      │
    │ P8_4 │    T9    │   GPIO1_7       │   GPIO1_7    │     39      │
    │ P8_5 │    R8    │   GPIO1_2       │   GPIO1_2    │     34      │
    │ P8_6 │    T8    │   GPIO1_3       │   GPIO1_3    │     35      │
    │ P8_7 │    R7    │    TIMER4       │   GPIO2_2    │     66      │
    │ P8_8 │    T7    │    TIMER7       │   GPIO2_3    │     67      │
    │ P8_9 │    T6    │    TIMER5       │   GPIO2_5    │     69      │
    │P8_10 │    U6    │    TIMER6       │   GPIO2_4    │     68      │
    │P8_11 │   R12    │   GPIO1_13      │   GPIO1_13   │     45      │
    │P8_12 │   T12    │   GPIO1_12      │   GPIO1_12   │     44      │
    │P8_13 │   T10    │   EHRPWM2B      │   GPIO0_23   │     23      │
    │P8_14 │   T11    │   GPIO0_26      │   GPIO0_26   │     26      │
    │P8_15 │   U13    │   GPIO1_15      │   GPIO1_15   │     47      │
    │P8_16 │   V13    │   GPIO1_14      │   GPIO1_14   │     46      │
    │P8_17 │   U12    │   GPIO0_27      │   GPIO0_27   │     27      │
    │P8_18 │   V12    │   GPIO2_1       │   GPIO2_1    │     65      │
    │P8_19 │   U10    │   EHRPWM2A      │   GPIO0_22   │     22      │
    │P8_20 │    V9    │   GPIO1_31      │   GPIO1_31   │     63      │
    │P8_21 │    U9    │   GPIO1_30      │   GPIO1_30   │     62      │
    │P8_22 │    V8    │   GPIO1_5       │   GPIO1_5    │     37      │
    │P8_23 │    U8    │   GPIO1_4       │   GPIO1_4    │     36      │
    │P8_24 │    V7    │   GPIO1_1       │   GPIO1_1    │     33      │
    │P8_25 │    U7    │   GPIO1_0       │   GPIO1_0    │     32      │
    │P8_26 │    V6    │   GPIO1_29      │   GPIO1_29   │     61      │
    │P8_27 │    U5    │   GPIO2_22      │   GPIO2_22   │     86      │
    │P8_28 │    V5    │   GPIO2_24      │   GPIO2_24   │     88      │
    │P8_29 │    R5    │   GPIO2_23      │   GPIO2_23   │     87      │
    │P8_30 │    R6    │   GPIO2_25      │   GPIO2_25   │     89      │
    │P8_31 │    V4    │  UART5_CTSN     │   GPIO0_10   │     10      │
    │P8_32 │    T5    │  UART5_RTSN     │   GPIO0_11   │     11      │
    │P8_33 │    V3    │  UART4_RTSN     │   GPIO0_9    │     9       │
    │P8_34 │    U4    │  UART3_RTSN     │   GPIO2_17   │     81      │
    │P8_35 │    V2    │  UART4_CTSN     │   GPIO0_8    │     8       │
    │P8_36 │    U3    │  UART3_CTSN     │   GPIO2_16   │     80      │
    │P8_37 │    U1    │  UART5_TXD      │   GPIO2_14   │     78      │
    │P8_38 │    U2    │  UART5_RXD      │   GPIO2_15   │     79      │
    │P8_39 │    T3    │   GPIO2_12      │   GPIO2_12   │     76      │
    │P8_40 │    T4    │   GPIO2_13      │   GPIO2_13   │     77      │
    │P8_41 │    T1    │   GPIO2_10      │   GPIO2_10   │     74      │
    │P8_42 │    T2    │   GPIO2_11      │   GPIO2_11   │     75      │
    │P8_43 │    R3    │   GPIO2_8       │   GPIO2_8    │     72      │
    │P8_44 │    R4    │   GPIO2_9       │   GPIO2_9    │     73      │
    │P8_45 │    R1    │   GPIO2_6       │   GPIO2_6    │     70      │
    │P8_46 │    R2    │   GPIO2_7       │   GPIO2_7    │     71      │
    └──────┴──────────┴─────────────────┴──────────────┴─────────────┘

    Üçüncü numaralandırma sistemi de Linux aygıt sürücülerinin kullandığı numaralandırma sistemidir. Bu numaralandırma
    sistemine "aygıt sürücü numaralandırması" diyebiliriz. Bu numaralandırma sistemi Linux'un sysfs dosya sisteminde kullanılan 
    numaralandırma sistemidir. Aygıt sürücüler bu sistemi kullanmaktadır. Bu sistemdeki pin numaraları GPIOXX biçiminde 
    belirtilmektedir. Her pinin bir numarası vardır. GPIOX_Y SoC numarası Z = X * 32 + Y biçiminde aygıt sürücü GPIOZ numarasına 
    dönüştürülmektedir. Örneğin GPIO1_14 pininin aygıt sürücü numarası GPIO46'dır. Örneğin GPIO3_21 pininin aygıt sürücü numarası 
    GPIO117 biçimindedir. Yukarıdaki tablolarda her pinin üç numaralandırma sistemindeki karşılıkları tek tek verilmiştir. 

    Peki yukarıda üç numaralandırma biçimini gördük. Hangi numaralandırmalar hangi bağlamlarda kullanılmaktadır? Fiziksel 
    bağlantılar yapılırken genellikle fiziksel numaralandırma kullanılmaktadır. Aşağı seviyeli SoC denetleyicisi üzerinde 
    işlemler yapılacaksa (örneğin aygıt sürücüler yazılacaksa) mecburen SoC numaralandırılmasının kullanılması gerekmektedir. 
    Ancak Linux'un sys dosya sistemindeki dizin girişleri kullanılacaksa yani kullanıcı modunda programlar yazılacaksa bu 
    bağlamda aygıt sürücü numaralandırması kullanılmaktadır. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    GPIO devrelerinin donanımsal özelliklerini Gürbüz Hoca anlatmıştı. Peki biz gömülü sistem mühendisi olarak bu GPIO pinleriyle 
    ne yapabiliriz? Temelde bu GPIO pinleri üç amaçla kullanılabilmektedir:

    OUT 
    IN
    Interrupt

    Bu pinleri biz önce belli bir yön için programlarız. OUT işlemi ilgili pine elektriksel işaret uygulamak anlamına gelmektedir. 
    Dolayısıyla bir pin elektriksel olarak Lojik 1 seviyesine çekildiğinde o başka elektronik devreyi sürebilir. IN işlemi 
    ters işlemdir. Dış dünyadaki bir birimin o uca uyguladığı elektriksel işaretin okunması anlamına gelir. O halde kartımızdan 
    dış dünyaya elektriksel ileti göndermek için OUT işlemi, dış dünyadan bu iletileri almak için IN işlemi yapmak gerekir. 
    GPIO pinlerinin diğer bir özelliği de "kesme (interrupt)" oluşturabilmesidir. Biz bu pinleri başka aygıtlara bağladığımızda 
    onların bu uçlar yoluyla kesme oluşturmasını sağlayabilmekteyiz. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    GPIO pinleriyle OUT ve IN işlemlerinin testi için basit devreler kullanacağız. OUT testi için en basit devre şüphesiz bir 
    LED'in yakılıp söndürülmesini sağlayan devredir. LED'in yakılması için test devresi şöyle oluşturulabilir:

    GPIO pin
    │    
    ├───[R 470Ω]───|>|───⏚ GND
                   A K

    Bu devrede LED'in kısa ucu (katot) toprağa uzun ucu (anot) önce bir dirence sonra da GPIO uçlarından birine bağlanmıştır. 
    Burada 470Ω gibi küçük dirençler kullanabilirsiniz. Ancak dirençsiz bağlamayınız. Biz örneklerimizde bu amaçla P9_12 (GPIO1_28, 
    GPIO60) pinini kullanacağız. 

    IN testi için en basit devre bir düğme (button) devresidir. Bu devrede düğmeye basılmamışsa GPIO ucundan lojik 1 değeri 
    basılmışsa 0 değeri okunmaktadır. Protoborta yerleştirebileceğiniz çok küçük düğmeler (push buttons) bulunmaktadır. Bunlardan 
    satın alabilirsiniz. Devre şöyledir:

    +3.3V
    │
    [10kΩ]
    │
    ├─── GPIO
    │
    [ Buton ]
    │
    ⏚ GND

    Burada düğmenin bir ucunun toprağa bağlı, diğer ucunun GPIO pinlerinden birine bağlı olduğuna dikkat ediniz. GPIO pinine 
    bağlı olan uç aynı zamanda 10K gibi büyük bir dirençle soketteki 3.3V ucuna bağlanmıştır. Böylece düğmeye basılmamışsa 
    ilgili uçtan lojik 1 değeri, basılmışsa 0 değeri okunacaktır. Biz örneklerimizde bu amaçla P9_16 (GPIO1_19, GPIO51) pinini 
    kullanacağız. 

    P9 soketinde toprak (GND) uçlarının ve 3.3V ile 5V uçlarının bulunduğuna dikkat ediniz. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    GPIO programlaması için Linux'ta çeşitli seçenekler vardır:

    - sysfs dosya sistemini kullanarak programlama.
    - "/dev/gpiochipX" aygıt sürücüsünü kullanarak programlama.
    - "gpiod" kütüphanesini kullanarak programlama (zaten gpiod kütüphanesi /dev/gpiochipX" aygıt sürücüsünü kullanıyor). 
    - Aygıt sürücü yazıp, bellek tabanlı IO (memory-mapped IO) işlemleriyle AM335x SoC içerisindeki GPIO denetleyicisine 
    komutlar göndererek programlama.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                        130. Ders 25/09/2025 - Perşembe 
-----------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi bir aygıt sürücü class_create çekirdek fonksiyonu ile "/sys/class" dizininde bir giriş yaratabilmekteydi. 
    Daha sonra device_create fonksiyonuyla da bir device nesnesi yaratılıp bu sysfs dosya sistemi üzerinde işlemler yapılabilmektedir. 
    Yine anımsayacağınız gibi sysfs dosya sistemi amaç olarak proc dosya sistemine benzemekteydi. proc dosya sisteminin bazı 
    yetersizlikleri görüldüğü için o dosya sistemi muhafaza edilerek sysfs dosya sisteminin çekirdeğe eklendiğinden bahsetmiştik. 
    İşte çekirdek içerisindeki gpio aygıt sürücüsü dosya tabanlı erişimler için "/sys/class/gpio" dizinini kullanmaktadır. 

    "/sys/class/gpio" dizininde "export", "unexport" dosyalarının yanı sıra GPIO pinlerini temsil eden "gpioxx" isminde (buradaki 
    "xx" GPIO aygıt sürücü numaralandırmasına ilişkin sayıyı belirtmektedir) dizinler vardır. Örneğin BBB'deki Linux dağıtımında 
    bu dizini görüntülediğimizde aşağıdaki girişleri görmekteyiz:

    $ debian@BeagleBone:/sys/class/gpio$ ls
    export   gpio114  gpio15  gpio3   gpio36  gpio46  gpio60  gpio68  gpio74  gpio80  gpiochip0
    gpio10   gpio115  gpio2   gpio30  gpio37  gpio47  gpio61  gpio69  gpio75  gpio81  gpiochip32
    gpio11   gpio116  gpio20  gpio31  gpio38  gpio48  gpio62  gpio7   gpio76  gpio86  gpiochip64
    gpio110  gpio117  gpio22  gpio32  gpio39  gpio49  gpio63  gpio70  gpio77  gpio87  gpiochip96
    gpio111  gpio12   gpio23  gpio33  gpio4   gpio5   gpio65  gpio71  gpio78  gpio88  unexport
    gpio112  gpio13   gpio26  gpio34  gpio44  gpio50  gpio66  gpio72  gpio79  gpio89
    gpio113  gpio14   gpio27  gpio35  gpio45  gpio51  gpio67  gpio73  gpio8   gpio9

    Şimdi bu dizinlerden birine girelim. Örneğin LED'imizi bağladığımız gpio60 dizinine geçelim. Bu dizinin içeriği şöyledir:

    debian@BeagleBone:/sys/class/gpio/gpio60$ ls
    active_low  device  direction  edge  label  power  subsystem  uevent  value

    Burada üç dosya bizim için önemlidir. "direction" dosyası ilgili pini OUT ya da IN biçiminde konfigüre etmek için kullanılmaktadır. 
    Bu dosyaya biz "out" ya da "in" yazısını yazdırdığımızda ilgili pin bu amaçla konfigüre edilmiş olur. Örneğin biz GPIO60 
    pinini (P9_12, GPIO1_28 pinini) OUT biçiminde şöyle konfigüre edebiliriz:

    $ echo "out" | sudo tee direction

    Örneğin biz GPIO51 numaralı pini IN olarak konfigüre etmek için önce "gpio51" dizinine geçip aşağıdaki komutu uygulayabiliriz:

    $ echo "in" | sudo tee direction

    Artık sıra ilgili pin OUT olarak konfigüre edilmişse o pine lojik 1 ya da lojik 0 değerini göndermeye, IN olarak konfigüre
    edilmişse o pine uygulanan işareti okumaya gelmiştir. Bunun için "value" dosyası kullanılmaktadır. Örneğin LED'imizin bağlı 
    olduğu GPIO60 pinini lojik 1 seviyesine (3.3 volt) çekmek için aşağıdaki komutu kullanabiliriz:

    $ echo "1" | sudo tee value

    Tekrar 0'a çekmek için ise aşağıdaki komutu kullanabiliriz:

    $ echo "0" | sudo tee value

    Şimdi de düğmeyi bağladığımız GPIO51 numaralı pini okumak için "gpio51" dizinine geçelim. "value" dosyası zaten herkes 
    tarafından okunabilmektedir. (Bu dosyanın erişim hakları "-rw-rw-r--" biçimindedir.) O halde bu pini şöyle okuyabiliriz:

    $ cat value
    1

    Düğmeye basarak okuma yaparsak 0 okumamız gerekir. Şimdi aynı denemeyi düğmeye basarak yapalım:

    $ cat value
    0
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Tabii yukarıda açıkladığımız "direction" ve "value" dosyalarını bir C programıyla açıp oraya "1" ve "0" karakterlerini 
    de gönderebiliriz. Örneğin LED'imizi 1 saniye süreyle yakıp söndüren bir programı aşağıdaki gibi yazabiliriz:

    #include <stdio.h>
    #include <stdlib.h>
    #include <fcntl.h>
    #include <unistd.h>

    void write_file(const char *path, const char *cmd);
    void exit_sys(const char *msg);

    int main(void)
    {
        int fd;

        write_file("/sys/class/gpio/gpio60/direction", "out");

        if ((fd = open("/sys/class/gpio/gpio60/value", O_RDWR)) == -1) 
            exit_sys("open");
        
        for (;;) {
            lseek(fd, 0, 0);
            if (write(fd, "1", 1) == -1)
                exit_sys("write");
            sleep(1);
            lseek(fd, 0, 0);
            if (write(fd, "0", 1) == -1)
                exit_sys("write");
            sleep(1);
        }

        close(fd);      /* unreachable code */

        return 0;
    }

    void write_file(const char *path, const char *cmd)
    {
        int fd;

        if ((fd = open(path, O_WRONLY)) == -1) 
            exit_sys("open");

        if (write(fd, cmd, strlen(cmd)) == -1)
            exit_sys("write");

        close(fd);
    }

    void exit_sys(const char *msg)
    {
        perror(msg);

        exit(EXIT_FAILURE);
    }

    Programdaki for döngüsüne dikkat ediniz:

    for (;;) {
        if (write(fd, "1", 1) == -1)
            exit_sys("write");
        sleep(1);
        if (write(fd, "0", 1) == -1)
            exit_sys("write");
        sleep(1);
    }

    Aslında bildiğiniz gibi write işlemlerinde dosya göstericisi ilerletilmektedir. Yani yazma işlemlerinden önce bizim 
    dosya göstericisini lseek fonksiyonuyla başa çekmemiz gerekir. Ancak aygıt sürücüler konusunda da gördüğümüz gibi
    bazen aygıt sürücüleri yazanlar bu tür amaçlarla oluşturdukları küçük arayüz dosyalarında dosya göstericisinin konumunu 
    dikkate almadan okumayı ve yazmayı hep baştan itibaren yapabilmektedir. Tabii siz bu bilgiyi bilmek zorunda olmadığınız 
    için daha temkinli bir biçimde yazma işleminden önce dosya göstericisini dosyanın başına çekmelisiniz. (BBB'deki "value" 
    dosyasına dosya göstericisini başa çekmeden de "1" ve "0" yazılabilmektedir.)  

    Yukarıdaki programda sonsuz döngü oluşturulduğu için programı Ctrl+C tuşları ile sonlandırabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de bir döngü içerisinde GPIO51 pinini okumak isteyelim. Okumayı sonsuz bir döngü içerisinde "polling" yöntemiyle 
    yapıp yalnızca değişiklik oluştuğunda pinin değerini yazdıralım. Böyle bir C programını aşağıdaki gibi yazabiliriz:

    #include <stdio.h>
    #include <stdlib.h>
    #include <fcntl.h>
    #include <unistd.h>
    
    void write_file(const char *path, const char *cmd); 
    void exit_sys(const char *msg);  
    
    int main(void)
    {
        int fd;
        char status, prev_status = '1';

        write_file("/sys/class/gpio/gpio51/direction", "in");

        if ((fd = open("/sys/class/gpio/gpio51/value", O_RDONLY)) == -1) 
            exit_sys("open");
        
        for (;;) {
            lseek(fd, 0, 0);
            if (read(fd, &status, 1) == -1)
                exit_sys("read");
            if (status != prev_status) {
                printf("%c\r", status);
                fflush(stdout);
                prev_status = status;
            }
        }

        close(fd);      /* unreachable code */

        return 0;
    }

    void write_file(const char *path, const char *cmd)
    {
        int fd;

        if ((fd = open(path, O_WRONLY)) == -1) 
            exit_sys("open");

        if (write(fd, cmd, strlen(cmd)) == -1)
            exit_sys("write");

        close(fd);
    }

    void exit_sys(const char *msg)
    {
        perror(msg);

        exit(EXIT_FAILURE);
    }

    Burada da sonsuz döngü söz konusu olduğu için programı sonlandırmak için Ctrl+C tuşlarını kullanabilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Peki yukarıdaki programlarda POSIX fonksiyonları yerine C'nin standart dosya fonksiyonlarını kullanabilir miydik? Evet 
    kullanabilirdik. Ancak C'nin standart dosya fonksiyonlarının "tamponlu (buffered)" biçimde çalıştığını göz önünde bulundurmak
    gerekir. Biz standart C fonksiyonlarıyla bir dosyaya yazma yaptığımızda aslında yazılanlar önce bir tampona yazılıp 
    biriktirilmekte sonra hedefe aktarılmaktadır. Bu tür durumlarda yazma yaptıktan sonra fflush çağrısı yapmayı unutmayınız. 
    (C standartlarına göre fseek işlemi fflush işlemine de yol açmaktadır.) Örneğin:

    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>

    void write_file(const char *path, const char *cmd); 

    int main(void)
    {
        FILE *f;

        write_file("/sys/class/gpio/gpio60/direction", "out");

        if ((f = fopen("/sys/class/gpio/gpio60/value", "w")) == NULL) {
            fprintf(stderr, "cannot open file!..\n");
            exit(EXIT_FAILURE);
        }

        for (;;) {
            fseek(f, 0, 0);
            fprintf(f, "1");        /* fputc('1', f); */
            fflush(f);
            
            sleep(1);
            
            fseek(f, 0, 0);     
            fprintf(f, "0");        /* fputc('0', f); */
            fflush(f);

            sleep(1);
        }

        fclose(f);

        return 0;
    }

    void write_file(const char *path, const char *cmd)
    {
        FILE *f;

        if ((f = fopen(path, "w")) == NULL) {
            fprintf(stderr, "cannot open file: %s\n", path);
            exit(EXIT_FAILURE);
        }
        fprintf(f, "%s", cmd);
        fclose(f);
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Tabii aslında biz yukarıdaki programları başka dillerde de yazabiliriz. Örneğin LED yakma programı Python'da birkaç satırla 
    aşağıdaki gibi yazılabilir:
                                         
    import time

    with open('/sys/class/gpio/gpio60/value', 'w') as f:
        while True:
            f.write('1')
            f.flush()
            time.sleep(0.2)
            f.write('0')
            f.flush()
            time.sleep(0.2)
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                        131. Ders 30/09/2025 - Salı
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki programları biz doğrudan BBB üzerinde derleyerek çalıştırdık. Her ne kadar BBB ortamı zayıf bir geliştirme 
    ortamı sunuyor olsa da basit programların doğrudan BBB üzerinde derlenmesi performans bakımından bir sorun doğurmamaktadır. 
    Şimdi de yukarıdaki programlardan birini host sistem olarak kullandığımız Linux sistemlerinde çapraz derleyici ile derleyelim 
    ve çalıştırılabilen kodu BBB'ye aktaralım. Bunun için daha önce yaptığımız gibi önce PATH çevre değişkenine çapraz derleyicimizin 
    "bin" dizinini eklememiz gerekir:

    $ PATH=$PATH:/home/kaan/Study/EmbeddedLinux/DriverDevelopment/BBB/gcc-arm-9.2-2019.12-x86_64-arm-none-linux-gnueabihf/bin

    Daha sonra ARCH çevre değişkenini "arm" biçiminde oluşturmamız gerekir:

    $ export ARCH=arm

    Artık herhangi bir yerde çapraz derleyicimizi "arm-none-linux-gnueabihf-gcc" ismiyle çalıştırabiliriz. Ancak daha kısa 
    isim kullanmak istersek CC gibi bir çevre değişkenini de bu ismi belirtecek biçimde oluşturabiliriz:

    $ export CC=arm-none-linux-gnueabihf-gcc

    Derlemeyi şöyle yapabiliriz:

    $ $CC -o led-blink led-blink.c

    Elde edilen çalıştırılabilir dosyayı "scp" komutuyla BBB'ye aşağıdaki gibi aktarabiliriz:

    $ scp led-blink debian@192.168.7.2:
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de GPIO pinlerinde kesme mekanizmasının kullanılmasına bir örnek verelim. GPIO pinini "kesme (interrupt)" için 
    konfigüre etmeden önce IN biçiminde konumlandırmak gerekir. sysfs arayüzünde kesme mekanizması için "edge" isimli dosya 
    kullanılmaktadır. Bu dosyaya "rising" ya da "falling" yazısı yazdırılır. "rising" kesmenin pin değeri 0'dan 1'e geçerken 
    oluşacağını "falling" 1'den 0'a geçerken oluşacağını belirtmektedir. Biz düğme devremizde düğmeye bastığımızda kesme 
    oluşmasını istiyorsak bu dosyaya "falling" yazmalıyız. Çünkü anımsayacağınız gibi bizim devremizde düğmeye basılmadığı 
    sürece pinden 1 okunuyordu. Düğmeye basıldığında 0 okunuyordu. Bu durumda düğmeye bastığımızda 1'den 0'a geçiş oluşacak 
    bu da kesmeyi tetikleyecektir. Tabii tam ters biçimde kesmenin parmağımızı düğmeden çektiğimizde tetiklenmesini istiyorsak 
    bu durumda "edge" dosyasına "rising" yazmalıyız. Bu işlemler komut satırında yapılabileceği gibi bir C programıyla da 
    yapılabilir. 

    sysfs dosya sistemi ile GPIO kesme işlemlerinin ele alınması için "multiplexed IO" fonksiyonları denilen select, poll 
    ya da epoll fonksiyonlarının kullanılması gerekmektedir. Biz bir pini kesme olarak konfigüre ettiğimizde o pinin "value" 
    dosyasını okursak bloke olmayız. Bu value dosyasının select, poll ya da epoll fonksiyonlarıyla ele alınması gerekmektedir. 
    select ve poll fonksiyonları POSIX fonksiyonlarıdır. Ancak epoll fonksiyonu Linux sistemlerine özgüdür. epoll fonksiyonu 
    poll fonksiyonunun Linux sistemleri için iyileşirilmiş bir biçimi gibidir. select, poll ve epoll fonksiyonları çekirdek 
    içerisindeki sys_select, sys_poll ve sys_epoll sistem fonksiyonlarını çağırmaktadır. Bu fonksiyonlar aslında belli bir 
    noktadan sonra ortak kodları çalıştırmaktadır. Biz aygıt sürücüler konusunda aygıt sürücülerin bu fonksiyonlarla nasıl 
    kullanılacağı üzerinde durmadık. Ancak bu üç fonksiyon da en sonunda karakter aygıt sürücülerinin file_operations yapısının 
    poll elemanında adresi tutulan fonksiyonu çağırmaktadır. Çekirdeğe gömülmüş olan GPIO aygıt sürücüsü bu poll fonksiyonunu 
    uygun biçimde ele almıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi sysfs arayüzü ile GPIO pinlerindeki kesme işlemlerini select fonksiyonuyla ele alabilmek 
    için önce pinleri uygun biçimde konfigüre etmek gerekir. Bu işlemi şöyle yapabiliriz:

    write_file("/sys/class/gpio/gpio51/direction", "in");
    write_file("/sys/class/gpio/gpio51/edge", "falling");

    Buradaki write_file fonksiyonunu yukarıdaki örneklerde de kullanmıştık:

    void write_file(const char *path, const char *cmd)
    {
        int fd;

        if ((fd = open(path, O_WRONLY)) == -1) 
            exit_sys("open");

        if (write(fd, cmd, strlen(cmd)) == -1)
            exit_sys("write");

        close(fd);
    }

    Daha sonra "value" dosyasını open fonksiyonuyla açmak gerekir. Açma işlemini "read-only" biçimde O_RDONLY bayrağıyla 
    yapabilirsiniz:

    if ((fd = open("/sys/class/gpio/gpio51/value", O_RDONLY)) == -1)
        exit_sys("open");

    Kesme işlemleri select, poll ve epoll fonksiyonlarında aygıt sürücü tarafından "exceptional" işlem olarak ele alınmıştır. 
    Dolayısıyla select fonksiyonunda bizim fonksiyonun exceptfds parametresini kullanmamız gerekir. O halde tipik bir kesme
    döngüsü şöyle oluşturulabilir:

    fd_set se;  
    ...

    if (read(fd, &buf, 1) == -1) 
        exit_sys("read");

    for (;;) {
        printf("waiting for interrupt...\n");

        FD_ZERO(&se);
        FD_SET(fd, &se);

        if (select(fd + 1, NULL, NULL, &se, NULL) == -1) 
            exit_sys("select");

        if (FD_ISSET(fd, &se)) {  
            lseek(fd, 0, SEEK_SET);     
            if (read(fd, &buf, 1) == -1) 
                exit_sys("read");
            printf("interrupt occured...\n");
        }
    }

    Burada biz tek bir pin üzerinde kesme durumunu ele aldık. Aynı işlemi birden fazla pin üzerinde de yapabilirdik. Tabii
    bu durumda FD_SET ile izlenecek tüm pinlere ilişkin betimleyicileri FD_SET makrosuyla fd_set nesnesine set etmemiz 
    gerekir. Aslında tek bir betimleyici için FD_ISSET kontrolünü yapmaya gerek yoktur. Burada bir noktaya dikkatinizi çekmek 
    istiyoruz. Aygıt sürücünün poll desteğini yazanlar blokeli bir dosya semantiği uygulamışlardır. Dolayısıyla select blokeyi 
    çözdüğü zaman eğer "value" dosyasından değer okunmazsa sonraki select çağrıları dosyada bilgi olduğu gerekçesiyle artık 
    blokeye yol açmayacaktır. Bu nedenle select fonksiyonunun blokesi çözüldükten sonra "value" dosyasının okunması gerekmektedir.  
    Yukarıdaki kodda bir ayrıntı daha vardır. Aygıt sürücüyü yazanlar işlemlere başlarken "value" dosyasında bir değer oluşmuş 
    gibi bir semantik uygulamışlardır. Eğer dosya açıldıktan sonra "value" dosyasından değer okunmazsa sanki bir kez kesme 
    oluşmuş gibi durum oluşmaktadır. Bu nedenle biz yukarıdaki kodda döngüye girmeden önce bir kez "value" dosyasını read 
    fonksiyonuyla okuduk. 

    Aşağıda uygulamanın tüm kodlarını veriyoruz. Programı Ctrl+C tuşlarına basarak sonlandırabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-intr.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/select.h>

void exit_sys(const char *msg);
void write_file(const char *path, const char *cmd);

int main(void)
{
    int fd;
    fd_set se;
    char buf;
    
    write_file("/sys/class/gpio/gpio51/direction", "in");
    write_file("/sys/class/gpio/gpio51/edge", "falling");

    if ((fd = open("/sys/class/gpio/gpio51/value", O_RDONLY)) == -1)
        exit_sys("open");
    
    if (read(fd, &buf, 1) == -1) 
        exit_sys("read");

    for (;;) {
        printf("waiting for interrupt...\n");

        FD_ZERO(&se);
        FD_SET(fd, &se);

        if (select(fd + 1, NULL, NULL, &se, NULL) == -1) 
            exit_sys("select");

        if (FD_ISSET(fd, &se)) {  
            lseek(fd, 0, SEEK_SET);     
            if (read(fd, &buf, 1) == -1) 
                exit_sys("read");
            printf("interrupt occured...\n");
        }
    }

    close(fd);      /* unreachable code */

    return 0;
}

void write_file(const char *path, const char *cmd)
{
    int fd;

    if ((fd = open(path, O_WRONLY)) == -1) 
        exit_sys("open");

    if (write(fd, cmd, strlen(cmd)) == -1)
        exit_sys("write");

    close(fd);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte akış select fonksiyonunda bloke olmaktadır. (Zaten amacımız da bunu sağlamaktır.) Ancak bu tür durumlarda 
    eğer başka birtakım işlemler de yapmak istiyorsanız yukarıdaki kod parçasını bir thread'in çalıştırmasını sağlamalısınız.
    Aşağıda böyle bir örnek verdik. Programı Ctrl+C tuşlarına basarak sonlandırabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-intr.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/select.h>
#include <pthread.h>

void exit_sys(const char *msg);
void exit_sys_err(const char *msg, int err);

void write_file(const char *path, const char *cmd);
void *thread_proc(void *param);

int main(void)
{
    int fd;
    pthread_t tid;
    int result;
    
    write_file("/sys/class/gpio/gpio51/direction", "in");
    write_file("/sys/class/gpio/gpio51/edge", "falling");

    if ((fd = open("/sys/class/gpio/gpio51/value", O_RDONLY)) == -1)
        exit_sys("open");
    
    if ((result = pthread_create(&tid, NULL, thread_proc, (void *)fd)) != 0) 
        exit_sys_err("pthread_create", result);

    for (;;) {
        printf("main thread running...\n");
        sleep(1);
    }

    close(fd);  /* unreachable code */

    return 0;
}

void write_file(const char *path, const char *cmd)
{
    int fd;

    if ((fd = open(path, O_WRONLY)) == -1) 
        exit_sys("open");

    if (write(fd, cmd, strlen(cmd)) == -1)
        exit_sys("write");

    close(fd);
}

void *thread_proc(void *param)
{
    int fd = (int)param;
    fd_set se;
    char buf;

    if (read(fd, &buf, 1) == -1) 
        exit_sys("read");

    for (;;) {
        printf("waiting for interrupt...\n");

        FD_ZERO(&se);
        FD_SET(fd, &se);

        if (select(fd + 1, NULL, NULL, &se, NULL) == -1) 
            exit_sys("select");

        if (FD_ISSET(fd, &se)) {  
            lseek(fd, 0, SEEK_SET);     
            if (read(fd, &buf, 1) == -1) 
                exit_sys("read");
            printf("interrupt occured...\n");
        }
    }
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_err(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                            132. Ders 07/10/2025 - Salı
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de kesme olaylarını select yerine poll fonksiyonu ile ele alan bir örnek yapalım. Yukarıda da belirttiğimiz gibi
    GPIO uçlarında kesme olduğunda bu olay poll fonksiyonunda POLLPRI biçiminde ortaya çıkmaktadır. Programın poll çağrısını
    yapan kısmı şöyledir:

    if (read(fd, &buf, 1) == -1) 
        exit_sys("read");

    pollfds[0].fd = fd;
    pollfds[0].events = POLLPRI;

    for (;;) {
        printf("waiting for interrupt...\n");
        if (poll(pollfds, 1, -1) == -1) 
            exit_sys("poll");
        
        if (pollfds[0].revents & POLLPRI) {
            if (read(fd, &buf, 1) == -1) 
                exit_sys("read");
            printf("interrupt occured...\n");
        }
    }

    poll fonksiyonun ayrıntıları için "UNIX/Linux Sistem Programlama Kursunun" dokümanlarını inceleyebilirsiniz. Aşağıda 
    örneği bir bütün olarak veriyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-intr.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/poll.h>

void exit_sys(const char *msg);
void write_file(const char *path, const char *cmd);

int main(void)
{
    int fd;
    unsigned char buf;
    struct pollfd pollfds[1];
    
    write_file("/sys/class/gpio/gpio51/direction", "in");
    write_file("/sys/class/gpio/gpio51/edge", "falling");

    if ((fd = open("/sys/class/gpio/gpio51/value", O_RDONLY)) == -1)
        exit_sys("open");
    
    if (read(fd, &buf, 1) == -1) 
        exit_sys("read");

    pollfds[0].fd = fd;
    pollfds[0].events = POLLPRI;

    for (;;) {
        printf("waiting for interrupt...\n");
        if (poll(pollfds, 1, -1) == -1) 
            exit_sys("poll");
        
        if (pollfds[0].revents & POLLPRI) {
            if (read(fd, &buf, 1) == -1) 
                exit_sys("read");
            printf("interrupt occured...\n");
        }
    }

    close(fd);  /* unreachable code */

    return 0;
}

void write_file(const char *path, const char *cmd)
{
    int fd;

    if ((fd = open(path, O_WRONLY)) == -1) 
        exit_sys("open");

    if (write(fd, cmd, strlen(cmd)) == -1)
        exit_sys("write");

    close(fd);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    GPIO pinleri üzerinde işlem yapmanın diğer bir yolu da "gpiod" isimli kütüphaneyi kullanmaktır. Bu kütüphane artık bu 
    konuda en yaygın kullanılan kütüphane haline gelmiştir. Kütüphane "sysfs" dosya sistemini değil doğrudan çekirdeğe gömülmüş 
    olan "gpiochip" aygıt sürücüsünü kullanmaktadır. Yani bu kütüphane aslında arka planda bu aygıt sürücüyü açıp aygıt 
    sürücüye ioctl komutlarını göndermektedir. "gpiod" yüksek seviyeli bir kütüphanedir. Ancak gpiod kütüphanesinin bir 
    süredir 2'li yeni versiyonları oluşturulmuştur. Fakat bu versiyonlar yerine default kurulumda hala 1'li versiyonlar 
    kurulmaktadır. Maalesef 2'li versiyonlarla 1'li versiyonlar arasında bir API uyumu da yoktur. Çünkü kütüphanenin ikili 
    versiyonlarında işlemlerin akışı da değiştirilmiştir. Biz burada kütüphanenin halen default olarak kullanılan 1'li 
    versiyonlarını ele alacağız. Ancak 2'li versiyonlarındaki farklılıklar üzerinde de kısaca duracağız. 

    Kütüphanenin 1'li versiyonlarının dokümantasyonuna PDF dosyası olarak aşağıdaki bağlantıdan erişebilirsiniz: 
    
    http://phwl.org/assets/images/2021/02/libgpiod-ref.pdf
    
    Kütüphanenin 2'li versiyonlarının dokümantasyonuna da aşağıdaki bağlantıdan erişebilirsiniz:

    https://libgpiod.readthedocs.io/en/latest/

    Kütüphane default durumda yüklü değildir. Kütüphaneyi Debian tabanlı sistemlerde aşağıdaki gibi yükleyebilirsiniz:

    $ sudo apt install libgpiod-dev

    Yukarıda da belirttiğimiz gibi bu default yüklemede kütüphanenin 1'li versiyonu (1.6.3 versiyonu) yüklenmektedir. 

    gpiod kütüphanesini kullanan bir grup komut satırından çalışan utility programlar da vardır. Bu programlar sayesinde 
    tıpkı sysfs arayüzünde yaptığımız gibi komut satırından temel test işlemlerini yapabilirsiniz. Sözünü ettiğimiz bu 
    utility programları da aşağıdaki gibi kurabilirsiniz:

    $ sudo apt install gpiod

    Yukarıdaki kurulumları ARM işlemcili gömülü sisteminize yaparsanız ve kodu o sistemde derlerseniz bir sorun oluşmaz. Bu 
    kütüphaneyi ve utility programları Intel tabanlı bilgisayarlarınızdaki Linux sistemlerine kurmanızın uç bazı durumlar 
    dışında bir anlamı yoktur. 

    Biz BBB gibi bir ortam için geliştirmeyi genel olarak Intel tabanlı masaüstü Linux sistemlerindeki çapraz derleyicileri 
    kullanarak yapmaktayız. Ancak çapraz derleyicilerimizde gpiod kütüphanesi bulunmamaktadır. O zaman bizim bu kütüphanenin
    kaynak kodlarını indirip ARM çapraz derleyicimize ilişkin araç zincirini kullanarak kütüphaneyi host makinede derlemek gerekir. 
    (Maalesef bu kütüphanelerin ARM için derlenmiş binary dosyaları yoktur.) 

    gpiod kütüphanesini çapraz derleyici ile derleme işlemi şu adımlardan geçilerek yapılabilir:

    1) Kütüphanenin kaynak kodları indirilir. İndirme işlemini wget komutuyla aşağıdaki gibi yapabilirsiniz:

    $ wget https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git/snapshot/libgpiod-1.6.3.tar.gz

    Buradan kaynak kodlar tar.gz formatında indirilmektedir. Açımı şöyle yapabilirziniz:

    $ tar -xzf libgpiod-1.6.3.tar.gz

    Artık kaynak kodlar "libgpiod-1.6.3" isimli bir dizine açılmıştır. 

    2) Derleme için host makinede bazı programların da bulunuyor olması gerekir. Bunların bazıları zaten sisteminizde muhtemelen 
    yüklü olacaktır. Ancak aşağıdaki komutla yüklü olmayan programları da yükleyebilirsiniz:

    3) sudo apt-get install -y autoconf-archive autoconf automake libtool pkg-config build-essential autotools-dev build-essential

    4) Çapraz derleyici ayarlarını yapmamız gerekir:

    $ PATH=$PATH:/home/kaan/Study/EmbeddedLinux/DriverDevelopment/BBB/gcc-arm-9.2-2019.12-x86_64-arm-none-linux-gnueabihf/bin
    $ export ARCH=arm
    $ export CC=arm-none-linux-gnueabihf-gcc

    Derleme işlemi için kaynak kod dizinine geçilip "autogen.sh" dosyası aşağıdaki komut satırı argümanlarıyla çalıştırılır:

    ./autogen.sh --host=arm-linux-gnueabihf --enable-tools=no --enable-bindings-cxx=no --prefix=/usr

    Bu program Makefile oluşturmaktadır. Makefile dosyası içerisinde derleyici $CC komutuyla çalıştırılmaktadır. 

    5) "autogen.sh" tarafından oluşturulan Makefile dosyası "make" programıyle işletilir:

    $ make

    6) Artık derleme sonrasında ARM işlemcileri için statik ve dinamik kütüphane dosyaları oluşturulmuştur. Bu dosyaların ve
    include dosyalarının araç zincirinin ilgili dizinlerine çekilmesi gerekir. Bu işlemler manuel olarak yapılabilir. Ancak 
    bu işlemleri kolaylaştırmak için "make install" komutu da bulundurulmuştur. Komutu şöyle kullanabilirsiniz:

    $ make install DESTDIR=$($CC --print-sysroot)

    Burada $($CC --print-sysroot) işlemi çapraz araç zincirinde ilgili dosyaların çekileceği kök dizini elde etmek için 
    kullanılmıştır. --print-sysroot masaüstü gcc derleyicilerinde bir çıktı vermemektedir. Bu seçenek çapraz derleyiciler 
    için kütüphanelerin ve include dosyalarının konuşlandırılacağı yerin kök dizinini vermektedir. 

    7) Artık uygulama programımızın derlenmesi işlemi çapraz derleyici ile aşağıdaki gibi yapılabilir:

    $ $CC -o gpiod-sample gpiod-sample.c -lgpiod

    Elde edilen çalıştırılabilir dosya BBB'ye kopyalanabilir.

    Burada bir noktaya dikkatinizi çekmek istiyoruz. Daha önceden de belirttiğimiz gibi gpiod kütüphanesi aslında "/dev/gpiochipN"
    aygıt dosyalarını kullanmaktadır. Bu aygıt dosyalarının erişim haklarına dikkat ediniz:

    crw-rw---- 1 root gpio 254, 0 Feb  4 22:05 /dev/gpiochip0
    crw-rw---- 1 root gpio 254, 1 Feb  4 22:05 /dev/gpiochip1
    crw-rw---- 1 root gpio 254, 2 Feb  4 22:05 /dev/gpiochip2
    crw-rw---- 1 root gpio 254, 3 Feb  4 22:05 /dev/gpiochip3

    Burada dosyanın sahibinin "root" olduğu ve grubunun da "gpio" olduğunu görüyorsunuz. Linux'un BBB için oluşturulmuş 
    orijinal imajındaki "debian" kullanıcısı "ek grup (supplementary groups)" olarak "gpio" grubunu da içermektedir. Yani 
    bu "debian" kullanıcısı aynı zamanda sanki "gpio" grubundaymış gibi de davranmaktadır. Dolayısıyla bizim bu aygıt 
    sürücü dosyalarını açıp, okuma yazma yapmak için sudo kullanmamıza gerek kalmamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                    133. Ders 09/10/2025 - Perşembe
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Burada önce gpiod kütüphanesinin utility programlarından da kısaca bahsetmek istiyoruz. 

    - gpiodetect isimli program GPIO aygıt sürücülerinin listesini bize vermektedir. Örneğin:

    $ gpiodetect
    gpiochip0 [gpio-0-31] (32 lines)
    gpiochip1 [gpio-32-63] (32 lines)
    gpiochip2 [gpio-64-95] (32 lines)
    gpiochip3 [gpio-96-127] (32 lines)

    - Kütüphanede pin yerine "hat (line)" sözcüğü kullanılmıştır. Belli bir GPIO aygıtındaki hatlar hakkında bilgiler şöyle
    edinilebilir:

    $ gpioinfo gpiochip0
    gpiochip0 - 32 lines:
        line   0: "[mdio_data]" unused input active-high 
        line   1: "[mdio_clk]"       unused   input  active-high 
        line   2: "P9_22 [spi0_sclk]" "P9_22" input active-high [used]
        line   3: "P9_21 [spi0_d0]" "P9_21" input active-high [used]
        line   4: "P9_18 [spi0_d1]" "P9_18" input active-high [used]
        line   5: "P9_17 [spi0_cs0]" "P9_17" input active-high [used]
        line   6:  "[mmc0_cd]"         "cd"   input   active-low [used]
        line   7: "P8_42A [ecappwm0]" "P9_42" input active-high [used]
        line   8: "P8_35 [lcd d12]" "P8_35" input active-high [used]
        line   9: "P8_33 [lcd d13]" "P8_33" input active-high [used]
        line  10: "P8_31 [lcd d14]" "P8_31" input active-high [used]
        line  11: "P8_32 [lcd d15]" "P8_32" input active-high [used]
        line  12: "P9_20 [i2c2_sda]" "P9_20" input active-high [used]
        line  13: "P9_19 [i2c2_scl]" "P9_19" input active-high [used]
        line  14: "P9_26 [uart1_rxd]" "P9_26" input active-high [used]
        line  15: "P9_24 [uart1_txd]" "P9_24" input active-high [used]
        line  16: "[rmii1_txd3]" unused input active-high 
        line  17: "[rmii1_txd2]" unused input active-high 
        line  18: "[usb0_drvvbus]" unused input active-high 
        line  19: "[hdmi cec]"       unused   input  active-high 
        line  20:     "P9_41B"      "P9_41"   input  active-high [used]
        line  21: "[rmii1_txd1]" unused input active-high 
        line  22: "P8_19 [ehrpwm2a]" "P8_19" input active-high [used]
        line  23: "P8_13 [ehrpwm2b]" "P8_13" input active-high [used]
        line  24:         "NC"       unused   input  active-high 
        line  25:         "NC"       unused   input  active-high 
        line  26:      "P8_14"      "P8_14"   input  active-high [used]
        line  27:      "P8_17"      "P8_17"   input  active-high [used]
        line  28: "[rmii1_txd0]" unused input active-high 
        line  29: "[rmii1_refclk]" unused input active-high 
        line  30: "P9_11 [uart4_rxd]" "P9_11" input active-high [used]
        line  31: "P9_13 [uart4_txd]" "P9_13" input active-high [used]

    Burada [used] belirteci ilgili GPIO ucunun pine bağlandığı anlamına gelmektedir. 

    - Belli bir pini (gpiod terminolojisi ile "hattı") çıkış olarak konfigüre etmek ve ilgili pini lojik 1 ya da lojik 0 
    seviyesine çekmek için "gpioset" komutu kullanılmaktadır. Komutun birinci parametresi gpio chip'inin ismini (yani "/dev" 
    dizinindeki aygıt sürücü ismini) almaktadır. Bunu "<numara>=1" ya da "<numara>=0" argümanları izler. Bu argümanlar birden 
    fazla girilebilmektedir. Buradaki <numara> daha önce görmüş olduğumuz GPIOX_Y SoC numaralandırmasındaki Y değeridir. 
    Örneğin biz LED'imizi GPIO1_28 SoC numarasına ilişkin pine bağlamıştık. Ancak gpioset programı sonlanırken ilgili pini 
    default duruma çekmektedir. Dolayısıyla örneğin bu programla bir LED'i yakmak istiyorsanız programın hemen sonlanmaması 
    gerekir. Bunu yapmanın tipik iki yolu vardır. Eğer --mode=wait kullanılırsa klavyeden CTRL+D (EOF) tuşlarına basılana 
    kadar program sonlanmaz. Eğer --mode=signal kullanılırsa bu durumda ancak bir sinyal oluştuğunda program sonlandırılır. 
    Tabii buradaki tipik sinyal Ctrl+C tuşlarıyla oluşturulan SIGINT sinyalidir. Örneğin GPIO60 (yani GPIO1_28) pinini OUT 
    olarak konfigüre edip onu lojik 1 seviyesine şöyle çekebiliriz:

    $ gpioset --mode=wait gpiochip1 28=1

    "gpioset" komutu her zaman ilgili pini önce OUT olarak konfigüre eder sonra da onu lojik 1 ya da lojik 0 düzeyine çeker. 
    
    Peki biz gpioset komutunu kullanarak LED'i 1 saniye yakıp bir saniye söndürmek istesek ve bunu bir döngü içerisinde 
    yapmak istesek bunu nasıl yapabiliriz? Bunun için --mode=time komut satırı argümanı ile -s <saniye_sayısı> ya da 
    --sec <saniye_sayısı> argümanının birlikte kullanılması gerekir. Örneğin:

    $ gpioset --mode=time --sec 1 gpiochip1 28=1

    Beklemeyi milisaniye cinsinden belirtmek için --usec <milisaniye_sayısı> argümanı kullanılmaktadır.

    Burada artık program 1 saniye sonra sonlanacaktır. 
    
    Aslında aynı işlemler timeout isimli kabuk komutuyla da yapılabilir. 
    Bu komut şöyle kullanılmaktadır:

    timeout <süre> <komut> [argümanlar...]

    Örneğin:

    timeout 1 gpioset --mode=wait gpiochip1 28=1

    Burada 1 saniye ilgili pin lojik 1 seviyesine çekilecektir. timeout programı default olarak çalıştırdığı programa SIGTERM 
    sinyalini göndermektedir. Başka sinyal göndermek isteniyorsa --signal=sinyal_numarası biçiminde komut satırı argümanı 
    kullanılmalıdır. 

    Tabii bu işlemlerin bir "kabuk betiği (shell script)" ile bir döngü içerisinde aşağıdaki gibi yapılması gerekir:

    #!/bin/bash
    while true; do
        gpioset --mode=time --sec 1 gpiochip1 28=1
        gpioset --mode=time --sec 1 gpiochip1 28=0
    done
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    - "gpioget" komutu ilgili pini IN biçiminde konfigüre edip o pindeki işareti okumaktadır. Komutun argümanları şöyledir:

    gpioget aygıt_ismi   pin_numarası
    
    Örneğin biz düğmemizi GPIO1_19 (GPIO51) pinine bağlamıştık. Bu pini IN durumuna çekip okuduğumuzda düğmeye basılmamışsa 1, 
    basılmışsa 0 okuduğumuzu anımsayınız. O halde okumayı şöyle yapabiliriz:

    $ gpioget gpiochip1 19

    - Belli pinlerdeki olayları izlemek için "gpiomon" komutu kullanılmaktadır. Bu komut ilgili pinleri kesme moduna sokar 
    ve ilgili olay olana kadar bekleme yapar. Kesmeyi çıkan kenar olarak konfigüre edip izlemek için --rising-edge argümanı, düşen
    kenar olarak konfigüre edip izlemek için --falling-edge argümanı kullanılmaktadır. Örneğin amacımız GPIO1_19 (GPIO51) 
    pinine basıldığında bunun anlaşılması olsun. Bizim devremizde bu uçtan default olarak lojik 1 okunuyordu. Biz düğmeye
    bastığımızda "düşen kenar tetiklemeli kesme" oluşacaktır. Bu izleme şöyle yapılabilir:

    $ gpiomon --falling-edge gpiochip1 19

    Bu komutla program sonsuz döngü oluşturacaktır. Her düğmeye bastığımızda oluşan kesmeyi yakalıp ekrana mesaj çıkartacaktır. 
    Sonsuz döngüden çıkmak için Ctrl+C tuşlarını kullanabilirsiniz. 
    
    Yukarıda açıkladığımız utility programların aslında bazı kullanım ayrıntıları da vardır. Bunları ilgili dokümanlardan 
    inceleyebilirsiniz. Ancak bu programlar kütüphane 2 versiyonları ile daha fazla komut argümanına sahip olmuştur. Bulduğunuz
    örneklerdeki komut satırı argümanlarının kendi makinenizde çalışmadığını görürseniz şaşırmayınız. 

    "gpiod" utility programları sysfs arayüzü ile uyumsuzluk oluşturabilmektedir. Bu komutları çalıştırdığınızda ilgili 
    pinin "/sys/class/gpio" dizininin silindiğini görürseniz şaşırmayınız. Bu durumda makineyi reset etmeden ilgili pin 
    dosyasını aşağıdaki gibi yeniden export edebilirsiniz:

    $ echo 60 | sudo tee /sys/class/gpio/export

    Bu örnek komut GPIO60 pinini yeniden export ederek dosya sisteminde görünür hale getirmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda "gpiod" kütüphanesinin komut satırından kullanılan utility programlarını (komutlarını da diyebiliriz) ele 
    aldık. Şimdi kütüphanenin C içerisinden nasıl kullanılacağı üzerinde duralım. Kütüphanedeki tüm fonksiyonların prototipleri, 
    sembolik sabitler ve yapı bildirimleri <gpiod.h> dosyası içerisindedir. Bu dosyayı programınızda include etmelisiniz. 
    Ayrıca kütüphanenin link aşamasında devreye girmesi için komut satırında -lgpiod seçeneğini kullanmayı unutmayınız. Örneğin:

    $ gcc -Wall -o gpio-sample gpio-sample.c -lgpiod
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    gpiod kütüphanesinin arka planda aslında "/dev/gpiochipN" aygıt dosyalarını açıp onlara ioctl komutlarını göndererek 
    yazılmış olduğunu belirtmiştik. Bu kütüphanede ilk yapılacak işlem ilgili GPIO chip'ini kütüphanedeki fonksiyonları 
    kullanarak açmaktır. Bunun için gpiod_chip_open_by_name fonksiyonu kullanılabilir. Bu fonksiyonun prototipi şöyledir:

    #include <gpiod.h>

    struct gpiod_chip *gpiod_chip_open_by_name(const char *name);

    Fonksiyon GPIO chip aygıt sürücüsünün ismini (yol ifadesini değil) alır. Başarı durumunda gpiod_chip yapısı türünden 
    bir nesnenin adresiyle geri döner. Bu nesne GPIO chip aygıt sürücüsü için bir handle niteliğindedir. Fonksiyon başarısızsa
    NULL adrese geri dönmektedir. Hata durumunda errno değişkeni set edilmektedir. Dolayısıyla hatanın nedenini perror 
    fonksiyonuyla yazdırabilirsiniz. Örneğin:

    struct gpiod_chip *chip;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
        
    İlgili chip aygıt sürücüsünü açmak için gpiod_chip_open_by_number fonksiyonu kullanılabilir. Bu fonksiyon yalnızca numara 
    almaktadır. (Örneğin bu fonksiyona 0 girilirse by "gpiochip0" anlamına gelmektedir.) gpiod_chip_open fonksiyonu ise aygıt
    sürücünün tam yol ifadesini almaktadır. Örneğin bu fonksiyona "/dev/gpiochipo" yol ifadesini girebiliriz. 

    Biz bu bölümde gpiod_chip nesnesine kısaca "chip nesnesi" de diyeceğiz. 

    Açılan bir chip aygıt sürücüsü gpiod_chip_close fonksiyonu ile kaynaklar serbest bırakılarak kapatılabilir. Fonksiyonun 
    prototipi şöyledir:

    #include <gpiod.h>

    void gpiod_chip_close(struct gpiod_chip *chip);

    Fonksiyon gpiod_chip nesnesinin adresini almaktadır. Örneğin:

    gpiod_chip_close(chip);

    Chip aygıt sürücüsünü açtıktan sonra üzerinde çalışacağımız pine ilişkin gpiod_line nesnesinin elde edilmesi gerekmektedir. 
    Bu işlem gpiod_chip_get_line fonksiyonuyla yapılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <gpiod.h>

    struct gpiod_line *gpiod_chip_get_line(struct gpiod_chip *chip, unsigned int offset);

    Fonksiyonun birinci parametresi chip nesnesinin adresini, ikinci parametresi ise o chip'teki pinin numarasını belirtmektedir. 
    Fonksiyon başarı durumunda gpiod_line isimli bir yapı türünden nesnenin adresine, başarısızlık durumunda ise NULL adrese 
    geri dönmektedir. Örneğin:

    struct gpiod_chip *chip;
    struct gpiod_line *line;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 28)) == NULL)
        exit_sys("gpiod_chip_get_line");

    Biz bu bölümde gpiod_line nesnesine hat nesnesi diyeceğiz. Anımsanacağı gibi bu kütüphanenin terminolojisinde "pin" yerine "hat 
    (line)" denilmektedir.)

    Açılan pinin  kapatılması için de gpiod_line_release fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir.

    #include <gpiod.h>

    int gpiod_line_release(struct gpiod_line *line);

    Fonksiyon hat nesnesinin adresini parametre olarak alır. Başarı durumunda 0 değerine başarısızlık durumunda -1 değerine 
    geri döner. Örneğin:

    struct gpiod_chip *chip;
    struct gpiod_line *line;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 28)) == NULL)
        exit_sys("gpiod_chip_get_line");

    printf("success...\n");

    gpiod_line_release(line);
    gpiod_chip_close(chip);

    İlgili GPIO pinini elde ettikten sonra onu IN ya da OUT biçiminde konfigüre etmek gerekir. Belli bir pin'i OUT olarak 
    konfigüre etmek için gpiod_line_request_output fonksiyonuyla yapılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <gpiod.h>

    int gpiod_line_request_output(struct gpiod_line *line, const char *consumer, int default_val);

    Fonksiyonun birinci parametresi hat nesnesinin adresini almaktadır. İkinci parametresi ise pin'i kullanan program 
    tarafından belirlenen bir ismi belirtmektedir.  Üçüncü parametre pine gönderilecek ilk işareti belirtir. Bu parametre 
    0 ya da 1 olabilir. Fonksiyon başarı durumunda 0, başarısızlık durumunda -1 değerine geri dönmektedir. Örneğin:

    struct gpiod_chip *chip;
    struct gpiod_line *line;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 28)) == NULL)
        exit_sys("gpiod_chip_get_line");

     if (gpiod_line_request_output(line, "myapp", 1) == -1)
        exit_sys("gpiod_line_request_output");

    printf("Press ENTER to exit...\n");
    getchar();

    gpiod_line_release(line);
    gpiod_chip_close(chip);

    Burada  LED'i bağladığımız pin'e 3.3V gönderdik. Dolayısıyla program sonlanana kadar LED'imiz yanacaktır. Peki biz 
    saniyede bir yanıp sönen LED uygulaması için döngü içerisinde her defasında gpiod_line_request_output fonksiyonunu mu 
    çağırmalıyız? Hayır, artık elimizde hat nesnesi varsa doğrudan ilgili pin'e lojik 0 ya da lojik 1 işaretini 
    gpiod_line_set_value fonksiyonuyla gönderebiliriz. Fonksiyonun prototipi şöyledir:

    #include <gpiod.h>

    int gpiod_line_set_value(struct gpiod_line *line, int value);

    Fonksiyonun birinci parametresi hat nesnesinin adresini, ikinci parametresi lojik işareti almaktadır. İkinci parametre 
    için girilecek değer 1 ya da 0 olabilir. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine
    geri dönmektedir. Örneğin:

    struct gpiod_chip *chip;
    struct gpiod_line *line;
    int out;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 28)) == NULL)
        exit_sys("gpiod_chip_get_line");
   
    if (gpiod_line_request_output(line, "myapp", 0) == -1)
        exit_sys("gpiod_line_request_output");

    out = 1;
    for (int i = 0; i < 30; ++i) {
        if (gpiod_line_set_value(line, out) == -1)
            exit_sys("gpiod_line_set_value");
        out = !out;
        sleep(1);
    }

    gpiod_line_release(line);
    gpiod_chip_close(chip);
---------------------------------------------------------------------------------------------------------------------------*/

/* gpiod-sample.c */

#include <stdio.h>
#include <unistd.h>
#include <gpiod.h>

void exit_sys(const char *msg);

int main(void)
{
    struct gpiod_chip *chip;
    struct gpiod_line *line;
    int out;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 28)) == NULL)
        exit_sys("gpiod_chip_get_line");
    
    if (gpiod_line_request_output(line, "myapp", 0) == -1)
        exit_sys("gpiod_line_request_output");

    out = 1;
    for (int i = 0; i < 30; ++i) {
        if (gpiod_line_set_value(line, out) == -1)
            exit_sys("gpiod_line_set_value");
        out = !out;
        sleep(1);
    }

    gpiod_line_release(line);
    gpiod_chip_close(chip);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                        134. Ders 14/10/2025 - Salı
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Belli bir hattı (yani pin'i) IN olarak konfigüre etmek için gpiod_line_request_input fonksiyonu kullanılmaktadır. Fonksiyonun
    prototipi şöyledir:

    #include <gpiod.h>

    int gpiod_line_request_input(struct gpiod_line *line, const char *consumer);

    Fonksiyonun birinci parametresi GPIO hattına ilişkin gpiod_line nesnesinin adresini almaktadır. İkinci parametre uygulamayı
    betimleyen herhangi bir isim olarak girilebilmektedir. Fonksiyon başarı durumunda 0, başarısızlık durumunda -1 değerine 
    geri dönmektedir. Belli bir hattı giriş olarak konfigüre ettikten sonra artık o hattan okuma yapılabilir. Bunun için 
    gpiod_line_get_value fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <gpiod.h>

    int gpiod_line_get_value(struct gpiod_line *line);

    Fonksiyon hat nesnesinin adresini parametre olarak alır ve hattaki giriş işaretini geri dönüş değeri olarak verir. Hata 
    durumunda fonksiyon -1 değerine geri dönmektedir. Örneğin:

    struct gpiod_chip *chip;
    struct gpiod_line *line;
    int result;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 19)) == NULL)
        exit_sys("gpiod_chip_get_line");
    
    if (gpiod_line_request_input(line, "myapp") == -1)
        exit_sys("gpiod_line_request_input");

    for (int i = 0; i < 10; ++i) {
        if ((result = gpiod_line_get_value(line)) == -1)
            exit_sys("gpiod_line_get_value");
        printf("%d\n", result);
        sleep(1);
    }

    gpiod_line_release(line);
    gpiod_chip_close(chip);

    Aşağıda programın tamamını veriyoruz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* gpiod-sample.c */

#include <stdio.h>
#include <unistd.h>
#include <gpiod.h>

void exit_sys(const char *msg);

int main(void)
{
    struct gpiod_chip *chip;
    struct gpiod_line *line;
    int result;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 19)) == NULL)
        exit_sys("gpiod_chip_get_line");
    
    if (gpiod_line_request_input(line, "myapp") == -1)
        exit_sys("gpiod_line_request_input");

    for (int i = 0; i < 10; ++i) {
        if ((result = gpiod_line_get_value(line)) == -1)
            exit_sys("gpiod_line_get_value");
        printf("%d\n", result);
        sleep(1);
    }

    gpiod_line_release(line);
    gpiod_chip_close(chip);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Tek hamlede birden fazla hattın değerini okumak ya da birden fazla hatta değişik değerleri tek hamlede yazmak isteyebiliriz. 
    Bu işlemlere gpiod kütüphanesinde "bulk işlemler" denilmektedir. Birden fazla hatta ilişkin gpiod_line nesnelerinin adreslerini 
    tutan gpiod_line_bulk isimli bir yapı vardır. Bu yapı şöyle bildirilmiştir:

    struct gpiod_line_bulk {
        unsigned int num_lines;
        struct gpiod_line *lines[GPIOD_LINE_BULK_MAX_LINES];
    };

    Birden fazla hattı almak için gpiod_chip_get_lines fonksiyonu kullanılmaktadır. Bu fonksiyonun prototipi şöyledir.

    #include <gpiod.h>

    int gpiod_chip_get_lines(struct gpiod_chip *chip, unsigned int *offsets, unsigned int num_offsets, struct gpiod_line_bulk *bulk);

    Fonksiyonun birinci parametresi gpiod_chip nesnesinin adresini, ikinci parametresi alınacak hatlara ilişkin numaraları, 
    üçüncü parametre ise ikinci parametrede belirtilen dizinin uzunluğunu belirtmektedir. Fonksiyon başarı durumunda 0 değerine, 
    başarısızlık durumunda -1 değerine geri dönmektedir. Burada elde edilen gpiod_line_bulk nesnesi gpiod_line_release_bulk 
    fonksiyonu ile serbest bırakılmaktadır. Bu fonksiyonun prototipi de şöyledir:

    void gpiod_line_release_bulk(struct gpiod_line_bulk *bulk);

    Fonksiyon gpiod_line_bulk nesnesini parametre olarak alıp oluşturduğu alanı serbest bırakır. Örneğin:

    struct gpiod_chip *chip;
    unsigned int offsets[] = {4, 17, 27};
    struct gpiod_line_bulk lb;

    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");

    if (gpiod_chip_get_lines(chip, offsets, 3, &lb) == -1)
        exit_sys("gpiod_chip_get_lines");
    
    /* ... */

    gpiod_line_release_bulk(&lb);

    Birden fazla hattı OUT olarak konfigüre etmek için gpiod_line_request_bulk_output fonksiyonu IN olarak konfigüre etmek 
    için gpiod_line_request_bulk_input fonksiyonu kullanılmaktadır. Bu fonksiyonların prototipileri şöyledir:

    #include <gpiod.h>

    int gpiod_line_request_bulk_output(struct gpiod_line_bulk *bulk, const char *consumer, const int *default_vals);
    int gpiod_line_request_bulk_input(struct gpiod_line_bulk *bulk, const char *consumer);

    birinci parametreleri gpiod_line_bulk nesnesinin adresini, ikinci parametreleri programcının vereceği uygulama ismini 
    almaktadır. default_vals parametresi OUT olarak konfigüre ederken verilecek ilk değerleri belirtir. Fonksiyonlar başarı 
    durumunda 0, başarısızlık durumunda -1 değerine geri dönmektedir. Örneğin:

    struct gpiod_chip *chip;
    unsigned int offsets[] = {4, 17, 27};
    unsigned int initial_values[] = {0, 0, 0};
    struct gpiod_line_bulk *lb;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if (gpiod_chip_get_lines(chip, offsets, 3, &lb) == -1)
        exit_sys("gpiod_chip_get_lines");

    if (gpiod_line_request_bulk_output(&lb, "myapp", initial_values) == -1)
        exit_sys("gpiod_line_request_bulk_output");

    /* ... */

    gpiod_line_release_bulk(&lb);
    gpiod_chip_close(chip);
    
    Birden fazla hattı tek hamlede set etmek için gpiod_line_set_value_bulk fonksiyonu kullanılmaktadır. Fonksiyonun prototipi 
    şöyledir:

    int gpiod_line_set_value_bulk(struct gpiod_line_bulk *bulk, const int *values);

    Fonksiyonun birinci parametresi gpiod_line_bulk nesnesinin adresini, ikinci parametresi hatlara set edilecek değerleri 
    almaktadır. Fonksiyon başarı durumunda 0 başarısızlık durumunda -1 değerine geri dönmektedir. Örneğin:

    struct gpiod_chip *chip;
    unsigned int offsets[] = {4, 19, 28};
    int initial_values[] = {0, 0, 0};
    int values[3];
    struct gpiod_line_bulk lb;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if (gpiod_chip_get_lines(chip, offsets, 3, &lb) == -1)
        exit_sys("gpiod_chip_get_lines");

    if (gpiod_line_request_bulk_output(&lb, "myapp", initial_values) == -1)
        exit_sys("gpiod_line_request_bulk_output");

    for (int i = 0; i < 10; ++i) {
        values[0] = 1;
        values[1] = 1;
        values[2] = 1;

        if (gpiod_line_set_value_bulk(&lb, values) == -1)
            exit_sys("gpiod_line_set_value_bulk");

        sleep(1);

        values[0] = 0;
        values[1] = 0;
        values[2] = 0;

        if (gpiod_line_set_value_bulk(&lb, values) == -1)
            exit_sys("gpiod_line_set_value_bulk");

        sleep(1);
    }

    gpiod_line_release_bulk(&lb);
    gpiod_chip_close(chip);

    Aşağıda örnek bir bütün olarak verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* gpiod-sample.c */

#include <stdio.h>
#include <unistd.h>
#include <gpiod.h>

void exit_sys(const char *msg);

int main(void)
{
    struct gpiod_chip *chip;
    unsigned int offsets[] = {4, 19, 28};
    int initial_values[] = {0, 0, 0};
    int values[3];
    struct gpiod_line_bulk lb;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if (gpiod_chip_get_lines(chip, offsets, 3, &lb) == -1)
        exit_sys("gpiod_chip_get_lines");

    if (gpiod_line_request_bulk_output(&lb, "myapp", initial_values) == -1)
        exit_sys("gpiod_line_request_bulk_output");

    for (int i = 0; i < 10; ++i) {
        values[0] = 1;
        values[1] = 1;
        values[2] = 1;

        if (gpiod_line_set_value_bulk(&lb, values) == -1)
            exit_sys("gpiod_line_set_value_bulk");

        sleep(1);

        values[0] = 0;
        values[1] = 0;
        values[2] = 0;

        if (gpiod_line_set_value_bulk(&lb, values) == -1)
            exit_sys("gpiod_line_set_value_bulk");

        sleep(1);
    }

    gpiod_line_release_bulk(&lb);
    gpiod_chip_close(chip);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Aynı anda birden fazla hattın değerini okumak için de gpiod_line_get_value_bulk fonksiyonu kullanılmaktadır. Fonksiyonun
    prototipi şöyledir:

   int gpiod_line_get_value_bulk(struct gpiod_line_bulk *bulk, int *values);

   Fonksiyonun birinci parametresi gpiod_line_bulk nesnesinin adresini, ikinci parametresi hatlardan okunan değerlerin 
   yerleştirileceği int dizinin adresi belirtmektedir. Örneğin:

    struct gpiod_chip *chip;
    unsigned int offsets[] = {4, 19, 28};
    int values[3];
    struct gpiod_line_bulk lb;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if (gpiod_chip_get_lines(chip, offsets, 3, &lb) == -1)
        exit_sys("gpiod_chip_get_lines");

    if (gpiod_line_request_bulk_input(&lb, "myapp") == -1)
        exit_sys("gpiod_line_request_bulk_output");

    for (int i = 0; i < 10; ++i) {
        if (gpiod_line_get_value_bulk(&lb, values) == -1)
            exit_sys("gpiod_line_set_value_bulk");
        for (int k = 0; k < 3; ++k)
            printf("line %d: %d\n", offsets[k], values[k]);
        sleep(1);
    }

    gpiod_line_release_bulk(&lb);
    gpiod_chip_close(chip);

    Örnek bir bütün olarak aşağıda verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* gpiod-sample.c */

#include <stdio.h>
#include <unistd.h>
#include <gpiod.h>

void exit_sys(const char *msg);

int main(void)
{
    struct gpiod_chip *chip;
    unsigned int offsets[] = {4, 19, 28};
    int values[3];
    struct gpiod_line_bulk lb;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if (gpiod_chip_get_lines(chip, offsets, 3, &lb) == -1)
        exit_sys("gpiod_chip_get_lines");

    if (gpiod_line_request_bulk_input(&lb, "myapp") == -1)
        exit_sys("gpiod_line_request_bulk_output");

    for (int i = 0; i < 10; ++i) {
        if (gpiod_line_get_value_bulk(&lb, values) == -1)
            exit_sys("gpiod_line_set_value_bulk");
        for (int k = 0; k < 3; ++k)
            printf("line %d: %d\n", offsets[k], values[k]);
        sleep(1);
    }

    gpiod_line_release_bulk(&lb);
    gpiod_chip_close(chip);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de gpiod kütüphanesinde kesme işlemlerinin nasıl yapıldığı üzerinde duralım. Kesme işlemlerini yapabilmek için önce 
    ilgili hattın "çıkan kenar tetiklemeli mi", "düşen kenar tetiklemeli mi" kesme oluşturacağı ayarlanmalıdır. Bunun için 
    gpiod_line_request_rising_edge_events ve gpiod_line_request_falling_edge_events fonksiyonları kullanılmaktadır. Fonksiyonların 
    prototipleri şöyledir:
    
    #include <gpiod.h>

    int gpiod_line_request_rising_edge_events(struct gpiod_line *line, const char *consumer);
    int gpiod_line_request_falling_edge_events(struct gpiod_line *line, const char *consumer);

    Fonksiyonların birinci parametreleri gpiod_line nesnesinin adresini, ikinci parametreleri uygulamayı belirten bir yazıyı 
    almaktadır. Fonksiyonlar başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. Bu fonksiyonlar 
    zaten hattı IN olarak konfigüre de etmektedir. Örneğin:

    struct gpiod_chip *chip;
    struct gpiod_line *line;
    int result;
    
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 19)) == NULL)
        exit_sys("gpiod_chip_get_line");
    
    if (gpiod_line_request_falling_edge_events(line, "myapp") == -1)
        exit_sys("gpiod_line_request_falling_edge_events");

    /* ... */
        
    gpiod_line_release(line);
    gpiod_chip_close(chip);

    Bundan sonra artık gpiod_line_event_wait fonksiyonu ile kesme oluşana kadar bloke beklenir. Tabii bu fonksiyon 
    aslında kendi içerisinde select ve poll fonksiyonlarını kullanmaktadır. Fonksiyonun prototipi şöyledir:

    #include <gpiod.h>

    int gpiod_line_event_wait(struct gpiod_line *line, const struct timespec *timeout);

    Fonksiyonun birinci parametresi gpiod_line nesnesinin adresini, ikinci parametresi zaman aşımı değerini almaktadır. 
    Zaman aşımı POSIX'in timespec yapısıyla belirtilmektedir:

    #include <time.h>

    struct timespec {
        time_t      tv_sec;                 /* Seconds */
        long        tv_nsec;                /* Nanoseconds [0, 999'999'999] */
    };

    Zaman aşımı parametresi NULL geçilirse zaman aşımı uygulanmaz. Fonksiyon zaman aşımı oluşursa 0 değerine, kesme olayı 
    gerçekleşirse 1 değerine ve başarısızlık durumunda -1 değerine geri dönmektedir. İlgili olay gerçekleştikten sonra 
    olayın gerçekleştiği hattın gpiod_line_event_read fonksiyonuyla okunması gerekmektedir. Aksi takdirde fonksiyon sonraki 
    seferde bekleme yapmayacaktır. gpiod_line_event_read fonksiyonunun prototipi şöyledir:

    #include <gpiod.h> 

    int gpiod_line_event_read(struct gpiod_line *line, struct gpiod_line_event *event);

    Fonksiyonun birinci parametresi gpiod_line nesnesinin adresini, ikinci parametresi gpiod_line_event isimli bir yapı 
    nesnesinin adresini almaktadır. Fonksiyon olayla ilgili bazı bilgileri bu nesneye yazmaktadır. Yapı şöyle bildirilmiştir:

    struct gpiod_line_event {
        struct timespec ts;   /* Timestamp (CLOCK_REALTIME) */
        int event_type;       /* GPIOD_LINE_EVENT_RISING_EDGE veya GPIOD_LINE_EVENT_FALLING_EDGE */
    };

    Burada yapının ts elemanı olayın oluş zamanını, event_type elemanı olayın türünü belirtmektedir. Bu eleman şunlardan 
    biri olabilir:

    GPIOD_LINE_EVENT_RISING_EDGE
    GPIOD_LINE_EVENT_FALLING_EDGE

    Tabii biz bu yapı içerisindeki bilgileri hiç kullanmayabiliriz. Ancak bu ikinci parametre NULL geçilememektedir. 
    Örneğin:

    struct gpiod_chip *chip;
    struct gpiod_line *line;
    struct gpiod_line_event event;
        
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 19)) == NULL)
        exit_sys("gpiod_chip_get_line");
    
    if (gpiod_line_request_falling_edge_events(line, "myapp") == -1)
        exit_sys("gpiod_line_request_falling_edge_events");

    for (int i = 0; i < 10; ++i) {
        if (gpiod_line_event_wait(line, NULL) == -1)
            exit_sys("gpiod_line_event_wait");

        if (gpiod_line_event_read(line, &event) == -1)
            exit_sys("gpiod_line_get_value");
        
        printf("interrupt occurred...\n");
    }

    gpiod_line_release(line);
    gpiod_chip_close(chip);

    Aşağıda örnek bir bütün olarak verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* gpiod-sample.c */

#include <stdio.h>
#include <unistd.h>
#include <gpiod.h>

void exit_sys(const char *msg);

int main(void)
{
    struct gpiod_chip *chip;
    struct gpiod_line *line;
    struct gpiod_line_event event;
        
    if ((chip = gpiod_chip_open_by_name("gpiochip1")) == NULL)
        exit_sys("gpiod_chip_open_by_name");
    
    if ((line = gpiod_chip_get_line(chip, 19)) == NULL)
        exit_sys("gpiod_chip_get_line");
    
    if (gpiod_line_request_falling_edge_events(line, "myapp") == -1)
        exit_sys("gpiod_line_request_falling_edge_events");

    for (int i = 0; i < 10; ++i) {
        if (gpiod_line_event_wait(line, NULL) == -1)
            exit_sys("gpiod_line_event_wait");

        if (gpiod_line_event_read(line, &event) == -1)
            exit_sys("gpiod_line_get_value");
        
        printf("interrupt occurred...\n");
    }

    gpiod_line_release(line);
    gpiod_chip_close(chip);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    gpiod kütüphanesi burada açıkladığımız fonksiyonlardan daha fazla fonksiyona sahiptir. Bunun için kütüphanenin orijinal
    dokümanlarına başvurabilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    gpiod kütüphanesinin aslında "/dev/gpiochipN" (buradaki N bir chip numarasını belirten bir sayıdır) aygıt sürücülerine 
    ioctl komutları göndererek yazıldığını belirtmiştik. Biz de aslında bu aygıt sürücüyü open fonksiyonuyla açıp ona 
    ioctl komutları göndererek de işlemlerimizi yapabiliriz. Tabii bunun için bu aygıt sürücünün dokümantasyonuna erişmemiz
    gerekir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                        135. Ders 16/10/2025 - Perşembe
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi biz çok ayrıntısına girmeden "/dev/gpiochipN" aygıt sürücülerinin nasıl kullanıldığını temel düzeyde açıklayalım. 
    BBB'de toplam GPIO aygıt sürücüsüne ilişkin dört aygıt dosyası bulunmaktadır:

    $ ls -l gpio*
    crw-rw---- 1 root gpio 254, 0 Feb  4 22:05 gpiochip0
    crw-rw---- 1 root gpio 254, 1 Feb  4 22:05 gpiochip1
    crw-rw---- 1 root gpio 254, 2 Feb  4 22:05 gpiochip2
    crw-rw---- 1 root gpio 254, 3 Feb  4 22:05 gpiochip3

    Görüldüğü gibi aygıt dosyalarının majör numaralarının aynıdır. Her bir minör numara bir GPIO denetleyicisini temsil 
    etmektedir. 

    GPIO aygıt sürücülerinin iki versiyonu çıkmıştır. Aygıt sürücünün 1 numaralı versiyonlarıyla 2 numaralı versiyonları 
    arasında uyumsuzluklar bulunmaktadır. Biz burada 1 numaralı versiyona ilişkin örnekler vereceğiz. 

    GPIO aygıt sürücücünün kullandığı bütün yapıların bildirimleri, sembolik sabit tanımlamaları <linux/gpio.h> dosyası 
    içerisindedir. Dolayısıyla bu dosya include etmelisiniz. 

    Bizim ilk yapacağımız şey ilgilendiğimiz aygıt dosyasını open POSIX fonksiyonuyla açıp bir dosya betimleyicisi elde 
    etmektedir:

    int fd;

    if ((fd = open("/dev/gpiochip1", O_RDWR)) == -1)
        exit_sys("open");

    GPIO chip'inin ismi ve hat sayısı aygıt sürücüye GPIO_GET_CHIPINFO_IOCTL ioctl komutu gönderilerek elde edilebilmektedir. 
    Aygıt sürücü chip'e ilişkin bilgileri adresini aldığı gpiochip_info isimli bir yapı nesnesinin içine yerleştirmektedir. 
    Bu yapı şöyle bildirilmiştir:

    struct gpiochip_info {
        char name[32];
        char label[32];
        __u32 lines;
    };

    Örneğin:

    int fd;
    struct gpiochip_info info;

    if ((fd = open("/dev/gpiochip1", O_RDWR)) == -1)
        exit_sys("open");

    if (ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, &info) == -1)
        exit_sys("ioctl");

    printf("Name: %s, Number of lines: %u\n", info.name, info.lines);

    Tıpkı gpiod kütüphanesinde olduğu gibi belli bir hat üzerinde işlem yapmadan önce o hattı elde etmek gerekir. OUT için 
    hat talep etme işlemi GPIO_GET_LINEHANDLE_IOCTL ioctl komutuyla yapılmaktadır. Bunun için gpiohandle_request yapısı 
    türünden bir nesne tanımlanır. Bu yapının içi memset fonksiyonuyla sıfırlanır. Sonra gpiohandle_request yapısının 
    lineoffsets elemanına OUT olarak konfigüre edeceğimiz hatların numaralarını yerleştiririz Yani örneğin bir 3 farklı hattı
    OUT olarak konfigüre edeceksek bu hat numaralarını lineoffsets[0], lineoffsets[1] ve lineoffsets[2] elemanlarına yerleştiririz. 
    Dizinin kaç elemanına yerleştirme yapmışsak yapının lines elemanına o sayı girilmelidir. Ayrıca bu OUT konfigürasyonunda 
    hattaki ilk değeri de yapının default_values dizisi yoluyla verebilmekteyiz. Ayrıca yapının consumer_label elemanına da 
    uygulamaya ilişkin bir isim iliştirilebilir. Aslında buraya kadar yapılan işlemler hattı IN olarak konfigüre etmek için 
    de kullanılmaktadır. Hattı OUT olarak konfigüre edilmesi için yapının flags elemanına GPIOHANDLE_REQUEST_OUTPUT değerinin 
    yerleştirilmesi gerekmektedir. 
    
    Örneğin biz gpiochip1 denetleyicisinin 28 numaralı ucunu OUT olarak aşağıdaki gibi konfigüre edebiliriz:

    int fd;
    struct gpiochip_info info;
    struct gpiohandle_request req;
    

    if ((fd = open("/dev/gpiochip1", O_RDWR)) == -1)
        exit_sys("open");

    if (ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, &info) == -1)
        exit_sys("ioctl");
    printf("Name: %s, Number of lines: %u\n", info.name, info.lines);

    memset(&req, 0, sizeof(req));
    req.lineoffsets[0] = 28;
    req.default_values[0] = 1;
    req.lines = 1;
    strcpy(req.consumer_label, "myapp");
    req.flags = GPIOHANDLE_REQUEST_OUTPUT;

    if (ioctl(fd, GPIO_GET_LINEHANDLE_IOCTL, &req) == -1)
        exit_sys("ioctl");

    OUT olarak konfigüre ettiğimiz hattı lojik 0 ve lojik 1 seviyesine çekmek için GPIOHANDLE_SET_LINE_VALUES_IOCTL ioctl komutu 
    gönderilmelidir. Burada bizim OUT olarak konfigüre ettiğimiz hatların işaretlerini gpiohandle_data isimli bir yapının values 
    dizisine kodlamamız gerekir. Ancak GPIOHANDLE_SET_LINE_VALUES_IOCTL komutunu artık yukarıdaki hat alma işlemi sonucunda 
    bize verilen gpiohandle_request yapısının fd elemanına ilişkin betimleyiciyi kullanarak uygulamamız gerekir. Bu ioctl komutunun 
    üçüncü parametresine gpiohandle_data yapı nesnesini adresi girilmelidir. Örneğin yukarıda OUT biçiminde konfigüre ettiğimiz hattı 
    şöyle 0'a çekebiliriz:

    int fd;
    struct gpiochip_info info;
    struct gpiohandle_request req;
    struct gpiohandle_data data;

    if ((fd = open("/dev/gpiochip1", O_RDWR)) == -1)
        exit_sys("open");

    if (ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, &info) == -1)
        exit_sys("ioctl");
    printf("Name: %s, Number of lines: %u\n", info.name, info.lines);

    memset(&req, 0, sizeof(req));
    req.lineoffsets[0] = 28;
    req.default_values[0] = 1;
    req.lines = 1;
    strcpy(req.consumer_label, "myapp");
    req.flags = GPIOHANDLE_REQUEST_OUTPUT;

    if (ioctl(fd, GPIO_GET_LINEHANDLE_IOCTL, &req) == -1)
        exit_sys("ioctl");

    sleep(5);

    data.values[0] = 0;
    if (ioctl(req.fd, GPIOHANDLE_SET_LINE_VALUES_IOCTL, &data) == -1)
        exit_sys("ioctl");

    Elde etmiş olduğumuz hatları geri bırakmak için tek yapılacak şey gpiohandle_request yapısının fd elemanı ile verilen 
    betimleyiciyi close etmektir. Yani programımızın sonunda iki betimleyiciyi de aşağıdaki gibi close etmeliyiz:

    close(req.fd);
    close(fd);

    Aşağıdaki örnekte 10 kez LED yakılıp söndürülmüştür.
---------------------------------------------------------------------------------------------------------------------------*/
<BURADA KALDIM>
/* gpio-driver-ioctl.c */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/gpio.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    struct gpiochip_info info;
    struct gpiohandle_request req;
    struct gpiohandle_data data;

    if ((fd = open("/dev/gpiochip1", O_RDWR)) == -1)
        exit_sys("open");

    if (ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, &info) == -1)
        exit_sys("ioctl");
    printf("Name: %s, Number of lines: %u\n", info.name, info.lines);

    memset(&req, 0, sizeof(req));
    req.lineoffsets[0] = 28;
    req.default_values[0] = 1;
    req.lines = 1;
    strcpy(req.consumer_label, "myapp");
    req.flags = GPIOHANDLE_REQUEST_OUTPUT;

    if (ioctl(fd, GPIO_GET_LINEHANDLE_IOCTL, &req) == -1)
        exit_sys("ioctl");

    for (int i = 0; i < 10; ++i) {
        data.values[0] = 0;
        if (ioctl(req.fd, GPIOHANDLE_SET_LINE_VALUES_IOCTL, &data) == -1)
            exit_sys("ioctl");
        sleep(1);
        data.values[0] = 1;
        if (ioctl(req.fd, GPIOHANDLE_SET_LINE_VALUES_IOCTL, &data) == -1)
            exit_sys("ioctl");
        sleep(1);
    }

    close(req.fd);
    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Hattan okuma yapmak da benzer biçimdedir. Önce hat talep edilir. Ancak talep edilirken gpiohandle_request yapısının flags 
    elemanı GPIOHANDLE_REQUEST_INPUT girilmelidir. Örneğin:

    int fd;
    struct gpiochip_info info;
    struct gpiohandle_request req;
    struct gpiohandle_data data;

    if ((fd = open("/dev/gpiochip1", O_RDWR)) == -1)
        exit_sys("open");

    if (ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, &info) == -1)
        exit_sys("ioctl");
    printf("Name: %s, Number of lines: %u\n", info.name, info.lines);

    memset(&req, 0, sizeof(req));
    req.lineoffsets[0] = 19;
    req.lines = 1;
    strcpy(req.consumer_label, "myapp");
    req.flags = GPIOHANDLE_REQUEST_INPUT;
    if (ioctl(fd, GPIO_GET_LINEHANDLE_IOCTL, &req) == -1)
        exit_sys("ioctl");

    Bundan sonra GPIOHANDLE_GET_LINE_VALUES_IOCTL ioctl komutu ile hatlardaki değerler okunabilir. Yine bu ioctl komutunda 
    da ioctl fonksiyonun üçüncü parametresine gpiohandle_data isimli yapı türünden bir nsnenin adresi girilmelidir. ioctl 
    uygulandıktan sonra yne bu nesnenin values dizisinde ilgili değer alınmaktadır. Örneğin:

    if (ioctl(req.fd, GPIOHANDLE_SET_LINE_VALUES_IOCTL, &data) == -1)
            exit_sys("ioctl");

    Aşağıdaki örnekte düğmeye basılıp basılmadığı bilgisi bir saniye periyotlarla kontrol edilerek yazdırılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-driver-ioctl.c */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/gpio.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    struct gpiochip_info info;
    struct gpiohandle_request req;
    struct gpiohandle_data data;

    if ((fd = open("/dev/gpiochip1", O_RDWR)) == -1)
        exit_sys("open");

    if (ioctl(fd, GPIO_GET_CHIPINFO_IOCTL, &info) == -1)
        exit_sys("ioctl");
    printf("Name: %s, Number of lines: %u\n", info.name, info.lines);

    memset(&req, 0, sizeof(req));
    req.lineoffsets[0] = 19;
    req.lines = 1;
    strcpy(req.consumer_label, "myapp");
    req.flags = GPIOHANDLE_REQUEST_INPUT;
    if (ioctl(fd, GPIO_GET_LINEHANDLE_IOCTL, &req) == -1)
        exit_sys("ioctl");

    for (int i = 0; i < 10; ++i) {
        if (ioctl(req.fd, GPIOHANDLE_GET_LINE_VALUES_IOCTL, &data) == -1)
            exit_sys("ioctl");

        printf("%d\n", data.values[0]);
        sleep(1);
    }   

    close(req.fd);
    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Kesme işlemi yapmak için önce gpioevent_request isimli bir yapı türünden nesne yaratıp içi sıfırlanır. Yapının lineoffset 
    elemanına kesme için ilgilendiğimiz hattın numarası yerleştirilir. Sonra yapının aşağıdaki bayrak elemanına aşağıdaki 
    değerler verilir:

    event_req.handleflags = GPIOHANDLE_REQUEST_INPUT;
    event_req.eventflags = GPIOEVENT_REQUEST_FALLING_EDGE; 

    Sonra da GPIO_GET_LINEEVENT_IOCTL komutuyla hat kesme içn konfigüre edilir. Buradaki event_req ile temsil edilen yapı 
    nesnesinin adresi ioctl fonksiyonunun üçüncü parametresine geçirilmeliir. Bu ioctl komutu herhangi bir bloke oluşturmaz. 
    Kesmeyi beklemek için bu yapının fd elemanı ile verilen betimleyiciden read fonksiyonu ile okuma yapmak gerekir. Okuma 
    işlemi kesme oluşana kadar thread'i bloke bekletecektir. Örneğin:

    int fd;
    struct gpioevent_request event_req;
    struct gpioevent_data event;

    if ((fd = open("/dev/gpiochip1", O_RDWR)) == -1)
        exit_sys("open");

    memset(&event_req, 0, sizeof(event_req));
    event_req.lineoffset = 19;
    event_req.handleflags = GPIOHANDLE_REQUEST_INPUT;
    event_req.eventflags = GPIOEVENT_REQUEST_FALLING_EDGE; 

    strcpy(event_req.consumer_label, "myapp");
    if (ioctl(fd, GPIO_GET_LINEEVENT_IOCTL, &event_req) == -1)
        exit_sys("ioctl");

    for (int i = 0; i < 10; ++i) {
        if (read(event_req.fd, &event, sizeof(event)) == -1)
            exit_sys("read");
        
        printf("intterupt occured...\n");
    }

    close(event_req.fd);
    close(fd);

    Aşağıda örnek bütünsel biçimde verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-driver-ioctl.c */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/gpio.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    struct gpioevent_request event_req;
    struct gpioevent_data event;

    if ((fd = open("/dev/gpiochip1", O_RDWR)) == -1)
        exit_sys("open");

    memset(&event_req, 0, sizeof(event_req));
    event_req.lineoffset = 19;
    event_req.handleflags = GPIOHANDLE_REQUEST_INPUT;
    event_req.eventflags = GPIOEVENT_REQUEST_FALLING_EDGE; 

    strcpy(event_req.consumer_label, "myapp");
    if (ioctl(fd, GPIO_GET_LINEEVENT_IOCTL, &event_req) == -1)
        exit_sys("ioctl");

    for (int i = 0; i < 10; ++i) {
        if (read(event_req.fd, &event, sizeof(event)) == -1)
            exit_sys("read");
        
        printf("intterupt occured...\n");
    }

    close(event_req.fd);
    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                                136. Ders 21/10/2025 - Salı 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de BBB içerisindeki GPIO denetleyicisine bellek tabanlı (memory-mapped) IO tekniği ile erişip doğrudan bu denetleyiciyi 
    programlayarak GPIO işlemlerini yapalım. Anımsanacağı gibi ARM mimarisinde zaten prt tabanlı (port-mapped) IO kullanılmıyordu. 
    Tüm denetleyicilerle adres ve veri yolu kullanılarak bellek erişim komutlarıyla haberleşme sağlanıyordu. Bu da bizim doğrudan 
    C'deki göstericilerle denetleyicinin yazmaçlarına erişebileceğimiz anlamına geliyordu. Bellek tabanlı IO işlemi yaparken 
    şunlara dikkat edilmesi gerektiğini anımsayınız:
    
    - Bellek tabanlı IO işlemeri için hangi fiziksel bellek adresinin denetleyicinin hangi yazmacına karşılık geldiğinin bilinmesi 
    gerekmektedir. Başka bir deyişle denetleyicinin hangi adresine hangi komut gönderildiğinde denetleyicinin ne yaptığının 
    baştan bilinmesi gerekmektedir. 

    - Denetleyicilereki bellek adresleri fiziksel adreslerdir. Programcının bu fiziksel adresler için sanal adresleri oluşturması
    gerekmektedir. 

    - Derleyiciler ve işlemciler birbirlerinden bağımsız komutların sırasını değiştirbiliyordu (instuction reordering). Bellek 
    tabanlı IO işlemlerinde bu durumun dikkate alınması gerekir. Bunun bellek bariyerleri (memory barriers) denilen mekanizmanın 
    kullanıldığını anımsayınız. 

    - Aynı bellek bölgesine farklı çekirdekler tarafından aynı anda yazma yapılırken ya da aynı bellek bölgesine bir çkirdek
    yazma yaparken aynı anda oradan başka bir çekirdek okuma yaparken bazı platformlarda bazı koşullarda bazulmalar olabileceğini 
    belirtmiştik. Bu nedenle okuma ve yazma işlemlerinin bu durum gözetilerek atomikbir biçimde yapılması tavsiye edilmektedir. 
    (Anımsanacağı gibi aygıt sürücüler konusunda görmüş olduğumuz ioreadxxx ve iowritexxx fonksiyonları bellek bariyerlerini 
    ve atomikliği kendi içlerinde oluşturmaktadır. Bu nedenle aygıt sürücüler içerisinde bu fonksiyonların kullanılması tavsiye 
    edilmektedir.)
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    BBB'de toplam dört adet GPIO denetleyicisi bulunduğunu anımsayınız. Bunların taban fiziksel adresleri şöyledir:

    #define GPIO_CHIP0_BASE  0x44E07000
    #define GPIO_CHIP1_BASE  0x4804C000
    #define GPIO_CHIP2_BASE  0x481AC000
    #define GPIO_CHIP3_BASE  0x481AE000

    Bu taban adreslerden itibaren her DWORD (4 byte) farklı bir anlama gelmektedir. Bunlara GPIO denetleyicisinin yazmaçları 
    diyebiliriz. Bizi ilgilendiren önemli yazmaçlar ve bunlar offste numaraları şöyledir:

    Yazmacın Sembolik İsimli                Offset Değeri

    #define GPIO_OE                             0x134
    #define GPIO_DATAIN                         0x138
    #define GPIO_DATAOUT                        0x13C
    #define GPIO_CLEARDATAOUT                   0x190
    #define GPIO_SETDATAOUT                     0x194

    BBB'deki diğer GPIO yazmaçları ve genel olarak GPIO denetleyicisi hakkında ayrıntılı açıklama için "AM335x and AMIC110 Sitara™ 
    Processors Technical Reference Manual" dokümanlarına başvurabilirsiniz. Aşağıdaki örneklerde gpio_base göstericisinin denetleyiciye 
    ilişkin taban sanal adresi gösterdiği varsayılacaktır. 

   -  GPIO_OE pinlerini (aslında denetleyicinin uçlarını) IN ya da OUT biçimide konfigüre etmek için kullanılmaktadır. Bu offset'ten 
   başlayan 4 byte'lık DWORD bilgi ger denetleyici ucunun konumunu bit bit temsil etmektedir. İlgili bit 0 yapıldığında o uç OUT 
   durumuna 1 yapıldığında IN durumuna konfigüre edilmektedir. O halde "pin" denetleyicinin uç numarasını belirtmek üzere o ucu 
   OUT olarak konfügüre etmek için şu işlem yapılmalıdır:

    volatile uint32_t *gpio_reg = (uint32_t *) (gpio_base + GPIO_OE);
    *gpio_reg &= ~(1 << pin);

    IN olarak konfigüre etme işlemi de şöyle yapılabilir:

    volatile uint32_t *gpio_reg = (uint32_t *) (gpio_base + GPIO_OE);
    *gpio_reg |= 1 << pin;
 
    - GPIO_DATAIN ile temsil edilen offset'teki 4 byte'lık DWORD değer denetleyicinin uçlarını tek hamlede okumak için kullanılmaktadır. 
    Tabii eğer biz "pin" numaralı ucun durumunu elde etmek istiyorsak şöyle yapmalıyız:

    volatile uint32_t *gpio_reg = (uint32_t *) (gpio_base + GPIO_DATAIN);
    result = *gpio_reg >> pin & 1;

    - GPIO_DATAOUT ile temsil edilen offset'teki 4 byte'lık DWORD değer denetleyicinin uçlarını lojik 0 ya da 1 çekmek için kullanılmaktadır. 
    Burada her bit bir ucu temsil etmektedir. Örneğin "pin" numaralı ucu diğer uçlardaki değerleri değiştirmeden şöyle 1 yapabiliriz:

    volatile uint32_t *gpio_reg = (uint32_t *) (gpio_base + GPIO_DATAOUT);
    *gpio_reg |= 1 << pin;

    Diğer uçlara dokunmadan ilgili uç şöyle 0'a çekilebilir:

    volatile uint32_t *gpio_reg = (uint32_t *) (gpio_base + GPIO_DATAOUT);
    *gpio_reg &= ~(1 << pin);

    - GPIO_CLEARDATAOUT ve GPIO_SETDATAOUT yazmaçları bit düzeyinde işlemleri elimine etmek için düşünülmüştür. Bu yazmaçlardaki 
    0 olan bitleer dikkate alınmaz. Yalnıca 1 olan bitler üzerinde işlem yapılmaktadır. GPIO_CLEARDATAOUT yalnızca 1 olan bitleri
    lojik 0 seviyesine, GPIO_SETDATAOUT ise yaşnızca 1 olan bitleri lojik 1 seviyesine çekmektedir. Örneğin biz "pin" numaralı 
    ucu lojik 1 seviyesine şöyle de çekebiliriz:

    volatile uint32_t *gpio_reg = (uint32_t *) (gpio_base + GPIO_SETDATAOUT);
    *gpio_reg = 1 << pin;
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de bellek tabanlı IO tekniğini kullanıcı modunda mmap fonksiyonuyla uygulayalım. Tabii aslında bu işlemler için 
    karakter aygıt sürücülerinin yazılması ve işlemlerin çekirdek modunda gerçekleştirilmesi tavsiye edilmektedir. 

    Kullanıcı modunda bellek tabanlı IO işlemleri için "/dev/mem" aygıt sürücüsü ve mmap POSIX fonksiyonu kullanılmaktadır. 
    mmap fonksiyonu "bellek tabanlı dosya (mempry-mapped file)" oluşturmak için kullanılabilmektedir. Bellek tabanlı dosyalar 
    sayesinde sanki bir dosya bellekteymiş de bellekte oraya yazma yapıldığında yazma doğrudan doğrudan dosyaya yapılıyormuş 
    gibi bir etki oluşturulmaktadır. "/dev/mem" aygıt sürücüsü fiziksel RAM'i sanki bir dosyaymış gibi göstermektedir. Örneğin
    biz bu dosyayı open fonksiyonu ile açıp dosya göstericisini belli bir offset'e konumlandırıp oraya yazma yaparsak fiziksel 
    RAM'e yazma yapımış oluruz. O halde "/dev/mem" dosyasını mmap ile belleğe çekerek bellekte yapacağımız yazma işlemi aslında 
    "/dev/mem" dosyasına yapılacaktır. Dolayısıyla biz fiziksel RAM'i kendi prosesimizin sanal adresl alanında bir yere çekip 
    onun üzerinde çalışabiliriz. mmap fonksiyonunun pek çok ayrıntısı vardır. Bu fonksiyonun çalışması "UNIX/Linux Sistem 
    Programlama" kurslarında ele alınmaktadır. mmap ile belleğe çekilen dosya munmap fonksiyonuyla boşaltılmaktadır. 
    Fonksiyonların prototipleri şöyledir:

    #include <sys/mman.h>

    void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t off);
    int munmap(void *addr, size_t len);

    mmap fonksiyonunun birinci parametresi programcınn arzu ettiği sanal bellek adresini belirtmektedir. Genellikle bu 
    parametre NULL geçilmektedir. Bu durumda map işlemi için uygun sanal adres fonksiyon tarafından tespit edilir. Fonksiyonun 
    ikinci parametresi mapping uzunluğunu belirtmektedir. Üçüncü parametre map edilen sayfaların koruma bilgilerini belirtiri. 
    Bu parametre için PROT_READ|PROT_WRITE değerini argüman olarak geçebilirsiniz. Dördüncü parametre tipik olarak MAP_SHARED
    biçiminde geçilmektedir. MAP_PRIVATE "copy-on-write" mekanizması için kullanılmaktadır. Fonksiyonun fd ile belirtilen 
    beşinci parametresi map edilecek dosyaya ilişkin dosya betimleyicisini belirtmektedir. Son parametre ise dosyanın hangi 
    offset'inden itibaren mapping yapılacağını belirtmektedir. Yani dosyanın belli bir offset'indne itibaren belli bir uzunluk 
    map edilebilmektedir. munmap fonksiyonun ise birinci parametresi mmap fonksiyonundan elde edilen adresi, ikinci parametresi 
    de unmap yapılacak uzunluğu belirtir. mmap fonksiyonu başarı durumunda map edilen dosyanın sanal bellek adresine, başarısızlık 
    durumunda ise MAP_FAILED özel değerine geri dönmektedir. munmap fonksiyonu ise başarı durumunda 0 değerine, başarısızlık 
    durumunda  -1 değerine geri dönmektedir. 

    mmap ve maunmap fonksiyonları sayfa tabanlı çalışmaktadır. Dolayısıyla bu fonksiyonlardaki uzunluk değerleri tipik 
    olarak 4096'nın katları olmalıdır. Bu fonksiyonlara uzun oolarak eğer sayfa katlarını vermezseniz, fonksiyonlar bunu 
    sayfa katlarına çekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    BBB'nin GPIO denetleyicileri için mapping işlemi tipik olarak şöyle yapılmaktadır:

    int fd;
    volatile uint8_t *gpio_base;

    if ((fd = open("/dev/mem", O_RDWR|O_SYNC)) == -1) 
       exit_sys("open");
        
    if ((gpio_base = (volatile uint8_t *)mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, GPIO_CHIP1_BASE)) == MAP_FAILED) 
        exit_sys("mmap");

    /* .... */

    munmap((void *)gpio_base, 4096);
    close(fd);

    Bu işlemi yaptıktan sonra atık GPIO denetleyicisinin yazmaçlarına bir gösterici yoluyla erişebilir hale gelmiş oluruz. 
    Bu durumda örneğin GPIO1_28 pinine bağladığımız LED'i 1 saniye arayla yakıp söndürme işlemi şöyle yapılabilir:

    gpio_reg = (uint32_t *) (gpio_base + GPIO_OE);
    clear_bit(gpio_reg, 28);
    gpio_reg = (uint32_t *) (gpio_base + GPIO_DATAOUT);

    for (int i = 0; i < 10; ++i) {
        set_bit(gpio_reg, 28);
        sleep(1);
        clear_bit(gpio_reg, 28)   ;
        sleep(1);
    }

    Buradaki clear_bit ve set_bit fonksiyonları uint32_t türünden bir değerin belli bir bitini diğer bitlerine dokunmadan 0 
    ve 1 yapmaktadır. Kodd önce ilgili pin OUT olarak konfigüe edilmiştir:

    gpio_reg = (uint32_t *) (gpio_base + GPIO_OE);
    clear_bit(gpio_reg, 28);

    Sonra ilgili pin 1'er saniye aralıklarla yakılıp södürülmüştür:

    gpio_reg = (uint32_t *) (gpio_base + GPIO_DATAOUT);

    for (int i = 0; i < 10; ++i) {
        set_bit(gpio_reg, 28);
        sleep(1);
        clear_bit(gpio_reg, 28);
        sleep(1);
    }

    Her okuma ve yazma işleminden sonra bellek bariyerlerini kullanmayı unutmayınız. Bu bariyerler hem derleyicinin hem de 
    işlemcinin komutları yeniden sıralamasını engelleyecektir. Ancak aygıt sürücü konusunda gördüğümüz bariyer fonksiyonlarını
    kullanıcı modunda doğrudan kullanamayız. Bu nedenle bu fonksiyonları gcc'nin eklentilerini kullanarak yenidne yazdık:

    #ifdef __arm__
        #define dmb()  __asm__ __volatile__ ("dmb" : : : "memory")
        #define rmb()  __asm__ __volatile__ ("dmb" : : : "memory")          
        #define wmb()  __asm__ __volatile__ ("dmb st" : : : "memory")  
    #elif defined(__aarch64__)
        #define dmb()  __asm__ __volatile__ ("dmb sy" : : : "memory")
        #define rmb()  __asm__ __volatile__ ("dmb ld" : : : "memory")
        #define wmb()  __asm__ __volatile__ ("dmb st" : : : "memory")
    #else
        #define dmb()  __sync_synchronize()
        #define rmb()  __sync_synchronize()
        #define wmb()  __sync_synchronize()
    #endif

    Program bir bütün olarak aşağıda verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-mmap.c */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>   

#define GPIO_CHIP0_BASE  0x44E07000
#define GPIO_CHIP1_BASE  0x4804C000
#define GPIO_CHIP2_BASE  0x481AC000
#define GPIO_CHIP3_BASE  0x481AE000

#define GPIO_OE                             0x134
#define GPIO_DATAIN                         0x138
#define GPIO_DATAOUT                        0x13C
#define GPIO_CLEARDATAOUT                   0x190
#define GPIO_SETDATAOUT                     0x194

#ifdef __arm__
    #define dmb()  __asm__ __volatile__ ("dmb" : : : "memory")
    #define rmb()  __asm__ __volatile__ ("dmb" : : : "memory")          
    #define wmb()  __asm__ __volatile__ ("dmb st" : : : "memory")  
#elif defined(__aarch64__)
    #define dmb()  __asm__ __volatile__ ("dmb sy" : : : "memory")
    #define rmb()  __asm__ __volatile__ ("dmb ld" : : : "memory")
    #define wmb()  __asm__ __volatile__ ("dmb st" : : : "memory")
#else
    #define dmb()  __sync_synchronize()
    #define rmb()  __sync_synchronize()
    #define wmb()  __sync_synchronize()
#endif

void exit_sys(const char *msg);

static inline void set_bit(volatile uint32_t *gpio_reg, int offset)
{
    *gpio_reg |= 1 << offset;  
    wmb();
}

static inline void clear_bit(volatile uint32_t *gpio_reg, int offset)
{
    *gpio_reg &= ~(1 << offset);
    wmb();
}

int main(void)
{
    int fd;
    volatile uint8_t *gpio_base;
    volatile uint32_t *gpio_reg;

    if ((fd = open("/dev/mem", O_RDWR|O_SYNC)) == -1) 
       exit_sys("open");
        
    if ((gpio_base = (volatile uint8_t *)mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, GPIO_CHIP1_BASE)) == MAP_FAILED) 
        exit_sys("mmap");

    gpio_reg = (uint32_t *) (gpio_base + GPIO_OE);
    clear_bit(gpio_reg, 28);
    gpio_reg = (uint32_t *) (gpio_base + GPIO_DATAOUT);

        for (int i = 0; i < 10; ++i) {
            set_bit(gpio_reg, 28);
            sleep(1);
            clear_bit(gpio_reg, 28)   ;
            sleep(1);
        }

    munmap((void *)gpio_base, 4096);
    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de GPIO denetleyicisinin GPIO_DATAIN yazmacını okuyarak belli bir pinin değerini elde edelim. Bunun için yine 
    aşağıdaki hazırlık işlemleri yapılır:

    if ((fd = open("/dev/mem", O_RDWR|O_SYNC)) == -1) 
       exit_sys("open");
        
    if ((gpio_base = (volatile uint8_t *)mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, GPIO_CHIP1_BASE)) == MAP_FAILED) 
        exit_sys("mmap");

    gpio_reg = (uint32_t *) (gpio_base + GPIO_OE);
    set_bit(gpio_reg, 19);
    gpio_reg = (uint32_t *) (gpio_base + GPIO_DATAIN);

    Pini okumak için read_bit isimli bir fonksiyon yazdık:

    
    static inline int read_bit(const volatile uint32_t *gpio_reg, int offset)
    {
        int first_val, second_val;

        for (int i = 0; i < TRYNUM; ++i) {
            first_val = *gpio_reg >> offset & 1;
            rmb();

            usleep(5000);

            second_val = *gpio_reg >> offset & 1;
            rmb();

            if (first_val == second_val)
                return second_val;
        }

        return second_val;
    }

    Burada "debouncing" sorununu çözmek için iki ardııl okumanın aynı değerde olup olmadığına baktık. Eğer az bir bekleme 
    ile iki okuma aynı değeri veriyorsa bir "debounce" durumu oluşmamıştır. Tüm denemeler sonucunda hala "debounce" oluşmuşsa
    artık yapılacak bir şey olmadığı için son değerle geri döndük.

    Programın tüm kodları aşağıda verilmiştir:
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-mmap-read.c */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>   

#define GPIO_CHIP0_BASE  0x44E07000
#define GPIO_CHIP1_BASE  0x4804C000
#define GPIO_CHIP2_BASE  0x481AC000
#define GPIO_CHIP3_BASE  0x481AE000

#define GPIO_OE                             0x134
#define GPIO_DATAIN                         0x138
#define GPIO_DATAOUT                        0x13C
#define GPIO_CLEARDATAOUT                   0x190
#define GPIO_SETDATAOUT                     0x194

#define TRYNUM                              10

#ifdef __arm__
    #define dmb()  __asm__ __volatile__ ("dmb" : : : "memory")
    #define rmb()  __asm__ __volatile__ ("dmb" : : : "memory")          
    #define wmb()  __asm__ __volatile__ ("dmb st" : : : "memory")  
#elif defined(__aarch64__)
    #define dmb()  __asm__ __volatile__ ("dmb sy" : : : "memory")
    #define rmb()  __asm__ __volatile__ ("dmb ld" : : : "memory")
    #define wmb()  __asm__ __volatile__ ("dmb st" : : : "memory")
#else
    #define dmb()  __sync_synchronize()
    #define rmb()  __sync_synchronize()
    #define wmb()  __sync_synchronize()
#endif

void exit_sys(const char *msg);

static inline void set_bit(volatile uint32_t *gpio_reg, int offset)
{
    *gpio_reg |= 1 << offset;  
    wmb();
}

static inline void clear_bit(volatile uint32_t *gpio_reg, int offset)
{
    *gpio_reg &= ~(1 << offset);
    wmb();
}

static inline int read_bit(const volatile uint32_t *gpio_reg, int offset)
{
    int first_val, second_val;

    for (int i = 0; i < TRYNUM; ++i) {
        first_val = *gpio_reg >> offset & 1;
        rmb();

        usleep(5000);

        second_val = *gpio_reg >> offset & 1;
        rmb();

        if (first_val == second_val)
            return second_val;
    }

    return second_val;
}

int main(void)
{
    int fd;
    volatile uint8_t *gpio_base;
    volatile uint32_t *gpio_reg;
    int bitval;

    if ((fd = open("/dev/mem", O_RDWR|O_SYNC)) == -1) 
       exit_sys("open");
        
    if ((gpio_base = (volatile uint8_t *)mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, fd, GPIO_CHIP1_BASE)) == MAP_FAILED) 
        exit_sys("mmap");

    gpio_reg = (uint32_t *) (gpio_base + GPIO_OE);
    set_bit(gpio_reg, 19);
    gpio_reg = (uint32_t *) (gpio_base + GPIO_DATAIN);

    for (int i = 0; i < 10; ++i) {
        bitval = read_bit(gpio_reg, 19);
        printf("%d\n", bitval);
        sleep(1);
    }

    munmap((void *)gpio_base, 4096);
    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                    138. Ders 30/10/2025 - Perşembe
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de bellek tabanlı IO ile GPIO denetleyicisine erişerek okuma yazma yapan bir karakter aygıt sürücüsü yazalım. 
    Aygıt sürücümüzün init fonksiyonunda GPIO denetleyicilerinin fiziksel adresleri sanal adreslere dönüştürülmüşütür:

    for (i = 0; i < NGPIO_CHIPS; ++i) {
        g_gpio_base_addrs[i] = ioremap(gpio_physical_addrs[i], 4096);
        if (g_gpio_base_addrs[i] == NULL) {
            for (k = 0; k < i; ++k)
                iounmap(g_gpio_base_addrs[k]);
            return -ENOMEM;
        }
    }

    Buradaki gpio_physical_addrs denetleyicilerin taban adreslerini belirtmektedir. Bu taban adresler zaten üretici firma 
    tarafından verilmektedir:

    #define GPIO_CHIP0_BASE         0x44E07000
    #define GPIO_CHIP1_BASE         0x4804C000
    #define GPIO_CHIP2_BASE         0x481AC000
    #define GPIO_CHIP3_BASE         0x481AE000

    unsigned long gpio_physical_addrs[NGPIO_CHIPS] = {
        GPIO_CHIP0_BASE, 
        GPIO_CHIP1_BASE, 
        GPIO_CHIP2_BASE, 
        GPIO_CHIP3_BASE
    };

    Aygıt sürücümüzün read ve write fonksiyonlarında GPIO aygıt sürücü pin numaralarını chip numarakarına ve chip'teki 
    pin numaralarına dönüştürdük:

    chip = *off / PINS_PER_CHIP;
    pin = *off % PINS_PER_CHIP;

    Burada PINS_PER_CHIP sembolik sabiti 32 değerindedir. Okuma ve yazma işlemlerinde önce ilgili pin IN ya da OUT olarak 
    konfigüre edilmiş sonra okuma ve yazma yapılmıştır:

    static ssize_t gpio_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        int chip, pin, bitval;
        uint32_t *gpio_reg;

        if (size != 1)
            return -EINVAL;

        chip = *off / PINS_PER_CHIP;
        pin = *off % PINS_PER_CHIP;

        gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
        iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);
        gpio_reg = (uint32_t *) (g_gpio_base_addrs[chip] + GPIO_DATAIN);
        bitval = read_bit(gpio_reg, pin);

        if (copy_to_user(buf, &"01"[bitval] , size) != 0)
            return -EFAULT;

        /* put_user("01"[bitval], buf); */

        return size;
    }

    static ssize_t gpio_write(struct file *filp, const char *buf, size_t size, loff_t *off)
    {
        int chip, pin;
        uint32_t *gpio_reg;
        char ch;

        if (size != 1) 
            return -EINVAL;

        chip = *off / PINS_PER_CHIP;
        pin = *off % PINS_PER_CHIP;

        gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
        iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
        gpio_reg = (uint32_t *) (g_gpio_base_addrs[chip] + GPIO_DATAOUT);
        if (copy_from_user(&ch, buf, size) != 0)
            return -EFAULT;
        if (ch == '0')
            iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
        else if (ch == '1')
            iowrite32(ioread32(gpio_reg) | (1 << pin), gpio_reg);
        else 
            return -EINVAL;

        return size;
    }

    Okuma yazma işlemleri karakter düzeyinde yani '0' ve '1' biçiminde yapılmaktadır. Okuma yazma işlemlerinin dosya göstericisinin
    gösterdiği offset'e ilişkin pin numarsından yapıldığına dikkat ediniz. Ancak okuma yazma sonrasında aygıt sürücümüzün 
    read ve write fonksiyonları dosya göstericisinin konumunu değiştirmemektedir. Tabii bizim lseek işleminde offset'i de aygıt 
    sürücümüz içerisinde konumlandırmamız gerekmektedir:

    static loff_t gpio_llseek(struct file *filp, loff_t off, int whence)
    {
        loff_t newpos;

        switch (whence) {
            case 0:
                newpos = off;
                break;
            case 1:
                newpos = filp->f_pos + off;
                break;
            case 2:
                newpos = (4 * PINS_PER_CHIP) + off;
                break;
            default:
                return -EINVAL;
        }
        if (newpos < 0 || newpos >= 128)
            return -EINVAL;

        filp->f_pos = newpos;

        return newpos;
    }

    Aygıt sürücümüzde herhangi bir ioctl komutunu bulundurmadık. 
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/delay.h>
#include <asm/io.h>
#include "gpio-driver.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("gpio-driver");

#define GPIO_CHIP0_BASE         0x44E07000
#define GPIO_CHIP1_BASE         0x4804C000
#define GPIO_CHIP2_BASE         0x481AC000
#define GPIO_CHIP3_BASE         0x481AE000

#define NGPIO_CHIPS             4
#define PINS_PER_CHIP           32

#define GPIO_OE                 0x134
#define GPIO_DATAIN             0x138
#define GPIO_DATAOUT            0x13C
#define GPIO_CLEARDATAOUT       0x190
#define GPIO_SETDATAOUT         0x194

#define TRYNUM                  10

static int gpio_open(struct inode *inodep, struct file *filp);
static int gpio_release(struct inode *inodep, struct file *filp);
static ssize_t gpio_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t gpio_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static loff_t gpio_llseek(struct file *filp, loff_t off, int whence);
static long gpio_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static inline int read_bit(const uint32_t *gpio_reg, int offset);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = gpio_open,
	.read = gpio_read,
    .write = gpio_write,
	.llseek = gpio_llseek,
    .release = gpio_release,
    .unlocked_ioctl = gpio_driver_ioctl
};

uint8_t *g_gpio_base_addrs[NGPIO_CHIPS];

static int __init gpio_init(void)
{
	int result;
    int i, k;
    unsigned long gpio_physical_addrs[NGPIO_CHIPS] = {
        GPIO_CHIP0_BASE, 
        GPIO_CHIP1_BASE, 
        GPIO_CHIP2_BASE, 
        GPIO_CHIP3_BASE
    };

	if ((result = alloc_chrdev_region(&g_dev, 0, 1, "gpio-driver")) < 0) {
		printk(KERN_INFO "cannot alloc char driver!...\n");
		return result;
	}
	cdev_init(&g_cdev, &g_fops);
	if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
		unregister_chrdev_region(g_dev, 1);
		printk(KERN_ERR "cannot add device!...\n");
		return result;
	}

    for (i = 0; i < NGPIO_CHIPS; ++i) {
        g_gpio_base_addrs[i] = ioremap(gpio_physical_addrs[i], 4096);
        if (g_gpio_base_addrs[i] == NULL) {
            for (k = 0; k < i; ++k)
                iounmap(g_gpio_base_addrs[k]);
            return -ENOMEM;
        }
    }

    printk(KERN_INFO "gpio-driver module initialization...\n");

	return 0;
}

static void __exit gpio_exit(void)
{
    int i;

    for (i = 0; i < NGPIO_CHIPS; ++i)
        iounmap(g_gpio_base_addrs[i]);
	cdev_del(&g_cdev);
	unregister_chrdev_region(g_dev, 1);
    
	printk(KERN_INFO "gpio-driver module exit...\n");
}

static int gpio_open(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "gpio-driver opened...\n");

	return 0;
}

static int gpio_release(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "gpio-driver closed...\n");

	return 0;
}

static ssize_t gpio_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    int chip, pin, bitval;
    uint32_t *gpio_reg;

    if (size != 1)
        return -EINVAL;

    chip = *off / PINS_PER_CHIP;
    pin = *off % PINS_PER_CHIP;

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
    iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);
    gpio_reg = (uint32_t *) (g_gpio_base_addrs[chip] + GPIO_DATAIN);
    bitval = read_bit(gpio_reg, pin);

    if (copy_to_user(buf, &"01"[bitval] , size) != 0)
        return -EFAULT;

    /* put_user("01"[bitval], buf); */

	return size;
}

static ssize_t gpio_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    int chip, pin;
    uint32_t *gpio_reg;
    char ch;

    if (size != 1) 
        return -EINVAL;

    chip = *off / PINS_PER_CHIP;
    pin = *off % PINS_PER_CHIP;

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
    gpio_reg = (uint32_t *) (g_gpio_base_addrs[chip] + GPIO_DATAOUT);
    if (copy_from_user(&ch, buf, size) != 0)
        return -EFAULT;
    if (ch == '0')
        iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
    else if (ch == '1')
        iowrite32(ioread32(gpio_reg) | (1 << pin), gpio_reg);
    else 
        return -EINVAL;

	return size;
}

static loff_t gpio_llseek(struct file *filp, loff_t off, int whence)
{
    loff_t newpos;

    switch (whence) {
        case 0:
            newpos = off;
            break;
        case 1:
            newpos = filp->f_pos + off;
            break;
        case 2:
            newpos = (4 * PINS_PER_CHIP) + off;
            break;
        default:
            return -EINVAL;
    }
    if (newpos < 0 || newpos >= 128)
        return -EINVAL;

    filp->f_pos = newpos;

    return newpos;
}

static long gpio_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    long result;
 
    switch (cmd) {
        case IOC_GPIO_TEST:
            break;
        default:
            result = -ENOTTY;
    }

    return result;
}

static inline int read_bit(const uint32_t *gpio_reg, int offset)
{
    int i;
    int first_val, second_val;

    for (i = 0; i < TRYNUM; ++i) {
        first_val = ioread32(gpio_reg) >> offset & 1;
        msleep(5);
        second_val = ioread32(gpio_reg) >> offset & 1;
        if (first_val == second_val)
            return second_val;
    }

    return second_val;
}

module_init(gpio_init);
module_exit(gpio_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/* gpio-driver-test-read.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char ch;

    if ((fd = open("gpio-driver", O_RDWR)) == -1) 
        exit_sys("open");
    
    lseek(fd, 51, 0);
    for (int i = 0; i < 10; ++i) {
        if (read(fd, &ch, 1) == -1)
            exit_sys("read");
        printf("%c\n", ch);
        sleep(1);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* gpio-driver-test-write.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char ch;

    if ((fd = open("gpio-driver", O_RDWR)) == -1) 
        exit_sys("open");
    
    lseek(fd, 60, 0);
    for (int i = 0; i < 10; ++i) {
        ch = '1';
        if (write(fd, &ch, 1) == -1)
            exit_sys("write");
        sleep(1);

        ch = '0';
        if (write(fd, &ch, 1) == -1)
            exit_sys("write");
        sleep(1);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de yukarıdaki aygıt sürücümüze kesme özelliği ekleyelim. Anımsanacağı gibi aygıt sürücülerde kesme oluştuğunda 
    belirlenen fonksiyonun çağrılması için request_irq isimli bir çekirdek fonksiyonu kullanılıyordu. İşlem bittiğinde de 
    ele alınan kesme free_irq fonksiyonu ile geri bırkılıyordu. Peki BBB'nin GPIO denetleyicisi hangi IRQ numaralarını 
    kullanmaktadır? İşte BBB'deki dört adet GPII denetleyicisinin kullandığı IRQ numaraları baştan bellidir. Bazı kartlardaki
    IRQ hatları programlama yoluyla değiştirilebilmektedir. Dolayısıyla o kartlarda kartın kullandığı IRQ numaralarını 
    "aygıt ağacı (device tree)" üzeirnden değiştirmek mümkün olabilmektedir. Ancak BBB'deki AM335x SoC'undaki denetleyiciler 
    için bu mümkün değildir. GPIO denetleyicilerinin IRQ numaralarını elde etmek için çekirdek içerisinde gpio_to_irq 
    isimli bir fonksiyon bulundurulmuştur:

    #include <linux/gpio.h>

    static int gpio_to_irq(unsigned gpio);

    Fonksiyon parametre olarak aygıt sürücü formatındaki GPIO numarasını alır, geri dönüş değeri olarak GPIO pini için 
    kullanılan IRQ numarasını verir. Fonksiyon başarısız olursa negatif errno değerine geri dönmektedir. 

    Bu biçimdeki aygıt sürücülerde IRQ'nun set edilmesi bir ioctl koduna yaptırılmalıdır. Örneğin:

    static long gpio_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
    {
        long result;
    
        switch (cmd) {
            case IOC_GPIO_IRQ_SET:
                result = set_gpio_irq(arg);
                break;
            default:
                result = -ENOTTY;
        }

        return result;
    }

    Burada IOC_GPIO_IRQ_SET ioctl komutu oluştuğunda set_gpio_irq fonksiyonu çağrılacaktır. Tabii kullanıcı modundan IRQ'yu
    set etmek isteyen kişi irq numarasını ve irq türünü belirtmelidir. Bu bilgileri bir yapı biçiminde ifade edebiliriz:
    
    enum IRQ_TYPE {
        IRQ_EDGE_RISING,
        IRQ_EDGE_FALLING,
        IRQ_EDGE_BOTH,
        IRQ_LEVEL_HIGH,
        IRQ_LEVEL_LOW,
    };

    struct IRQ_INFO {
        int gpio_pin;
        enum IRQ_TYPE irq_type;       
    };

    İşte ioctl fonksiyonun üçüncü parametresine IRQ_INFO türünden bir yaı nesnesinin adresi geçirilmektedir. 

    BBB'nin GPIO denetleyicilerinde IRQ'nun set edilmesi için aşağıdaki yazmaçlar kullanılmaktadır:

    #define GPIO_IRQSTATUS_0        0x2C
    #define GPIO_IRQSTATUS_1        0x30
    #define GPIO_IRQSTATUS_SET_0    0x34
    #define GPIO_IRQSTATUS_SET_1    0x38
    #define GPIO_IRQSTATUS_CLR_0    0x3C
    #define GPIO_IRQSTATUS_CLR_1    0x40

    Burada _0 ve _1 sonekli sembolik sabitler görüyorsunuz. Yukarıda da belirttiğimiz gibi aslında her GPIO denetleyicisi 
    iki IRQ hattı kullanabilmektedir. _0 sonekli hat ilk hat, _1 sonekli hat ise diğer hattır. Tabii sistem programcısı 
    tipik olarak bunlardan birini kullanır. Biz de uygulamamızda _0'lı olanları kullanacağız. GPIO_IRQSTATUS_SET_0 ve 
    GPIO_IRQSTATUS_SET_1 yazmacının ilgili biti 1 yapılırsa o bite ilişkin kesme yazılımsal yolla oluşturulmaktadır. Bu 
    yazmaçlar okunduğunda ise o anda kesme oluşan pin'lerden 1 elde edilmektedir. GPIO_IRQSTATUS_CLR_0 ve GPIO_IRQSTATUS_CLR_1 
    yazmaçlarına yazma yapıldığında 1 olan bitlerdeki kesme olayı sonlandırılır. Okuma uyapıldığında ise 1 olan bitler 
    kesme durumunda olmayan pin'leri belirtmektedir. Burada isminde SET ya da CLR olmayan GPIO_IRQSTATUS_0 ve GPIO_IRQSTATUS_1 
    biçiminde iki yazmaç daha görüyorsunuz. Bu yazmaçlar okunduğunda ilgili pinlerde kesme oluşup oluşmadığı bilgisi elde edilir. 
    Bu yazmaçlara yazma yapıldığında ise 1 olan bitler programlama yoluyla kesme oluşturmakta 0 olan bitler ise kesmeyi ortadan
    kaldırmaktadır.
    
    Burada önemli bir noktayı belirtmek istiyoruz. Bir kesme donanımsal olarak gerçekleştiğinde ya da IRQSTATUS yazmaçları 
    ile programlama yoluyla gerçekleştirildiğinde eğer kesme bu STATUS yazmaçlarında ilgili bit set ya da reset edilerek ortadan 
    kaldırılmazsa sürekli kesme oluşturmaktadır. Bu duruma "IRQ fırtınası (IRQ storm)" da denilmektedir. Bu nedenle bir kesme
    oluştuğunda kesme kodu içerisinde ilgili STATUS yazmaçları yoluyla bu eksme durumunun ortadan kaldırılması gerekir.

    İlgili pini kesme türüne göre konfigüre edebilmek için şu yazmaçlar kullanılmaktadır:

    #define GPIO_LEVELDETECT0       0x140
    #define GPIO_LEVELDETECT1       0x144
    #define GPIO_RISINGDETECT       0x148
    #define GPIO_FALLINGDETECT      0x14C

    Bu yazmaçların ilgili bitler 1 yapıldığında pin ilgili türe konfigüre edilmiş olur. Örneğin bizim chpi1'in 19 numaralı 
    ucunı (yani GPIO51 pinini) düşen kenar tetiklemeli olarak konfigüre etmemiz için GPIO_FALLINGDETECT yazmacının 19 numaralı 
    bitini 1 yapmamız gerekir. Ancak set işlemlerinde güvenlik amacıyla bir yazmacın bir biti set edilirken diğer yazmaçların
    diğer bitlerinin clear edilmesi uygun olur. Çünkü aynı bit birden fazla yazmaçta set edilmişse birden fazla olay yüzüenden 
    kesme oluşur. Tabii bir ucu kesme olarak konfigüre etmedne önce onun aynı zamanda IN olarak konfigüre edilmesi de 
    gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/delay.h>
#include <asm/io.h>
#include "gpio-driver.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("gpio-driver");

#define GPIO_CHIP0_BASE         0x44E07000
#define GPIO_CHIP1_BASE         0x4804C000
#define GPIO_CHIP2_BASE         0x481AC000
#define GPIO_CHIP3_BASE         0x481AE000

#define NGPIO_CHIPS             4
#define PINS_PER_CHIP           32

#define GPIO_OE                 0x134
#define GPIO_DATAIN             0x138
#define GPIO_DATAOUT            0x13C
#define GPIO_CLEARDATAOUT       0x190
#define GPIO_SETDATAOUT         0x194

#define TRYNUM                  10

static int gpio_open(struct inode *inodep, struct file *filp);
static int gpio_release(struct inode *inodep, struct file *filp);
static ssize_t gpio_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t gpio_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static loff_t gpio_llseek(struct file *filp, loff_t off, int whence);
static long gpio_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static inline int read_bit(const uint32_t *gpio_reg, int offset);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = gpio_open,
	.read = gpio_read,
    .write = gpio_write,
	.llseek = gpio_llseek,
    .release = gpio_release,
    .unlocked_ioctl = gpio_driver_ioctl
};

uint8_t *g_gpio_base_addrs[NGPIO_CHIPS];

static int __init gpio_init(void)
{
	int result;
    int i, k;
    unsigned long gpio_physical_addrs[NGPIO_CHIPS] = {
        GPIO_CHIP0_BASE, 
        GPIO_CHIP1_BASE, 
        GPIO_CHIP2_BASE, 
        GPIO_CHIP3_BASE
    };

	if ((result = alloc_chrdev_region(&g_dev, 0, 1, "gpio-driver")) < 0) {
		printk(KERN_INFO "cannot alloc char driver!...\n");
		return result;
	}
	cdev_init(&g_cdev, &g_fops);
	if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
		unregister_chrdev_region(g_dev, 1);
		printk(KERN_ERR "cannot add device!...\n");
		return result;
	}

    for (i = 0; i < NGPIO_CHIPS; ++i) {
        g_gpio_base_addrs[i] = ioremap(gpio_physical_addrs[i], 4096);
        if (g_gpio_base_addrs[i] == NULL) {
            for (k = 0; k < i; ++k)
                iounmap(g_gpio_base_addrs[k]);
            return -ENOMEM;
        }
    }

    printk(KERN_INFO "gpio-driver module initialization...\n");

	return 0;
}

static void __exit gpio_exit(void)
{
    int i;

    for (i = 0; i < NGPIO_CHIPS; ++i)
        iounmap(g_gpio_base_addrs[i]);
	cdev_del(&g_cdev);
	unregister_chrdev_region(g_dev, 1);
    
	printk(KERN_INFO "gpio-driver module exit...\n");
}

static int gpio_open(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "gpio-driver opened...\n");

	return 0;
}

static int gpio_release(struct inode *inodep, struct file *filp)
{
	printk(KERN_INFO "gpio-driver closed...\n");

	return 0;
}

static ssize_t gpio_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    int chip, pin, bitval;
    uint32_t *gpio_reg;

    if (size != 1)
        return -EINVAL;

    chip = *off / PINS_PER_CHIP;
    pin = *off % PINS_PER_CHIP;

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
    iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);
    gpio_reg = (uint32_t *) (g_gpio_base_addrs[chip] + GPIO_DATAIN);
    bitval = read_bit(gpio_reg, pin);

    if (copy_to_user(buf, &"01"[bitval] , size) != 0)
        return -EFAULT;

    /* put_user("01"[bitval], buf); */

	return size;
}

static ssize_t gpio_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    int chip, pin;
    uint32_t *gpio_reg;
    char ch;

    if (size != 1) 
        return -EINVAL;

    chip = *off / PINS_PER_CHIP;
    pin = *off % PINS_PER_CHIP;

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
    gpio_reg = (uint32_t *) (g_gpio_base_addrs[chip] + GPIO_DATAOUT);
    if (copy_from_user(&ch, buf, size) != 0)
        return -EFAULT;
    if (ch == '0')
        iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
    else if (ch == '1')
        iowrite32(ioread32(gpio_reg) | (1 << pin), gpio_reg);
    else 
        return -EINVAL;

	return size;
}

static loff_t gpio_llseek(struct file *filp, loff_t off, int whence)
{
    loff_t newpos;

    switch (whence) {
        case 0:
            newpos = off;
            break;
        case 1:
            newpos = filp->f_pos + off;
            break;
        case 2:
            newpos = (4 * PINS_PER_CHIP) + off;
            break;
        default:
            return -EINVAL;
    }
    if (newpos < 0 || newpos >= 128)
        return -EINVAL;

    filp->f_pos = newpos;

    return newpos;
}

static long gpio_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    long result;
 
    switch (cmd) {
        case IOC_GPIO_TEST:
            break;
        default:
            result = -ENOTTY;
    }

    return result;
}

static inline int read_bit(const uint32_t *gpio_reg, int offset)
{
    int i;
    int first_val, second_val;

    for (i = 0; i < TRYNUM; ++i) {
        first_val = ioread32(gpio_reg) >> offset & 1;
        msleep(5);
        second_val = ioread32(gpio_reg) >> offset & 1;
        if (first_val == second_val)
            return second_val;
    }

    return second_val;
}

module_init(gpio_init);
module_exit(gpio_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/* gpio-driver-test-read.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char ch;

    if ((fd = open("gpio-driver", O_RDWR)) == -1) 
        exit_sys("open");
    
    lseek(fd, 51, 0);
    for (int i = 0; i < 10; ++i) {
        if (read(fd, &ch, 1) == -1)
            exit_sys("read");
        printf("%c\n", ch);
        sleep(1);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* gpio-driver-test-write.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char ch;

    if ((fd = open("gpio-driver", O_RDWR)) == -1) 
        exit_sys("open");
    
    lseek(fd, 60, 0);
    for (int i = 0; i < 10; ++i) {
        ch = '1';
        if (write(fd, &ch, 1) == -1)
            exit_sys("write");
        sleep(1);

        ch = '0';
        if (write(fd, &ch, 1) == -1)
            exit_sys("write");
        sleep(1);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                            139. Ders 04/11/2025 - Salı
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de kesme oluşana kadar blokede bekleten bir aygıt sürücü yazalım. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                            140. Ders 06/11/2025 - Perşembe
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Kesme gelene kadar bekleme yapan aygıt sürücümüzün init fonksiyonunda GPIO denetleyicilerinin taban adresleri bellek tabaklı 
    IO amacıyla bir göstericisi dizisinde saklanıp bunlar için sanal adresler oluşturulmuştur:

    static int __init gpio_init(void)
    {
        int result;
        int i, k;
        unsigned long gpio_physical_addrs[NGPIO_CHIPS] = {
            GPIO_CHIP0_BASE, 
            GPIO_CHIP1_BASE, 
            GPIO_CHIP2_BASE, 
            GPIO_CHIP3_BASE
        };

        if ((result = alloc_chrdev_region(&g_dev, 0, 1, "gpio-driver")) < 0) {
            printk(KERN_INFO "cannot alloc char driver!...\n");
            return result;
        }
        cdev_init(&g_cdev, &g_fops);
        if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
            unregister_chrdev_region(g_dev, 1);
            printk(KERN_ERR "cannot add device!...\n");
            return result;
        }

        for (i = 0; i < NGPIO_CHIPS; ++i) {
            g_gpio_base_addrs[i] = ioremap(gpio_physical_addrs[i], 4096);
            if (g_gpio_base_addrs[i] == NULL) {
                for (k = 0; k < i; ++k)
                    iounmap(g_gpio_base_addrs[k]);
                return -ENOMEM;
            }
        }

        printk(KERN_INFO "gpio-driver module initialization...\n");

        return 0;
    }

    GPIO denetleyicilerinin taban sanal adresleri g_gpio_base_addrs dizisine yerleştirilmiştir. Aygıt sürücümüzde read işleminde
    iki biçimde yapılabilmektedir: Blokeli ve blokesiz. Default mod blokeli moddur. Blokeli modda pin okunmak istediğinde 
    read fonksiyonu bloke olur. İlgili pin değeri lojik 0'a düşürüldüğünde bloke çözülür. Bunun için bir bekleme kuyruğu 
    oluşturulmuş ve GPIO IRQ'su işlenerek bu bekleme kuyruğunda bekleyen thread'ler çalışma kuyruğuna alınmıştır. read işleminde
    her zaman ilgili pin IN olarak konfigüre edilip eğer daha önce kesme konfigürasyonu yapılmamışsa kesme konfigürasyonu da
    düşüne kenar olarak yapılmıştır:

    static ssize_t gpio_read(struct file *filp, char *buf, size_t size, loff_t *off)
    {
        int chip, pin, bitval;
        uint32_t *gpio_reg;
        unsigned long flags;
        struct IRQ_DATA *irq_data;
        int result;

        if (size != 1)
            return -EINVAL;

        if (*off < 0 || *off >= TOTAL_PINS)
            return -EINVAL;

        chip = *off / PINS_PER_CHIP;
        pin = *off % PINS_PER_CHIP;

        irq_data = &g_irq_data[*off];

        if (filp->f_flags & O_NONBLOCK) {
            spin_lock_irqsave(&g_spinlock, flags);

            gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
            iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);

            gpio_reg = (uint32_t *) (g_gpio_base_addrs[chip] + GPIO_DATAIN);
            bitval = read_bit(gpio_reg, pin);

            spin_unlock_irqrestore(&g_spinlock, flags);

            if (copy_to_user(buf, &"01"[bitval] , size) != 0)
                return -EFAULT;

            return size;
        }
                
        gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
        iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);
        
        if (!g_irq_data[*off].irq_flag)
            if ((result = set_gpio_irq(*off )) != 0)
                return result;

        if (wait_event_interruptible(irq_data->wq, atomic_read(&irq_data->wait_flag) != 0) != 0)
            return -ERESTARTSYS;
        atomic_set(&irq_data->wait_flag, 0);
    

        if (copy_to_user(buf, &"01"[bitval] , size) != 0)
            return -EFAULT;

        return size;
    }

    Eğer okuma işlemi dosya O_NONBLOCK ile açılığ yapılmışsa bu durumda hiç bloke oluşmamakta ve doğrudan pin'in değeri 
    okunmaktadır. 

    Kesme oluşturulduğunda çağrılacak kesme kodu da şöyle yazılmıştır:

    static irqreturn_t gpio_irq_handler(int irq, void *dev_id)
    {
        uint32_t *gpio_reg;
        struct IRQ_DATA *irq_data;

        irq_data = (struct IRQ_DATA *)dev_id;

        gpio_reg = (uint32_t *)(g_gpio_base_addrs[1] + GPIO_IRQSTATUS_0);
        iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);

        atomic_set(&irq_data->wait_flag, 1);
        wake_up_interruptible(&irq_data->wq);

        return IRQ_HANDLED;
    }

    Aygıt sürücümüzde her pin için ayrı bir bekleme kuyruğu bulunmaktadır. Pin'lere ilişkin bilgiler global bir dizide 
    tutulmaktadır:

    struct IRQ_DATA {
        int chip;
        int pin;
        int irq_flag;
        atomic_t wait_flag;
        wait_queue_head_t wq;
    };

    static struct IRQ_DATA g_irq_data[TOTAL_PINS];

    IRQ set edilirken request_şrq fonksiyonunda IRQ!nun düşen kenara ilişkin olduğu belirtilmelidir:

    static int set_gpio_irq(int gpio_pin)
    {
        int chip, pin;
        uint32_t *gpio_reg;
        int irqno;
        int result;
        unsigned long flags;

        if (gpio_pin < 0 || gpio_pin >= TOTAL_PINS)
            return -EINVAL;

        chip = gpio_pin / PINS_PER_CHIP;
        pin = gpio_pin % PINS_PER_CHIP;

        spin_lock_irqsave(&g_spinlock, flags);

        gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_LEVELDETECT0);
        iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);

        gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_LEVELDETECT1);
        iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);

        gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_RISINGDETECT);
        iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
        
        gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_FALLINGDETECT);
        iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);

        spin_unlock_irqrestore(&g_spinlock, flags);

        if (mutex_lock_interruptible(&g_mutex) != 0)
            return -ERESTARTSYS;

        g_irq_data[gpio_pin].chip = chip;
        g_irq_data[gpio_pin].pin = pin;
        g_irq_data[gpio_pin].irq_flag = 1;

        init_waitqueue_head(&g_irq_data[gpio_pin].wq);

        if ((irqno = gpio_to_irq(gpio_pin)) < 0) {
            printk(KERN_INFO "Cannot get IRQ number...\n");
            mutex_unlock(&g_mutex);
            return irqno;
        }

        if ((result = request_irq(irqno, gpio_irq_handler, IRQF_TRIGGER_FALLING|IRQF_SHARED, 
                    "irq-driver", &g_irq_data[gpio_pin])) != 0) {
            printk(KERN_INFO "Cannot set IRQ...\n");
            mutex_unlock(&g_mutex);
            return result;
        }

        mutex_unlock(&g_mutex);

        printk(KERN_INFO "IRQ successfully set...\n");

        return 0;
    }

    Aygıt sürücümüzde ioctil işlemi bulunmamaktadır. Ancak biz yine daha sonra eklenebilir diye ioctl işlemlerine yönelik 
    temel kodları da bulundurduk.

    Örneğin kodları bütün olarak aşağıda verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* gpio-deriver.h */

#ifndef HPET_DRIVER_H_
#define HPET_DRIVER_H_

#include <linux/stddef.h>
#include <linux/ioctl.h>

#define GPIO_DRIVER_MAGIC		    'g'

#define IOC_GPIO_IRQ_TEST	       _IO(GPIO_DRIVER_MAGIC, 1)

#endif

/* gpio-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/delay.h>
#include <linux/spinlock.h>
#include <linux/wait.h>
#include <asm/atomic.h>
#include <asm/io.h>
#include <linux/interrupt.h>
#include <linux/gpio.h>
#include "gpio-driver.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Kaan Aslan");
MODULE_DESCRIPTION("gpio-driver");

#define GPIO_CHIP0_BASE         0x44E07000
#define GPIO_CHIP1_BASE         0x4804C000
#define GPIO_CHIP2_BASE         0x481AC000
#define GPIO_CHIP3_BASE         0x481AE000

#define NGPIO_CHIPS             4
#define PINS_PER_CHIP           32
#define TOTAL_PINS              (NGPIO_CHIPS * PINS_PER_CHIP)

#define GPIO_OE                 0x134
#define GPIO_DATAIN             0x138
#define GPIO_DATAOUT            0x13C
#define GPIO_CLEARDATAOUT       0x190
#define GPIO_SETDATAOUT         0x194

#define GPIO_IRQSTATUS_0        0x2C
#define GPIO_IRQSTATUS_1        0x30
#define GPIO_IRQSTATUS_SET_0    0x34
#define GPIO_IRQSTATUS_SET_1    0x38
#define GPIO_IRQSTATUS_CLR_0    0x3C
#define GPIO_IRQSTATUS_CLR_1    0x40

#define GPIO_LEVELDETECT0       0x140
#define GPIO_LEVELDETECT1       0x144
#define GPIO_RISINGDETECT       0x148
#define GPIO_FALLINGDETECT      0x14C

#define TRYNUM                  10

static int gpio_open(struct inode *inodep, struct file *filp);
static int gpio_release(struct inode *inodep, struct file *filp);
static ssize_t gpio_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t gpio_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static loff_t gpio_llseek(struct file *filp, loff_t off, int whence);
static long gpio_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
static irqreturn_t gpio_irq_handler(int irq, void *dev_id);

static int set_gpio_irq(int gpip_pin);
static int reset_gpio_irq(int gpip_pin);
static inline int read_bit(const uint32_t *gpio_reg, int offset);

static dev_t g_dev;
static struct cdev g_cdev;
static struct file_operations g_fops = {
	.owner = THIS_MODULE,
	.open = gpio_open,
	.read = gpio_read,
    .write = gpio_write,
	.llseek = gpio_llseek,
    .release = gpio_release,
    .unlocked_ioctl = gpio_driver_ioctl
};

enum IRQ_TYPE {
    IRQ_EDGE_RISING,
    IRQ_EDGE_FALLING,
    IRQ_EDGE_BOTH,
    IRQ_LEVEL_HIGH,
    IRQ_LEVEL_LOW,
};

struct IRQ_DATA {
    int chip;
    int pin;
    int irq_flag;
    atomic_t wait_flag;
    wait_queue_head_t wq;
};

static uint8_t *g_gpio_base_addrs[NGPIO_CHIPS];
static struct IRQ_DATA g_irq_data[TOTAL_PINS];

static DEFINE_SPINLOCK(g_spinlock);
static DEFINE_MUTEX(g_mutex);

static int __init gpio_init(void)
{
	int result;
    int i, k;
    unsigned long gpio_physical_addrs[NGPIO_CHIPS] = {
        GPIO_CHIP0_BASE, 
        GPIO_CHIP1_BASE, 
        GPIO_CHIP2_BASE, 
        GPIO_CHIP3_BASE
    };

	if ((result = alloc_chrdev_region(&g_dev, 0, 1, "gpio-driver")) < 0) {
		printk(KERN_INFO "cannot alloc char driver!...\n");
		return result;
	}
	cdev_init(&g_cdev, &g_fops);
	if ((result = cdev_add(&g_cdev, g_dev, 1)) < 0) {
		unregister_chrdev_region(g_dev, 1);
		printk(KERN_ERR "cannot add device!...\n");
		return result;
	}

    for (i = 0; i < NGPIO_CHIPS; ++i) {
        g_gpio_base_addrs[i] = ioremap(gpio_physical_addrs[i], 4096);
        if (g_gpio_base_addrs[i] == NULL) {
            for (k = 0; k < i; ++k)
                iounmap(g_gpio_base_addrs[k]);
            return -ENOMEM;
        }
    }

    printk(KERN_INFO "gpio-driver module initialization...\n");

	return 0;
}

static void __exit gpio_exit(void)
{
    int i;

    for (i = 0; i < NGPIO_CHIPS; ++i)
        iounmap(g_gpio_base_addrs[i]);
	cdev_del(&g_cdev);
	unregister_chrdev_region(g_dev, 1);
    
	printk(KERN_INFO "gpio-driver module exit...\n");
}

static int gpio_open(struct inode *inodep, struct file *filp)
{
	return 0;
}

static int gpio_release(struct inode *inodep, struct file *filp)
{
    int i;
    unsigned long flags;

   if (mutex_lock_interruptible(&g_mutex) != 0)
        return -ERESTARTSYS;
    for (i = 0; i < TOTAL_PINS; ++i) {
        if (g_irq_data[i].irq_flag)
            reset_gpio_irq(i);
            atomic_set(&g_irq_data[i].wait_flag, 0);
    }
    mutex_unlock(&g_mutex);

	printk(KERN_INFO "gpio-driver closed...\n");

	return 0;
}

static ssize_t gpio_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    int chip, pin, bitval;
    uint32_t *gpio_reg;
    unsigned long flags;
    struct IRQ_DATA *irq_data;
    int result;

    if (size != 1)
        return -EINVAL;

    if (*off < 0 || *off >= TOTAL_PINS)
        return -EINVAL;

    chip = *off / PINS_PER_CHIP;
    pin = *off % PINS_PER_CHIP;

    irq_data = &g_irq_data[*off];

    if (filp->f_flags & O_NONBLOCK) {
        spin_lock_irqsave(&g_spinlock, flags);

        gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
        iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);

        gpio_reg = (uint32_t *) (g_gpio_base_addrs[chip] + GPIO_DATAIN);
        bitval = read_bit(gpio_reg, pin);

        spin_unlock_irqrestore(&g_spinlock, flags);

        if (copy_to_user(buf, &"01"[bitval] , size) != 0)
            return -EFAULT;

        return size;
    }
            
    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
    iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);
    
    if (!g_irq_data[*off].irq_flag)
        if ((result = set_gpio_irq(*off )) != 0)
            return result;


    if (wait_event_interruptible(irq_data->wq, atomic_read(&irq_data->wait_flag) != 0) != 0)
        return -ERESTARTSYS;
    atomic_set(&irq_data->wait_flag, 0);
   
    if (copy_to_user(buf, &"01"[bitval] , size) != 0)
        return -EFAULT;

    return size;
}

static ssize_t gpio_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    int chip, pin;
    uint32_t *gpio_reg;
    char ch;
    unsigned long flags;

    if (size != 1) 
        return -EINVAL;

    chip = *off / PINS_PER_CHIP;
    pin = *off % PINS_PER_CHIP;

    spin_lock_irqsave(&g_spinlock, flags);

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_OE);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
    gpio_reg = (uint32_t *) (g_gpio_base_addrs[chip] + GPIO_DATAOUT);

    spin_unlock_irqrestore(&g_spinlock, flags);

    if (copy_from_user(&ch, buf, size) != 0)
        return -EFAULT;
    if (ch == '0')
        iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
    else if (ch == '1')
        iowrite32(ioread32(gpio_reg) | (1 << pin), gpio_reg);
    else {
        return -EINVAL;
    }

	return size;
}

static loff_t gpio_llseek(struct file *filp, loff_t off, int whence)
{
    loff_t newpos;
 
    switch (whence) {
        case 0:
            newpos = off;
            break;
        case 1:
            newpos = filp->f_pos + off;
            break;
        case 2:
            newpos = (4 * PINS_PER_CHIP) + off;
            break;
        default:
            return -EINVAL;
    }
    if (newpos < 0 || newpos >= 128)
        return -EINVAL;

    filp->f_pos = newpos;

    return newpos;
}

static long gpio_driver_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    long result;
 
    switch (cmd) {
        case IOC_GPIO_IRQ_TEST:
            break;
        default:
            result = -ENOTTY;
    }

    return result;
}

static irqreturn_t gpio_irq_handler(int irq, void *dev_id)
{
    uint32_t *gpio_reg;
    struct IRQ_DATA *irq_data;

    irq_data = (struct IRQ_DATA *)dev_id;

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[1] + GPIO_IRQSTATUS_0);
    iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);

    atomic_set(&irq_data->wait_flag, 1);
    wake_up_interruptible(&irq_data->wq);

    return IRQ_HANDLED;
}

static int set_gpio_irq(int gpio_pin)
{
    int chip, pin;
    uint32_t *gpio_reg;
    int irqno;
    int result;
    unsigned long flags;

    if (gpio_pin < 0 || gpio_pin >= TOTAL_PINS)
        return -EINVAL;

    chip = gpio_pin / PINS_PER_CHIP;
    pin = gpio_pin % PINS_PER_CHIP;

    spin_lock_irqsave(&g_spinlock, flags);

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_LEVELDETECT0);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_LEVELDETECT1);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_RISINGDETECT);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
    
    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_FALLINGDETECT);
    iowrite32(ioread32(gpio_reg) | 1 << pin, gpio_reg);

    spin_unlock_irqrestore(&g_spinlock, flags);

    if (mutex_lock_interruptible(&g_mutex) != 0)
        return -ERESTARTSYS;

    g_irq_data[gpio_pin].chip = chip;
    g_irq_data[gpio_pin].pin = pin;
    g_irq_data[gpio_pin].irq_flag = 1;

    init_waitqueue_head(&g_irq_data[gpio_pin].wq);

    if ((irqno = gpio_to_irq(gpio_pin)) < 0) {
        printk(KERN_INFO "Cannot get IRQ number...\n");
        mutex_unlock(&g_mutex);
        return irqno;
    }

    if ((result = request_irq(irqno, gpio_irq_handler, IRQF_TRIGGER_FALLING|IRQF_SHARED, 
                "irq-driver", &g_irq_data[gpio_pin])) != 0) {
        printk(KERN_INFO "Cannot set IRQ...\n");
        mutex_unlock(&g_mutex);
        return result;
    }

    mutex_unlock(&g_mutex);

    printk(KERN_INFO "IRQ successfully set...\n");

    return 0;
}

static int reset_gpio_irq(int gpio_pin)
{
    int chip, pin;
    uint32_t *gpio_reg;
    int irqno;
    unsigned long flags;

    chip = gpio_pin / PINS_PER_CHIP;
    pin = gpio_pin % PINS_PER_CHIP;

    spin_lock_irqsave(&g_spinlock, flags);

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_LEVELDETECT0);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_LEVELDETECT1);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_RISINGDETECT);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
    
    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_FALLINGDETECT);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);

    gpio_reg = (uint32_t *)(g_gpio_base_addrs[chip] + GPIO_IRQSTATUS_SET_0);
    iowrite32(ioread32(gpio_reg) & ~(1 << pin), gpio_reg);
    
    if ((irqno = gpio_to_irq(gpio_pin)) < 0) {
        printk(KERN_INFO "Cannot get IRQ number...\n");
        return irqno;
    }
    g_irq_data[gpio_pin].irq_flag = 0;

    spin_unlock_irqrestore(&g_spinlock, flags);

    free_irq(irqno, &g_irq_data[gpio_pin]);

    return 0;
}

static inline int read_bit(const uint32_t *gpio_reg, int offset)
{
    int i;
    int first_val, second_val;

    for (i = 0; i < TRYNUM; ++i) {
        first_val = ioread32(gpio_reg) >> offset & 1;
        msleep(5);
        second_val = ioread32(gpio_reg) >> offset & 1;
        if (first_val == second_val)
            return second_val;
    }

    return second_val;
}

module_init(gpio_init);
module_exit(gpio_exit);

# Makefile

 obj-m += ${file}.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* load (bu satırı dosyaya kopyalamayınız) */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./${module}.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod -m $mode $module c $major 0

/* unload (bu satırı dosyaya kopyalamayınız ) */

#!/bin/bash

module=$1

/sbin/rmmod ./${module}.ko || exit 1
rm -f $module

/* gpio-driver-irq-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include "gpio-driver.h"

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char ch;

    if ((fd = open("gpio-driver", O_RDWR)) == -1) 
        exit_sys("open");

    lseek(fd, 51, 0);

    ch = '1';
    write(fd, &ch, 1);

    for (int i = 0; i < 10; ++i) {
        printf("waiting for pressing button...\n");
        if (read(fd, &ch, 1) == -1)
            exit_sys("read");
        printf("%c\n", ch);
    }
       
    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*---------------------------------------------------------------------------------------------------------------------------
                                        141. Ders 11/11/2025 - Salı
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Şimdi de Raspberry Pi'daki GPIO kullanımı üzerimde duralım. Anımsanacağı gibi Raspberry Pi'da iki sütun haline toplam 
    40 tane IP pin'i vardır. Bu pinlerin bazıları çok işlevlidir. Bazıları ise belirli amaca yöneliktir. Pin numaralandırmaları
    yine soldaki sütun tek numaralar sağdaki sütun çüft numaralar olacak biçimde yapılmıştır:

    1   2
    3   4
    5   6
    7   8
    9   10
    11  12
    13  14
    15  16
    17  18
    19  20
    21  22
    23  24
    25  26
    27  28
    29  30
    31  32
    23  34
    35  36
    37  38
    39  40

    Aşağıda tabloda aygıt pin'lerin sürücü numralandırması ile işlevleri belirtilmektedir. 

    ╔═════╦═══════════╦═══════════════╦════════════════════════════╗
    ║  #  ║ BCM GPIO  ║ Fiziksel Pin  ║   Alternatif Fonksiyon     ║
    ╠═════╬═══════════╬═══════════════╬════════════════════════════╣
    ║  1  ║  GPIO0    ║    Pin 27     ║ ID_SD (I2C0 SDA - EEPROM)  ║
    ║  2  ║  GPIO1    ║    Pin 28     ║ ID_SC (I2C0 SCL - EEPROM)  ║
    ║  3  ║  GPIO2    ║    Pin 3      ║ I2C1 SDA                   ║
    ║  4  ║  GPIO3    ║    Pin 5      ║ I2C1 SCL                   ║
    ║  5  ║  GPIO4    ║    Pin 7      ║ GPCLK0                     ║
    ║  6  ║  GPIO5    ║    Pin 29     ║ GPIO                       ║
    ║  7  ║  GPIO6    ║    Pin 31     ║ GPIO                       ║
    ║  8  ║  GPIO7    ║    Pin 26     ║ SPI0 CE1                   ║
    ║  9  ║  GPIO8    ║    Pin 24     ║ SPI0 CE0                   ║
    ║ 10  ║  GPIO9    ║    Pin 21     ║ SPI0 MISO                  ║
    ║ 11  ║  GPIO10   ║    Pin 19     ║ SPI0 MOSI                  ║
    ║ 12  ║  GPIO11   ║    Pin 23     ║ SPI0 SCLK                  ║
    ║ 13  ║  GPIO12   ║    Pin 32     ║ PWM0                       ║
    ║ 14  ║  GPIO13   ║    Pin 33     ║ PWM1                       ║
    ║ 15  ║  GPIO14   ║    Pin 8      ║ UART0 TXD                  ║
    ║ 16  ║  GPIO15   ║    Pin 10     ║ UART0 RXD                  ║
    ║ 17  ║  GPIO16   ║    Pin 36     ║ GPIO                       ║
    ║ 18  ║  GPIO17   ║    Pin 11     ║ GPIO                       ║
    ║ 19  ║  GPIO18   ║    Pin 12     ║ PWM0 / PCM CLK             ║
    ║ 20  ║  GPIO19   ║    Pin 35     ║ PWM1 / PCM FS              ║
    ║ 21  ║  GPIO20   ║    Pin 38     ║ PCM DIN                    ║
    ║ 22  ║  GPIO21   ║    Pin 40     ║ PCM DOUT                   ║
    ║ 23  ║  GPIO22   ║    Pin 15     ║ GPIO                       ║
    ║ 24  ║  GPIO23   ║    Pin 16     ║ GPIO                       ║
    ║ 25  ║  GPIO24   ║    Pin 18     ║ GPIO                       ║
    ║ 26  ║  GPIO25   ║    Pin 22     ║ GPIO                       ║
    ║ 27  ║  GPIO26   ║    Pin 37     ║ GPIO                       ║
    ║ 28  ║  GPIO27   ║    Pin 13     ║ GPIO                       ║
    ╚═════╩═══════════╩═══════════════╩════════════════════════════╝

    Aşağıdaki şekilde ise pin'lerin başlık üzerinde konumları ve işlevleri gösterilmektedir:

       ┌─────────────────────────────────────────────────┐
    1  │ •  3.3V Power              5V Power  •          │ 2
    3  │ •  GPIO2   (I2C1 SDA)      5V Power  •          │ 4
    5  │ •  GPIO3   (I2C1 SCL)      Ground               │ 6
    7  │ •  GPIO4   (GPCLK0)        GPIO14    •  (TX)    │ 8
    9  │    Ground                  GPIO15    •  (RX)    │ 10
    11 │ •  GPIO17                  GPIO18    •  (PWM)   │ 12
    13 │ •  GPIO27                  Ground               │ 14
    15 │ •  GPIO22                  GPIO23    •          │ 16
    17 │ •  3.3V Power              GPIO24    •          │ 18
    19 │ •  GPIO10  (MOSI)          Ground               │ 20
    21 │ •  GPIO9   (MISO)          GPIO25    •          │ 22
    23 │ •  GPIO11  (SCLK)          GPIO8     •  (CE0)   │ 24
    25 │    Ground                  GPIO7     •  (CE1)   │ 26
    27 │ •  GPIO0   (ID_SD)         GPIO1     •  (ID)    │ 28
    29 │ •  GPIO5                   Ground               │ 30
    31 │ •  GPIO6                   GPIO12    •  (PWM)   │ 32
    33 │ •  GPIO13  (PWM)           Ground               │ 34
    35 │ •  GPIO19  (PWM)           GPIO16    •          │ 36
    37 │ •  GPIO26                  GPIO20    •  (PCM)   │ 38
    39 │    Ground                  GPIO21    •  (PCM)   │ 40
       └─────────────────────────────────────────────────┘
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Aslında Raspberry Pi ile BBB GPIO pin'lerinin kullanılması konusunda oldukça benzemektedir. Raspberry PI'da da GPIO 
    denetleyicisi Broadcom'un SoC çipi içerisindedir ve GPIO denetleyicisine yine bellek tabanlı IO (memory-mapped IO) 
    tekniğiyle erişilmektedir. Yine Raspberry Pi'da da GPIO uçları için sysfs arayüzü BBB'de olduğu gibi kullanılmaktadır. 
    Yine "/sys/class/gpio" dizinine geçilerek ilgili pin'lere ilişkin export edilmiş dizin girişleri yoluyla IO işlemleri 
    komut satırından yapılabilmektedir. Bu dizinin içeriği aşağıdakine benzer olacaktır:

    export  gpiochip512  gpiochip529  gpiochip535  gpiochip567  gpiochip571  unexport

    Burada gpiochipXXX dizinleri GPIO denetleyicilerini belirtmektedir. gpiochip512 denetleyicisi GPIO pinlerini kontrol eden 
    denetleyicidir. Aslında BCM SoC çiplerinde toplamda bir tane GPIO denetleyicisi vardır. Ancak Linux çekirdeği bize sanki 
    birden fazla GPIO denetleyicisi varmış gibi bir görünüm sunmaktadır. SoC içerisinde 54 GPIO ucunun yalnızca 26 tanesi 
    pinlere verilmiş durumdadır. GPIO pin'leri üzerinde işlem yapabilmek için global GPIO numarasının elde edilmesi gerekir. 
    Bu numarada bir taban numaraya GPIO aygıt sürücü numarasının eklenmesiyle elde edilmektedir. Linux çekirdeği GPIO pin'lerini
    gpiochip512 çip diziniyle göstermektedir. Bu bu çip dizinin taban değeri 512'dir. Bu taban değer ilgili dizindeki "base" 
    elde edilebilir:

    $ cat /sys/class/gpio/gpiochip512/base
    512

    Biz hangi aygıt sürücü numarasına ilişkin GPIO pin'ini kullanacaksak o değeri bu numaraya ekleyerek global GPIO numarasını
    elde ederiz. Örneğin GPIO6 pin'ini kullanmak isteyelim. Bu durumda global GPIO pin numarası 512 + 6 = 518 olacaktır. 
    Default durumda herhangi bir pin export edilmemiştir. Export işlemi global pin numarasına göre yapılmaktadır. Export işlemi 
    için BBB'de olduğu gibi  "/sys/class/gpio" dizinindeki "export" dosyası kullanılmaktadır. Örneğin:

    $ echo 518 > /sys/class/gpio/export

    Artık export ettiğimiz pin "/sys/class/gpio" dizininde gözükecektir:

    $ ls /sys/class/gpio
    export  gpio518  gpiochip512  gpiochip529  gpiochip535  gpiochip567  gpiochip571  unexport

    Bu dizine geçildiğinde tıpkı BBB'de olduğu gibi ilgili pin'e erişmek için dosyalar görülecektir:

    $ ls ls /sys/class/gpio/gpio518
    active_low  device  direction  power  subsystem  uevent  value

    Burada yine direction dosyasıyla BBB'de olduğu gibi pin IN ya da OUT olarka konfigüre edilir. value dosyası yoluyla da
    pin'deki değer elde edilip pin'e yeni değer set edilebilmektedir. Dolayısıyla aslında pin export edildikten sonra 
    yapılacak her şey BBB'de olduğu gibidir. 

    Aslında BBB'de belirttiğimiz gibi GPIO pin'leri için sysfs dosya sisteminin kullanılması "deprecated" yapılmıştır. Tıpkı
    BBB'de olduğu gibi Raspberry Pi'da "libgpiod" kütüphanesi benzer biçimde kullanılabilmektedir. Bu kütüphane kullanılırken 
    gpiod_chip_open_by_name fonksiyonunda çip ismi "gpiochip512" biçiminde girilmelidir. Hat numarası da aygıt sürücü GPIO 
    numarası olarak girilmelidir. Örneğin GPIO6 numaralı pin'deki LED şöyle yapılabilir:

    #include <gpiod.h>
    #include <stdio.h>
    #include <unistd.h>

    #define CHIP_NAME       "gpiochip512"
    #define LINE_OFFSET     6
    #define CONSUMER        "led_test"

    int main(void)
    {
        struct gpiod_chip *chip;
        struct gpiod_line *line;
        int ret;

        chip = gpiod_chip_open_by_name(CHIP_NAME);
        if (!chip) {
            perror("gpiod_chip_open_by_name");
            return 1;
        }

        line = gpiod_chip_get_line(chip, LINE_OFFSET);
        if (!line) {
            perror("gpiod_chip_get_line");
            gpiod_chip_close(chip);
            return 1;
        }

        ret = gpiod_line_request_output(line, CONSUMER, 0);
        if (ret < 0) {
            perror("gpiod_line_request_output");
            gpiod_chip_close(chip);
            return 1;
        }

        printf("LED ON\n");
        gpiod_line_set_value(line, 1);
        sleep(1);
        printf("LED OFF\n");
        gpiod_line_set_value(line, 0);

        gpiod_line_release(line);
        gpiod_chip_close(chip);
        return 0;
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Raspbeery PI'daki GPIO denetleyicisinin fiziksel taban adresleri şöyledir:

    #define BCM2835_PERI_BASE   0x20000000  // Pi 1
    #define BCM2836_PERI_BASE   0x3F000000  // Pi 2/3
    #define BCM2711_PERI_BASE   0xFE000000  // Pi 4
    #define BCM2712_PERI_BASE   0x1F00000000  // Pi 5 (64-bit!)

    #define GPIO_OFFSET         0x00200000
    #define GPIO_BASE          (PERI_BASE + GPIO_OFFSET)

    Burada taban fiziksel adres GPIO_BASE sembolik sabiti ile temsil edilmiştir. Bu taban adresten itibaren toplam 41 tane
    32 bitlik bellek tabanlı erişilen yazmaç vardır.

    // Function Select (Her GPIO için 3-bit fonksiyon kodu)
    #define GPFSEL0   0x00  // GPIO 0-9
    #define GPFSEL1   0x04  // GPIO 10-19
    #define GPFSEL2   0x08  // GPIO 20-29
    #define GPFSEL3   0x0C  // GPIO 30-39
    #define GPFSEL4   0x10  // GPIO 40-49
    #define GPFSEL5   0x14  // GPIO 50-53

    // Output Set (Write 1 to set)
    #define GPSET0    0x1C  // GPIO 0-31
    #define GPSET1    0x20  // GPIO 32-53

    // Output Clear (Write 1 to clear)
    #define GPCLR0    0x28  // GPIO 0-31
    #define GPCLR1    0x2C  // GPIO 32-53

    // Pin Level (Read only)
    #define GPLEV0    0x34  // GPIO 0-31
    #define GPLEV1    0x38  // GPIO 32-53

    // Event Detect Status
    #define GPEDS0    0x40
    #define GPEDS1    0x44

    // Rising/Falling Edge Detect
    #define GPREN0    0x4C
    #define GPFEN0    0x58

    // Pull-up/Pull-down
    #define GPPUD     0x94  // Control
    #define GPPUDCLK0 0x98  // Clock 0-31
    #define GPPUDCLK1 0x9C  // Clock 32-53

    Buradaki GPFSELN yazmaçları belli bir pin'i IN, OUT ve diğer bazı biçimlerde konfigüre  etmek için kullanılmaktadır. 
    Her yazmaç 32 bit olmasına karşın yalnızca 10 tane GPIO pin'ini konfigüre edebilmektedir. Bu yazmaçlardaki her 3 bit 
    bir pin'in konfigürasyonunu belirtmektedir:

    000 = Input
    001 = Output  
    010-111 = Alternate Functions (ALT0-ALT5)

    Örneğin GPIO17 pin'ini OUT olarak şöyle konfigüre edebiliriz:

    volatile uint32_t *gpio = (uint32_t*)GPIO_BASE;
    volatile uint32_t *gpfsel1 = gpio + (GPFSEL1 / 4);

    int pin = 17;
    int reg_idx = pin / 10;       // = 1 (GPFSEL1)
    int bit_offset = (pin % 10) * 3;  // = 21

    *gpfsel1 = (*gpfsel1 & ~(7 << bit_offset)) | (1 << bit_offset);

    Tabii bu işlemler aslında aygıt sürücü içerisinde daha güvenli bir biçimde yapılmalıdır. Yukarıda her pin için 3 bitlik 
    bir konfigürasyon bilgisinin bulundurulduğunu belirtmiştik. Oradaki 010 ile 111 arasındaki bitler alternatif konfigürasyon
    numarasını belirtmektedir. Bu alternatif konfigürasyonlar şöyledir:

    BCM  Board  Fonksiyon           ALT0      ALT1    ALT2    ALT3    ALT4    ALT5
    ───────────────────────────────────────────────────────────────────────────────
    0    27     ID_SD (EEPROM)      I2C0_SDA   -       -       -       -       -
    1    28     ID_SC (EEPROM)      I2C0_SCL   -       -       -       -       -
    2    3      I2C1 SDA            I2C1_SDA   -       -       -       -       -
    3    5      I2C1 SCL            I2C1_SCL   -       -       -       -       -
    4    7      GPCLK0              GPCLK0     -       -       -       -       -
    7    26     SPI0 CE1            SPI0_CE1_N -       -       -       -       -
    8    24     SPI0 CE0            SPI0_CE0_N -       -       -       -       -
    9    21     SPI0 MISO           SPI0_MISO  -       -       -       -       -
    10   19     SPI0 MOSI           SPI0_MOSI  -       -       -       -       -
    11   23     SPI0 SCLK           SPI0_SCLK  -       -       -       -       -
    12   32     PWM0                PWM0       -       -       -       -       -
    13   33     PWM1                PWM1       -       -       -       -       -
    14   8      UART0 TXD           UART0_TXD  -       -       -       UART1_TX -
    15   10     UART0 RXD           UART0_RXD  -       -       -       UART1_RX -
    17   11     GPIO                -          -       -       -       -       -
    18   12     PWM0/PCM_CLK        PCM_CLK    -       PWM0    -       -       -
    22   15     GPIO                -          -       -       -       -       -
    23   16     GPIO                -          -       -       -       -       -
    24   18     GPIO                -          -       -       -       -       -
    25   22     GPIO                -          -       -       -       -       -
    27   13     GPIO                -          -       -       -       -       -

    İlgili pin'i alternatif konfigürasyon moduna sokma işlemi şöyle yapılabilir:

    typedef enum {
        GPIO_FUNC_INPUT  = 0b000,
        GPIO_FUNC_OUTPUT = 0b001,
        GPIO_FUNC_ALT0   = 0b100,
        GPIO_FUNC_ALT1   = 0b101,
        GPIO_FUNC_ALT2   = 0b110,
        GPIO_FUNC_ALT3   = 0b111,
        GPIO_FUNC_ALT4   = 0b011,
        GPIO_FUNC_ALT5   = 0b010
    } GPIO_ALT_MODES;

    void gpio_set_function(int pin, GPIO_ALT_MODES alt) 
    {
        int reg = pin / 10;
        int shift = (pin % 10) * 3;
         volatile uint32_t *fsel = gpio_map + reg;
        uint32_t value = *fsel;

        value &= ~(7 << shift);
        value |= (alt << shift);
        *fsel = value;
    }
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    "libgpiod" kütüphanesine alternatif olarak Raspberry Pi için "pigpio" isimli ayrı kütüphane de bulundurulmuştur. Kütüphane 
    indirilebilir:

    $ sudo apt-get install pigpio 

    Aslında zaten Raspberri OS içerisinde bu kütüphane yüklü durumdadır. Kütüphanedeki fonksiyon prototipleri ve diğer 
    birtakım bildrimler <pigpio.h> başlık dosyasında bulunmaktadır. Kütüphane genel değil Raspberry Pi için yazıldığından 
    dolayı kullanımı da oldukça kolaydır. Önce gpioInitialise fonksiyonu çağrılır. Sonra ilgili pin gpioSetMode fonksiyonuyla 
    IN ya da OUT biçiminde konfigüre edilir. Pin'e değer yazmak için gpioWrite fonls,yonu pin'den değer okumak için gpioRead 
    fonksiyonu kullanılmaktadır. İşlemler bittiğinde gpioTerminate fonksiyonu çağrılır. Derleme işlemini yaparken -lpigpio" 
    seçeneği ile bağlama aşamasında kütüphanenin kullanılmasının sağlanması gerekir. Örneğin:

    $ gcc -o sample sample.c -lpigpio 

    Aşağıda GPIO6 numaralı pin'e bağlı LED'i yakıp söndüren bir örnek verilmiştir:

    #include <pigpio.h>

    int main(void) {
        if(gpioInitialise() < 0) return 1;
        
        gpioSetMode(17, PI_OUTPUT);
        
        for(int i = 0; i < 10; i++) {
            gpioWrite(17, 1);
            gpioDelay(500000);
            gpioWrite(17, 0);
            gpioDelay(500000);
        }
        
        gpioTerminate();
        return 0;
    }

    Kütüphanenin daha pek çok özelliği vardır. Ancak yukarıda da belirttiğimiz gibi kullanımı oldukça kolaydır. Kütüphanenin
    dokğmantasytonuna aşağıdaki bağlantıdan erişebilirsiniz:

    https://abyz.me.uk/rpi/pigpio/download.html
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
                                        142. Ders 13/11/2025 - Perşembe
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Bu bölümde UNIX/Linux sistemlerinde seri port haberleşme üzerinde duracağız. Bu haberleşmeyi BBB ve Raspberry Pi üzerinde 
    uygulayacağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Seri port haberleşmesi oldukça eskilere dayanmaktadır. Ancak hala bu haberleşme yöntemi geçerliliğini korumaktadır. 
    Seri port haberleşmesi 80 yılların başlarında PC'lere bilgisayar-modem ve bilgisayar-yazıcı haberleşmesi için standart 
    bir biçimde eklenmiştir. Ancak zamanla USB haberleşmesi yaygınlaşınca seri portlar masaüstü bilgisayarlardan ve notebook'lardan
    kaldırılmıştır. Bu kursta da gördüğümüz gibi özel çeviricilerle seri port haberleşmesi USB yoluyla da sağlanmaktadır. 
    Eskiden PC'lerde seri port'lar 9 pin'li erkek konnektörler biçiminde (bunlara DB-9 portu da denilmektedir) bulunduruluyordu. 
    Bu 9 pin'in anlamları şöyledi:

    ╭─────────────╮
    │ ○ ○ ○ ○ ○   │  (pinler dışarı çıkıntılı)
    │  ○ ○ ○ ○    │
    ╰─────────────╯

    Pin 1: DCD (Data Carrier Detect)
    Pin 2: RxD (Receive Data)
    Pin 3: TxD (Transmit Data)
    Pin 4: DTR (Data Terminal Ready)
    Pin 5: GND (Ground/Toprak)
    Pin 6: DSR (Data Set Ready)
    Pin 7: RTS (Request to Send)
    Pin 8: CTS (Clear to Send)
    Pin 9: RI (Ring Indicator)

    Buradaki isimler "bilgisayar-modem haberleşmesi" dikkate alınarak verilmiştir. Haberleşme için minimum kullanılacak
    uçlar şunlardır:

    RxD: Receive Data
    TxD: Transmit Data
    GND: Toprak

    Minimal bağlantıda iki tarafın RxD uçları karşı tarafın TxD uçlarına bağlanmaktadır. Toprak uçları da katşılıklı 
    bağlanmaktadır:

      PC 1 (DTE)                    PC 2 (DTE)
        Erkek                         Erkek
    ╭───────────╮                 ╭───────────╮
    │ ○ ○ ○ ○ ○ │                 │ ○ ○ ○ ○ ○ │
    │  ○ ○ ○ ○  │                 │  ○ ○ ○ ○  │
    ╰───────────╯                 ╰───────────╯
      1 2 3 4 5                     1 2 3 4 5
      6 7 8 9                        6 7 8 9

    Pin 2 (RxD) ─────────────────────────── Pin 3 (TxD)
                    çapraz
    Pin 3 (TxD) ─────────────────────────── Pin 2 (RxD)

    Pin 5 (GND)─────────────────────────── Pin 5 (GND)

    PC'lerdeki seri port'lar RS-232 denilen voltaj standartlarına uygun biçimde üretilmektedir. RS-232 standardında lojik 1 
    lojik 0 için şu gerilim seviyeleri kullanılmaktadır:

    Lojik 0: +3V ile +15V arası, tipik olarak +5V ile +12V
    Lojik 1: -3V ile -15V arası, tipik olarak -5V ile -12V

    Bu yüksek gerilim seviyeleri iki bilgisayar arasında uzun kablolarla (örneğin 20 metre) bağlantı yapılabilmesini 
    sağlamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Seri haberlşme aslında "UART (Universial Asynchronous Receiver and Transmitter)" denilen denetleyicilerle yapılmaktadır.
    Eski PC'lerde UART denetleyicisi olarak "Intel 8250" kullanılıyordu. Sonra "NS 16550" denetleyicileri kullanılmaya başlandı. 
    Artık UART denetleyicileri SoC'ların ya da chipset'lerin içerisinde bulunmaktadır. Klasik UART denetleyicilerinin 
    uçları eskiden RS-232 voltaj seviyelerine yükseltilerek seri port'un pin'lerine veriliyordu. UART denetleyicileri TTL 
    düzeyinde çık veriyordu. TTL çıkışları mikro elektronik uygulamalarında kullanılmaktadır. TTL voltaj seviyeleri tipik 
    olarak şöyledir:

    Lojik 0: 0V - 0.8V 
    Lojik 1: 2V - 5V

    RS-232 çıkışlarını doğrudan TTL düzeyinde çalışan UART denetleyicilerinin uçlarına bağlamayınız. Bunun için RS-232'den 
    TTL'e dönüştürme yapan dönüştürücüler bulunmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Seri port haberleşmesi oldukça yalındır. Haberleşme için iki tarafın UART denetleyicisi eşit hızlarda ve aynı biçimde 
    konfigüre edilir. Sistem programcısı UART denetleyicisine bilgileri byte düzeyinde verir. UART denetleyicisi bu bilgiyi 
    bitlerine ayırır ve TxD ucundan belirlenen hızda kodlar. Gönderici tarafın TxD uzu alıcı tarafında RxD ucuba bağlı olduğu 
    için gönderilen bitler alıcı taraftaki UART tarafından alınmaktadır. Alıcı taraftaki UART bu bitleri birleştirir, byte
    biçimine getirir. Sistem programcısı onu byte olarak alır. Bu haberleşmeye "asenkron (asynchronous)" denmesinin nedeni
    byte'lar arasındaki sürenin değişebilmesindendir. Ancak byte'ların bitleri aynı hızda kodlanıp alınmaktadır. 

    Peki UART haberleşmesinde alıcı taraftaki UART bilginin gönderilmeye başlandığını nasıl anlamaktadır? İşte bilgi 
    gönderilmiyorken TxD hattı lojik 1 seviyesinde tutulur. Bit'ler gönderilme başlanmadan önce hat bir periyot lojik 0'a 
    çekilir. Buna "start bit" denilmektedir. Böylece karşı taraftaki UART bilginin gönderilmeye başlandığını anlar. Sonra 
    iki taraf aynı frekansta bit'leri gönderip alırlar. Ancak hattın yeniden lojik 1 seviyesine çekilerek bırakılması 
    gerekmektedir. İşte en sonunda hattın yeniden lojik 1 seviyesine çekilmesine "stop bit" denilmektedir. Hat lojik 1 
    seviyesine bir periyot değil iki periyot da çekilebilir. Buna da stop bit sayısı denilmektedir. Genellikle 1 stop bit 
    kullanılmaktadır. Ancak alıcının yavaş olduğu durumlarda artık çok seyrek de olsa 2 stop bit kullanılabilmektedir. UART 
    haberleşmesinde gönderen tarafın gönderdiği bitleri alan tarafın düzgün alıp almadığını belirlemek için "parity" hata 
    kontrol biti de data bitlerinden sonra isteğe bağlı gönderilip alınabilmektedir. Parity kullanılmayabilir. Bu durumda 
    data bitlerinden sonra hemen stop bit gönderilir. Parity kullanılacaksa "tek parity (odd parity)" ya da "çift parity 
    (even parity)" biçiminde iki seçenek söz konusudur. Tek parity "data bitlerindeki 1'lerin sayısını tek yapmak için geçerken
    biti", çift parity ise "data bitlerindeki 1'lerin sayısını çift yapmak için gereken biti" belirtmektedir. Örneğin:

    0100 0011 

    Buradaki 8 bitin tek parity'si 0, çift parity'si ise 1'dir. Artık parity kullanımı hemen hemen ortadan kalkmıştır. 

    UART haberleşmesi "full duplex" bir haberleşmedir. Yani UART haberleşmesinde iki taraf da birbirlerine aynı anda bilgi 
    gönderip bilgi alabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Haberleşmenin türü ne olursa olsun hepsinde "akış kontolü (flow control)" denilen bir olgu vardır. Akış kontrolü "alan 
    tarafın gönderen tarafı geçici olarak durdurmasını ve sonra yeniden göndermeye devam ettirmesini sağlayan" bir mekanizmadır. 
    Gönderen tarafın gönderdiği bilgiler alan taraf tarafından hemen işlenemeyebilir. Bazen alan taraf bunları işlemekte 
    yavaş kalabilir. Bu tür durumlarda gönderen tarafın gönderdiği bilgiler bir tamponda bekletilir. Alan taraf bilgileri 
    bu tapon alarak işler. Ancak alan taraf gecikirse bu tampon da taşabilmektedir. O halde alan tarafın gönderen tarafı geçici 
    olarak durdurması gerekmektedir. Tabii alıcı taraf önceden belirlenen hızda bilgiyi alıp işleyebiliyorsa bir sorun oluşmaz. 
    Ancak iletimin güvenli hale getirilmesi için akış kontrolü önerilmektedir. 

    UART haberleşmesinde iki tür akış kontrolü uygulanabilmektedir:

    1) Donanımsal akış kontrolü
    2) Yazılımsal akış kontrolü

    Donanımsal akış kontrolü tipik olarak UART'ın iki ucundan sağlanmaktadır. Bunun için tipik olarak olarak RTS (request to 
    Send) ve CTS (Clear to Send) uçları kullanılmaktadır. Bir RTS ucu diğer tarafın CTS ucuna bağlanmaktadır. Böylece bir 
    taraf RTS ucuna bir işaret gönderdiğinde diğeri bunu CTS ucundan okuyabilmektedir. Yukarıda da belirttiğimiz gibi 
    pin'lere RTS ve CTS isimleri geleneksel bilgisayar-modem haberlemesi dikkate alınarak verilmiştir. Tipik akış kontrolü 
    kontolü şöyle yapılmaktadır: Alan taraf tipik olarak RTS ucunu lojik 1 seviyesinde tutar. Gönderen taraf da CTS ucuyla 
    bu değeri okur. Bu değer lojik 1 olduğu sürece gönderen taraf göndermeye devam eder. Eğer alıcı taraf CTS ucunu lojik 0 
    değerine çekerse gönderen taraf artık bu uç lojik 1 seviyesine  çekilene kadar bekler. Tabii diğer taraf da karşı tarafa 
    aynı biçimde akış kontrolü uygulamaktadır. RTS/CTS akış kontrolü farklı biçimlerde de uygulanabilmektedir. Eski UART 
    denetleyicileri bu RTS/CTS akış kontrolünü donanımsal düzeyde yapmıyordu. Ancak daha sonra pek çok UART devresi bunu 
    donanımsal biçimde de yapar hale gelmiştir. 

    Yazılımsal akış kontrolünde yukarıdaki senaryo elektriksel olarak değil alan tarafın gönderen tarafa özel karakterler
    göndermesiyle sağlanmaktadır. Bunun için kullanılan tipik yazılımsal protokole XON/XOFF protokolü denilmektedir. Alıcı 
    taraf gönderici tarafı durdurmak için XOFF özel karakterini gönderir. Gönderen taraf bu karakteri aldığında göndermeyi 
    durdurur. Alıcı taraf gönderici tarafın devam etmesini sağlamak için XON özel karakterini göndermektedir. XON ve XOFF
    karakteri olarak aşağıdaki karakterler kullanılmaktadır:

    Dec  Hex  Oct  Ctrl   Açıklama
    ───────────────────────────────────────
    17  0x11 021  ^Q     XON  (Devam)
    19  0x13 023  ^S     XOFF (Dur)

    XON/XOFF protokolü tamamen programlama yoluyla oluşturulmaktadır. 

    Peki akış kontrolünde karşı taraf ne zaman durdurulup ne zaman devam ettirilmelidir? Tipik olarak sistem programcıları 
    tahsis ettikleri tampon %70 ile %90 arasında bir doluluk seviyesine geldiğinde karşı tarafı durdurmakta tampon %10 ile 
    %30 civarında bir doluluk seviyesine düştüğünde ise karşı tarafı devam ettirmektedir. 

    Peki sistem programcısı UART'ta çok hızlı veri gönderirse ne olur? İşte UART denetleyicilerinin içerisinde de donanımsal 
    biçimde organize edilmiş bir FIFO tampon vardır. Tabii tampon da dolarsa gönderen taraf UART'a bilgiyi gönderdiği halde 
    UART bunu tamponunda saklayamaz ve bilgi kaçırılabilir. Ancak gönderen taraf zaten UART'ın bunu aldığını anlayabilmektedir. 
    Eski Intel 8250 UART denetleyicilerinde böyle bir donanımsal tampon yoktu. Daha sonra NS 16550 modellerine 16 byte'lık 
    gönderme ve alma tamponları eklendi. Bugünkü SoC içerisindeki UART denetleyicilerinde genel olarak 64'lük ya da 32'lik 
    donanımsal tamponlar bulunmaktadur. USB seri dönüştürücülerde bu tamponların uzunlukları 256 gibi yüksek değerlerdedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda programcının UART denetleyicisine byte verdiğini ondan byte aldığını belirttik. Byte'ın bitlere dönüştürülerek 
    gönderilip alınmasını AURT denetleyicisi yapıyordu. İşte UART terminolojisinde gönderilecek bit öbeğine "data bitleri" 
    denilmektedir. UART denetleyicileri 5, 6, 7, 8 data bitlerini desteklemektedir. Örneğin biz UART denetleyicisini 5 data 
    bit olarak konfigüre edersek ancak ona 0 ile 31 arasında bir değer gönderebiliriz. Peki neden gönderilecek bilgi standart 
    8 bit değil de duruma göre ayarlanabilen bir değerdedir? İşte bunun amacı özel durumlarda hız kanacı sağlamaktır. Örneğin 
    kişi düz metin göndermek isteyebilir. Bu durumda 5 bit yetebilir. Daha az bit gönderildiği için daha hızlı bir iletişim 
    sağlanır. Ancak tabii günümüzde UART data bitlerinin sayısı 8 olacak biçimde konfigüre edilmektedir. 
    Bu durumda temel UART ayarları şunlardan olulmaktadır:

    - Data bitlerinin sayısı
    - Stop bitlerinin sayısı (1 ya da 2)
    - Parity kullanılacak mı? Kullanılacaksa tek parity mi çift parity mi?
    - Gönderim alma hızı (saniyedeki bit sayısı)

    UART'ın gönderim alma hızı "baud" terimiyle ifade edilmektedir. Tabii bunun içerisine start bit ve stop bit varsa parity 
    biti de dahildir. Yani örneğin data bitlerinin sayısı 8 ise aslında byte'lar arasında boşluk olmasa bile 10 bit ya da 11
    ya da 12 bit iletim yapılmaktadır. Haberleşmede iletimi hedeflenen bilginin kendisine İngilizce "payload" da denilmektedir. 
    Örneğin data bitlerinin sayısı 8 ise payload 8 bittir. Ancak aslında daha fazla bit karşı tarafa gönderilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde seri port programlaması üç biçimde yapılabilmektedir:

    1) Standart POSIX termios kütüphanesini kullanmak 
    2) Özel kütüphaneleri kullanmak
    3) Aygıt sürücü yazmak yoluyla ya da mevcut aygıt sürücüleri doğrudan kullanmak yoluyla

    Tabii en taşınabilir yöntem standart "termios" arayüzünü kullanmaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
    BBB'lerde toplam 6 tane UART denetleyicisi ve uç takımı vardır. Bunlardan biri (sistem boot edilmeden önce terminal 
    olarak kullanılan çıkış) 6 pinli GPIO P9 başlığımım yanında bulunmaktadır. Geri kalan 5 tanesi GPIO pin'lerinin içerisinde 
    multiplexed edilmiştir. Yani bu 5 UART uçları GPIO olarak da UART olarak da konfigüre edilebilmektedir. Dolayısıyla 
    GPIO soketlerindeki UART uçlarını kullanmadan önce bu uçların GPIO olarak değil de UART olarak konfigüre edilmesi 
    gerekir. 
    
    Biz kursumuzda temek denemeleri UART2 ile UART4 uçlarını karşılıklı bağlayarak yapacağız. Dolayısıyla örneğin UART2'den
    bilgi gönderdiğimizde onu UART4'ten, UART4'ten bilgi gönderidğimizde ise onu UART2'den okuyabileceğiz.  
---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------*/


/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/


/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/


