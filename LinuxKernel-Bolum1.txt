/*----------------------------------------------------------------------------------------------------------------------

                                       C ve Sistem Programcıları Derneği

     "Linux Kernel - İşletim Sistemlerinin Tasarımı ve Gerçekleştirilmesi" Kursunda Yapılan Örnekler ve Özet Notlar
                                                   1. Bölüm

                                              Eğitmen: Kaan ASLAN

        Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.
        Kaynak belirtmek için aşağıdaki referansı kullanabilirsiniz:

    Aslan, K. (2025), "Linux Kernel - İşletim Sistemlerinin Tasarımı ve Gerçekleştirilmesi Kursu, Sınıfta Yapılan 
        Örnekler ve Özet Notlar", C ve Sistem Programcıları Derneği, İstanbul.

                    (Notları sabit genişlikli font kullanan programlama editörleri ile açınız.)
                        (Editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz.)

                                        Son Güncelleme: 29/08/2025 - Cuma

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
                                            1. Ders 19/07/2025 - Cumartesi
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Kurs katılımcılarıyla tanışıldı.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Kursun amacı, kapsamı ve genel işleyişi hakkında açıklamalar yapıldı. Yardımcı kaynaklar (kitaplar, dokümanlar ve 
    web sayfaları) tanıtıldı.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Kursumuz için bir sanal makineye herhangi bir Linux dağıtımının kurulması gerekmektedir. Dağıtım minimalist biçimde 
    kurulabilir. Ancak Linux içerisinde C derleyicisinin (gcc ya da clang) ve binary utility araçlarının bulunuyor olması 
    gerekir. Kursumuzda Linux kaynak kodları üzerinde değişiklikler yapıp çekirdeği yeniden derleyerek çeşitli denemeler 
    yapacağız. Bu nedenle kurduğunuz sistemin bir kopyasını da saklamanızı salık veriyoruz.

    Kurusumuzda Debian türevi bir Linux dağıtımının kurulmuş olduğu varsayılacaktır. Biz bazı konularda açıklamalar 
    yaparken Debian dağıtımının "apt" paket sistemini kullanacağız.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Kursumuzda Linux işletim sisteminin kaynak kodlarında gezinmek için https://elixir.bootlin.com/linux/ sitesini 
    kullanacağız. Bu sitede Linux'un 0.01 versiyonundan günümüzdeki en son versiyonuna kadar bütün resmi versiyonlarının 
    kaynak kodları bulunmaktadır ve bu kaynak kodlar üzerinde gezintiler (navigation) yapılabilmektedir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
												2. Ders 20/07/2025 - Pazar
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    İşletim sistemleri bilgisayar donanımının kaynaklarını yöneten, bilgisayar donanımı ile kullanıcı arasında arayüz 
    oluşturan sistem programlarıdır. Bilgisayar bilimlerinin akademik öncülerinin çoğu işletim sistemlerini bir kaynak 
    yöneticisi (resource manager) olarak tanımlamıştır.

            +----------------------+
            | Uygulama Programları |
            +----------------------+
        +-----------------------------+
        |       İşletim Sistemi       |
        +-----------------------------+
    +-----------------------------------+
    |        Bilgisayar Donanımı        |
    +-----------------------------------+

    İşletim sistemlerinin yönettiği kaynakların en önemlileri şunlardır:

    - CPU: İşletim sistemi hangi programın ne zaman, ne kadar süre için CPU'ya atanacağına karar verip bu işlemleri 
    gerçekleştirmektedir.

    - Ana Bellek (Main Memory (RAM)): İşletim sistemi programların ana belleğin neresine yükleneceğine karar verir 
    ve ana bellek kullanımını düzenler.

    - İkincil Bellekler: İşletim sistemi bir dosya sistemi (file system) oluşturarak dosyaların parçalarını ikincil 
    belleklerde etkin bir biçimde tutar ve kullanıcılara bir dosya kavramıyla sunar.

    - Çevre Birimleri (klavye, fare, yazıcı vs.): İşletim sistemi fare, klavye, yazıcı gibi çevre birimlerini yöneterek 
    onları kullanıma hazır hale getirir. Yardımcı işlemcileri (denetleyicileri) programlayarak onların işlev görmesini 
    sağlamaktadır.

    - Ağ İşlemleri: İşletim sistemi ağa ilişkin donanım birimlerini yöneterek dışarıdan gelen bilgileri onları talep 
    eden programlara iletir.

    İşletim sistemleri kaynak yönetimine göre alt sistemlere ayrılarak da incelenebilmektedir. Örneğin işletim 
    sisteminin "çizelgeleyici (scheduler)" alt sistemi demekle CPU yönetimini sağlayan alt sistemi kastedilmektedir. 
    Ana bellek yönetimi (memory management) yine soyutlanarak incelenen önemli alt sistemlerden biridir. İşletim 
    sistemlerinin ikincil bellek yönetimine "dosya sistemi (file system)" da denilmektedir. Tabii bütün bu sistemler 
    birbirinden kopuk olarak değil birbirleriyle ilişkili bir biçimde işlev görmektedir. Bu durumu insanın "solunum 
    sistemi", "dolaşım sistemi", "sinir sistemi", "boşaltım sistemi" gibi alt sistemlerine benzetebiliriz. Bu alt 
    sistemlerin birinde bile çalışma bozukluğu oluşsa insan yaşamını yitirebilmektedir.

    İşletim sistemleri yapı olarak iki kısımdan oluşmaktadır: Çekirdek (kernel) ve kabuk (shell). Çekirdek işletim 
    sisteminin donanımı kontrol eden ve kaynakları yöneten motor kısmıdır. Aslında işletim sistemi denildiğinde akla 
    çekirdek gelmektedir. Kabuk ise işletim sisteminin kullanıcı ile arayüz oluşturan önyüzüdür. Örneğin UNIX/Linux 
    sistemlerinde bash gibi komut satırı, GNOME, KDE gibi pencere yöneticileri, Windows'taki masaüstü (Explorer), 
    macOS'teki masaüstü (Aqua) bu işletim sistemlerinin kabuk kısımlarını oluşturmaktadır.

    +-----------------------------------+
    |           Kabuk (Shell)           |
    |   +---------------------------+   |
    |   |                           |   |
    |   |    Çekirdek (Kernel)      |   |
    |   |                           |   |
    |   +---------------------------+   |
    +-----------------------------------+

    Pekiyi işletim sistemi bu kadar temel donanım yönetimini sağlıyorsa işletimi olmadan programlama yapılabilir mi? 
    İşletim sistemi olmadan programlama faaliyetine halk arasında "bare metal programlama" denilmektedir. Bare metal 
    programlama gömülü sistemlerde, mikrodenetleyicilerin kullanıldığı uygulamalarda kullanılmaktadır. Bare metal 
    programlama genellikle özel bir amaca hizmet edecek biçimde yapılmaktadır. Amaçlar fazlalaştığı zaman ve sistem 
    karmaşıklaştığı zaman artık işletim sistemlerine gereksinim duyulmaktadır.

    Bazı kontrol yazılımları işletim sistemlerinin bazı etkinliklerini de sağlamaktadır. Bir kontrol yazılımının 
    işletim sistemi olarak isimlendirilmesi için yukarıda açıkladığımız kaynak yönetimlerinin önemli bir bölümününü 
    sağlıyor olması gerekir. Bu kaynak yönetimlerinin çoğunu sağlamayan kontrol yazılımlarına genel olarak "firmware" 
    de denilmektedir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    İşletim sistemleri çeşitli biçimlerde sınıflandırılabilmektedir:

    - Proses Yönetimine Göre: Aynı anda tek bir programı çalıştıran işletim sistemlerine "tek prosesli (single processing)", 
    aynı anda birden fazla programı çalıştırabilen işletim sistemlerine ise "çok prosesli (multiprocessing) işletim sistemleri 
    denilmektedir. Örneğin DOS işletim sistemi tek prosesli bir sistemdi. Biz bu işletim sisteminde bir programı çalıştırırdık 
    ancak çalıştırdığımız program sonlanınca başka bir programı çalıştırabilirdik. Halbuki Windows, UNIX/Linux, MacOS gibi 
    işletim sistemleri çok prosesli işletim sistemleridir.

    - Kullanıcı Sayısına Göre: Birden fazla farklı kullanıcının çalışabildiği sistemlere "çok kullanıcılı (multiuser)", 
    tek bir kullanıcının çalışabildiği sistemlere "tek kullanıcılı (single user)" sistemler denilmektedir. Genellikle 
    çok prosesli işletim sistemleri aynı zamanda çok kullanıcılı sistemlerdir. Birden fazla kullanıcının söz konusu 
    olduğu sistemlerde kullanıcıların yetkilerinin ayarlanması, kullanıcıların birbirlerinin alanlarına erişmesinin 
    engellenmesi, sistem kaynaklarını belli oranlarda bölüşmesi gerekebilmektedir. Örneğin DOS tek kullanıcılı bir 
    sistemdi. Halbuki Windows, UNIX/Linux ve macOS sistemleri çok kullanıcılı sistemlerdir.

    - Çekirdek Yapısına Göre: İşletim sistemleri çekirdek yapısına göre "tek parçalı çekirdekli (monolithic kernel)" 
    ve "mikro çekirdekli (microkernel)" olmak üzere ikiye ayrılmaktadır. Tek parçalı çekirdekli işletim sisteminin büyük 
    kısmı çekirdek modunda çalışır. Mikro çekirdekli sistemlerde ise çekirdek modunda çalışan kısım minimize edilmeye 
    çalışılmıştır. Aslında tek parçalı ve mikro çekirdekli tesarımları bir spektrum olarak düşünebiliriz. (Örneğin bu 
    spektrumda bazı çekirdekler tek parçalı tarafa yakın bazıları ise mikro tarafa yakın olabilmektedir.)

    - Dışsal Olaylarla Yanıt Verebilme Özelliğine Göre: İşletim sistemleri dışsal olaylara yanıt verme bakımından gerçek 
    zamanlı olan (real-time) ve gerçek zamanlı olmayan (non-real-time) sistemler olmak üzere ikiye ayrılabilir. Dışsal 
    olaylara hızlı bir biçimde yanıt verebilecek çekirdek yapısına sahip olan işletim sistemlerine "gerçek zamanlı (real-time) 
    işletim sistemleri denilmektedir. Gerçek zamanlı işletim sistemleri de kendi aralarında "katı (hard real-time)" ve 
    "gevşek (soft real-time)" işletim sistemleri olmak üzere ikiye ayrılabilmektedir. Katı gerçek zamanlı sistemler dışsal 
    olaylara yanıt verme bakımından çok güvenilir olma iddiasındadır. Gevşek gerçek zamanlı sistemler ise bu konuda daha 
    toleranslıdır.

    - Dağıtıklık Durumuna Göre: İşletim sistemleri dağıtıklık durumuna göre "dağıtık olan (distributed)" ve "dağıtık olmayan 
    (non-distributed)" sistemler biçiminde ikiye ayrılabilmektedir. Dağıtık işletim sistemlerinde sistem birden fazla 
    bilgisayardan oluşan tek bir sistem gibi davranmaktadır. Örneğin 10 tane makineyi tek bir sistem olarak düşünebilirsiniz. 
    Bu durumda bu bilgisayarların kaynakları (örneğin diskleri ve CPU'ları) bu 10 makine tarafından paylaşılmaktadır. 
    Windows, UNIX/Linux ve macOS dağıtık işletim sistemleri değildir. Ancak bu sistemlerde dağıtık uygulamalar yapılabilmektedir.

    - Donanım Özelliğine Göre: Neredeyse her yaygın masaüstü işletim sisteminin bir mobil versiyonu da oluşturulmuştur. 
    IOS (Iphone Operating System) ve ipadOS Apple firmasının (yani macOS sistemlerinin) mobil işletim sistemleridir. Android 
    bir çeşit mobil Linux sistemi olarak değerlendirilebilir. Android projesinde Linux çekirdeği alınmış, biraz özelleştirilmiş, 
    bazı parçaları atılmış, buna bir mobil arayüz giydirilmiş ve sistem akıllı telefonlara ve tabletlere uygun hale getirilmiştir. 
    Nokia eskiden Symbian sistemlerinde büyük bir pazar payına sahipti. Ancak bu firma akıllı telefon geçişini iyi yönetemedi. 
    MeeGo ve Maemo gibi işletim sistemlerini denedi. Sonra ekonomik sıkıntılar sonucunca büyük ölçüde Microsoft tarafından 
    satın alındı. Windows'un mobil versiyonuna genel olarak Windows CE denilmektedir. Windows CE'nin akıllı telefonlar ve 
    tabletler için özelleştirilmiş biçimine ise Windows Mobile ve Windows Phone denilmektedir. Ancak Microsoft 2010 yılında 
    Windows Mobile işletim sistemini 2017'de de Windows Phone işletim sistemini sonlandırmıştır ve bu alandaki rekabetten 
    tamamen çekilmiştir. Windows CE ise Windows IoT Core ismiyle farklı bir tasarımla evrimleşerek devam ettirilmektedir.

    - Kaynak Kod Lisansına Göre: Kaynak kod lisansına göre işletim sistemlerini kabaca "açık kaynak kodlu (open source)" 
    ve "mülkiyete bağlı (proprieatary)" olmak üzere ikiye ayırabiliriz. Açık kaynak kodlu işletim sistemleri değişik açık 
    kaynak kod lisanslarına sahip olabilmektedir. Bunların kaynak kodları indirilip üzerinde değişiklikler yapılabilmektedir. 
    Örneğin Windows işletim sistemi mülkiyete sahiptir. Oysa Linux, BSD sistemleri, Solaris, Android gibi sistemler açık 
    kaynak kodludur. macOS sistemlerinin ise çekirdeği açık diğer kısımları (örneğin kabuk kısmı ve diğer katmanları) 
    kapalıdır.

    - Kaynak Kodun Özgünlüğüne Göre: Bazı işletim sistemleri bazı işletim sistemlerinin kodları alınıp değiştirilerek 
    oluşturulmuştur (örneğin Android ve macOS'ta olduğu gibi). Bazı işletim sistemlerinin kodları ise sıfırdan yazılmıştır. 
    Kodları sıfırdan yazılan yani orijinal kod temeline dayanan işletim sistemlerinden bazıları şunlardır:

    AT&T UNIX
    DOS
    Windows
    Linux
    BSD'ler (belli bir yıldan sonra)
    Solaris
    XENIX
    VMS

    Burada orijinal mimari ile orijinal kod tabanını birbirine karıştırmamak gerekiyor. Linux UNIX işletim sisteminin 
    mimarisini temel almıştır. Ancak tüm kodları sıfırdan yazılmıştır. Yani orijinal AT&T UNIX sistemindeki kaynak kodların 
    bir bölümü kopyalanarak kullanılmamıştır.

    - GUI Çalışma Desteğine Göre: Bazı işletim sistemleri GUI çalışma modelini doğrudan desteklerken bazıları desteklememektedir. 
    Örneğin Windows sistemleri çekirdekle entegre edilmiş bir GUI çalışma modeli sunmaktadır. UNIX/Linux sistemleri de 
    X Window (ya da X11) ve Wayland katmanlarıyla benzer bir model sunmaktadır. Fakat örneğin DOS işletim sisteminin böyle 
    bir doğal GUI desteği yoktu.

    - Ağ Üzerinde Hizmet Alıp Verme Rollerine Göre: İşletim sistemlerini ağ altında hizmet alıp verme rollerine göre 
    "istemci (client) ve sunucu (server) biçiminde de iki gruba ayırabiliriz. Bazı işletim sistemlerinin istemci versiyonları 
    birbirlerinden ayrılmıştır. Bazılarında ise bu ayrım yapılmamıştır. Örneğin Windows 7, 8, 10, 11 sistemleri bu bakımdan 
    istemci (client) sistemleridir. Halbuki Windows Server 2016, 2019 sunucu sistemleri olarak piyasaya sürülmüştür. 
    Eskiden Mac OS X'in istemci ve sunucu versiyonları farklıydı. Fakat Mac OS X 10.7 (Lion) ile birlikte istemci ve 
    sunucu versiyonları birleştirildi. Linux dağıtımlarının çoğu da hem istemci hem de sunucu olarak kullanılabilmektedir. 
    Ancak bazı dağıtımların ise istemci ve sunucu versiyonları farklıdır. Pekiyi işletim sistemlerinin istemci ve sunucu 
    versiyonları arasındaki farklılıklar nelerdir? Kabaca iki tür farklılığın olduğunu söyleyebiliriz. Birincisi çekirdekle 
    ilgili farklılıklardır. Genellikle sunucu sistemlerinde çizelgeleyici alt sistemde istemci sistemlerine göre farklılıklar 
    bulunmaktadır. İkincisi ise barındırdıkları yardımcı yazılımlardır. işletim sistemlerinin sunucu versiyonları hazır bazı 
    sunucu programlarını da içermektedir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Şimdi de işletim sistemlerinin tarihsel gelişimi üzerinde duracağız. 1940’lı yıllarda ilk elektronik bilgisayarlar 
    yapıldığında henüz bir işletim sistemi kavramı yoktu. Bu bilgisayarlara program yazacak olanlar işletim sistemi 
    faaliyetlerini de kendileri yapmak zorunda kalıyordu. (Yani şimdi mikrodenetleyicilere bare metal kod yazanlarda 
    olduğu gibi.) Transistör bulunduktan sonra 1950’li yıllarda artık elektronik bilgisayarlar yavaş yavaş transistörlerle 
    yapılmaya başlandı. Transistörlerin ortaya çıkması hem bilgisayarların kapasitelerini ve güvenilirliklerini artırmış, 
    hem de güç harcamalarını düşürmüştür.

    1950'li yıllarda IBM gibi pek çok bilgisayar üreticisi firma yalnızca donanım satıyordu. İşletim sistemi gibi programları 
    yazmak kullanıcıların yapması gereken bir işti. Böylece donanımı satın alan her kurum işletim sistemine benzeyen 
    programları da kendisi yazıyordu. Bu anlamda standart bir işletim sistemi yoktu. Bugünkü anlamda ilk işletim sisteminin 
    General Motors'un 1956 yılında IBM'in 701 sistemi için yazdığı NAA IO (North American Aviation Input Output System) olduğu 
    söylenebilir.

    1960'lara gelindiğinde IBM System/360 isminde yeni bir bilgisayar donanımı geliştirme işine girişti ve artık donanımla 
    işletim sistemini birlikte satma fikrini benimsedi. Bu donanım 1964 yılında duyuruldu ve 1965 yılında gerçekleştirildi. 
    İlk System/360 Model 30 bilgisayarları o zamanın "Solid Logic Technology (SLD)" teknolojisiyle üretilmişti. Hem öncekilerden 
    daha güçlüydü hem de daha az yer kaplıyordu. Saniyede 34500 işlem yapabiliyordu ve 8K ile 64K ana belleğe sahipti. 
    1967 yılında System/360'ın Model 60'ı piyasaya sürüldü. Bu model saniyede 16.6 milyon komut çalıştırabiliyordu ve ana 
    belleği de tipik olarak 512K, 768K ve 1 MB idi. IBM Sistem 360 donanımları için 1964 yılında ilk kez OS/360 işletim 
    sistemini geliştirdi. IBM daha sonra 1967 yılında OS/360 Model 67 için OS/360'ın TSS 360 isminde zaman paylaşımlı (time 
    sharing system) bir versiyonunu daha geliştirmiştir. IBM'in System/360 makineleri ve işletim sistemleri önemli ticari 
    başarı kazandı. System/360'ı System/370 izledi. System/360 ve System/370 için başka kurumlar da işletim sistemleri 
    geliştirmiştir. Michigan Terminal System (MTS) ve MUSIC/SP bunlar arasında önemli olanlardandır.

    1960'lı yıllarda başka firmalar da işletim sistemleri geliştirmiştir. Örneğin Control Data Corporation firmasının 
    SCOPE işletim sistemi batch işlemler yapabiliyordu. Aynı firma MACE isminde bu işletim sisteminin zaman paylaşımlı 
    bir versiyonunu da yazmıştır. Firma bu çalışmalarını 1970'li yıllarda Kronos işletim sistemiyle devam ettirmiştir. 
    Burroughs firması 1961 yılında MCP işletim sistemi ile B5000 bilgisayarlarını, GE firması da 1962 yılında GECOS işletim 
    sistemiyle GE-600 serisi bilgisayarlarını piyasaya sürdü. UNIVAC dünyanın ilk ticari bilgisayarlarını üreten firmadır. 
    Bu firma da 1962 yılında UNIVAC 1107 için EXEC I işletim sistemini yazdı. Bu işletim sistemini sırasıyla Exec 2 ve 
    Exec 8 izledi.

    DEC (Digital Equipment Corporation) eskilerin en önemli bilgisayar üretici firmalarından biriydi. (DEC 1998 yılında 
    Compaq firması tarafından Compaq' firması da 2002 yılında HP firması tarafından satın alındı.) Firmanın en önemli 
    ürünleri PDP (Programmed Data Processor) isimli bilgisayarlarıdır. Firma PDP-1'den (1959) başlayarak PDP-16'ya (1971-
    1972) kadar PDP makinelerinin 16 versiyonunu piyasaya sürmüştür. DEC'in PDP-8'inin mini bilgisayar devrimini başlattığı 
    söylenebilir. Bu model 50000'in üzerinde satışa ulaşmıştır. UNIX işletim sistemi 1969 yılında ilk kez DEC'in PDP-7 modeli 
    üzerinde yazılmıştır. 1965 yılında piyasaya sürülen DEC PDP-7 18 bitlik bir makineydi. Makine DECsys denilen işletim 
    sistemi benzeri bir yönetici programla beraber satılıyordu. DEC'in 1966 yılında çıkardığı PDP-10 26 bitlik bir makineydi 
    DEC bu modelle birlikte işletim sistemi olarak TOPS-10 isimli bir sisteme geçti.

    1960'lı yılların sonuna kadar işletim sistemleri ağırlıklı olarak sembolik makine diliyle yazılıyordu. 1960’lı yılların 
    sonlarında AT&T Bell Lab. tarafından UNIX işletim sistemi geliştirildiğinde önemli bir devrim yaşandı. UNIX işletim 
    sistemi 1973 yılında C ile yeniden yazılmıştır. Böylece artık işletim sistemlerinin yüksek seviyeli dillerle de yazılabildiği 
    görülmüştür. PDP-11'i 16 bitlik PDP-12 izledi. PDP-12 Intel'in x86 ve Motorola'nın 6800 işlemcileri için ilham kaynağı 
    olmuştur.

    1970’li yılların ikinci yarısında entegre devrelerin de geliştirilmesiyle "ev bilgisayarları (home computer)" ortaya 
    çıkmaya başladı. Bunlarda genellikle BASIC yorumlayıcıları ile iç içe geçmiş CP/M tya da GEOS işletim sistemleri kullanılıyordu. 
    1970'li yıllarda pek çok firma farklı ev bilgisayarları üretmiştir. BBC Micro, Commodore 64, Apple II, Atari, Amstrad, 
    ZX Spectrum dönemin en ünlü ev bilgisayarlarındandı. Bu makinelerde kullanılan işlemciler Intel'in 8080'i, Zilog'un 
    Z80'i, Motorola'nın 6800'ü gibi 8 bitlik işlemcilerdi.

    DEC firması 1977 yılında VAX isimli bilgisayarı ve 32 bitlik işlemci birimini piyasaya sürdü. VAX ailesi makineler o 
    yıllarda önemli bi ticari başarı kazanmıştır. DEC VAX makineleri için VAX/VMS isimli bir işletim sistemi yazmıştı. DEC 
    bu işletim sisteminin ismini 1992 yılında OpenVMS olarak değiştirdi. DEC 1992 yılında 64 bitlik RISC tasarımı olan Alpha 
    işlemcilerini piyasaya sürdü ve OpenVMS Alpha işlemcilerine port edildi. OpenVMS hala kullanılmaya devam etmektedir. 
    Itanium ve X86-64 portları da vardır.

    Apple firması 1976 yılında kuruldu. Apple'ın ilk bilgisayarı Apple I idi. Bunu 1977'de Apple II, 1980'de de Apple III 
    izledi. Bu ilk Apple bilgisayarlarında AppleDOS isimli işletim sistemleri kullanılıyordu. Daha sonra Apple 1983'te 
    Lisa modelini piyasaya sürdü. 1983'ün sonlarında da ilk Macintosh bilgisayarını çıkarttı. Lisa ile birlikte Apple 
    grafik tabanlı işletim sistemlerine geçiş yaptı. Lisa ve sonraki Apple bilgisayarlarının hepsi grafik bir arayüze 
    sahiptir. Macintosh markası daha sonra Mac olarak telaffuz edilmeye başlandı. Lisa bilgisayarlarında kullanılan 
    işletim sistemi LisaOS ismindeydi. Apple daha sonra Machntosh bilgisayarlarının değişik versiyonlarını piyasaya sürdü. 
    Bunlardaki işletim sistemini "System Software 1 (1984), System Software 2 (1985), System Software 3 (1986), System 
    Software 4 (1987), System Software 5 (1987), System Software 6 (1988), ve System Software 7 (1991)" olarak isimlendirdi. 
    Apple System Software 7.5'ten sonra işletim sisteminin ismini "System Software" yerine Mac OS olarak değiştirdi ve 
    System Software 7.6 versiyonu Mac OS 7.6 ismiyle çıktı. Daha sonra Apple 1997 yılında Mac OS 8'i, 1999 yılında da 
    Mac OS 9'u çıkarmıştır.

    1980'li yıllarda Mac bilgisayarlarının fiyatı çok yüksekti ve satışları da iyi gitmiyordu. Çünkü Steve Jobs bilgisayarların 
    program yazmak için değil kullanmak için alınması gerektiğini düşünüyordu. Nihayet Apple'daki çalkantılar sonucunda 
    Steve Jobs 1985 yılında Apple'dan ayrılmak zorunda kaldı (kovuldu da denebilir) ve NeXT firmasını kurdu. NeXT firması 
    NeXT isimli bilgisayarları geliştirdi. Bu bilgisayarlarda NeXTSTEP isimli işletim sistemi kullanılıyordu. Daha sonra 
    bu sistem açık hale getirildi ve OPENSTEP ismini aldı. Dünyanın ilk Web tarayıcısı Tim Berners Lee tarafından Cern’de 
    NeXT bilgisayarları üzerinde gerçekleştirilmiştir.

    Steve Jobs 1997 yılında Apple’a geri döndü. Apple da NeXT firmasını 200 milyon dolara satın aldı. Sonra piyasaya 
    iMac ve Power Mac serileri çıktı. Daha sonra Steve Jobs Mac’lerin çekirdeklerini tamamen değiştirme kararı aldı. 
    Mac’ler Mac OS'un 10 versiyonu ile birlikte yeni bir çekirdeğe geçtiler. Mac OS işletim sistemlerinin 10'lu versiyonları 
    Roma rakamıyla Mac OS X biçiminde isimlendirilmiştir. Apple Mac OS X ismini 2012 yılında Mountain Lion (10.8) sürümü 
    ile OS X olarak, 2016 yılında da Sierra (10.12) sürümüyle birlikte de macOS olarak değiştirmiştir.

    DOS işletim sistemi text ekranda çalışıyordu. Microsoft da geleceğin grafik tabanlı işletim sistemlerinde olduğunu 
    gördü ve yavaş yavaş DOS'u bırakarak grafik tabanlı bir sisteme geçmeyi planladı. Bunun için Windows isimli grafik 
    arayüzün birinci versiyonunu 1985'te çıkardı. Bunu 1987'de Windows 2, 1990'da Windows 3.0 ve 1992'de de Windows 3.1 
    izledi. Bu 16 bit Windows sistemleri işletim sistemi değildi. DOS üzerinden çalıştırılan birer grafik arayüz gibiydi. 
    Microsoft daha sonra Windows'u Windows NT 3.1 ile bağımsız bir işletim sistemi haline getirdi. Microsoft bundan sonra 
    sırasıyla 1994 yılında Windows NT 3.5'i, 1995 yılında Windows NT 3.51'i ve Windows 95'i, 1998 yılında Windows 98'i, 
    2000 yılında Windows 2000 ve Windows ME'yi, 2001 yılında Windows XP'yi, 2006 yılında Windows Vista'yı, 2012 yılında 
    Windows 8'i, 2015 yılında Windows 10'u ve nihayet 2021 yılında da Windows 11'i çıkarmıştır.

    Linux işletim sistemi 1992 yılında bir dağıtım biçiminde piyasaya çıkmıştır. Linux işletim sisteminin hikayesi daha 
    geniş olarak izleyen paragraflarda ele alınmaktadır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
												3. Ders 26/07/2025 - Cumartesi
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Şimdi de UNIX türevi işletim sistemlerinin tarihsel gelişimi üzerinde durmak istiyoruz. UNIX İşletim sistemi AT&T Bell 
    Laboratuvarlarında 1969-1971 yılları arasında geliştirildi. Proje ekibinin lideri Ken Thompson'du. Çalışma ekibinde 
    Dennis Ritchie, Brian Kernighan gibi önemli isimler de vardı. Ekip daha önce General Electric'in GE-645 mainframe 
    bilgisayarı için Multics işletim sistemi üzerinde çalışıyordu. (Multics işletim sisteminin geliştirilmesine 1964 yılında 
    başlandı. Projede General Electric, MIT ve Bell Lab birlikte çalışıyordu. Sonra proje Honeywell şirketi tarafından 
    devralınmıştır.)

    AT&T 1969 yılında bu projeden çekilerek kendi işletim sistemini geliştirmek istemiştir. Geliştirme çalışmasına DEC'in 
    PDP-7 makinelerinde başlanmıştır. UNIX ismi 1970 yılında Brian Kernighan tarafından Multics'ten kelime oyunu yapılarak 
    uydurulmuştur. Proje ekibi AT&T'yi DEC PDP-11 almaya ikna etti ve böylece geliştirme çalışmaları PDP-11 ile devam etti. 
    UNIX'in resmi olarak ilk sürümü Ekim 1971'de ikinci sürümü Aralık 1972'de, Üçüncü ve dördüncü sürümleri de 1973 yılında 
    yayınlanmıştır. UNIX işletim sistemi büyük ölçüde PDP'nin sembolik makine dili ve Ken Thompson'ın B isimli programlama 
    diliyle geliştirilmiştir. B programlama dili fonksiyonları alıp DEC'in makine diline dönüştürüyordu. Bu bakımdan B bir 
    yorumlayıcı değil derleyiciydi. İşte 1972 yılında Dennis Ritchie, Ken Thompson'ın B programlama dilinden hareketle C 
    Programlama dilini geliştirmiştir. UNIX işletim sisteminin dördüncü sürümü 1973 yılında yeniden C Programlama Dili ile 
    yazılmıştır. 1974 yılında UNIX'in beşinci sürümü oluşturuldu. Bu sürümlerin hepsi araştırma amaçlıydı ve "educational 
    license" ismiyle lisanslanmıştı. UNIX işletim sistemi bir araştırma projesi olarak organize edilmişti. Bu nedenle AT&T 
    kaynak kodlarını araştırma kuruluşlarına ücretsiz dağıtılmıştır. 1975 yılında UNIX'in altıncı sürümü şirketlere yönelik 
    hazırlandı. UNIX'in altıncı versiyonunun kaynak kodları 20,000 dolara (şimdikinin 120,000 doları) şirketlere sunuldu. 
    1977 yılında Bell Lab, UNIX'i Interdata 7/32 isimli 32 bit mimariye port etti. Bunu 1978'de VAX portu izledi.

    1974 yılında California Üniversitesi (Berkeley) işletim sisteminin kopyasını Bell Lab'tan aldı. 1978 yılında "Berkeley 
    Software Distribution (1BSD)" ismiyle AT&T dışındaki ilk UNIX dağıtımını gerçekleştirdi. Bu dağıtım hayatını hala FreeBSD, 
    OpenBSD ve NetBSD olarak devam ettirmektedir. 1979'da BSD'nin ikinci versiyonu (2BSD) ve 1979'un sonlarına doğru da üçüncü 
    versiyonu (3BSD) piyasaya sürüldü. Bunu 1980 yılında versiyon 4 (4BSD) izlemiştir. 1991 yılında BSD UNIX'ten AT&T kodları 
    tamamen arındırılmış ve kod bakımından özgün hale getirilmiştir. BSD'nin son versiyonu 1995'te 4.4BSD Lite Release 2 
    olarak çıkmıştır.

    1980'li yıllarda pek çok kurum ve ticari firma UNIX kodlarını lisans ücreti ödeyerek AT&T'den satın alıp kendilerine 
    yönelik UNIX sistemleri oluşturmuştur. Bunların önemli olanları şunlardır:

    AIX: IBM tarafından geliştirilmiş olan UNIX türevi sistemlerdir. İlk kez 1986 yılında piyasaya sürülmüştür. IBM AIX'i 
    System/370, RS/6000 PS2 bilgisayarlarında kullanıyordu. Bu sistemler AT&T UNIX System 5 kodları temel alınarak geliştirilmiştir. 
    AIX hala kullanılmaktadır. Son sürümü 2021 yılında 7.3 olarak piyasaya sürülmüştür. AIX PowerPC, x86 işlemcileri için de 
    port edilmiştir.

    IRIX: SGI firması tarafından AT&T ve BSD kodları değiştirilerek 1988'de oluşturulmuştur. 2006'da bırakılmıştır.

    HP-UX: HP 9000 bilgisayarları için 1982'de oluşturulmuştur. Motorola 68000 ve Itanium işlemcileri için yazılmıştır. 
    Hala devam ettirilmektedir.

    ULTRIX: DEC firmasının PDP-7, PDP-11 ve VAX donanımları için geliştirdiği UNIX sistemiydi. İlk versiyonu 1984 yılında 
    çıktı. 1995 yılında piyasadan çekildi.

    XENIX: Microsoft tarafından 1980 yılında geliştirilmeye başlanmıştır. İlk versiyonu 1980'in sonlarına doğru çıkmıştır. 
    Daha sonra SCO firması Microsoft'la bu konuda iş birliği yapmış 1987 yılında da Microsoft sistemi tamamen SCO'ya 
    devretmiştir. Bu sistemi daha sonra SCO firması, SCO-UNIX olarak devam ettirmiştir.

    SCO-UNIX: SCO firması XENIX'i Microsoft'tan alınca bunu SCO-UNIX olarak devam ettirdi. SCO-UNIX'in ilk versiyonu 1989 
    yılında çıktı. SCO sonra bunu OpenServer ismiyle devam ettirmiştir.

    FreeBSD, NETBSD ve OpenBSD: 4.3BSD sistemleri temel alınarak geliştirilmiştir. FreeBSD ve NetBSD 1993 yılında, OpenBSD 
    ise 1996 yılında piyasaya çıkmıştır. Sürdürülmeye devam etmektedir. Önemli bir UNIX varyantı durumundadır. Bu üç 
    sistem de birbirlerine çok benzemektedir. FreeBSD genel amaçlı client ve server işletim sistemi olma niyetindedir. 
    NetBSD daha taşınabilirdir ve geniş bir port'a sahiptir. Daha çok bilimsel çalışmalarda tercih edilmektedir. OpenBSD 
    güvenliğin önemli olduğu alanlarda tercih edilmektedir.

    SunOS (Solaris): Sun firmasının BSD kodlarıyla oluşturduğu UNIX türevi işletim sistemiydi. İlk versiyonu 1982 yılında 
    çıktı. SunOS işletim sistemi 5.2 versiyonundan sonra (1992) Solaris ismiyle pazarlanmaya başlamıştır. Solaris daha 
    sonra OpenSolaris biçiminde açık kaynak kodlu olarak bir süre varlığını devam ettirdi. Oracle firmasının Sun firmasını 
    2010'da satın almasından sonra bu proje de durduruldu. Bu proje Illumos ismiyle başka ekip tarafından devam ettirilmektedir.

    Linux: Linux Torvalds'ın öncülüğünde geliştirilmiş en yaygın UNIX türevi işletim sistemidir. İlk versiyonu 1991 
    yılında çıkmıştır. Hala devam ettirilmektedir. Linux'un tarihsel gelişimi izleyen bölümde ayrıntılı bir biçimde 
    açıklanmaktadır.

    Mac OS X, OS X, macOS: Carnegie Mellon üniversitesinin Mach isimli çekirdeği ile BSD UNIX sisteminin bir araya getirilmesiyle 
    oluşturulmuştur. İlk versiyonu 2001 yılında piyasaya sürülmüştür. İzleyen bölümlerde Mac OS işletim sistemlerinin 
    tarihsel gelişimi ayrıntılı olarak ele alınmaktadır.

    İzleyen paragrafta özel olarak Linux sistemlerinin tarihsel gelişimi üzerinde duracağız.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    İşletim sistemlerinin tarihsel gelişimini ele aldığımız önceki bölümde de belirttiğimiz gibi Apple firmasının Mac 
    bilgisayarları Mac OS'un 10 versiyonu ile birlikte yeni bir çekirdeğe geçtiler. Mac OS işletim sistemlerinin 10'lu 
    versiyonları Roma rakamıyla Mac OS X biçiminde isimlendirildi. Apple Mac OS X ismini 2012 yılında Mountain Lion (10.8) 
    sürümü ile OS X olarak, 2016 yılında da Sierra (10.12) sürümüyle birlikte de macOS olarak değiştirdi. Biz Mac OS X, 
    OS X ve macOS sistemlerine bu bölümde "Mac OS X türevi sistemler" de diyeceğiz.

    Mac OS X türevi işletim sistemleri UNIX türevi sistemlerdir. Bu işletim sistemlerinin çekirdeğine Darwin denilmektedir. 
    Darwin açık kaynak kodlu bir işletim sistemdir. Ancak Mac OS X türevi sistemler tam anlamıyla açık sistemler değildir. 
    Bu sistemlerin çekirdeği açık olsa da geri kalan kısımları mülkiyete sahip (proprietary) biçimdedir.

    Darwin'in hikayesi 1989 yılında NeXT'in NeXTSTEP işletim sistemiyle başladı. NeXTSTEP daha sonra OpenStep ismiyle API 
    düzeyinde standart hale getirildi. 1996'nın sonunda 1997'nin başında Steve Jobs Apple'a dönerken Apple da NeXT firmasını 
    satın aldı ve sonraki işletim sistemini OpenStep üzerine kuracağını açıkladı. Bundan sonra Apple 1997’de OpenStep üzerine 
    kurulu olan Rapsody'yi çıkardı. 1998'de de yeni işletim sisteminin Mac OS X olacağını açıkladı. Daha sonra 2000 yılında 
    Apple Rapsody'den Darwin projesini türetti. Darwin her ne kadar Mac sistemlerinin çekirdeği olarak tasarlanmışsa da ayrı 
    bir işletim sistemi olarak da yüklenebilmektedir. Ancak Darwin grafik arayüzü olmadığı için Mac programlarını çalıştıramamaktadır. 
    Daha sonra Darwin'i bağımsız bir işletimn sistemi haline getirmek amacıyla Darwin'den de çeşitli projeler türetilmiştir. 
    Bunlardan biri Apple tarafından 2002'de başlatılan OpenDarwin'dir. Bu proje 2006'da sonlandırılmıştır. 2007'de PureDarwin 
    projesi başlatılmıştır.

    Darwin'in çekirdeği XNU üzerine oturtulmuştur. XNU NeXT firması tarafından NEXTSTEP işletim sisteminde kullanılmak üzere 
    geliştirilmiş bir çekirdektir. XNU, Carnegie Mellon ("Karnegi" diye okunuyor) üniversitesi'nin Mach 3 mikrokernel çekirdeği 
    ile 4.3BSD karışımı hibrit bir sistemdir.

    Mac OS X türevi sistemlerin versiyonları şunlardır:

    - Mac OS X 10.0 (Cheetah, 2001)
    - Mac OS X 10.1 (Puma, 2001)
    - Mac OS X 10.2 (Jaguar, 2002)
    - Mac OS X 10.3 (Panther, 2003)
    - Mac OS X 10.4 (Tiger, 2005)
    - Mac OS X 10.5 (Leopard, 2007)
    - Mac OS X 10.6 (Snow Leopard, 2009)
    - Mac OS X 10.7 (Lion, 2011)
    - OS X 10.8 (Mountain Lion, 2012)
    - OS X 10.9 (Maverics, 2013)
    - OS X 10.10 (Yosemite, 2014)
    - OS X 10.11 (El Capitan, 2015)
    - macOS 10.12 (Sierra, 2017)
    - macOS 10.13 (High Sierra, 2017)
    - macOS 10.14 (Mojave, 2018)
    - macOS 10.15 (Catalina, 2019)
    - macOS 11 (Big Sur, 2020)
    - macOS 12 (Monterey, 2021)
    - macOS 13 (Ventura, 2022)
    - macOS 14	(Sonoma, 2023)
    - macOS 15	(Sequoia, 2024)

    MacOS büyük ölçüde POSIX uyumlu bir sistemdir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Şimdi de UNIX/Linux dünyasında önemli bir yeri olan "GNU Projesi", "özgür yazılım" ve "açık kaynak kod akımları" üzerinde 
    durmak istiyoruz.

    1970'lerdeki mikro bilgisayarlar devrimine kadar yazılımda bir telif anlayışı yoktu. Yani yazılımın dağıtılması konusunda 
    sözleşmeler ve hukuki yaptırımlara gerek duyulmamıştı. Yazılım zaten donanımla birlikte satılıyordu ya da kuruma özel 
    yapılıyordu. 1969 yılında IBM yazılımı donanımla birlikte verdiği için rekabet kurallarına uymadığı gerekçesiyle mahkemeye 
    verilmiştir ve cezaya çarptırılmıştır. 1970'li yıllarda yazılım maliyetleri artmış, yazılım sektörü genişlemiş ve lisanslama 
    politikaları da uygulamaya sokulmuştur. Pek çok yazılım bu yıllarda özel lisanslarla piyasaya sürülmeye başlanmıştır. 
    1980'li yıllarda bu lisanslama faaliyetleri hız kazanmıştır.

    1980'li yıllarda tüm UNIX türevi sistemler çeşitli biçimlerde sınırlandırıcı lisanslara sahipti. Yani 1980'li yıllarda 
    sınırlaması olmayan UNIX türevi sistemler kalmamıştı. Bu nedenle bedava ve sınırlamasız UNIX türevi bir işletim sistemine 
    gereksinim duyulmaya başlandı. İşte durumdan vazife çıkaran ünlü Emacs editörünün yazarı Richard Stallman 1983 yılının 
    sonlarına doğru GNU projesini başlattı ve özgür yazılım (free software) fikrini oraya attı. GNU projesinin amacı açık 
    kaynak kodlu UNIX benzeri bir işletim sistemini ve geliştirme araçlarını yazmaktı. Proje fiilen 1984 yılında başlamıştır.

    Stallman 1985 yılında özgür yazılım kavramını yaygınlaştırmak amacıyla Free Software Foundation (www.fsf.org) isimli 
    kurumu kurdu ve atık GNU projesi bu kurum tarafından yürütülmeye başlandı. FSF özgür yazılım modeli için GPL (GNU Public 
    License) denilen lisansı ortaya çıkardı. Özgür yazılım akımında oluşturulan bir yazılım istenildiği gibi çalıştırılabilir, 
    kopyalanabilir, incelenebilir, dağıtılabilir, değiştirilebilir ve iyileştirilebilir. Daha açık bir biçimde özgür yazılım 
    tipik olarak aşağıdaki dört özgürlükle tanımlanmıştır:

    Özgürlük 0: Programı her türlü amaç için çalıştırma özgürlüğü
    Özgürlük 1: Programın kaynak kodunu inceleme ve değiştirebilme özgürlüğü
    Özgürlük 2: Programın kopyalarını çıkartabilme ve yeniden dağıtabilme özgürlüğü
    Özgürlük 3: Programı iyileştirebilme ve iyileştirilmiş programı yayınlama özgürlüğü

    GNU projesi bağlamında pek çok temel araç (gcc derleyici, ld bağlayıcı vs.) geliştirilmiştir. Fakat hedeflenen bir 
    çekirdek bir türlü oluşturulamamıştır.

    Aslında özgür yazılım (free software) ile açık kaynak kod (open source) akımları arasında bazı farklar olmakla birlikte 
    her iki akımın da hedefleri benzerdir. Özgür yazılım bir sosyal harekete benzetilirken açık kaynak kod akımı bir geliştirme 
    metodolojisine benzetilmektedir. Biz kursumuzda tüm bu akımları "açık kaynak kod (open source)" olarak nitelendireceğiz. 
    Özgür yazılım akımının temel lisansı GPL'dir (GNU Public Licence). Bunun yumuşatılmış LGPL (Lesser GPL) biçiminde bir 
    versiyonu da oluşturulmuştur. Ayrıca Apache, MIT, BSD gibi açık kaynak kodlu başka lisanslar da vardır. Şüphesiz bu 
    lisansların aralarında birtakım farklılıklar bulunmakla birlikte pek çok yönleri de ortaktır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Linux Torvalds Helsinki Üniversitesinde öğrenciyken bir işletim sistemi yazmaya niyetlenmiştir. O zamanlarda telif 
    uygulanmayan UNIX türevi bir işletim sistemi kalmamıştı ve GNU projesinin işletim sistemi de (GNU Hurd) bitirilememişti. 
    MINIX isimli bir işletim sistemi Andrew Tanenbaum tarafından yazılmıştı ancak bu sisteminin lisansı yalnızca akademik 
    kullanımlara izin verecek biçimde sınırlandırılmıştı. Linus Torvalds projesini USENET haber gruplarında duyurdu ve zamanla 
    kendisine gönüllü yardım edecek sistem programcıları buldu. Yazılım dünyasında bu tür girişimlerle sık karşılaşıldığı 
    halde başarı olasılığı nispeten düşük olmaktadır. Linus Torvalds'ın bu girişimi başarıya ulaşmıştır.

    1991 yılında Linux'un 0.01 sürümü oluşturuldu. 1994 yılında stabil bir biçimde Linux 1.0 versiyonu dağıtılmaya başlandı. 
    Bunu 1996 yılında Linux 2.0, 1999 yılında 2.2, 2000 yılında 2.4 ve 2003 yılında 2.6 izledi. Daha sonra Linux versiyon 
    numaralandırma sistemi değiştirilmiştir. 2011 yılında 3.0, 2015 yılında 4.0, 2019 yılında 5.0, 2022 yılında da 6.0 
    versiyonu çıkmıştır. Kursun yapıldığı zamandaki son çekirdek sürümü Ekim 2022'de çıkmış olan 6.0'dır.

    Linux çekirdeklerinin versiyonları ve bu versiyonlarda eklenen önemli özellikleri şöyle listeleyebiliriz:

    Sürüm	Tarih	        Önemli Yenilikler

    0.01	Ağustos 1991	Linus Torvalds tarafından duyurulan ilk sürüm; sadece temel fonksiyonlara sahipti.
    1.0	    Mart 1994	    İlk "resmi" sürüm; çoklu işlemci desteği yoktu. Ağ üzerinden TCP/IP desteği sağlandı.
    1.2	    Mart 1995	    x86 dışı mimarilere (Alpha, MIPS) ilk destekler geldi.
    2.0	    Haziran 1996	SMP (Simetrik Çoklu İşlemci) desteği eklendi. Daha fazla mimari desteği sunuldu.
    2.2	    Ocak 1999	    Gelişmiş ağ yığını, IPv6 desteği, daha fazla SMP ölçeklenebilirliği.
    2.4	    Ocak 2001	    USB, PCMCIA ve Bluetooth desteği, 64 GB RAM'e kadar bellek desteği (PAE ile).
    2.6	    Aralık 2003	    Yeni scheduler (O(1)), udev ile dinamik aygıt yönetimi, sysfs, Native POSIX thread kütüphanesi 
                            (NPTL), preemptive kernel
    3.0	    Temmuz 2011	    Büyük bir teknik değişiklik yok; sadece sürüm numarası sadeleştirildi (2.6.x'lerin devamı).
    4.0	    Nisan 2015	    Canlı kernel güncelleme (live patching) özelliği eklendi.
    5.0	    Mart 2019	    Yeni donanım desteği, enerji verimliliği iyileştirmeleri, Adiantum şifreleme algoritması.
    5.4     Kasım 2019	    Lockdown modu, fs-verity desteği.
    5.10    Aralık 2020	    EXT4 ve Btrfs iyileştirmeleri, AMD GPU desteği.
    5.15    Kasım 2021	    NTFS3 dosya sistemi, yeni I/O kontrolcüsü.
    6.0	    Ekim 2022	    Rust diline ilk çekirdek içi destek, Scheduler ve TCP performans iyileştirmeleri.
    6.1     Aralık 2022	    Rust desteği genişletildi, Intel AMX desteği.
    6.6     Kasım 2023	    Apple Silicon (M1/M2) desteği, yeni enerji yönetimi özellikleri.

    Linux monolithic bir çekirdek yapısına sahiptir. Büyük ölçüde POSIX uyumu bulunmaktadır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Açık kaynak kodlu yazılımlar bir araya getirilip paketlenerek istenildiği gibi dağıtılabilmektedir. Dağıtım (distribution) 
    bu anlamda kullanılan genel bir terimdir ve her türlü açık kaynak kodlu yazılım için dağıtım söz konusu olabilir. Ancak 
    biz burada Linux dağıtımları üzerinde duracağız.

    Linux temel olarak bir çekirdek geliştirme projesidir. Linux kaynak kodlarına baktığınızda tüm kodların çekirdekle 
    ilgili olduğunu görürsünüz. Çekirdeğin dışındaki tüm yazılımlar (örneğin init prosesinden başlayarak, kabuk yazılımları, 
    paket yöneticileri, pencere yöneticileri vs.) hep başka proje grupları tarafından gerçekleştirilmiş açık kaynak kodlu 
    yazılımlardır. İşte tüm bu açık kaynak kodlu yazılımların Linux çekirdeği temelinde bir araya getirilmesi ve doğrudan 
    kullanıcının install edip çalıştırabileceği biçimde paketlenmesine Linux dağıtımları denilmektedir. Linux dağıtımları 
    pencere yöneticileri (KDE, GNOME gibi), paket yöneticileri (APT, RPM, YUM, DPKG, PACMAN, ZYPPER gibi) ve diğer yararlı 
    uygulama programları bakımından farklılıklar gösterebilmektedir.

    Toplamda iki yüzün üzerinde Linux dağıtımının olduğu söylenebilir. Ancak bunlar arasında az sayıda dağıtım çok popüler 
    olmuştur. Bazı dağıtımlar bazı dağıtımlardan fork edilerek oluşturulmuştur. Aşağıda en çok kullanılan dağıtımlara 
    ilişkin dağıtım ağacını veriyoruz:

    Linux
    ├── Debian
    │   ├── Ubuntu
    │   │   ├── Linux Mint
    │   │   ├── Pop!_OS
    │   │   ├── elementary OS
    │   │   └── Zorin OS
    │   ├── Devuan       # Systemd olmayan Debian
    │   └── Kali Linux   # Güvenlik test amaçlı
    ├── Red Hat Linux (eski)
    │   ├── Fedora       # Topluluk temelli, RHEL'in test yatağı
    │   │   └── RHEL (Red Hat Enterprise Linux)
    │   │       ├── CentOS (→ 2021 sonrası CentOS Stream)
    │   │       ├── AlmaLinux
    │   │       └── Rocky Linux
    ├── Slackware
    │   └── Slax         # Hafif sürüm
    ├── Arch Linux
    │   ├── Manjaro
    │   └── EndeavourOS
    ├── Gentoo
    │   └── Calculate Linux
    ├── SUSE Linux
    │   ├── openSUSE Leap
    │   └── openSUSE Tumbleweed
    ├── Android          # Mobil, Linux çekirdeğine dayalı
    ├── Alpine Linux     # Minimal, güvenli, konteyner dostu
    └── Chrome OS
        └── Chromium OS  # Açık kaynak tabanı

    Burada en çok kullanılan Linux dağıtımlarından bahsedeceğiz.

    Debian Dağıtımı: En önemli ve en eski Linux dağıtımlarından biridir. Knoppix, Mint, Ubuntu dağıtımları Debian türevi 
    dağıtımlardır.

    Fedora: Red Hat firması tarafından çıkarılmış olan dağıtımdır. İlk kez 2003 yılında oluşturulmuştur. RPM paket 
    yöneticisini kullanır. CentOS ve Scientific Linux en önemli Fedora türevi dağıtımlardır. 2000 yılında ilk sürümü 
    yapılan Red Hat Enterprise Linux (RHEL) en önemli Fedora türevidir. Ondan da CentOS, Scientific Linux gibi dağıtımlar 
    türetilmiştir. CentOS server makinelerde en yaygın kullanılan Linux versiyonudur.

    OpenSUSE: Alman SUSE firmasının desteklediği dağıtımdır. SUSE Linux Enterprise isminde ticari bir versiyonu da vardır. 
    ZYpp, YaST ve RPM paket yöneticilerini kullanmaktadır.

    Slackware: En eski Linux dağıtımıdır. 1993 yılında oluşturulmuştur. Sürdürümü yavaş olmakla birlikte hala devam 
    etmektedir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    1980'li yıllarda AT&T ya da BSD kodlarından türetilmiş olan ve çoğunluğu şirketlere ait olan pek çok UNIX türevi 
    sistem oluşturuldu. Bu sistemler birbirlerine çok benzemekle birlikte aralarında bazı farklılıklara da sahipti. İşte 
    IEEE durumdan vazife çıkartarak bu UNIX türevi sistemleri standardize etmek için kolları sıvadı ve bunun sonucu olarak 
    da POSIX standartlarını oluşturdu.

    POSIX sözcüğü Richard Stallman tarafından önerilmiştir. "Portable Operating System Interface for UNIX" sözcüklerinden 
    kısaltılarak uydurulmuştur ve "poziks" biçiminde okunmaktadır. POSIX standartları üzerinde çalışmalar 1985 yılında 
    başlamıştır ve ilk standartlar 1988 yılında "IEEE Std 1003.1-1988" kod numarasıyla oluşturulmuştur. POSIX her ne kadar 
    UNIX türevi sistemler için düşünülmüşse de UNIX türevi mimariye sahip olamayan sistemler için de kullanılabilecek bir 
    standarttır. (Örneğin Windows sistemleri Interix denilen alt sistemle POSIX uyumlu olarak da kullanılabilmekteydi. 
    Interix alt sistemi daha sonra Windows 8 ile birlikte Windows'tan kaldırılmıştır.)

    POSIX standartları 4 bölümden oluşmaktadır:

    1) Base Definitions: Bu bölümde temel tanımlamalar bulunmaktadır.
    2) Shell & Utilities: Bu bölümde kabuk komutları ve standart utility programlar ele alınmaktadır.
    3) System Interfaces: Bu bölümde C programcıları için hazır bulunan POSIX fonksiyonları açıklanmaktadır.
    4) Rationale: Çeşitli kuralların ve özelliklerin gerekçeleri bu bölümde açıklanmaktadır.

    POSIX standartlarının zaman içerisinde çeşitli versiyonları çıkartılmıştır. Bu versiyonlarda hem yeni POSIX fonksiyonları 
    kütüphaneye eklenmiş hem de standartlardaki bazı bozukluklar ve uyumsuzluklar düzeltilmiştir. Standardın önemli 
    versiyonları şu senelerde yayınlanmıştır: 1992, 1993, 1995, 1997, 2001, 2004, 2008, 2017. Standartlardaki en önemli 
    değişim 1993 yılında "POSIX 1.b" diye de isimlendirilen "Realtime-extensions" ile 1995 yılında "POSIX 1.c" diye 
    isimlendirilen "Thread-extensions" isimli eklemelerdir. Bu eklemelerle POSIX'e gerçek zamanlı işlemler için çeşitli 
    özelliklerle thread kullanımı eklenmiştir.

    "Single UNIX Specification" UNIX türevi sistemler için oluşturulmuş diğer önemli standarttır. Bir sistemin UNIX olarak 
    değerlendirilebilmesi için bu standartlara uygun olması gerekmektedir. Standartlar "Austin Group" isimli toplulukla 
    "Open Group" isimli dernek tarafından geliştirilmiştir. Sürdürümü Open Group tarafından yapılmaktadır. Open Group 
    hali hazırda UNIX sistemlerinin isim haklarını elinde bulundurmaktadır. Single UNIX Specification isimli standardın 
    zamanla pek çok versiyonu oluşturulmuştur.

    POSIX standartları ile "Single UNIX Specification" standartları arasında eskiden daha fazla farklılıklar vardı. Ancak 
    bugün itibari ile bu iki standart birbirlerine yaklaştırılmış ve son versiyonlarla aynı hale getirilmiştir. Single 
    UNIX Specification dokümanlarına Internet'ten Open Group'un web sitesinden erişilebilir:

    https://pubs.opengroup.org/onlinepubs/9799919799/
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Kursumuzda önce Linux çekirdeğinin kaynak kodlarının genel dizi yapısı üzerinde duracağız.

    Linux çekirdeğinin kaynak kod ağacı üzerinde temel dizinler aynı kalmak üzere zaman içerisinde çeşitli değişikler 
    yapılmıştır. Biz burada çekirdeğin son versiyonlarını dikkate alarak açıklamalar yapacağız. Linux kaynak kod ağacındaki 
    temel dizinler şunlardır:

    linux-6.x/
    ├── arch/          → Mimarilere özel kodlar (x86, ARM, RISC-V, vs.)
    ├── block/         → Blok aygıt altyapısı
    ├── certs/         → Kernel modül imzalama için sertifikalar
    ├── crypto/        → Kriptografik algoritmalar ve API’ler
    ├── Documentation/ → Belgeler (API, özellikler, davranışlar)
    ├── drivers/       → Aygıt sürücüleri (net, usb, gpu, vs.)
    ├── fs/            → Dosya sistemi sürücüleri (ext4, btrfs, vs.)
    ├── include/       → Global başlık dosyaları (headers)
    ├── io_uring/      → 5.1 çekirdeği ile eklenen asenkron io_uring sistem fonksiyonları için çekirdek kodları
    ├── init/          → Kernelin ilk başlatma kodları
    ├── ipc/           → IPC mekanizmaları (semaphore, message queue, vs.)
    ├── kernel/        → Temel kernel işlevleri (zamanlayıcı, process, vs.)
    ├── lib/           → Genel amaçlı yardımcı fonksiyonlar
    ├── mm/            → Bellek yönetimi
    ├── net/           → Ağ yığını (TCP/IP, socket, protokoller)
    ├── samples/       → Örnek kodlar (örnek eBPF, modül kodları, vs.)
    ├── scripts/       → Derleme sürecine yardımcı betikler
    ├── security/      → Güvenlik altyapısı (LSM, SELinux, AppArmor, vs.)
    ├── sound/         → Ses sürücüleri (ALSA, etc.)
    ├── tools/         → Kullanıcı uzayı araçları (perf, bpftool, vs.)
    ├── usr/           → Yerleşik initramfs oluşturmak için
    ├── virt/          → Sanallaştırma (KVM, Xen, vs.)
    ├── MAINTAINERS    → Dosyaların kim tarafından korunduğu bilgisi
    ├── Makefile       → Ana derleme talimatı
    └── Kconfig        → Kernel yapılandırma seçenekleri

    arch => arch sözcüğü "architecture" sözcüğünden kısaltılmıştır. Bu dizinde işlemci mimarisine göre değişebilen 
    çekirdek kodları her bir işlemci ailesi ayrı bir dizinde olacak biçimde bulundurulmaktadır.

    block => Eskiden bu dizin "drivers" dizini içerisindeydi. Burada işletim sisteminin blok düzeyinde işlemler yapan 
    kodları bulundurulmuştur.

    certs => Bu dizinde çekirdek modüllerine ilişkin sertifikasyonlarla ilgili kodlar bulunmaktadır.

    crypto => Çekirdeğin içerisinde kullanılan şifreleme işlemlerine yönelik kaynak kodlar bulunmaktadır.

    Documentation => Burada çeşitli alt sistemlere ilişkin dokümanlar bulunmaktadır.

    drivers => Burada aygıt sürücülere ilişkin çekirdek kodları bulunmaktadır. Tabii bu aygıt sürücüler isteğe göre 
    seçilerek yalnızca bir grubu derlenmektedir.

    fs => Bu dizinde dosya sistemlerine yönelik çekirdek kodları bulundurulmaktadır.

    include => Çekirdek kodlarında include edilen tüm başlık dosyaları bu dizinin içerisinde bulundurulmaktadır. Tabii 
    bu dizinde de alt dizinler vardır.

    init => Çekirdeğin çalışabilir hale gelmesi için yapılan ilk işlemlere ilişkin kodlar burada bulundurulmaktadır.

    iu_uring => 5.1 çekirdekleri ile eklenen yüksek performanslı asenkron IO işlemleri için kullanılan sistem fonksiyonlarının 
    gerçekleştirimine ilişkin kodlar bu dizinde bulunmaktadır.

    ipc => Borular, mesaj kuyrukları gibi IPC nesnelerine ilişkin kaynak kodlar bu dizin içerisindedir.

    kernel => Bu dizin çekirdeğin en temel işlevlerine ilişkin kaynak kodları barındırmaktadır. (Çekirdek kodlarının 
    içerisinde ayrıca bir "kernel" dizinin bulunması biraz tuhaf olsa da bu aslında adeta "çekirdeğin çekirdeği" gibi 
    bir anlama gelmektedir.)

    lib => Bu dizinde çekirdeğin değişik yerlerinde kullanılan genel amaçlı utility fonksiyonların kodları bulundurulmaktadır. 
    Burada "lib" sözcüğünün statik ve dinamik kütüphane ile bir ilgisi yoktur. Zaten Linux derlenirken bu biçimde kütüphane 
    dosyaları oluşturulmamaktadır.

    mm => Çekirdeğin tüm ana bellek yönetim kodları bu dizinde bulunmaktadır.

    net => Çekirdeğin tüm "ağ (network)" alt sistemine ilişkin kodları bu dizinde bulunmaktadır.

    rust => Linux çekirdeğinde 6'lı versiyonlarla Rust Programlama Dili de kullanılmaya başlanmıştır. Bu dizinde çekirdeğe 
    ilişkin Rust kodları bulunmaktadır. Kursun yapıldığı tarihteki Linux çekirdeklerinde Rust kodları çok az yer kaplamaktadır.

    samples => Burada alt sistemlere ilişkin örnek kodlar bulunmaktadır.

    scripts => Bu dizinde çekirdek derlemesi sırasında faydalanılan script dosyaları bulundurulmuştur.

    security => Çekirdeğin sistem güvenliği ile ilgili kodları bu dizinde bulunmaktadır.

    sound => Ses işlemlerine yönelik çekirdek kodları bu dizinde bulunmaktadır.

    tools => Bu dizinde çekirdek geliştirmesinde ve analizinde kullanılan yardımcı programlar bulundurulmaktadır. Aslında
    bu dizindeki programların çekirdekle bir ilgisi yoktur. Bunlar yardımcı araçlardır. Çekirdek kodlarının içerisinde yer
    almazlar.

    usr => Bu dizinde "geçici kök dosya sistemine (initial ramdisk)" ilişkin kodlar bulunmaktadır. Bunların bazı sistemlerde 
    konfigürasyon yoluyla çekirdek kodlarına aktarılmaktadır.

    virt => Burada çekirdeğin sanallaştırmaya hizmet eden kodları bulundurulmaktadır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
												4. Ders 27/07/2025 - Pazar
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Kursumuzun bu bölümünde Linux sistemlerinin boot edilmesi süreci ele alınacaktır. İşletim sisteminin otomatik olarak 
    yüklenerek çalışır hale getirilmesi sürecine "boot" işlemi denilmektedir. (Boot terimi İngilizce "askeri bottan 
    (çizmeden)" gelmektedir.) Biz bilgisayar sistemine güç verdiğimizde bir süre sonra işletim sisteminin otomatik 
    yüklendiğini görmekteyiz. Aslında işletim sisteminin yüklenmesi biraz karmaşık bir süreçle gerçekleşmektedir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Mikroişlemciler güç uygulandığında (reset edildiğinde) belli bir adresten itibaren çalışacak biçimde tasarlanmıştır. 
    Buna işlemcilerin "reset vektörü" denilmektedir. İşlemcilerin reset vektörleri genellikle fiziksel belleğin başında 
    ya da sonunda bulunmaktadır. Örneğin Intel işlemcilerinde reset vektörü belleğin sonunda, ARM işlemcilerinde ise 
    belleğin başında bulunmaktadır. İşlemci reset edildiğinde belli bir adresten çalışmaya başladığına göre orada çalışmaya 
    hazır bir kodun bulunuyor olması gerekir. Tabii bu kod RAM (DRAM) bellekte bulunamaz. Çünkü sisteme güç uygulandığında 
    RAM belleğin de içeriği sıfırlanmaktadır, ayrıca bugünkü DRAM belleklerin kullanılabilmesi için de onların donanımsal 
    olarak programlanması gerekmektedir. İşte bilgisayar sistemlerinde işlemcinin reset vektöründe tipik olarak ROM bellekler 
    bulundurulur. Eskiden bu amaçla EPROM bellekler kullanılıyordu. Artık uzunca bir süredir EEPROM (flash EPROM) bellekler 
    kullanılmaktadır. Pekiyi reset vektöründeki kod ne yapmaktadır?

    Bugün kullandığımız DRAM bellekler güç kaynağı verilir verilmez kullanıma hazır hale getirilememektedir. Onların da 
    kullanıma hazır hale getirilmesi (initialize edilmesi) gerekir. Benzer biçimde yine bazı donanım aygıtlarının kullanılmadan 
    önce kullanıma hazır hale getirilmesi (initialize edilmesi) gerekmektedir. İşte reset vektörüne yerleştirilmiş olan kodlar 
    bilgisayar sistemini kullanıma hazır hale getirecek kodları barındırmaktadır. Tabii burada donanımdan donanıma değişen 
    bazı ayrıntılar da söz konusu olabilmektedir. Reset vektöründeki kodlar genellikle donanımı üreten firmalar tarafından 
    yazılmaktadır. Bunlar çok temel kodlar olduğu için bunlara "BIOS" ya da "firmware" gibi isimler verilmiştir. Bu tür temel 
    BIOS ya da firmware kodlarının donanımı kullanıma hazır hale getirmek için yaptığı işlemlerden bazıları şunlardır:

    - DRAM bellekleri (bildiğimiz RAM) kullanıma hazır getirme
    - Çok çekirdekli sistemlerde çekirdeklerin kullanıma hazır hale getirilmesi
    - Donanım aygıtlarının ve çevre birimlerinin tespit edilmesi ve bunların tablolara (örneğin ACPI tablosu) yerleştirilmesi
    - Çevre birimlerinin (yani yardımcı işlemcilerin) kullanıma hazır hale getirilmesi
    - SSD ve HDD gibi depolama birimlerinin kullanıma hazır hale getirilmesi
    - Klavye, fare gibi giriş çıkış aygıtlarının kullanıma hazır hale getirilmesi
    - Ekran kartı gibi görüntü aygıtlarının kullanıma hazır hale getirilmesi

    Reset vektöründeki kodlar çalıştırılınca artık donanım genel olarak çalışmaya hazır bir duruma getirilmiştir. Bundan 
    sonra akışın bir biçimde sistem programcısına devredilmesi gerekir. Akışın devredilmesi tipik olarak ikincil bellekteki 
    belli bir disk bloğunun RAM'e yüklenmesi ve oradaki kodun çalıştırılması yoluyla yapılmaktadır. Tersten gidersek sistem 
    programcısı programını ikincil belleğin (diskin) bir bloğuna yerleştirir ve bu süreçler sonucunda bu program çalışır 
    hale gelir. Pekiyi işletim sistemi nasıl yüklenmektedir? ROM'daki BIOS ya da firmware kodunun işletim sistemini yüklemesi 
    genel olarak mümkün değildir. Bunun temel nedenleri şunlardır:

    - İşletim sistemleri çok büyük olabilir. ROM'daki kod bunu yapabilecek yeterlilikte olmayabilir.
    - İşletim sistemlerinin yüklenmesi sistemden sisteme değişebilen ve nispeten karmaşık bir süreçtir. ROM'daki küçük kodun 
    bunu yapması genellikle mümkün olamamaktadır.
    - İkincil bellekte birden fazla işletim sistemi bulunuyor olabilir. Bu durumda bunların hangisinin nasıl yükleneceğine 
    karar verilmesi ve karar verilen işletim sisteminin yüklenmesi ROM'daki küçük program tarafından genellikle yapılamaz.

    O halde tek çıkar yol ROM'daki programın diskteki bir önyükleyiciyi yüklemesi ve işletim sisteminin yüklenmesinin bu 
    program tarafından yapılmasıdır. İşletim sistemlerini yükleyen bu tür programlara "önyükleyici (bootloader)" denilmektedir. 
    (Biz "bootloader" terimi yerine bunun Türkçesi olan "önyükleyici" terimini de kullanacağız.) Yani yukarıda da belirttiğimiz 
    gibi sistem programcısı diskteki önceden tespit edilmiş alana kendi kodunu yerleştirir. (Genellikle BIOS ya da firmware 
    kodları küçük bir disk bloğunu yükleyip çalıştırmaktadır.) İşte sistem programcısının özel disk bloğuna yerleştirdiği 
    bu program da önyükleyici (bootloader) programını yüklemektedir. Bugün değişik platformlarda kullanılan değişik "önyükleyici" 
    programlar bulunmaktadır. Örneğin Microsoft kendi Windows sistemleri için kendi "önyükleyici" programını kullanmaktadır. 
    Buna "Windows Boot Manager (bootmgr)" denilmektedir. UNIX/Linux sistemlerinde değişik proje grupları tarafından yazılmış 
    olan değişik önyükleyici programlar kullanılabilmektedir. Örneğin Linux sistemlerinde eskiden "LILO" isimli önyükleyici 
    yoğun biçimde kullanılıyordu. Daha sonra GRUB isimli önyükleyici yaygın biçimde kullanılmaya başlandı. Son yıllarda 
    SYSLINUX isimli bootloader paketi de belli bir ölçüde kullanım bulmuştur. Bu önyükleyici minimalist bir tasarıma sahiptir 
    ve daha çok küçük sistemlerde tercih edilmektedir. Gömülü Linux sistemlerinde bugün en çok tercih edilen ise "Das U-Boot" 
    ya da kısaca "U-Boot (Universal Bootloader)" denilen önyükleyici programdır.

    O halde işletim sisteminin yüklenmesi pek çok donanım ve platformda aşağıdaki aşamalardan geçilerek yapılmaktadır:

    Mikroişlemci RESET ediliyor ---> ROM'daki RESET vektöründe bulunan kodlar çalışıyor ---> ROM'daki kodlar diskteki 
    önceden belirlenmiş olan bloğu RAM'e yükleyerek çalıştırıyor ---> RAM'e yüklenen bu küçük program önyükleyici 
    programı RAM'e yüklüyor ---> Önyükleyici program işletim sistemini yükleyerek işletim sisteminin başlangıç kodlarını 
    çalıştırıyor.

    Burada birkaç soru aklınıza gelebilir. Bunlardan biri ROM'daki RESET vektöründe bulunan kodların oraya kimin tarafından 
    yerleştirilmiş olduğudur. ROM'daki RESET vektöründe bulunan kodlar çok aşağı seviyeli kodlar olduğu için bunlar genellikle 
    donanımı tasarlayan kurumlar tarafından yazılıp oraya yerleştirilmektedir. Örneğin bugün kullandığımız PC sistemlerinde 
    ROM'daki bu kodlara BIOS (Basic Input Output System) denilmektedir. BIOS kodları PC donanımını tasarlayan IBM tarafından 
    yazılmıştı. Ancak bugün BIOS üretici firmalar tarafından yazılmaktadır. Bu ROM bellekler bugün EEPROM teknolojisi ile 
    üretildikleri için BIOS güncellemesi de yapılabilmektedir. Örneğin Beaglebone Black kartlarındaki ROM programı Texas 
    Instruments (TI) firması tarafından yazılmıştır. Raspberry PI kartlarındaki ROM programı ise Broadcom firması tarafından 
    yazılmış durumdadır. Özetle ROM'da bulunan bu aşağı seviyeli kodlar ilgili donanımı tasarlayan kurumlardaki sistem 
    programcıları tarafından yazılmıştır.

    Pekiyi ROM'daki program önyükleyici (bootloader) programını ikincil bellekte nasıl arayıp bulmaktadır? Bunun için 
    birkaç teknik kullanılabilmektedir. Birincisi ROM'daki programın doğrudan ikincil belleğin önceden belirlenmiş bloklarını 
    yüklemesidir. Örneğin klasik PC sistemlerinde ROM'daki (BIOS'taki) program diskin 0'ıncı bloğunu (yani ilk 512 byte'ı 
    içeren bloğu) yüklemektedir. (Ancak daha sonra PC sistemlerinde "UEFI BIOS" ismi altında eski klasik BIOS kodları 
    oldukça geliştirilmiştir. Artık bu UEFI BIOS kodları bazı dosya sistemlerini de tanımaktadır.) Örneğin Raspberry 
    Pi'da ROM'daki kodları FAT dosya sistemini tanıyabilmektedir. FAT dosya sistemi Microsoft'un DOS sistemlerinde 
    kullandığı karmaşık olmayan sade bir dosya sistemidir. İşte ROM'daki kodlar FAT gibi bir dosya sistemini tanıyorsa 
    oranın kök dizininde belli isimdeki dosyayı bulup RAM'e de yükleyebilmektedir.

    Sistem reset edildiğinde tüm boot işlemi bir bütünün parçaları gibi düşünülürse burada devreye giren programlara birer 
    aşama numarası da verilebilmektedir. Örneğin boot işleminin RESET vektöründe bulunan kısmına "birinci aşama bootloader  
    (stage-1 / first stage bootloader)", bu programın yüklediği programa "ikinci aşama bootloader (stage-2 / second stage 
    bootloader)" ve bunun da yüklediği programa (yani işletim sistemini yükleyen GRUB gibi programlara da) "üçüncü 
    aşama bootloader (stage-3 / third stage bootloader)" denilebilmektedir. Ancak bazı kaynaklar bu ROM'daki kodu boot 
    sürecinin bir parçası olarak ele almamaktadır. Dolayısıyla bu kaynaklar ROM kodunun kendisine değil, onun yüklediği 
    programa "birinci aşama bootloader (stage-1 / first stage bootloader), işletim sistemini yükleyen programa (yani 
    GRUB gibi) ise "ikinci aşama bootloader (stage-2 / second stage bootloader)" demektedir. Örneğin Wikipedia boot 
    işleminde donanım bileşenlerini hazır hale getiren reset vektöründeki programı "birinci aşama bootloader", işletim 
    sistemini yükleyen programı ise (GRUB gibi) "ikinci aşama bootloader" olarak isimlendirmiştir. Biz kursumuzda izleyen 
    paragraflarda bu terminolojiyi kullanacağız.

    Bugün pek çok masaüstü Linux dağıtımında GRUB isimli önyükleyici program kullanılmaktadır. Bu önyükleyici program 
    Linux çekirdek imajını bellek yükleyerek çalıştırmaktadır. Linux'un çekirdek parametreleri de bu önyükleyici tarafından 
    kullanıcıdan alınıp Linux'a verilmektedir. Biz kursumuzda çekirdek derlemesi yaparken ve sistemi çekirdekle boot 
    ederken önyükleyicinin GRUB olduğunu varsayacağız.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Kursumuzdaki örnekler x86 tabanlı masaüstü bilgisayar kullanılarak verilemektedir. (Burada "masaüstü (desktop)" terimi 
    yalnızca kasalı bilgisayarlar için değil notebook'lar için de kullanılan genel bir terimdir.) x86 tabanlı masaüstü 
    bilgisayarlara tarihsel bakımdan "PC (Personal Computer)" da denilmektedir. (2000'lerin başında Apple Intel tabanlı 
    PC mimarisine geçtiyse de kullandığı PC donanımında bazı farklılıklar da oluşturmuştur. Sonra Apple'ın Intel mimarisini 
    de bırakıp ARM mimarisine geçtiğini biliyorsunuz. Ancak PC denildiğinde Intel ve ARM tabanlı macOS sistemleri kastedilmemektedir.)

    Bugün kullandığımız PC sistemlerinin temel donanımları 70'li yılların sonlarında ve 80'li yılların başlarında IBM 
    tarafından tasarlanmıştır. Bu bilgisayarlar 1980'in Aralık ayında IBM'in tasarladığı donanım ve Microsoft'un tasarladığı 
    DOS işletim sistemiyle piyasaya sürüldü. Zaman ilerledikçe bu PC donanımlarında bazı iyileştirmeler yapıldıysa da 
    temel mimari büyük ölçüde aynı kalmıştır.

    Eskiden PC'lerde klasik BIOS (legacy BIOS) kullanılıyordu. Ancak 2010'lardan sonra modern UEFI BIOS'lar yaygınlaştı. 
    Artık bugün ağırlıklı olarak UEFI BIOS'lar kullanılıyor. (Ancak bu modern UEFI BIOS'lar eski klasik BIOS (legacy BIOS) 
    gibi de çalışabilecek özelliklere sahip olabilmektedir). Biz burada klasik eski BIOS'a sahip PC'lerin boot sürecinden 
    bahsedeceğiz.

    Eski klasik BIOS'lara (legacy BIOS) sahip PC'ler reset edildiğinde BIOS kodları DRAM belleği ve pek çok donanım birimini 
    programladıktan sonra CMOS setup'ta belirtilen "boot sırasına (boot sequence)" göre ilgili medyanın 0'ıncı sektörünü 
    belleğe yükleyip akışı oraya devretmektedir. (PC mimarisinde diskten okunabilecek ya da diske yazılabilecek en küçük 
    birime "sektör (sector)" denilmektedir.) İkincil belleklerdeki ilk sektöre "MBR (Master Boot Record)" denilmektedir. 
    MBR'de toplam 512 byte'lık bir program bulunur. MBR'nin sonunda 64 byte'lık "Disk Bölümleme Tablosu (Disk Partition 
    Table)" vardır. MBR'deki program duruma göre ya bir önyükleyici programını yüklemekte ya da default durumda aktif 
    disk bölümünün 0'ıncı sektörünü RAM'e yükleyip akışı oraya devretmektedir. (PC sistemlerinde her disk bölümünün ilk 
    sektörüne (0'ıncı sektörüne) "boot sektör" denilmektedir. Boot sektör ilgili işletim sisteminin yüklenmesinden sorumludur.) 
    Tabii MBR'deki program daha büyük bir önyükleyici programını da yükleyebilmektedir. Bu durumda hangi işletim sisteminin 
    yükleneceği önyükleyici program tarafından bir menü yoluyla kullanıcıya da sorulabilmektedir. UEFI BIOS öncesindeki 
    eski BIOS sistemini kullanan (legacy BIOS) PC sistemlerindeki boot sürecini aşağıdaki gibi özetleyebiliriz:

    PC'ye güç veriliyor ve mikroişlemci RESET ediliyor ---> EEPROM'daki BIOS kodları temel hazırlık işlemlerini yapıyor 
    ---> EEPROM'daki BIOS kodları diskin ilk sektörünü (MBR) RAM'e yüklüyor ve akışı ona devrediyor ---> MBR'deki program 
    önyükleyiciyi RAM'e yüklüyor ---> Önyükleyici seçilen disk bölümünün boot sektörünü RAM'e yüklüyor ---> Seçilen disk 
    bölümünün boot sektörü işletim sistemini yüklüyor ---> Akış işletim sistemi kodlarına devrediliyor.

    Kursumuzda UEFI BIOS sistemlerinin işlevi temel çalışma mekanizması başka bir bölümde ele alınacaktır.

    Yukarıda da belirttiğimiz gibi bugünkü Linux yüklü olan Intel x86 tabanlı PC sistemlerinde genellikle önyükleyici 
    olarak GRUB tercih edilmektedir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Linux çekirdeğinin kodlarına dokunmadan onunla ilgili bazı davranış değişikliklerinin yapılması temelde beş biçimde 
    sağlanabilmektedir:

    1) Çekirdek modunda çalışan "çekirdek modülleri (kernel modules)" ve "aygıt sürücüler (device drivers)" yoluyla: 
    İşletim sistemlerinin çoğu çekirdeğin bir parçası gibi işlev görecek kodların yüklenmesine ve çalıştırılmasına olanak 
    sağlamaktadır. Bu yöntemde çekirdeğin yeniden derlenmesine gerek yoktur. Zaten çekirdek modülleri ve aygıt sürücüleri 
    çalışmakta olan çekirdek içerisine yüklenmektedir. Çekirdek modüllerini ve aygıt sürücüleri "kasalı bilgisayarlardaki 
    genişleme yuvalarına takılan kartlara benzetebiliriz. Nasıl takılan bu kartlar donanımın bir parçası haline geliyorsa 
    çekirdek modülleri ve aygıt sürücüler de çekirdeğin bir parçası haline gelmektedir. Linux'taki çekirdek modüllerinin 
    ve aygıt sürücülerinin yazımı kursumuzun konularına dahil değildir.

    2) Çekirdek yüklenip başlatılırken (initialize ederken) ismine "çekirdek komut satırı parametreleri (kernel command 
    line parameters)" denilen parametreler yoluyla çekirdeğin davranışı değiştirilebilmektedir. Çekirdek komut satırı 
    parametreleri "önyükleyici tarafından" çekirdeğe iletilmektedir. Linux çekirdeğinin pek çok komut satırı parametresi 
    vardır. Bu parametreler yoluyla çekirdekte bazı davranış değişiklikleri oluşturulabilmektedir. Bunun için de çekirdeğin 
    yeniden derlenmesi gerekmez.

    3) Çekirdek derlenirken çekirdek kodlarına hiç dokunmadan bazı konfigürasyon parametreleri ile oynanarak çekirdekte 
    davranış değişiklikleri oluşturulabilmektedir. Çekirdek konfigüre edilirken bazı alt sistemler çekirdekten çıkartılabilmekte, 
    bazı alt sistemlerde ince ayarlar yapılabilmektedir. Tabii çekirdek konfigüre edilirken her ne kadar biz çekirdek 
    kodlarını değiştirmiyor olsak da aslında sembolik sabitler yoluyla arka planda derleme işlemine sokulan kodlar üzerinde 
    de değişikler yapılmış olmaktadır. O halde çekirdeğin konfigüre edilmesinin iki amacı vardır:

    - Çekirdek içerisindeki alt sistemlere ilişkin bileşenlerin çekirdeğe eklenmesini ve çekirdekten çıkartılmasını sağlamak.
    - Çekirdeğin üzerinde bazı davranış değişikliklerini oluşturmak.

    Çekirdek konfigüre edildikten sonra yeniden derlenmelidir. Yani bu yöntem çekirdeğin yeniden derlenmesini gerektirmektedir.

    4) Çekirdek kodlarında doğrudan değişiklikler yapılıp çekirdek yeniden derlenebilir. Bu çekirdekte davranış değişikliği 
    oluşturmak için kullanılan en aşağı seviyeli yöntemdir.

    5) Nihayet çekirdek çalışırken de çekirdeğin davranışı bazı komutlarla (bu komutlar bazı mekanizmaları ve sistem 
    fonksiyonlarını kullanmaktadır), konfigürasyon dosyalarıyla ve bazı mekanizmalarla da (örneğin "proc" ve "sys" 
    dosya sistemi yoluyla) çekirdek davranışları değiştirilebilmektedir. Tabii bunun için de çekirdeğin yeniden derlenmesi 
    gerekmez. Örneğin sistem çalışırken bir prosesin açabileceği dosya sayısını "proc" dosya sistemi yoluyla şöyle 
    değiştirebiliriz:

    $ echo 2048 | sudo tee /proc/sys/fs/file-max
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
												5. Ders 02/08/2025 - Cumartesi
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Linux'ta çekirdek komut satırı parametreleri birbirinden boşluklarla ayrılmış yazılardan oluşmaktadır. Bazı parametrelerin 
    argümanları yoktur, bazılarının vardır. Eğer parametrenin bir argümanı varsa "parametre=değer" biçiminde ('=' karakteri 
    boşluksuz olarak kullanılmalıdır) yoksa yalnızca "parametre" biçiminde belirtilmektedir. Çekirdek komut satırı parametreleri 
    tek bir yazı biçiminde çekirdeğe aktarılmaktadır. Çekirdek bu komut satırı parametrelerini kendini kullanıma hazır 
    hale getirmenin (kendini initialize etmenin) ön aşamalarında parse eder ve bu değerleri yapılandırma amacıyla kullanır. 
    Tabii çekirdeğin komut satırı parametreleri tipik olarak önyükleyici (bootloader) tarafından çekirdeğe iletilmektedir. 
    Örneğin çekirdek komut satırı parametreleri aşağıdaki gibi bir görünümde olabilir:

    console=serial0,115200 console=tty1 root=PARTUUID=382d6f16-02 rootfstype=ext4 fsck.repair=yes rootwait quiet splash 
    plymouth.ignore-serial-consoles cfg80211.ieee80211_regdom=TR

    Linux çekirdeğinin onlarca farklı komut satırı parametresi vardır. Bunların çoğu spesifik konulara ilişkindir ve ancak 
    çekirdeğin yapısını iyi bilen kişiler tarafından anlamlandırılabilir. Tabii bazı parametrelerin anlamları herkes 
    tarafından anlaşılacak kadar açıktır. Çekirdek parametrelerinin dokümantasyonuna aşağıdaki bağlantıdan erişebilirsiniz:

    https://www.kernel.org/doc/html/v4.14/admin-guide/kernel-parameters.html

    Linux çekirdeği komut satırı parametrelerini parse ederken gerçekte olmayan (yani çekirdek tarafından kullanılmayan) 
    bir parametre gördüğünde onu yok saymaktadır. Ancak biz kendi parametrelerimizin de çekirdek tarafından saklanmsını 
    sağlayabiliriz.

    Biz kursumuzda çeşitli bölümlerde çekirdeğin komut satırı parametreleri hakkında açıklamalarda bulunacağız.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Bazı durumlarda çekirdeğin sıfırdan derlenmesi gerekebilmektedir. Çekirdeğin yeniden derlenmesinin gerektiği tipik 
    durumlar şunlardır:

    - Bazı çekirdek modüllerinin ve aygıt sürücülerin çekirdek imajından çıkartılması ve dolayısıyla çekirdeğin küçültülmesi 
    için.
    - Yeni birtakım modüllerin ve aygıt sürücülerin çekirdek imajına eklenmesi için.
    - Çekirdeğe tamamen başka birtakım özelliklerin ve alt sistemlerin eklenmesi için.
    - Çekirdek üzerinde çekirdek parametreleriyle sağlanamayacak bazı konfigürasyon değişikliklerinin yapılabilmesi için.
    - Çekirdek kodlarında yapılan değişikliklerin etkin hale getirilmesi için.
    - Çekirdeğe yama (patch) yapılması için.
    - Yeni çıkan çekirdek kodlarının kullanılabilir hale getirilmesi için.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Çekirdeğin derlenmesi için öncelikle çekirdek kaynak kodlarının derleme yapılacak bilgisayara indirilmesi gerekir. 
    Bazı dağıtımlar default durumda çekirdeğin kaynak kodlarını da kurulum sırasında makineye çekmektedir. Çekirdek 
    kodları "kernel.org" sitesinde bulundurulmaktadır. Tarayıcdan "kernel.org" sitesine girip "pub/linux/kernel" 
    dizinine geçtiğinizde tüm yayınlanmış çekirdek kodlarını göreceksiniz. İndirmeyi tarayıcıdan doğrudan yapabilirsiniz. 
    Eğer indirmeyi komut satırından "wget" programıyla yapmak istiyorsanız aşağıdaki URL'yi kullanabilirsiniz:

    https://cdn.kernel.org/pub/linux/kernel/[MAJOR_VERSION].x/linux-[VERSION].tar.xz

    Buradaki MAJOR_VERSION "3", "4", "5", "6" gibi tek bir sayıyı belirtmektedir. VERSION ise çekirdeğin büyük ve küçük 
    numaralarını belirtmektedir. Örneğin biz çekirdeğin 6.9.2 versiyonunu şöyle indirebiliriz:

    $ wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.9.2.tar.xz
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Çekirdek kodları indirildikten sonra onun açılması gerekir. Açma işlemi tar komutuyla aşağıdaki gibi yapılabilir:

    $ tar -xvJf linux-5.15.12.tar.xz

    Burada Linux'ta kullanılan sıkıştırma formatlarında kısaca bahsetmek istiyoruz.

    UNIX/Linux sistemlerinde kullanılan "tar" utlity programı sıkıştırma yapmamaktadır. Yalnızca dosyaları uç uca ekleyip 
    onları tek bir dosya haline getirmektedir. Bu sayede kullanılmayan dosyalar dosya sisteminde daha az yer kaplar hale 
    getirilebilir. Aynı zamanda onların iletilmesi ve kopyalanması da kolaylaştırılmış olur. Sıkışıtma programları ise 
    aslında tek bir dosyayı sıkıştırmaktadır. O halde UNIX/Linux sistemlerinde kullanıcılar bir grup dosyayı sıkıştırmak 
    için önce onları tar'layıp tek dosya haline getirirler, sonra bu dosyayı sıkıştırırlar. Bu işlemler sonucunda dosya 
    uzantısı da ".tar.gz", gibi "tar.xz" gibi dosyanın hem tar'lanmış hem de sıkıştırılmış olduğunu belirten biçimde olur. 
    Açım sırasında da önce sıkıştırılan dosyalar açılır. Buradan ".tar" dosyası elde edilir. Sonra da bu ".tar" dosyasının 
    içerisindeki dosyalar dışarı çıkartılır.

    Linux'ta çeşitli sıkıştırma yöntemleri (formatları da diyebiliriz) kullanılmaktadır. Bunların bazıları şunlardır:

    - gzip formatı (dosyaların uzantıları ".gz" biçimindedir)
    - bz2 formatı (dosyaların uzantıları ".bz2" biçimindedir)
    - xz formatı (dosyaların uzantıları ".xz" biçimindedir)
    - Klasik zip formatı (dosyaların uzantıları ".zip" ya da ".z" biçimindedir)

    Bu formatlar sıkıştırma bakımından farklı performans göstermektedir. Ancak formatın sıkıştırma performansı ne kadar 
    yüksekse işlem yapma süresi de o kadar uzun olmaktadır. Tipik olarak bu formatların sıkıştırma performansları için 
    aşağıdaki ilişki söz konusudur:

    xz > bz2 > gzip == zip

    Yani en iyi sıkıştırma "xz" formatında, daha sonra "bz2" formatında daha sonra da "gzip" formatındadır. gzip formatı ile 
    zip formatı aynı algoritmaları kullanmaktadır. Dolayısıyla bunların performansları birbirine benzerdir. Ancak yukarıda da 
    belirttiğimiz gibi sıkıştırma performansı yükselirken (yani daha iyi hale gelirken) sıkıştırma ve açma için gereken zaman 
    da uzamaktadır.

    Yukarıdaki formatlara göre sıkıştıran ve açan programlar hazır biçimde bulunmaktadır. Bu programların isimleri şunlardır:

    gzip, gunzip
    bzip2, bunzip2
    xz, unxz
    zip, unzip

    zip programının dışındaki programların hepsi tek bir dosyayı sıkıştırıp açmaktadır. Dolayısıyla yukarıda da belirttiğimiz 
    gibi eğer birden fazla dosya sıkıştırılacaksa önce onların birleştirilmesi gerekir. O halde önce "tar" programının kullanımı 
    hakkında bazı bilgiler verelim.

    tar programının pek çok komut satırı seçeneği olsa da en çok kullanıcılan seçenekler "-c" "-x" "-f" "-v" seçenekleridir. 
    "-c" tar'lamak için "-x" ise açmak için kullanılır. "-v" seçeneği programın daha fazla bilgi vermesini sağlamaktadır. 
    "-f" seçeneği bir argümanla kullanılır. Argüman ".tar" dosyasını belirtir. tar programı birden fazla dosyayı komut satırı 
    argümanıyla alabilir. Tabii birden fazla dosyayı belirtmek için kabuğun joker karakterlerinden faydalanabilirsiniz. Argüman 
    olarak dosya yerine dizinler de verilebilir. Bu durumda bu dizinin içerisindeki dosyaların hepsi tar'lanıp açılmaktadır. 
    Örneğin:

    $ tar -c -f test.tar x.txt y.txt z.txt

    Genellikle kullanıcılar seçenekleri aşağıdaki gibi birleştirmektedir:

    $ tar -cf test.tar x.txt y.txt z.txt

    Tabii burada "f" seçeneğinin seçenek listesinde en sonra olması gerekmektedir.

    gzip programı ile sıkıştırmak oldukça kolaydır. Örneğin:

    $ gzip test.tar

    Açma işlemi de şöyle yapılabilir:

    $ gunzip test.tar.gz

    Buradan biz "test.tar" dosyasını elde edeceğiz. Onu da açmamız gerekir. gzip ve gunzip programlarının eski dosyayı da 
    sildiğine dikkat ediniz. tar komutu ile hem tar'lamak hem de aynı zamanda gzip işlemini yapmak için tar komutunda "-z" 
    seçeneği kullanılmaktadır. Yani "-z" seçeneği "önce tar'la sonra gzip yap" anlamına gelmektedir. Tabii tar programı da 
    aslında kendi içerisinde gzip programını da çalıştırmaktadır. Örneğin:

    $ tar -cvzf test.tar.gz x.txt y.txt

    Burada biz dosyaları hem tar'ladık hem de sıkıştırdık. Açma işlemi de aynı biçimde yapılmaktadır:

    $ tar -xvzf test.tar.gz

    bzip2 programının kullanımı gzip programına oldukça benzemektedir. Örneğin:

    $ bzip2 test.tar

    Açım da benzer biçimde yapılmaktadır:

    $ bunzip2 test.tar.bz2

    Önce tar'layıp sonra bzip2 ile sıkıştırma işlemi tek hamlede tar programı tarafından "-j" seçeneği ile yapılabilmektedir. 
    ("-z" seçeneğinin gzip için "-j" seçeneğinin bz2 için kullanıldığına dikkat ediniz.) Örneğin:

    $ tar -cvjf test.tar.bz2 x.txt y.txt

    Açım da benzer biçimde yapılabilir:

    $ tar -xvjf test.tar.bz2

    xz programı ile sıkıştırma yapma da benzer biçimdedir. Örneğin:

    $ xz test.tar

    Açım da benzerdir:

    $ unxz test.tar.xz

    Hem tar'lamak hem de xz haline getirmek için tar programında "-J" seçeneği kullanılmaktadır. Örneğin:

    $ tar -cvJf test.tar.xz x.txt y.txt

    Açım işlemi de şöyle yapılabilir:

    $ tar -xvJf test.tar.xz
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Dağıtımlar (Ubuntu, Mint, Fedora gibi) çekirdek kodlarında küçük değişiklikler ve kendilerine özgü özelleştirmeler 
    ve yamamalar da yapabilmektedir. Debian tabanlı sistemlerde o anda makinede yüklü olan mevcut çekirdeğin ilgili dağıtıma 
    ilişkin kaynak kodlarını indirmek için aşağıdaki komutu da kullanabilirisiniz:

    $ sudo apt-get install linux-source

    Burada yükleme "/usr/src" dizinine yapılacaktır. Ancak bu komut doğrudan sıkıştırılmış dosyayı indirmektedir. Yani açım 
    yapmamaktadır. Aslında istenirse bulunulan makinedeki versiyon numarasına ilişkin dağıtıma özgü kaynak kodlar yerine 
    istenilen bir versiyona ilişkin kaynak kodlar da indirilebilir. Bunun için komutta linux-source argümanına istenilen 
    versiyonun majör, minör ve patch numarası "-majör.minör.patch" biçiminde eklenir. Örneğin:

    $ sudo apt-get install linux-source-6.8.0

    Bu biçimde indirdiğimiz çekirdek kaynak kodları Debian ya da Ubuntu depolarından indirilmektedir. Bunlar bu dağıtımlar 
    tarafından yamanmış kodlardır. Örneğin Mint'te çalışıyorsanız indirdiğiniz kodlar Ubuntu için yamanmış kodlar olacaktır.

    BBB için derleme yapmak istiyorsanız yine "kernel.org"deki kaynak kodları indirebilirsiniz. Ancak BBB için bazı 
    özelleştirmelerin de yapılmış olduğu kaynak kodların indirilip derlenmesi birtakım kolaylıklar sağlamaktadır. Bu aşağıdaki 
    komutla yapabilirsiniz:

    $ git clone https://github.com/beagleboard/linux.git

    Benzer biçimde Raspbbey Pi için de "kernel.org"deki kaynak kodlar kullanılabilir. Ancak Raspberry Pi'a özgü daha 
    güncel aygıt sürücüler ve aygıt ağacı dosyalarını içeren Linux kaynak kodlarının projenin kendi sitesinden indirilmesi 
    daha uygun olur. İndirmeyi aşağıdaki bağlantıdan yapabilirsiniz:

    $ git clone --depth=1 https://github.com/raspberrypi/linux.git
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Linux kaynak kodlarının versiyonlanması eskiden daha farklıydı. Çekirdeğin 2.6 versiyonlarından sonra versiyon 
    numaralandırma sistemi değiştirildi. Eskiden (2.6 ve öncesinde) versiyon numaraları çok yavaş ilerletiliyordu. 2.6 
    sonrasındaki yeni versiyonlamada versiyon numaraları daha hızlı ilerletilmeye başlanmıştır. Bugün kullanılan Linux 
    versiyonları nokta ile ayrılmış üç sayıdan oluşmaktadır:

    Majör.Minör.Patch

    Buradaki "majör numara" büyük ilerlemeleri, "minör numara" ise küçük ilerlemeleri belirtmektedir. Eskiden (2.6 ve 
    öncesinde) tek sayı olan minör numaralar "geliştirme versiyonlarını (ya da beta versiyonlarını)", çift olanlar ise 
    stabil hale getirilmiş dağıtılan versiyonları belirtiyordu. Ancak 2.6 sonrasında artık tek ve çift minör numaralar 
    arasında böyle bir anlam farklılığı kalmamıştır. Patch numarası birtakım böceklerin giderildiği ya da çok küçük 
    yeniliklerin çekirdeğe dahil edildiği versiyonları belirtmektedir. Patch numarası minör numaralardan daha küçük 
    bir ilerlemenin söz konusu olduğunu anlatmaktadır.

    Linux kaynak kodları konfigüre edilip derlendiğinde çekirdek imajının ismine bir alan daha eklenebilmektedir. Bu alana 
    biz "Extra" alanı diyeceğiz. Bu durumda çekirdek imaj ismi (kaynak kod versiyon ismi değil) şu hale gelecektir:

    Majör.Minör.Patch-Extra (Extra için -rcX, -stable, -custom, -generic gibi sözcükler kullanılabilir)

    Bu extra alanı tamamen derleme işlemini yapan kişi ya da kurumun versiyon bilgisine eklediği, onların isteklerine göre 
    belirlenmiş bir alandır. Burada Extra ile temsil edilen alanda "rcX (X burada bir sayı belirtir) "stable", "custom", 
    "generic", "realtime" gibi sözcükler bulunabilmektedir. "rc" harfleri "release candidate" sözcüklerinin kısaltmasıdır. 
    "stable" sözcüğü dağıtılan sürümün "kararlı sürüm" olduğunu belirtir. Eğer sistem programcısı çekirdekte kendisi birtakım 
    değişiklikler yapıyorsa genellikle "Extra" alanında "custom" sözcüğünü kullanır. Ayrıca "Extra" alanındaki sözcüğün başına 
    ya da sonuna versiyon ya da build numaraları getirilebilmektedir. Örneğin "custom" sözcüğünü ayrıca "-<custom_version_number>" 
    biçiminde bir versiyon numarası da izleyebilir. Buradaki numaralar sistem programcısının kendi özelleştirmesine ilişkin 
    numaralardır. "generic" sözcüğünü dağıtımlar sıkça kullanmaktadır. Bu "generic" sözcüğü çekirdeğin "genel kullanım için 
    konfigüre edilmiş olduğunu belirtmektedir. "realtime" sözcüğü genellikle gerçek zamanlı bir yapılandırmada kullanılmaktadır. 
    "generic" ve "realtime" sözcüklerinin öncesinde "-N-" biçiminde bir sayı da bulunabilmektedir. Bu sayı "dağıtıma özgü 
    yama ya da derleme numarasını belirtmektedir. Örneğin:

    6.8.0-51-generic

    Burada -51 yapılandırmaya özgü bir numara belirtmektedir. "-generic" ise yapılandırmanın genel kullanım için olduğunu 
    belirtmektedir.

    Çalışmakta olan Linux sistemi hakkında bilgiler "uname -a" komutu ile elde edilebilir. Örneğin:

    $ uname -a
    Linux kaan-virtual-machine 5.15.0-91-generic #101-Ubuntu SMP Tue Nov 14 13:30:08 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux

    Bu bilgi içerisinden yalnızca çekirdek versiyonu görüntülenmek isteniyorsa "uname -r" seçeneği kullanılmalıdır:

    $ uname -r
    6.8.0-51-generic

    Buradan biz çekirdeğin "6.8.0" sürümünün kullanıldığını anlıyoruz. Burada genel yapılandırılmış bir çekirdek söz 
    konusudur. "91" sayısı dağıtıma özgü yama ya da derleme numarasını belirtir.

    Daha önceden de belirttiğimiz gibi "uname" komutu bu bilgileri "/proc" dosya sisteminin içerisinde almaktadır. 
    Örneğin:

    $ cat /proc/version
    Linux version 5.15.0-91-generic (buildd@lcy02-amd64-045) (gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld
    (GNU Binutils for Ubuntu) 2.38) #101-Ubuntu SMP Tue Nov 14 13:30:08 UTC 2023
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi büyük projelerin derlenmesi için "build otomasyon araçları" denilen araçlar kullanılmaktadır. Bunların 
    en yaygın kullanılanı "make" denilen araçtır. Linux çekirdeklerinin derlenmesi de "make" aracı ile yapılmaktadır. 
    Ancak Linux çekirdeklerinin derlenmesinde projeye özgü bazı yapılar ve yöntemler de kullanılmıştır. Buna "KConfig 
    sistemi" ya da "KBuild sistemi" denilmektedir. Biz önce çekirdek derleme işleminin hangi adımlardan geçilerek yapılacağını 
    göreceğiz. Sonra çekirdeğin önemli konfigürasyon parametreleri üzerinde biraz duracağız. Sonra da çekirdekte bazı 
    değişiklikler yapıp değiştirilmiş çekirdekle sistemin açılmasını sağlayacağız.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Linux'ta çekirdek derlemesi tipik olarak aşağıdaki aşamalardan geçilerek gerçekleştirilmektedir:

    1) Derleme öncesinde derlemenin yapılacağı makinede bazı programların yüklenmiş olması gerekmektedir. Çünkü KBuild 
    sistemi yalnızca binary araçları değil bazı başka kütüphaneleri de kullanmaktadır. Çekirdeğin derlenmesi için gerekebilecek 
    programları şöyle yükleyebilirsiniz:

    $ sudo apt update
    $ sudo apt install build-essential libncurses-dev bison flex libssl-dev wget gcc-arm-linux-gnueabihf \
    binutils-arm-linux-gnueabihf libelf-dev dwarves

    2) Çekirdek kodları indirilerek açılır. Biz bu konuyu yukarıda ele almıştık. İndirmeyi şöyle yapabiliriz:

    $ wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.9.2.tar.xz

    Bu işlemden sonra "linux-6.9.2.tar.xz" isimli dosya indirilmiş durumdadır. Onu aşağıdaki gibi açabiliriz:

    $ tar -xvJf linux-6.9.2.tar.xz

    Bu işlemden sonra "linux-6.9.2" isminde bir dizin oluşturulacaktır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
												6. Ders 03/08/2025 - Pazar
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    3) Çekirdek derlenmeden önce konfigüre edilmelidir. Çekirdeğin konfigüre edilmesi birtakım çekirdek özelliklerin 
    belirlenmesi anlamına gelmektedir. Konfigürasyon bilgileri çekirdek kaynak kod ağacının kök dizininde (örneğimizde 
    "linux-6.9.2" dizini) ".config" ismiyle bulunmalıdır. Bu ".config" dosyası default durumda kaynak dosyaların kök 
    dizininde bulunmamaktadır. Bunun çekirdeği derleyen kişi tarafından oluşturulması gerekmektedir. Çekirdek konfigürasyon 
    parametreleri oldukça fazladır ve bunların bazılarının anlamlandırılması özel bilgi gerektirmektedir. Biz izleyen 
    paragraflarda önemli çekirdek konfigürasyon parametrelerini açıklayacağız. Çekirdek konfigürasyon parametreleri çok 
    fazla olduğu için bunlar bazı genel amaçları karşılayacak biçimde default değerlerle önceden oluşturulmuş durumdadır. 
    Önceden oluşturulmuş default konfigürasyon dosyaları kaynak kod ağacında "arch/<mimari>/configs" dizininin içerisinde 
    bulunmaktadır. Örneğin Intel x86 mimarisi için bu default konfigürasyon dosyaları şöyledir:

    $ ls arch/x86/configs
    hardening.config  i386_defconfig  tiny.config  x86_64_defconfig  xen.config

    Burada biz 64 bit Linux sistemleri için "x86_64_defconfig" dosyasını kullanabiliriz. O halde bu dosyayı kaynak dosyaların 
    bulunduğu dizininin kök dizinine ".config" ismiyle kopyalayabiliriz:

    $ cp arch/x86/configs/x86_64_defconfig .config

    Biz bütün işlemlerde çekirdek kaynak kodlarının kök dizininde bulunduğumuzu (current working directory) varsayacağız. 
    Ancak burada bir noktaya dikkatinizi çekmek istiyoruz. Linux kaynak kodlarındaki default konfigürasyon dosyaları 
    minimalist biçimde konfigüre edilmiştir. Bu nedenle pek çok modül bu default konfigürasyon dosyalarında işaretlenmiş 
    değildir. Bu tür denemeleri zaten çalışan çekirdeğin derlenmesinde kullanılan konfigürasyon dosyalarından hareketle 
    yaparsanız daha fazla modül dosyası oluşturulabilir ancak daha az zahmet çekebilirsiniz. Linux sistemlerinde genel 
    olarak "/boot" dizini içerisinde "config-<çekirdek_sürümü>" ismiyle mevcut çekirdeğe ilişkin konfigürasyon dosyası 
    bulundurulmaktadır.

    Burada bir noktaya dikkatinizi çekmek istiyoruz. Çekirdek kaynak kodlarındaki "arch/<platform>/configs" dizinindeki 
    "x86_64_defconfig" konfigürasyon dosyası ".config" ismiyle kopyalandıktan sonra ayrıca "make menuconfig" ya da "make oldconfig" 
    gibi bir işlemle onun satırlarına delenecek çekirdekte bulunan yeni birtakım özelliklere ilişkin bazı default değerlerin 
    de eklenmesi gerekir. Bu işlem sonraki aşamada açıklayacağımız "make menuconfig" komutyuyla gerçekleştirilmektedir.

    Aslında ".config" dosyasını oluşturmanın başka alternatif yolları da vardır:

    make defconfig: Bu komut çalıştığımız sisteme uygun olan konfigürasyon dosyasını temel alarak mevcut donanım bileşenlerini 
    de gözden geçirerek sistemin açılması için gerekli minimal bir konfigürasyon dosyasını ".config" ismiyle oluşturmaktadır. 
    Örneğin biz 64 bit Intel sistemine ilişkin bir bilgisayarda çalışıyorsak "make defconfig" dediğimizde "arch/x86/configs/x86_64_defconfig" 
    dosyası temel alınarak o anda çalışılmakta olan çekirdek donanımları da göz önünde bulundurularak nispeten minimal 
    olan bir konfigürasyon dosyası oluşturmaktadır.

    make oldconfig: Bu seçeneği kullanmak için kaynak kök dizinde bir ".config" dosyasının bulunuyor olması gerekir. 
    Ancak bu seçenek "KConfig" dosyalarındaki ve kaynak dosya ağacındaki diğer değişiklikleri de göz önüne alarak bu eski 
    ".config" dosyasını eğer söz konusu mimaride birtakım değişiklikler yapılmışsa o değişikliklere uyumlandırmaktadır. Yani örneğin 
    biz eski bir ".config" dosyasını kullanıyor olabiliriz. Ancak çekirdeğin yeni versiyonlarında ek birtakım başka konfigürasyon 
    parametreleri de eklenmiş olabilir. Bu durumda "make oldconfig" bize bu eklenenler hakkında da bazı sorular sorup bunların 
    dikkate alınmasını sağlayacaktır. Başka bir deyişle "make oldconfig" eski bir konfigürasyon dosyasını yeni çekirdekler 
    için uyumlandırmaktadır.

    make <platform>_defconfig: Bu seçenek belli bir platformun default konfig dosyasını ".config" dosyası olarak save 
    etmektedir. Örneğin biz Intel makinelerinde çalışıyor olabiliriz ancak "BeagleBone Black (BBB)" için default konfigürasyon 
    dosyası oluşturmak isteyebiliriz. Eğer biz "make defconfig" yaparsak Intel tabanlı bulunduğumuz platform dikkate 
    alınarak ".config" dosyası oluşturulur. Ancak biz burada örneğin "make bb.org_defconfig" komutunu uygularsak bu durumda 
    Intel mimarisinde çalışıyor olsak da "bb.org_defconfig" konfigürasyon dosyası ".config" olarak save edilir. Tabii biz 
    aslında bu komutu kullanmak yerine ilgili platformun konfigürasyon dosyasını manuel olarak da ".config" biçiminde 
    kopyalayabiliriz.

    make modules: Bu seçenek ile yalnızca modüller derlenir. Yani bu seçenek ".config" dosyasında belirtilen aygıt sürücü 
    dosyalarını derler ancak çekirdek derlemesi yapmaz. Yalnızca "make" işlemi zaten aynı zamanda bu işlemi de yapmaktadır.

    make uninstall: "make install" işlemi ile yapılanları geri alır.

    Aşağıdaki "make xxxconfig" komutları ise seyrek kullanılmaktadır:

    make allnoconfig: Tüm seçenekleri "hayır (no)" olarak ayarlar (minimal özellikler).

    make allyesconfig: Tüm seçenekleri "evet (yes)" olarak ayarlar (maksimum özellikler).

    make allmodconfig: Tüm aygıt sürücülerin çekirdeğin dışında modül (module) biçiminde derleneceğini belirtir.

    make localmodconfig: Sistemde o anda yüklü modüllere dayalı bir yapılandırma dosyası (".config" dosyası) oluşturur.

    make silentoldconfig: Yeni seçenekler için onları görmezden gelir ve o yeni özellikler ".config" dosyasına yansıtılmaz.

    make dtbs: Kaynak kod ağacında "/arch/platform/boot/dts" dizinindeki aygıt ağacı kaynak dosyalarını derler ve "dtb" 
    dosyalarını elde eder. Gömülü sistemlerde bu işlemin yapılması ve her çekirdek versiyonuyla o versiyonun "dtb" dosyasının 
    kullanılması tavsiye edilir. Ancak gömülü sistemlerde zaten "make" işlemi aygıt ağacı dosyalarını da derlemektedir.

    Yukarıda da belirttiğimiz gibi aslında pek çok dağıtım o anda yüklü olan çekirdeğe ilişkin konfigürasyon dosyasını "/boot" 
    dizini içerisinde "config-$(uname -r)" ismiyle bulundurmaktadır. Örneğin kursun yapılmakta olduğu Mint dağıtımında "/boot" 
    dizinin içeriği şöyledir:

    $ ls /boot
    config-6.8.0-51-generic      initrd.img.old
    System.map-6.8.0-51-generic  efi
    grub                         vmlinuz
    initrd.img                   vmlinuz-6.8.0-51-generic
    initrd.img-6.8.0-51-generic

    Buradaki "config-6.8.0-51-generic" dosyası çalışmakta olduğumuz çekirdekte kullanılan konfigürasyon dosyasıdır. Buradaki 
    "config-6.8.0-51-generic" dosyası sistem açılırken herhangi bir biçimde kullanılmamaktadır. (Yani bu dosyayı silseniz 
    hiçbir sorun oluşmaz.) Bu dosya o çekirdeği yeniden derleyecek kişiler için kolaylık sağlamak amacıyla bulundurulmaktadır.

    Daha önceden de belirttiğimiz gibi eğer çalışılan sistemdeki konfigürasyon dosyasını temel alacaksanız bu dosyayı Linux kaynak 
    kodlarının bulunduğu kök dizine ".config" ismiyle kopyalayabilirsiniz:

    $ cp /boot/config-$(uname -r) .config

    Fakat eski bir konfigürasyon dosyasını yeni bir çekirdekle kullanmak için ayrıca "make oldconfig" işleminin de yapılması 
    gerekmektedir. Sonraki maddede göreceğimiz "make menuconfig" işlemi aynı zamanda "make oldconfig" işlemini de kendi 
    içerisinde barındırmaktadır.

    4) Şimdi elimizde pek çok değerin set edilmiş olduğu ".config" isimli bir konfigürasyon dosyası vardır. Artık bu konfigürasyon 
    dosyasından hareketle yalnızca istediğimiz özellikleri değiştirebiliriz. Bunun için "make menuconfig" komutunu kullanabiliriz:

    $ make menuconfig

    Bu komut ile birlikte text ekranda konfigürasyon seçenekleri listelenecektir. Tabii buradaki seçenekler ".config" dosyasındaki 
    içerikten hareketle oluşturulmuş durumdadır. Bunların üzerinde değişiklikler yaparak ".config" dosyasını yeniden save edebiliriz. 
    Aslında "make menuconfig" işlemi hiç ".config" dosyası oluşturulmadan doğrudan da yapılabilmektedir. Bu durumda hangi sistemde 
    çalışılıyorsa o sisteme özgü default config dosyası temel alınmaktadır. Biz en azından "General stup/Local version - append 
    to kernel release" seçeneğine "-custom" gibi bir sonek girmenizi böylece yeni çekirdeğe "-custom" soneki iliştirmenizi tavsiye 
    ederiz. Yukarıda da belirttiğimiz gibi "make menuconfig" işlemi zaten "make oldconfig" işlemini de kendi içerisinde barındırmaktadır.

    Pekiyi biz hazır bir ".config" dosyasını kaynak kod ağacının kök dizinine kopyaladıktan sonra hiç "make menuconfig" ya da 
    "make oldconfig" yazmazsak ne olur? Bu durumda sorun çıkmayabilir. Eğer kaynak kod çekirdeği yeniyse "make" işlemi sırasında 
    "make oldconfig" gibi bir işlem de yapılmaktadır. Ancak biz ".config" dosyasını kaynak kod ağacının kök dizinine kopyaladıktan 
    sonra "make menuconfig" ya da "make oldconfig" işlemini yapmanızı salık veriyoruz. "make menuconfig" işlemini yapıyorssanız 
    ayrıca "make oldconfig" işlemini yapmanıza gerek yoktur.

    ".config" dosyası elde edildiğinde çekirdek imzalamasını ortadan kaldırmak için dosyayı açıp aşağıdaki özellikleri belirtildiği 
    gibi değiştirebilirsiniz (bunların bazıları zaten default durumda aşağıdaki gibi de olabilir):

    CONFIG_SYSTEM_TRUSTED_KEYS=""
    CONFIG_SYSTEM_REVOCATION_KEYS=""
    CONFIG_SYSTEM_TRUSTED_KEYRING=n
    CONFIG_SECONDARY_TRUSTED_KEYRING=n

    CONFIG_MODULE_SIG=n
    CONFIG_MODULE_SIG_ALL=n
    CONFIG_MODULE_SIG_KEY=""

    Çekirdek imzalaması konusu daha ileride ele alınacaktır.

    Yukarıda da belirttiğimiz gibi derlenecek çekirdeklere yerel bir versiyon belirteci ve numarası da atanabilmektedir. 
    Bu işlem Bu "make menuconfig" menüsünde "General Setup/Local version - append custom release" seçeneği kullanılarak 
    ya da ".config" dosyasında "CONFIG_LOCALVERSION" satırı edit edilerek yapılabilir. Örneğin:

    CONFIG_LOCALVERSION="-custom"

    Artık çekirdek sürümüne "-custom" sonekini eklemiş olduk.

    5) Derleme işlemi için "make" komutu kullanılmaktadır. Örneğin:

    $ make

    Eğer derleme işleminin birden fazla CPU ya da çekirdek ile yapılmasını istiyorsanız "-j<cpu_sayısı>" seçeneğini 
    komuta dahil edebilirsiniz. Çalışılan sistemdeki CPU sayısının "nproc" komutuyla elde edildiğini anımsayınız. O halde 
    biz derleme için make komutunu şöyle kullanabiliriz:

    $ make -j$(nproc)

    Derleme işlemi bittiğinde ürün olarak biz "çekirdek imajını (yani çekirdek kodlarının bulunduğu dosyayı)", "çekirdek 
    tarafından yüklenecek olan modül dosyalarını (aygıt sürücü dosyalarını)" ve "diğer bazı dosyaları" elde etmiş oluruz. 
    Derleme işleminden sonra oluşturulan bu dosyalar ve onların yerleri şöyledir (buradaki <çekirdek_sürümü> "uname -r" 
    ile elde edilecek yazıyı belirtiyor):

    - Sıkıştırılmış Çekirdek Imajı: "arch/<platform>/boot" dizininde "bzImage" ismiyle oluşturulmaktadır. Denemeyi yaptığımız 
    Intel makinede dosyanın yol ifadesi "arch/x86_64/boot/bzImage" biçimindedir. (Ancak buradaki dosya x86_64 platformu için 
    "arch/x86/boot/bzImage" dosyasına sembolik link de yapılmış olabilir.)

    - Çekirdeğin Sıkıştırılmamış ELF İmajı: Kaynak kök dizininde "vmlinux" ismiyle oluşturulmaktadır.

    - Çekirdek Modülleri (Aygıt Sürücü Dosyaları): Çekirdek modülleri "drivers" dizininin altındaki dizinlerde, "fs" dizininin 
    altındaki dizinlerde ve "net" dizininin altındaki dizinlerde bulunur. Ancak "make modules_install" ile bunların hepsi 
    belirli bir dizine çekilebilir.

    - Çekirdek Sembol Tablosu: Kaynak kök dizininde "System.map" ismiyle bulunur. Çekirdek sembol tablosundan yalnızca çekirdek 
    debug edilirken faydalanılmaktadır. Bu dosya silinse bile sistemin çalışmasında bir sorun oluşmaz.

    Çekirdeğin derlemesi ne kadar zaman almaktadır? Şüphesiz bu derlemenin yapıldığı makineye göre değişebilir. Ancak derleme 
    süresinin uzamasına yol açan en önemli etken çekirdek konfigüre edilirken seçilen amodül (aygıt sürücü) sayısıdır. Pek 
    çok dağıtım "belki ileride lazım olur" gerekçesiyle konfigürasyon dosyalarında pek çok modülü dahil etmektedir. Bu 
    nedenle bir dağıtımın konfigürasyon dosyasını kullandığınız zaman çekirdek derlemesi uzayacaktır. Ayrıca çekirdek 
    konfigüre edilirken çok fazla modülün dahil edilmesi modüllerin çok fazla yer kaplamasına da yol açabilmektedir. Çekirdek 
    kodlarındaki platforma özgü default konfigürasyon dosyaları daha minimalist bir biçimde oluşturulmuş durumdadır. Derleminin 
    yapıldığı makine ve o makinedeki CPU sayısı da önemlidir. Örneğin sanal makineler genellikle düşük donanım konfigürasyonuyla 
    çalıştırıldığı için sanal makinelerde derleme süresi uzayacaktır. Tabii çekirdek bütünsel olarak bir kez derlendikten sonra 
    çekirdek kodlarında değişiklik yapıp çekirdeği yeniden derlemek istediğimizde artık derleme süresi bütünsel derleme kadar 
    uzun olmayacaktır. Çekirdek kodlarını değiştirdiğimizde ya da çekirdek kodlarına yeni bir dosya ya da dizin eklediğimizde 
    hangi dosyaların yeniden derleneceği yapılan değişikliğin ya da eklemelerin yerine göre değişebilmektedir. Temel dosyalardaki 
    değişiklikler çok fazla dosyanın yenidne derlenmesine yol açmaktadır.

    Bu tür durumlarda biz kursumuzda zamanı kısaltmak için ana makinenin Linux olduğu makine de kullanacağız. Bu makineye 
    dersin yapıldığı Windows host sisteminden uzak bağlantıyla bağlanacağız.

    6) Derleme sonrasında farklı dizinlerde oluşturulmuş olan aygıt sürücü dosyalarını (modülleri) belli bir dizine kopyalamak 
    için "make modules_install" komutu kullanılmaktadır. Bu komut seçeneksiz kullanılırsa default olarak "/lib/modules/<çekirdek_sürümü>" 
    dizinine kopyalama yapar. Her ne kadar bu komut pek çok ".ko" uzantılı aygıt sürücü dosyasını hedef dizine kopyalıyorsa 
    da bunlar çekirdek tarafından otomatik olarak yüklenmemektedir. Bu modüller kullanıcı tarafından yapılan birtakım işlemler 
    sonucunda başka bir deyişle ancak talep edildiğinde yüklenmektedir. Örneğin:

    $ sudo make modules_install

    Aslında "make modules_install" komutunun modül dosyalarını (aygıt sürücü dosyalarını) istediğimiz bir dizine kopyalamasını 
    da sağlayabiliriz. Bunun için INSTALL_MOD_PATH çevre değişkeni kullanılmaktadır. Örneğin:

    $ sudo INSTALL_MOD_PATH=modules make modules_install

    Burada aygıt sürücü dosyaları "/lib/modules/<çekirdek_sürümü>" dizinine değil bulunulan yerdeki "modules" dizinine 
    kopyalanacaktır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Pekiyi "make modules_install" komutu yalnızca modül dosyalarını mı hedef dizine kopyalamaktadır? Hayır aslında bu 
    komut modül dosyalarının kopyalanması dışında bazı dosyaları da oluşturup onları da hedef dizine kopyalamaktadır. 
    make modules_install komutu sırasıyla şunları yapmaktadır:

    - Modül dosyalarını "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.
    - "modules.dep" isimli dosyayı oluşturur ve bunu "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.
    - "modules.alias" isimli dosyayı oluşturur ve bunu "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.
    - "modules.order" isimli dosyayı oluşturur ve "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.
    - "modules.builtin" isimli dosyayı "/lib/modules/<çekirdek_sürümü>" dizinine kopyalar.

    Aslında burada oluşturulan dosyaların bazıları mutlak anlamda bulundurulmak zorunda değildir. Ancak sistemin öngörüldüğü 
    gibi işlev göstermesi için bu dosyaların ilgili dizinde bulundurulması uygundur.

    Bir aygıt sürücü başka aygıt sürücüleri de kullanıyor olabilir. Bu durumda bu aygıt sürücü yüklenirken onun kullandığı 
    tüm sürücülerin özyinelemeli olarak yüklenmesi gerekir. İşte "modules.dep" dosyası bir aygıt sürücünün yüklenmesi için 
    başka hangi aygıt sürücülerin yüklenmesi gerektiği bilgisini tutmaktadır. Aslında "modules.dep" bir text dosyadır. Bu 
    text dosya" satırlardan oluşmaktadır. Satırların içeriği şöyledir:

    <modül_yolu>: <bağımlılık1> <bağımlılık2> ...

    Dosyanın içeriğine şöyle örnek verebiliriz:
    ...
    kernel/arch/x86/crypto/nhpoly1305-sse2.ko.zst: kernel/crypto/nhpoly1305.ko.zst kernel/lib/crypto/libpoly1305.ko.zst
    kernel/arch/x86/crypto/nhpoly1305-avx2.ko.zst: kernel/crypto/nhpoly1305.ko.zst kernel/lib/crypto/libpoly1305.ko.zst
    kernel/arch/x86/crypto/curve25519-x86_64.ko.zst: kernel/lib/crypto/libcurve25519-generic.ko.zst
    ...

    Eğer bu "modules.dep" dosyası olmazsa bu durumda "modeprob" komutu çalışmaz ve çekirdek modülleri yüklenirken eksik 
    yükleme yapılabilir. Dolayısıyla sistem düzgün bir biçimde açılmayabilir. Eğer bu dosya elimizde yoksa ya da bir 
    biçimde silinmişse bu dosyayı yeniden oluşturabiliriz. Bunun için "depmod -a" komutu kullanılmaktadır. Komut doğrudan 
    kullanıldığında o anda çekirdek sürümü için "modules.dep" dosyasını oluşturmaktadır. Örneğin:

    $ sudo depmod -a

    Ancak siz yüklü olan başka bir çekirdek sürümü için "modules.dep" dosyasını oluşturmak istiyorsanız bu durumda çekirdek 
    sürümünü de komut satırı argümanı olarak aşağıdaki gibi komuta vermelisiniz:

    $ sudo depmod -a <çekirdek sürümü>

    Tabii depmod komutunun çalışabilmesi için "/lib/modules/<çekirdek_sürümü>" dizininde modül dosyalarının bulunuyor olması 
    gerekir. Çünkü bu komut bu dizindeki modül dosyalarını tek tek bulup ELF formatının ilgili bölümlerine bakarak modülün 
    hangi modülleri kullandığını tespit ederek "modules.dep" dosyasını oluşturmaktadır.

    "modules.alias" dosyası belli bir isim ya da id ile aygıt sürücü dosyasını eşleştiren bir text dosyadır. Bu dosyanın 
    bulunmaması bazı durumlarda sorunlara yol açmayabilir. Ancak örneğin USB port'a bir aygıt takıldığında bu aygıta ilişkin 
    aygıt sürücünün hangisi olduğu bilgisi bu dosyada tutulmaktadır. Bu durumda bu dosyanın olmayışı aygıt sürücünün yüklenememesine 
    neden olabilir. Dosyanın içeriği aşağıdaki formata uygun satırlardan oluşmaktadır:

    alias <tanımlayıcı> <modül_adı>

    Örnek bir içerik şöyle olabilir:

    ...
    alias usb:v05ACp*d*dc*dsc*dp*ic*isc*ip*in* apple_mfi_fastcharge
    alias usb:v8086p0B63d*dc*dsc*dp*ic*isc*ip*in* usb_ljca
    alias usb:v0681p0010d*dc*dsc*dp*ic*isc*ip*in* idmouse
    alias usb:v0681p0005d*dc*dsc*dp*ic*isc*ip*in* idmouse
    alias usb:v07C0p1506d*dc*dsc*dp*ic*isc*ip*in* iowarrior
    alias usb:v07C0p1505d*dc*dsc*dp*ic*isc*ip*in* iowarrior
    ...

    Bu dosya bir biçimde silinirse yine "depmod -a" komutu ile oluşturulabilir. (Yani "depmod" komutu yalnızca "modules.dep" 
    dosyasını değil bu dosyayı da oluşturmaktadır.)

    "modules.order" dosyası aygıt sürücü dosyalarının yüklenme sırasını barındıran bir text dosyadır. Bu dosyanın her 
    satırında bir çekirdek aygıt sürücüsünün dosya yol ifadesi bulunur. Daha önce yazılmış aygıt sürücüler daha sonra 
    yazılanlardan daha önce yüklenir. Bu dosyanın olmaması genellikle bir soruna yol açmaz. Ancak modüllerin belli sırada 
    yüklenmemesi bazı durumlarda bozukluklara da neden olabilmektedir. Bu dosyanın silinmesi durumunda yine bu dosya da 
    "depmod -a" komutuyla oluşturulabilmektedir.

    7) Eğer gömülü sistemler için derleme yapıyorsanız kaynak kod ağacında "arch/<platform>/boot/dts" dizini içerisindeki aygıt 
    ağacı kaynak dosyalarını da derlemelisiniz. Tabii elinizde zaten o versiyona "özgü aygıt (device tree blob)" dosyası 
    bulunuyor olabilir. Bu durumda bu işlemi hiç yapmayabilirsiniz. Aygıt ağacı kaynak dosyalarını derlemek için "make dtbs" 
    komutunu kullanabilirsiniz:

    $ make dtbs

    Derlenmiş aygıt ağacı dosyaları "arch/<platform>/boot/dts" dizininde ya da bu dizinin altındaki ilgili "vendor" dizininde 
    oluşturulacaktır. Yukarıda da belirttiğimiz gibi aygıt ağaçları gömülü sistemlerde kullanılmaktadır. Intel tabanlı PC'lerde 
    donanım birimlerinin tespit edilmesi otomatik olarak ACPI protokolü yoluyla yapıldığı için aygıt ağacı dosyaları bu platformda 
    kullanılmamaktadır. Ancak örneğin ARM platformunu kullanan gömülü sistemlerde ya da BBB ve Raspberry Pi gibi SBC'lerde aygıt 
    ağaçları kullanılmaktadır.

    8) Bizim çekirdek imajını, geçici kök dosya sistemine ilişkin dosyayı (bunu bizim oluşturmamız gerekir) ve aygıt ağacı 
    dosyasını "/boot" dizinine kopyalamamız gerekir. Ancak aslında bu işlem de "make install" komutuyla otomatik olarak 
    yapılabilmektedir. "make install" komutu bu dosyaları "/boot" dizinine kopyalamanın yanı sıra aynı zamanda GRUB önyükleyici 
    programın konfigürasyon dosyalarında da güncellemeler yapıp yeni çekirdeğin GRUB menüsü içerisinde görünmesini de 
    sağlamaktadır. Komut şöyle kullanılabilir:

    $ sudo make install

    Burada biz "geçici kök dosya sistemi ("initial ramdisk" ya da "initrd") diye bir terim kullandık. Geçici kök dosya sistemi 
    diskteki asıl kök dosya sistemi mount edilene kadar geçici bir süre sanki diskteki dosya sistemiymiş gibi işlev gören bir 
    RAM disk imajıdır. Tipik Linux sistemlerinde önce geçici kök dosya sistemi mount edilerek temel dosyalara oradan erişilir. 
    Sonra bu geçici dosya sistemi RAM'den atılıp diskteki gerçek kök dosya sistemi mount edilmektedir. Şimdi "geçici kök dosya 
    sistemine ne gerek var, doğrudan diskteki asıl kök dosya sistemi neden kullanılamıyor?" sorusu aklınıza gelebilir. Geçici 
    kök dosya sistemine gereksinimi basit bir örnekle anlayabiliriz. Diyelim ki diske erişmekte kullanılan aygıt sürücüsü 
    çekirdeğin içerisine yerleştirilmemiş olsun yani dışarıda "lib/modules/$(uame -r)" dizininde bir dosya biçiminde bulunyor 
    olsun. Şimdi çekirdeğin diske erişebilmesi için bu aygıt sürücüye ihtiyacı olacaktır. Ancak aygıt sürücü de disktedir. 
    İşte böyle bir durumda bu aygıt sürücüleri de barındıran bir RAM disk dosya sistemi oluşturulmakta ve önyükleyici 
    tarafından (örneğin GRUB önyükleyicisi) bu dosya da RAM'e yüklenmektedir. Böylece çekirdek artık diske erişebilir 
    hale gelir. Tabii bu gereklilik yalnızca diske erişim için söz konusu değildir. Diske erişmeden önce de başka aygıt 
    sürücülere gereksinim olabilmektedir. Ayrıca bazı kabuk komutlarının da çalıştırılabilmesi gerekebilmektedir. Pekiyi 
    bir Linux sistemi hiç geçici kök dosya sistemi olmadan da boot edilebilir mi? Evet teorik olarak bu mümkündür. Eğer 
    çekirdeğin gereksinim duyacağı bütün aygıt sürücü dosyaları konfigürasyon aşamasında çekirdeğin içerisine gömülmüşse 
    geçici kök dosya sistemi oluşturmadan da sistem boot edilebilir. Ancak bu sırada çözülmesi gereken problemlerle de 
    karşılaşılabilmektedir. Özellikle masaüstü sistemlerinde geçici kök dosya sistemi olmadan sistemi boot etmek oldukça 
    zahmetlidir. Geçici kök dosya sistemi aynı zamanda işletim sistemini "güvenli kipte (safe mode)" açmak için de 
    kullanılmaktadır. Geçici kök dosya sistemi sistem güncellemelerinde de kullanılmaktadır. Pek çok durumda çalışmakta 
    olan dosyalar diskte değiştirilemediği için mecburen sistem güncellemeleri geçici kök dosya sistemi yoluyla yapılmaktadır.

    "make install" komutu sırasıyla yapılanlar şunlardır:

    - Çekirdek imajı "arch/<platform>/boot/bzImage" dizininden alınarak hedef "/boot" dizinine "vmlinuz-<çekirdek_sürümü>" 
    ismiyle kopyalanır.
    - "System.map" dosyası hedef "/boot" dizinine "System.map-<çekirdek_sürümü>" ismiyle kopyalanır.
    - ".config" dosyası "/boot" dizinine "config-<çekirdek_sürümü>" ismiyle kopyalanır.
    - "Geçici kök dosya sistemine ilişkin dosyayı oluşturulur ve hedef "/boot" dizinine "initrd.img-<çekirdek_sürümü>" 
    ismiyle kopyalanır. (Aslında GRUB geçici kök dosya sistemini "update-initramfs" isimli programla oluşturmaktadır.)
    - Eğer GRUB önyükleyicisi kullanılıyorsa GRUB konfigürasyonu güncellenir ve GRUB menüsüne yeni girişler eklenir. 

    Böylece sistemin otomatik olarak yeni çekirdekle açılması sağlanır.

    "make install" komutu uygulandığında eğer çekirdeğin versiyon bilgisi aynı ise "/boot" dizinindeki bir önceki kurulumun 
    dosyaları ".old" uzantısıyla saklanmaktadır. Böylece son "make install" komutundan önceki kuruluma manuel olarak geri 
    dönebilirsiniz. Örneğin yeniden aynı çekirdek versiyonunu "make install" yaptığımızda "/boot" dizininin içeriği şöyle
    olacaktır:

    kaan@kaan-Huawei:~/Study/LinuxKernel/linux-6.9.2$ ls -l /boot
    total 655480
    -rw-r--r-- 1 root root    287375 Haz  7  2024 config-6.8.0-38-generic
    -rw-r--r-- 1 root root    287766 Ağu 15 11:57 config-6.9.2-custom
    -rw-r--r-- 1 root root    287766 Ağu 15 11:55 config-6.9.2-custom.old
    drwx------ 3 root root      4096 Oca  1  1970 efi
    drwxr-xr-x 6 root root      4096 Ağu 15 11:57 grub
    lrwxrwxrwx 1 root root        23 Ağu 10 11:20 initrd.img -> initrd.img-6.9.2-custom
    -rw-r--r-- 1 root root  73052139 Kas 19  2024 initrd.img-6.8.0-38-generic
    -rw-r--r-- 1 root root 526888758 Ağu 15 11:57 initrd.img-6.9.2-custom
    -rw------- 1 root root   9055262 Haz  7  2024 System.map-6.8.0-38-generic
    -rw-r--r-- 1 root root   8365115 Ağu 15 11:57 System.map-6.9.2-custom
    -rw-r--r-- 1 root root   8365115 Ağu 15 11:55 System.map-6.9.2-custom.old
    lrwxrwxrwx 1 root root        20 Ağu 15 11:57 vmlinuz -> vmlinuz-6.9.2-custom
    -rw-r--r-- 1 root root  14944648 Haz  7  2024 vmlinuz-6.8.0-38-generic
    -rw-r--r-- 1 root root  14819840 Ağu 15 11:57 vmlinuz-6.9.2-custom
    -rw-r--r-- 1 root root  14819840 Ağu 15 11:55 vmlinuz-6.9.2-custom.old
    lrwxrwxrwx 1 root root        24 Ağu 15 11:57 vmlinuz.old -> vmlinuz-6.9.2-custom.old
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
                                        7. Ders 09/08/2025 - Cumartesi
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Biz "make install" komutu ile yapılan işlemleri manuel olarak da yapabiliriz. Yukarıda da belirttiğimiz gibi derleme 
    işlemi sonucunda elde edilmiş olan dosyaların hedef sistemde bazı dizinlerde bulunuyor olması gerekir. Aslında çekirdek 
    imajı ve geçici kök dosya sistemi dosyaları default yerlerin dışında başka yerlerde de bulundurulabilir. Önyükleyiciye 
    bu konuda bilgi verilebilir. Ancak yukarıdaki dosyaların hedef sistemde bulundurulduğu default yerler şöyledir:

    - Çekirdek İmajı ---> "/boot" dizini
    - Çekirdek Sembol Tablosu ---> "/boot" dizini
    - Modül Dosyaları ---> "/lib/modules/<çekirdek_sürümü>/kernel" dizini
    - Geçici Kök Dosya Sistemi Dosyası ---> "/boot" dizinine

    Ancak yukarıdaki dosyalar dışında isteğe bağlı olarak aşağıdaki dosyalar da hedef sisteme konuşlandırılabilir:

    - Konfigürasyon Dosyası ---> "/boot" dizini
    - Modüllere İlişkin Bazı Dosyalar ---> "/lib/modules/<çekirdek_sürümü>" dizinine

    Pekiyi yukarıda belirttiğimiz dosyalar hedef sistemdeki ilgili dizinlere hangi isimlerle kopyalanmalıdır? İşte tipik 
    isimlendirme şöyle olmalıdır (buradaki <çekirdek_sürümü> "uname -r" komutuyla elde edilecek olan yazıdır):

    - Çekirdek İmajı: "/boot/vmlinuz-<çekirdek_sürümü>". Örneğin "vmlinuz-6.9.2-custom" gibi.
    - Çekirdek Sembol Tablosu: "/boot/System.map-<çekirdek_sürümü>". Örneğin "System.map-6.9.2-custom" gibi.
    - Modüllere İlişkin Dosyalar: Bunlar yukarıda da belirttiğimiz gibi "/lib/modules/<çekirdek_sürümü>" dizininin içerisine 
    kopyalanmalıdır.
    - Konfigürasyon Dosyası: "/boot/config-<çekirdek_sürümü>". Örneğin "config-6.9.2-custom" gibi.
    - Geçici Kök Dosya Sistemine İlişkin Dosya: "/boot/initrd.img-<çekirdek_sürümü>". Örneğin "initrd.img-6.9.2-custom" gibi.
    Bu dosyayı "update-initramfs" programıyla oluşturabilirsiniz. 

    Ayrıca bazı dağıtımlarda "/boot" dizini içerisindeki "vmlinuz" dosyası default olan "vmlinuz-<çekirdek_sürümü>" dosyasına, 
    "initrd.img" dosyası da "/boot/initrd.img-<çekirdek_sürümü>" dosyasına sembolik link yapılmış durumda olabilir. Ancak bu 
    sembolik bağlantıları GRUB kullanmamaktadır. Aşağıda Intel sistemindeki 6.8.0 çekirdeğinin yüklü olduğu "/boot" dizinin 
    default içeriğini görüyorsunuz:

    $ ls -l /boot    
    -rw-r--r-- 1 root root    287375 Haz  7  2024 config-6.8.0-38-generic
    drwx------ 3 root root      4096 Oca  1  1970 efi
    drwxr-xr-x 6 root root      4096 Ağu 15 11:57 grub
    lrwxrwxrwx 1 root root        23 Ağu 10 11:20 initrd.img -> initrd.img-6.8.0-38-generic
    -rw-r--r-- 1 root root  73052139 Kas 19  2024 initrd.img-6.8.0-38-generic
    -rw------- 1 root root   9055262 Haz  7  2024 System.map-6.8.0-38-generic
    lrwxrwxrwx 1 root root        20 Ağu 15 11:57 vmlinuz -> vmlinuz-6.8.0-38-generic
    -rw-r--r-- 1 root root  14944648 Haz  7  2024 vmlinuz-6.8.0-38-generic

    Geçici kök dosya sisteminin içerisindeki dosyalar "cpio" denilen bir arşiv formatıyla arşivlenmektedir. cpio arşivi
    aslında tıpkı "tar" arşivinde olduğu gibi yalnızca dosyaların uç uca eklenmesiyle oluşturulmaktadır. İstersenin geçiçi 
    kök dosya sistemine ilişkin "initrd-xxx" dosyalarını açabilirsiniz. Ancak bu dosyaların içeriği dağıtımların versiyonlarına 
    göre değişebilmektedir. Yeni dağıtımlarda bu "initrd-xxx" arşiv dosyası birkaç bölümden oluşmaktadır. Eğer diz bu dosyayı 
    "cpio" programıyla açmaya çalışırsanız bu progam yalnızca ilk bölümü açacaktır. Tüm bölümleri açmak için "unmkinitramfs" 
    programından fayalanılabilirsiniz. unmkinitramfs programı ile açım şöyle yapılabilir:

    unmkinitramfs /boot/initrd.img-6.9.2-custom initrd

    Bu komutla geici kök dosya sistemine ilişkin arşiv dosyası "initrd" isimli dizinin altına açılacaktır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Pekiyi derleme sonucunda elde ettiğimiz dosyaları manuel isimlendirirken çekirdek sürüm yazısını nasıl bileceğiz? 
    Bunun için "uname -r" komutunu kullanamayız. Çünkü bu komut bize o anda çalışmakta olan çekirdeğin sürüm yazısını 
    verir. Biz yukarıdaki denemede Linux'un "6.9.2" sürümünü derledik. Bunun sonuna da "-custom" getirdik. Bu durumda 
    sürüm yazısının da "6.9.2-custom" olmasını bekleriz. Burada önemli bir uyarıda bulunmak istiyoruz. Bu sürüm yazısı 
    manuel olarak dosyaların isimlerinin değiştirilmesiyle değiştirilememektedir. Çünkü sürüm yazısı çekirdek imajının 
    içerisine de yazılmaktadır ve bizim bazı dosyalara verdiğimiz isimlerin çekirdek içerisindeki bu yazıyla uyumlu olması 
    gerekir. Default olarak "kernel.org" sitesinden indirilen kaynak kodlar derlendiğinde çekirdek sürümü "6.9.2" gibi üç 
    haneli bir sayılardan oluşmaktadır. Yani yazının sonunda "-generic" gibi "-custom" gibi sonekler yoktur. Tabii çekirdeği 
    derlemeden önce yukarıda da belirttiğimiz gibi ".config" dosyasında "CONFIG_LOCALVERSION" özelliğine bu sürüm numarasından 
    sonra eklenecek bilgiyi girebilirsiniz. Örneğin:

    CONFIG_LOCALVERSION="-custom"

    Anımsayacağınız gibi bu işlem "make menuconfig" menüsünde "General Setup/Local version - append custom release" seçeneği 
    kullanılarak da yapılabilmektedir. Biz buradaki örneğimizde bu işlemi yaparak çekirdeği derledik. Dolayısıyla bizim derlediğimiz 
    çekirdekte çekirdek imajı içerisinde yazan sürüm ismi "6.9.2-custom" biçimindedir. Pekiyi biz bu ismi unutsaydık nasıl 
    öğrenebilirdik? Bunun basit bir yolu sıkıştırılmamış çekirdek dosyası içerisindeki (kaynak kök dizindeki "vmlinux" dosyası) 
    string tablosunda "Linux version" yazısını aramaktır. Örneğin:

    $ strings vmlinux | grep "Linux version"
    Linux version 6.9.2-custom (kaan@kaan-virtual-machine) (gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld (GNU Binutils for 
    Ubuntu) 2.38) # SMP PREEMPT_DYNAMIC
    Linux version 6.9.2-custom (kaan@kaan-virtual-machine) (gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld (GNU Binutils for 
    Ubuntu) 2.38) #2 SMP PREEMPT_DYNAMIC Thu Dec 5 17:55:14 +03 2024

    Buradan sürüm yazısının "6.9.2-custom" olduğu görülmektedir. O halde bizim derleme sonucunda elde ettiğimiz dosyaları 
    manuel biçimde kopyalarken sürüm bilgisi olarak "6.9.2-custom" yazısını kullanmamız gerekir. Çekirdek imajının "/boot" 
    dizinine manuel kopyalanması işlemi şöyle yapılabilir (kaynak kök dizinde bulunduğumuzu varsayıyoruz):

    $ sudo cp arch/x86_64/boot/bzImage /boot/vmlinuz-6.9.2-custom

    Konfigürasyon dosyasını da şöyle kopyalayabiliriz:

    $ sudo cp .config /boot/config-6.9.2-custom

    Tabii bizim çekirdek modüllerini de "/lib/modules/6.9.2-custom/kernel" dizinine, geçici kök dosya sistemine ilişkin 
    dosyayı da "/boot" dizinine kopyalamamız gerekir. Çekirdek modüllerinin kopyalanması biraz zahmetli bir işlemdir. 
    Çünkü bunlar derlediğimiz çekirdekte farklı dizinlerde bulunmaktadır. Bu kopyalamanın en etkin yolu "make modules_install" 
    komutunu kullanmaktır. Benzer biçimde çekirdek dosyalarının ve gerekli diğer dosyaların uygun yerlere kopyalanması 
    için de en etkin yöntem "make install" komutudur.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Normal olarak biz "make install" yaptığımızda eğer sistemimizde GRUB önyükleyicisi varsa komut GRUB konfigürasyon 
    dosyalarında da güncellemeler yaparak sistemin yeni çekirdekle açılmasını sağlamaktadır. Böylece kullanıcı bir menü 
    yoluyla sistemin kendi istediği çekirdekle açılmasını da sağlayabilmektedir. GRUB menüsü otomatik olarak görüntülenmemektedir. 
    Boot işlemi sırasında ESC tuşuna basılırsa menü görüntülenir. Eğer GRUB menüsünün her zaman görüntülenmesi isteniyorsa 
    "/etc/default/grub" dosyasındaki iki satır aşağıdaki gibi değiştirilmelidir:

    GRUB_TIMEOUT_STYLE=menu
    GRUB_TIMEOUT=5

    Buradaki GRUB_TIMEOUT satırı eğer müdahale yapılmamışsa menünün en fazla 5 saniye görüntüleneceğini belirtmektedir.

    Bu işlemden sonra "update-grub" programı da çalıştırılmalıdır:

    $ sudo update-grub

    Bu tür denemeler yapılırken GRUB menüleri bozulabilmektedir. Düzeltme işlemleri bazı konfigürasyon dosyalarının edit 
    edilmesiyle manuel biçimde yapılabilir. Konfigürasyon dosyaları güncellendikten sonra "update-grub" programı mutlaka 
    çalıştırılmalıdır. Ancak eğer GRUB konfigürasyon dosyaları konusunda yeterli bilgiye sahip değilseniz GRUB işlemlerini 
    görsel bir biçimde "grub-customizer" isimli programla da yapabilirsiniz. Bu program "debian depolarında" olmadığı için 
    önce aşağıdaki gibi programın bulunduğu yerin "apt" kayıtlarına eklenmesi gerekmektedir:

    $ sudo add-apt-repository ppa:danielrichter2007/grub-customizer
    $ sudo apt-get update
    $ sudo apt-get install grub-customizer

    Bu işlemden sonra kurulum yapılabilir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Biz yukarıda çekirdek derleme ve yeni çekirdeği kurma sürecini maddeler halinde açıkladık. Şimdi yukarıdaki adımları 
    özet haline getirelim:

    1) Çekirdek derlemesi için gerekli olan araçlar kurulur.

    2) Çekirdek kodları indirilir ve açılır.

    3) Zaten hazır olan konfigürasyon dosyası "/boot" dzininden alınarak ".config" ismiyle kaynak kök dizine kopyalanır.

    4) Konfigürasyon dosyası üzerinde "make menuconfig" komutu ile değişiklikler yapılır. 

    5) Eğer çekirdeğin imzalanması istenmiyorsa yukarıda belirtildiği gibi ".config" dosyasındaki bazı satırlar üzerinde
    değişiklikler yapılır.

    6) Çekirdek derlemesi "make -j$(nproc)" komutu ile gerçekleştirilir.

    7) Modüller ve ilgili dosyalar hedefe "sudo make modules_install" komutu ile konuşlandırılır.

    8) Çekirdek imajı ve ilgili dosyalar "sudo make install" komutu ile hedefe konuşlandırılır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Pekiyi yeni çekirdeği derleyip sisteme dahil ettikten sonra nasıl onu sistemden tamamen çıkartabiliriz? Tabii yapılan 
    işlemlerin tersini yapmak gerekir. Kaldırma işlemi manuel biçimde şöyle yapılabilir:

    - "/lib/modules/<çekirdek_sürümü>" dizini tamamen silinir.
    - "/boot" dizinindeki çekirdek sürümüne ilişkin dosyalar silinir.
    - "/boot" dizininden çekirdek sürümüne ilişkin dosyalar silindikten sonra "update-grub" programı sudo ile çalıştırılmalıdır.
    Bu program "/boot" dizinini inceleyip otomatik olarak ilgili girişleri GRUB menüsünden siler. Yani aslında GRUB 
    konfigürasyon dosyaları üzerinde manuel değişiklik yapmaya gerek yoktur. GRUB işlemleri için diğer bir alternatif 
    ise "grub-customizer" programı ile görsel silme yapmaktır. Ancak bu program "/boot" dizini içerisindeki dosyaları 
    ve modül dosyalarını silmez. Yalnızca ilgili girişleri GRUB menüsünden çıkartmaktadır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
                                        8. Ders 10/08/2025 - Pazar
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Çekirdeği yeniden derlemenin gerekçelerinden bahsetmiştik. Bunlardan biri de çekirdek kodları üzerinde değişikliklerin 
    yapılmış olmasıydı. Pekiyi çekirdek kodları üzerinde değişiklikler nasıl yapılabilir? Çekirdek kodları üzerinde değişiklikler 
    tipik olarak dört yolla  yapılmaktadır:

    1) Çekirdek kodlarındaki bir dosya içerisinde bulunan fonksiyon kodlarında değişiklik yapılması.
    2) Çekirdek kodlarındaki bir dosya içerisine yeni bir fonksiyon eklenmesi.
    3) Çekirdek kodlarındaki bir dizin içerisine yeni bir C kaynak dosyası eklenmesi.
    4) Çekirdek kodlarındaki bir dizin içerisine yeni bir dizin ve bu dizinin içerisine de çok sayıda C kaynak dosyalarının 
    eklenmesi.

    Eğer biz birinci maddedeki ve ikinci maddedeki gibi çekirdek kodlarına yeni bir dosya eklemiyorsak çekirdeğin derlenmesini
    sağlayan make dosyalarında bir değişiklik yapmamıza gerek yoktur. Ancak çekirdeğe yeni bir kaynak dosya ya da dizin 
    ekleyeceksek bu eklemeyi yaptığımız dizindeki make dosyasında izleyen paragraflarda açıklayacağımız biçimde bazı 
    güncellemelerin yapılması gerekir. Böylece çekirdek yeniden derlendiğinde bu dosyalar da çekirdek imajının içerisine 
    eklenmiş olacaktır. Eğer kaynak kod ağacında bir dizinin altına yeni bir dizin eklemek istiyorsak bu durumda o dizini 
    yine üst dizine ilişkin make dosyasında belirtmemiz ve o dizinde ayrı bir Makefile oluşturmamız gerekir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    GNU Make aracı oldukça ayrıntılı özelliklere sahip bir build aracıdır. Bu aracın ayrıntılarını öğrenmek ayrı bir 
    çabayı gerektirmektedir. Make dili aslında aldukça aşağı seviyeli bir build dilidir. Bu nedenle özellikle son yirmi 
    yıldır programcılar doğrudan GNU Make aracını kullanmak yerine daha üst düzey make araçlarını kullanmayı tercih 
    etmektedir. Bunlardan en yaygın olanlardan biri CMake denilen araçtır. Microsoft MSBuild isimli kendi tasarladığı 
    build aracını kullanmaktadır.
        
    Make dilinde değişkenler oluşturulabilmektedir. Örneğin:

    obj-y = a.o

    Burada obj-y isimli değişken a.o bilgisini tutmaktadır. Değişkenleri bir çeşit makro gibi düşünebilirsiniz. Bir 
    değişkene ekleme yapmak için Make dilinde += operatörü kullanılaktadır. Örneğin:

    obj-y = a.o
    obj-y += b.o 
    obj-y += c.o 

    Burada artık obj-y değişkeni a.o b.o c.o biçiminde olacaktır. 

    Linux çekirdeğinde özyinelemeli bir make yöntemi kullanılmaktadır. Her dizinde bir Makefile dosyası vardır. Bunun 
    içerisindeki obj-y gibi obj-m gibi bazı değişkenler += operatöryle eklenerek biriktirilmektedir. Bunlar da derleme
    ve bağlama işlemine sokulmaktadır. Yukarıda da belirttiğimiz gibi Linux'taki bu build sistemine KBuild ya da KConfig 
    sistemi denilmektedir. 

    Bizim Linux'ta Makefile dosyaları üzerinde gerekli güncellemeleri yapmak için çok fazla bilgiye sahip olmamız gerekmez.
    Bazı yönergeleri uygun bir biçimde yerine getirirsek hedefimize ulaşabiliriz. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Linux kaynak kod ağacında dizinlerin altında "Makefile" isimli make dosyaları bulunur. Eğer bir dizinin altına yeni 
    bir dosya eklenecekse o dizinin içerisinde bulunan Makefile dosyasının içerisine aşağıdaki gibi bir satırın eklenmesi 
    gerekir:

    obj-y += dosya_ismi.o

    Buradaki += operatörü obj-y isimli hedefe ekleme yapma anlamına gelmektedir. "obj" sözcüğünün yanındaki "-y" harfi 
    ilgili dosyanın çekirdeğin bir parçası biçiminde çekirdek imajının içerisine gömüleceğini belirtmektedir. Make dosyalarının 
    bazı satırlarında "obj-y" yerine "obj-m" de görebilirsiniz. Bu da ilgili dosyanın ayrı bir modül biçiminde derleneceği 
    anlamına gelmektedir. Eklemeler genellikle çekirdek imajının içine yapıldığı için biz de genellikle "obj-y" kullanırız. 
    Eğer bir dosyanın (aygıt sürücüler için bu durum söz konusudur) çekirdek imajının içine gömülmesi yerine ayrı bir çekirdek 
    modülü olarak derlenmesi isteniyorsa bu durumda dosyanın yerleştirildiği dizinin "Makefile" dosyasına aşağıdaki gibi bir 
    eklemenin yapılması gerekir:

    obj-m += dosya_ismi.o

    Eğer çekirdek kaynak kodlarına tümden bir dizin eklemek isteniyorsa bu durumda önce o dizininin oluşturulduğu dizindeki 
    "Makefile" dosyasına aşağıdaki gibi bir ekleme yapılmalıdır: 

    obj-y += dizin_ismi/

    Burada dizin isminden sonra '/' karakterini unutmayınız. Tabii bu ekleme bir modül biçiminde de olabilirdi:

    obj-m += dizin_ismi/

    Fakat bu ekleme tek başına yetmemektedir. Bu ekleme yapıldıktan sonra  ayrıca yaratılan dizinde "Makefile" isimli 
    bir dosyanın oluşturulması ve o dosyanın içerisinde o dizindeki kaynak dosyaların da belirtilmesi gerekmektedir. 
    Örneğin biz "drivers" dizininin altında "mydriver" isimli bir dizin oluşturup onun da içerisine "a.c" "b.c" ve "c.c" 
    dosyalarını eklemiş olalım. Bu durumda önce "drivers" dizini içerisindeki "Makefile" dosyasına aşağıdaki gibi bir 
    satır ekleriz:

    obj-y += mydriver/

    Sonra da "mydriver" dizini içerisinde "Makefile" isimli bir dosya oluşturup bu dosyanın içerisinde de dizin içerisindeki
    dosyaları belirtiriz. Örneğin:

    obj-y += a.o
    obj-y += b.o
    obj-y += c.o
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Kaynak kod ağacında Makefile dosyasının dşında build sistemiyle ilgili "Kconfig" isimli dosyalar da bulunmaktadır. 
    Bu dosyaların içerisinde ilgili dosyaların ya da dizinlerin "konfigürasyon dosyasına" yansıtılması için gerekli 
    bilgiler bulundurulmaktadır. Örneğin biz eklediğimiz "mydriver" dizinindeki dosyaların çekirdek kodlarına dahil edilip 
    edilmeyeceğini çekirdeği derleyenin konfigürasyon aşamasında belirlemesini sağlayabiliriz. Bunun için bu "Kconfig" 
    dosyasına bir giriş eklememiz gerekir. Böylece bu giriş de "menuconfig" yapıldığında bir seçenek olarak karşımıza 
    gelecektir. Tabii ekleyeceğimiz dosya ve dizinleri "Kconfig" dosyasında belirtmek zorunda değiliz.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    "menuconfig" menüsünde seçenekler için birkaç seçme biçimi bulunmaktadır. Eğer seçenekte [] varsa bu seçenek "seçilebilir
    ya da seçilmeyebilir" anlamına gelmektedir. Eğer bu seçenek seçilirse köşeli parantez içerisinde bir * karakteri 
    gösterilmektedir. Eğer ilgili seçenekte <> varsa bu açısal parantezlerin içersinde M karakteri ya da * getirilebilmekte 
    ya da bunun içi boş bırakılabilmektedir. Bu açısal parantezli seçeneklere "üç konumlu seçenekler" de denilmektedir. 
    Eğer ilgili seçenekte -*- varsa bu seçenek seçilememezlik yapılamaz. Yani mutlaka çekirdek kodlarında bu seçeneğin 
    bulunması gerekir. Tabii menuconfig menüsünde yapılan her şey aslında ".config" dosyasına yansıtılmaktadır. 

    []      ---> seçilebilir ya da seçilmeyebilir
    <?>     ---> üç konumlu, seçilebilir, seçilmeyebilir ya da 'M' olarak belirtilebilir
    -*-     ---> seçilememezlik yapılamaz
    değer   ---> ilgili özellik 

/*----------------------------------------------------------------------------------------------------------------------

/*----------------------------------------------------------------------------------------------------------------------
    Pekiyi çekirdeğin konfigüre edilmesi aşamasında "menuconfig" işleminde belirlediğimiz seçenekler kaynak kodlara nasıl 
    yansıtılmaktadır? Örneğin biz "menuconfig" işleminde bir modülün çekirdek kodlarına dahil edilmesini ilgili girişi "*" 
    ile seçerek sağlayabilmekteyiz. Benzer biçimde biz konfigürasyon aşamasında bazı çekirdek parametrelerini de değiştirebilmekteyiz. 
    Örneğin "timer tick" frekansı "menuconfig" menüsünde bir sayı biçiminde belirlenebilmektedir. Pekiyi buradaki belirlemeler
    çekirdek kodlarına ve build sistemine nasıl yansıtılmaktadır?

    Anımsanacağı gibi "menuconfig" ve diğer config menülerinde yapılan seçimler daha önce de belirttiğimiz gibi ".config" 
    isimli bir text dosyaya save edilmektedir. Bu ".config" dosyası "özellik=değer" biçiminde satırlardan oluşmaktadır. 
    Aşağıda dosyanın birkaç satırını görüyorsunuz:

    ...
    CONFIG_CC_HAS_ASM_INLINE=y
    CONFIG_CC_HAS_NO_PROFILE_FN_ATTR=y
    CONFIG_PAHOLE_VERSION=125
    CONFIG_IRQ_WORK=y
    CONFIG_BUILDTIME_TABLE_SORT=y
    CONFIG_THREAD_INFO_IN_TASK=y
    ...

    Çekirdek derlenirken ilk aşamada bu ".config" dosyasının içeriği "include/generated/autoconf.h" dosyasının içerisine 
    #define önişlemci komutları biçiminde aktarılmaktadır. İşte eğer ilgili konfigürasyon dosyasındaki değer "y" ya da "m" 
    ise bu "autoconf.h" dosyası içerisinde buna ilişkin sembolik sabit 1 olarak görünür. (Başka bir deyişle "menuconfig"
    menüsünde [*] ya da <*> ya da <M> seçenekleri için sembolik sabit 1 olur.) Eğer konfigürasyon dosyasında ilgili seçenek 
    gerçekten bir değer belirtiyora "autoconf.h" dosyası içerisinde bu sembolik sabit o değerde olur. Eğer konfigürasyon 
    dosyasında ilgili seçenek "n" biçiminde seçilmişse (yani "menuconfig" menüsünde ilgili seçenek [] ya da <> biçiminde 
    seçilmişse) bu durumda ilgili sembolik sabit hiç define edilmemiş hale gelir. Özetle aslında ".config" dosyası içerisindeki 
    satırlardan C'ce anlamlı #define önişlemci komutları oluşturulmaktadır. Aşağıda üretilmiş olan "autoconf.h" dosyasının 
    birkaç satırını görüyorsunuz:

    ...
    #define CONFIG_IGB_HWMON 1
    #define CONFIG_ACPI_HOTPLUG_CPU 1
    #define CONFIG_DEV_DAX_KMEM_MODULE 1
    #define CONFIG_RIONET_RX_SIZE 128
    #define CONFIG_USB_SERIAL_KEYSPAN_PDA_MODULE 1
    #define CONFIG_BOOTTIME_TRACING 1
    ...

    Çekirdeğe ilişkin bir C kodu içerisinde "ilgili seçenek seçilmişse" bir kod parçasını derlemeye dahil etmek için 
    #ifdef önişlemci konutundan faydalanabilirsiniz. Örneğin:

    #ifdef CONFIG_XXX
    ...
    #endif

    Tabii üretilen bu "autoconf.h" dosyası çekirdek kaynak kodlarındaki çeşitli include dosyalarında doğrudan ya da 
    dolaylı bir biçimde include edilmiş durumdadır. Linux kaynak kodları da bu sembolik sabitleri kullanacak biçimde 
    yazılmıştır. Tabii Linux'un kaynak kodlarında "autoconf.h" dosyasını bulamazsınız. Çünkü bu dosya make işlemi 
    sırasında oluşturulmaktadır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Biz yukarıdaki paragrafta ".config" dosyasındaki konfigürasyon parametrelerinin nasıl C'ye sembolik sabitler biçiminde 
    yansıtıldığını gördük. Pekiyi bu konfigürasyon seçenekleri "Makefile" dosyalarına nasıl yansıtılmaktadır? Aşağıda 
    çekirdeğin bir "Makefile" içeriğini görüyorsunuz:

    ...
    obj-$(CONFIG_I8254)             += i8254.o
    obj-$(CONFIG_104_QUAD_8)        += 104-quad-8.o
    obj-$(CONFIG_INTERRUPT_CNT)     += interrupt-cnt.o
    obj-$(CONFIG_RZ_MTU3_CNT)       += rz-mtu3-cnt.o
    obj-$(CONFIG_STM32_TIMER_CNT)   += stm32-timer-cnt.o
    ...

    Bu satırlar aslında "ilgili konfigürasyon seçenekleri seçilmişse ilgili dosyaların derlemeye dahil edileceğini" belirtmektedir. 

    İşte "KBuild" sistemi aynı zamanda bu ".config" dosyasından hareketle make programı için anlamlı olan değişkenler de 
    oluşturmaktadır. Bu değişkenleri yukarıda açıkladığımız sembolik sabitlerle karıştırmayınız. Bu değişkenler make dili 
    için anlamlı olan make dilinin değişkenleridir. Örneğin eğer ".config" dosyasında bir seçenek "y" olarak belirtilmişse 
    (başka bir deyişle "menuconfig" menüsünde seçenek [*] ya <*> biçiminde seçilmişse) bu konfigürasyon seçeneği için make 
    dilinde "y" değeri eğer "m" olarak belirtilmişse (başka bir deyişle "menuconfig" menüsünde <M> biçiminde seçilmişse)
    "m" değeri oluşturulmaktadır. Böylece aslında yukarıdaki make satırları ilgili seçenek "y" olarak seçilmişse obj-y
    biçimine "m" olarak olarak seçilmişse obj-m biçimine dönüştürülmektedir. Örneğin:

    obj-$(CONFIG_I8254)         += i8254.o

    Byrada CONFIG_I8254 seçeneği "y" ise ilgili dosya obj-y değişkenine dahil olacaktır. Yani çekirdeğin içerisinde bulunacaktır. 
    Ancak bu CONFIG_I8254 seçeneği "m" ise ilgili dosya obj-m değişkenine dahil olacaktır. Eğer bu seçenek "n" ise (yani hiç 
    seçilmemişse) çekirdek build sistemi ya bu CONFIG_I8254 değişkenini hiç tanımlamamakta ya da bunu n olarak tanımlamaktadır. 
    Her iki durumda da artık bu dosya herhangi bir biçimde derlemeye dahil edilmeyecektir. 

    Çekirdeğe birtakım kodlar ekleyenler eğer eklemeleri "Kconfig" dosyası yoluyla konfigürasyona yansıtmışlarsa bu durumda 
    kendi "Makefile" dosyasına bu eklemeleri yukarıdaki gibi girebilirler. Örneğin biz "mymodule" ile temsil 
    ettiğimiz bir modül dosyası oluşturup bu modül dosyasının çekirdek kodlarına eklenip eklenmeyeceğini konfigürasyonda 
    "Kconfig" dosyası yoluyla belirtebiliriz. Bu durumda "Makefile" içerisindeki girişi aşağıdaki gibi de oluşturabiliriz:

    obj-$(CONFIG_MYMODULE) += mymodule.o

    Görüldüğü gibi burada aslında konfigüre eden nasıl seçmişse biz onun seçimini yansıtmış olmaktayız. ".config" dosyasında 
    bir özellik "no" ise bu durumda ilgili "Makefile" satırı hale gelecektir:

    obj-n += mymodule.o

    obj-n biçiminde bir birikim yapılmadığı için zaten bu satır derleme aşamasında dikkate alınmayacaktır. Ancak bazen 
    sistem programcıları "y" durumu için aşağıdaki gibi bir kontrol ile modülü koşullu bir biçimde de derleme sürecine 
    ekleyebilmektedir:

    ifeq ($(CONFIG_MYSYSCALL), y)
        obj-y += mysyscall.o
    endif

    Burada eğer konfigürasyon yapılırken ilgili seçenek "y" biçiminde (yani [0] ya da <*> biçiminde) geçilmişse bu durumda 
    biz de ilgili dosyayı derlemeye dahil etmiş olduk.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
                                        9. Ders 16/08/2025 - Cumartesi
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Bir C dosyasını ya da dizini çekirdek kodlarına ekledikten sonra onun konfigürasyon sırasında (örneğin "make menuconfig"
    işlemi sırasında) sırasında görünebilirliğini sağlamak için "Kconfig" dosyalarının kullanıldığını belirtmiştik. Yani 
    "Kconfig" dosyaları yaptığımız değişikliklerin konfigüre edilebilirliğini sağlamak için kullanılmaktadır. Kconfig" 
    dosyalarının genel formatı için aşağıdaki bağlantılara başvurabilirsiniz:

    https://docs.kernel.org/kbuild/kconfig-language.html

    "Kconfig" dosyaları tıpkı "Makefile" dosyalarında olduğu gibi özyinelemeli biçimde işletilmektedir. Yani biz çekirdek 
    kaynak kod ağacında bir dizin yaratmayıp zaten var olan bir dizinin içerisine bir ".c" dosyası yerleştiriyorsak "Makefile" 
    ve "Kconfig" dosyaları oluşturmamıza gerek yoktur. Gerekli işlemleri zaten dizin içerisinde var olan bir "Makefile" ve 
    "Kconfig" dosyaları üzerinde yaapabiliriz. Ancak eğer biz bir dizin oluşturup onun içerisine dosyalar yerleştireceksek 
    o dizin için bir tane "Makefile" ve bir tane de "Kconfig" dosyası oluşturmamız gerekir.

    Önceki paragrafta Linux kaynak kod ağacında bir dizin yaratıp onun içerisine dosyalar yerleştirirken o dizin için "Makefile" 
    ve "Kconfig" dosyalarının yazılması gerektiğini belirtmiştik. (Tabii aslında "Kconfig" dosyasının bulundurulması zorunlu 
    değildir. Ancak eklenen özelliğin konfigüre edilebilirliğinin sağlanması için gerekmektedir.) Bu dosyalar oluşturulduktan 
    sonra dış dizindeki "Makefile" ve "Kconfig" dosyalarında aşağıda belirtilen işlemler de yapılmalıdır:

    1) Daha önceden de belirttiğimiz gibi dış dizindeki "Makefile" dosyasında alt dizinin dikkate alınacağı aşağıdaki gibi 
    bir satırla belirtilmelidir:

    obj-y += <dizin_ismi>/

    2) Dış dizinin "Kconfig" dosyasında iç dizindeki "Kconfig" dosyasının dikkate alınması aşağıdaki gibi bir satırın 
    eklenmesiyle sağlanmaktadır:

    source "kaynak_kod_ağacının_köküne_göreli_yol_ifadesi"

    Örneğin:

    source "drivers/mydriver/Kconfig"

    Buradaki yol ifadesi çekirdek kodlarının kök dizinine göreli olmalıdır. 

    Biz "Kconfig" dosyasına yukarıdaki gibi bir giriş yerleştirdiğimizde artık "make menuconfig" gibi konfigürasyon menülerinde 
    eklediğimiz "Kconfig" elemanı bir menü seçeneği biçiminde karşımıza çıkacaktır.

    Örneğin biz bir aygıt sürücü dosyalarımızı çekirdeğin kaynak kod ağacında "drivers" dizinin altına "mydriver" dizini açarak
    eklemek isteyelim. Bu durumda şunları yapmamız gerekir:

    1) "drivers" dizini içerisinde "mydriver" dizinini yaratıp içerisine "mydriver.c" dosyasını (belki de "mydriver.h" gibi 
    bir başlık dosyasını da) yerleşt.irmeliyiz.

    2) "drivers/mydriver" dizininde aşağıdaki gibi bir "Kconfig" dosyasını oluşturmalıyız:

    config MYDRIVER
    tristate "My Character Device Driver"
    default y
    help
    Enable this option to include support for My Device Driver.
    It can either be built as a module or statically linked into the kernel.

    Buradaki "config MYDRIVER" satırı aslında make dilinde CONFIG_MYDRIVER değişkenin oluşturulmasına yol açmaktadır.

    3) Üst dizindeki ("drivers" dizinindeki) "Kconfig" dosyasına aşağıdaki satırı yerleştirmeliyiz:

    source "drivers/mydriver/Kconfig" 

    4) "drivers/mydriver" dizinindeki "Makefile" dosyası içerisine aşağıdaki gibi bir satır eklemeliyiz:

    obj-$(CONFIG_MyDRIVER) += mydriver.o

    5) Üst dizindeki (yani "drivers" dizinindeki) "Makefile" içerisine aşağıdaki gibi bir satır eklemeliyiz:

    obj-$(CONFIG_MyDRIVER) += mydriver/
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Şimdi çekirdeğe bazı kodlar ekleyip onu yeniden derleyerek bir deneme yapalım. Örneğin çekirdeğe yeni bir çekirdek 
    modülü ekleyelim ve çekirdeğin o modül gömülü olarak başlatılmasını sağlayalım. Ancak burada biz aynı zamanda bu 
    çekirdek modülünün "make menuconfig" ile seçilebilmesini de sağlayalım. Çekirdek modüllerinin nasıl yazılacağını 
    bilmediğinizi varsayıyoruz. Ancak biz yine de örneğimizde "hiçbir şey yapmayan iskelet bir çekirdek modülü" oluşturacağız. 
    Bu işlem şu adımlardan geçilerek yapılabilir (kaynak kod ağacının kök dizininde bulunduğumuzu varsayıyoruz):

    1) "drivers/mydriver" dizini yaratılır.

    2) İskelet bir çekirdek modülü "mydriver.c" biçiminde "drivers/mydriver" dizininde oluşturulur aşağıdaki gibi 
    oluşturulur:

    /* mydriver.c */

    #include <linux/module.h>
    #include <linux/kernel.h>

    MODULE_LICENSE("GPL");
    MODULE_AUTHOR("Kaan Aslan");
    MODULE_DESCRIPTION("General Device Driver");

    static int __init mydriver_init(void)
    {
        printk(KERN_INFO "Hello World...\n");

        return 0;
    }

    static void __exit mydriver_exit(void)
    {
        printk(KERN_INFO "Goodbye World...\n");
    }

    module_init(mydriver_init);
    module_exit(mydriver_exit);

    3) "drivers/mydriver" dizininde "Kconfig" dosyası aşağıdaki gibi oluşturulmalıdır:

    config MYDRIVER
    tristate "My Character Device Driver"
    default y
    help
      Enable this option to include support for My Device Driver.
      It can either be built as a module or statically linked into the kernel.

    Burada konfigürasyon makrosunun ismi CONFIG_MYDRIVER biçiminde olacaktır.

    4) Üst dizinin (yani "drivers" dizinin) "Kconfig" dosyasına aşağıdaki ekleme yapılmalıdır:

    source "drivers/mydriver/Kconfig"

    5) "drivers/mydriver" dizininde aşağıdaki içeriğe sahip bir "Makefile" dosyası oluşturulmalıdır:

    obj-$(CONFIG_MY_DRIVER) += my_driver.o

    6) Üst dizindeki ("drivers" dizinindeki) "Makefile" dosyasına aşağıdaki satır eklenmelidir:

    obj-$(CONFIG_MY_DRIVER) += mydriver/

    Artık çekirdeği derleyebiliriz. "menuconfig" menüsünde kendi aygıt sürücümüze ilişkin seçenek de çıkacaktır.

    Çekirdek imzalamasını devre dışı bırakmak içn konfigürasyon dosyasındaki satırlarda aşağıdaki değişiklikleri yapmayı 
    unutmayınız:

    CONFIG_SYSTEM_TRUSTED_KEYS=""
    CONFIG_SYSTEM_REVOCATION_KEYS=""
    CONFIG_SYSTEM_TRUSTED_KEYRING=n
    CONFIG_SECONDARY_TRUSTED_KEYRING=n

    CONFIG_MODULE_SIG=n
    CONFIG_MODULE_SIG_ALL=n
    CONFIG_MODULE_SIG_KEY=""

    Yeni çekirdeğimize "-custom" ismini de ekleyebiliriz. Daha önceden de belirttiğimiz gibi eğer çekirdeğin eski versiyonundan
    konfigürasyon dosyası alınacaksa "make oldconfig" uygulanıp o versiyondan sonra eklenmiş olan özelliklerin gözden geçirilmesi 
    sağlanmalıdır. Ancak "make menuconig" işlemi zaten "make oldconfig" işlemini de içermektedir. 

    7) Artık çekirdek derlemesi aşağıdaki gibi yapılabilir:

    $ make -j$(nproc)

    8) Derleme işlemi bittikten sonra önce çekirdek modüllerini "sudo make modules_install" ile sonra da çekirdeğin kendisini 
    "sudo make install" ile install edebilirsiniz:

    $ sudo make modules_install
    ...
    $ sudo make install
    ...

    Anımsanacağı gibi "make install" komutu artık sistemin yeni çekirdekle açılmasını sağlayacaktır. "make install" aynı 
    zamanda geçici kök dosya sistemini "update-initramfs" komutu ile oluşturup "/boot" dizinine yerleştirmektedir. Tabii 
    "update-initramfs" programını siz de gerektiğinde kullanabilirsiniz. Programın tipik kullanımı şöyledir:

    $ sudo update-initramfs -c -k <çekirdek_sürümü>

    Buradaki "çekirdek_sürümü" yalnızca çekirdeğin numarasını değil ona verdiğiniz ekleri de içermelidir. (Örneğin 
    "6.9.2-custom" gibi.) Bu komut geçici kök dosya sistemini o anda çalışmakta olan sistemin konfigürasyonunu da dikkate 
    alarak oluşturur ve "/boot" dizinine kopyalar. Yukarıda da belirttiğimiz gibi "make install" zaten bu programı 
    çalıştırarak geçici kök dosya sistemini "/boot" dizininde oluşturmaktadır.

    Pekiyi çekirdeğin kaynak kodlarına yaptığımız eklemenin gerçekten yapılmış olduğunu nasıl anlayabiliriz? Bizim 
    yazdığımız iskelet aygıt sürücü kodlarında çekirdek aygıt sürücümüz yüklediğinde "mydriver_init" fonksiyonu çağrılacaktır. 
    Bu fonksiyonun içinde de printk isimli çekirdek fonksiyonu ile biz bir log mesajı yazdırdık. Bu log mesajları "kernel 
    ring buffer" denilen bir kuyruk sistemine yazılmaktadır. "dmesg" komutuyla bu kuyruk sistemi görüntülenebilir. Eğer 
    "dmesg" yaptığımızda biz bu mesajları görürsek aygıt sürücümüzün yüklenmiş olduğu sonucunu çıkartabiliriz. Örneğin:
    
    $ dmesg | grep  "Hello"
    
    Çekirdeğe gömülü olan modüller "/proc/modules" dosyasında görünmezler, dolayısıyla da "lsmod" komutu ile de bunları 
    göremeyiz. Bunlar için "/sys/module" dizininde de bir giriş oluşturulmamaktadır. "modinfo" komutu ise çekirdeğe 
    ilişkin bazı dosyalara da baktığı için bize bu konuda bilgi verebilmektedir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Pekiyi çekirdek kodlarında küçük değişiklikler yaptıktan sonra yeniden "make modules_install" ve "make install" 
    işlemlerine gerek var mı? Aslında küçük değişiklikler için bu işlemler yapılmazsa genellikle bir sorun ortaya çıkmaz. 
    Yeni oluşturulan çekirdek imajı doğrudan eskisinin üzerine kopyalanabilir. Ancak değişikliğin yerine ve kapsamına göre 
    çekirdeğin sembol tabloları değişebileceği için genel olarak her derlemeden sonra "make install" yapabilirsiniz. 
    "drivers" dizininde "obj-m" biçiminde değişiklikler yapılmışsa "make modules_install" yapılmalıdır. Yukarıdaki örnekte 
    biz "drivers" dizininin içerisine "obj-y" ile eklemeler yaptık. Bu durumda aslında "make modules_install" yapmaya 
    gerek yoktur. Ancak aygıt sürücüler "obj-m" biçiminde ekleniyorsa make modules_install" komutu uygulnamalıdır. Çekirdeğin 
    modüllerle ilgili olmayan kısımlarında yapılan değişikler için "make modules_install" yapılmasına gerek olmadığını 
    bir kez daha belirtmek istiyoruz. "make modules_install" işleminden önce eski "/lib/modules/<çekirdek_sürümü>" dizinini 
    de "rm -r" komutu ile silmek daha güvenli bir yaklaşımdır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Biz yukarıdaki çekirdek derlemesi sürecinde imzalama (signing) işlemlerini devre dışı bırakmıştık. Çekirdek kodları
    ve özellikle de aygıt sürücüler belli imzalara sahip olacak biçimde derlenebilmektedir. Böylece onlar üzerinde birtakım 
    istenmeyen değişikliklerin yapılarak değiştirilmiş çekirdek ya da aygıt sürücülerin yüklenmesi engellenmiş olur. 
    Yukarıda  da gördüğünüz gibi çekirdek kodları ve aygıt sürücülerde bu imzalama işlemi devre dışı da bırakılabilmektedir. 
    Ancak imzalama süreci sistem güvenliğini artırmaktadır. Bu tür imzalama işlemleri yalnızca Linux sistemlerinde değil 
    diğer UNIX türevi sistemlerde, Windows ve macOS sistemlerinde de bulunmaktadır. 
    
    Çekirdeğin imza kontrolü temel olarak UEFI BIOS (eğer "secure boot seçeneği aktif ise) ve önyükleyiciler (örneğin GRUB) 
    tarafından yapılmaktadır. Ancak Linux çekirdeği de aygıt sürücüler ve modüller yüklenirken imza kontrolü uygulayabilmektedir.
    Biz burada çekirdek ve modül imzalamalarının nasıl yapılacağı üzerinde duracağız. 
    
    İmzalama işlemi tipik olarak şu adımlardan geçilerek yapılmaktadır:

    1) İmzalama işlemi için öncelikle "openssl" kütüphanesinin yüklenmiş olması gerekir. Yükleme işlemi aşağıdaki gibi 
    yapılabilir:

    $ sudo apt-get install openssl

    Daha sonra "openssl" programı ile aşağıdaki gibi bir ".pem" dosyası üretilir:

    openssl req -new -x509 -newkey rsa:2048 -sha256 \
    -keyout signing_key.key -out certs/signing_key.crt \
    -nodes -days 36500 -subj "/CN=Local Kernel Module Key/"

    Üretilen ".pem" dosyası genellikle kaynak kod ağacında "certs" isimli bir dizine yerleştirilir:

    $ mkdir -p certs
    $ mv signing_key.pem /certs

    Daha sonra konfigürasyon dosyasında imzalama için aşağıdaki değişiklikler yapılmalıdır:

    CONFIG_MODULE_SIG=y
    CONFIG_MODULE_SIG_ALL=y
    CONFIG_MODULE_SIG_SHA256=y
    CONFIG_SYSTEM_TRUSTED_KEYRING=y
    CONFIG_MODULE_SIG_KEY="certs/signing_key.pem"
    CONFIG_SYSTEM_TRUSTED_KEYS="certs/signing_key.pem"

    Biz yukarıdaki işlemleri yaptığımızda yalnızca aygıt sürücüleri imzalamış oluruz. Çekirdeğin kendisinin imzalanması
    ayrıca yapılmalıdır. Yukarıda da belirttiğimiz gibi UEFI BIOS'lar ve GRUB gibi önyükleyiciler çekirdek imajını
    yüklemeden önce ayarları uygun biçime getirildiyse çekirdek imzasına bakmaktadır. Eğer çekirdek imzası yanlışsa 
    (çekirdek dışarıdan kasti ya da yanlışlıkla bozulmuş olabilir) çekirdeği hiç yüklememektedir. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
                                            10. Ders 17/08/2025 - Pazar
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Çekirdeğin imzalanaması şöyle yapılabilir:

    - Oluşturnuş olduğumuz "signing_key.pem" dosyasından private ve public key ayrıştırılır:

    $ openssl x509 -in signing_key.pem -outform DER -out db.crt
    # openssl rsa -in signing_key.pem -outform PEM -out db.key

    - Sonra da çekirdek sbsign programı ile aşağıdaki gibi imzalanır:

    sbsign --key db.key --cert db.crt --output vmlinuz.signed vmlinuz-6.9.2-custom

    Genellikle bu biçimde bir çekirdek imzalaması seyrek olarak yapılmaktadır. Önceki paragrafta biz aygıt sürücü 
    dosyalarının imzalandığını belirtmiştik. Aynı makinede aygıt sürücüyü derlerken (build ederken) oluşturulan imza 
    bilgisi de kullanılmaktadır. Yani biz aynı makinede bir aygıt sürücü derlediğimizde aygıt sürücümüz de zaten imzalanmış 
    olacaktır. 

    Pekiyi aygıt sürücüler yukarıdaki gibi imzalandıktan sonra ya biz başka bir makinede oluşturulmuş olan ya da başka
    bir uygulamanın oluşturmuş olduğu aygıt sürücüleri yüklemek istersek ne olacaktır? Normal olarak o aygıt sürücüler 
    bizim ürettiğimiz imza ile imzalanmadığı için onların yüklenmemesini bekleriz. Ancak bu durum kullanıcıları ek bir 
    çabaya sürükleyebilmektedir. İşte default durumda imzası uyuşmayan aygıt sürücüler sistem tarafından bir uyarı verilerek 
    yine de yüklenmektedir. Ancak bu tür durumlarda daha katı bir kontrolün uygulanması isteniyorsa ".config" dosyasında
    aşağıdaki gibi ekstra bir üst düzey güvenlik belirtilebilir:

    CONFIG_MODULE_SIG_FORCE=y

    Bu işlem "menuconfig" menüsünde "Enable loadable module support/Module signature verification/Require modules to 
    be validly signed" seçeneğinden de yapılabilir. Bu durumda çekirdek kendi oluşturduğumuz imzayla imzalanmamış olan 
    modülleri yüklemeyecektir. 

    Eğer biz başkalarının yazdığı bir aygıt sürücüyü yüklerken ama çekirdeğin uyarı vermesini ya da yüklemeyi reddetmesini 
    istemiyorsak o aygıt sürücüyü de kendi ürettiğimiz anahtarla (ya da dağıtımın public anahtarıyla) imzalamalıyız. Bu 
    işlem çekirdek kodlarındaki "scripts" dizini içerisinde bulunan "sign-file" betiği (script) yapılmaktadır. Bu betiğin 
    tipik kullanımı şöyledir:

    scripts/sign-file <hash_alg> <private_key.pem> <public_cert.pem> <module.ko>

    Örneğin:

    scripts/sign-file sha256 signing_key.pem.pem signing_key.pem mydriver.ko

    Pekiyi Ubuntu, Mint gibi dağıtımlar çekirdek imzalaması uygulamakta mıdır? Evet genel olarak dağıtımlar kendi 
    private anahtarlarıyla (private keys) çekirdeği ve aygıt sürücüleri imzalamaktadır. Ancak aygıt sürücülerin yüklenmesinde 
    imza kontrolünü zorunlu hale getirmemektedir. İmzalama için kullanılacak public anahtarlar "/proc/keys" dosyasında 
    belirtilmektedir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Bir Linux sisteminin düzgün bir biçimde açılması için belli dizinlerin kök dosya sisteminde bulunuyor olması gerekir. 
    Biz bir dağıtımı kurduğumuzda zaten bu kök dosya sistemi de oluşturulmaktadır. Pekiyi sıfırdan dağıtımı tamamen 
    kurmadan kök dosya sistemini nasıl oluşturulabiliriz? Bu işlem tamamen manuel biçimde yapılabilir. Yani uygulamacı 
    kök dizin içerisindeki gerekli dizinleri elle yaratır. Sonra gerekli programları kaynak kodlarından hareketle hedef 
    makine için derler ve onları konuşlandırır. Sonra yine gerekli birtakım konfigürasyon dosyalarını elle oluşturur. 
    Ancak bu manuel yöntem oldukça zahmetlidir. Bunun yerine bu işlemi pratik bir biçimde yapan araçlar geliştirilmiştir. 
    Örneğin gömülü sistemlerde "BusyBox" denilen araç bu amaçla sıkça kullanılmaktadır. Kullanımı da oldukça kolaydır. 
    Gömülü sistemler için "Buildroot" ve "Yocto" gibi projeler daha genel amaçlar için gerçekleştirilmiştir ancak bunlarla 
    kök dosya sistemi de oluşturulabilmektedir. Bazı dağıtımların bu işi yapan özel utility programları da vardır. Örneğin 
    "debootstrap" programı Debian tabanlı kök dosya sistemini Internet'ten indirerek yerel makinede oluşturabilmektedir. 
    Ancak bu araçların bazıları esnek değildir. Özellikle gömülü sistemlerde düşük bir sistem kaynağının olduğu dikkate 
    alındığında bu araçların bazıları minimalist bir kurulum sağlayamamaktadır. 

    debootstrap programı default olarak sisteminizde yüklü değildir. Bunu aşağıdaki gibi kurabilirsiniz:

    $ sudo apt-get install debootstrap

    debootstrap programının pek çok komut satırı argümanı vardır. Biz burada en önemli birkaç argüman üzerinde duracağız. 
    --arch komut satırı seçeneği hedef CPU mimarisini belirtmektedir. Bu argüman girilmezse o andaki platform temel 
    alınmaktadır. 64 bit Intel platformu için burada "amd64", BBB gibi 32 bit ARM platformu için "armhf", 64 bit ARM 
    platformu için bu seçeneğe "arm64" girilmelidir. Programın ilk seçeneksiz argümanı Debian sisteminin varyantını 
    belirtmektedir. Bu argüman için "buster" girebilirsiniz. İkinci komut satırı argümanı hedef kök dosya sisteminin 
    oluşturulacağı dizini, üçüncü komut satırı argümanı ise paketlerin indirileceği depoyu (repository) belirtmektedir. 
    Örneğin:

    $ sudo debootstrap --arch=amd64 --include=systemd bullseye myrootfs http://deb.debian.org/debian/

    Yukarıda da belirttiğimiz gibi "--arch" seçeneği girilmemişse programın çalıştırıldığı makine için kök dosya sistemi 
    indirilip kurulmaktadır. 
    
    Default durumda "debootstrap" pek çok paketi kök dosya sistemine dahil ettiği için paketlerin indirilmesi ve kök dosya 
    sisteminin oluşturulması biraz zaman alacaktır.

    Uygulamacı isterse "--include" ve "--exclude" komut satırı seçenekleriyle birtakım paketleri dahil edebilir ya da
    dışlayabilir. Ancak bu işlem biraz yorucudur. Örneğin biz "systemd" dışında "sudo" ve "gcc" paketlerini de aşağıdaki 
    gibi kuruluma dahil edebiliriz:

    $ sudo debootstrap --arch=amd64 --include=systemd,sudo,gcc bullseye myrootfs http://deb.debian.org/debian/

    debootstrap programı ile eğer host makineyle aynı platform için indirme işlemi yapılıyorsa deboostrap önce Internetten 
    gerekli paketleri indirip yerel makinede bir dizin içerisinde kök dosya sistemini oluşturur sonra da indirimin yapıldığı 
    dizinde ikinci aşama işlemleri gerçegerçekleştirir. Eğer host makineden farklı bir sistem için indirme yapılıyorsa 
    (örneğin host sistem Intel tabanlı bir makineyse ve ARM tabanlı bir Debian kök dosya sistemi oluşturulmak isteniyorsa) 
    debootstrap yüklemesini yapmadan önce aşağıdaki gibi "qemu" emülatör paketinin statik versiyonu ve "binfmt" destek 
    paketi kurulmalıdır:

    $ sudo apt install qemu-user-static binfmt-support

    Bu işlemden sonra debootstrap programı yukarıda belirttiğimiz biçimde çalıştırılabilir:

    $ sudo debootstrap --include=systemd --arch armhf buster myrootfs http://deb.debian.org/debian/

    Bu komut hem birinci aşama hem de ikinci aşama işlemleri yapıp bitirecektir. Artık istenildiği zaman chroot işlemi 
    de yapılabilir:

    $ sudo chroot myrootfs
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    "debootstrap" programı ile biz Debian kök dosya sistemi için geçici kök dosya sistemi de oluşturabiliriz. Bunun en 
    pratik yolu kök dosya sistemini kurduktan sonra "chroot" yapıp "update-initramfs" programı ile geçici kök dosya 
    sistemini oluşturmaktır. Ancak bunun için "/boot" dizinin ve "/lib/modules" dizinin uygun biçimde oluşturulmuş olması 
    gerekir. "update-initramfs" programı bu dizinlerdeki içerikten faydalanmaktadır. "update-initramfs" programı "initramfs-tools" 
    isimli pakettedir. chroot yaptıktan sonra öncelikle bu paketi aşağıdaki gibi kurmalısınız:

    $ sudo apt-get install initramfs-tools

    Bundan sonra geçici kök dosya sistemini aşağıdaki gibi oluşturabilirsiniz (Debian kök dosya sisteminin kökünde olduğumuzu 
    varsayıyoruz):

    $ update-initramfs -c -k 6.9.2-custom -b .

    Burada "6.6.32-custom" çekirdeğin sürüm ismidir. Geçici kök dosya sistemi "initrd.img-6.6.32-custom" ismiyle bulunulan 
    dizinde oluşturulacaktır. "-b ." seçeneği oluşturulacak dosyanın dizinini belirtmektedir. 

    Biz bu tür konuların ayrıntılarına girmeyeceğiz. Bu konular daha çok "Gömülü Linux Sistemleri - Geliştirme ve Uygulama"
    kursunun konularını oluşturmaktadır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Aygıt sürücü geliştirirken çekirdeğinin kaynak kodlarına gereksinim duyulmaz. Ancak çekirdeğin başlık dosyalarının 
    geliştirmenin yapıldığı bilgisayarda yüklü olması gerekir. Çekirdek kodlarının kendisini değil de yalnızca başlık 
    dosyalarını indirmek için aşağıdaki komut kullanılabilir:

    sudo apt install linux-headers-$(uname -r)

    Buradaki $(uname -r) çalışılmakta olan makinedeki çekirdek sürümünün belirtmektedir. Tabii biz istediğimiz 
    çekirdek sürümünün başlık dosyalarını da indirebiliriz. İndirilen dosyalar "/usr/src" dizininin altına $(uname -r) 
    isimli dizin içerisine yerleştirilmektedir.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Linux çekirdeğinin gerçekleştiriminde çeşitli veri yapılarından (data structures) faydalanılmıştır. Çekirdekte 
    en çok kullanılan veri yapıları şunlardır:

    - Çift Bağlı Listeler
    - Bitmap'ler 
    - Hash Tabloları
    - Kuyruk Sistemleri
    - Dengelenmiş Ağaçlar ve Radix Ağaçları

    Çekirdek içerisinde bu veri yapıları genelleştirilmiş yani türden bağımsız bir biçimde gerçekleştirilmiştir. 

    Biz bu bölümde "bağlı listelerin (linked list)" Linux çekirdeğindeki gerçekleştirimleri üzerinde duracağız. Diğer 
    veri yapılarını çeşitli konular içerisinde yeri geldikçe açıklayacağız. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Çekirdeğin en önemli veri yapılarından biri bağlı listelerdir. Genel olarak çekirdekteki neredeyse tüm bağlı listeler 
    "çift bağlı (doubly linked)" biçimde kullanılmaktadır. Önce bağlı listelerin Linux çekirdeğindeki gerçekleştirimeleri 
    üzerinde duracağız.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Aralarında öncelik-sonralık ilişkisi olan veri yapılarına "liste (list)" denilemektedir. Örneğin bu tanıma göre 
    diziler de "liste tarzı" veri yapılarıdır. Liste tarzı veri yapılarının en yaygın kullanılanlarından biri "bağlı liste 
    (linked list)" denilen veri yapısıdır. Önceki elemanının sonraki elemanın yerini gösterdiği dolayısıyla elemanların 
    ardışıl olma zorunluluğunun ortadan kaldırıldığı listelere "bağlı liste" denilmektedir. Dizi elemanlarının bellekte 
    fiziklsel olarak ardışıl biçimde bulunduğunu anımsayınız. Bağlı listeler adeta "elemanları bellekte ardışıl olmak 
    zorunda olmayan diziler" gibidir. 

    Bağlı listelerin her elemanına "düğüm (node)" denilmektedir. Bağlı listelerde her düğüm sonraki düğümün yerini tuttuğuna 
    göre ilk elemanın yeri biliniyorsa liste elemanlarının hepsine erişilebilmektedir. Örneğin:

    head ----> node ---> node ---> node ----> node (NULL)

    Her düğümün yalnızca sonraki düğümün yerini değil aynı zamanda önceki düğümün yerini de tuttuğu bağlı listelere 
    "çift bağlı listeler (double linked lists)" denilmektedir. Çift bağlı listelerde belli bir düğümün adresini biliyorsak 
    yalnızca ileriye doğru değil, geriye doğru da gidebiliriz.

    head <----> node <---> node ---> node <----> node (NULL)

    Çift bağlı listelere ilişkin bir düğümünün bellekte daha fazla yer kaplayacağına dikkat ediniz. Çift bağlı listelerin 
    tek bağlı listelere göre en önemli özelliği "adresi bilinen bir düğümün" silinebilmesidir. Tek bağlı listelerde bu 
    durum mümkün değildir. Uygulamalarda ve özellikle çekirdek kodlarında buna çok sık gereksinim duyulmaktadır. 

    Eğer bir bağlı listede son eleman da ilk elemanı gösteriyorsa bu tür bağlı listelere "döngüsel bağlı listeler 
    (circular linkes lists)" de denilmektedir. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Pekiyi bağlı listelere neden gereksinim duyulmaktadır? Diziler varken bağlı listelere gerek var mıdır? Dizilerle 
    bağlı listeler arasındaki farklılkları, benzerlikleri ve bağlı listelere neden gereksinim duyulduğunu birkaç maddede 
    açıklayabiliriz:

    1) Diziler ardışıl alana gereksinim duymaktadır. Ancak belleğin bölündüğü (fragmente olduğu) durumlarda bellekte yeteri 
    kadar küçük boş alanlar olduğu halde bunlar ardışıl olmadığı için dizi tahsisatı mümkün olamamaktadır. Bu tür durumlarda 
    ardışıllık gereksinimi olmayan bağlı listeler kullanılabilir. Özellikle heap gibi bir alanda çok sayıda dinamik dizi 
    bellek kullanımı bakımından verimsizliğe yol açabilmektedir. Bu dinamik diziler zamanla büyüdükçe birbirini engeller 
    hale gelebilmektedir. İşte uzunluğu baştan belli olmayan çok sayıda dizinin oluşturulacağı durumlarda dinamik dizi 
    yerine bağlı listeler toplamda daha iyi performans gösterebilmektedir. Dinamik dizilerde dinamik dizinin büyütülmesi 
    yavaş bir işlemdir. Çünkü büyütme sırasında bloklar yer değiştirebilmektedir. 

    2) Dizilerde araya eleman ekleme (insert etme) ve aradaki bir elemanı silme dizinin kaydırılmasına ("expand" ve "shrink" 
    edilmesine) yol açacağından yavaş bir işlemdir. Teknik olarak dizilerde eleman insert etme ve eleman silme O(N) karmaşıklıkta 
    bir işlemdir. Halbuki bağlı listelerde eğer düğümün yeri biliniyorsa bu işlem O(1) karmaşıklıkta (yani döngü olmadan 
    tekil işlemlerle) yapılabilmektedir. O halde araya eleman eklemenin ve aradan eleman silmenin çok yapıldığı sistemlerde 
    diziler yerine bağlı listeler tercih edilebilmektedir. Çekirdek veri yapılarında araya eleman ekleme ve aradan eleman 
    silme gibi işlemler çok yoğun yapılmaktadır.

    3) Bağlı listelerde belli bir indeksteki elemana erişmek O(N) karmaşıklıkta bir işlemdir. Halbuki dizilerde elemana 
    erişim O(1) karmaşıklıkta yani çok hızlıdır. O halde belli bir indeks değeri ile elemana erişimin yoğun yapıldığı 
    durumlarda bağlı listeler yerine diziler tercih edilmelidir. 

    4) Bağlı listeler toplamda bellekte daha fazla yer kaplama eğilimindedir. Çünkü bağlı listenin her düğümü sonraki 
    (ve duruma göre önceki) elemanın yerini de tutmaktadır. 

    O halde bağlı listeler tipik olarak şu durumlarda dizilere tercih edilmelidir:

    - Eleman insert etmenin ve eleman silmenin sık yapıldığı durumlarda.
    - Uzunluğu baştan belli olmayan çok sayıda dizinin kullanıldığı durumlarda.
    - İndeks yoluyla erişimin az yapıldığı durumlarda.
    - Toplam bellek miktarının yeteri kadar fazla olduğu sistemlerde.

    İşte tüm yukarıdaki nedenlerden dolayı bağlı listeler çekirdek için en önemli veri yapılarından biridir. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Linux çekirdeğinde bağlı liste gerçekleştirimi "include/linux/list.h" dosyasında yapılmıştır. Bu dosya içerisindeki 
    fonksiyonlar static inline biçiminde tanımlanmıştır. Çekirdek derlemesi sırasında derleyicinin optimizasyon seçeneği 
    ayarlandığı için derleyici buradaki inline fonksiyonları sanki bir makro gibi koda açmaktadır. 

    Linux çekirdeğindeki bağlı listelerde bağlı listelerin düğümleri list_head isimli bir yapıyla temsil edilmektedir:

    struct list_head {
        struct list_head *next;
        struct list_head *prev;
    };

    Aslında belli yapılar değil bu list_head yapıları bağlı liste içerisinde birbirine bağlanmaktadır:

    list_head (kök) <----> list_head <---> list_head <---> list_head <---> list_head <---> list_head <---> list_head 

    Tabii eğer bu list_head yapıları başka bir yapının (buna asıl yapı deiyelim) içerisindeyse bu durumda aslında bir 
    list_head yapısının adresi asıl yapının bir elemanının adresi haline gelmektedir. Biz C'de bir yapının bir elemanının 
    adresini biliyorsak kolaylıkla o yapının başlangıç adresini elde edebiliriz. Çünkü yapı elemanları ardışıldır ve 
    standart offsetof makrosuyla belli bir yapı elemanının yapının başlangıcından itibaren hangi offset'te bulunduğu 
    bilgisi elde edilebilmektedir. offsetof <stddef.h> içerisinde aşağıdakine benzer biçimde tanımlanmıştır:

    #define offsetof(type, member)   ((size_t)&(((type *)0)->member))

    offsetof makrosunun birinci paranetresi yapının tür ismini, ikinci parametresi ilgili yapı elemanının ismini almaktadır. 
    Tabii offsetof makrosu yalnızca size_t türünden bir byte offset'i vermektedir. Elemanın adresinin makroyla elde 
    edilen bu değerden çıkartılarak tür dönüştürmesinin yapılması gerekir. İşte bunun için Linux çekirdeğinde container_of 
    isimi bir makro bulundurulmuştur. Bu makronun basit yazımı şöyle yapılabilir:

    #define container_of(ptr, type, member)    ((type *)((char *)ptr - myoffsetof(type, member)))

    container_of makrosunun birinci parametresi yapı elemanın adresini, ikinci parametresi yapının tür ismini ve üçüncü 
    parametresi de ilgili yapı elemanının ismini almaktadır. Bu makro ikinci parametresine girilmiş olan yapı türünden 
    bir adres vermektedir. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
                                            11. Ders 23/08/2025 - Cumartesi
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Linux çekirdeğindeki bağlı listeler kullanırken önce bir başlangıç düğümünün oluşturulması gerekir. Başlangıç düğümünde 
    next ve prev göstericilerinin başlangıç düğümünün kendisini göstermesi gerekir. Örneğin:

    struct list_head head = {&head, &head};

    Bu ilkdeğer verme C'de geçerlidir. Çünkü C'de bir değişken faaliyet alanına "=" atomu ile ilkdeğer verme kısmından 
    önce sokulmaktadır. "list.h" dosyasında bu işlemi yapan aşağıdki gibi bir makro da bulundurulmuştur:

    #define LIST_HEAD_INIT(name) {&(name), &(name)}

    Bu durumda başlangıç düğümü bu makroyla şöyle de oluşturulabilir:

    struct list_head head = LIST_HEAD_INIT(head);

    Aslında bu tanımlamanın tamamını yapan aşağıdaki gibi bir makro da bulundurulmuştur:

    #define LIST_HEAD(name) \ 
	    struct list_head name = LIST_HEAD_INIT(name)

    O halde biz başlangıç düğümünü basit bir biçimde şöyle oluşturabiliriz:

    LIST_HEAD(head);

    Linux'un bağlı liste gerçekleştiriminde next ve prev göstricilerinde NULL adres kullanılmamıştır. Son düğümün next 
    göstericisi NULL yerine başlangıç düğümünü, ilk düğümün prev göstericisi de NULL yerine son düğümü göstermektedir. 
    Yani aslında bağlı liste gerçekleştirimi döngüsel (circular) gibidir. Herhangi bir düğümden başlanarak başlangıç düğümü 
    de atlanırsa tam dolaşım sağlanabilir. Bağlı listenin başlangıç düğümünün prev göstericisi de son düğümü göstermektedir.

    Bağlı listenin başına list_head düğümünü eklemek için list_add fonksiyonu kullanılmaktadır:

    static inline void list_add(struct list_head *new, struct list_head *head)
    {
        __list_add(new, head, head->next);
    }

    Fonksiyonun birinci parametresi eklenecek düğümün adresini, ikinci parametresi başlangıç düğümünün adresini almaktadır. 

    Çekirdek kodlarında iki alt tire ile başlayan fonksiyonlar aşağı seviyeli fonksiyonlardır. Yani doğrudan çağrılmayan 
    ancak başka fonksiyonların içerisinden dolaylı biçimde çağrılan fonksiyonlardır. Buradaki __list_add fonksiyonu şöyle 
    yazılmıştır:

    static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
    {
        if (!__list_add_valid(new, prev, next))
            return;

        next->prev = new;
        new->next = next;
        new->prev = prev;
        WRITE_ONCE(prev->next, new);
    }

    Bağlı listenin sonuna düğüm eklemek için list_add_tail fonksiyonu kullanılmaktadır:

    static inline void list_add_tail(struct list_head *new, struct list_head *head)
    {
        __list_add(new, head->prev, head);
    }

    Pekiyi biz bağlı listeyi nasıl dolaşabiliriz? Başlangıç düğümünü geçerek sürekli ileriye gidersek son düğüm de 
    başlangıç düğümünü gösterdiğine göre dolaşımı aşağıdaki gibi bir for döngüsüyle yapabiliriz:

    struct list_head *lh;
    /* ... */

    for (lh = head.next; lh != &head; lh = lh->next) {
        /* ... */    
    }

    Tabii böyle bir döngüde dolaşım yapılırken aslında biz her yinelemede ilgili yapının başlangıç adresini değil 
    list_head yapısının başlangıç adresini elde ederiz. container_of makrosu ile bu adresin yapı adresine dönüştürülmesi 
    gerekir. Örneğin biz struct SAMPLE türünden yapı nesnelerini birbirine bağlamış olalım:
    
    LIST_HEAD(head);

    struct SAMPLE { 
        int a; 
        struct list_head link;
    };

    Eklemeleri şöyle yapmış olalım:

    struct SAMPLE *ps;
    
    for (int i = 0; i < 10; ++i) {
        if ((ps = (struct SAMPLE *)malloc(sizeof(struct SAMPLE))) == NULL) {
            fprintf(stderr, "cannot allocate memory!..\n");
            exit(EXIT_FAILURE);
        }
        ps->a = i;
        list_add_tail(&ps->link, &head);
    }
    
    Çekirdek kodlarında malloc gibi kullanıcı modu fonksiyonları kullanılamaz. Ancak biz burada yalnızca anlaşılır 
    bir test örneği vermek istiyoruz. struct SAMPLE yapımızdaki link elemanı list_head yapılarını birbirine bağlamak için
    bulundurulmuştur. Örneğimizdeki list_add_tail fonksiyonunda ekleme yapılacak düğümün SAMPLE yapısının içerisindeki
    link elemanının adresi olduğuna dikkat ediniz. Şimdi dolaşımı şöyle yapabiliriz:

    struct SAMPLE *ps;
    struct list_head *lh;
    /* ... */

    for (lh = head.next; lh != &head; lh = lh->next) {
        ps = container_of(lh, struct SAMPLE, link);
        /* ... */
    }

    Burada artık ps göstericisi list_head nesnesini değil struct SAMPLE nesnesini göstermektedir. Aslında "list.h" dosyası 
    içerisinde buradaki döngüyü oluşturan list_for_each isimli bir makro da bulundurulmuştur:

    static inline int list_is_head(const struct list_head *list, const struct list_head *head)
    {
        return list == head;
    }

    #define list_for_each(pos, head) \
	    for (pos = (head)->next; !list_is_head(pos, (head)); pos = pos->next)

    Makronun birinci parametresi list_head türünden bir göstericiyi, ikinci parametresi başlangıç düğümünün adresini 
    almaktadır. Döngünün her yinelenmesinde bu göstericiye sonraki düğümün list_head adresi atanmaktadır. Örneğin:

    struct list_head *lh;
    /* ... */

    list_for_each(lh, &head) {
        ps = container_of(lh, struct SAMPLE, link);
        printf("%d\n", ps->a);
    }

    Aslında çekirdekteki "list.h" dosyası içerisinde yukarıdaki dolaşımı tek hamlede yapan list_for_each_entry isimli bir 
    makro da bulunmaktadır:

    #define list_for_each_entry(pos, head, member)				\
	for (pos = list_first_entry(head, typeof(*pos), member);	\
	     !list_entry_is_head(pos, head, member);			    \
	     pos = list_next_entry(pos, member))

    Makronun birinci paramtresi asıl yapı türünden bir göstericidir. Makro her yinelemede bu göstericiye sonraki düğümün 
    adresini yerleştirmektedir. Makronun ikinci parametresi başlangıç düğümünün adresini, üçüncü parametresi ise yapı 
    içerisindeki list_head elemanın ismini belirtmektedir. Bu makronun eşdeğeri bazı ayrıntılar ihmal edilerek şöyle de 
    yazılabilir:

    #define my_list_for_each_entry(pos, head, member)                                           \
        for (pos = container_of((head)->next, typeof(*pos), member);  &(pos)->member != head;   \
            pos = container_of((pos)->member.next, typeof(*pos), member)) 
        
    C standartlarında bir ifadenin türünü veren bir tür belirleyicisi yoktu. C++'a C++11 ile birlikte decltype ismi ile 
    böyle bir belirleyici eklendi. gcc derleyicileri uzun süredir bu işi yapan typeof isimli belirleyiciyi desteklemektedir. 
    Nihayet C'ye de C23 ile birlikte resmi olarak typeof belirleyicisi eklenmiştir. Makroda türün tür isminin typeof(*pos) 
    ifadesiyle elde edildiğine dikkat ediniz. Bu makro ile dolaşım şöyle sağlanabilir:

    struct SAMPLE *ps;
    /* ... */

    list_for_each_entry(ps, &head, link) {
        /* ... */
    }

    Bağlı liste makrolarının ve fonksiyonlarının isimlerinin sonunda entry sözcüğü varsa bu makro ya da fonksiyon asıl 
    yapıya ilişkin adres, yoksa list_head türünden adres verip almaktadır. 

    Bağlı listeden bir düğümü silmek için list_del fonksiyonu kullanılmaktadır. Fonksiyon şöyle tanımlanmıştır:

    static inline void __list_del(struct list_head * prev, struct list_head * next)
    {
        next->prev = prev;
        WRITE_ONCE(prev->next, next);
    }

    static inline void __list_del_entry(struct list_head *entry)
    {
        if (!__list_del_entry_valid(entry))
            return;

        __list_del(entry->prev, entry->next);
    }

    static inline void list_del(struct list_head *entry)
    {
        __list_del_entry(entry);
        entry->next = LIST_POISON1;
        entry->prev = LIST_POISON2;
    }

    Fonksiyonun parametresi silinecek düğüme ilişkin list_head elemanın adresini almaktadır. Burada silinen düğümdeki 
    next ve prev göstericilerine özel bazı değerler atanmıştır. Bu bizim için bir ayrıntıdır.

    Bağlı listenin arasına düğüm ekleyen insert isimli fonksiyonlar yoktur. Zaten list_add fonksiyonu araya ekleme 
    işlemini de yapmaktadır. Örneğin biz araya şöyle eklama yapabiliriz:

    list_add(&ps->link, &ps_insert->link);

    Burada ps eklenecek düğümün asıl yapı adresini, ps_insert ise önüne eklemenin yapılacağı asıl yapı adresini 
    belirtmektedir. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Belli bir süreden sonra "list.h" dosyasına RCU (Read-Copy_Update) mekanizamasını destekleyecek biçimde dolaşım yapan 
    list_for_each_rcu isimli makro da eklenmiştir. Bu makro bir yazıcı varsa okuyucuları bekletmeden işlem yapabilmeyi 
    sağlamaktadır. "Read-copy-update" mekanizması ileride ele alınacaktır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Çekirdeğin eski sürümlerinde "list.h" dosyası oldukça sade idi. Sonra bu dosyanın içeriğinde de bazı faydalı değişiklikler 
    yapıldı. Ancak bu değişiklikler veri yaısının anlaşılmasını da biraz zorlaştırmıştır. Örneğin 2.2.26 çekirdeğindeki
    "list.h" dosyası oldukça sade bir biçimde aşağıdaki gibi oluşturulmuştur:

    /* 2.2.26 <list.h> dosyasının içeriği */

    #ifndef _LINUX_LIST_H
    #define _LINUX_LIST_H

    #ifdef __KERNEL__

    /*
    * Simple doubly linked list implementation.
    *
    * Some of the internal functions ("__xxx") are useful when
    * manipulating whole lists rather than single entries, as
    * sometimes we already know the next/prev entries and we can
    * generate better code by using them directly rather than
    * using the generic single-entry routines.
    */

    struct list_head {
        struct list_head *next, *prev;
    };

    #define LIST_HEAD_INIT(name) { &(name), &(name) }

    #define LIST_HEAD(name) \
        struct list_head name = { &name, &name }

    #define INIT_LIST_HEAD(ptr) do { \
        (ptr)->next = (ptr); (ptr)->prev = (ptr); \
    } while (0)

    /*
    * Insert a new entry between two known consecutive entries. 
    *
    * This is only for internal list manipulation where we know
    * the prev/next entries already!
    */
    static __inline__ void __list_add(struct list_head * new,
        struct list_head * prev,
        struct list_head * next)
    {
        next->prev = new;
        new->next = next;
        new->prev = prev;
        prev->next = new;
    }

    /*
    * Insert a new entry after the specified head..
    */
    static __inline__ void list_add(struct list_head *new, struct list_head *head)
    {
        __list_add(new, head, head->next);
    }

    /*
    * Insert a new entry at the tail
    */
    static __inline__ void list_add_tail(struct list_head *new, struct list_head *head)
    {
        __list_add(new, head->prev, head);
    }

    /*
    * Delete a list entry by making the prev/next entries
    * point to each other.
    *
    * This is only for internal list manipulation where we know
    * the prev/next entries already!
    */
    static __inline__ void __list_del(struct list_head * prev,
                    struct list_head * next)
    {
        next->prev = prev;
        prev->next = next;
    }

    static __inline__ void list_del(struct list_head *entry)
    {
        __list_del(entry->prev, entry->next);
    }

    static __inline__ int list_empty(struct list_head *head)
    {
        return head->next == head;
    }

    /*
    * Splice in "list" into "head"
    */
    static __inline__ void list_splice(struct list_head *list, struct list_head *head)
    {
        struct list_head *first = list->next;

        if (first != list) {
            struct list_head *last = list->prev;
            struct list_head *at = head->next;

            first->prev = head;
            head->next = first;

            last->next = at;
            at->prev = last;
        }
    }

    #define list_entry(ptr, type, member) \
        ((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))

    #define list_for_each(pos, head) \
            for (pos = (head)->next; pos != (head); pos = pos->next)

    #endif /* __KERNEL__ */

    #endif
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
                                        12. Ders 24/08/2025 - Pazar
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    İşletim sistemlerinde "program" terimi çoğu kez "çalıştırılabilen bir dosyayı" ya da "bir kaynak dosyayı" belirtmektedir. 
    Çalışmakta olan programlara ise "proses" denilmektedir. Bir program çalıştırıldığında artık o bir proses haline gelmektedir. 
    Aynı programı birden fazla kez de çalıştırabiliriz. Bu durumda birbirinden bağımsız birden fazla proses oluşacaktır. 

    İşletim sistemlerinin proses yönetimlerindeki en önemli veri yapısı "proses kontrol bloğu (precess control block)" 
    denilen veri yapısıdır. İşletim sistemleri her proses için kavramsal olarak ismine "proses kontrol bloğu" denilen bir 
    yapı türünden nesne oluşturmaktadır. Proseslerin yönetimi proses kontrol bloğu denilen bu veri yapısına başvurularak 
    yapılmaktadır. Proses kontrol bloğu terimi yerine bazı kaynaklar "proses betimleyicisi (process descriptor)" terimini 
    de kullanmaktadır. 

    Proses kontrol blokları içerisinde prosese ilişkin gerekli bütün bilgiler bulundurulmaktadır. Bu bilgilerden bazıları 
    şunlardır:

    - Prosesin kullanıcı id'si, grup id'si gibi hesap (credential) bilgileri
    - Proses id'si 
    - Prosesin üst prosesinin, alt proseslerinin, kardeş proseslerinin hangi prosesler olduğu bilgisi
    - Prosesin durumsal bilgisi
    - Prosesin bağlamsal geçişini (context switch) sağlama için gereksinim duyulan alanlar
    - Prosesin bellekte nereye yüklü olduğu gibi bellekle ilgili bilgileri
    - Prosesin çizelgeleyici ile ilgili olan bilgileri (örneğin çizelgemele politikası, önceliği gibi)
    - Prosesin CPU kullanım istatistiği
    - Prosesin sinyal bilgileri
    - Prosesin proslerarası haberleşme için gerekli olan bilgileri
    - Prosesin çalışma dizini (current working directory)
    - Prosesin açmış olduğu dosyalara ilişkin bilgiler
    - ...
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Linux çekirdeğinde proses kontrol bloğu <include/linux/sched.h> dosyası içerisinde bulunan task_struct isimli yapıyla
    temsil edilmiştir. Bu task_struct yapısı eskiden daha az eleman içeriyordu. Sonra çekirdek gittikçe geliştirilince
    dev bir yapı haline geldi. Örneğin bu task_struct yapısı Linus projeye ilk başlandığında (Linux 0.01) şu biçimdeydi:

    struct task_struct {
    /* these are hardcoded - don't touch */
        long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
        long counter;
        long priority;
        long signal;
        fn_ptr sig_restorer;
        fn_ptr sig_fn[32];
    /* various fields */
        int exit_code;
        unsigned long end_code,end_data,brk,start_stack;
        long pid,father,pgrp,session,leader;
        unsigned short uid,euid,suid;
        unsigned short gid,egid,sgid;
        long alarm;
        long utime,stime,cutime,cstime,start_time;
        unsigned short used_math;
    /* file system info */
        int tty;		/* -1 if no tty, so it must be signed */
        unsigned short umask;
        struct m_inode * pwd;
        struct m_inode * root;
        unsigned long close_on_exec;
        struct file * filp[NR_OPEN];
    /* ldt for this task 0 - zero 1 - cs 2 - ds&ss */
        struct desc_struct ldt[3];
    /* tss for this task */
        struct tss_struct tss;
    };

    Örneğin çekirdeğin 2.4'lü versiyonunda bu yapı şu hale gelmiştir:

    struct task_struct {
        /*
        * offsets of these are hardcoded elsewhere - touch with care
        */
        volatile long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
        unsigned long flags;	/* per process flags, defined below */
        int sigpending;
        mm_segment_t addr_limit;	/* thread address space:
                            0-0xBFFFFFFF for user-thead
                            0-0xFFFFFFFF for kernel-thread
                        */
        struct exec_domain *exec_domain;
        volatile long need_resched;
        unsigned long ptrace;

        int lock_depth;		/* Lock depth */

    /*
    * offset 32 begins here on 32-bit platforms. We keep
    * all fields in a single cacheline that are needed for
    * the goodness() loop in schedule().
    */
        long counter;
        long nice;
        unsigned long policy;
        struct mm_struct *mm;
        int processor;
        /*
        * cpus_runnable is ~0 if the process is not running on any
        * CPU. It's (1 << cpu) if it's running on a CPU. This mask
        * is updated under the runqueue lock.
        *
        * To determine whether a process might run on a CPU, this
        * mask is AND-ed with cpus_allowed.
        */
        unsigned long cpus_runnable, cpus_allowed;
        /*
        * (only the 'next' pointer fits into the cacheline, but
        * that's just fine.)
        */
        struct list_head run_list;
        unsigned long sleep_time;

        struct task_struct *next_task, *prev_task;
        struct mm_struct *active_mm;
        struct list_head local_pages;
        unsigned int allocation_order, nr_local_pages;

    /* task state */
        struct linux_binfmt *binfmt;
        int exit_code, exit_signal;
        int pdeath_signal;  /*  The signal sent when the parent dies  */
        /* ??? */
        unsigned long personality;
        int did_exec:1;
        unsigned task_dumpable:1;
        pid_t pid;
        pid_t pgrp;
        pid_t tty_old_pgrp;
        pid_t session;
        pid_t tgid;
        /* boolean value for session group leader */
        int leader;
        /* 
        * pointers to (original) parent process, youngest child, younger sibling,
        * older sibling, respectively.  (p->father can be replaced with 
        * p->p_pptr->pid)
        */
        struct task_struct *p_opptr, *p_pptr, *p_cptr, *p_ysptr, *p_osptr;
        struct list_head thread_group;

        /* PID hash table linkage. */
        struct task_struct *pidhash_next;
        struct task_struct **pidhash_pprev;

        wait_queue_head_t wait_chldexit;	/* for wait4() */
        struct completion *vfork_done;		/* for vfork() */
        unsigned long rt_priority;
        unsigned long it_real_value, it_prof_value, it_virt_value;
        unsigned long it_real_incr, it_prof_incr, it_virt_incr;
        struct timer_list real_timer;
        struct tms times;
        unsigned long start_time;
        long per_cpu_utime[NR_CPUS], per_cpu_stime[NR_CPUS];
    /* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */
        unsigned long min_flt, maj_flt, nswap, cmin_flt, cmaj_flt, cnswap;
        int swappable:1;
    /* process credentials */
        uid_t uid,euid,suid,fsuid;
        gid_t gid,egid,sgid,fsgid;
        int ngroups;
        gid_t	groups[NGROUPS];
        kernel_cap_t   cap_effective, cap_inheritable, cap_permitted;
        int keep_capabilities:1;
        struct user_struct *user;
    /* limits */
        struct rlimit rlim[RLIM_NLIMITS];
        unsigned short used_math;
        char comm[16];
    /* file system info */
        int link_count, total_link_count;
        struct tty_struct *tty; /* NULL if no tty */
        unsigned int locks; /* How many file locks are being held */
    /* ipc stuff */
        struct sem_undo *semundo;
        struct sem_queue *semsleeping;
    /* CPU-specific state of this task */
        struct thread_struct thread;
    /* filesystem information */
        struct fs_struct *fs;
    /* open file information */
        struct files_struct *files;
    /* namespace */
        struct namespace *namespace;
    /* signal handlers */
        spinlock_t sigmask_lock;	/* Protects signal and blocked */
        struct signal_struct *sig;

        sigset_t blocked;
        struct sigpending pending;

        unsigned long sas_ss_sp;
        size_t sas_ss_size;
        int (*notifier)(void *priv);
        void *notifier_data;
        sigset_t *notifier_mask;
        
    /* Thread group tracking */
        u32 parent_exec_id;
        u32 self_exec_id;
    /* Protection of (de-)allocation: mm, files, fs, tty */
        spinlock_t alloc_lock;

    /* journalling filesystem info */
        void *journal_info;
    };

    Bugünkü 6'lı çekirdeklerde bu yapı birkaç sayfa uzunluğundadır. Eskiden yukarıda da gördüğünüz gibi yapının her 
    elemanı çekirdek derlemesine dahil ediliyordu. Ancak 2.6'lı versiyonlardan başlanarak artık yapı elemanlarının bazıları 
    konfigürasyona (yani "menuconfig" menüsündeki seçeneklere ya da doğrudan ".config" dosyasındaki seçeneklere) bağlı 
    olarak yapıya dahil edilmektedir. Bu nedenle gelişmiş çekirdeklerde yapıda aşağıdaki gibi #ifdef blokları görürseniz 
    şaşırmayınız:

    struct task_struct {
    #ifdef CONFIG_THREAD_INFO_IN_TASK
        /*
        * For reasons of header soup (see current_thread_info()), this
        * must be the first element of task_struct.
        */
        struct thread_info		thread_info;
    #endif
        unsigned int			__state;

        /* saved state for "spinlock sleepers" */
        unsigned int			saved_state;

        /*
        * This begins the randomizable portion of task_struct. Only
        * scheduling-critical items should be added above here.
        */
        randomized_struct_fields_start

        void				*stack;
        refcount_t			usage;
        /* Per task flags (PF_*), defined further below: */
        unsigned int			flags;
        ....
    };

    Bilindiği gibi Linux sistemlerinde yeni bir proses fork isimli POSIX fonksiyonuyla yaratılmaktadır. fork POSIX 
    fonksiyonu çekirdek içerisindeki sys_fork isimli sistem fonksiyonunu çağırmaktadır. Yeni çekirdeklerde bu fonksiyon 
    da kernel_clone isimli çekirdek fonksiyonu çağırmaktadır. İşte task_struct yapısı bu fonksiyonlar tarafından çekirdeğin 
    heap alanında yaratılmaktadır. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi UNIX/Linux sistemlerinde her prosesin (yani çalışmakta olan her programın) "o anda sistem genelinde 
    tek (unique) olan" bir "proses id (process id)" değeri vardır. Proses id değeri hem çekirdek tarafından hem de 
    kullanıcı modundan çağrılabilen sistem fonksiyonları tarafından kullanılan bir kavramdır. Proses id değeri bir 
    prosesi temsil etmekte kullanılan tamsayısal bir değerdir. ps komutuyla proseslere ilişkin proses id değerlerinin 
    görüntülendiğini anımsayınız. Kullanıcı modunda getpid POSIX fonksiyonu çalışmakta olan programın proses id'sini 
    getppid POSIX fonksiyonu ise üst prosesin proses id'sini vermektedir. Tabii prosesin proses id'si ve üst prosesin 
    proses id'si proses kontrol bloğunda yani task_struct yapısı içerisinde saklanmaktadır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    İşletim sistemlerine thread kavramı 90'lı yıllarda sokulmuştur. Ancak ilk thread denemeleri çeşitli çalışmalar 
    eşliğinde daha önceleri yapılmıştır. Linux işletim sistemine thread'ler ilk kez çekirdeğin 2.0 versiyonuyla eklenmiş 
    olsa da daha sonra çeşitli düzeltmelerle thread yapısı biraz değiştirilmiştir. 
    
    Proses kavramı çalışmakta olan programın tüm bilgilerini temsil etmektedir. Halbuki thread yalnızca bir akış 
    belirtmektedir. Bir proses tek bir akışla çalışmaya başlar. Bu akış da bir thread belirtmektedir. Prosesin çalışmaya
    başladığı thread'e "ana thread (main thread)" de denilmektedir. Thread'ler de kullanıcı modundan sistem fonksiyonları 
    (sys_clone sistem fonksiyonu) ile yaratılmaktadır. 
    
    UNIX türevi sistemlere thread'ler ilk kez sokulduğunda farklı varyantlar farklı thread kütüphaneleri kullanıyordu. 
    Sonra thread kavramı POSIX standratlarına da POSIX.1c ile 1995 yılında sokuldu. Böylece POSIX taşınabilir thread 
    fonksiyonları oluşturdu. POSIX'in kullanıcı modundan kullanılabilen taşınabilir thread fonksiyonlarının gerçekleştirimi 
    için Linux'ta olduğu gibi çeşitli UNIX varyantları çekirdek içerisinde de değişiklikler yapmak zorunda kalmıştır. 

    Thread'lerin yalnızca bir akış belirttiğini söylemiştik. Proses kavramı ise tüm thread'lerle birlikte çalışmakta 
    olan programın tüm bilgilerini temsil etmektedir. Pek çok bilgi thread'e özgü değildir, prosese özgüdür. Örneğin 
    bir thread'in "çalışma dizini (current working directory)" diye bir kavram yoktur. Prosesin çalışma dizini diye bir 
    kavram vardır. Örneğin bir thread'in kullanıcı id'si, grup id'si diye bir kavram yoktur. Prosesin kullanıcı id'si 
    ve grup id'si diye bir kavram vardır. Yani çalışmakta olan programa ilişkin pek çok bilgi programın tüm thread'leri
    için de geçerlidir. 

    Aslında thread'ler aynı bellek alanını ve ortak bilgileri kullanan prosesler gibi de düşünülebilir. Zaten Linux 
    işletim sisteminde thread yaratmakla proses yaratmak aslında aynı çekirdek fonksiyonuyla yapılmaktadır. 
    Yani bir prosesin thread'lerini biz aynı bellek alanını kullanan prosesler gibi de düşünebiliriz. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Linux işletim sisteminde thread'ler de adeta aynı bellek alanı üzerinde çalışan birer proses gibi düşünülmüştür. 
    Bu nedenle yalnızca prosesler için değil thread'ler için de task_struct yapısı oluşturulmaktadır. Tabii işletim sistemi 
    bir prosesin thread'lerini yani ana thread'in ve diğer thread'lerin task_struct nesnelerini izleyen paragraflarda 
    göreceğimiz biçimde bağlı listelerde tutmaktadır. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde prosesler arasında kuvvetli bir "altlık-üstlük (parent-child)" ilişkisi vardır. Bir proses 
    yaratıldığında prosesin task_sruct bilgilerinin çoğu üst prosesten (parent process) alınmaktadır. Örneğin bir program
    başka bir programı fork/exec ile çalıştırdığında çalıştırılan program çalıştıran programın pek çok özelliğini 
    almaktadır. Örneğin fork işlemi sırasında fork yapan programın kullanıcı id'si ve çalışma dizini neyse yeni yaratılan 
    alt prosesin (child process) kullanıcı id'si ve çalışma dizini de aynı olur. Daha teknik olarak ifade edersek fork 
    işlemi sırasında alt proses için yaratılan task_struct yapısının pek çok elemanı üst prosesin task_struct yapısından 
    kopyalanmaktadır. 

    POSIX thread sisteminde thread'ler arasında önemli bir altlık-üstlük ilişkisi yoktur. Yani birkaç özel durum dışında 
    bir thread'i hangi thread'in yarattığının önemi yoktur. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    task_struct yapısının pek çok gösterici elemanı vardır. Bu gösterici elemanları başka yapıları göstermektedir. Hatta
    o güsterici elemanların gösterdiği yapıların elemanları da başka yapıları gösterebilmektedir. O halde task_struct
    aslında dallı budaklı bir yapıdır. Biz bir bilgnin proses kontrol bloğunda olduğunu söylediğimiz zaman o bilginin
    hemen task_struct içerisindeki bir elemanda olduğunu kastetmeyeceğiz. O bilgi task_struct içerisindeki bir elemanın 
    gösterdiği başka bir yapının içerisinde de olabilir. Önemli olan o bilgiye task_struct yapısından hareketle erişilebilmesidir.

    Bir task_struct yapısının ana elemanları diğer bir task_struct yapısına kopyalanırsa (C'de zaten aynı türden iki 
    yapı nesnesi birbirine atandığında yapının karşılıklı elemanları kopyalanmaktadır) aslında asıl yapı ile kopyalanmış 
    olan yapının gösterici elemanları aynı yapıları gösterir duruma gelir. Programlamada bu tür kopyalama "sığ kopyalama 
    (shallow copy)" denildiğini anımsayınız. Aslında task_struct yapısının bu biçimdeki dallı budaklı tasarımı üst proses-alt 
    proses ilişkisinde alt prosesin üst prosesten birtakım özellikleri alması (inherit etmesi) sürecinde faydalar sağlamaktadır. 
    Böylece alt prosesin task_struct yapısına daha az eleman kopyalanmaktadır. Örneğin güncel çekirdeklerdeki task_struct 
    yapısının aşağıdaki kısmına dikkat ediniz:

    struct task_struct {
        /* .... */
        
        /* Filesystem information: */
        struct fs_struct		*fs;

        /* Open file information: */
        struct files_struct		*files;
        
        /* .... */
    };

    Burada aslında fs göstericisi aaşağıdaki gibi bir yapıyı göstermektedir:

    struct fs_struct {
        int users;
        spinlock_t lock;
        seqcount_spinlock_t seq;
        int umask;
        int in_exec;
        struct path root, pwd;
    } __randomize_layout;

    Prosesin kök dizininin ve çalışma dizinin burada tutulduğuna dikkat ediniz. files göstericisi ise aşağıdaki gibi 
    bir yapıyı göstermektedir:

    struct files_struct {
    /*
    * read mostly part
    */
        atomic_t count;
        bool resize_in_progress;
        wait_queue_head_t resize_wait;

        struct fdtable __rcu *fdt;
        struct fdtable fdtab;
    /*
    * written part on a separate cache line in SMP
    */
        spinlock_t file_lock ____cacheline_aligned_in_smp;
        unsigned int next_fd;
        unsigned long close_on_exec_init[1];
        unsigned long open_fds_init[1];
        unsigned long full_fds_bits_init[1];
        struct file __rcu * fd_array[NR_OPEN_DEFAULT];
    };

    fork işlemi sırasında sığ kopyalama yapıldığında üst proses ve alt proses aynı fs_struct ve files_struct yapılarını
    gösteriyor olacaktır.
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Thread'lerin de tıpkı prosesler gibi task_struct yapısına sahip olduğunu belirtmiştik. Pekiyi işletim sisteminin 
    çizelgeleyici (scheduler) alt sistemi neleri çizelgelemektedir? İşte çizelgeleyici alt sistem aslında yalnızca 
    thread'leri yani thread'lere ilişkin task_struct yaplarını çizelgelemektedir. Yani çizelgeleyici alt sistemin 
    "çalıştırma kuyruğunda (run queue)" yalnızca task_struct yapılarının olduğunu varsayabilirsiniz. Bir proses yaratıldığında 
    zaten o proses için yaratılan task_struct nesnesi aynı zamanda prosesin ana thread'inin task_struct nesnesi gibidir. 
    Başka bir deyişle aslında bütün task_struct nesneleri birer thread belirtmektedir. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Eskiden Linux sistemleri yalnızca tek işlemciyi desteklyordu. Sonra 2.0 versiyonuyla birlikte çekirdek zamanla birden 
    fazla işlemciyi ya da çekirdeği (core) destekler hale geldi. İşte bir thread çalışırken task_struct * türünden 
    current isimli global değişken o anda çalışmakta olan thread'e ilişkin task_struct nesnesini gösterecek biçimde 
    ayarlanmaktadır. Yani bir çekirdek kodunda current göstericisini görürseniz bu current göstericisi o anda çalışmata 
    olan thread'e ilişkin task_struct nesnesini gösteriyor durumda olacaktır. Tabii bu current göstericisinin o anda 
    çalışan thread'e ilişkin task_struct nesnesini göstermesini "bağlamsal geçişi (context switch)" gerçekleştiren çizelgelyici 
    alt sistem sağlamaktadır. Eskiden Linux yalnızca tek işlemciyi desteklerken current global değişkeni de toplamda bir 
    taneydi. Daha sonra Linux birden fazla işlemciyi ya da çekirdeği desteklemeye başlayınca current global değişkeni de 
    biçim değiştirdi. 

    Bir süredir birden fazla işlemciyi ya da çekirdeği destekleyen Linux çekirdeklerinde artık current değişkeni bir 
    gösterici değil fonksiyon belirtmektedir. (Eskiden doğrudan task_struct türünden bir gösterici belirtiyordu.) Mevcut 
    çekirdeklerde current aşağıdaki gibi bir makro biçiminde tanımlanmıştır:

    #define current get_current()

    Görüldüğü gibi artık biz curent değişkenini kullandığımızda aslında get_current() fonksiyonunu çağırıp bu fonksiyonun 
    geri dönüş değerini kullanmış olmaktayız. Pekiyi bu fonksiyon o anda işlemcide ya da çekirdekte çalışmakta olan 
    thread'in task_struct yapısının adresini nasıl bulup geri döndürmektedir? İşte bunun için Linux çekirdeklerinde 
    zaman içerisinde platforma da (işlemciye de) bağlı olacak biçimde çeşitli teknikler kullanılmıştır. Bu konu thread'in 
    "çekirdek stack alanı (kernel stack)" ve "işlemciye özgü global alanlar" konusuyla ilgilidir. Biz bu konuya başka 
    bir bölümde göreceğiz. Ancak burada pratik bir açıklama yapmak gerekirse şunları söyleyebiliriz: O anda thread'i 
    çalıştırmakta olan işlemcinin ya da çekirdeğin bir yazmacı özel bir alanı göstermektedir (tabii bu gösterme bağlamsal 
    geçiş sırasında ayarlanmaktadır), çalışmakta olan thread'in task_struct yapısının adresi de buradan hareketle 
    elde edilmektedir.  
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi UNIX/Linux sistemlerinde kullanıcı modunda yeni bir proses fork POSIX fonksiyonu ile, yeni bir thread 
    de pthread_create fonksiyonu ile yaratılmaktadır. Yukarıda da belirttiğimiz gibi aslında bu iki çağrı da belirli bir 
    noktadan sonra çekirdek içerisindeki aynı fonksiyonları çağırmaktadır. Kullanıcı modundaki fork fonksiyonun çağrı 
    mekanizması şöyledir:

    fork (kullanıcı modu) ---> sys_fork (çekirdek modu) ---> kernel_clone ---> ....

    pthread_create fonksiyonunun çağrı mekanizması da tipik olarak şöyledir (ancak kütüphaneden kütüphaneye ön aşamalar 
    değişebilir):

    pthread_create ---> sys_clone ---> kernel_clone ---> ....

    O halde aslında çekirdek gözüyle bakıldığında bir thread başka bir therad tarafından yaratılmaktadır. Yani bu 
    yaratımda iki thread söz konusudur: Yaratan thread ve yaratılan thread. Yaratan thread'e ilişkin zaten task_struct 
    yapısı mevcuttur. O halde yaratılan thread için de bir task_struct yapısı oluşturulup bir biçimde bu yapılar 
    ilişkilendirilecektir. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
    Şimdi de task_struct yapısı içerisinde proseslerin thread'leri arasındaki ilişkinin nasıl oluşturulduğunu görelim. 
    Yani çekirdek ya da sistem programcısı bir prosesin tüm thread'lerinin task_struct yapılarını nasıl elde edebilmektedir, 
    bunun üzerinde duralım. 
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------
<BURADA KALDIK>
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------*/

