                                            C ve Sistem Programcıları Derneği

                                                   Python Uygulamaları 

                                         Sınıfta Yapılan Örnekler ve Özet Notlar 
                                                         2. Bölüm
        
                                                    Eğitmen: Kaan ASLAN   
                
                Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.
                Kaynak belirtmek için aşağıdaki referansı kullanabilirsiniz:           

                Aslan, K. (2025), "Python Uygulamaları Kursu", Sınıfta Yapılan Örnekler ve Özet Notlar, 
                    C ve Sistem Programcıları Derneği, İstanbul.

                        (Notları sabit genişlikli font kullanan programlama editörleri ile açınız.)
                            (Editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz.)

                                        Son Güncelleme: 12/07/2025 - Cumartesi


#------------------------------------------------------------------------------------------------------------------------------------
                                        43. Ders 23/08/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Python genel amaçlı bir programlama dili olmasının yanı sıra makine öğrenmesi, veri bilimi ve matematiksel alanlarda da çok tercih 
    edilmektedir. Ancak Python saf haliyle veri işleme (data processing) konusunda bazı yeteneklerden yoksundur. Veri işleme konusunda 
    kullanılan programlama dilleri genellikle "vektörel işlem" yapma yeteneğine sahiptir. Vektörel işlem demekle biz iki dizinin 
    karşılıklı elemanlarının kolay bir biçimde işleme sokulabilmesini anlatmak istiyoruz. Örneğin Matlab (ya da Open source versiyonu 
    olan Octave) gibi R gibi diller ve ortamlar bu vektörel işlem yapma yeteneğine sahiptir. Vektörel işlem yapabilme yeteneği matematiksel 
    ve istatistiksel pek çok işlemi kısaltmaktadır. Başka bir deyişle matematiksel ve istatiksel konularda kolaylık sağlayan dillerde
    vektörel işlem yapma önemli bir ortak özelliktir.

    Python'a vektörel işlem yapma yeteneğini kazandırmak için bazı üçüncü parti kütüphaneler oluşturulmuştur. Bunların en çok kullanılanı 
    "NumPy" isimli kütüphanedir. NumPy Python'da en çok kullanılan kütüphanelerden biridir. Bazı gerekçelerle Python standart kütüphanesine 
    dahil edilmemiş olsa da standart kütüphendeki pek çok modülden çok daha yoğun kullanılmaktadır. (NumPy hızlı güncellenmektedir. 
    Standart kütüphaneye dahil edilmesinin hantallığa yol açacağı düşünülmüştür.) Numpy kütüphanesi adeta Python'u R ya da Matlab 
    gibi bir dil haline getirmektedir. Numpy C'de yazılmış bir kütüphanedir. Kütüphane paralel programlama tekniklerini kullanmamakla 
    birlikte modern işlemcilerin SIMD (Single Instruction Multiple Data) komutlarını da kullanarak etkin bir biçimde gerçekleştirilmiştir. 
    Dolayısıyla Numpy işlemlerinin Python diline kıyasla daha hızlı yapılacağı söylenebilir. (Örneğin biz bir NumPy fonksiyonunu 
    çağırdığımızda aslında rka planda bir C fonksiyonu çalıştırılmaktadır. Dolayısıyla işlemler adeta C hızında yapılmaktadır.)

    Pekiyi Python'u NumPy kütüphanesi ile R'laştırmak yerine doğrudan R ya da Matlab kullanmak daha uygun değil midir? Matlab ve 
    R genel amaçlı diller değildir. Bunlar uzmanlığı programlama olmayan kişilere yönelik hazırlanmış ortamlar ve dillerdir. Halbuki 
    Python genel amaçlı bir programlama dilidir. Python'un genel amaçlı olması nümerik analiz, veri bilimi ve makine öğrenmesi gibi 
    alanlarda da R ve Matlab'ten daha fazla tercih edilmesine yol açmıştır. (Matlab isimli dil ve ürün "Mathworks" isimli bir firmanın 
    mülkiyetindedir. Dolayısıyla ücretlidir. Tabii Matlab'in de çeşitli açık kaynak kodlu biçimleri zamanla oluşturulmuştur. R ise 
    açık kaynak kodlu bir dildir.) 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy kütüphanesi pip programıyla aşağıdaki gibi indirilip kurulabilir:

    pip install numpy

    Anaconda dağıtımında NumPy ve pek çok yaygın kütüphane zaten kurulum sırasında pakete dahil edilmektedir. Yani Anconda için NumPy'ı 
    indirip kurmamıza gerek yoktur. 

    Genellikle NumPy programcıları bu kütüphaneyi np ismiyle import etmektedir. Örneğin:

    import numpy as np

    Projenin ana web sayfası "numpy.org" biçimindedir. Orijinal dokümanlara aşağıdaki bağlantıdan erişilebilirsiniz:

    https://numpy.org/doc/

    Kütüphanenin API referansına da aşağıdaki bağlantıdan erişebilirsiniz:

    https://numpy.org/doc/stable/reference/index.html#reference
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Python'a vektörel işlem yapma yeteneği bir sınıf ile kazandırılabilir. Yani örneğin biz bir sınıf yazabiliriz. Bu sınıf için 
    __add__ gibi, __mul__ gibi operatör metotlarını bulundurabiliriz. Bu operatör metotları da listenin karşılıklı elemanlarını işleme 
    sokabilir. 

    Aşağıda bu fikrin uygulanmasına yönelik örnek bir kod bulunmaktadır. Ancak tamamen Python dünyasında kalarak bu tür vektörel 
    işlemleri yapan bir sınıf oluşturmak işlemlerin yavaş yapılmasına yol açacaktır. Oysa sayısal analiz işlemlerinde işlem yükü 
    oldukça fazla olduğu için bu tür vektörel işlemlerin mümkün olduğunca hızlı bir biçimde yapılması istenir. 
#------------------------------------------------------------------------------------------------------------------------------------

class ndarray:
    def __init__(self, array = None):
        if array:
            self.array = array
        else:
            self.array = []
        
    def __add__(self, nd):
        if isinstance(nd, int):
            new_nd = ndarray()            
            for i in range(len(self.array)):
                new_nd.array.append(self.array[i] + nd)
            return new_nd
            
        if len(self.array) != len(nd.array):
            raise ValueError('arrays are not the same size')

        new_nd = ndarray()            
        for i in range(len(self.array)):
            new_nd.array.append(self.array[i] + nd.array[i])
            
        return new_nd
    
    def __mul__(self, nd):
        if len(self.array) != len(nd.array):
            raise ValueError('arrays are not the same size')

        new_nd = ndarray()   
        for i in range(len(self.array)):
            new_nd.array.append(self.array[i] * nd.array[i])
                        
        return new_nd
    
    def __repr__(self):
        return str(self.array)    
        
x = ndarray([1, 2, 3, 4, 5])
y = ndarray([10, 20, 30, 40, 50])
z = ndarray([5, 2, 3, 1, 6])

k = (x + y) * z
print(k)

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy kütüphanesinin ana veri yapısı ndarray isimli sınıftır. Tıpkı yukarıdaki örnekte olduğu gibi ndarray isimli sınıfa pek çok 
    operatör metodu eklenmiş ve ndarray nesneleri vektörel işlem yapabilir hale getirilmiştir. Tabii NumPy'ın ndarray sınıfı ve diğer 
    global fonksiyonlar yukarıda da belirttiğimiz gibi C'de yazılmış durumdadır. Byunlar işlemcilrin özel SIMD komutlarını da kullanmaktadır. 
    NumPy kütüphanesinin ndarray sınıfının yetenekleri oldukça geniştir. Dolayısıyla NumPy kütüphanesini iyi bir biçimde öğrenmek için
    bu ndarray isimli sınıfın nasıl kullanıldığını öğrenmek gerekir. 

    NumPy kütüphanesi bazı bakımlardan eleştirilebilir. Bir işlemin çok değişik biçimlerde yapılabilmesi öğrenmeyi ve akılda tutmayı 
    zorlaştırmakta ve programcıları tereddüte sevk edebilmektedir. Kütüphanenin API tasarımı kanımızca daha iyi yapılabilirdi.

    Yukarıda da belirttiğimiz gibi NumPy'daki ana veri yapısı ndarray sınıfıdır. ndarray nesnelerine "NumPy dizisi (NumPy array)" de 
    denilmektedir. Biz de kursumuzda bazen "ndarray nesnesi" bazen de "NumPy dizisi" terimini kullanacağız.  
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Numpy'da ilk öğrenilecek şey ndarray nesnesinin (yani NumPy dizisinin) oluşturulmasıdır. Bunun çeşitli yolları vardır. NumPy dizisi
    oluşturmanın en temel yolu array isimli fonksiyonu kullanmaktadır. array fonksiyonu bir dolaşılabilir nesneyi alıp ondan bir 
    numpy dizisi (yani ndarray nesnesi) oluşturmaktadır. Örneğin biz bu fonksiyona parametre olarak bir Pyton listesi, bir Python demeti 
    ya da bir range nesnesi verebiliriz.Örneğin:

    a = np.array([10, 20, 30, 40, 50])
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([1, 2, 3, 4, 5])
print(a, type(a))

#------------------------------------------------------------------------------------------------------------------------------------
    Biz argüman olarak array fonksiyonuna dolaşılabilir nesnelerden oluşan dolaşılabilir nesneler verirsek array fonksiyonu bize 
    çok bıyutlu bir ndarray nesnesi verir. Tipik olarak çok boyutlu diziler Python'daki liste listeleri verilerek yaratılabilmektedir. 
    Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi Python'daki list, tuple, dict gibi veri yapıları aslında değerlerin kendisini tutmamaktadır. Değerlerin tutulduğu 
    nesnelerin adreslerini tutmaktadır. Bu biçimdeki çalışma yoğun sayısal işlemleri oldukça hantal hale gelmektedir. Bu nedenle NumPy 
    dizileri değerleri Python'un listeleri gibi değil C Programlama Dilindeki diziler gibi tutmaktadır. Örneğin:

    a = np.array([1, 2, 3, 4, 5])

    Burada a değişkenin gösteridiği NumPy dizisi tamamen C'deki gibi bir dizidir. Yani NumPy dizisinin elemanları dizi elemanlarına
    ilişkin nesnelerin adreslerini değil doğrudan değerlerin kendisini tutmaktadır. Bu nedenle NumPy dizileri (yani ndarray nesneleri) 
    birkaç istisna durum dışında homojendir. Yani NumPy dizilerinin elemanları genel olarak aynı türdendir. NumPy dizileri Python'daki 
    türler türünden elemanları değil C Programlama Dilindeki türler türünden elemanları tutarlar. Bir NumPy dizisinin tuttuğu elemanların 
    türlerine bu NumPy dizisinin dtype türü denilmektedir. Örneğin bir NumPy dizisinin dtype türü "float32" ise bu C'deki 32 bitlik 
    gerçek sayı türü olan "float" anlamına gelmektedir. Ya da örneğin bir NumPy dizisinin dtype türü "uint64" ise bu C'deki "unisgned 
    long long int" türüne karşılık gelmektedir.  C'de de veri türleri Python'dan çok daha çeşitlidir. İzleyen paragraflarda bir NumPy 
    dizisinin türlerinin neler olabileceğini listeleyeceğiz. 

    NumPy dizilerinin dtype bilgisi sınıfın dtype isimli örnek özniteliğinden elde edilebilir. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a.dtype
    dtype('int32')
    >>> b = np.array([1, 2.2, 4, 5.2, 7])
    >>> b.dtype
    dtype('float64') 

    Bir NumPy dizisinin dtype bilgisini elde ettiğimizde bu bilgi NumPy içerisindeki bir dtype sınıfı türünden olur. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([1, 2, 3.4, 4.7, 5])

print(a.dtype)

#------------------------------------------------------------------------------------------------------------------------------------
    array fonksiyonu ile bir NumPy dizisi yaratılırken eğer dtype belirtilmezse default durumda array fonksiyonu eğer tüm değerler 
    Python int türündense ve önce int32 sonra int64 türlerinden hangisi yeterliyse diziyi o dtype türünden yaratmaktadır. Ancak 
    değerlerden en az biri Python'un float türündense bu durumda diziyi float64 dtype türüyle yaratmaktadır. Örneğin:

    >>> a = np.array([1, 2, 3, 4, 5])
    >>> a.dtype
    dtype('int32')
    >>> a = np.array([3000000000, 2, 3, 4, 5])
    >>> a.dtype
    dtype('int64')
    >>> a = np.array([1, 2, 3., 4, 5])
    >>> a.dtype
    dtype('float64')
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    array fonksiyonuyla NumPy dizisi (ndarray nesnesi) yaratılırken yaratılacak NumPy dizisinin C'deki dtype türü array fonksiyonun 
    dtype parametresi ile açıkça belirlenebilir. array fonksiyonunun dtype parametresi string biçiminde girilebilir. Yukarıda da 
    belirtitğimiz gibi aslında her dtype türü NumPy içerisinde bir sınıfla temsil edilmiştir. dtype için doğrudan np.float32 gibi, 
    np.float64 gibi sınıf isimleri de kullanılabilir. Her ne kadar C'de float64 türü (yani double türü) yaygın kullanılıyorsa da pek 
    çok sayısal analiz uygulamalarında ve makine öğrenmesi uygulamalarında büyük diziler söz konusu olduğu için float32 dtype tercih 
    edilmektedir. Örneğin:

    >>> a = np.array([1, 2, 3, 4, 5], dtype='float64')
    >>> a
    array([1., 2., 3., 4., 5.])
    >>> a.dtype
    dtype('float64')
    >>> b = np.array([1, 2, 3, 4, 5], dtype=np.int8)
    >>> b
    array([1, 2, 3, 4, 5], dtype=int8)
    >>> b.dtype
    dtype('int8')
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2.3, 3], [4, 5, 6]], dtype='float32')
print(a, a.dtype)

import numpy as np

b = np.array([[1, 2.3, 3], [4, 5, 6]], dtype=np.float32)
print(b, b.dtype)

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy dizilerinde kullanabileceğimiz dtype türlerinin önemli olanları şunlardır: 

    bool_ /bool8 : bool türü
    byte / int8 : Bir byte'lık işaretli tamsayı türü
    ubyte / uint8 : Bir byte'lık işaretsiz tamsayı türü
    short / int16 : İki byte'lık işaretli tamsayı türü
    ushort / uint16: İki byte'lık işaretsiz tamsayı türü
    int : Platforma bağlı olarak dört byte ya da 8 byte'lık işaretli tamsayı türü.
    uint : Platforma bağlı olarak dört byte ya da 8 byte'lık işaretsiz tamsayı türü.
    int32 : Dört byte'lık işaretli tamsayı türü
    uint32 : Dört byte'lık işaretsiz tamsayı türü
    int64 : Sekiz byte2lık işaretli tamsayı türü
    uint64 : Sekiz byte'lık işaretsiz tamsayı türü
    float32 / single : Dört byte'lık gerçek sayı türü
    float64 / float / double : Sekiz byte'lık gerçek sayı türü
    str : Yazı turan tür
    object: Heterojen tür

    Diğer türler için Numpy dokümantasyonlarına başvurabilirsiniz. 

    NumPy'da çokça dtype türü olduğu halde en fazla kullanılan dtype türleri "float32", "float64", "int32" ve "uint8" türleridir. 
    NumPy default olarak noktalı sayılar için "float64" türünü, tamsayılar için "int32" türünü kullanmaktadır. Bir NumPy dizisi bu 
    türlerdense print edilirken genel olarak dtype türü gösterilmemektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisi ndarray sınıfının __init__ metoduyla da oluşturulabilir. Bu durumda oluşturulan NumPy dizisi çöp değerler (Yani 
    dizi için bellek alanında eskiden kalmış ratgele değerler) iöermektedir. __init__ metodunun birinci parametresi oluşturulacak NumPy 
    dizisinin boyutlarını bir demetle alır. (Tek boyut için demet kullanmaya gerek yoktur.) Yine yaratım sırasında dtype belirtilebilir. 
    Örneğin:

    Örneğin:

    >>> a = np.ndarray(10, dtype=np.int8)
    >>> a
    array([111,   0, 117,   0, 100,   0,  45,   0, 115,   0], dtype=int8)
    >>> b = np.ndarray((3, 3), dtype=np.int8)
    >>> b
    array([[114,   0, 111],
        [  0, 103,   0],
        [114,   0,  97]], dtype=int8)

    NumPy dizilerinin ndarray sınıfının __init__ metoduyla yaratılması pek tavsiye edilen bir yöntem değildir. 
#------------------------------------------------------------------------------------------------------------------------------------
    
import numpy as np

a = np.ndarray((3, 3), dtype='float32')     # a 3x3'lük çöp değerlerden oluşan bir numpy dizisi
print(a, a.dtype)

#------------------------------------------------------------------------------------------------------------------------------------
    İçi sıfırlarla dolu NumPy dizileri oluşturulabilir. Bunun için zeros fonksiyonu kullanılmaktadır. zeros fonksiyonun birinci parametresi
    yine Numpy dizisinin boyutlarını (shape) belirtir. Genel olarak yaratıcı fonksiyonlardaki boyut belirten shape parametresi bir demet 
    olarak girilir. Ancak demet yerine shape parametresi için int türden düz bir sayı sayı girlirse bu durumda tek boyutlu dizi yaratılır. 
    Örneğin:

    >>> a = np.zeros(10, dtype='int8')
    >>> a
    array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=int8)
    >>> b = np.zeros((10, 10), dtype=np.float32)
    >>> b
    array([[0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]], dtype=float32)
#------------------------------------------------------------------------------------------------------------------------------------
    
import numpy as np

a = np.zeros(10, dtype='int32')
print(a)

b = np.zeros((5, 5), dtype=np.float32)
print(b)

#------------------------------------------------------------------------------------------------------------------------------------
    ones isimli fonksiyon içi 1'lerle dolu bir NumPy dizisi oluşturmaktadır. Yine fonksiyonun birinci parametresi oluşturulacak dizinin 
    boyutlarını, dtype parametresi ise dtype türünü belirtir.  Örneğin:

    >>> a = np.ones(10, dtype='int32')
    >>> a
    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
#------------------------------------------------------------------------------------------------------------------------------------
    
import numpy as np

a = np.ones((3, 3), dtype='uint32')        # 3x3'lük uint32 türünden birlerle dolu dizi
print(a, a.dtype)

#------------------------------------------------------------------------------------------------------------------------------------
    full isimli fonksiyon NumPy dizisini bizim istediğimiz değerle doldurarak yaratır. (Yani zeros ve ones fonksiyonlarının genel 
    biçimidir.) Bu fonksiyonun yine birinci parametresi NumPy dizisinin boyutlarını, ikinci parametresi doldurulacak değerleri 
    belirtmektedir. Fonksiyonda yine dtype belirtilebilir. Örneğin:

    >>> a = np.full(10, 5, dtype='int8')
    >>> a
    array([5, 5, 5, 5, 5, 5, 5, 5, 5, 5], dtype=int8)
    >>> b = np.full((5, 5), 1.2, dtype='float32')
    >>> b
    array([[1.2, 1.2, 1.2, 1.2, 1.2],
        [1.2, 1.2, 1.2, 1.2, 1.2],
        [1.2, 1.2, 1.2, 1.2, 1.2],
        [1.2, 1.2, 1.2, 1.2, 1.2],
        [1.2, 1.2, 1.2, 1.2, 1.2]], dtype=float32)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.full((3, 3), 10, dtype=np.float32)

print(a, a.dtype)

#------------------------------------------------------------------------------------------------------------------------------------
    empty isimli fonksiyon içi herhangi bir biçimde doldurulmamış olan çöp değerlerden oluşan NumPy dizisi oluşturmaktadır. Zaten 
    yukarıda da belirttiğimiz gibi ndarray sınıfı türünden nesne yaratırken de aynı biçimde çöp değerlerden oluşan MumPy dizisi 
    yaratılabiliyordu. Bazen programcı bir NumPy dizisi oluşturup onun içini doldurabilmektedir. İşte bu tür durumlarda zeros gibi 
    bir fonksiyonunun sıfırlama sırasında zaman kaybetmesi istenmeyebilir. Ancak tabii bu tür zaman kayıpları genel olarak Python 
    dünyasında önemli kabul edilmemektedir. Örneğin:

    a = np.empty(10, dtype=np.int32)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.empty(10, dtype='uint8')

print(a, a.dtype)

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda görmüş olduğumuz fonksiyonların _like son ekli biçimleri de vardır. Yani zeros_like, ones_like, empty_like, full_like 
    gibi. Bu fonksiyonlar parametre olarak bir NumPy dizisini alır. Yaratılacak NumPy dizisinin boyutlarını ve dtype özelliğini 
    parametresiyle aldığı dizideki gibi yapar. Örneğin elimizde 2x4'lük float32 değerlerinden oluşan bir NumPy dizisi olsun. Biz de 
    zeros_like fonksiyonu ile 2x4'lük float32 değerlerine sahip ancak içi 0'lardan oluşan bir numpy dizisi yaratmak isteyebiliriz:

    >>> a = np.array([[1, 2, 3, 4], [5, 6, 7, 8]], dtype='float32')
    >>> b = np.zeros_like(a)
    >>> b
    array([[0., 0., 0., 0.],
        [0., 0., 0., 0.]], dtype=float32)

    Bu _like sonekli fonksiyonlarda biz dtype da belirtebiliriz. Bu durumda oluşturulacak NumPy dizisinin dtype özelliği diziden değil 
    bizim belirttiğimiz türden olur. Örneğin:

    >>> a = np.array([[1, 2, 3, 4], [5, 6, 7, 8]], dtype='float32')
    >>> b = np.zeros_like(a, dtype='float64')
    >>> b
    array([[0., 0., 0., 0.],
        [0., 0., 0., 0.]])
    >>> b.dtype
    dtype('float64')    
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6]], dtype=np.float32)

print(a, a.dtype)

b = np.zeros_like(a)
print(b, b.dtype)

#------------------------------------------------------------------------------------------------------------------------------------
    Rastgele değerlerden NumPy dizisi oluşturabilmek için numpy.random modülünde çeşitli fonksiyonlar bulundurulmuştur. Örneğin 
    numpy.random.random fonksiyonu belli bir boyutta 0 ile 1 arasında rastgele gerçek sayı değerleri oluşturmaktadır. Bu fonksiyon 
    dtype parametresine sahip değildir. Her zaman float64 olarak NumPy dizisini yaratmaktadır. Fonksiyonun boyut belirten bir parametresi 
    vardır. Örneğin:

    >>> a = np.random.random((5, 5))
    >>> a
    array([[0.82089125, 0.08025651, 0.73226155, 0.06222221, 0.12049264],
        [0.43171059, 0.45946347, 0.2128061 , 0.5012849 , 0.82467442],
        [0.90062584, 0.82899044, 0.14757077, 0.82961189, 0.67917696],
        [0.60761068, 0.60724418, 0.69019941, 0.73556308, 0.25155426],
        [0.4610114 , 0.25969294, 0.09778555, 0.54427295, 0.9985059 ]])
#------------------------------------------------------------------------------------------------------------------------------------

a = np.random.random((3, 3))
print(a)  

#------------------------------------------------------------------------------------------------------------------------------------
    numpy.random.randint fonksiyonu [low, high) aralığında rastgele tamsayı değerlerinden oluşan NumPy dizisi yaratmaktadır. Bu 
    fonksiyonun üçüncü parametresi yaratılacak NumPy dizisinin boyutunu almakatdır. Bu parametre girilmezse tek bir değer üretilmektedir. 
    Örneğin:

    >>> a = np.random.randint(10, 20, (5, 5), dtype='int8')
    >>> a
    array([[11, 18, 10, 18, 13],
        [16, 15, 12, 18, 12],
        [14, 11, 12, 17, 18],
        [10, 18, 18, 14, 19],
        [10, 16, 17, 14, 14]], dtype=int8)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.random.randint(0, 10, (3, 3), dtype='int32')
print(a)

#------------------------------------------------------------------------------------------------------------------------------------
    arange fonksiyonu Python'un built-in range fonksiyonuna oldukça benzemektedir. Ancak arange bize dolaşılabilir bir nesne vermez. 
    Doğrudan bir NumPy dizisi verir. start, stop, step parametreleri range fonksiyonunda olduğu gibidir. Python'un range fonksiyonundaki 
    start, stop ve step değerlerinin int türünden olması gerektiğini anımsayınız. Halbuki NumPy'daki arange fonksiyonunda parametreler
    float türünden de (yani noktalı sayılar da) olabilir. Böylelikle biz arange ile noktasal artırımlarla bir NumPy dizisi oluşturabiliriz.
    arange fonksiyonu dtype parametresi de alabilmektedir. Ancak bu fonksiyon her zaman tek boyutlu bir diziyi bize verir. Örneğin:

    >>> a = np.arange(-1, 1, 0.1)
    >>> a
    array([-1.00000000e+00, -9.00000000e-01, -8.00000000e-01, -7.00000000e-01,
        -6.00000000e-01, -5.00000000e-01, -4.00000000e-01, -3.00000000e-01,
        -2.00000000e-01, -1.00000000e-01, -2.22044605e-16,  1.00000000e-01,
         2.00000000e-01,  3.00000000e-01,  4.00000000e-01,  5.00000000e-01,
         6.00000000e-01,  7.00000000e-01,  8.00000000e-01,  9.00000000e-01])
    >>> b
        array([0.       , 1.1      , 2.2      , 3.3000002, 4.4      , 5.5      ,
       6.6000004, 7.7000003, 8.8      , 9.900001 ], dtype=float32)

    Fonksiyonda dtype belirtilmezse eğer start, stop, step tamsayı türlerindense default dtype türü np.int32, bunlardan biri float 
    türündense default dtype np.float64 alınmaktadır.

    arange fonksiyonunu kullanırken dikkat etmek gerekir. Çünkü noktasal artırımlar, noktasal start ve stop değerleri yuvarlama 
    hatalarından dolayı beklenenden fazla ya da az sayıda eleman üretebilir. (Örneğin 0.1 artırımlarla ilerleken yuvarlama hatasından 
    dolayı stop değerine çok yakın ama ondan küçük bir değer oluşabilir ve bu değer de dizi içinde bulunabilir.) Zaten Python'daki 
    built-in range sınıfının tamsayı değerler almasının nedeni de budur. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.arange(0, 100, 2, dtype='float32')
print(a)

a = np.arange(0, 0.8, 0.1, dtype='float32')
print(a)

#------------------------------------------------------------------------------------------------------------------------------------
    arange fonksiyonun yukarıda belirtilen probleminden dolayı noktasal artırım için genellikle programcılar linspace fonksiyonunu
    tercih ederler. Bu fonksiyon start, stop ve num parametrelerine sahiptir. Fonksiyon her zaman start ve stop değerlerini de içerecek 
    biçimde eşit aralıklı num tane değeri oluşturarak onu bir NumPy dizisi olarak vermektedir. linspace ile elde edilecek eleman sayısı 
    belli olduğu için arange fonksiyonu yerine genellikle programcılar bunu tercih etmektedir. linspace fonksiyonun dtype parametresi 
    de vardır. Bu parametre için argüman girilmezse default dtype türü np.float64 olarak alınmaktadır.  Örneğin:

    >>> a = np.linspace(0, 10, 10)
    >>> a
    array([ 0.        ,  1.11111111,  2.22222222,  3.33333333,  4.44444444,
            5.55555556,  6.66666667,  7.77777778,  8.88888889, 10.        ])
    >>> a = np.linspace(0, 10, 11)
    >>> a
    array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.])
    >>> a = np.linspace(0, 1, 20, dtype='float32')
    >>> a
    array([0.        , 0.05263158, 0.10526316, 0.15789473, 0.21052632,
        0.2631579 , 0.31578946, 0.36842105, 0.42105263, 0.47368422,
        0.5263158 , 0.57894737, 0.6315789 , 0.68421054, 0.7368421 ,
        0.7894737 , 0.84210527, 0.8947368 , 0.94736844, 1.        ],
        dtype=float32)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.linspace(0, 10, 5)
print(a)

a = np.linspace(0, 10, 20, dtype='float32')
print(a)

#------------------------------------------------------------------------------------------------------------------------------------
    Burada özellikle linspace(0, 5, 5) gibi çağrıdan [0, 1, 2, 3, 4, 5] değerlerinin elde edilmeyeceğine dikkat ediniz. Eğer bu 
    değerler elde edilmek isteniyorsa bu durumda num parametresi 6 olarak girilmelidir.  Örneğin:

    >>> a = np.linspace(0, 5, 5)
    >>> a
    array([0.  , 1.25, 2.5 , 3.75, 5.  ])
    >>> a = np.linspace(0, 5, 6)
    >>> a
    array([0., 1., 2., 3., 4., 5.])
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.linspace(0, 5, 5)
print(a)

a = np.linspace(0, 5, 6)
print(a)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisinin boyutlarını (yani kaça kaçlık olduğunu) nesnenin shape isimli özniteliği ile elde edebiliriz. shape özniteliği 
    bize boyutları belirten bir demet vermektedir. Örneğin:

    >>> a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
    >>> a
    array([[ 1,  2,  3,  4],
        [ 5,  6,  7,  8],
        [ 9, 10, 11, 12]])
    >>> a.shape
    (3, 4)
    >>> a.shape[0]
    3
    >>> a.shape[1]
    4

    Bir NumPy dizisinin kaç boyutlu olduğu bilgisini nesnenin dmim özniteliğindne elde edebiliriz. Örneğin:

    >>> a = np.random.random((3, 5, 7))
    >>> a.ndim
    3

    Tabii aslında a.ndim ile len(a.shape) aynı değeri vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6]], dtype=np.float32)

print(a.shape)
print(a.shape[0], a.shape[1])

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisine len fonksiyonunu uygularsak o bize en dıştaki boyutu verir. Örneğin:

    >>> a = np.random.random((3, 5, 7))
    >>> len(a)
    3

    Dizideki toplam eleman sayısı nesnenin size özniteliği ile elde edilmektedir. Örneğin:

    >>> a.size
    105
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy'da belli bir işi yapmanın birden fazla yöntemi olabilmektedir. Örneğin bazı işlemler doğrudan ndarray sınıfının metotlarıyla,
    bazı işlemler ise numpy modülündeki fonksiyonlarla yapılabilmektedir. NumPy'da belki bir tasarım kusuru olarak şöyle üç durum 
    söz konusudur:

    - Bazı ndarray metotlarının aynı isimli np modülünde global fonksiyon karşılıkları vardır.
    - Bazı ndarray metotlarının aynı isimli np moüdlünde global fonksiyon karşılıkları yoktur.
    - Bazı global fonksiyonların ise ndarray sınıfında bir metot karşılıkları yokturç
    
    Örneğin a bir ndarray nesnesi foo da yapılacak işlemi belirten bir isim olsun biz bu işlemi ndarray sınıfının foo metoduyla şöyle 
    yapabiliriz:

    a.foo(...)

    Ancak aynı işlem foo isimli global fonksiyonla da yapılabilmektedir:

    np.foo(a, ...)

    İki kullanım biçimi arasındaki farka dikkat ediniz. a.foo(...) çağrısında zaten foo a nesnesi üzerinde işlem yapacaktır. (Buradaki 
    a nesnesinin foo metoduna self parametresi olarak aktarılacağına dikkat ediniz.) Ancak np.foo fonksiyonu işlem yapacağı nesneyi 
    bizden parametre olarak almaktadır. Ancak her türlü işlem için hem ndarray sınıfında bir metot hem de global bir fonksiyon 
    bulunmamaktadır. Bazı işlemler için yalnızca numpy modülünde fonksiyon bulundurulmuştur. Bunların bir metot karşılığı yoktur. 
    Bazı işlemler için de yalnızca ndarray içerisinde metot bulundurulmuştur. Bunların da fonksiyon karşılıkları yoktur. Bazı işlemler 
    için de yukarıda belirttiğimiz gibi hem metotlar hem de fonksiyonlar bulunmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisinin boyutları değiştirilebilir. Bunun için ndarray sınıfının reshape metodu ya da reshape fonksiyonu kullanılabilmektedir.
    Metot da fonksiyon da orijinal dizinin shape özelliğini değiştirmez bize belirlediğimiz shape türünden yeni bir "view" nesnesi 
    verir. Default durumda ndarray elemanları C Programlama Dilindeki gibi satırsal biçimde belleğe tek boyutlu olarak yerleştirilmektedir.
    reshape işlemi de bellekteki duruma göre yapılmaktadır. Örneğin aşağıdaki gibi bir NumPy dizisi bulunuyor olsun:

    1 2 3 4 
    5 6 7 8 

    Bu dizi aslında C'de bellekte zaten tek boyutlu biçimde aşağıdaki gibi tutulmaktadır:

    1 2 3 4 5 6 7 8 
    
    Şimdi biz bu diziyi 4x2 olarak reshape yaparsak dizi şu hale gelir:

    1 2
    3 4
    5 6
    7 8

    Yani reshape işlemini şöyle düşünmelisiniz: Sanki önce çok boyutlu dizi tek boyuta dönüştürülüp, yeniden yeni boyuta dönüştürülmektedir. 
    reshape işleminden yeni bir kopya elde edilmemektedir. Aynı dizinin yeni bir görüntüsü yani bir "view" nesnesi elde edilmektedir. 

    >>> a = np.random.randint(0, 100, (5, 4))
    >>> a
    array([[27, 32, 69,  5],
        [92, 69, 31, 16],
        [60, 97, 25, 72],
        [72, 53, 82, 14],
        [20, 84, 67, 23]])
    >>> b = a.reshape(2, 10)
    >>> b
    array([[27, 32, 69,  5, 92, 69, 31, 16, 60, 97],
        [25, 72, 72, 53, 82, 14, 20, 84, 67, 23]])
    >>> c = np.reshape(a, (4, 5))
    >>> c
    array([[27, 32, 69,  5, 92],
        [69, 31, 16, 60, 97],
        [25, 72, 72, 53, 82],
        [14, 20, 84, 67, 23]])

    reshape işleminin yeni bir dizi yaratmadığına dikkat ediniz. Aslında reshape edilmemiş dizi ile reshape edilmiş dizi aynı dizidir. 
    Örneğin:

    >>> a = np.arange(20)
    >>> b = a.reshape(5, 4)
    >>> a
    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19])
    >>> b
    array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11],
        [12, 13, 14, 15],
        [16, 17, 18, 19]])
    >>> b[1, 1] = 1000
    >>> a
    array([   0,    1,    2,    3,    4, 1000,    6,    7,    8,    9,   10,
            11,   12,   13,   14,   15,   16,   17,   18,   19])

    reshape metodunu kullanırken boyutlar demet olarak verilmek zorunda değildir. Ancak demet olarak da (aslında dolaşılabilir bir 
    nesne olarak da) verilebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2, 3, 4], [5, 6, 7, 8]], dtype=np.float32)

print(a)

result = a.reshape((4, 2))
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtitğimiz gibi reshape metodu ya da reshape fonksiyonu bize bir "view" nesnesi vermektedir. Python'da "view" nesnesi 
    demekle "asıl verilere referans eden nesneler" anlaşılmaktadır. Yani bir view nesnesi üzerinde değişiklik yapılırsa aslında 
    değişiklik asıl nesne üzerinde yapılmış olur, ana nesne üzerinde değişiklik yapılırsa bunddan "view" nesnesi de etkilenir. 
    Örneğin:

    >>> a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
    >>> a
    array([[ 1,  2,  3,  4],
        [ 5,  6,  7,  8],
        [ 9, 10, 11, 12]])
    >>> b = a.reshape(4, 3)
    >>> b
    array([[ 1,  2,  3],
        [ 4,  5,  6],
        [ 7,  8,  9],
        [10, 11, 12]])
    >>> a[0, 0] = 100
    >>> b
    array([[100,   2,   3],
        [  4,   5,   6],
        [  7,   8,   9],
        [ 10,  11,  12]])
    >>> b[1, 2] = 200
    >>> a
    array([[100,   2,   3,   4],
        [  5, 200,   7,   8],
        [  9,  10,  11,  12]])

    reshape işleminde yeniden boyutlandırma yapılırken orijinal eleman sayısı elde edilmelidir. Örneğin elimizde 5x4'lük bir NumPy 
    dizisi olsun. Biz bu diziyi 2x10'luk hale getirebiliriz. 1x20'lik hale de getirebiliriz. Ancak 3x6'lık hale getiremeyiz. Örneğin:

    >>> a = np.random.randint(0, 100, (5, 4))
    >>> a
    array([[53, 80, 87, 24],
        [35, 48, 36, 57],
        [18, 83, 54, 69],
        [51,  4, 73, 98],
        [70, 37, 61, 93]])
    >>> b = a.reshape(3, 6)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    ValueError: cannot reshape array of size 20 into shape (3,6)

    reshape metodunda ve fonksiyonunda argüman bir demet olarak (aslında dolaşılabilir nesne olarak) girilmeyip tek bir int değer 
    girilirse bu durumda dizi tek boyuta dönüştürülür. Örneğin:

    >>> a = np.random.randint(0, 100, (5, 4))
    >>> a
    array([[52, 93, 89, 94],
        [32,  0, 88, 76],
        [54, 75, 81, 37],
        [28, 61, 49, 38],
        [ 4, 64, 90, 72]])
    >>> b = a.reshape(20)
    >>> b
    array([52, 93, 89, 94, 32,  0, 88, 76, 54, 75, 81, 37, 28, 61, 49, 38,  4,
        64, 90, 72])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy metotları ve fonksiyonlarının zincir (chain) oluşturacak biçimde kullanılmasıyla sık karşılaşılmaktadır. Örneğin:

    >>> a = np.arange(20).reshape(5, 4)
    >>> a
    array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11],
        [12, 13, 14, 15],
        [16, 17, 18, 19]])

    Burada arange fonksiyonu ile verilen NumPy dizisi o dizi üzerinde doğrudan reshape metodu çağrılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    reshape fonksiyonunda ya da metodunda argümanlardan yalnızca biri -1 olarak girilebilir. Bu durumda bu argümanın değeri dizinin 
    boyutlarına göre otomatik biçimde belirlenir. Örneğin:

    >>> a = np.random.randint(0, 100, (5, 4))
    >>> a
    array([[47, 95, 52, 91],
        [12, 41, 34, 45],
        [69, 15, 47, 33],
        [37, 28,  0, 56],
        [99, 29, 85, 74]])

    Burada 5x4'lük bir NumPy dizisi oluşturulmuştur. Biz bu diziyi aşağıdaki gibi reshape etmek isteyelim:

    >>> b = a.reshape(10, -1)

    Burada -1 yerine gelebilecek tek uygun değer 2'dir. O halde buraya 2 yazılmış olduğu varsayılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında reshape işlemi asıl dizi üzerinde (yani "in-place" biçimde) de onun shape örnek özniteliğine yeni bir demet atayarak da 
    yapılabilmektedir. Burada atanan değerin bdolaşılabilir bir nesne olması gerekir. Örneğin:

    >>> a = np.random.randint(0, 100, (5, 4))
    >>> a
    array([[89, 31, 87, 92],
        [ 3, 59, 49, 73],
        [85, 57, 31, 90],
        [62, 66, 53, 10],
        [45, 12, 21, 87]])
    >>> a.shape = (2, 10)
    >>> a
    array([[89, 31, 87, 92,  3, 59, 49, 73, 85, 57],
        [31, 90, 62, 66, 53, 10, 45, 12, 21, 87]])
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2, 3, 4], [5, 6, 7, 8]], dtype=np.float32)

print(a)
a.shape = (4, 2)
print(a)

#------------------------------------------------------------------------------------------------------------------------------------
    Çok boyutlu dizilerin tek boyutlu hale getirilmesi sık gereksinim duyulan bir işlemlerdendir. Örneğin elimizde 5x4'lük bir NumPy 
    dizisi olsun. Biz de bunu tek boyutlu bir dizi haline getirmeye çalışalım. Tabii bu işlemi reshape metoduyla ya da fonksiyonuyla 
    yapabiliriz. Örneğin:

    >> a = np.random.randint(0, 100, (5, 4))
    >>> a
    array([[39, 48, 33, 13],
        [95, 61, 38, 51],
        [27, 28, 26, 56],
        [32, 29, 55, 16],
        [12, 29, 34, 62]])

    >>> b = a.reshape(20)
    >>> b
    array([39,  48,  33,  13,  95,  61,  38,  51,  27,  28,  26,  56,  32,
        29,  55,  16,  12,  29,  34,  62])

    Ancak bu işlem için ravel isimli bir metot ve aynı isimli global bir fonksiyon da bulundurulmuştur. ravel bize reshape işleminde 
    olduğu gibi bir view nesnesi vermektedir. Örneğin:

    >>> b = a.ravel()
    >>> b
    array([39, 48, 33, 13, 95, 61, 38, 51, 27, 28, 26, 56, 32, 29, 55, 16, 12,
        29, 34, 62])
    >>> b[0] = 100
    >>> a
    array([[100,  48,  33,  13],
        [ 95,  61,  38,  51],
        [ 27,  28,  26,  56],
        [ 32,  29,  55,  16],
        [ 12,  29,  34,  62]])

    Aynı işlem flatten isimli metot ya da fonksiyonla da yapılabilmektedir. Ancak flatten metodu ya da fonksiyonu bir view nesnesi 
    vermez. Gerçek nesnenin bir kopyasını vermektedir. Örneğin:

    >>> a = np.random.randint(0, 100, (5, 4))
    >>> a
    array([[11, 90, 36,  4],
        [22, 26,  8, 48],
        [35, 79, 50, 18],
        [25, 52, 94, 26],
        [36, 83, 90, 21]])
    >>> b = a.flatten()
    >>> b
    array([11, 90, 36,  4, 22, 26,  8, 48, 35, 79, 50, 18, 25, 52, 94, 26, 36,
        83, 90, 21])
    >>> b[0] = 100
    >>> a
    array([[11, 90, 36,  4],
        [22, 26,  8, 48],
        [35, 79, 50, 18],
        [25, 52, 94, 26],
        [36, 83, 90, 21]])
    >>> a[0, 0] = 200
    >>> b
    array([100,  90,  36,   4,  22,  26,   8,  48,  35,  79,  50,  18,  25,
            52,  94,  26,  36,  83,  90,  21])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisi tek boyutlu ya da çok boyutlu olabilir. Hatta boyutsuz NumPy dizileri de söz konusu olabilir. Ancak bu durumda 
    dizi tek bir eleman içerebilir. Yani tek bir değer sanki bir dizi değil de bağımısz tek bir değer gibi ndarray nesnesi biçiminde 
    de ifade edilebilmektedir. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> a.shape
    (3, 3)
    >>> b = np.array([1, 2, 3, 4, 5])
    >>> b
    array([1, 2, 3, 4, 5])
    >>> b.shape
    (5,)
    >>> c = np.array(123)
    >>> c
    array(123)
    >>> c.shape
    ()
    >>> c.ndim
    0
    >>> type(c)
    <class 'numpy.ndarray'>

    Tek bir değerden oluşan ndarray nesnelerinin boyutunun olmadığına dikkat ediniz. Biz böyle NumPy dizilerine "boyutsuz NumPy dizileri"
    diyeceğiz. Bu tür durumlarda dizi içerisindeki değer item metodu ile, tür dönüştürmesi ile ya da [()] ifadesi ile elde edilebilir. 
    Örneğin:

    >>> a = np.array(100)
    >>> a
    array(100)
    >>> int(a)
    100
    >>> a[()]
    100
    >>> a.item()
    100

    item metodu yalnızca tek elemana sahip NumPy dizilerinde ya da boyutsuz değer içeren NumPy dizilerinde kullanılabilir.
    Bu metodun global bir fonksiyon karşılığı yoktur.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                        44. Ders 24/08/2025 – Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisi ndarray sınıfının tolist metodu ile Python listesine de dönüştürülebilir. Örneğin:

    >>> a = np.arange(20).reshape(5, 4)
    >>> a
    array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11],
        [12, 13, 14, 15],
        [16, 17, 18, 19]])
    >>> b = a.tolist()
    >>> b
    [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19]]
    >>> a = np.random.random((2, 3))
    >>> a
    array([[0.89825016, 0.64433664, 0.07580248],                
        [0.62594548, 0.48109102, 0.08182892]])
    >>> b = a.tolist()
    >>> b
    [[0.8982501574859335, 0.644336642866961, 0.07580248213618257], [0.6259454839761603, 0.4810910207754172, 0.08182892407036302]]

    Tabii aslında zaten list sınıfının __init__ metoduna biz dolaşılabilir bir nesne verdiğimizde metot onu dolaşarak ondan 
    list nesnesi oluşturabilmektedir. Bu durumda a bir NumPy dizisi belirtmek üzere a.tolist() işlemi ile list(a) işlemi arasında 
    işlevsel bir fark yoktur. 

    Python'daki range fonksiyonu ile biz noktalı artırımlar oluşturamıyorduk. Noktalı artırımlarla Python listesini arange 
    fonksiyonu ile şöyle elde edebiliriz:

    >>> a = np.arange(0, 1, 0.1).tolist()
    >>> a
    [0.0, 0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9]
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[4, 2, 3], [7, 1, 9], [5, 10, 6]], dtype='float32')

b = a.tolist()
print(b, type(b))       # [[4.0, 2.0, 3.0], [7.0, 1.0, 9.0], [5.0, 10.0, 6.0]] <class 'list'>

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Numpy dizisinin elemanlarına [] operatörüyle erişilebilmektedir. Eğer dizi çok boyutluysa erişim köşeli parantez içerisinde 
    her boyut için virgüllerle ayrılmış indeks belirtilerek yapılmaktadır. Örneğin:

    >>> a = np.arange(20).reshape((5, 4))
    >>> a
    array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11],
        [12, 13, 14, 15],
        [16, 17, 18, 19]])
    >>> a[2, 3]
    11
    >>> a[0, 0]
    0

    Tabii elemana erişirken boyut dikkate alındığında sınır dışına çıkılıyorsa IndexError exception'ı oluşmaktadır. Örneğin:

    >>> a = np.arange(20).reshape((5, 4))
    >>> a
    array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11],
        [12, 13, 14, 15],
        [16, 17, 18, 19]])
    >>> a[2, 3]
    11
    >>> a[0, 0]
    0

    Erişim işleminde tıpkı Python listelerinde olduğu gibi negatif indeksler de kullanılabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy dizileri değiştirilebilir (mutable) nesnelerdir. Biz bir NumPy dizisinin belli bir elemanını değiştirebiliriz.  Örneğin:

    >>> a = np.arange(20).reshape((5, 4))
    >>> a
    array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11],
        [12, 13, 14, 15],
        [16, 17, 18, 19]])
    >>> a[2, 3] = 100
    >>> a
    array([[  0,   1,   2,   3],
        [  4,   5,   6,   7],
        [  8,   9,  10, 100],
        [ 12,  13,  14,  15],
        [ 16,  17,  18,  19]])

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Köşeli parantez operatörü ile elemana erişirken n boyutlu bir NumPy dizisinde köşeli parantez içerisine k < n biçiminde k tane 
    index girilebilir. Bu durumda geri kalan elemanlar bir NumPy dizisi olarak elde edilecektir. Örneğin 3x3'lük bir a dizimiz olsun. 
    Biz de erişimi a[1] biçiminde yaparsak a dizisinin 1'inci indeksli satırınaki tüm değerleri NumPy dizisi olarak bir view nesnesi 
    biçiminde elde ederiz. Örneğin:

    >>> a = np.arange(9).reshape(3, 3)
    >>> a
    array([[0, 1, 2],
        [3, 4, 5],
        [6, 7, 8]])
    >>> a[1]
    array([3, 4, 5])

    Başka bir deyişle biz n boyutlu bir NumPy dizisinin elemanına erişirken k < n tane indeks verebiliriz. Bu durumda diğer boyutların 
    tüm elemanları elde edilmektedir. Örneğin:

   >>> a = np.arange(27).reshape(3, 3, 3)
    >>> a
    array([[[ 0,  1,  2],
            [ 3,  4,  5],
            [ 6,  7,  8]],

        [[ 9, 10, 11],
            [12, 13, 14],
            [15, 16, 17]],

        [[18, 19, 20],
            [21, 22, 23],
            [24, 25, 26]]])
    >>> a[1]
    array([[ 9, 10, 11],
        [12, 13, 14],
        [15, 16, 17]])
    >>> a[1, 2]
    array([15, 16, 17])
    >>> a[1, 2, 2]
    17

    Bu örnekte biz 3x3x3'lük bir NumPy dizisi oluşturduk. Biz bu diziyi "her biri 3x3'lük olan 3 elemanı bir dizi" gibi düşüneneliriz.
    Buradaki a[1] erişimi aslında 3 elemanlı 3x3'lük dizinin 1'inci indeksli dizisi anlamına gelmektedir. a[1, 2] erişimi ise 3x3'lük 
    3 tane dizinin 1'inci indeksteki dizisinin 2'inci indeksteki satırı anlamına gelmektedir. Tabii bu erişimlerin hepsi bize birer 
    view nesnesi vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.arange(27).reshape((3, 3, 3))
print(a)

b = a[1]
print(b)

c = a[1, 2]
print(c)

d = a[1, 2, 2]
print(d)

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy dizileri üzerinde dilimleme (slicing) yapılabilir. Dilimleme işleminde tamamen Python listelerindeki semantik uygulanmaktadır. 
    Dilimleme her boyut için ayrı ayrı yapılabilmektedir. Dilimleme işleminden yeni bir NumPy dizisi view nesnesi olarak elde edilmektedir. 
    Dilimleme ilk boyuttan başlanarak boyut boyut gerçekleştirilmektedir. Örneğin a dizisi 10x10'luk boyutunda olsun:
    
    >>> a = np.arange(100).reshape((10, 10))
    >>> a
    array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14, 15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
        [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],
        [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
        [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],
        [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],
        [70, 71, 72, 73, 74, 75, 76, 77, 78, 79],
        [80, 81, 82, 83, 84, 85, 86, 87, 88, 89],
        [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]])
 
    Biz burada  a[2:5, 4:7] dilimlemesi yapmak isteyelim. Bu işlem NumPy tarafından şöyle yürütülmektedir:

    1) Önce a[2], a[3] ve a[4] satırları elde edilir:

     20, 21, 22, 23, 24, 25, 26, 27, 28, 29
     30, 31, 32, 33, 34, 35, 36, 37, 38, 39
     40, 41, 42, 43, 44, 45, 46, 47, 48, 49

    2) Sonra bu elde edilen satırlardan 4, 5 ve 6 indeksle sütunlar elde edilir:

    24, 25, 26
    34, 35, 36
    44, 45, 46

    Şimdi bu işlemi komut satırında gerçekleştirelim:

    >>> a[2:5, 4:7]
    array([[24, 25, 26],
        [34, 35, 36],
        [44, 45, 46]])

    Dilimleme işleminde aynı boyutta bir dizi elde edildiğine dikkat ediniz. 

    Şimdi tersten gidelim. Elimizde 3x3x3'lük üç boyutlu bir NumPy dizisi olsun:

    >>> a = np.arange(27).reshape((3, 3, 3))
    >>> a
    array([[[ 0,  1,  2],
            [ 3,  4,  5],
            [ 6,  7,  8]],

        [[ 9, 10, 11],
            [12, 13, 14],
            [15, 16, 17]],

        [[18, 19, 20],
            [21, 22, 23],
            [24, 25, 26]]])

    Biz bu diziden aşağıdaki kısmı elde etmek isteyelim:

    19, 20
    22, 23
    
    Burada önce bizim son diziyi elde etmemiz gerekir:

    >>> a[2:3]
    array([[[18, 19, 20],
            [21, 22, 23],
            [24, 25, 26]]]),

    Sonra bu dizi içerisindeki 0'ınci ve 1'inci satırları elde etmemiz gerekir:

    >>> a[2:3, 0:2]
    array([[[18, 19, 20],
            [21, 22, 23]]])

    Nihayet buradaki 1'inci ve 2'inci sütunları elde etmemiz gerekir:

    >>> a[2:3, 0:2, 1:3]
    array([[[19, 20],
            [22, 23]]])

    Burada biz yine üç boyutlu bir dizi elde ettik. Eğer bunu iki boyuta indirgemek istiyorsak reshape yapmamız gerekir. 
    Örneğin:

    >>> a[2:3, 0:2, 1:3].reshape((2, 2))
    array([[19, 20],
        [22, 23]])

    
    Dilimleme işleminde Python listelerinde oldupu gibi negatif indeksler de kullanılabilmektedir. 

    Aşağıdaki örnekte 4X5'lik bir NumPy dizisinde satır ve sütun üzerinde ayrı ayrı dilimleme yapılarak bu NumPy dizisinden bir alt 
    dizi elde edilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]], dtype=np.float32)

print(a)

b = a[1:3, 1:3]
print(b)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir resim aslında pixel'lerden oluşmaktadır. Resim eğer renkli ise her pixel RGB biçiminde üç ayrı byte'tan oluşur. Ancak ".png"
    formatına ilişkin resimlerin her pixel'i transparanlık bilgisini de içerdiği için dört byte'tan oluşmaktadır. Eğer elimizde 
    ".jpg" gibi, ".bmp" gibi, ".png" gibi bir resim dosyası varsa o resmin pixel'lerini bir NumPy dizisi biçiminde elde etmenin 
    birkaç yolu vardır. (Bu dosyaları open fonksiyonuyla açıp okumaya çalışmayınız. Çünkü bu dosyaların ieçrisinde başka birtakım 
    metadata bilgileri de vardır.) Kurusumuzda izleyen bölümlerde göreceğimiz Matplotlib kütüphanesindeki imread isimli fonksiyon 
    resim dosyasının yol ifadesini alarak onun pixel'lerini bize NumPy dizisi biçiminde vermektedir. Örneğin:

    from matplotlib.pyplot import imread

    data = imread('AbbeyRoad.jpg')

    Burada data 3 boyutlu bir NumPy dizisidir. Biz data[x, y] biçiminde bir erişim yaparsak resmin RGB bilgilerine ilişkin 3 elemanlı 
    bir NumPy dizisi elde ederiz. Aslında aynı işlem "Python Image Library (PIL ya da PILLOW)" denilen bir kütüphane ile de yapılabilmektedir:

    from PIL import Image

    image = Image.open('AbbeyRoad.jpg')
    data = np.array(image)

    Pekiyi elimizde RGB renklerine ilişkin pixel'lerden oluşan bir NumPy dizisi varsa bu resmi nasıl çizdirebiliriz? Bunun da birkaç 
    yolu vardır. Örneğin bu işlem Matplotlib kütüphanesindeki imshow fonksiyonu ile yapılabilir:

    from matplotlib.pyplot import imread, imshow

    data = imread('AbbeyRoad.jpg')
    imshow(data)

    Ancak imshow fonksiyonu resmi kendisi boyutlandırarak çizdirmektedir. Yani resmi orijinal boyutuyla görüntülemek biraz zahmetlidir. 
    Elimizdkei NumPy dizisine ilişkin resmi görüntülemenin diğer bir yolu da yine PIL kütüphensini kullanmaktadır. Örneğin:

    from PIL import Image

    image = Image.fromarray(data)
    image.show()

    Ancak show metodu resmi IPython konsolunda değil default ilişkilendirilmiş programla göstermektedir. Biz elimizdeki Image nesnesi 
    içerisind ebulunan resmi Image sınıfının save metodula save edebiliriz. Örneğin:

    image.save('Clpped-AbbeyRoad.jpg')

    Bir resim üzerinde işlemler aslında resmin pixelleri üzerinde yapılmaktadır. Biz resmin pixel'lerini NumPy dizisi halinde elde
    ettikten sonra artık onu dilimleyerek resmin belirli kısımlarını atabiliriz. Ya da satırları yer değiştirerek resmi ters yüz 
    edebiliriz. Örneğin:

    data = imread('AbbeyRoad.jpg')
    clipped_data = data[30:-30, 30:-30, :]
 #------------------------------------------------------------------------------------------------------------------------------------

from matplotlib.pyplot import imread, imshow

data = imread('AbbeyRoad.jpg')
clipped_data = data[30:-30, 30:-30, :]

from PIL import Image

image = Image.fromarray(clipped_data)
image.show()

image.save('Clpped-AbbeyRoad.jpg')

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtildiği gibi elemana erişim sırasında ilk k tane boyut için indeks girilmiş ancak geri kalan indeksler girilmemişse 
    aslında girilmeyen indekslerin hepsi işleme dahil edilmektedir. Örneğin elimizde iki boyutlu a isimli bir NumPy dizisi olsun. Bu durumda 
    a[1] biçiminde bir erişim a[1, :] anlamına gelmektedir. Ya da örneğin b üç boyutlu bir NumPy dizisi olsun. Bu durumda b[k] gibi 
    bir ifade ile b[k, :, :] ifadesi eşdeğerdir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]], dtype=np.float32)

val = a[1]
print(val)

val = a[1, :]
print(val)

val = a[:, 4]
print(val)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir numpy dizisinin elemanları [] operatörü ile elde edildiğinde ürünün boyutuna dikkat ediniz. Örneğin iki boyutlu matristen 
    bir satırı ya da sütunu çektiğimizde elde ettiğimiz dizi tek boyutlu olmaktadır. Ancak biz iki boyutlu matrisin belli bir kısmını 
    dilimleyerek çektiğimizde elde edilen dizi iki boyutlu olmaktadır. Başka bir deyişle çok boyutlu bir diziden elde edilen dizi 
    duruma göre tek boyutlu ya da çok boyutlu olabilmektedir. Dilimleme bize her zaman aynı boyutta bir NumPy dizisi vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Biz bir NumPy dizisinin tek bir elemanını elde ettiğimizde bu eleman Python türünden int, float ya da bool olmaz. C Programlama 
    Dilindeki türlerden (yani dtype türlerinden olur.) Buna NumPy'da skaler de denilmektedir. Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3))
    >>> a
    array([[83, 60, 50],
        [ 5, 28, 98],
        [34, 39, 56]])
    >>> x = a[0, 0]
    >>> x
    83
    >>> type(x)
    <class 'numpy.int32'>

    Burada a dizinin [0, 0] indeksindeki eleman elde edildiğinde elde edilen bu değer numpy.int32 isimli bir türdendir. Bu türler 
    tür dönüştürmesi yapılarak Python'un orijinal türlerine dönüştürülebilir. Örneğin:

    >>> int(x)
    83

    NumPy'daki skaler nesneleri biz aritmetik işlemlere sokarsak yine Python türünden değil NumPy'daki skaler türden değer elde ederiz. 
    Örneğin:

    >>> x = np.float32(3.14)
    >>> x
    3.14
    >>> type(x)
    <class 'numpy.float32'>
    >>> y = x + 2
    >>> y
    5.140000104904175
    >>> type(y)
    <class 'numpy.float64'>
#------------------------------------------------------------------------------------------------------------------------------------
import numpy as np

a = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]], dtype=np.float32)

val = a[1]
print(type(val), val.shape)     # <class 'numpy.ndarray'> (5,)

val = a[:, 4]
print(type(val), val.shape)     # <class 'numpy.ndarray'> (4,)

val = a[2:4, 1:3]
print(type(val), val.shape)     # <class 'numpy.ndarray'> (2, 2)

val = a[3, 4]
print(type(val), val.shape)     # <class 'numpy.float32'> ()

x = val + 2
print(type(x), x.shape)         # <class 'numpy.float64'> ()

y = float(x)
print(type(y))                  # <class 'float'>            

#------------------------------------------------------------------------------------------------------------------------------------
    Dilimleme sırasında bir "view" nesnesinin elde edildiğine dikkat ediniz.Yani dilim üzerinde işlem yapıldığında bundan ana nesne, 
    ana nesne üzerinde işlem yapıldığında bundan dilimlenmiş nesne etkilecektir. Örneğin:

    >>> a = np.arange(100).reshape((10, 10))
    >>> a
    array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14, 15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
        [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],
        [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
        [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],
        [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],
        [70, 71, 72, 73, 74, 75, 76, 77, 78, 79],
        [80, 81, 82, 83, 84, 85, 86, 87, 88, 89],
        [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]])
    >>> b = a[4:6, 2: 7]
    >>> b
    array([[42, 43, 44, 45, 46],
        [52, 53, 54, 55, 56]])
    >>> a[4, 2] = 100
    >>> b
    array([[100,  43,  44,  45,  46],
        [ 52,  53,  54,  55,  56]])
    >>> b[0, 0] = 200
    >>> a
    array([[  0,   1,   2,   3,   4,   5,   6,   7,   8,   9],
        [ 10,  11,  12,  13,  14,  15,  16,  17,  18,  19],
        [ 20,  21,  22,  23,  24,  25,  26,  27,  28,  29],
        [ 30,  31,  32,  33,  34,  35,  36,  37,  38,  39],
        [ 40,  41, 200,  43,  44,  45,  46,  47,  48,  49],
        [ 50,  51,  52,  53,  54,  55,  56,  57,  58,  59],
        [ 60,  61,  62,  63,  64,  65,  66,  67,  68,  69],
        [ 70,  71,  72,  73,  74,  75,  76,  77,  78,  79],
        [ 80,  81,  82,  83,  84,  85,  86,  87,  88,  89],
        [ 90,  91,  92,  93,  94,  95,  96,  97,  98,  99]])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Programcı bazen bir view nesnesi elde etmek istemeyebilir. Gerçekten orijinal nesnenin bir kopyasını oluşturmak isteyebilir. 
    Bunun için ndarray sınıfının copy metodu ya da copy fonksiyonu kullanılabilir. Örneğin:

    >>> a = np.arange(25).reshape((5, 5))
    >>> a
    array([[ 0,  1,  2,  3,  4],
        [ 5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14],
        [15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24]])
    >>> b = a.copy()
    >>> b
    array([[ 0,  1,  2,  3,  4],
        [ 5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14],
        [15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24]])
    >>> a[0, 0] = 100
    >>> b
    array([[ 0,  1,  2,  3,  4],
        [ 5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14],
        [15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24]])

    Burada biz a nesnesinin aynı değerleri içeren bir kopyasını oluşturduk. Artık iki kopya birbirinden farklıdır. Birinde yapılan 
    değişiklik diğerini etkilemeyecektir. Tabii dilimleme yapıldıktan sonra da copy metodu çağrılabilir. Örneğin:

    >>> a = np.arange(25).reshape((5, 5))
    >>> a
    array([[ 0,  1,  2,  3,  4],
        [ 5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14],
        [15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24]])
    >>> b = a[2:4, 1:3].copy()
    >>> b
    array([[11, 12],
        [16, 17]])
    >>> a[2, 2] = 100
    >>> b
    array([[11, 12],
        [16, 17]])
    >>> b[0, 0] = 200
    >>> a
    array([[  0,   1,   2,   3,   4],
        [  5,   6,   7,   8,   9],
        [ 10,  11, 100,  13,  14],
        [ 15,  16,  17,  18,  19],
        [ 20,  21,  22,  23,  24]])
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]], dtype=np.float32)

b = a.copy()

a[0, 0] = 100

print(a)
print(b)

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi biz bir NumPy dizisinden tek bir eleman çektiğimizde o bir NumPy dizisi olmaz, bir NumPy dtype 
    değeri olur. Aslında dtype türleri de birer sınıf belirtmktedir ve biz o sınıflar türünden de nesneler yaratabiliriz. Örneğin:

    x = np.float32(10)

    Biz buradan C'deki "float" türüne ilişkin (yani 4 byte uzunlukta gerçek sayı türüne ilişkin) bir nesne elde etmiş olduk. Örneğin:

    >>> x = np.float32(3.14)
    >>> x
    3.14
    >>> type(x)
    <class 'numpy.float32'>
     >>> float(x)
    3.140000104904175
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

x = np.float32(10)
print(x, type(x))      # 10.0 <class 'numpy.float32'> 

#------------------------------------------------------------------------------------------------------------------------------------
    Elimizde bir NumPy skaleri (yani dtype nesnesi) varsa o nesnenin içerisindeki değeri Python türü olarak iki biçimde elde edebiliriz:
    Python türüne tür dönüştürmesi yaparak ya da dtype sınıflarının item metotlarını kullamak. Örneğin:

    >>> x = np.float32(3.14)
    >>> float(x)
    3.140000104904175
    >>> x.item()
    3.140000104904175
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

x = np.float32(10)
print(x, type(x))

y = x.item()
print(y, type(y))

x = np.int8(3)
print(x, type(x))

y = x.item()
print(y, type(y))

#------------------------------------------------------------------------------------------------------------------------------------
   İki NumPy dizisi ya da skaleri işleme sokulduğunda bunların dtype türleri aynı ise sonuç olarak elde edilen dtype türü de aynı 
   olur. Örneğin:

    >>> a = np.array([1, 2, 3], dtype=np.float32)
    >>> b = np.array([1, 2, 3], dtype=np.float32)
    >>> c = a + b
    >>> c.dtype
    dtype('float32')

    Farklı dtype türlerine ilişkin diziler de işleme sokulabilirler. Bu durumda şu kurallar işletilmektedir:

    1) İki NumPy dizisinin dtype türü de tamsayı türlerine ilişkinse ürün büyük tamsayı türünden olur. Örneğin:

    >>> a = np.array([1, 2, 3], dtype=np.int8)
    >>> b = np.array([1, 2, 3], dtype=np.int64)
    >>> c = a + b
    >>> c.dtype
    dtype('int64')

    2) Dizilerden biri işaretli dtype türünden diğeri ise işaretsiz dtype türünden ise elde edilecek ürün bu türleri kapsayan daha 
    büyük ilk işaretli türden olmaktadır. Örneğin:

    >>> a = np.array([1, 2, 3], dtype=np.uint8)
    >>> b = np.array([1, 2, 3], dtype=np.int8)
    >>> c = a + b
    >>> c.dtype
    dtype('int16')

    3) Dizilerden birinin dtype türü tamsayı türünden diğerinin dtype türü gerçek sayı türünden ise ürün gerçek sayı türüne ilişkin 
    dtype türünden olur. Örneğin:

    >>> a = np.array([1, 2, 3], dtype=np.int8)
    >>> b = np.array([1, 2, 3], dtype=np.float32)
    >>> c = a + b
    >>> c.dtype
    dtype('float32')
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi dilimleme işlemi her zaman bir NumPy view nesnesinin elde edilmesine yol açmaktadır. Ancak dilimleme 
    olmaksızın belli bir elemana erişildiğinde dtype türlerine ilişkin bir skaler nesne elde edilmektedir. Bu dtype nesneleri bir view 
    belirtmezler. Örneğin:

    >>> a = np.array([1, 2, 3], dtype='int32')
    >>> x = a[0]

    Biz burada x'e atama yaptığımızda zaten Python dinamik tür sistemine sahip bir programlama dili olduğu için artık x yeni atanan 
    değer türünden olur. Örneğin:

    >>> x = 12
    >>> type(x)
    <class 'int'>
    >>> a
    array([1, 2, 3])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi elimizde bir ndarray nesnesi (yani NumPy dizisi) varsa, biz bu ndarray nesnesinin bir view belirtip belirtmediğini nasıl 
    anlarız? Bunun birkaç yolu vardır. En dolaysız yolu nesnenin base isimli örnek özniteliğine bakmaktır. Eğer nesne bir view nesnesi 
    değil de gerçek bir nesne ise base örnek özniteliği None değerini verecektir. Eğer nesne bir view nesnesi ise base örnek özniteliği 
    gerçek nesnenin referansını verecektir. (View nesneleri aslında bir biçimde gerçek nesnenin adresini ve onun hangi kısmına 
    referans edildiği bilgisini tutmaktadır.) Örneğin:

    >>> a = np.array([[1, 2, 3], [5, 6, 7], [7, 8, 9]], dtype='float32')
    >>> a
    array([[1., 2., 3.],
        [5., 6., 7.],
        [7., 8., 9.]], dtype=float32)
    >>> b = a[1:, 1:]
    >>> b
    array([[6., 7.],
        [8., 9.]], dtype=float32)
    >>> print(b.base)
    [[1. 2. 3.]
    [5. 6. 7.]
    [7. 8. 9.]]
    >>> print(a.base)
    None
    >>> id(a)
    1897598332432
    >>> id(b)
    1897598330320
    >>> id(b.base)
    1897598332432
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

print(a.base)       # None

b = a[1, :]

print(id(a))
print(id(b.base))

print(a is b.base)      # True

#------------------------------------------------------------------------------------------------------------------------------------
   Aşağıdaki örnekte aslında elde edilen a nesnesi bir view nesnesidir:

   >>> a = np.arange(20).reshape(5, 4)
    >>> a.base
    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19])
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.arange(0, 20, dtype='float32').reshape(4, 5)
print(a.base is None)       # False

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisi dolaşılabilir bir nesneyle indekslenebilir. Bu durumda ilgili indeksteki elemanlar bir NumPy dizisi biçiminde elde 
    edilmektedir. Örneğin:

    >>> a = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])
    >>> a
    array([ 10,  20,  30,  40,  50,  60,  70,  80,  90, 100])
    >>> b = a[[1, 4, 6]]
    >>> b
    array([20, 50, 70])

    Burada biz a deizinin sırasıyla 1, 4, ve 6 numaralı indekslerindeki elemanlardna oluşan bir NumPy dizisi elde etmiş olduk. 
    Tabii biz aynı indeksi birden fazla kez kullabiliriz. Örneğin:

    >>> a = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])
    >>> a[[3, 4, 3, 1]]
    array([40, 50, 40, 20])
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])

b = a[[2, 5, 3, 1]]
print(b)                # [30 60 40 20]

#------------------------------------------------------------------------------------------------------------------------------------
    Demetlerin köşeli parantezdeki özel anlamını anımsayınız. Python'da her zaman a[x, y, z] sentaksı ile a[(x, y, z)] sentakı aynı 
    anlamdadır. Bu nedenle dolaşılabilir nesnenin demet biçiminde oluşturulması error'e yol açabilecektir. Örneğin:

    >>> a = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])
    >>> b = a[(1, 4, 6)]
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    IndexError: too many indices for array: array is 1-dimensional, but 3 were indexed
        
    Fakat yine biz bu tür durumlarda demet kullanabiliriz. Ancak demetten sonra ekstra bir ',' atomu da sentaksta kullanılmalıdır. 
    Örneğin:

    >>> b = a[(1, 4, 6), ]
    >>> b
    array([20, 50, 70])

    Anımsanacağı gibi Python'da genel olarak "virgüllü listelerde (comma separeted lists)" son bir virgül atomu hataya yol açmamaktadır. 
    Örneğin:

    x = [10, 20, 30, ]
    y = 10, 20, 30, 

    Yani biz bir  NumPy dizisinin tek bir elemanına erişirken de eksta ',' atomu kullanırsak bu sentaks bakımından geçerlidir. İndekslemede 
    kullanılan bu ekstra ',' aslında indeksin bir demet olduğunu belirtmektedir. Yani örneğin a[1, ] ifadesi aslında a[(1, )] ifadesi ile 
    eşdeğerdir. Yukarıda da belirtildiği gibi NumPy dizileri demetle indekslenebilmektedir. Ancak Python listeleri demetlerle indekslenemez. 
    Örneğin:

    >>> a = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])
    >>> a[1]
    20
    >>> a[1, ]
    20
    >>> a[(1, )]
    20

    Bir NumPy dizisini dolaşılabilir bir nesneyle indekslediğimizde elde edilen dizi bir view belirtmemektedir. Örneğin:

    >>> a = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])
    >>> a
    array([ 10,  20,  30,  40,  50,  60,  70,  80,  90, 100])
    >>> b = a[[1, 3, 5]]
    >>> print(b.base)
    None
    >>> c = a[[1, 2, 3]]
    >>> print(c.base)
    None
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])

b = a[(2, 5, 3, 1),]
print(b)                # [30 60 40 20]

#------------------------------------------------------------------------------------------------------------------------------------
                                            45. Ders 30/08/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Çok boyutlu dizilerde de her boyut için dolaşılabilir bir nesne ile indeks belirtilebilir. Bu durumda indekslerdeki dolaşılabilir 
    nesnelerin elemanlarının eşit uzunlukta olması gerekir. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> b = a[[0, 2], [1, 2]]
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> b
    array([2, 9])

    Burada dilimleme yapılmamaktadır. a[[0, 1], [1, 2]] ifadesini görenler sanki burada "0 ve 2 indeksli satırların, 1 ve 2 indeksli sütunların
    seçildiğini" sanabilmektedir. Halbuki burada aslında a[0, 1] ve a[2, 2] elemanları seçilmiştir. Örneğin:

    >>> a = np.random.randint(0, 100, (10, 10))
    >>> a
    array([[90, 43, 86, 40, 96, 68, 75, 36, 63, 30],
        [85,  8, 59, 43, 43, 60,  2, 21, 80, 50],
        [49, 71, 58, 54, 60, 94, 49, 58, 73, 27],
        [95, 95, 31, 67,  5, 42, 14, 71, 66, 57],
        [17, 37, 50, 44, 35, 88,  3,  7, 53, 66],
        [84, 50, 41, 18,  8, 50, 93, 99, 49, 47],
        [18, 62, 29, 44, 23, 80, 35, 98, 26, 59],
        [59, 44, 20, 75, 19, 93, 80, 54, 75, 10],
        [21, 24, 77, 66, 28, 40, 61, 52, 80, 78],
        [56, 66, 68, 98, 45, 56, 39, 16, 62, 93]])
    >>> a[[3, 6, 8, 2], [1, 7, 4, 6]]
    array([95, 98, 28, 49])

    Burada [3, 1], [6, 7], [8, 4], [2, 6] elemanları seçilmiştir.

    İndeksleme sırasında bir indeks dolaşılabilir nesneyse diğer indeksler dilimleme yoluyla da belirtilebilir. Örneğin:

    >>> a[[3, 6, 8, 2], :]
    array([[95, 95, 31, 67,  5, 42, 14, 71, 66, 57],
        [18, 62, 29, 44, 23, 80, 35, 98, 26, 59],
        [21, 24, 77, 66, 28, 40, 61, 52, 80, 78],
        [49, 71, 58, 54, 60, 94, 49, 58, 73, 27]])
    >>> a[[3, 6, 8, 2], 2:5]
    array([[31, 67,  5],
        [29, 44, 23],
        [77, 66, 28],
        [58, 54, 60]])

    Dilimlemede dilimleme sonucunda elde edilen elemanlar herhangi bir sayıda olabilir. Örneğin:

    >>> import numpy as np
    >>> a = np.arange(100).reshape((10, 10))
    >>> a
    array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14, 15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
        [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],
        [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
        [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],
        [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],
        [70, 71, 72, 73, 74, 75, 76, 77, 78, 79],
        [80, 81, 82, 83, 84, 85, 86, 87, 88, 89],
        [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]])

    >>> a[[3, 5, 1, 6], 2:5]
    array([[32, 33, 34],
        [52, 53, 54],
        [12, 13, 14],
        [62, 63, 64]])

    Burada 5, 5, 1 ve 6 satırlarının 2, 3, ve 4'üncü sütunları elde edilmiştir. 

    Boyutların hepsinde dolaşılabilir nesne ya da dilimleme yapılması zorunlu değildir. Boyutlarda tek bir sayı da belirtilebilir. Örneğin:

    >>> a[[3, 6, 8, 2], 2]
    array([31, 29, 77, 58])

    Yukarıda da belirttiğimiz gibi birden fazla indekste dolaşılabilir nesne kullanılacaksa bunların eleman sayısının aynı olması 
    gerekmektedir. Örneğin:

    >>> a[[3, 6, 8, 2], [2, 5]]
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    IndexError: shape mismatch: indexing arrays could not be broadcast together with shapes (4,) (2,)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.arange(100).reshape(10, 10)

print(a)
             
b = a[[1, 2, 4], [1, 4, 6]]         # a[1, 1], a[2, 4], a[4, 6]
print(b)

b = a[[1, 2, 4], 5]                 # a[1, 5], a[2, 5], a[4, 5]
print(b)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisine bool indeksleme uygulanabilir. bool indeksleme için dizi uzunluğu ve boyutu kadar bool türden dolaşılabilir 
    bir nesne kullanılır. Bu dolaşılabilir nesnedeki True olan elemanlara karşı gelen dizi elemanları elde edilmektedir. Örneğin:

    array([ 10,  20,  30,  40,  50,  60,  70,  80,  90, 100])
    >>> a[[True, False, True, True, False, True, True, False, True, True]]
    array([ 10,  30,  40,  60,  70,  90, 100])

    Tabii çok boyutlu NumPy dizilerinde de benzer biçimde bool indeksleme yapılabilmektedir. Bu durumda her boyut için ayrı bir dolaşılabilir 
    bool nesne verilir. Elde edilecek değerler Bu bool nesnelerdeki True olan boyutların kesişimlerindeki değerler olacaktır. 
    Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> a[[True, False, True], [False, True, True]]
    array([2, 9])

    Buradaki seçim mantığı şöyledir: Önce True olan satır ve sütunların yerine onların indeks numaraları yerleştirilir. Sonra daha önce
    gördüğümüz gibi sanki birden fazla boyutta dolaşılabilir nesnede indeks varmış gibi işlem yapılır. Örneğin:

    a[[True, False, True], [False, True, True]]

    Bu işlemin eşdeğeri şöyledir:

    a[[0, 2], [1, 2]]

    Bu da a[0, 2] ve a[2, 2] elemanları anlamına gelmektedir. Tabii bu biçimdeki indekslemede boyutlardaki True elemanlarının sayısının 
    aynı olması gerekir. Örneğin:

    a[[True, True, False], [False, True, True]]

    Bu indekslemenin eşdeğeri şöyledir:

    a[[0, 1], [1, 2]]

    Bu da şu dizinin elde edilmesine yol açacaktır:

    array([2, 6])

    Çok boyutlu NumPy dizileri aynı boyuttaki bool türden NumPy dizileri ile indekslenebilmektedir. Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3))
    >>> a
    array([[47, 88, 61],
        [13, 54, 89],
        [33, 33, 16]])
    >>> b = np.array([[True, False, True], [True, True, False], [False, False, True]])
    >>> a[b]
    array([47, 61, 13, 54, 16])

    Ancak çok boyutlu NumPy dizileri bool türden liste listeleriyle (yani iki boyutlu listelerle) indekslenememektedir. Örneğin:

    >>> b = [[True, False, True], [True, True, False], [False, False, True]]
    >>> a[b]
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    IndexError: too many indices for array: array is 2-dimensional, but 3 were indexed

    Çok boyutlu NumPy dizilerine bool indeksleme uyguldadınızda elde edilen ürünün tek boyutlu olduğuna dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bool indeksleme filtreleme yapmak için çokça kullanılmaktadır. Anımsanacağı gibi bir NumPy dizisi skaler işlemlere sokulduğunda 
    aslında dizinin her elemanı işleme sokulmaktadır. a bir NumPy dizisi olmak üzere biz a > 40 gibi bir işlem yaparsak burada dizinin 
    her elemanı 40'tan büyük mü diye kontrol yapılacak ve dizi uzunluğu kadar uzunlukta bool türden bir NumPy dizisi elde edilecektir. 
    Örneğin:

    >>> a = np.array([32, 45, 12, 67, 18, 41, 92, 9, 12])
    >>> a
    array([32, 45, 12, 67, 18, 41, 92,  9, 12])
    >>> a > 40
    array([False,  True, False,  True, False,  True,  True, False, False])

    İşte bu tür karşılaştırma operatörlerinden elde edilen diziler bool indekslemede kullanılırsa "belli koşulu sağlayan elemanlar" 
    filtrelenebilir. Örneğin:

    >>> a[a > 40]
    array([45, 67, 41, 92])
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([3, 5, 34, 12, 9, 37, 32, 10])

result = a > 15
print(result)           # [False False  True False False  True  True False]

b = a[result]           
print(b)                # [34 37 32]

b = a[a > 15]           # a dizisi içerisindeki 15'ten büyük olan değerler elde ediliyor
print(b)                # [34 37 32]

#------------------------------------------------------------------------------------------------------------------------------------
    Örneğin bir NumPy dizisinin ortalamadan küçük elemanlarını a[a > np.mean(a)] ifadesi ile elde edebiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([3, 5, 34, 12, 9, 37, 32, 10])

print(np.mean(a))

result = a[a < np.mean(a)]
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Örneğin bir NumPy dizisinin çift elemanlarını da aynı biçimde elde edebiliriz.
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([3, 5, 34, 12, 9, 37, 32, 10])

print(np.mean(a))

result = a[a % 2 == 0]
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Köşeli parantez içerisindeki "... (ellipsis)" sentaksı "ondan önceki ve sonraki eksenlerin hepsi dahil edilecek" anlamına 
    gelmektedir. Örneğin a dizisinin 4 boyutlu olduğunu düşünelim. a[k, ...] ifadesi tamamen a[k, :, :, :] ile eşdeğerdir. Örneğin 
    a[1, ..., 3] ifadesi ise a[1, :, : 3] ile eşdeğerdir. a[1, 2, ..., 5] ifadesi a[1, 2, :, 5] ile eşdeğerdir. Ancak ellipsis köşeli 
    parantez içerisinde yalnızca bir kez kullanılabilir. Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3, 3))
    >>> a
    array([[[57, 31, 50],
            [12, 82, 96],
            [83,  5, 48]],

        [[92, 50, 83],
            [28, 62, 20],
            [28, 97, 38]],

        [[78, 91, 48],
            [76,  9, 54],
            [43, 59, 76]]])
    >>> b = a[..., 2]
    >>> b
    array([[50, 96, 48],
        [83, 20, 38],
        [48, 54, 76]])
    >>> b = a[:, :, 2]
    >>> b
    array([[50, 96, 48],
        [83, 20, 38],
        [48, 54, 76]])
    >>> b = a[2, ...]
    >>> b
    array([[78, 91, 48],
        [76,  9, 54],
        [43, 59, 76]])
    >>> b = a[2, :, :]
    >>> b
    array([[78, 91, 48],
        [76,  9, 54],
        [43, 59, 76]])

#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.arange(27).reshape(3, 3, 3)

print(a)
print('----------------')

b = a[1, ...]       # eşdeğeri a[1, :, :]
print(b)

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında NumPy'da yukarıda ele almadığımız değişik dtype türleri de vardır. Ancak bu konunun ayrıntılarına burada girmeyeceğiz.
    Değişik türler array fonksiyonunda hiç dtype belirtilmeden bir araya getirilirse array fonksiyonu eğer mümkünse bunların hepsini 
    yazıya dönüştürüp sanki birer yazı gibi saklamaktadır. Örneğin:

    >>> a = np.array([1, 'ankara', True])
    >>> a
    array(['1', 'ankara', 'True'], dtype='<U11')

    Burada "<U11" dtype türü "Unicode UTF-16 karakterlerindenden oluşan her bir eleman için 11 karakter yer ayrılmış olan" bir dtype 
    türünü temsil etmektedir. Buradaki '<' karakteri "little endian" anlamına gelmektedir. 

    Bir NumPy dizisinin her elemanı bir Python nesnesinin adresini de tutabilir. Bu aslında bir çeşit Python listesi gibi bir durum 
    oluşturur. Bunun için dtype türü object olarak belirtilir. Bu object türü bir yazı olarak ya da doğrudan Python'daki object sınıf 
    ismi olarak kullanılabilir. (Ancak np.object biçiminde belirleme eskiden kullanılıyordu sonradan "deprecated" yapıldı. Artık Python'daki 
    object ismi kullanılmaktadır.) Örneğin:

    >>> a = np.array([12, 34.5, 'ankara'], dtype=object)
    >>> a
    array([12, 34.5, 'ankara'], dtype=object)
    >>> type(a[0])
    <class 'int'>
    >>> type(a[1])
    <class 'float'>
    >>> type(a[2])
    <class 'str'>
#------------------------------------------------------------------------------------------------------------------------------------

a = np.array([[1, 2, 'Erkek'], [4, 5, 'Kadın'], [3, 6, 'Erkek'], [5, 8, 'Kadın']], dtype=object)
print(a, a.dtype)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisini transpoze etmek için ndarray sınıfının transpose isimli metodu ya da transpose fonksiyonu kullanılmaktadır. 
    Aynı zamanda ndarray nesnesinin T isimli öniteliği de transpose matrisini bize vermektedir. Yani a isimli NumPy dizisinin 
    transpose  matrisi aşağıdaki gibi üç biçimde elde edilebilir:

    b = a.transpose()
    b = np.transpose(a)
    b = a.T

    Transpoze işlemi her zaman bir view nesnesi oluşturularak yapılmaktadır. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> b = a.transpose()
    >>> b
    array([[1, 4, 7],
        [2, 5, 8],
        [3, 6, 9]])
    >>> b.base
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> c = np.transpose(a)
    >>> c
    array([[1, 4, 7],
        [2, 5, 8],
        [3, 6, 9]])
    >>> c.base
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> d = a.T
    >>> d
    array([[1, 4, 7],
        [2, 5, 8],
        [3, 6, 9]])
    >>> d.base
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Çok boyutlu dizilerin transpoze edilmeleri eksen temelinde yapılmaktadır. Yani hangi boyutların hangi boyutlarla transpoze edileceği 
    ayrı ayrı belirtilebilmektedir. Örneğin a üç boyutlu bir NumPy dizisi olsun. a.transpose([1, 2, 0]) işlemi ile eski 1'inci eksen 
    artık 0'ıncı eksen eski 1'inci eksen artık 1'inci eksen ve eski 0'ıncı eksen artık 2'inci eksen olur. Yani transpoze işlemi sırasındaki 
    taşıma şöyle yapılır:

    a[i, j, k] --> a[J, k, i]

    Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3, 3))
    >>> a
    array([[[51, 90, 29],
            [ 7, 20, 73],
            [33, 89, 21]],

        [[12, 41, 70],
            [29, 35, 13],
            [92, 26, 61]],

        [[21, 82, 33],
            [ 3,  3, 44],
            [22, 42, 37]]])
    >>> a.transpose([1, 2, 0])
    array([[[51, 12, 21],
            [90, 41, 82],
            [29, 70, 33]],

        [[ 7, 29,  3],
            [20, 35,  3],
            [73, 13, 44]],

        [[33, 92, 22],
            [89, 26, 42],
            [21, 61, 37]]])
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2], [4, 5], [7, 8]], dtype='float32')
print(a, a.shape, end='\n\n')

b = np.transpose(a)

print(b, b.shape, end='\n\n')
print(b.base is None)       # False

#------------------------------------------------------------------------------------------------------------------------------------
    İki NumPy dizisi üzerinde toplama, çarpma, çıkarma, bölme ya da karşılaştırma gibi işlemler yapıldığında aslında ndarray sınıfının 
    operatör metotları çağrılmaktadır. Bu operatör metotları da NumPy dizilerinin karşılıklı elemanları üzerinde işlemler yapmaktadır. 
    Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> b = np.array([[3, 1, 4], [1, 5, 9], [2, 6, 5]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> b
    array([[3, 1, 4],
        [1, 5, 9],
        [2, 6, 5]])
    >>> c = a * b
    >>> c
    array([[ 3,  2, 12],
        [ 4, 25, 54],
        [14, 48, 45]])
    >>> d = a + b
    >>> d
    array([[ 4,  3,  7],
        [ 5, 10, 15],
        [ 9, 14, 14]])
        
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype='float32')
b = np.array([[2, 1, 4], [1, 3, 5], [1, 1, 2]], dtype='float32')

c = a + b
print(c)

c = a * b
print(c)

c = a / b
print(c)

c = a - b
print(c)

#------------------------------------------------------------------------------------------------------------------------------------
    İki NumPy dizisinin işleme sokulabilmesi için bunların boyutlarının aynı olması gerekir. Ancak boyutları aynı olmayan NumPy dizileri 
    eksen temelinde de işlemlere sokulabilmektedir. Bu tür işlemlere İngilizce "broadcasting" denilmektedir. Örneğin 3 elemanlı bir NumPy 
    dizisi 3x3'lük bir numpy dizisi ile işleme sokulabilir. Bu durumda aslında 3 elemanlık dizi bu 3x3'lük matrisin her satırı ile işleme 
    sokulacaktır. İşte bu duruma "broadcasting" denilmektedir. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> b = np.array([1, 3, 5])
    >>> c = b + a
    >>> c
    array([[ 2,  5,  8],
        [ 5,  8, 11],
        [ 8, 11, 14]])

    Broadcasting sütun temelinde de yapılabilmektedir. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> b = np.array([[1], [3], [5]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> b
    array([[1],
        [3],
        [5]])
    >>> c = b + a
    >>> c
    array([[ 2,  3,  4],
        [ 7,  8,  9],
        [12, 13, 14]])

    Tabii * ve / operatörlerinin bu bağlamda değişme özellikleri vardır. Yani yukarıdaki örneklerde operand'ları yer değiştirdiğimizde de
    aynı sonuçları buluruz. 

    a ve b dizilerine broadcasting ile işlemlere sokalım. Burada a dizisi n boyutlu k dizisi de k < n olmak üzere k boyutlu olsun. 
    a dizisinin son k tane boyutunun b dizisinin k tane boyutuyla aynı olması gerekir. Bu durumda bu durumda broadcasting a dizisinin 
    ilk n - k boyurunun b diziisyle işleme sokulması biçiminde gerçekleşmektedir. Örneğin a dizisi 5x3x2 boyutunda b dizisi de 3x2 
    boyutunda olsun. Bu durumda a disizinin ilk boyutuna ilişkin 5 dizi b ile işleme sokulacaktıri. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([1, 2, 3])
b = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype='float32')

c = a + b
print(c, end='\n\n')

c = a * b
print(c)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir skaler bir NumPy dizisi ile işleme sokulabilir. Bu da bir çeşit "broadcasting" işlemidir. Bu durumda skaler NumPy dizisinin 
    her elemanıyla işleme sokulmuş olur. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> b = 2 * a
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> b
    array([[ 2,  4,  6],
        [ 8, 10, 12],
        [14, 16, 18]])
    >>> b = a * 2
    >>> b
    array([[ 2,  4,  6],
        [ 8, 10, 12],
        [14, 16, 18]])

#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype='float32')

c = 3 * a
print(c, end='\n\n')

#------------------------------------------------------------------------------------------------------------------------------------
    İki NumPy dizisinin çarpılmasının bir matris çarpımı olmadığına dikkat ediniz. Bu durumda iki dizinin karşılıklı elemanları 
    birbirleriyle çarpılmaktadır. Eğer gerçekten matris çarpımının yapılması isteniyorsa matmul isimli fonksiyon ya da @ operatörü 
    kullanılmalıdır. @  operatörü Python'a 3.5 versiyonuyla eklenmiştir. Bu operatör aslında sınıfın __matmul__ metodunu çağırmaktadır. 
    Yani a @ b işlemi ile a.__matmul__(b) işlemi eşdeğerdir. Bilindiği gibi iki matris çarpılabilmesi için soldaki matris sütun sayısının
    sağdaki matrisin satır sayısına eşit olması gerekir. Matris çarpımının sonucunda elde edilen matris soldaki matrisin satır sayısı 
    ve sağdaki matrisin sütun sayısı boyutunda olur. Yani örneğin mxn boyutlu bir matiris ile nxk boyutlu bir matris çarpılabilir. 
    Çarpım sonucunda mxk boyutunda bir matris elde edilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2, 1], [3, 1, 2], [1, 3, 2]])
b = np.array([[3, 2, 1], [1, 1, 1], [1, 2, 3]])
             
c = np.matmul(a, b)
print(c)

c = a @ b
print(c)

#------------------------------------------------------------------------------------------------------------------------------------
    Matris çarpımını andıran ismine "dot product" denilen bir işlem de vardır. Dot product iki dizinin karşılıklı elemanlarının 
    çarpılarak toplanması anlamına gelmektedir. Dot product işlemi dot isimli fonksiyonla ya da ndarray sınıfının  dot metoduyla yapılabilmektedir. Örneğin:

    >>> a = np.array([1, 2, 3, 4, 5])
    >>> b = np.array([3, 2, 4, 1, 2])
    >>> c = np.dot(a, b)
    >>> c
    33
    >>> c = a.dot(b)
    >>> c
    33

    Eğer diziler iki boyutlu ise dot product işlemi matris çarpımı gibi yapılmaktadır. Dot product işlemi özellikle "yapay sinir 
    ağlarında" yaygın kullanılan bir işlemdir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy kütüphanesi veri bilimi, istatikl ve makine öğrenmesi alanlarında sıkça kullanılmaktadır. İstatistikte bir varlığa (entity)
    ilişkin özellikler birbirinden farklı olabilmektedir. Örneğin bir kişinin boy uzunluğu, kilosu, yaşı farklı türden niceliklerdir. 
    İşte varlıklara ilişkin onların farklı özelliklerinin oluşturduğu topluluğa "veri kümesi (data set)" ya da "veri tablosu (data table)" 
    denilmektedir. Veri kümeleri ya da veri tabloları daha önce görmüş olduğumuz veritabanı tablolarına oldukça benzemektedir. 
    
    Bir veri kümesindeki satırlara genellikle "satır (row)" denir. Sütunlara ise "sütun (column) ya da daha sıklıkla "özellik (feature)" 
    denilmektedir. Örneğin kişilerin boy uzunluklarından, kilolarından ve yaşlarından oluşan aşağıdaki gibi bir veri kümesi bulunyor 
    olsun:
    
    Boy     Kilo    Yaş
    182     90      42
    178     82      34
    168     71      37
    ...     ...     ...

    Burada "Boy", "Kilo" ve "Yaş" sütunları bu veri kümesinin özelliklerini oluşturmaktadır. 

    İstatistikteki veri kümeleri NumPy'da iki boyutlu NumPy dizileriyle temsil edilmektedir. Bu tür veri kümelerinde sütun temelinde 
    ya da satır temelinde istatistiksel işlemlerin yapılması istenebilmektedir. Örneğin yukarıdaki veri kümesinde biz kişilerin boy 
    ortalamalarını, kilo ortalamalarını ve yaş ortalamalarını bulmak isteyebiliriz. Bunun için sütun temelinde işlemlerin yapılması 
    gerekmektedir. İşte bir matirisin satırları üzerinde ya da sütunları üzerinde işlemler yapmaya "eksenli işlemler" denilmektedir. 
    NumPy'da pek çok fonksiyonun ve metodun "axis" isimli eksen belirten bir parametresi vardır. Bu axis parametresi işlemlerin satır 
    temelinde mi sütun temelinde mi yapılacağını belirtir. Tabii aslında NumPy dizileri üç boyutlu ya da daha fazla boyutlu da olabilir. 
    Bu durumda eksen işlemleri diğer boyutlara göre de yapılabilir. Ancak uygulamada genellikle iki boyutlu NumPy dizileri üzerinde işlemler 
    yoğun bir biçimde yapılmaktadır. 
    
    
    Yukarıda pek çok NumPy fonksiyonunun bir axis parametresi olduğunu belirtmiştik. Örneğin sum isimli fonksiyonun parametrik sayısı 
    şöyledir:

    numpy.sum(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)

    Görüldüğü gibi fonksiyonun bir axis parametresi vardır. 
    
    Eğer fonksiyonlar ve metotlarda axis parametresi girilmezse (yani default bırakılırsa) fonksiynlar ve metotlar genellikle tüm 
    elemanları işleme sokmaktadır. Örneğin:

    >>> dataset = np.array([[182, 90, 42], [178, 82, 34], [168, 71, 27]])
    >>> dataset
    array([[182,  90,  42],
        [178,  82,  34],
        [168,  71,  27]])
    >>> np.sum(dataset)
    874

    Burada axis belirtilmediği için matrisin tüm elemanlarının toplamı elde edilmiştir. Pekiyi axis paramtresi nasıl girilmelidir?
    axis parametresine 0'dan itibaren dizinin boyut sayısından 1 eksiğine kadar tamsayılar girilebilir. Örneğin iki boyutlu bir NumPy 
    dizisi için axis parametresine 0 ya da 1 girebiliriz. Üç boyutlu bir NumPy dizisi için axis parametresine 0, 1 ya da 2 girebiliriz. 
    Axis numaralandırması indekslemedeki sıraya göre yapılmaktadır. Örneğin iki boyutlu a isimli bir NumPy dizisi olsun. Bu dizinin bir 
    elemanına biz a[i, k] biçiminde erişiriz. İşte bu 02ıncı indeksle (i indeksi) belirtilen eksen 0'ıncı eksen, birinci indeksle belirtilen 
    eksen ise (k indeksi) 1'inci eksendir. Eğer a dizisi üç boyutlu olsaydı biz dizinin bir elemanına a[i, k, j] biçiminde erişirdik. 
    Bu durumda ilk index 0'ıncı eksene, ikinci indeks 1'inci eksene ve üçüncü indeks 2'inci eksene ilişkin olurdu.

    İşte eksensel işlemler yaparken işlemlerde hangi eksen değiştilerek işlem gerçekleşiyorsa axis parametresi o ekseni belirtiecek biçimde 
    verilmelidir. Aşağıdaki veri tablosuna bir daha bakınız:

    Boy     Kilo    Yaş
    182     90      42
    178     82      34
    168     71      37
    ...     ...     ...

    Biz burada sütunsal ortalamaları bulmak istiyorsak bunun için satır indekslerini değiştiririz. Yani a[i, k] erişimlerinde k'yı 
    sabit tutarsak i'leri değiştirerek sütunların ortalamalarını elde ederiz. O halde burada sütunsal işlemler için axis parametresi 
    axis=0 biçiminde girilmelldir. Eğer biz satırsal ortalamalrı bulmak isteseydik a[i, k] erişimlerinde k'ları değiştirmemiz gerekirdi. 
    Çünkü a[i, k] erişimlerinde i sabit olmak üzere biz k indeksini değiştirerek satırların sütunlarını elde ederiz. Bu nedenle atırsal 
    işlemler için axis parametresini axis=1 biçiminde kullanmamız gerekir. Yani işlemde hangi eksende değişiklik yapılarak işlem 
    yürütülecekse axis parametresi o ekseni belirtecek biçimde girilmelidir. 

    Bir NumPy dizisine satır ya da sütun eklemek, bir NumPy dizisinden satır ya da sütun silmek söz konusu olduğunda eksen parametresi 
    değişikliğin etki edeceği boyut biçiminde girilmelidir. Örneğin amacımız iki boyutlu bir NumPy dizisine satır eklemek ya da ondan 
    satır silmek olsun. Bu durumda bu işlemden satır sayısı yani 0'ıncı eksen etkilenecektir. O halde bizim ilgili fonksiyonu axis=0
    parametresi ile çağırmamız gerekir. Ancak iki boyutlu NumPy dizisine bir sütun ekleyecek ya ondan bir sütun silecek olsaydık bu 
    durumda axis parametresini axis=1 biçiminde girmemiz gerekirdi. 

    Yukarıdaki durum NumPy'a yeni başlayanlarda bir kafa karışıklığı oluşturabilmektedir. Biz iki boyutlu diziler axis işlemlerinin 
    özetini şöyle ifade edebiliriz:

    - İki boyutlu dizilerde sütunsal işlemler için axis=0, satırsal işlemler için axis=1 girilmelidir. 
    - İki boyutlu dizilerde satır ekleme ve silme işlemlerinde axis=0, sütun ekleme ve silme işlemlerinde axis=1 girilmelidir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi N boyutlu bir NumPy dizisinde indeksleme yapılırken girilen değerler sırasıyla axis numaralarını 
    vemektedir. Örneğin üç boyutlu bir a dizisinde belli bir indekse a[i, k, n] gibi üç indeksle erişiriz. Buradaki i indeksiyle 
    belirttiğimiz ilk boyut axis = 0'dır. k indeksi ile belirttiğimiz ikinci boyut axis=1'dir. Nihayet n indeksiyle belirttiğimiz 
    üçüncü boyut ise axis=2'dir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi eksensel işlemler yapan bazı fonksiyonlara ve metotlara değinelim:

    - sum fonksiyonu ve ndarray sınıfınıun sum metodu eksensel toplama işlemi yapmaktadır. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> result = np.sum(a, axis=1)
    >>> result
    array([ 6, 15, 24])
    >>> result = np.sum(a, axis=0)
    >>> result
    array([12, 15, 18])
    >>> result = np.sum(a)
    >>> result
    45
    >>> result = a.sum(axis=1)
    >>> result
    array([ 6, 15, 24])
    >>> result = a.sum(axis=0)
    >>> result
    array([12, 15, 18])
        
    - mean isimli fonksiyon ve ndarray sınıfının mean metodu eksen temelinde aritmetik ortalama işlemi yapmaktadır. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> result = np.mean(a, axis=0)
    >>> result
    array([4., 5., 6.])
    >>> result = a.mean(axis=0)
    >>> result
    array([4., 5., 6.])

    - Median işlemi median fonksiyonu ile yapılmaktadır. (ndarray sınıfının böyle bir metodu yoktur.) Eğer değerler çift ise ortadaki 
    iki değerin aritmetik ortalaması median olarak elde edilmektedir. Örneğin:

    >>> a = np.random.randint(0, 100, (10, 10))
    >>> a
    array([[58, 14, 13, 19, 76, 50, 78, 82, 63, 77],
        [77, 11, 28, 32, 65, 74,  4, 54, 53, 79],
        [32, 23, 91, 89, 12, 71, 31, 46, 69, 30],
        [94, 50,  8, 76, 28, 32, 63, 76, 97, 74],
        [97, 58, 36, 56,  5,  7, 47, 15, 16, 95],
        [29, 25, 83, 72, 31, 17, 90, 34, 57, 37],
        [18, 92, 98, 92, 62, 97, 94, 69, 12, 38],
        [54, 49, 54, 41, 18, 91, 65, 70, 49, 42],
        [51, 27, 95, 55, 74, 52, 85, 95, 15, 24],
        [90, 28, 42, 33, 89,  2, 58, 54, 53,  7]])
    >>> result = np.median(a, axis=0)
    >>> result
    array([56. , 27.5, 48. , 55.5, 46.5, 51. , 64. , 61.5, 53. , 40. ])

    - Standart sapma hesabı için std isimli fonksiyon ya da ndarray sınıfının std metodu, varyans hesabı için var isimli fonksiyon ya da ndarray 
    sınıfının var metodu kullanılmaktadır. Burada default olarak bölüm n değerine yapılır. Bu fonksiyonların ve metotların ddof parametreleri 
    bölümün "n - ddof" olarak yapılmasını sağlamaktadır. Bu metotlarda ve fonksiyonlarda ddof için default değer 0'dır. Eğer n-1'e bölme 
    yapılmak isteniyorsa ddof=1 girilmelidir. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> result = np.std(a, axis=0)
    >>> result
    array([2.44948974, 2.44948974, 2.44948974])

    >>> result = np.var(a, axis=0)
    >>> result
    array([6., 6., 6.])
    >>> result = a.std(axis=0)
    >>> result
    array([2.44948974, 2.44948974, 2.44948974])
    >>> result = a.var(axis=0)
    >>> result
    array([6., 6., 6.])

    - max ve min fonksiyonları ve ndarray sınıfının min ve nax metotları eksensel en büyük ve en küçük değerleri bulmaktadır. Örneğin:

    >>> a = np.array([[1, 6, 3], [4, 8, 2], [1, 2, 9]])
    >>> a
    array([[1, 6, 3],
        [4, 8, 2],
        [1, 2, 9]])
    >>> result = np.max(a, axis=0)
    >>> result
    array([4, 8, 9])
    >>> result = np.max(a, axis=1)
    >>> result
    array([6, 8, 9])
    >>> result = np.max(a)
    >>> result
    9
    >>> result = a.max(axis=0)
    >>> result
    array([4, 8, 9])
    >>> result = a.min(axis=0)
    >>> result
    array([1, 2, 2])

    Ayrıca NumPy'da bir de maximum ve minimum isimli iki fonksiyon vardır. (ndarray sınıfının maximum ve minimum isimli metotları 
    yoktur.) Ancak bu fonksiyonlar karşılık ikş ya da fazla değerin ya da karşılıklı iki ya da daha fazla NumPy dizisinin maksimum 
    ve minimum elemanlarını bulmaktadır. Bu fonksiyonların axis parametreleri yoktur. Örneğin:

    >>> result = np.maximum(10, 5)
    >>> result
    10
    >>> result = np.maximum([1, 3, 7], [2, 1, 9])
    >>> result
    array([2, 3, 9])

    - arxmax ve argmin fonksiyonları ve ndarray sınıfının argmax ve argmin metotları eksen temelinde en büyük ve en küçük elemanları 
    değil onların indekslerini vermektedir. Bu işlem özellikle makine öğrenmesinde yaygın biçimde kullanılmaktadır. Örneğin:

    >>> a = np.array([[1, 9, 3], [8, 7, 1], [6, 4, 5]])
    >>> a
    array([[1, 9, 3],
        [8, 7, 1],
        [6, 4, 5]])
    >>> result = np.argmax(a, axis=0)
    >>> result
    array([1, 0, 2], dtype=int64)
    >>> result = a.argmax(axis=0)
    >>> result
    array([1, 0, 2], dtype=int64)
    >>> result = a.argmin(axis=0)
    >>> result
    array([0, 2, 1], dtype=int64)

    -  prod fonksiyonu  ve ndarray sınıfının prod metodu eksen temelinde çarpım değerlerini elde etmek için kullanılmaktadır. 
    Örneğin:

    >>> a = np.array([[1, 9, 3], [8, 7, 1], [6, 4, 5]])
    >>> a
    array([[1, 9, 3],
        [8, 7, 1],
        [6, 4, 5]])  
    >>> result = np.prod(a, axis=0)
    >>> result
    array([ 48, 252,  15])
    >>> result = a.prod(axis=0)
    >>> result
    array([ 48, 252,  15])

    - cumsum isimli fonksiyon ve ndarray sınıfının metodu kümülatif toplamlardan oluşan numpy dizisi vermektedir. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> result = np.cumsum(a, axis=0)
    >>> result
    array([[ 1,  2,  3],
        [ 5,  7,  9],
        [12, 15, 18]])
    >>> result = a.cumsum(axis=0)
    >>> result
    array([[ 1,  2,  3],
        [ 5,  7,  9],
        [12, 15, 18]])

    -  sort fonksiyonu ve ndarray sınıfının sort metodu axis temelinde sıraya dizme işlemi yapar. Bu fonksiyonda axis için değer girilmezse 
    default olarak son eksen değeri alınır. sort fonksşyonu in-place işlem yapmamakta ancak sort metodu in-place işlem yapmaktadır. Örneğin:

    >>> a = np.random.randint(0, 100, (10, 10))
    >>> a
    array([[ 8,  7, 38,  8, 40, 78, 39, 19, 93, 21],
        [99, 23, 65, 80, 90, 90, 83, 61, 78, 44],
        [78, 48, 58, 28, 41, 12, 88,  8, 26, 70],
        [ 6, 31, 51, 71, 75, 14, 60, 81, 93, 50],
        [ 4, 92, 72, 89, 80, 94, 70, 16, 17, 90],
        [40, 27,  2, 10,  8, 29, 71, 34, 34, 92],
        [82, 97, 15, 90, 57, 42, 33, 91, 11, 20],
        [47, 10, 43, 95, 40, 67, 88, 68, 53, 44],
        [86, 17, 16, 18, 87, 75,  6, 49, 23, 31],
        [96, 37, 33, 13, 67,  7, 70,  0, 86, 13]])
    >>> result = np.sort(a, axis=0)
    >>> result
    array([[ 4,  7,  2,  8,  8,  7,  6,  0, 11, 13],
        [ 6, 10, 15, 10, 40, 12, 33,  8, 17, 20],
        [ 8, 17, 16, 13, 40, 14, 39, 16, 23, 21],
        [40, 23, 33, 18, 41, 29, 60, 19, 26, 31],
        [47, 27, 38, 28, 57, 42, 70, 34, 34, 44],
        [78, 31, 43, 71, 67, 67, 70, 49, 53, 44],
        [82, 37, 51, 80, 75, 75, 71, 61, 78, 50],
        [86, 48, 58, 89, 80, 78, 83, 68, 86, 70],
        [96, 92, 65, 90, 87, 90, 88, 81, 93, 90],
        [99, 97, 72, 95, 90, 94, 88, 91, 93, 92]])
    >>> result = np.sort(a)
    >>> result
    array([[ 7,  8,  8, 19, 21, 38, 39, 40, 78, 93],
        [23, 44, 61, 65, 78, 80, 83, 90, 90, 99],
        [ 8, 12, 26, 28, 41, 48, 58, 70, 78, 88],
        [ 6, 14, 31, 50, 51, 60, 71, 75, 81, 93],
        [ 4, 16, 17, 70, 72, 80, 89, 90, 92, 94],
        [ 2,  8, 10, 27, 29, 34, 34, 40, 71, 92],
        [11, 15, 20, 33, 42, 57, 82, 90, 91, 97],
        [10, 40, 43, 44, 47, 53, 67, 68, 88, 95],
        [ 6, 16, 17, 18, 23, 31, 49, 75, 86, 87],
        [ 0,  7, 13, 13, 33, 37, 67, 70, 86, 96]])
    
    - argsort fonksiyonu ve ndarray sınıfının argsort metodu dizinin kendisini değil indekslerini sıraya dizer ve sıraya 
    dizilmiş indeks dizisi ile geri döner. Yani hem fonksiyon hem de metot in-place işlem yapmamaktadır.Örneğin:

    >>> a = np.random.randint(0, 100, (10, 10))
    >>> a
    array([[52, 68, 19, 79, 88, 17, 58, 39, 48, 24],
        [89, 61, 50, 69, 50, 79, 53, 40,  4, 85],
        [23, 45, 43,  3, 97, 41, 62, 97, 20, 41],
        [40, 22, 94, 34, 60,  2, 25, 44,  0, 65],
        [29, 28, 23, 55, 31, 86, 89, 37, 31, 46],
        [37, 68, 55, 13, 32, 55,  4, 31, 24, 21],
        [80, 54, 59, 78, 50, 64, 51, 73, 28, 77],
        [43, 15, 99, 36, 36, 98, 79, 87, 21,  3],
        [23, 62, 93, 79, 94,  5, 16, 36, 20, 95],
        [ 4, 26, 92, 71, 66, 23, 11, 99, 66, 98]])
    >>> result = np.argsort(a, axis=0)
    >>> result
    array([[9, 7, 0, 2, 4, 3, 5, 5, 3, 7],
        [2, 3, 4, 5, 5, 8, 9, 8, 1, 5],
        [8, 9, 2, 3, 7, 0, 8, 4, 2, 0],
        [4, 4, 1, 7, 1, 9, 3, 0, 8, 2],
        [5, 2, 5, 4, 6, 2, 6, 1, 7, 4],
        [3, 6, 6, 1, 3, 5, 1, 3, 5, 3],
        [7, 1, 9, 9, 9, 6, 0, 6, 6, 6],
        [0, 8, 8, 6, 0, 1, 2, 7, 4, 1],
        [6, 0, 3, 0, 8, 4, 7, 2, 0, 8],
        [1, 5, 7, 8, 2, 7, 4, 9, 9, 9]], dtype=int64)
    >>> result = a.argsort(axis=0)
    >>> result
    array([[9, 7, 0, 2, 4, 3, 5, 5, 3, 7],
        [2, 3, 4, 5, 5, 8, 9, 8, 1, 5],
        [8, 9, 2, 3, 7, 0, 8, 4, 2, 0],
        [4, 4, 1, 7, 1, 9, 3, 0, 8, 2],
        [5, 2, 5, 4, 6, 2, 6, 1, 7, 4],
        [3, 6, 6, 1, 3, 5, 1, 3, 5, 3],
        [7, 1, 9, 9, 9, 6, 0, 6, 6, 6],
        [0, 8, 8, 6, 0, 1, 2, 7, 4, 1],
        [6, 0, 3, 0, 8, 4, 7, 2, 0, 8],
        [1, 5, 7, 8, 2, 7, 4, 9, 9, 9]], dtype=int64)

    NumPy kütüphanesinde çok fazla fonksiyon ve ndarray sınıfının metodu bulunmaktadır. NumPy dokümanlarından bunlara gerektiğinde 
    başvurabilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy kütüphanesinde bir NumPy dizisinin her elemanı üzerinde işlem yapan ancak axis parametresine sahip olmayan pek çok klasik 
    matematiksel fonksiyon ve ndarray sınıfının metodu da vardır. Bunlardan bazıları şunlardır: sqrt, square, power, log, log10, log2, 
    round, exp, sin, cos, tan, arcsin, arccos, arctan, lcm (okek), gcd (obeb). Örneğin karekök gibi, sin, cos gibi işlemler zaten 
    birdne değer üzerinde uygulanan işlemler değildir. Dolayısıyla bunların eksensel yapılması söz konusu olamaz. Örneğin:

    >>> a = np.random.random((5, 5))
    >>> a
    array([[0.7697629 , 0.94185538, 0.39760624, 0.89994749, 0.03884618],
        [0.95536686, 0.57196936, 0.1364953 , 0.63398182, 0.52060019],
        [0.46564122, 0.94068844, 0.20854218, 0.77252757, 0.62490003],
        [0.12142791, 0.8926136 , 0.62890967, 0.37622973, 0.71989936],
        [0.52172981, 0.20142574, 0.08345288, 0.24866786, 0.04276729]])
    >>> result = np.sin(a)
    >>> result
    array([[0.695965  , 0.80865099, 0.38721243, 0.78329427, 0.03883641],
        [0.81652559, 0.54128901, 0.13607185, 0.5923575 , 0.4974009 ],
        [0.44899584, 0.80796394, 0.20703389, 0.69794758, 0.5850162 ],
        [0.12112973, 0.77871412, 0.58826339, 0.36741652, 0.659309  ],
        [0.49838056, 0.20006645, 0.08335605, 0.24611301, 0.04275425]])
    >>> result = np.power(a, 2)
    >>> result
    array([[0.59253492, 0.88709155, 0.15809072, 0.80990548, 0.00150903],
        [0.91272584, 0.32714895, 0.01863097, 0.40193295, 0.27102455],
        [0.21682174, 0.88489475, 0.04348984, 0.59679884, 0.39050004],
        [0.01474474, 0.79675904, 0.39552737, 0.14154881, 0.51825508],
        [0.272202  , 0.04057233, 0.00696438, 0.0618357 , 0.00182904]])
    >>> result = np.log(a)
    >>> result
    array([[-0.26167274, -0.05990354, -0.92229312, -0.10541887, -3.24814547],
        [-0.04565986, -0.55866985, -1.9914651 , -0.455735  , -0.65277293],
        [-0.76433986, -0.06114329, -1.56761393, -0.25808759, -0.4701636 ],
        [-2.1084345 , -0.11360149, -0.46376764, -0.97755534, -0.32864386],
        [-0.65060542, -1.60233452, -2.48347311, -1.39163717, -3.1519818 ]])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi Python operatörleri de NumPy dizilerine uygulandığında karşılıklı elemanlar üzerinde işlemler 
    yapar. Aslında bunların fonksiyon karşılıkları da vardır. Tabii bunlar da axis parametresi almamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[8, 2, 18], [11, 23, 5], [1, 4, 32]], dtype=np.float32)
b = np.array([[1, 3, 5], [1, 4, 3], [1, 4, 2]], dtype=np.float32)

c = a * b
print(c)

c = np.multiply(a, b)
print(c)

#------------------------------------------------------------------------------------------------------------------------------------
    where isimli fonksiyon tipik olarak bir bool dizi ve iki de dizi parametresi almaktadır. Bu bool dizinin uzunluğunun bu iki dizinin
    uzunluğu kadar olması gerekir. Bu fonksiyon eğer bool dizideki eleman True ise birinci dizideki elemanı, False ise ikinci dizideki 
    elemanı vermektedir. Örneğin:

    >>> a = np.array([3, 6, 3, 8, 9, 5, 8])
    >>> b = np.array([8, 4, 2, 7, 5, 6, 4])
    >>> a
    array([3, 6, 3, 8, 9, 5, 8])
    >>> b
    array([8, 4, 2, 7, 5, 6, 4])
    >>> result = np.where([True, False, True, True, False, True, False], a, b)
    >>> result
    array([3, 4, 3, 8, 5, 5, 4])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii aslında where fonksiyonun birinci parametresi genellikle koşul operatörü ile oluşturulmaktadır. where fonksiyonu çok boyutlu 
    dizilerde de benzer biçimde kullanılabilir. Örneğin:

    >>> a = np.array([3, 6, 3, 8, 9, 5, 8])
    >>> b = np.array([8, 4, 2, 7, 5, 6, 4])
    >>> a
    array([3, 6, 3, 8, 9, 5, 8])
    >>> b
    array([8, 4, 2, 7, 5, 6, 4])
     >>> result = np.where(a > 4, a, b)
    >>> result
    array([8, 6, 2, 8, 9, 5, 8])

    Burada eğer a dizisindeki eleman 4'ten büyük ise a dizisindeki eleman, değilse b dizisindeki eleman elde edilmiştir. 

    Aslında where fonksiyonunun parametreleri bir skaler de olabilir. Bu durumda koşulun sağlandığı ya da sağlanmadığı elemanlar 
    belli değerlerle doldurulmuş olur. Örneğin:

    >>> a = np.random.randint(0, 100, 10)
    >>> b = np.random.randint(0, 100, 10)
    >>> a
    array([12, 57, 78, 57, 35, 23, 31, 70, 27, 66])
    >>> b
    array([ 4,  7, 49, 44,  5, 55, 47, 15,  8, 76])
    >>> result = np.where(a > 50, a, -1)
    >>> result
    array([-1, 57, 78, 57, -1, -1, -1, 70, -1, 66])

    Burada a'daki 50'den büyük elemanlar için a'daki değer, 50'den küçük elemanlar için -1 değeri elde edilmektedir. 
        
    where fonksiyonu aslında parametresiz de kullanılabilmektedir. Bu durumda koşulu sağlayan dizi elemanlarının indeksleri 
    elde edilmektedir. Örneğin:

    >>> a = np.random.randint(0, 100, 10)
    >>> a
    array([56, 65, 62, 34, 69, 56,  9, 36, 50,  1])
    >>> result = np.where(a > 50)
    >>> result
    (array([0, 1, 2, 4, 5], dtype=int64),)

    Burada a dizisinde 50'dem büyük olan değerlerin indeksleri elde edilmiştir. Tabii biz NumPy dizilerini dolaşılabilir nesnelerle 
    indeksleyebildiğimize göre buran elde edilen result dizisiyle de indeksleyebiliri<. Örneğin:

    >>> a[result]
    array([56, 65, 62, 69, 56])

    where fonksiyonun bir metot karşılığı yoktur. Parametresiz where fonksiyonu nasıl yazılmış olabilir? En basit yazım yöntemi 
    dizi içerisindeki True olan değerlerin indesklerini elde etmektir. Örneğin:

    def mywhere(condition):
        return [index for index, val in enumerate(condition) if val]
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    clip fonksiyonu ve ndarray sınıfının clip metodu bizden bir NumPy dizisi ve min, max değerlerini almaktadır. Fonksiyon min 
    değerinden düşük olanları min değerine, max değerinden büyük olanları ise max değerine çekerek bize yeni bir NumPy dizisi verir. 
    min ve max arasındaki değerlere dokunmaz. Yani clip fonksiyonu ile elde edilen dizi kesinlikle [min, max] arası değerlere sahip 
    olacaktır. Örneğin:

    >>> a = np.random.randint(0, 10, 10)
    >>> a
    array([9, 7, 5, 4, 8, 3, 5, 0, 1, 1])
    >>> result = np.clip(a, 4, 7)
    >>> result
    array([7, 7, 5, 4, 7, 4, 5, 4, 4, 4])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy dizilerine satır ve sütun eklemek isteyebiliriz. Pek çok veri analizi uygulamasında bu tür işlemler gerekebilmektedir. Örneğin
    elimizdeki veri tablosunda kişilerin boy ve kiloları sütunlar halinde bulunuyor olabilir. Biz de bu boy ve kilo bilgisinden hareketle
    tabloya "vücut kitle endeksi (body mass index)" sütunu eklemek isteyebiliriz. Ya da örneğin veri tablosunda kişilerin isimleri de 
    olabilir. İsimlerin veri analizinde önemi olmadığı için bu isim sütununu silmek isteyebiliriz. 

    Ancak maalesef bu tür işlemler NumPy'da göreli olarak yavaştır. Çünkü bu tür işlemlerde çoğu durumda "view" oluşturulamamaktadır. 
    Dolayısıyla programcının bir döngü içerisinde bir NumPy dizisine sürekli satır eklemesi gibi işlemler (böyle şeyleri Python listeleri 
    üzerinde yapmıştık) iyi teknik kabul edilmemektedir. Bu tür durumlarda programcının mümkün olduğu kadar işin başında NumPy dizisinin 
    boyutlarını tespit etmeye çalışması ve diziyi işin başında bir kez zeros gibi bir fonksiyonla yaratması ve döngü içerisinde satır, 
    sütun eklemek yerine satır güncellemesi yapması uygundur. Tabii her zaman işin başında bir dizinin boyutlarını belirleme olasılığımız 
    olmayabilir. NumPy dizileri üzerinde "in-place" işlemler genellikle yapılamamaktadır. Bu nedenle genellikle bu tür işlemler dizinin 
    kendi üzerinde yapılmaz, işlem sonucunda bu işlemlerin yapılmış olduğu yeni bir dizi elde edilir.

    Daha önceden de belirttiğimiz gibi NumPy'da ekleme ve silme gibi işlemlerde axis paraetresi bu işlemin sonucunda değişikliğin 
    oluştuğu ekseni belirtmektedir. Örneğin biz iki boyutlu bir NumPy dizisine satır eklemek istersek burada satır bu dizinin ilk 
    boyutu üzerinde değişiklik yaratır. Bu nedenle satır ekleme işleminde axis=0 girilmelidir. Sütun eklemelerinde ise axis=1 olmalıdır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisine eksensel bir ekleme (örneğin satır, sütun eklemesi için) append fonksiyonu kullanılır. append her zaman NumPy 
    dizisinin yeni bir kopyasını oluşturur. Yani in-place işlem yapmaz. append fonksiyonunun birinci parametresi eklemenin yapılacağı 
    NumPy dizisini, ikinci parametresi eklenecek değerlerin bulunduğu NumPy dizisini belirtmektedir. append fonksiyonunda biz her zaman 
    ana diziyle aynı satır ya da sütun sayısına sahip bir dizi eklemeliyiz. Örneğin iki bir boyutlu bir diziye tek bir satır ekleyeceksek 
    bu satırın sanki tek satırlık bir matris gibi olması gerekir. Benzer biçimde iki boyutlu bir diziye tek bir sütun ekleyeceksek bu 
    sütunun sanki tek sütunlu bir matris biçiminde olması gerekir. Örneğin:

    >> a = np.random.randint(0, 100, (5, 5))
    >>> a
    array([[84, 39, 66, 84, 47],
        [61, 48,  7, 99, 92],
        [52, 97, 85, 94, 27],
        [34, 97, 76, 40,  3],
        [69, 64, 75, 34, 58]])
    >>> b = np.append(a, [[1], [2], [3], [4], [5]], axis=1)
    >>> b
    array([[84, 39, 66, 84, 47,  1],
        [61, 48,  7, 99, 92,  2],
        [52, 97, 85, 94, 27,  3],
        [34, 97, 76, 40,  3,  4],
        [69, 64, 75, 34, 58,  5]])
    >>> b = np.append(a, [[1, 2, 3, 4, 5]], axis=0)
    >>> b
    array([[84, 39, 66, 84, 47],
        [61, 48,  7, 99, 92],
        [52, 97, 85, 94, 27],
        [34, 97, 76, 40,  3],
        [69, 64, 75, 34, 58],
        [ 1,  2,  3,  4,  5]])

    Burada matrise sütun eklerken eklenecek sütunun bir sütun vektörü biçiminde satır eklerken eklenecek satırın bir satır vektörü 
    biçiminde verildiğine dikkat ediniz. Eklenecek NumPy dizisi orijinal dizi ile aynı boyutsal değerde olmalıdır. (Yani örneğin iki
    boyutlu bir NumPy dizisine iki boyutlu bir NumPy dizisi ekleyebiliriz.)

    Tek hamlede birden fazla satır ve sütun da eklenebilir. Örneğin:

    >>> a
    array([[84, 39, 66, 84, 47],
        [61, 48,  7, 99, 92],
        [52, 97, 85, 94, 27],
        [34, 97, 76, 40,  3],
        [69, 64, 75, 34, 58]])

    >>> b = np.append(a, np.array([[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]]), axis=1)
    >>> b
    array([[84, 39, 66, 84, 47,  1,  1],
        [61, 48,  7, 99, 92,  2,  2],
        [52, 97, 85, 94, 27,  3,  3],
        [34, 97, 76, 40,  3,  4,  4],
        [69, 64, 75, 34, 58,  5,  5]])

    Burada tek hemlede iki sütun eklenmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Mademki append bizden aynı boyutta bir dizi istemektedir. O zaman onu aynı boyuta getirmek için reshape işlemi yapabiliriz. 
    Örneğin:

  >>> a
    array([[84, 39, 66, 84, 47],
        [61, 48,  7, 99, 92],
        [52, 97, 85, 94, 27],
        [34, 97, 76, 40,  3],
        [69, 64, 75, 34, 58]])
    >>> b = np.append(a, np.array([1, 2, 3, 4, 5]).reshape(-1, 1), axis=1)
    >>> b
    array([[84, 39, 66, 84, 47,  1],
        [61, 48,  7, 99, 92,  2],
        [52, 97, 85, 94, 27,  3],
        [34, 97, 76, 40,  3,  4],
        [69, 64, 75, 34, 58,  5]])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    append işleminde eksen belirtilmezse (axis parametresinin default değeri None biçimindedir). Eklemenin yapılacağı dizi ve eklenecek 
    dizi önce flatten işlemiyle tek boyuta indirgenir. Sonra işlem yapılır. Bu işleme bazen seyrek de olsa gereksinim duyulmaktadır. 
    Bu durumda append yapılacak değerler herhangi bir boyutta girilebilir. Zaten bu değerler de flatten işlemine sokulmaktadır. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> b = np.array([10, 20, 30])
    >>> b
    array([10, 20, 30])
    >>> result = np.append(a, b)
    >>> result
    array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 20, 30])

    >>> b = np.array([[10], [20], [30]])
    >>> result = np.append(a, b)
    >>> result
    array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 20, 30])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında append fonksiyonun concatenate isminde daha genel bir biçimi de vardır. concatenate fonksiyonu birden fazla NumPy dizisini 
    bir dizi ya da demet olarak alır onları peşi dıra brirleştirir, birleştirilmiş diziyle geri döner. concatenate fonksiyonun da 
    axis parametresi vardır. eğer sütunsal ekleme yapılıyorsa dizilerin satır uzunluklarının, satırsal ekleme yapılıyorsa dizilerin 
    sütun uzunluklarının aynı olması gerekir. Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3))
    >>> b = np.random.randint(0, 100, (3, 2))
    >>> c = np.random.randint(0, 100, (3, 1))
    >>> a
    array([[10, 22, 77],
        [18, 15, 27],
        [30, 52, 70]])
    >>> b
    array([[26, 80],
        [ 6, 14],
        [75, 54]])
    >>> c
    array([[71],
        [ 1],
        [43]])
    >>> result = np.concatenate((a, b, c), axis=1)
    >>> result
    array([[10, 22, 77, 26, 80, 71],
        [18, 15, 27,  6, 14,  1],
        [30, 52, 70, 75, 54, 43]])

    Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3))
    >>> b = np.random.randint(0, 100, (2, 3))
    >>> c = np.random.randint(0, 100, (1, 3))
    >>> a
    array([[58, 55, 25],
        [50, 84, 56],
        [49, 12, 18]])
    >>> b
    array([[81,  1, 51],
        [44, 48, 56]])
    >>> c
    array([[91, 49, 86]])
    >>> result = np.concatenate((a, b, c), axis=0)
    >>> result
    array([[58, 55, 25],
        [50, 84, 56],
        [49, 12, 18],
        [81,  1, 51],
        [44, 48, 56],
        [91, 49, 86]])

    concatenate fonksiyonunda axis belirtilmezse default durumda axis boyut sayısından bir eksik alınmaktadır. (Yani örneğin iki 
    boyutlu eklemelerde default durum axis=0 biçimindedir.) axis belirtilmediği durumda flatten işlemi yapılmamaktadır. Aslında 
    NumPy'ın kaynak kodlarına bakıldığında append fonksiyonunun zaten concatenate kullanılarak yazıldığı görülmektedir:

    def append(arr, values, axis=None): 
        arr = asanyarray(arr)
        if axis is None:
            if arr.ndim != 1:
                arr = arr.ravel()
            values = ravel(values)
            axis = arr.ndim-1
        return concatenate((arr, values), axis=axis)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    append ve concatenate fonksiyonlarına benzer hstack ve vstack fonksiyonları da vardır. Bu fonksiyonlar da aslında concatenate 
    kullanılarak yazılmıştır. hstack(t) çağrısı concatenate(t, axis=1) ile vstack(t) çağrısı da concatenate(t, axis=1) çağrısı ile 
    yaklaşık eşdeğerdir. Yani hstack sütun eklemelerde vstack ise satır eklemelerde kullanılır. Yine eklenecek değerler bu fonksiyonlara
    demet ya da dizi biçiminde verilmektedir. Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3))
    >>> b = np.random.randint(0, 100, (3, 2))
    >>> c = np.random.randint(0, 100, (3, 1))
    >>> a
    array([[ 3, 67, 11],
        [21, 89, 98],
        [ 3, 11,  3]])
    >>> b
    array([[94,  6],
        [ 9, 87],
        [14, 83]])
    >>> c
    array([[70],
        [12],
        [54]])
    >>> result = np.hstack((a, b, c))
    >>> result
    array([[ 3, 67, 11, 94,  6, 70],
        [21, 89, 98,  9, 87, 12],
        [ 3, 11,  3, 14, 83, 54]])
    >>> result = np.concatenate((a, b, c), axis=1)
    >>> result
    array([[ 3, 67, 11, 94,  6, 70],
        [21, 89, 98,  9, 87, 12],
        [ 3, 11,  3, 14, 83, 54]])

    vstack ise satır eklemelerinde kullanılmaktadır. Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3))
    >>> b = np.random.randint(0, 100, (2, 3))
    >>> c = np.random.randint(0, 100, (1, 3))
    >>> a
    array([[27, 38, 17],
        [61, 74, 99],
        [99, 65, 47]])
    >>> b
    array([[16,  5, 86],
        [46, 15, 59]])
    >>> c
    array([[40, 25, 45]])
    >>> result = np.vstack((a, b, c))
    >>> result
    array([[27, 38, 17],
        [61, 74, 99],
        [99, 65, 47],
        [16,  5, 86],
        [46, 15, 59],
        [40, 25, 45]])
    >>> result = np.concatenate((a, b, c), axis=0)
    >>> result
    array([[27, 38, 17],
        [61, 74, 99],
        [99, 65, 47],
        [16,  5, 86],
        [46, 15, 59],
        [40, 25, 45]])   
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    hstack ve stack fonksiyonlarına benzer column_stack ve row_stack isimli fonksiyonlar da vardır. Bu fonksiyonlar tek boyutlu 
    ya da iki boyutlu NumPy dizilerini demet olarak almaktadır. Bunlara demetler tek boyutlu dizi olarak da verilebilmektedir. Bunlar 
    her zaman iki boyutlu dizi vermektedir. Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3))
    >>> a
    array([[77,  8, 78],
        [ 6, 65, 94],
        [70, 40, 74]])
    >>> b = np.array([1, 2, 3])
    >>> b
    array([1, 2, 3])
    >>> c = np.column_stack((a, b))
    >>> c
    array([[77,  8, 78,  1],
        [ 6, 65, 94,  2],
        [70, 40, 74,  3]])

    Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3))
    >>> a
    array([[76, 76, 25],
        [ 7, 13, 44],
        [ 1, 41, 78]])
    >>> a = np.array([1, 2, 3])
    >>> b = np.array([4, 5, 6])
    >>> c = np.array([7, 8, 9])
    >>> a
    array([1, 2, 3])
    >>> b
    array([4, 5, 6])
    >>> c
    array([7, 8, 9])
    >>> result = np.column_stack((a, b, c))
    >>> result
    array([[1, 4, 7],
        [2, 5, 8],
        [3, 6, 9]])

    Tabii girdiğimiz parametrelerin birer NumPy dizisi olamsı da zorunlu değildir. Örneğin:

    >>> result = np.column_stack((a, b, c))
    >>> result
    array([[1, 4, 7],
        [2, 5, 8],
        [3, 6, 9]])
    >>> result = np.column_stack(([1, 2, 3], [4, 5, 6], [7, 8, 9]))
    >>> result
    array([[1, 4, 7],
        [2, 5, 8],
        [3, 6, 9]])
    
    Burada bir noktaya dikkat ediniz. Bu fonksiyonlar her zaman bir boyutlu ya da iki boyutlu dizilerden oluşan demet ya da dizileri 
    alarak her zaman iki boyutlu diziler vermektedir. row_stack fonksiyonu da benzerdir:

    >>> result = np.row_stack(([1, 2, 3], [4, 5, 6], [7, 8, 9]))
    >>> result
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])

    Bu fonksiyonlarda da axis parametresinin olmadığına dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------------------
<BURADA KALDIM>
#------------------------------------------------------------------------------------------------------------------------------------
    insert isimli fonksiyon bizden bir NumPy dizisini, insert edilecek pozisyonu ve insert edilecek değerleri almaktadır. Insert işlemi
    insert edilmek istenen değerler insert pozisyonunda olacak biçimde diğer değerlerin kaydırılması yoluyla yapılmaktadır. Ancak 
    insert fonksiyonunda insert edilecek dizi append fonksiyonunda olduğu gibi oluşturulmamaktadır. insert fonksiyonunda insert edilecek 
    dizi dolaşıldığında satırlara ya da sütunlara insert edilecek değerler elde edilmelidir. Dolayısıyla insert edilecek dizi tek boyutlu 
    olarak da verilebilir. axis parametresi 0 girilirse satır, 1 girilirse sütun insert edilmektedir. Örneğin:

    >>> b = np.random.randint(0, 100, (3, 2))
    >>> a = np.random.randint(0, 100, (3, 5))
    >>> a
    array([[92, 75, 10,  3, 45],
        [58, 59, 23, 25, 27],
        [57,  3, 99, 78, 85]])
    >>> b = np.array([1, 2, 3])
    >>> result = np.insert(a, 2, b, axis=1)
    >>> result
    array([[92, 75,  1, 10,  3, 45],
        [58, 59,  2, 23, 25, 27],
        [57,  3,  3, 99, 78, 85]])
    >>> a = np.random.randint(0, 100, (3, 5))
    >>> a
    array([[59, 48, 56, 87, 87],
        [ 4, 69, 56, 60,  9],
        [66, 33, 69,  9, 79]])
    >>> result = np.insert(a, 1, [10, 20, 30, 40, 50], axis=0)
    >>> result
    array([[59, 48, 56, 87, 87],
        [10, 20, 30, 40, 50],
        [ 4, 69, 56, 60,  9],
        [66, 33, 69,  9, 79]])

    Görüldüğü gibi bir matrise satır ve sütun inserft ederken biz insert edilecek diziyi tek boyutlu olarak verdik. Eğer birden 
    fazla satır ya da sütun insert edilecekse bu satır ya da sütun bilgileri her zaman iki boyutlu dolaşılabilir bir nesne biçiminde 
    verilmelidir. insert fonksiyonu girilen bu nesneyi dolaşarak insert edilecek satır ya da sütunları elde eder. Örneğin:

    >>> a = np.random.randint(0, 100, (3, 5))
    >>> a
    array([[28, 66, 10,  3, 48],
        [ 3, 23, 91, 55, 34],
        [37, 49, 87, 85, 25]])
    >>> b = np.array([[10, 20, 30], [40, 50, 60]])
    >>> b
    array([[10, 20, 30],
        [40, 50, 60]])
    >>> result = np.insert(a, 2, b, axis=1)
    >>> result
    array([[28, 66, 10, 40, 10,  3, 48],
        [ 3, 23, 20, 50, 91, 55, 34],
        [37, 49, 30, 60, 87, 85, 25]])
    >>> b = np.array([[10, 20, 30, 40, 50], [60, 70, 80, 90, 100]])
    >>> b
    array([[ 10,  20,  30,  40,  50],
        [ 60,  70,  80,  90, 100]])
    >>> result = np.insert(a, 1, b, axis=0)
    >>> result
    array([[ 28,  66,  10,   3,  48],
        [ 10,  20,  30,  40,  50],
        [ 60,  70,  80,  90, 100],
        [  3,  23,  91,  55,  34],
        [ 37,  49,  87,  85,  25]])

    insert işleminde insert edilecek değer bir skaler de olabilir. Bu durumda ilgili satır ya da sütun o değerle doldurulur. 
    Örneğin:
    
    >>> a = np.random.randint(0, 100, (3, 5))
    >>> a
    array([[17, 58, 66, 45, 10],
        [ 8, 96, 25, 99, 67],
        [65,  7, 70, 99, 97]])
    >>> result = np.insert(a, 2, 0, axis=1)
    >>> result
    array([[17, 58,  0, 66, 45, 10],
        [ 8, 96,  0, 25, 99, 67],
        [65,  7,  0, 70, 99, 97]])
    >>> a
    array([[17, 58, 66, 45, 10],
        [ 8, 96, 25, 99, 67],
        [65,  7, 70, 99, 97]])
    >>> result = np.insert(a, 1, 0, axis=0)
    >>> result
    array([[17, 58, 66, 45, 10],
        [ 0,  0,  0,  0,  0],
        [ 8, 96, 25, 99, 67],
        [65,  7, 70, 99, 97]])

    Bu yöntemle birden fazla satır ya da sütun da insert edilebilir. Ancak yine bunların iki boyutlu tek elemandan oluşan diziler
    biçiminde verilmesi gerekir. Örneğin:

    >>> a = np.random.randint(0, 100, (3, 5))
    >>> a
    array([[39, 82, 92, 38,  5],
        [ 9, 40, 68, 87, 21],
        [89, 50, 36, 44, 92]])
    >>> result = np.insert(a, 1, [[0], [1]], axis=1)
    >>> result
    array([[39,  0,  1, 82, 92, 38,  5],
        [ 9,  0,  1, 40, 68, 87, 21],
        [89,  0,  1, 50, 36, 44, 92]])
    >>> result = np.insert(a, 1, [[0], [1]], axis=0)
    >>> result
    array([[39, 82, 92, 38,  5],
        [ 0,  0,  0,  0,  0],
        [ 1,  1,  1,  1,  1],
        [ 9, 40, 68, 87, 21],
        [89, 50, 36, 44, 92]])

    Burada o'larla ve 1'lerle dolu iki sütun ve satır insert edilmiştir. 

    Insert işleminde de axis belirtilmezse önce insert işleminin uygulanacağı dizi flatten yapılıp tek boyuta dönüştürülür, sonra insert 
    o noktaya yapılır. Örneğin:

   >>> a = np.random.randint(0, 100, (3, 5))
    >>> a
    array([[99, 83, 81, 61, 14],
        [78, 23, 62, 28, 80],
        [24, 15, 49, 80, 84]])
    >>> result = np.insert(a, 3, [10, 20, 30])
    >>> result
    array([99, 83, 81, 10, 20, 30, 61, 14, 78, 23, 62, 28, 80, 24, 15, 49, 80,
        84])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisinden belli elemanlar silinebilir. Bunun için delete fonksiyonu kullanılmaktadır. Bu fonksiyonun bir metot karşılığı 
    yoktur. delete fonksiyonunda silinecek NumPy dizisi, silinecek elemanın indeksi ve eksen bilgisi girilmektedir. Eğer axis parametresi 
    için argüman girilmezse önce dizi flatten yapılıp sonra işleme sokulmaktadır. Silme işlemi sonucunda her zaman yeni bir dizi elde
    edilmektedir. Yani bu fonksiyonun bize verdiği nesneler view belirtmemektedir. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> result = np.delete(a, 1, axis=1)
    >>> result
    array([[1, 3],
        [4, 6],
        [7, 9]])
    >>> result.base

    delete fonksiyonu ile birden fazla satır ya da sütun da silinebilmektedir. Bunun için satır ve sütun numaraları bir demet ya da 
    liste biçiminde verilmelidir. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> result = np.delete(a, [1, 2], axis=1)
    >>> result
    array([[1],
        [4],
        [7]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> result = np.delete(a, [0, 2], axis=0)
    >>> result
    array([[4, 5, 6]])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Son 20 yıldır giderek artan bir biçimde "veri bilimi (data science)" terimi kullanılmaya başlanmıştır. Veri bilimi "verileri 
    analiz etme, onlardan faydalı içgörüler elde etme, sonuç çıkarma ve kesitirim yapma" amacıyla uygulanan  yöntemleri ve süreçleri 
    betimlemektedir. Aslında veri biliminin uğraş alanına benzeyen "veri analizi (data analytics)" genel olarak "istatistik" denilen 
    bilimin bir alt dalı idi. Ancak son 20 yıldır veriler üzerinde bilgisayar programlaması yoluyla klasik istatistikte yapılmayan 
    pek çok işlemler yapılmaya başlanmıştır. İşte "veri bilimi" terimi adeta uygulamalı istatistiğin bilgisayar bilimleri ile iç içe 
    geçmiş bir biçimini anlatmaktadır. Programlama ile veri analizine yönelik uygulamalar artık "veri bilimi uygulamaları" biçiminde 
    ele alınmaya başlanmıştır. Verilerin bilgisayar yardımıyla analiz edilmesi ve faydalı birtakım çıkarımların yapılması veri biliminin 
    önemli bir alanını oluşturmaktadır.   
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Veri bilimi uygulamalarında analiz edilecek veriler şu biçimlerde bulunabilmektedir:

    - Dosyalar içerisinde
    - Veritabanlarının içerisinde
    - Sürekli gelen bir akış içerisinde (örneğin TCP portundan gelen veriler gibi)

    Ancak en çok karşılaşılan durum analiz edilecek verilerin dosyalar içerisinde bulunmasıdır. Pekiyi verilerin içerisinde bulunduğu 
    dosyalar hangi formattadır? İşte en yaygın kullanılan format "CSV (Comma Seperated Values)" denilen formattır. Bu formatta satırların 
    sütunları ',' karakterleriyle satırlar da '\n '(LF) ya da '\r' ve '\n' (CR/LF) karakterleriyle birbirinden ayrılmaktadır. CSV 
    formatında virgüllerden sonra boşluk bırakılmadığına dikkat edibiz. Örneğin:

    1.2,3,5.7,4
    3.2,16,5.6,8
    1.2,7,3.6,8
    ...

    CSV formatında dosyanın başında bir başlık kısmı da bulunabilmektedir. Bu başlık kısmı sütunların ne anlama geldiğine ilişkin 
    sütun isimlerinden oluşmaktadır. Örneğin:

    no,boy,kilo
    1,172,72.3
    2,182,85.2
    3,168,71.6
    ...

    CSV bir text formattır. Dolayısıyla biz bir CSV dosyasını editöre çekip onun üzerinde değişiklikler yapabiliriz. CSV formatı 
    herhangi bir kurum tarafından standardize edilmiş bir format değildir. Format içerisinde çeşitli belirsizlikler vardır. Bu nedenle 
    CSV formatının çeşitli biçimleri (diyalekleri) bulunmaktadır.

    Daha önceden de belirttiğimiz gibi istatistikte ve veri analizinde veriler "veri kümeleri (datasets)" biçiminde ifade edilmektedir. 
    ("Veri kümesi" yerine "veri tablosu (data table)" terimi de kullanılmaktadır.) Bir veri kümesi matrisel bir biçimde satırlardan 
    ve sütunlardan oluşmaktadır. Veri kümesindeki sütunlara "sütun (column)" ya da "özellik (feature)" satırlara ise "satır (row)" 
    ya da "kayıt (record)" denilmektedir. 

    Veri kümelerinin dosyada saklanmasına ilişkin "HDF (Hierachical Data Format)" gibi çeşitli "binary" formatlar da bulunmaktadır. 
    Biz kursumuzda yalnızca CSV formatı üzerinde duracağız. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi veri kümeleri nasıl oluşturulmaktadır? Veri kümelerini oluşturmak için verilerin toplanması gerekir. Veri toplama işleminin
    birkaç tipik yöntemi vardır:

    - Veriler anket (survey) yoluyla toplanabilir.
    - Veriler zaten bir biçimde doğal akış içerisinde oluşmuş olabilir. (Örneğin sosyal ağlardaki yazışmalar birer veri olarak zaten 
    sosyal ağın organizasyonu yapan kişiler tarafından veritabanlarında saklanmaktadır.)
    - Veriler otomatik olarak sensörlerden elde ediliyor olabilir. Günümüzde verilerin önemli bir kısmı bu biçimde otomatik elde 
    edilmektedir.
    - Bazen veriler çeşitli kurumlar tarafından (örneğin istatistik kurumları) zaten elde edilmiş durumdadır. Kişler de o kurumlardan 
    ilgili veri kümelerini alabilmektedir. 

    Örnek veri kümeleri Internet'te pek çok kaynaktan elde edilebilir. Son yıllarda "kaggle.com" isimli organizasyon bu bakımdan çok
    kullanılır hale gelmiştir. Kaggle, Google tarafından makine öğrenmesi uygulamalarını teşvik etmek amacıyla oluşturulmuş olan bir 
    organizasyondur.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy'da CSV gibi text tabanlı dosyalardan verileri okuyarak bir NumPy dizisi biçiminde bize veren loadtxt isimli bir fonksiyon 
    vardır. Veri bilimcisi bu fonksiyonu çok sık kullanmaktadır. 

    loadtxt fonksiyonunun birinci parametresi okunacak dosyanın yol ifadesini alır. Fonksiyonun ikinci patramtresi dtype türünü  
    belirtmektedir. dtype türü belirtilmezse default olarak np.float64 alınmaktadır. Bu dtype türü okunan bilgilerin hangi dtype 
    türüne ilişkin bir NumPy dizisi olarak verileceğini belirtmektedir. Fonksiyonun skiprows parametresi dosyanın başından itibaren 
    kaç satırın atlanacağını belirtmektedir. Eğer CSV dosyasında bir başlık kısmı varsa skiprows=1 yapılarak bu başlık kısmı atlanmalıdır. 
    Fonksiyonun delimiter parametresi değerlerin ayrıştırılacağı karakteri belirtmektedir. loadtxt fonksiyonu yalnızca CSV dosyalarını 
    değil değerlerin başka ayrıraçlarla ayrıldığı dosyaları da okuyabilmektedir. CSV dosyalarını okumak için delimiter parametresi 
    delimiter=',' biçiminde girilmelidir. Eğer delimiter parametresi girilmezse default ayıracın boşluk karakterleri olduğu kabul 
    edilmektedir.
    
    Aşağıdaki gibi "points.csv" isminde bir CSV dosyamız olsun:

    x,y
    10,23
    5,9
    6.1,8.7
    12,81
    4.2,9.3
    11,27
    32,72
    12.3,7.8

    Dosyayı şöyle okuyabiliriz:

   dataset = np.loadtxt('point.csv', dtype=np.float32, delimiter=',', skiprows=1)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

dataset = np.loadtxt('point.csv', dtype=np.float32, delimiter=',', skiprows=1)
print(dataset)

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte eğer "points.csv" dosyasında satırların sütunları boşluklarla ayrılmış olsaydı "delimiter" parametresine bir 
    şey girmememiz gerekmeyecekti. Çünkü bu durumda değerler arasındaki tüm boşluk karakterleri atılmaktadır. Örneğin "points.txt" 
    dosyası aşağıdaki gibi olsun:

    x,y
    10 23
    5 9
    6.1 8.7
    12 81
    4.2 9.3
    11 27
    32 72
    12.3 7.8

    Bu durumda okuma şöyle yapılmalıdır:

    dataset = np.loadtxt('points.txt', dtype=str, skiprows=1)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

dataset = np.loadtxt('points.csv', skiprows=1)
print(dataset)

#------------------------------------------------------------------------------------------------------------------------------------
    Pek çok veri kümesinde bazı sütunlar yazısal (kategorik) bazı sütunlar sayısal biçimdedir. Örneğin zambaklara ilişkin bilgilern 
    bulunduğu "iris.csv" dosyasının içeriği şöyledir:

    sepal_length,sepal_width,petal_length,petal_width,species
    5.1,3.5,1.4,0.2,Iris-setosa
    4.9,3,1.4,0.2,Iris-setosa
    4.7,3.2,1.3,0.2,Iris-setosa
    4.6,3.1,1.5,0.2,Iris-setosa
    5,3.6,1.4,0.2,Iris-setosa
    5.4,3.9,1.7,0.4,Iris-setosa
    4.6,3.4,1.4,0.3,Iris-setosa
    5,3.4,1.5,0.2,Iris-setosa
    4.4,2.9,1.4,0.2,Iris-setosa
    4.9,3.1,1.5,0.1,Iris-setosa
    5.4,3.7,1.5,0.2,Iris-setosa
    4.8,3.4,1.6,0.2,Iris-setosa
    ...

    Bu biçimde yalnızca sayısal bilgi içermeyen sütunların bulunduğu CSV dosyaları dtype=np.float32 gibi nümerik dtype belirtilerek 
    okunamaz. Bu tür dosyalar ancak dtype türü object ya da str biçiminde belirtilerek okunabilmektedir. Ancak bu durumda d<a okuma 
    sonucunda yazılardan oluşan bir NumPy dizisi elde edilir. Yazılardan oluşan NumPy dizilerini de sayısal biçime dönüştürmek oldukça 
    zahmetlidir. Örtneğin:

    dataset = np.loadtxt('iris.csv', delimiter=',', dtype=str, skiprows=1)

    Burada okuma sonucunda elde edilen NumPy dizisi yazılardan oluşmaktadır:

    array([['5.1', '3.5', '1.4', '0.2', 'Iris-seosa'],
       ['4.9', '3', '1.4', '0.2', 'Iris-setosa'],
       ['4.7', '3.2', '1.3', '0.2', 'Iris-setosa'],
       ['4.6', '3.1', '1.5', '0.2', 'Iris-setosa'],
       ['5', '3.6', '1.4', '0.2', 'Iris-setosa'],
       ['5.4', '3.9', '1.7', '0.4', 'Iris-setosa'],
       ['4.6', '3.4', '1.4', '0.3', 'Iris-setosa'],
       ['5', '3.4', '1.5', '0.2', 'Iris-setosa'],
       ['4.4', '2.9', '1.4', '0.2', 'Iris-setosa'],
       .....
    )
    
    Pekiyi o zaman bu tür dosyalar nasıl okunacaktır?
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                            47. Ders 06/09/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    loadtxt fonksiyonunun usecols parametresine dolaşılabilir bir nesne girilir. Bu parametre dosyadan hangi sütunların elde edileceğini 
    belirtir. Biz veri tablolarındaki yalnızca bazı sütunları almak isteyebiliriz. İlk sütun 0 numaralı sütundur. Böylece okunmak 
    istenen sütunlar fonksiyona bir liste biçiminde (genel olarak dolaşılabilir bir nesne biçiminde) girilebilir. Örneğin:

    dataset = np.loadtxt('iris.csv', delimiter=',', dtype=np.float32, skiprows=1, usecols=[0, 1, 2, 3])

    Buarad "iris.csv" veri kümesindeki zambakların türünü belirten son sütun okunmamıştır. (Bu son sütunun indeks numarası 4'tür. Bizim 
    bu sütunu okumaya dahil etmediğimize dikkat ediniz.)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de Covid-19 salgınındaki çeştli bilgileri barındıran "country_wise_latest.csv" isimli veri kümesinde loadtxt fonksiyonu 
    ile okuma yapalım. "country_wise_latest.csv" veri kümesini aşağıdaki bağlantıdan indirebilirsiniz:

    https://www.kaggle.com/datasets/imdevskp/corona-virus-report

    Bu veri kümesi aşağıdaki gibi bir içeriğe sahiptir:

    Country/Region,Confirmed,Deaths,Recovered,Active,New cases,New deaths,New recovered,Deaths / 100 Cases,Recovered / 100 Cases,
    Deaths / 100 Recovered,Confirmed last week,1 week change,1 week % increase,WHO Region
    Afghanistan,36263,1269,25198,9796,106,10,18,3.5,69.49,5.04,35526,737,2.07,Eastern Mediterranean
    Albania,4880,144,2745,1991,117,6,63,2.95,56.25,5.25,4171,709,17.0,Europe
    Algeria,27973,1163,18837,7973,616,8,749,4.16,67.34,6.17,23691,4282,18.07,Africa
    Andorra,907,52,803,52,10,0,0,5.73,88.53,6.48,884,23,2.6,Europe
    Angola,950,41,242,667,18,1,0,4.32,25.47,16.94,749,201,26.84,Africa
    Antigua and Barbuda,86,3,65,18,4,0,5,3.49,75.58,4.62,76,10,13.16,Americas
    ...
    
    Biz bu veri tablosundan Confirmed, Deaths, Recovered, Active sütunlarındaki bilgileri almak isteyelim. Bu sütunların indeks 
    numaraları 1, 2, 3, 4 biçimindedir. Okuma işlemi aşağıdaki gibi yapılabilir:

    >>> dataset = np.loadtxt('country_wise_latest.csv', delimiter=',', dtype=np.float32, skiprows=1, usecols=[1, 2, 3, 4])
    >>> dataset
    array([[3.626300e+04, 1.269000e+03, 2.519800e+04, 9.796000e+03],
        [4.880000e+03, 1.440000e+02, 2.745000e+03, 1.991000e+03],
        [2.797300e+04, 1.163000e+03, 1.883700e+04, 7.973000e+03],
        [9.070000e+02, 5.200000e+01, 8.030000e+02, 5.200000e+01],
        [9.500000e+02, 4.100000e+01, 2.420000e+02, 6.670000e+02],
        [8.600000e+01, 3.000000e+00, 6.500000e+01, 1.800000e+01],
        [1.674160e+05, 3.059000e+03, 7.257500e+04, 9.178200e+04],
        [3.739000e+04, 7.110000e+02, 2.666500e+04, 1.001400e+04],
        ...

    Şimdi veri tablosundaki ilk ve son sütunu atarak geri kalan sütunları almak isteyelim. Bu veri tablosunda toplam 15 sütun vardır. İşlemi 
    şöyle yapapbiliriz:

   >>> dataset = np.loadtxt('country_wise_latest.csv', delimiter=',', dtype=np.float32, skiprows=1, usecols=range(1, 14))
    >>> dataset
    array([[3.6263e+04, 1.2690e+03, 2.5198e+04, ..., 3.5526e+04, 7.3700e+02,
            2.0700e+00],
        [4.8800e+03, 1.4400e+02, 2.7450e+03, ..., 4.1710e+03, 7.0900e+02,
            1.7000e+01],
        [2.7973e+04, 1.1630e+03, 1.8837e+04, ..., 2.3691e+04, 4.2820e+03,
            1.8070e+01],
        ...,
        [1.6910e+03, 4.8300e+02, 8.3300e+02, ..., 1.6190e+03, 7.2000e+01,
            4.4500e+00],
        [4.5520e+03, 1.4000e+02, 2.8150e+03, ..., 3.3260e+03, 1.2260e+03,
            3.6860e+01],
        [2.7040e+03, 3.6000e+01, 5.4200e+02, ..., 1.7130e+03, 9.9100e+02,
            5.7850e+01]], shape=(187, 13), dtype=float32)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

dataset = np.loadtxt('country_wise_latest.csv', delimiter=',', dtype=np.float32, skiprows=1, usecols=[1, 2, 3, 4])
print(dataset)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir veri tablosunda bazı sütunlarda sayısal bilgiler de yazısal bilgiler bulunuyor olabilir. İstatistikte kategori belirten 
    sütunlara "kategorik sütunlar" ya da "nominal sütunlar" denilmektedir. Örneğin yukarıdaki "country_wise_latest.csv" dosyasının 
    ilk sütunu vakalara ilişkin ülkeleri belirtmektedir. Veri analizi yapılırken bu tür kategorik sütunların 0, 1, 2, 3... biçiminde 
    sayısal hale dönüştürülmesi gerekebilmektedir. (Aslında genellikle bu tür sütunlar "one-hot-encoding" denilen yöntemle sayısal biçime 
    dönüştürülmektedir.) Bu tür yazısal sütunların olduğu veri tablolarını loadtxt ile okurken dtype türü default olarak float64 olduğu 
    için okuma soruna yol açacaktır. Burada uygulanacak yöntemlerden biri yukarıda da belirttiğimiz gibi dtype=object ya da dtype=str 
    ile okuma yapmaktır. Ancak bu durumda loadtxt tüm sütunları yazısal biçime dönüştürecektir. Yani bu yöntemde biz dosyayı okumuş oluruz 
    fakat onu istediğimiz hale geitrmemiz zor olur. 

    Aşağıdaki gibi "persons.csv" isminde bir dosya bulunuyor olsun:

    kilo,boy,yaş,cinsiyet
    67.2,172,43,kadın
    87.2,183,52,erkek
    32,142,9,erkek
    90,168,48,kadın
    ...

    Biz bu dosyayı dtype=float32 vererek biçiminde okuyamayız. dtype=object ya da dtype=str biçiminde okursak tüm sütunlar yazı gibi 
    okunavaktır. Halbuki bizim yapmak istediğimiz şey kadın=0, erkek=1 gibi bu kategorik sütunu sayısal biçime dönüştürmektir. İşte 
    bunu yapmanın birkaç yolu vardır. loadtxt fonksiyonunun "converters" parametresi bir sözlük nesnesi olarak girilir. Bu sözlüğün 
    anahtarları sütun numaralarını, değerleri çağrılacak fonksiyonları belirtir. loadtxt tarafından dosya okunurken ilgili sütun 
    verisi bir str nesnesi olarak bu fonksiyona parametre yapılır, bu fonksiyonun geri dönüş değeri o sütunun değeri gibi okunur. 

    Yukarıdaki dosyayı okurken cinsiyet sütununu kadın=0, erkek=1 biçiminde sayısallaştırmak isteyelim. Bu işlemi aşağıdaki gibi 
    yapabiliriz. Ancak CSV dosyasında Türkçe karakterler varsa loadtxt fonksiyonunun encoding parametresini 'utf-8' yapmalısınız. 
    Yani özetle CSV dosyası hangi encoding'e göre oluşturulmuşsa o encoding'e göre okuma yapılmalıdır. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

def gender_converter(gender):
    return {'erkek': 0, 'kadın': 1}[gender]
    
dataset = np.loadtxt('persons.csv', delimiter=',', dtype=np.float32, skiprows=1, encoding='utf-8', converters={3: gender_converter})
print(dataset)

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte daga üzerinde çalıştığımız "iris.csv" veri kğmesindeki zambak türüne ilişkin dönüştürme uygulanmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

def iris_converter(iris):
    return {'Iris-setosa': 0, 'Iris-versicolor': 1, 'Iris-virginica': 2}[iris]
    
dataset = np.loadtxt('iris.csv', delimiter=',', dtype=np.float32, skiprows=1, encoding='utf-8', converters={4: iris_converter})
print(dataset)

#------------------------------------------------------------------------------------------------------------------------------------
    loadtxt fonksiyonunun max_rows parametresi okunacak satır sayısını belirtmektedir. Böylece biz skiprows ve max_rows parametrelerini 
    ayarlayarak dosyanın ilgili kısmını okuyabiliriz.
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

def iris_converter(iris):
    return {'Iris-setosa': 0, 'Iris-versicolor': 1, 'Iris-virginica': 2}[iris]
    
dataset = np.loadtxt('iris.csv', delimiter=',', dtype=np.float32, skiprows=1, max_rows=10, encoding='utf-8', converters={4: iris_converter})
print(dataset)

#------------------------------------------------------------------------------------------------------------------------------------
    Maalesef loadtxt fonksiyonu farklı diyaleklere sahip olan CSV dosyalarını okuyamamaktadır. Örneğin bir sütun iki tırnaklı ise 
    bazı CSV okuyucuları bu iki tırnağın içerisindekileri dikkate almadan o iki tırnağın tamamını sütun bilgisi olarak okumaktadır. 
    Ancak loadtxt bunu yapamamaktadır. Bu tür durumlarda CSV dosyalarının önce loadtxt tarafından okunabilecek hale getirilmesi gerekir.
    
    Aslında loadtxt fonksiyonu ileride göreceğimiz Pandas kütüphabesinin read_csv fonksiyonuna göre oldukça zayıf kalmaktadır. Pandas'ın
    read_csv fonksiyonu pek CSV diyaleğini otomatik olarak anlayabilmekte ve farklı sütun yapılarını farklı türlerden olacak biçimde
    tablo biçiminde (buna Pandas'ta DataFrame denilmektedir) okuyabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    loadtxt fonksiyonun tersini de yapmak isteyebiliriz. Örneğin bir NumPy dizisini bir CSV ya da text dosya olarak diskte saklamak 
    isteyebiliriz. Bunun için savetxt fonksiyonu kullanılmaktadır. Bu fonksiyonun birinci parametresi save edilecek dosyanın yol 
    ifadesini, ikinci parametresi NumPy dizisini belirtir. Yine bu fonksiyonda da delimiter parametresi bulunmaktadır. Fonksiyon 
    default durumda sayıları üstel formatta dosyaya yazmaktadır. fmt parametresi C dilindeki printf fonksiyonunun format parametresi 
    gibi girilebilir. (Örneğin "%d" 10 luk sistemde yuvarlayarak yazdırma anlamındandır. %.5f noktadan sonra 5 basamak yazdır anlamına 
    gelir). Fonksiyonun header parametresi ilk satıra yazdırılacak yazının belirlenmesinde kullanılabilir. Ancak default durumda bu 
    yazının başına # karakteri getirilmektedir. Bu istenmiyorsa comments='' girilmelidir. Başlık kısmında Türkçe karakterler kullanılacaksa 
    yine encoding'e dikkat edilmelidir. Pek çok editörün default durumda "utf-8" encoding'ine göre save işlemi yaptığını anımsayınız. 
    BOM marker eklemek için encoding='utf-8-sig' bçiminde encoding belirtilebilir.  Örneğin:

    import numpy as np

    data = np.random.randint(0, 100, (10, 10))
    np.savetxt('numbers.csv', data, delimiter=',', fmt='%.0d', header='A,B,C,D,E,F,G,H,I,J', comments='')

    Buradan aşağıdaki gibi bir CSV dosyası elde edilmiştir:

    A,B,C,D,E,F,G,H,I,J
    91,29,99,65,33,18,10,30,5,79
    56,86,56,17,38,95,56,1,10,99
    93,88,90,97,93,16,67,0,71,29
    3,8,83,88,74,78,80,93,11,60
    66,60,51,83,79,77,18,72,62,91
    90,93,58,67,32,45,66,96,60,76
    81,2,28,74,74,31,75,48,99,86
    35,96,59,60,1,57,7,28,64,94
    13,29,75,8,10,53,43,25,63,9
    95,15,96,10,98,32,9,48,53,46
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    loadtxt fonksiyonunun binary okuma yapan load isimli, savetxt fonksiyonunun binary yazma yapan save isimli biçimleri de vardır. 
    Bu fonksiyonlar NumPy tarafından oluşturulan ".npy" dosya formatı biçiminde okuma yazma yaparlar. Binary okuma yazma aslında çok 
    tercih edilen bir biçim değildir. Daha çok veri bilimi uygulamalarında text tabanlı CSV dosyası ve türevleri kullanılmaktadır. Ancak 
    dosyalar çok büyük ise text dosyalar çok yer kaplar hale gelmektedir. Bu tür durumlarda binary dosyalar tercih edilebilmektdir. 
    save ve load fonksiyonlarının delimiter gibi, header gibi, fmt gibi parametreleri yoktur. Örneğin:

    import numpy as np

    data = np.random.randint(0, 100, (10, 10))
    np.save('numbers.npy', data)

    data2 = np.load('numbers.npy')
    print(data2)

    save işlemi ile olşuturulan ".npy" dosyasını text editörde açmaya çalışmayınız. Binary dosyaların içerisinde yazılar olmadığı 
    için anlamlı şeyler göremezsiniz.
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

data = np.random.randint(0, 100, (10, 10))
np.save('numbers.npy', data)

data2 = np.load('numbers.npy')
print(data2)
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi Python'da bir sınıf nesnesi bool türüne dönüştürüldüğünde eğer sınıfın ya da onun taban sınıfının __bool__ 
    metodu özel olarak yazılmamışsa True değeri elde edilmektedir. Bir NumPy dizisi bool türüne dönüştürülürse bu durum yanlış anlaşılmalara 
    yol açabileceği için ndarray sınıfının __bool__ metodunda exception fırlatılmıştır. Yani biz bir ndarray nesnesini bool türüne 
    dönüştüremeyiz. if, while gibi deyimler bu dönüştürmeyi yaptıklarına göre biz NumPy dizilerini bu deyimlerdeki kontrol ifadesi 
    olarak kullanamayız.
#------------------------------------------------------------------------------------------------------------------------------------
   
import numpy as np

a = np.array([1, 2, 3, 4, 5])

if a:                   # exception oluşacak!
    print('True')
else:
    print('False')

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisinin içerisindeki her elemanı bool türüne dönüştürüp bunların hepsi True ise True değerini veren en az bir tanesi 
    False ise False değerini veren all isimli bir fonksiyon vardır. Bu fonksiyon aynı zamanda ndarray sınıfının metodu olarak da
    yazılmıştır. Örneğin:

    data = np.array([1, 2, 3, 4, 5])
    result = data.all()
    print(result)           # True

    data = np.array([1, 2, 0, 4, 5])
    result = data.all()
    print(result)           # False
    
    Örneğin biz bir Numpy dizisini bir değerle karşılaştırdığımızda aslında onun her elemanını o değerler karşılaştırmış oluruz. 
    Sık yapılan bir hata doğrudan bu karşılaştırmanın sonucunun bool olduğunu sanmaktır. Bu durumda yukarıda da belirttiğimiz gibi 
    exception oluşacaktır. Örneğin:

    import numpy as np

    data = np.array([18, 21, 15, 40])

    if data > 10:                     # exception
        print('Yes')
    else:
        print('No')
        
    Burada programcılar "sanki dizinin her elemanı 10'dan büyük mü" karşılaştırmasını yaptıklarını sanmaktadır. Oysa data > 10 
    işleminden bir NumPy dizisi elde edilmektedir. Bu NumPy dizisi de bool türüne dönüştürülemez. Burada exception oluşacaktır. 
    Bu işlemin aşağıdaki gibi yapılması gerekirdi:

    import numpy as np

    data = np.array([18, 21, 15, 40])

    if (data > 10).all():                     
        print('True')
    else:
        print(False')

    Buarada nokta operatörünün önceliği yüksek olduğu için karşlaştırma operatörü paranteze alınmıştır. Bu tür durumlarda metot yerine 
    fonksiyon kullanımını tercih edebilirsiniz. Örneğin:

    if np.all(a > 10):                     
        print('True')
    else:
        print(False')
    
    any isimli fonksiyon ise dizi içerisinde bool türüne dönüştürülen elemanlardan en az bir tanesi True ise True değerini hepsi False 
    ise False değerini vermektedir. Örneğin:

    data = np.array([18, 21, 15, 40])

    if np.any(data > 10):                     
        print('True')
    else:
        print('False')

    Burada dizi elemanlarından en az bir tanesi 30'dan büyükse any metodu True değerine aksi takdirde False değerine geri dönecektir. 
    Örneğin:
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    NumPy'da iki NumPy dizisinin eşitliği aşağıdaki gibi karşılaştırılamaz:

    if a == b:          # exception oluşur
        pass

    Burada a ve b bir NumPy dizisi olduğuna göre a == b işleminden her elemanı bool türden olan bir NumPy dizisi elde edilecektir. 
    Dolayısıyla yukarıda belirttiğimiz sorun ortaya çıkacaktır. O halde bu işlem aşağıdaki gibi yapılmalıdır:

    if np.all(a == b):
        pass

    Özetle a ve b biçiminde iki NumPy dizisinin karşılıklı elemanlarının eşitliğini kontrol etmek için np.all(a == b) ifadesi 
    kullanılmalıdır. 
#------------------------------------------------------------------------------------------------------------------------------------
   
import numpy as np

a = np.array([18, 21, 15, 40])
b = np.array([18, 21, 15, 40])

if a == b:
    print('a == b')
else:
    print('a != b')
   
#------------------------------------------------------------------------------------------------------------------------------------
    NumPy kütüphanesinde linalg isimli pakette temel lineer cebir işlemlerini yapan fonksiyonlar bulunmaktadır. Örneğin det isimli 
    fonksiyon kare matrisin determinantını hesaplar:

    >>> a = np.array([[1, 2, 7], [4, 1, 6], [4, 8, 9]])
    >>> result = np.linalg.det(a)
    >>> result
    133.0
    >>> a = np.array([[1, 2, 7], [2, 4, 14], [4, 8, 9]])
    >>> result = np.linalg.det(a)
    >>> result
    0.0
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2, 3], [4, 2, 1], [6, 9, 3]])

b = np.linalg.det(a)
print(b)

#------------------------------------------------------------------------------------------------------------------------------------
    inv isimli fonksiyon matris tersini bulmaktadır. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 2, 1], [6, 9, 3]])
    >>> a
    array([[1, 2, 3],
        [4, 2, 1],
        [6, 9, 3]])
    >>> result = np.linalg.inv(a)
    >>> result
    array([[-0.05263158,  0.36842105, -0.07017544],
        [-0.10526316, -0.26315789,  0.19298246],
        [ 0.42105263,  0.05263158, -0.10526316]])
#------------------------------------------------------------------------------------------------------------------------------------
   
import numpy as np

a = np.array([[1, 2, 3], [4, 2, 1], [6, 9, 3]], dtype=np.float64)

b = np.linalg.inv(a)
print(b)

c = np.matmul(a, b)
print(c)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir lineer denklem sistemi AX = b biçiminde ifade edilebilir. Örneğin:

   3x1 - 2x2 + x3 = 2
   -x1 + 2x2 - x3 = 0
   x1 + x2 + x3 = 6

    Bu denklem sisteminde A matrisi şöyledir:

     3  -2  1
    -1  2  -1
     1  1   1

    b matirisi de şöyledir:

     1
     0
    13

    Denklemin çözümü şöyle yapılabilir:

    A⁻¹AX = A⁻¹b
    X = A⁻¹b
    
    Yani aslında X değerleri A'nın tersinin b ile çarpımı biçiminde bulunabilir. Tabii buradaki çarpım matris çarpımıdır. Örneğin:

    >>> A = np.array([[3, -2, 1], [-1, 2, -1], [1, 1, 1]])
    >>> b = np.array([[2], [0], [6]])
    >>> A
    array([[ 3, -2,  1],
        [-1,  2, -1],
        [ 1,  1,  1]])
    >>> b
    array([[2],
        [0],
        [6]])
    >>> np.linalg.inv(A) @ b
    array([[1.],
       [2.],
       [3.]])

    Bu tür durumlarda sütun vektörlerini yazmak zor oldupu için reshape işleminden faydalanabilirisiniz:

    >>> A = np.array([[3, -2, 1], [-1, 2, -1], [1, 1, 1]])
    >>> b = np.array([2, 0, 6]).reshape(-1, 1)
    >>> np.linalg.inv(A) @ b
    array([[1.],
        [2.],
        [3.]])
#------------------------------------------------------------------------------------------------------------------------------------ 

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında yukarıdaki işlemi tek hamlede yapan solve isimli bir fonkisyon vardır. Örneğin:

    >>> A = np.array([[3, -2, 1], [-1, 2, -1], [1, 1, 1]])
    >>> b = np.array([2, 0, 6]).reshape(-1, 1)
    >>> np.linalg.solve(A, b)
    array([[1.],
        [2.],
        [3.]])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Matematikte birtakım problemler iki biçimde çözülebilmektedir:

    1) Sembolik yöntemle
    2) Nümerik yöntemle

    Sembolik yönteme "kapalı (closed)" yöntem de denilmektedir. Bu yöntemde problem genellikle fonksiyon olarak verilir. Çözüm de 
    bir fonksiyon olarak istenir. Örneğin f(x) = 3x² - 5x + 10 gibi bir fonksiyon olsun. Bu fonksiyonun türevini biz yine bir 
    fonksiyon olarak elde etmek istiyorsak sembolik ya da kapalı yöntemi kullanmış oluruz. Ancak bu fonksiyonun belli bir noktadaki 
    türevinin değerini elde etmek istediğimizde bu işlem sembolik olarak da nümerik olarak da yapılabilir. Bazı problemler yalnızca 
    nümerik yöntemlerle çözülebilmektedir. Örneğin 5'inci dereceden daha büyük denklemlerin sembolik çözümü oluşturulamamaktadır. 
    Pek çok optimizasyon probleminin de sembolik çözümü mümkün değildir. Okullarda genellikle sembolik yöntemler üzerinden matematik 
    anlatılmaktadır. Her ne kadar mühendislik ve bazı bölümlerde "mümerik analiz" adı altında dersler olsa da bunlara yeterli önem 
    verilmemektedir. 

    Python'da sembolik bir biçimde matemetiksel işlemler yapan en önemli kütüphane "SymPy" ("Symbolic Pyton" sözcüklerinden kısaltma) 
    denilen kütüphanedir. Nümerik işlemler için ise en yaygın kullanılan kütüptane "SciPy" ("Scientic Pyton" sözcüklerinden kısaltma)
    kütüphanesidir. Matematiksel ve istatistiksel yöntemlerle makine öğrenmesi uygulamaları için "scikit-learn" isimli kütüphane, 
    yapay sinir ağları ve derin öğrenme için ise "TensorFlow", "PyTorch" ve "Theano" isimli kütüphaneler yaygın biçimde kullanılmaktadır. 
    Doğal dil işleme (NLP) işlemleri için ise "Hugging Face" isimli kütüphane ilk seçeneklerdendir. Tabii kütüpahnelerin başka 
    alternatifleri de vardır. Ancak sözünü ettiğimiz bu kütüpahneler bu amaçlar için kullanılan en yaygın kütüphanelerdir. 

    Taban Kütüphaneler ===> NumPy, Pandas
    Sembolik Matemetik ===> SymPy
    Nümerik Matematik ===> SciPy
    İstatistiksel ve Matematiksel Makine Öğrenmesi Uygulamaları ===> scikit-learn
    Yapay Sinir Ağları ve Derin Öğrenme ===> TensorFlow, PyTorchi Theano
    Doğal Dil İşleme ===> Hugging Face

    Bu bölümde SymPy kütüphanesinin kullanımı üzerinde duracağız. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi Python'da sembolik yöntemlerle matematiksel işlem yapan en yaygın SymPy kütüphanesidir. 
  
    SymPy kütüphanesinin dokümantasyonu aşağıdaki adreste bulunmaktadır:

    https://docs.sympy.org/latest/index.html

    Anaconda dağıtımında SymPy zaten dağıtımın kendi içersinde bulunmaktadır. Ancak diğer dağıtımlarda bunun pip programı ile kurulması 
    gerekir:

    pip install sympy

    Biz burada bu kütüphaneyi sp ismiyle import edeceğiz:

    import sympy as sp
#------------------------------------------------------------------------------------------------------------------------------------
 
#------------------------------------------------------------------------------------------------------------------------------------
    SymPy'da önce fonksiyonları oluşturan x, y gibi değişkenlerin birer sembol olarak ifade edilmesi gerekir. Bunun için SymPy'da 
    Symbol isimli bir sınıf kullanılmaktadır. Symbol sınıfı bizden sembolün ismini parametre olarak almaktadır. Her ne kadar aslında 
    SymPy sınıf nesneleri üzerinde işlem yapıyorsa da görüntüleme aşamasında bizim verdiğimiz sembol yazısını kullanmaktadır. Örneğin:

    >>> x = sp.Symbol('x')
    >>> x
    >>> type(x)
    <class 'sympy.core.symbol.Symbol'>

    Tabii sembole verdiğimiz isim ile onu atadığımız değişkenin isminin aynı olması gerekmez. Ancak kafa karışıklığı oluşmasın isteniyorsa
    Python'daki değişken ismiyle sembole verilen isim aynı yapılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------
   
import sympy as sp

x = sp.Symbol('x')
print(x, type(x))       # x <class 'sympy.core.symbol.Symbol'>

#------------------------------------------------------------------------------------------------------------------------------------
                                                48. Ders 07/09/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Symbol sınıfıyla oluşturulan sembollerin birtakım özellikleri vardır. Bu özellikler Symbol nesnesi yaratılırken isimli parametrelerle 
    belirlenebilmektedir. Bu isimli parametreler şöyledir:

    real
    imaginary
    positive
    negative
    odd
    even
    prime
    finite
    infinite

    Örneğin:

    x = sp.Symbol('x', real=True)

    İlgili özelliklerin olup olmadığı aşağıdaki özniteliklerle test edilebilir:

    is_real
    is_imaginary
    is_positive
    is_negative
    is_odd
    is_even
    is_prime
    is_finite
    is_infinite

    Örnğin:

    x = sp.Symbol('x', real=True)

    result = x.is_real

    result burada True olacaktır.

    Başlangıçta bu özniteliklerin çoğu False değerdedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Sembollerin görüntülenmesi eğer grafik bir ekranda matematiksel bir biçimde yapılmak isteniyorsa bu durumda işin başında aşağıdaki 
    çağrı yapılmalıdır:

    sp.init_printing()

    Buradaki sp.init_printing() çağrısı komut satırında dğeişkenin ismi yazıldığındaki görüntü üzerinde etkili olmaktadır. Yani başka 
    bir deyişle bu çağrı __repr__ metodunu oluşturmaktadır. Değişkenler print edildiğinde yine text karakterlerle print edilmektedir. 
    Tabii matematiksel ifadelerin grafik ekranda görüntülenebilmesi için ortamın da buna uygun olması gerekmektedir. Örneğin Spyder
    içerisindeki IPython ortamı böyle grafiksel gösterimlere uygundur. Ancak komut satırlarında grafiksel görüntüleme yapılmadığı 
    için semboller Unicode çizim karakterleriyle görüntülenmeye çalışılmaktadır.

    Eğer Spyder IDE'sindeki IPython konsolunda matematiksel ifadeleri programlama yoluyla görüntülemek istiyorsanız bu IPython 
    konsoluna özgü display fonksiyonunu aşağıdaki gibi kullanabilirsiniz:

    from IPython.display import display

    display(expression)
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x = sp.Symbol('x', infinite=True)
y = sp.sqrt(x ** 2 + 5 * x)

print(y)
display(y)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir grup sembol tek hamlede symbols isimli fonksiyonla yaratılabilmektedir. symbols fonksiyonu bizden sembol isimlerine ilişkin 
    bir yazı alır. Bu yazıdaki sembol isimleri boşluklarla ya da virgüllerle ayrılmış olabilir. symbols fonksiyonu bize Symbol 
    nesnelerinden oluşan bir demet vermektedir. Biz bu demeti açıp (unpack yapıp) değişkenlere atayabiliriz. Örneğin:

    x, y, z, k = result = sp.symbols('x y z k')

    Burada biz tek hamlede dört sembol yaratmış olduk.
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp

x, y, z, k = sp.symbols('x, y, z, k')

print(x, y, z, k)

#------------------------------------------------------------------------------------------------------------------------------------
    Fonksiyonlarda geçen sabit değerler de aslında SymPy'da sınıflarla temsil edilmiştir. Örneğin Integer isimli sınıf tamsayı 
    sabitini SymPy sabiti biçiminde tutmaktadır. Örneğin:

    a = sp.Integer(3)

    Buradaki sabit bir string olarak da verilebilirdi:

    a = sp.Integer('3')

    Benzer biçimde float değerler de Float isimli bir sınıfla temsil edilebilmektedir. Örneğin:

    b = sp.Float('1.23456')

    Buradaki parametre string olarak girildiğinde bir yuvarlama hatası oluşmayacaktır. Ancak parametre bir float biçiminde de 
    girilebilir:

    b = sp.Float(1.23456)
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x = sp.Symbol('x')
a = sp.Float('3.456789')

y = a * x ** 2
display(y)

#------------------------------------------------------------------------------------------------------------------------------------
    Bazı özel değerler özel bazı değişken isimleriyle temsil edilmiştir. Örneğin e sayısı sp.E ile, pi sayısı sp.pi ile, sonsuz değeri
    sp.oo ile temsil edilmiştir. Diğer özel değerlerin temsili için SymPy dokümanlarına başvurabilirsiniz. Örneğin:

    >>> sp.pi
    π
    >>> sp.E
    ℯ
    >>> sp.oo
    ∞
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x = sp.pi
display(x)

x = sp.E
display(x)

x = sp.oo
display(x)

#------------------------------------------------------------------------------------------------------------------------------------
   Bir Symbol nesnesi operatörlerle işleme sokulabilmektedir. Bu durumda operatör fonksiyonları devreye girer ve bize çeşitli sınıflar 
   türünden nesneler verir. Örneğin biz sembolü başka bir sembolle ya da sabitle topladığımızda bize Add isimli bir sınıf türünden 
   nesne verilmektedir. Bir sembolü başka bir sembolle ya da bir sabitle çarptığımızda bize Mul isimli bir nesne verilmektedir. Aslında 
   bu sınıfların hepsi Expr isimli bir sınıftan türetilmiştir. Böylece matematiksel ifadeler kütüphane içseirinde içsel olarak bir 
   ağaçla temsil edilebilmektedir:

   Basic (en üst sınıf)
  └── Expr (ifadeler için)
      ├── Add (toplama işlemleri)
      ├── Mul (çarpma işlemleri)  
      ├── Pow (üs alma işlemleri)
      └── diğer matematiksel işlemler
      
   Örneğin:

    >>> x, y = sp.symbols('x, y')
    >>> z = x * y
    >>> type(z)
    <class 'sympy.core.mul.Mul'>
    >>> z = x * y + 2
    >>> type(z)
    <class 'sympy.core.add.Add'>
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp

x = sp.Symbol('x')

result = x * 2
print(result, type(result))     # 2*x <class 'sympy.core.mul.Mul'>

result = x + 2
print(result, type(result))     # x + 2 <class 'sympy.core.add.Add'>

result = x ** 2
print(result, type(result))     # x**2 <class 'sympy.core.power.Pow'>

#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi işlemler sonucunda elde edilen Add, Sub, Mul türünden sınıf nesnelerin anlamı nedir? İşte SymPy aslında bir ifadeyi bir 
    ağaç biçiminde tutmaktadır. Örneğin:

    result = 3 * x + 2

    Burada aslında result nesnesi bu ifadeyi temsil eden ağacın kök düğümüdür. Bu kök düğüm Add sınıfı türündendir. Add sınıfı iki 
    ayrı düğümün adresini tutmaktadır. Bunlardan biri Mul düğümü diğeri de 2 değerini temsil eden Integer düğümüdür:

                             Add
                Mul                       Integer(2)
    Integer(3)       Symbol(x)

    Programcının aslında bu işlemin ağaç bakımından detaylarını bilmesine gerek yoktur. Programcı yalnızca şunu bilmelidir: Aslında 
    bir ifade oluşturduğumuzda bu ifade bir ağaç veri yapısı biçiminde bellekte oluşturulmaktadır ve o ağacın köküne ilişkin bir 
    nesne bize verilmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    İfadelerin sadeleştilmesi simplify isimli fonksiyonla yapılmaktadır. Örneğin:

    >>> x = sp.Symbol('x')
    >>> exp = (3 * x ** 2 - 3 * x) / (3 * x)
    >>> sp.simplify(exp)
    x - 1
    
    Örneğin ifademiz (x ** - 1) / (x + 1) olsun. Bu ifade sadeleştirilirse (x - 1) elde edilecektir:

    >>> x = sp.Symbol('x')
    >>> exp = (x ** 2 - 1) / (x + 1)
    >>> sp.simplify(exp)
    x - 1

    Örneğin:

    >>> exp = ((x ** 2 - x - 12) / (x ** 2 + 8 * x + 15) ) / ((x ** 2 - 5 * x + 4) / (x ** 2 + 3 * x - 10))
    >>> sp.simplify(exp)
    x - 2
    ─────
    x - 1
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x = sp.Symbol('x')
exp = (x ** 2 - 1) / (x + 1)
result = sp.simplify(exp)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda 2 * sin(x) * cos(x) ifadesinin sin(2x) biçiminde sadeleştirildiğini göreceksiniz:

    >>> x = sp.Symbol('x')
    >>> exp = 2 * sp.sin(x) * sp.cos(x)
    >>> sp.simplify(exp)
    sin(2⋅x)

#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x = sp.Symbol('x')
exp = 2 * sp.sin(x) * sp.cos(x)
result = sp.simplify(exp)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda ÖSS sınavında çıkmış olan bir sadeleştirme sorusu çözülmüştür.
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x, y = sp.symbols('x, y')
expression = ((x ** 2 + x - 6) / (x **  2 + 3 * x - 10)) * ((x ** 2 - x * y + 5 * x - 5 * y) / (x ** 2 + x * y + 3 * x + 3 * y))
result = sp.simplify(expression)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
     Aşağıda başka bir ÖSS sadeleştirme sorusu çözülmüştür.
#------------------------------------------------------------------------------------------------------------------------------------

    import sympy as sp
    from IPython.display import display

    sp.init_printing()

    x, y = sp.symbols('x, y')
    expression = ((x / (1 + x)) - (1 / (1 - x))) / ((1 / (1 + x)) + (x / (1 - x)))
    result = sp.simplify(expression)
    display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    expand fonksiyonu simplify fonksiyonunun adeta ters işlemini yapmaktadır. Yani fonksiyon çarpım ifadelerini açar. Örneğin:

    >>> x = sp.Symbol('x')
    >>> exp = (x - 1) * (x + 1)
    >>> sp.expand(exp)
    2
    x  - 1

    Örneğin:

    >>> x = sp.Symbol('x')
    >>> exp = (x - 1) ** 3 * (x - 1)
    >>> sp.expand(exp)
    4      3      2
    x  - 4⋅x  + 6⋅x  - 4⋅x + 1

#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x, y = sp.symbols('x, y')

exp = (x - y) ** 2 + 3 * (x + y) ** 2
result = sp.expand(exp)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında expand fonksiyonlarının özel biçimleri vardır. Bunlar ilgili konuda açım uygularlar. Örneğin biz trigonometrik bir açım 
    yapacaksak expand_trig fonksiyonunu kullanırız. Yani aslında expand fonksiyonu bu özel fonksiyonları kullanıp daha karmaşık açımları 
    yapmaya çalışmaktadır. expand ile yapamadığınız işlemleri bunlarla yapabilirsiniz. Bunların listesi şöyledir:

    expand_log
    expand_mul
    expand_multinomial
    expand_complex
    expand_trig
    expand_power_base
    expand_power_exp
    expand_func

#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x = sp.Symbol('x')
exp = sp.sin(2 * x)

result = sp.expand_trig(exp)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Örneğin logaritmik açım için expand_log fonksiyonu kullanılır.
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

x = sp.Symbol('x')
expression = sp.log(2 * x)
result = sp.expand_log(expression)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Çarpanlara ayırma da çok karşılaşılan işlemlerdendir. Bu işlem factor isimli fonksiyonla yapılmaktadır. Örneğin:

    >>> x = sp.Symbol('x')
    >>> exp = x ** 2 - 1
    >>> sp.factor(exp)
    (x - 1)⋅(x + 1)

#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x = sp.Symbol('x')
exp = x ** 2 - 1
result = sp.factor(exp)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda daha karmaşık bir çarpanlara ayırma örneği verilmiştir:

    >>> x = sp.Symbol('x')
    >>> exp = x ** 3 + 6 * x ** 2 + 5 * x
    >>> sp.factor(exp)
    x⋅(x + 1)⋅(x + 5)

#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x = sp.Symbol('x')
exp = x ** 3 + 6 * x ** 2 + 5 * x
result = sp.factor(exp)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir ifadenin sonucunu hesaplamak için subs (substitute) isimli metot kullanılmaktadır. Metodun basit kullanımında birinci parametre
    değeri yerleştirilecek değişkeni, ikinci parametre onun değerini belirtir. Örneğin:

    >>> x = sp.Symbol('x')
    >>> exp = 3 * (x - 1) ** 3 + 2
    >>> exp.subs(x, 2)
    5
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp

x = sp.Symbol('x')
exp = 3 * (x - 1) ** 3 + 2
result = exp.subs(x, 2)
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Eğer ifadede birden fazla değişken için yerleştirme yapılması isteniyorsa bu durumda dolaşılabilir bir nesne içerisinde iki 
    elemanlı dolaşılabilir nesnelerin kullanılması gerekir (örneğin iki elemanlı demetlerden oluşan listeler gibi). Örneğin:

    >>> x, y = sp.symbols('x y')
    >>> exp = 3 * (x - 1) ** 2 + 2 * (y + 1) ** 3
    >>> exp.subs([(x, 2), (y, 1)])
    19

#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp

x = sp.Symbol('x')
y = sp.Symbol('y')

exp = x ** 2 - 3 * y + 2
result = exp.subs([(x, 1), (y, 2)])

print(result)       # -3
    
#------------------------------------------------------------------------------------------------------------------------------------
   evalf isimli metot sp.pi gibi sp.e gibi özel değerleri sayısal değerlerle değiştir. Ancak ifade içerisindeki sembollere
   dokunmaz. subs metodu ise özel değerleri açmamaktadır. Bu nedenle bazen bu iki metodun bir arada kullanılması gerekebilmektedir. 
   Örneğin:

   >>> x = sp.Symbol('x')
    >>> exp = 2 * x * sp.pi + 3 - 2 * sp.E - x
    >>> exp.subs(x, 2)
    -2⋅ℯ + 1 + 4⋅π
    >>> exp.subs(x, 2).evalf()
    8.12980695744108
    >>> exp.evalf()
    5.28318530717959⋅x - 2.43656365691809
    >>> exp.evalf().subs(x, 2)
    8.12980695744108
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp

x, y, z = sp.symbols('x, y, z')

f = sp.pi * x ** 2 - 3 * y + 2 * z
result = f.subs([(x, 2), (y, 3), (z, -1)])
print(result)

result = f.subs([(x, 2), (y, 3), (z, -1)]).evalf()
print(result)

f = sp.log(x ** 2)

result = f.subs(x, 2).evalf()
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    lambdify isimli fonksiyon bizden sembolü ve ifadeyi argüman olarak alır. Bize bir Python fonksiyonu verir. Biz artık o fonksiyonu 
    çağırdığımızda adeta evalf ve subs işlemleri yapılıp bunun sonucu elde edilmiş olacaktır. Yani biz bu fonksiyon sayesinde SymPy 
    dünyasından çıkıp Python dğnyasına geri dönebiliriz. lambdify fonksiyonu bizden değişkeni ve ifadeyi parametre olarak 
    alır. Örneğin:

    x = sp.Symbol('x')
    exp = 3 * x ** 2 - sp.pi + 2
    f = sp.lambdify(x, exp)

    result = f(3)
    print(result)

    Burada lambdify fonksiyonun nasıl çağrıldığına dikkat ediniz:

    f = sp.lambdify(x, exp)

    Biz bu çağrıda fonksiyona şunları demekteyiz: "Ben fbana verdiğin fonksiyona x iin bir argüman gireceğim. Sen bu argmanı x olarak 
    kabul edip bu ifadeye sok ve ifadeden elde edilen geri dönüş değerini bana ver". Örneğimizdeki lambdify fonksiyonunun verdiği 
    fonksiyonun naısl çağrıldığına dikkat ediniz:

    result = f(3)

    Aslında biz buradan 3 * 9 - pi + 2 değerini elde etmiş olacağız. 

    Eğer ifadede birdne fazla değişken varsa bu değişkenlerin lambdify fonksiyon birinci argümanında demet biçiminde verilmesi 
    gerekir. Örneğin:

    x, y, z = sp.symbols('x y z')
    exp = 3 * x ** 2 - 5 * y + z

    f = sp.lambdify((x, y, z), exp)

    result = f(1, 2, 3)
    print(result)           # -4

#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp

x, y, z = sp.symbols('x y z')
exp = 3 * x ** 2 - 5 * y + z

f = sp.lambdify((x, y, z), exp)

result = f(1, 2, 3)
print(result)           # -4

#------------------------------------------------------------------------------------------------------------------------------------
    Sembolik (belirsiz) türev alma işlemi matemetikte sıkça karşımıza çıkmaktadır. Bir fonksiyonun belli bir noktadaki türevinin 
    sayısal değerinin bulunması çeşitli "nümerik analiz" yöntemleriyle kolay bir biçimde elde edilebilmektedir. Ancak bir fonksiyonun 
    türev fonksiyonunu sembolik bir biçimde elde etmek matematikte daha sık kullanılmaktadır. SymPy'da türev işlemi için diff isimli 
    fonksiyon bulundurulmuştur. diff fonksiyonunun birinci parametresi türevi alınacak ifadeyi, ikinci parametresi türevin hangi 
    değişkene göre alınacağını belirtmektedir. Örneğin:

    >>> x = sp.Symbol('x')
    >>> f = 3 * x ** 5 - 5 * x ** 3 + 2 * x - 1
    >>> sp.diff(f, x)
        4       2
    15⋅x  - 15⋅x  + 2

    Örneğin:

    >>> x = sp.Symbol('x')
    >>> f = 3 * sp.sin(x) ** 2
    >>> sp.diff(f, x)
    6⋅sin(x)⋅cos(x)
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

x = sp.Symbol('x')
f = 3 * x ** 5 - 5 * x ** 3 + 2 * x - 1

result = sp.diff(f, x)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Çok değişkenli fonksiyonlarda türev değişkenlerin herhangi birine göre alınabilmektedir. Bu durumda diğer değişkenler sanki sabit 
    sayılarmış gibi işleme sokulmaktadır. Buna "kısmi türev (partial derivative)" denilmektedir. Özellikle doğrusal olmayan optimizasyon 
    problemlerinde çok değişkenli fonksiyonların her değişkene göre parçalı türevleri alınarak bir vektör elde edilmektedir. Bu vektöre 
    "gradyen vektör" denilmektedr. Bu gradyen vektör fonksiyonun maksimum ve minimum noktalarını bulmak için kullanılmaktadır. 

    Sympy'da parçalı türevler yukarıdaki gibi uygulanmaktadır. Tabii istenirse önce bir değişkene göre türev alıp sonra başka 
    değişkene göre de türev alınabilir. Örneğin:

    >>> x, y = sp.symbols('x y')
    >>> f = 3 * x ** 2 * 2 * y - 5 * x * y + 2

    Burada f fonksiyonu iki değişkenli bir fonksiyondur. Biz bu fonksiyonn x'e göre parçalı türevini alalım. Matematikte parçalı 
    türevler matematikte ∂f/∂x biçiminde gösterilmektedir. 

    >>> sp.diff(f, x)
    12⋅x⋅y - 5⋅y

    Şimdi de aynı fonksiyonun y'ye göre türeviniz alalım. Yani ∂f/∂y işlemini yapalım:

    >>> sp.diff(f, y)
       2
    6⋅x  - 5⋅x

    Şimdi de önce x'göre sonra y'ye göre parçalı türev alalım. Yani ∂²f/∂y∂x işlemini yapalım. Bubu tek hamlede aşağıdaki gibi 
    yapabiliriz:

    >>> sp.diff(f, x, y)
    12⋅x - 5
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

x, y = sp.symbols('x y')

f = 3 * x ** 2 * 2 * y - 5 * x * y + 2

result = sp.diff(f, x)
print(result)

result = sp.diff(f, y)
display(result)

result = sp.diff(f, x, y)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Sembolik integralin (belirsiz integral de denilmektedir) matematikte yaygın bir kullanım alanı vardır. Grafiksel olarak integral 
    eğri altında kalan alanı veren bir işlemdir. SymPy'da integrate fonksiyonu ile belirsiz integral işlemleri yapılabilmektedir. 
    intergate fonksiyonunun kullanılması diff fonksiyonundaki gibidir. Aşağıda f(x) = (x - 1) fonksyonunun integrali bulunmuştur:

    >>> x = sp.Symbol('x')
    >>> f = x - 1
    >>> sp.integrate(f, x)
     2
    x
    ── - x
    2
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

x = sp.Symbol('x')

f = x - 1

result = sp.integrate(f, x)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Python'da istatistik, veri bilimi ve makine öğrenmesi alanlarında yaygın biçimde kullanılan Pandas kütüphanesini ele 
    alacağız. Pandas kütüphanesi Numpy kütüphanesinin üzerine oturtulmuştur. Kütüphane NumPy kütüphanesinin sunduğu pek çok olanağa
    sahiptir. Pandas'ın en önemli özelliği farklı türlerden sütunlara sahiğ veri kümelerini DataFrame adı altında temsil edebilmesidir. 
    NumPy'da bir NumPy dzisinin tüm elemanlarının aynı dtype türünden olması gerektiğini anımsayınız. Halbuki istatiste, veri biliminde
    e makine öğrenmesinde kullanılan veri kümeleri farklı sütun türlerine sahip olabilmektedir. Örneğin sütunlardan biri kişilerin 
    boy uzunluklarını, diğeri yaşlarını, diğeri kilolarını ve diğeri de cinsiyetlerini belirtiyor olabilir. NumPy kısmında bu tür 
    CSV dosyalarının NumPy dizisi haline getirilmesinin ne kadar zor olduğunu görmüştük. İşte Pandas bize farklı sütun türlerine 
    sahip veri kümeleri üzerinde çalışma olanağı sağlamaktadır. Pandas kütüphanesi aslında uygulamacılar tarafından NumPy kütüphanesinden
    daha yaygın kullanılmaktadır. Birtalkım işlemler yapıldıktan sonra Pandas nesneleri NumPy dizilerine dönüştürülüp işlemere 
    NumPy le de devam edilebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
   Pandas kütüphanesi Anaconda dağıtımında dağıtımla birlikte zaten kurulmuş durumdadır. Ancak yeni bir sanaş ortam oluşturduğunuzda 
   Pandas kurulumunu pip programı ile aşağıdaki gibi yapabilirsiniz:

   pip install pandas

   Pandas kütüphanesi programcılar tarafından geleneksel olarak pd ismiyle import edilmektedir. Örneğin:

   import pandas as pd 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Pandas'ta sütunlardan ve satırlardan oluşan veri kümeleri DataFrame isimli bir sınıf ile temsil edilmektedir. Veri kümesindeki 
    belli bir sütun ise Series isimli sınıfla temsil edilmiştir. Yani DataFrame sınıfını Series nesnelerini tutan bir sınıf gibi 
    düşünebiliriz. Biz kurusumuzda önce Series sınıfını ele alıp inceleyeceğiz. Pandas temel bazı yeteneklerini bu sınıf üzerinde 
    tanıtacağız. Sonra DataFrame sınıfını ele alıp açıklayacağız. Pandas büyük ölçüde Series ve DataFrame sınıflarının kullanımı 
    ile ilgilidir.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Series nesnesi dolaşılabilir bir nesne ile Series sınıfının __init__ metoduyla oluşturulabilir. Buradaki dolaşılabilir nesne 
    bir Python listesi, demeti olabileceği gibi bir Numpy dizisi de olabilir. Örneğin:

    >>> s = pd.Series([1, 2, 3, 4, 5])
    >>> s
    0    1
    1    2
    2    3
    3    4
    4    5
    dtype: int64
    >>> a = np.random.rand(10)
    >>> s = pd.Series(a)
    >>> s
    0    0.839374
    1    0.494721
    2    0.386717
    3    0.095209
    4    0.163746
    5    0.549368
    6    0.453674
    7    0.052371
    8    0.868359
    9    0.038974
    dtype: float64
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import pandas as pd

s = pd.Series([1, 2, 3, 4, 5, 6])
print(s)

a = np.array([1, 2, 3, 4, 5])
s = pd.Series(a)
print(s)

#------------------------------------------------------------------------------------------------------------------------------------
   Series nesnelerinin de tıpkı NumPy dizilerinde olduğu gibi bir dtype türü vardır. Bir Series nesnesi yaratılırken nesnenin dtype 
   türü dtype parametresiyle belirtilebilir. Pandas'a özgü ayrı dtype türleri yoktur. Aslında Pandas Series bilgilerini NumPy dizisi 
   olarak saklamaktadır. Dolayısıyla Series nesnesi yaratılırken dtype bilgisi NumPy'ın dtype türü olarak belirtilir. Örneğin:
 
    >>> s = pd.Series([1, 2, 3, 4, 5], dtype=np.float32)
    >>> s
    0    1.0
    1    2.0
    2    3.0
    3    4.0
    4    5.0
    dtype: float32

   Tabii burada dtype belirtilirken np.float32 gibi bir ifade kullanılacaksa NumPy kütüphanesinin de import edilmesi gerekir. Ancak 
   bunun yerine programcı dtype türünü Numpy'da olduğu gibi yazısal da belirtebilmektedir. Bu durumda Numpy kütüphanesinin import 
   edilmesine gerek kalmaz. Örneğin:

    >>> s = pd.Series([1, 2, 3, 4, 5], dtype='float32')
    >>> s
    0    1.0
    1    2.0
    2    3.0
    3    4.0
    4    5.0
    dtype: float32

   Eğer Series nesnesi zaten NumPy dizisi ile oluşturuluyorsa ve dtype belirtilmemişse Numpy dizisindeki dtype bilgisi kullanılır. Diğer 
   durumlarda NumPy'da olduğu gibi eğer Series fonksiyonuna verilen tüm elemanlar int türdense dtype türü 'int64' olarak en az bir 
   eleman float türündense 'flaot64' olarak alınmaktadır. Örneğin:

   >>> a = np.array([1, 2, 3, 4, 5], dtype='float32')
   >>> a
    array([1., 2., 3., 4., 5.], dtype=float32)
    >>> s = pd.Series(a)
    >>> s
    0    1.0
    1    2.0
    2    3.0
    3    4.0
    4    5.0
    dtype: float32

    >>> s = pd.Series([1, 2, 3, 4, 5])
    >>> s
    0    1
    1    2
    2    3
    3    4
    4    5
    dtype: int64
    >>> s = pd.Series([1.2, 2, 3, 4, 5])
    >>> s
    0    1.2
    1    2.0
    2    3.0
    3    4.0
    4    5.0
    dtype: float64

    Series nesneleri tek boyutlu bir kavram belirtmektedir. Dolayısıyla biz çok boyutlu bir NumPy dizisini Series nesnesi haline getiremeyiz.
    
    Series sınıfının yine dtype isimli örnek özniteliği bize Series nesnesinin dtype bilgisini vermektedir. Örneğin:

    >>> s = pd.Series([1, 2, 3, 4, 5], dtype='float32')
    >>> s
    0    1.0
    1    2.0
    2    3.0
    3    4.0
    4    5.0
    dtype: float32
    >>> s.dtype
    dtype('float32')

    Yukarıda da belirttiğmiz gibi Series nesnesi yaratılırken verilen değerlerin normal olarak tek boyutlu olması gerekir. Ancak biz 
    Series fonksiyonuna bir liste listesi gibi iki boyutlu bir nesne verirsek bu durumda aslında Series nesnesi tek boyutlu olur. 
    Onun her elemanı bir listeyi tutar hale gelir. Böyle Series nesnelerinin dtype türü de object olmak zorudadır. object dtype türü 
    ile "elemanları farklı türlerden olabilen" Series nesneleri oluşturulabilmektedir. Örneğin:

    >>> s = pd.Series([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> s
    0    [1, 2, 3]
    1    [4, 5, 6]
    2    [7, 8, 9]
    dtype: object

    Örneğin:

    >>> s = pd.Series(['ali', 3.5, 123])
    >>> s
    0    ali
    1    3.5
    2    123
    dtype: object

    Ancak genel olarak Series nesnelerinin bu biçimde object türü altında farklı nesneleri tutması arzu edilen bir durum değildir. 

    Yukarıda da belirttiğimiz gibi Series nesnesinin yaratımında çok boyutlu NumPy dizileri kullanılamamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import pandas as pd

s = pd.Series([1, 2.4, 3, 4, 5, 6])
print(s.dtype)          # float64

a = np.array([1, 2, 3, 4, 5], dtype=np.float32)
s = pd.Series(a)
print(s.dtype)          # float32

s = pd.Series([1, 2, 3, 4, 5], dtype='float64')
print(s.dtype)          # float64

#------------------------------------------------------------------------------------------------------------------------------------
                                            49.Ders 13/09/2025-Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir CSV dosyasından hareketle bir DataFrame nesnesi elde edildiğinde DataFrame nesnelerin bazı sütunları yazı içerebilmektedir. 
    Yani Series nesnelerinin dtype türünün nümerik değil yazısal olması durumuyla sık karşılaşılmaktadır. Bu tür durumlarda genellikle
    Seriees nesnesinin dtype türü "object" biçiminde karşımıza çıkar. Ancak yazıları saklamak için aslında "string" dtype türü daha 
    uygundur. Bu "string" dtype türünü Payhın'un "str" türü ile karıştırmayınız. Ancak yine de yazıların object dtype türü ile 
    karşımıza çıkmasında bir sakınca yoktur. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Series nesnesi sütun değerlerinin yanı sıra aynı zamanda index değerlerine de sahiptir. İndex değerleri belirtilmediyse 0'dan 
    başlayan ardışıl tamsayılar index değeri olarak kullanılır. Örneğin:

    >>> import pandas as pd
    >>> s = pd.Series([10, 20, 30, 40, 50], dtype='float32')
    >>> s
    0    10.0
    1    20.0
    2    30.0
    3    40.0
    4    50.0
    dtype: float32

    index'leri istediğimiz biçimde set etmek için Series nesnesi yaratılırken (yani Series sınıfının __init__ metodunda) index 
    parametresini kullanabiliriz. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'], dtype='float32')
    >>> s
    a    10.0
    b    20.0
    c    30.0
    d    40.0
    e    50.0
    dtype: float32

    index parametresi bir liste, demet gibi dolaşılabilir bir nesne biçiminde girilebilir. Ancak string'ler dolaşılabilir bir nesne 
    olduğu halde biz string giremeyiz. Aşağıdaki yaratım exception oluşturur:

    s = pd.Series([10, 20, 30, 40, 50], index='abcde', dtype='float32')

    Ancak bu işlemi şöyle yapabiliriz:

    s = pd.Series([10, 20, 30, 40, 50], index=list('abcde'), dtype='float32')
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Series nesnesinin index bilgisini almak için index özniteliği kullanılabilir. Aynı zamanda index özniteliğine biz daha sonra değer 
    de atayabiliriz. Bu durumda index bilgisini değiştirmiş oluruz. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], dtype='float32')
    >>> s
    0    10.0
    1    20.0
    2    30.0
    3    40.0
    4    50.0
    dtype: float32
    >>> s.index
    RangeIndex(start=0, stop=5, step=1)
    >>> s.index = ['a', 'b', 'c', 'd', 'e']
    >>> s
    a    10.0
    b    20.0
    c    30.0
    d    40.0
    e    50.0
    dtype: float32

    Ancak index bilgisinin belli bir elemanına değer atayamayız. Örneğin:

    >>> s.index[2] = 'x'
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "C:\Users\aslan\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\indexes\base.py", line 5383, in __setitem__
        raise TypeError("Index does not support mutable operations")
    TypeError: Index does not support mutable operations

    Yukarıda da belirttiğimiz gibi genellikle index değerleri dizi indeksleri gibi 0'dan itibaren tamsayılar biçiminde karşımıza 
    çıkmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    Series nesnelerinin elemanlarına erişmek için üç yol vardır. Series nesnesi s olmak üzere:

    1) Doğrudan köşeli parantez operatörü ile. Yani s[...] biçiminde.
    2) loc özniteliği ve köşeli parantez operatörü ile. Yani s.loc[...] biçiminde
    3) iloc özniteliği ve köşeli parantez operatörü ile. Yani s.iloc[...] biçiminde

    Biz s[...] erişimine  doğrudna indeksleme, s.loc[...] erişimine loc indekslemesi ve s.iloc[...] erişimine ise iloc indekslemesi 
    diyeceğiz. 

    Series nesneleri "değiştirilebilir (mutable)" nesnelerdir. Bir Series nesnesine erişip onu değiştirebiliriz. 

    Series nesnelerinin index belirten eğerlerine) "etiket (label)" de denilmektedir. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=['ali', 'veli', 'selami', 'ayşe', 'fatma'], dtype='float32')
    >>> s
    ali       10.0
    veli      20.0
    selami    30.0
    ayşe      40.0
    fatma     50.0
    dtype: float32

    Burada indeks belirten "ali", "veli", "selami", "ayşe" ve "fatma" değerlerine "etiket (label)" de denilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    Doğrudan köşeli parantez ile elemana erişmede köşeli parantez içerisindeki değerin önce etiket olup olmadığına bakılır. Eğer 
    bu değer bir etiket ise o etiketin değerine erişilir. Eğer köşeli parantez "içerisindeki değer bir etiket değilse ve etiketlerin 
    hiçbiri int türden değilse" bu durumda ilk eleman sıfır olmak üzere sıra numarasıyla erişim yapılır. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'], dtype='float32')
    >>> s
    a    10.0
    b    20.0
    c    30.0
    d    40.0
    e    50.0
    dtype: float32
    >>> s['c']
    30.0
    >>> s[3]
    40.0

    Ancak sayısal olmayan etiketlere sayısal bir indeks ile doğrudna köşeli parantezle erişmek "deprecated" yapılmıştır. Yeni Pandas
    sürümlerinde "deprecated" uyarısı verilmektedir. Dolayısıyla ileride doğrudan s[...] eişimi ile s.loc[...] erişimi arasında bir 
    fark kalmamaktadır. 

    Doğrudan indekslemede eğer index olarak kullanılan etiketlerde sayısal değerler varsa bu durumda doğrudan köşeli parantez ile 
    sırasal erişim yapılamamktadır. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=['ali', 'veli', 1, 'selami', 'ayşe'], dtype='float32')
    >>> s
    ali       10.0
    veli      20.0
    1         30.0
    selami    40.0
    ayşe      50.0
    dtype: float32
    >>> s[1]
    30.0
    >>> s[0]
    Traceback (most recent call last):
    File "C:\ProgramData\Anaconda3\lib\site-packages\pandas\core\indexes\base.py", line 3361, in get_loc
        return self._engine.get_loc(casted_key)
    File "pandas\_libs\index.pyx", line 76, in pandas._libs.index.IndexEngine.get_loc
    File "pandas\_libs\index.pyx", line 108, in pandas._libs.index.IndexEngine.get_loc
    File "pandas\_libs\hashtable_class_helper.pxi", line 5198, in pandas._libs.hashtable.PyObjectHashTable.get_item
    File "pandas\_libs\hashtable_class_helper.pxi", line 5206, in pandas._libs.hashtable.PyObjectHashTable.get_item
    KeyError: 0

    Tabii asıl olan elemanlara etiketler kullanılarak erişilmesidir. 

    Yukarıda da belirttiğimiz gibi eskiden doğrudan indeksleme "eğer böyle bir etiket varsa o etiketin belirttiği 
    değere eriş, yoksa sırasal eriş" anlamına geliyordu. Ancak artık doğrudan indeksleme ile "sırasal erişme"
    "deprecated" yapıldığı için ver ileride kaldırılabileceği için doğrudan indeksleme ile izleyen paragraflarda 
    açıklayacağımız loc indekslemesi arasında bir fark kalmamıştır.
----------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    s.loc[...] biçimindeki loc indekslemesinde erişimde her zaman köşeli parantez içerisindeki ifadenin bir etiket belirtmesi gerekir.  
    Yani bu indekslemede her zaman etiket dikkate alınmaktadır. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=list('abcde'), dtype='float32')
    >>> s
    a    10.0
    b    20.0
    c    30.0
    d    40.0
    e    50.0
    dtype: float32

    Burada indeksler birer harften oluşmaktadır. Biz bu Series nesnesinin elemanına s.iloc[...] ile erişeceksek köşeli parantezlerin
    içerisine etiket yerleştirmeliyiz. Sıra numarası yerleştiremeyiz. Örneğin:

    >>> s.loc['a']
    10.0
    >>> s.loc['e']
    50.0

    Yani loc özniteliği ile erişimde köşeli parantez içerisinde her zaman etiket bulundurulması gerekmektedir. Yukarıda da belirttiğimiz
    gibi eskiden doğrudan indeksleme ile loc indekslemesi arasında fark vardı. Ancak yukarıda belirttiğimiz "deprecated" durum yüzünden
    artık bir fark kalmamıştır. 

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    s.iloc[...] biçimindeki iloc indekslemesinde köşeli parantez içerisine her zaman sıra numarası belirten int bir değer yerleştirilmek 
    zorundadır. Erişim de her zaman listelerde olduğu gibi elemanın indeks numarasına göre yapılır. iloc indekslemesinde köşeli parantez 
    içerisine etiket yerleştiremeyiz. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=list('abcde'), dtype='float32')
    >>> s[2]
    30.0
    >>> s[3]
    40.0
    >>> s.iloc['e']
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "C:\Users\CSD\anaconda3\lib\site-packages\pandas\core\indexing.py", line 967, in __getitem__
        return self._getitem_axis(maybe_callable, axis=axis)
    File "C:\Users\CSD\anaconda3\lib\site-packages\pandas\core\indexing.py", line 1517, in _getitem_axis
        raise TypeError("Cannot index by location index with a non-integer key")
    TypeError: Cannot index by location index with a non-integer key

    Özetle biz erişimi s.loc biçiminde yapıyorsak köşeli parantez içerisine etiket yerleştirmek zorundayız. Biz erişimi s.iloc[...] 
    biçiminde yapıyorsak köşeli parantez içerisine sıra numarası yerleştirmek zorundayız. Ancak biz erişim s[...] biçiminde yapıyorsa 
    köşeli parantez içerisine etiket ya da sıra numarası yerleştirebiliriz. Ancak bu sıra numarası eğer hiçbir eleman int türden değilse 
    kullanılabilmektedir. Fakat "deprecated" meslesi yüzünden artık s[...] erişimi ile s.loc[...] erişimi arasında bir fark kalmayacaktır. 
    Genellikle programcılar s.loc[...] ve s.iloc[...] erişimlerini kullanırlar.

    Yukarıda da belirttiğimiz gibi default durumda zaten etiketler 0'dan itibaren tamsayılar biçiminde karşımıza çıkmaktadır. Bu 
    durumda loc indekslemesiyle iloc indeskelemesi arasında bir farklılık oluşmamaktadır. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50])
    >>> s
    0    10
    1    20
    2    30
    3    40
    4    50
    dtype: int64
    >>> s.loc[3]
    np.int64(40)
    >>> s.iloc[3]
    np.int64(40)
    >>> s[3]
    np.int64(40)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Doğrudan, loc ile ya da iloc ile indeksleme yaparken birden fazla index dolaşılabilir bir nesne biçiminde verilebilir. Bu durumda 
    o indeksteki elemanlardan bir Series nesnesi elde edilmektedir. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'], dtype='float32')
    >>> s[[1, 3, 4]]
    b    20.0
    d    40.0
    e    50.0
    dtype: float32
    >>> s[['c', 'a', 'e']]
    c    30.0
    a    10.0
    e    50.0
    dtype: float32
    >>> s.loc[['a', 'e', 'b']]
    a    10.0
    e    50.0
    b    20.0
    dtype: float32
    >>> s.iloc[[1, 3, 2]]
    b    20.0
    d    40.0
    c    30.0
    dtype: float32

    Bu tür erişimlerden bir view nesnesi elde edilmemektedir. Yeni bir Series nesnesi elde edilmektedir.  Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], dtype='float32')
    >>> s
    0     10.0
    1     20.0
    2     30.0
    3     40.0
    4     50.0
    5     60.0
    6     70.0
    7     80.0
    8     90.0
    9    100.0
    dtype: float32
    >>> k = s.iloc[[3, 5, 7]]
    >>> k
    3    40.0
    5    60.0
    7    80.0
    dtype: float32
    >>> k[0] = 1000
    >>> s
    0     10.0
    1     20.0
    2     30.0
    3     40.0
    4     50.0
    5     60.0
    6     70.0
    7     80.0
    8     90.0
    9    100.0
    dtype: float32

    Bu örnekte k'da değişiklik yapıldığında s'te bu değişiklik görülmemektedir. O halde burada bir view nesnesi söz konusu değildir. 

    Anımsanacağı gibi Python'da a[(1, 2, 3, 4, 5)] iafdesi ile a[1, 2, 3, 4, 5] şfadesi tamamen aynı anlama gelmektedir. Pandas'ta 
    a[1, 2, 3, 4, 5] gibi bir erişim çok boyutlu erişim anlamına geldiği için biz birden çok indeksi köşeli parantez içerisinde demet
    biçiminde veremeyiz. 

    Doğrudan indekslemede hem etiket hem de sıra numarası bir arada kullanılamz. Ancak bunlardan biri kullanılabilir. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'], dtype='float32')
    >>> k = s[['b', 'a', 'e']]
    >>> k
    b    20.0
    a    10.0
    e    50.0
    dtype: float32
    >>> k = s[[1, 3, 0]]
    >>> k
    b    20.0
    d    40.0
    a    10.0
    dtype: float32
    >>> k = s[['a', 3, 0]]
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
        
    File "C:\Users\CSD\anaconda3\lib\site-packages\pandas\core\indexes\base.py", line 5845, in _raise_if_missing
        raise KeyError(f"{not_found} not in index")
    ...
    KeyError: '[3, 0] not in index'

    Tabii yukarıda da belirtitğimiz gibi zaten doğrudan indeksleme artık loc indekslemesi ile aynı anlama gelmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd

s = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'], dtype='float32')
print(s)          

result = s[[1, 3, 4]]
print(result)

result = s[['a', 'c', 'd']]
print(result)

result = s.loc[['a', 'd', 'e']]
print(result)

result = s.iloc[[1, 3, 4]]
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Birden çok elemana erişerek atama da yapılabilmektedir. Bu durumda bu işlemden ilgili indekslerdeki tüm eelmanlar etkilenir. 
    Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], dtype='float32')
    >>> s[[3, 5, 7]] = 1000
    >>> s
    0      10.0
    1      20.0
    2      30.0
    3    1000.0
    4      50.0
    5    1000.0
    6      70.0
    7    1000.0
    8      90.0
    9     100.0
    dtype: float32
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Doğrudan, loc ile ya da iloc ile bool indeksleme de yapılabilmektedir. Yani biz bir Series nesnesinin belli elemanlarını bool 
    değerlerden oluşan dolaşılabilir bir nesne ile elde edebiliriz. Bu durumda True olan indekslere karşı gelen elemanlar elde edilmektedir. 
    bool indeksleme söz knusu olduğunda indesklemnin doğrudan, loc ile ya da iloc ile yapılması arasında bir farklılık oluşmamaktadır. 
    Yani bool indeskleme doğrudan, loc ile ya da iloc ile yapılabilmektedir. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'], dtype='float32')
    >>> s[[True, False, True, True, False]]
    a    10.0
    c    30.0
    d    40.0
    dtype: float32
    >>> s.loc[[True, False, True, True, False]]
    a    10.0
    c    30.0
    d    40.0
    dtype: float32
    >>> s.iloc[[True, False, True, True, False]]
    a    10.0
    c    30.0
    d    40.0
    dtype: float32
    
    NumPy dizilerinde olduğu gibi bool indekslemenin en önemli faydası filtreleme yapılabilmesidir. Belli koşulu sağlayan elemanlar 
    bu biçimde elde edilebilmektedir. Sonraki paragraflarda da ele alacağımız gibi bir Series nesnesi üzerinde karşılaştırma operatörlerini 
    uygularsak bool bir Series nesnesi elde ederiz. Örneğin:

    >>> s > 30
    a    False
    b    False
    c    False
    d     True
    e     True
    dtype: bool

    Bu sayede buradan elde edilen bool türden Seris nesnesi Series nesnesini filtrelemek için bool indekslemede kullanılabilir. 
    Örneğin:    

    >>> s[s > 30]
    d    40.0
    e    50.0
    dtype: float32
    >>> s.loc[s > 30]
    d    40.0
    e    50.0
    dtype: float32
    >>> s.iloc[s > 30]

    Ancak özel bir durum olarak dtype türü bool olan Series nesnesi ile iloc indekslemesi yapılamamakatdır. Örneğin:

    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "C:\ProgramData\Anaconda3\lib\site-packages\pandas\core\indexing.py", line 931, in __getitem__
        return self._getitem_axis(maybe_callable, axis=axis)
    File "C:\ProgramData\Anaconda3\lib\site-packages\pandas\core\indexing.py", line 1552, in _getitem_axis
        self._validate_key(key, axis)
    File "C:\ProgramData\Anaconda3\lib\site-packages\pandas\core\indexing.py", line 1400, in _validate_key
        raise ValueError(
    ValueError: iLocation based boolean indexing cannot use an indexable as a mask
#------------------------------------------------------------------------------------------------------------------------------------
 
import pandas as pd

s = pd.Series([3, 56, 12, 34, 21], dtype='float32')

k = s[s > 20]
print(k)

#------------------------------------------------------------------------------------------------------------------------------------
    Series nesnesinin içerisindeki değerler nesnenin values özniteliği ile bir NumPy dizisi olarak elde edilebilmektedir. Aslında 
    Series nesneleri, zaten değerleri NumPy dizisi içerisinde tutmaktadır. values elemanı da bize doğrudan aslında bu diziyi verir. 
    Bu dizide değişiklik yaptığımızda Series nesnesinin elemanında değişiklik yapmış oluruz. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], dtype='float32')
    >>> a = s.values
    >>> s
    0    10.0
    1    20.0
    2    30.0
    3    40.0
    4    50.0
    dtype: float32
    >>> a
    array([10., 20., 30., 40., 50.], dtype=float32)
    >>> a[0] = 100
    >>> s
    0    100.0
    1     20.0
    2     30.0
    3     40.0
    4     50.0
    dtype: float32

    Yani values örnek özniteliği zaten Series nesnesinin içerisinde tutulan NumPy dizisinin adresini bize vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------
  
import pandas as pd

s = pd.Series([3, 56, 12, 34, 21], dtype='float32')

a = s.values

print(a)

a[2] = 1000

print(s)

#------------------------------------------------------------------------------------------------------------------------------------
    Series nesnesinin sonuna eleman eklemek için eskiden Series sınıfının append metodu kullanıyordu. Sonra bu metot kaldırıldı. Artık 
    Series nesnesinin sonuna ekleme için concat fonksiyonu kullanılmaktadır. Aslında concat fonksiyonu DataFrame nesneleriyle de çalışmaktadır. 
    Biz burada concat fonksiyonuna Series nesnelerinden oluşan bir demet veriririz. Fonksiyon da bu Series nesnelerini birleştirerek 
    yeni bir Series nesnesi verir. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], dtype='float32')
    >>> k = pd.Series([100, 200], dtype='float32')
    >>> result = pd.concat((s, k))
    >>> result
    0     10.0
    1     20.0
    2     30.0
    3     40.0
    4     50.0
    0    100.0
    1    200.0
    dtype: float32

    Burada iki Series nesnesinin etiketlerinin de birleştirmeye dahil edildiğine dikkat ediniz. Böylece sonuçta aynı etiketlere sahip 
    elemanlardan oluşan bir Series nesnesi elde edilebilmektedir. Böylesi bir durumda etiket verilerek indeksleme yapıldığında (yani 
    doğrudan ya da loc indekslemesi yapıldığında) aynı değerden oluşan birden fazla eleman elde edilmektedir. Örneğin:
    
   >>> result[0]
    0     10.0
    0    100.0

    >>> result.loc[1]
    1     20.0
    1    200.0
    dtype: float32

    Ancak iloc indekslemesinde sıra numarası veridliği için ve her elemanın sıra numarası farklık olduğu için elemanlara tek tek 
    erişilebilmektedir. Örneğin:

    >>> result
    0     10.0
    1     20.0
    2     30.0
    3     40.0
    4     50.0
    0    100.0
    1    200.0
    dtype: float32
    >>> result.iloc[0]
    10.0
    >>> result.iloc[5]
    100.0

    concat işlemiyle elde edilen Series nesnesine yeniden sıfırdan indeks atayabilmek için concat fonksiyonunda ignore_index parametresi 
    True geçilmelidir:

   >>> s = pd.Series([10, 20, 30, 40, 50], dtype='float32')
    >>> k = pd.Series([100, 200], dtype='float32')
    >>> result = pd.concat((s, k), ignore_index=True)
    >>> result
    0     10.0
    1     20.0
    2     30.0
    3     40.0
    4     50.0
    5    100.0
    6    200.0
    dtype: float32
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    concat biçiminde bir fonksiyon varsa da araya eleman eklemek için bir insert fonksiyonu bulunmamaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Series nesnesinden eleman silmek için Series sınıfının drop metodu kullanılmaktadır (drop isimli bir fonksiyon yoktur). Bu metot 
    her zaman etiket temelinde çalışır. Hiçbir zaman sıra numarasıyla çalışmaz. Biz tek bir etiket de kullanabiliriz. Bir grup etiketi 
    dolaşılabilir bir nesne biçiminde de metoda verebiliriz. Metot default durumda "inplace" silme işlem yapmaz. Bize silinmiş yeni bir 
    Series nesnesi verir. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'], dtype='float32')
    >>> s
    a    10.0
    b    20.0
    c    30.0
    d    40.0
    e    50.0
    dtype: float32
    >>> result = s.drop('b')
    >>> result
    a    10.0
    c    30.0
    d    40.0
    e    50.0
    dtype: float32
    >>> result = s.drop(['a', 'e'])
    >>> result
    b    20.0
    c    30.0
    d    40.0
    dtype: float32

    inplace işlem yapmak için mettota inplace isimli bir parametre bulundurulmuştur. Bu parametre True geçilirse silme işlemi nesnenin
    kendi üzerinde yapılmaktadır. Tabii bu durumda metot herhangi bir değerle geri dönmez. Geri dönüş değeri olarak None değeri elde 
    edilir. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'], dtype='float32')
    >>> s
    a    10.0
    b    20.0
    c    30.0
    d    40.0
    e    50.0
    dtype: float32
    >>> s.drop(['a', 'e'], inplace=True)
    >>> s
    b    20.0
    c    30.0
    d    40.0
    dtype: float32
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Series nesnelerine isim de verilebilmektedir. Bunun için Series nesnesi yaratılırken name isimli parametre kullanılır. Daha sonra 
    biz bu ismi sınıfın name elemanı ile alıp istersek değiştirebiliriz. 

    >>> s = pd.Series([10, 20, 30, 40, 50], name='My Series', dtype='float32')
    >>> s
    0    10.0
    1    20.0
    2    30.0
    3    40.0
    4    50.0
    Name: My Series, dtype: float32
    >>> s.name = 'Your Series'
    >>> s
    0    10.0
    1    20.0
    2    30.0
    3    40.0
    4    50.0
    Name: Your Series, dtype: float32

    İsim verilmiş Series nesneleri DataFrame sütunu haline getirildiğinde bu isim DataFrame içerisindeki sütun ismi halinegekmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd

s = pd.Series([3, 56, 12, 34, 21], dtype='float32', name='Numbers')

print(s)

print(s.name)

s.name = 'Test Numbers'
print(s)

#------------------------------------------------------------------------------------------------------------------------------------
    Series sınıfının size örnek özniteliği bize nesnedeki eleman sayısını verir. Tabii biz bu eleman sayısını built-in len fonksiyonuyla 
    da elde edebiliriz. Benzer biçimde sınıfın shape isimli örnek özniteliği bize Series nesnesinin bouyutlarını bir demet biçiminde 
    vermektedir. Yukarıda da belirttiğimiz gibi Series nesneleri genellikle tek boyutlu olur. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], name='Numbers', dtype='float32')
    >>> s
    0    10.0
    1    20.0
    2    30.0
    3    40.0
    4    50.0
    Name: Numbers, dtype: float32
    >>> len(s)
    5
    >>> s.size
    5
    >>> s.shape
    (5,)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    İki Series nesnesinin karşılıklı elemanlarını işleme sokabiliriz. Bu konuda davranış NumPy kütüphanesine benzerdir. Zaten Pandas 
    neredeyse vektörel işlem yapma bakımından NumPy kasamaktadır. Örneğin:

    >>> s = pd.Series([5, 10, 15, 20, 35], dtype='float32')
    >>> k = pd.Series([1, 2, 3, 4, 5], dtype='float32')
    >>> s
    0     5.0
    1    10.0
    2    15.0
    3    20.0
    4    35.0
    dtype: float32
    >>> k
    0    1.0
    1    2.0
    2    3.0
    3    4.0
    4    5.0
    dtype: float32
    >>> result = s + k
    >>> result
    0     6.0
    1    12.0
    2    18.0
    3    24.0
    4    40.0
    dtype: float32
    >>> result = s * k
    >>> result
    0      5.0
    1     20.0
    2     45.0
    3     80.0
    4    175.0
    dtype: float32
    >>> result = s > k
    >>> result
    0    True
    1    True
    2    True
    3    True
    4    True
    dtype: bool

    Burada karşılıklı elemanlardan kastedilen şey aslında indeks uyuşmasıdır. Elemanların sıra numarası ne olursa olsun etiketleri 
    uyuşanlar kendi aralarında işleme sokulmaktadır. Etiketleri uyuşmayanlar işlem sonucunda NaN biçiminde elde edilir. Yani işlem 
    sonucunun şöyle edildiğini varsayabilirsiniz: Önce sol taraftaki operand'ın tüm etiketleri, sonra sağ taraftaki operand'ın tüm 
    etiketleri peşi sıra uç uca eklenir. Uyuşan etiketler işleme sokulup sonuç o etiket ile oluşturulur, uyuşmayan etiketler işlem 
    sonucunda NaN biçiminde elde edilir. Burada etiket uyuşmasında karşılıklı elemanların uyuşmasına değil etiketlerin uyuşmasına 
    bakılmamaktadır. Yani uyuşum için etiketlerin karşılıklı uyuşumu önemli değildir. 

    import pandas as pd

    >>> a = pd.Series([1, 2, 3], index=['a', 'b', 'c'])
    >>> b = pd.Series([10, 20, 30])
    >>> c = a + b
    >>> c
    a   NaN
    b   NaN
    c   NaN
    0   NaN
    1   NaN
    2   NaN
    dtype: float64
    >>> a = pd.Series([1, 2, 3], index=['a', 'b', 'c'])
    >>> b = pd.Series([1, 2, 3], index=['x', 'b', 'y'])
    >>> c = a + b
    >>> c
    a    NaN
    b    4.0
    c    NaN
    x    NaN
    y    NaN
    dtype: float64
    >>> a = pd.Series([1, 2, 3], index=['a', 'b', 'c'])
    >>> b = pd.Series([10, 20, 30], index=['x', 'y', 'a'])
    >>> c = a + b
    >>> c
    a    31.0
    b     NaN
    c     NaN
    x     NaN
    y     NaN
    dtype: float64

    Aslında NumPy'ın aksine Pandas'ta iki Series nesnesi üzerinde işlem yapılırken bu nesnelerin aynı uzunluğa sahip olması da 
    gerekmemektedir. Örneğin:

    >>> s = pd.Series([1, 2, 3, 4, 5], dtype='float32')
    >>> k = pd.Series([10, 20, 30], dtype='float32')
    >>> result = s + k
    >>> result
    0    11.0
    1    22.0
    2    33.0
    3     NaN
    4     NaN
    dtype: float32
    
    Burada s ve k'nın ilk üç etiketi uyuştuğu için toplanmıştır. Ancak s'teki fazlalık NaN biçiminde sonuca yansıtılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Series sınıfının pek çok faydalı metodu vardır. Bu metotlar bize yaptıklar işlem sonucunda yeni bir Series nesnesi verirler. Aslında 
    bu metotlar NumPy metotlarına çok benzemektedir. Anımsanacağı gibi NumPy'da pek çok işlem hem metotlarla hem de fonksiyonlarla 
    yapılabilmektedir. Ancak Pandas'ta ağırlıklı olarak metotlar kullanılmaktadır. Yani pek işlem yalnızca metotlarla yapıkmaktadır. 
    Pek çok işlemin fonksiyon karşılığı yoktur. Tabii metotlar bize genel olarak yeni bir Series nesnesi oluşturup vermektedir. 

    - abs metodu elemanların mutlak değerlerini elde eder. add metodu karşılıklı elemanları toplar (yani + operatörü ile yapılanı yapar). 
    Örneğin:

    >>> s = pd.Series([3, -7, 7, 4 -3])
    >>> k = s.abs()
    >>> k
    0    3
    1    7
    2    7
    3    1
    dtype: int64

    - min ve max metotları nesnesi içerisindeki en küçük ve en büyük elemanları bize verir. 

    - sort_values metodu sıraya dizme ilmei yapar. Bu metodun inplace parametresi de vardır. Örneğin:

    >>> s = pd.Series([4, 18, -4, 54, 10])
    >>> s
    0     4
    1    18
    2    -4
    3    54
    4    10
    dtype: int64
    >>> s.sort_values()
    2    -4
    0     4
    4    10
    1    18
    3    54

    - argmax, argmin, argsort metotoları sırasıyla en büyük elemanın indeksini, en küçük elemanın indeksini ve sort edilme durumundaki 
    indeksleri vermektedir. Örneğin:

    >>> s.argsort()
    0    3
    1    2
    2    1
    3    4
    4    0
    dtype: int64

    Diğer önemli bazı metotlar da şunlardır:

    - count
    - mean
    - std
    - var
    - mode
    - median
    - cumsum
    - unique

    unique metodu nesnedeki tek elemanları elde eder. Yani yineleyen elemanlardan kurtulmak için metot kullanılabilir. Ancak Pandas'ın
    uniuque metodu NumPy'ın unique fonksiyonu gibi sıraya dizmew işlemi yapmamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Series nesnesinin dtype türünü değiştirmek isteyebiliriz. Bunun için astype metodu kullanılmaktadır. astype metodu bize 
    belirttiğimiz türden yeni bir Series nesnesi vermektedir. Örneğin:

    >>> s = pd.Series([12, 8, 4, 2, 9], dtype='float32')
    >>> k = s.astype('int32')
    >>> k
    0    12
    1     8
    2     4
    3     2
    4     9
    dtype: int32

    C'de None biçiminde bir tür yoktur. Python'daki None değeri Numpy ve Pandas'ta eğer dtype 'float32' ya da 'float64' ise 
    NaN (Not a Number) ile ifade edilmektedir. Eğer nesnenin dtype türü tamsayı türlerine ilişkinse zaten NaN değeri söz konusu olamaz. 
    
    - count metodu Nan olmayan elemanların sayısını vermektedir. Örneğin:

    >>> s = pd.Series([10, None, 30, None, 50], dtype='float32')
    >>> result = s.count()
    >>> result
    3

    - dot isimli metot "dot product" yapmaktadır. Yani karşılıklı (etiket bakımından uyuşan) elemanların çarpımını bulmaktadır. Örneğin:

    >>> a = pd.Series([1, 2, 3], dtype='float32')
    >>> b = pd.Series([4, 5, 6], dtype='float32')
    >>> c = a.dot(b)
    >>> c
    32.0
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir veri kümesi üzerinde çalışırken çeşitli biçimlerde "eksik verilerle" karşılaşabiliriz. Örneğin bir anket uygulamasında kişiler
    bazı sorulara yanıt vermek istememiş olabilir. Ya da verilerin sensörlerle elde edildiği durumda sensör arızalarından dolayı bazı 
    veriler elde edilememiş olabilir. Bu tür durumlarda çeşitli yöntemler izlenebilmektedir. Eksik verilerin tamamen atılması (bir veri 
    tablosu söz konusuysa eksik verilerin bulunduğu satırın atılması) ya da eksik verilerin diğer verilerden hareketle doldurulması (
    buna İngilizce "imputation"   denilmektedir) sık kullanılan yöntemlerdendir. Pandas'ta eksik veirler Series ya da DataFrame nesnelerinde 
    NaN ile görüntülenmektedir. 
    
    - Series sınıfında eksik verilerin ele alınmasına yönelik çeşitli metotlar da bulundurulmuştur. dropna metodu eksik verileri atmak 
    için kullanılmaktadır. Yani NaN değerleri Series nesnesinden silinir. Metot bize eksik değerleri silinmiş olan yeni bir Series 
    nesnesi verir. Örneğin:

    >>> s = pd.Series([3, None, 7, 9, None, 10], dtype='float32')
    >>> s
    0     3.0
    1     NaN
    2     7.0
    3     9.0
    4     NaN
    5    10.0
    dtype: float32
    >>> result = s.dropna()
    >>> result
    0     3.0
    2     7.0
    3     9.0
    5    10.0
    dtype: float32

    dropna metodunun inplace parametresi True geçilirse eksik verilerin silinmesi inplace olarak yapılmaktadır. 

    fillna isimli metot eksik verileri (yani NaN olan elemanları) spesifik bir değerle doldurmaktadır. Örneğin biz eksik verileri 
    aşağıdaki gibi ortalamayla doldurabiliriz:

    >>> s = pd.Series([3, None, 7, 9, None, 1], dtype='float32')
    >>> s
    0    3.0
    1    NaN
    2    7.0
    3    9.0
    4    NaN
    5    1.0
    dtype: float32
    >>> s.fillna(s.mean())
    0    3.0
    1    5.0
    2    7.0
    3    9.0
    4    5.0
    5    1.0
    dtype: float32

    mean metodunun eksik verileri hesaba katmadığına dikkat ediniz. Yukarıdaki s nesnesinin mean ile alınan ortalaması bu yüzden 
    5 çıkmıştır. Bu netodun da inplace parametresi bulunmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
   - Series sınıfının isna ya da isnull metodu metodu Nan olanların True olduğu Nan olmayanların False olduğu bir Series nesnesi 
    vermektedir. Bu sayede biz NaN değerler üzerinde filtreleme işlemleri yapabiliriz. isna ile isnaull arasında hiçbir farklılık 
    yoktur. Örneğin:

    >>> s = pd.Series([1, 2, None, 2, None, 5, None], dtype=np.float32)
    >>> s
    0    1.0
    1    2.0
    2    NaN
    3    2.0
    4    NaN
    5    5.0
    6    NaN
    >>> s[s.isna()]
    2   NaN
    4   NaN
    6   NaN
    dtype: float32
    >>> s = pd.Series([1, 2, None, 2, None, 5, None], dtype=np.float32)
    >>> s[~s.isna()]
    0    1.0
    1    2.0
    3    2.0
    5    5.0
    dtype: float32

    Son örnekteki ~ operatörü bool türdne Series nesnesindeki True değerleri False, False değerleri True yapmaktadır. 

    Örneğin biz eksik verilerin sayısını şöyle elde edebiliriz:

    >>> s = pd.Series([1, 2, None, 2, None, 5, None], dtype=np.float32)
    >>> s.isna().sum()
    np.int64(3)
#------------------------------------------------------------------------------------------------------------------------------------    

#------------------------------------------------------------------------------------------------------------------------------------
    - hist isimli metot histogram çizmektedir. Ancak histogram için arka planda Matplotlib kütüphanesini kullanmaktadır. Örneğin:

    import pandas as pd
    import numpy as np

    s = pd.Series(np.random.randn(1000))

    s.hist()

    Burada önce standart normal dağılılma ilişkin rastgele değerler elde edilmiş sonra o değerlerden bir Series nesnesi oluşturularak 
    Series sınıfının hist metodu ile histogram çizilmiştir. Eğer komut satırında aynı şeyi yapacaksanız matplotlib kütüphanesinin show
    metodunu da çağırmalısınız. Örneğin:

    >>> import pandas as pd
    >>> import numpy as np
    >>> import matplotlib.pyplot as plt
    >>> s = pd.Series(np.random.randn(1000))
    >>> s.hist()
    <Axes: >
    >>> plt.show()

    Histogramdaki çubuk sayısı hist parametresi ile ayarlanabilmektedir. Default çubuk sayısı 10 tandedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                            50.Ders 14/09/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------    
    - Series sınıfının median, mean, mode, std ve var metotları klasik istatistiksel işlemleri yapmaktadır. Bu metotlar NaN değerler 
    sanki yokmuş gibi davranmaktadır. Örneğin:

    >>> s = pd.Series([1, 2, 3, 5, 8, 9, 4, 5, 2, 5])
    >>> s.mean()
    4.4
    >>> s.median()
    4.5
    >>> s.mode()
    0    5
    dtype: int64
    >>> s.std()
    2.590581230363393
    >>> s.var()
    6.711111111111112

    Ancak Pandas'taki std ve var metotları standart sapma ve varyans hesaplarken n değerine değil n - 1 değerine bölme yapmaktadır. 
    Aslında bu metotlar n - ddof değerine bölüm uygulamaktadır. Default ddof değeri 1'dir. Eğer bu metotların NumPy kütüphanesinde 
    olduğu gibi n'e bölme yapmasını istiyorsanır ddof parametresine 0 girmelisiniz. Örneğin:

    >>> s = pd.Series([1, 2, 3, 5, 8, 9, 4, 5, 2, 5])
    >>> s.std()
    2.590581230363393
    >>> s.std(ddof=0)
    2.4576411454889016
    >>> a = s.to_numpy()
    >>> a
    array([1, 2, 3, 5, 8, 9, 4, 5, 2, 5], dtype=int64)
    >>> a.std()
    2.4576411454889016
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Series sınıfının values örnek özniteliği bize Series nesnesi içerisindeki değerleri bir NumPy dizisi olarak veriyodu. Aynı işlem 
    Series sınıfının array örnek özniteliği ile de yapılabilmektedir. array örnek özniteliği aynı NumPy dizisine referans eden başka 
    bir sınıf türünden nesne vermektedir. 

    >>> b = s.array
    >>> id(b)
    1689465751568
    >>> b[3] = 1000
    >>> s
    0       1.0
    1       2.0
    2     100.0
    3    1000.0
    4       5.0
    dtype: float32

    array özniteliği ile values özniteliği birbirine çok benzemektedir. array özniteliği gerçek bir NumPy dizisi vermez. Pandas içeisinde 
    sarmalanmış olan bir dizi vermektedir. 

    Series sınıfının to_numpy metodu values örnek özniteliği gibidir. Ancak to_numpy değişik seçeneklere de sahiptir. Default durumda 
    to_numpy metodu ile values örnek özniteliği aynı Numpy dizisini vermektedir. Fakat örneğin to_numpy metodunda copy=True geçilirse 
    metot bize kopyalama yaparak başka bir Numpy dizisi verir. Örneğin:

    >>> s = pd.Series([1, 2, 3, 4, 5], dtype='float32')
    >>> a = s.values
    >>> a
    array([1., 2., 3., 4., 5.], dtype=float32)
    >>> id(a)
    1689358507664
    >>> b = s.to_numpy()
    >>> b
    array([1., 2., 3., 4., 5.], dtype=float32)
    >>> id(b)
    1689358507664
    >>> c = s.to_numpy(copy=True)
    >>> c
    array([1., 2., 3., 4., 5.], dtype=float32)
    >>> id(c)
    1689358507856
    >>> c[2] = 1000
    >>> s
    0    1.0
    1    2.0
    2    3.0
    3    4.0
    4    5.0
    dtype: float32

    Özetle bir Series nesnesi içerisindeki değerleri NumPy dizisi olarak almak istersek values örnek özniteliğini ya da to_numpy 
    metodunu kullanabiliriz.

    Eğer Series nesnesi içerisindeki değerleri bir Python listesi biçiminde elde etmek istersek Series sınıfının to_list metodunu 
    kullanabiliriz. Tabii to_list her çağrıldığında aslında bize farklı bir list nesnesi verecektir. Örneğin:

    >>> s = pd.Series([1, 2, 3, 4, 5], dtype='float32')
    >>> s
    0    1.0
    1    2.0
    2    3.0
    3    4.0
    4    5.0
    dtype: float32
    >>> a = s.to_list()
    >>> a
    [1.0, 2.0, 3.0, 4.0, 5.0]
    >>> id(a)
    1689468256384
    >>> b = s.to_list()
    >>> id(b)
    1689466572096

    NumPy'da da tolist isimli (isimde alt tire olmadığına dikkat ediniz) bir metodun olduğunu anımsayınız.
#------------------------------------------------------------------------------------------------------------------------------------
 
#------------------------------------------------------------------------------------------------------------------------------------
    Series sınıfının daha pek çok faydalı metodu vardır. Bu metotları Pandas dokümanlarından inceleyebilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Pandas'taki en önemli veri yapısı DataFrame denilen veri yapısıdır. DataFrame tipik olarak istatistiksel veri kümelerini temsil 
    etmek için düşünülmüştür. DataFrame nesnesinin sütunlardan oluşan matrisel bir yapısı vardır. Aslında DataFrame nesnesi Series 
    nesnelerinden oluşmaktadır. Yani DataFrame nesnelerinin sütunları Series nesneleridir. Başka bir deyişle DataFrame nesnesi Series
    nesnelerinin yan yana dizilmesinden oluşmaktadır.

    NumPy dizilerinin elemanları aynı türden olur. Her ne kadar elemanları aynı türden olmayan NumPy dizileri de oluşturulabiliyorsa 
    da (örneğin dtype='object' alınarak) bu biçimde NumPy dizilerinin uygulamada kullanımı yoktur. Pandas kütüphanesinin en önemli 
    özelliği sütunları farklı türlerden olabilen, ismine DataFrame denilen veri yapısına sahip olmasıdır. İstatistik ve veri bilimindeki 
    "veri kümeleri (datasets)" de zaten böyle bir yapıya sahiptir. Bu bakımdan veri kümeleri ilişkisel veritabanlarındaki tablolara 
    da benzetilebilir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir DataFrame nesnesi tipik olarak DataFrame sınıfının __init__ metodu yoluyla oluşturulur. DataFrame sütunlardan oluşmaktadır. 
    DataFrame nesnelerinde hem satırların hem de sütunların etiketleri (yani indeksleri) vardır. Bir DataFrame nesnesinde satır etiketleri 
    index parametresiyle, sütun etiketleri ise columns parametresiyle belirlenebilmektedir. Genellikle satırlar Series nesnelerinde 
    olduğu gibi sayısal indeks biçiminde sütunlar ise birer yazı biçiminde karşımıza çıkar. 
    
    DataFrame nesnesi iki boyutlu bir Python listesi ile oluşturulabilir. Bu durumda listenin içerisindeki her liste bir satırı 
    belirtmektedir. Eğer index parametresi ve columns parametresi belirtilmezse oluşturulan DataFrame nesnesinin satır etiketleri 
    ve sütun etiketleri 0, 1, 2, ... biçiminde sayısal değerlerden oluşturulur Örneğin:

    >>> df = pd.DataFrame([[10, 20, 30], [40, 50, 60], [70, 80, 90]])
    >>> df
        0   1   2
    0  10  20  30
    1  40  50  60
    2  70  80  90

    Biz satırlara ilişkin etiketleri index parametresiyle, sütunlara ilişkin etiketleri ise columns parametresiyle belirleyebiliriz. 
    Örneğin:

    >>> df = pd.DataFrame([[10, 20, 30], [40, 50, 60], [70, 80, 90]], index=['a', 'b', 'c'], columns=['X', 'Y', 'Z'])
    >>> df
        X   Y   Z
    a  10  20  30
    b  40  50  60
    c  70  80  90
    
    Ancak yukarıda da belirttiğimiz gibi genellikle DataFRame nesnelerinin sütunlarına yazısal etiketleri (yani isimler) iliştirilir 
    ancak satırlarına etiket iliştirilmez. Satırlar default olarak sayısal biçimde karşımıza çıkar.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii DataFrame nesneleri aslında farklı türlere sütunlardan oluşturulabilir. Örneğin:

    >>> df = pd.DataFrame([['Ali Serçe', 'Erkek', 172, 72], ['Fehmi Ak', 'Erkek', 182, 92], ['Ayşe Er', 'Kadın', 168, 68]], 
    columns=['Adı Soyadı', 'Cinsiyet', 'Boy', 'Kilo'])
    >>> df
    Adı Soyadı Cinsiyet  Boy  Kilo
    0  Ali Serçe    Erkek  172    72
    1   Fehmi Ak    Erkek  182    92
    2    Ayşe Er    Kadın  168    68

    Bir DataFrame nesnesi iki boyutlu bir NumPy dizisi ile de yaratılabilir. Örneğin:

   >>> a = np.random.randint(0, 100, (10, 5))
    >>> a
    array([[57, 61,  0, 88, 72],
        [10, 47, 38, 19, 79],
        [79, 51, 14, 50, 88],
        [36, 47,  8, 52, 67],
        [25, 88, 42, 46, 42],
        [37, 98, 36, 96, 69],
        [82, 97, 14, 53, 92],
        [43, 89, 57, 62, 94],
        [21, 65, 26, 80, 40],
        [86, 91, 91, 10, 16]])
    >>> df = pd.DataFrame(a, columns=['A', 'B', 'C', 'D', 'E'])
    >>> df
        A   B   C   D   E
    0  57  61   0  88  72
    1  10  47  38  19  79
    2  79  51  14  50  88
    3  36  47   8  52  67
    4  25  88  42  46  42
    5  37  98  36  96  69
    6  82  97  14  53  92
    7  43  89  57  62  94
    8  21  65  26  80  40
    9  86  91  91  10  16    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame nesnesi bir sözlük ile de yaratılabilir. Bu durumda sözlüğün anahtarları sütun isimlerini, değerleri de sütunlardaki 
    değerleri belirtir. Örneğin:

    >>> d = {'Adı Soyadı': ['Kaan Aslan', 'Ali Serçe', 'Ayşe Er'], 'Boy': [182, 174, 168], 'Kilo': [78, 69, 56]}
    >>> d
    {'Adı Soyadı': ['Kaan Aslan', 'Ali Serçe', 'Ayşe Er'], 'Boy': [182, 174, 168], 'Kilo': [78, 69, 56]}
    >>> df = pd.DataFrame(d)
    >>> df
    Adı Soyadı  Boy  Kilo
    0  Kaan Aslan  182    78
    1   Ali Serçe  174    69
    2     Ayşe Er  168    56

    Görüldüğü gibi sözlüğün anahtarları sütun isimleri haline gelmiştir. Örneğimizde sözlüğün değerlerinin bir liste biçiminde 
    oluşturulduğuna dikkat ediniz. Bu listenin elemanları ilgili sütunun satır değerlerini belirtmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir DataFrame nesnesinin sütunları farklı türlerden olabilir. Örneğin:

    >>> d = {'a': np.array([1, 2, 3], dtype='float32'), 'b': np.array([4, 5, 6], dtype='int32'), 
        'c': np.array([True, False, True], dtype='bool')}
    >>> df = pd.DataFrame(d)
    >>> df
        a   b     c
    0  1.0  4   True
    1  2.0  5  False
    2  3.0  6   True

    Örneğin:

    >>> df = pd.DataFrame({'A': np.array([1, 2, 3], dtype='int32'), 'B': np.array(['X', 'Y', 'Z'], dtype='str'), 
        'C': np.array([1.2, 4.5, 7.8], dtype='float32')})
    >>> df
    A  B    C
    0  1  X  1.2
    1  2  Y  4.5
    2  3  Z  7.8

    Bir DataFrame nesnesinin sütunları farklı türlerden olabileceğine göre bu durumda DataFrame nesnesi için tek bir dtype türünden 
    bahsedilemez. Çünkü her sütunun ayrı bir dtype türü vardır. İşte DataFrame sınıfının dtypes örnek özniteliği bize bir Series 
    nesnesi olarak tüm sütunların türlerini vermektedir. Örneğin:

    >>> d = {'a': np.array([1, 2, 3], dtype='float32'), 'b': np.array([4, 5, 6], dtype='int32'), 
        'c': np.array([True, False, True], dtype='bool')}
    >>> df = pd.DataFrame(d)
    >>> df.dtypes
    a    float32
    b      int32
    c       bool
    dtype: object

    Burada Series nesnesinin elemanlarının etiketleri DataFrame nesnesinin sütunlarından değerleri ise onların dtype 
    türlerinden oluşmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    Bir DataFrame nesnesinin elemanlarına erişebiliriz. İndeksleme işlemi Series nesnelerinde olduğu gibi üç yolla yapılmaktadır. 
    df değişkeninin DataFrame türünden olduğunu varsayalım:

    1) df[...] biçiminde indeksleme. Buna "doğrudan indeksleme" diyeceğiz. 
    2) df.loc[...] biçiminde indeksleme. Buna "loc indekslemesi" diyeceğiz.
    3) df.iloc[...] iloc biçiminde indeksleme. Buna da "iloc indekslemesi" diyeceğiz. 
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    Doğrudan df[...] biçiminde indeskelemede biz sütunları elde ederiz. Bu durumda indeks olarak sütun etiketlerinin (yani isimleri)
    verilmesi gerekir. (Sütun indeksleri kullanılamamaktadır.) Eğer doğrudan indekslemede tek bir sütun belirtiliyorsa bu durumda 
    bize o sütun bir Series nesnesi biçiminde verilir. Örneğin:

   >>> df = pd.DataFrame({
    ...     'Adı Soyadı': ['Ali Serçe', 'Ayşe Er', 'Hakan Demir', 'Fehmi Uzun', 'Esra Elli'],
    ...     'Boy': [175, 167, 183, 175, 169],
    ...     'Kilo': [74.5, 62.4, 82.4, 92, 71],
    ...     'Cinsiyet': ['Erkek', 'Kadın', 'Erkek', 'Erkek', 'Kadın']
    ...     })
    >>> s = df['Boy']
    >>> s
    0    175
    1    167
    2    183
    3    175
    4    169
    Name: Boy, dtype: int64
    >>> type(s)
    <class 'pandas.core.series.Series'>
    >>> s = df['Cinsiyet']
    >>> s
    0    Erkek
    1    Kadın
    2    Erkek
    3    Erkek
    4    Kadın
    Name: Cinsiyet, dtype: object
    >>> type(s)
    <class 'pandas.core.series.Series'>

    Doğrudan indekslemede bir liste biçiminde birden fazla sütun da belirtilebilir. Bu durumda bize Series nesnesi değil DataFrame nesnesi 
    verilir. Örneğin:

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    0    Ali Serçe  175  74.5    Erkek
    1      Ayşe Er  167  62.4    Kadın
    2  Hakan Demir  183  82.4    Erkek
    3   Fehmi Uzun  175  92.0    Erkek
    4    Esra Elli  169  71.0    Kadın
    >>> result = df[['Kilo', 'Cinsiyet']]
    >>> result
    Kilo Cinsiyet
    0  74.5    Erkek
    1  62.4    Kadın
    2  82.4    Erkek
    3  92.0    Erkek
    4  71.0    Kadın
    >>> type(result)
    <class 'pandas.core.frame.DataFrame'>

    Birden fazla sütunun artık Series belirtmediğine DatFrame belirttiğine dikkat ediniz.
    
    Bir DataFrame nesnesinin doğrudan indekslenmesiyle elde edilen Series nesneleri aslında view belirtmektedir. Ancak bu view 
    nesnelerinin güncellenmesi tavsiye edilmemektedir. Ancak doğrudan indekslemeden elde edilen DataFrame nesneleri bir view belirtmemektedir. 
    Örneğin:
   
    >>> a = np.arange(50).reshape((10, 5))
    >>> df = pd.DataFrame(a, columns=['A', 'B', 'C', 'D', 'E'])
    >>> df
        A   B   C   D   E
    0   0   1   2   3   4
    1   5   6   7   8   9
    2  10  11  12  13  14
    3  15  16  17  18  19
    4  20  21  22  23  24
    5  25  26  27  28  29
    6  30  31  32  33  34
    7  35  36  37  38  39
    8  40  41  42  43  44
    9  45  46  47  48  49
    >>> s = df['C']
    >>> s
    0     2
    1     7
    2    12
    3    17
    4    22
    5    27
    6    32
    7    37
    8    42
    9    47
    Name: C, dtype: int32
    >>> s[0] = 100
    >>> df
        A   B    C   D   E
    0   0   1  100   3   4
    1   5   6    7   8   9
    2  10  11   12  13  14
    3  15  16   17  18  19
    4  20  21   22  23  24
    5  25  26   27  28  29
    6  30  31   32  33  34
    7  35  36   37  38  39
    8  40  41   42  43  44
    9  45  46   47  48  49

    Bu örnekte s değişkenine atadığımız Series nesnesi üzerinde değişiklik yaptığımızda bundan asıl DataFrame nesnesinin etkilendiğine
    dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    loc indekslemesinde her zaman etiketler kullanılmaktadır. İndeksleme köşeli parantezler içerisinde yallnızca satır etiketi verilerek 
    yapılırsa o satırın tüm sütun elemanları bir Series nesnesi biçiminde elde edilmektedir. Tabii sütunların türleri farklı olabileceğine 
    göre elde edieln Series nesnesinin de dtype türü object olur. Örneğin:

    >>> df = pd.DataFrame({
    ...     'Adı Soyadı': ['Ali Serçe', 'Ayşe Er', 'Hakan Demir', 'Fehmi Uzun', 'Esra Elli'],
    ...     'Boy': [175, 167, 183, 175, 169],
    ...     'Kilo': [74.5, 62.4, 82.4, 92, 71],
    ...     'Cinsiyet': ['Erkek', 'Kadın', 'Erkek', 'Erkek', 'Kadın']
    ...     }, index=['a', 'b', 'c', 'd', 'e'])

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın
    
    >>> df.loc['d']
    Adı Soyadı    Fehmi Uzun
    Boy                  175
    Kilo                92.0
    Cinsiyet           Erkek
    Name: d, dtype: object

    Burada df['d'] ifadesi ile biz DataFrame nesnesinin 'd' etiketli satırını bir Series nesnesi olarak elde ettik. Elde edilen Series
    nesnesinin etiketleri sütun isimlerinden değerleri de o satırdaki o sütunlara karşı gelen değerlerden oluşmaktadır. 

    loc indekslemesinde biz [] operatörünün içerisine satırlar için birden fazla birden fazla etiket de girebiliriz. Bu durumda tabii
    birden fazla satır elde edileceği için bize bir DatFarme nesnesi verilecektir. Örneğin:

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın

    >>> df.loc[['b', 'd']]
    Adı Soyadı  Boy  Kilo Cinsiyet
    b     Ayşe Er  167  62.4    Kadın
    d  Fehmi Uzun  175  92.0    Erkek
    
    Pandas indekslemelerinde tek bir satır ya da sütunun Series nesnesi olarak ancak birden fazla satır ya da sütunun DataFrame nesnesi 
    olarak verildiğine dikkat ediniz. 

    loc indesklemesinde satırı belirttikten sonra sütun belirlemesi de yapabiliriz. Bu durumda DataFrame içerisindeki belli bir hücrenin
    içerisindeki değer elde edilir. Tabii loc indekslemesinde her zaman satır ve sütunlardaki etiketlerin kullanılması gerekmektedir. 
    Örneğin:

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın
   
    >>> df.loc['d', 'Kilo']
    92.0
    >>> df.loc['a', 'Cinsiyet']
    'Erkek'

    Sütunlarda da birden fazla sütun seçilebilir. Örneğin:

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın

    >>> df.loc['c', [['Boy', 'Kilo']]
    >>> df.loc['c', ['Boy', 'Kilo']]
    Boy      183
    Kilo    82.4
    Name: c, dtype: object

    Hem satırda hem de sütunda birdeh fazla elema seçilebilir. Örneğin:

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın

    >>> df.loc[['a', 'd'], ['Boy', 'Kilo']]
    Boy  Kilo
    a  175  74.5
    d  175  92.0

    İndekslemelerde dilimleme de yapılabilir. Köşeli parantezler içerisinde satırlar ya da sütunlarda ya da her ikisinde dilim 
    ifadesi kullanılabilir. Ancak dilimleme yine her zaman etiketlerle yapılmak zorundadır. loc indekslemesindesk, dilimlerdeki 
    bitiş etikei dilimlemeye dahildir. Örneğin:

        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın

    >>> df.loc['a':'d']
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek

    Burada indeksleme sütun belirtilmemiştir. O halde satırların tüm sütunları elde edilmektedir. 'd' satırının da dilimlemeye dahil 
    olduğuna dikkat ediniz. Örneğin:

    >>> df.loc['a':'d', 'Boy':'Cinsiyet']
    Boy  Kilo Cinsiyet
    a  175  74.5    Erkek
    b  167  62.4    Kadın
    c  183  82.4    Erkek
    d  175  92.0    Erkek

    Tüm satırları ya da tüm sütunları belirtmek için yine ':' operatörü tek başına kullanılabilir. Örneğin:

    >>> df.loc[:, ['Boy', 'Cinsiyet']]
    Boy Cinsiyet
    a  175    Erkek
    b  167    Kadın
    c  183    Erkek
    d  175    Erkek
    e  169    Kadın

    loc indekslemesinde step miktarı da sayısal biçimde belirtilebilir. Örneğin:

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın

    >>> df.loc['a':'e':2]
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    c  Hakan Demir  183  82.4    Erkek
    e    Esra Elli  169  71.0    Kadın

    Burada 'a' satırından 'e' satırına ikişer atlamalı dilimleme yapılmıştır.

    loc indekslemesinde bool indeksleme de yapılabilir. Örneğin:

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın

    >>> df[[True, False, True, False, True]]
        Adı Soyadı  Boy  Kilo Cinsiyet
        a    Ali Serçe  175  74.5    Erkek
        c  Hakan Demir  183  82.4    Erkek
        e    Esra Elli  169  71.0    Kadın

    Tabii bool indeskleme sayesinde filtreleme de yapılabilmektedir. Örneğin biz kilosu 80'in yukarısında olan satırları şöyle elde
    edebiliriz:

    >>> df.loc[df['Kilo'] > 80]
        Adı Soyadı  Boy  Kilo Cinsiyet
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek

    Burada df['Kilo'] > 80 ifadesi ile bool bir Series nesnesi elde edilmektedir. Bu bool türden Series nesnesi loc indekslemesinde 
    kullanılmıştır. Örneğin:

    >>> df.loc[df['Kilo'] > 80, ['Adı Soyadı', 'Kilo']]
    Adı Soyadı  Kilo
    c  Hakan Demir  82.4
    d   Fehmi Uzun  92.0

    Burada Kilosu 80'den büyük olan Kişilerin "Adı Soyadı" ve "Kilo" bilgileri elde edilmiştir.

    loc indekslemesinde her zaman etiketler kullanılmaktadır. Tabii satır etiketleri default durumda sayısal bir biçimde bulunduğundan
    kişiler loc indeskelemesiyle sayısal indeksleme yaptığını sanabilmektedir. Örneğin:

    >>> df = pd.DataFrame({
    ...     'Adı Soyadı': ['Ali Serçe', 'Ayşe Er', 'Hakan Demir', 'Fehmi Uzun', 'Esra Elli'],
    ...     'Boy': [175, 167, 183, 175, 169],
    ...     'Kilo': [74.5, 62.4, 82.4, 92, 71],
    ...     'Cinsiyet': ['Erkek', 'Kadın', 'Erkek', 'Erkek', 'Kadın']
    ...     })

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    0    Ali Serçe  175  74.5    Erkek
    1      Ayşe Er  167  62.4    Kadın
    2  Hakan Demir  183  82.4    Erkek
    3   Fehmi Uzun  175  92.0    Erkek
    4    Esra Elli  169  71.0    Kadın
    
    >>> df.loc[3]
    Adı Soyadı    Fehmi Uzun
    Boy                  175
    Kilo                92.0
    Cinsiyet           Erkek
    Name: 3, dtype: object
    
    >>> df.loc[1:4]
        Adı Soyadı  Boy  Kilo Cinsiyet
    1      Ayşe Er  167  62.4    Kadın
    2  Hakan Demir  183  82.4    Erkek
    3   Fehmi Uzun  175  92.0    Erkek
    4    Esra Elli  169  71.0    Kadın

    Burada loc indekslemesinde yine etiketler kullanılmıştır. Ancak etiketler zaten default durumda birer sayı belirtmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    iloc indekslemesinde her zaman etiketler değil indeks numaaları kullanılmak zorundadır. İndeksleme biçimi loc indekslemesi gibidir. 
    iloc indekslemesinin loc indeskelemesinden farkı indeks olarak etiketlerin değil sayıların kullanılmasıdır. Örneğin:

    >>> df = pd.DataFrame({
    ...     'Adı Soyadı': ['Ali Serçe', 'Ayşe Er', 'Hakan Demir', 'Fehmi Uzun', 'Esra Elli'],
    ...     'Boy': [175, 167, 183, 175, 169],
    ...     'Kilo': [74.5, 62.4, 82.4, 92, 71],
    ...     'Cinsiyet': ['Erkek', 'Kadın', 'Erkek', 'Erkek', 'Kadın']
    ...     }, index=['a', 'b', 'c', 'd', 'e'])
    
    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın

    >>> df.iloc[2]
    Adı Soyadı    Hakan Demir
    Boy                   183
    Kilo                 82.4
    Cinsiyet            Erkek

    Burada df.iloc[2] indekslemesinde satırların etiketleri dikkate alınmamaktadır. Bu indeksleme ile 2 numaralı satır elde 
    edilmektedir. Örneğin:

    >>> df.iloc[[1, 3, 2]]
        Adı Soyadı  Boy  Kilo Cinsiyet
    b      Ayşe Er  167  62.4    Kadın
    d   Fehmi Uzun  175  92.0    Erkek
    c  Hakan Demir  183  82.4    Erkek
    
    Burada 1, 3 ve 2 numaralı satırlar elde edilmiştir. 

    iloc indekslemesinde sütun için yine isimler değil numaralar kullanılmak zorundadır. Örneğin:

    >>> df.iloc[[1, 3], [2, 3]]
    Kilo Cinsiyet
    b  62.4    Kadın
    d  92.0    Erkek
            
    iloc indesklemesinde de yine dilimleme yapılabilmektedir. Ancak dilimlerdeki başlangıç ve bitim indeks numaralarından oluşmak 
    zorundadır. Ancak bitim indeksleri dilimlemeye dahil değildir. Örneğin:

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın

    >>> df.iloc[2:4, 1:3]
    Boy  Kilo
    c  183  82.4
    d  175  92.0

    Burada tıpkı Python'da olduğu artık bitim indeksinin dilimlemeye dahil edilmediğine dikkat ediniz. Örneğin:

    >>> df.iloc[:, 2:4]
    Kilo Cinsiyet
    a  74.5    Erkek
    b  62.4    Kadın
    c  82.4    Erkek
    d  92.0    Erkek
    e  71.0    Kadın

    Burada tüm satırların 2înci ve 3'üncü indeksli sütunları elde edilmiştir. 

    iloc indekslemesinde negatif indekslemenin de kullanılabildiğine dikkat ediniz. Örneğin:

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın

    >>> df.iloc[-1]
    Adı Soyadı    Esra Elli
    Boy                 169
    Kilo               71.0
    Cinsiyet          Kadın
    Name: e, dtype: object
    
    >>> df.iloc[:-2, 2:4]
    Kilo Cinsiyet
    a  74.5    Erkek
    b  62.4    Kadın
    c  82.4    Erkek

    iloc indeskelemesinde de step miktarı da belirtilebilir. Örneğin:

    >>> df.iloc[1:5:2, :]
    Adı Soyadı  Boy  Kilo Cinsiyet
    b     Ayşe Er  167  62.4    Kadın
    d  Fehmi Uzun  175  92.0    Erkek

    iloc indekslemesinde de bool indeksleme yapılabilmektedir. Örneğin:

    >>> a = np.arange(25).reshape(5, 5)
    >>> df = pd.DataFrame(a, columns=list('ABCDE'), index=list('xyzkn'))
    >>> df
        A   B   C   D   E
    x   0   1   2   3   4
    y   5   6   7   8   9
    z  10  11  12  13  14
    k  15  16  17  18  19
    n  20  21  22  23  24
    >>> k = df.iloc[[False, True, True, False, True]]
    >>> k
        A   B   C   D   E
    y   5   6   7   8   9
    z  10  11  12  13  14
    n  20  21  22  23  24
    
    Bool indekslemede loc ile iloc arasında küçk bir fark vardır. Biz iloc ile bool indekslemede Series nesnelerini kullanamayız ancak 
    loc indekslemesinde kullanabiliriz. Bu özelliği Series nesnelerinde de aynı biçimde olduğunu anımsayınız. Ancak bool türden bir
    Series nesnesi loc indeklemesinde kullanılacaksa Series nesnesinin satır indeksleriyle DataFrame nesnesinin satır indeksleri 
    aynı olmalıdır. Örneğin:

    >>> a = np.arange(25).reshape(5, 5)
    >>> df = pd.DataFrame(a, columns=list('ABCDE'), index=list('xyzkn'))
    >>> df
        A   B   C   D   E
    x   0   1   2   3   4
    y   5   6   7   8   9
    z  10  11  12  13  14
    k  15  16  17  18  19
    n  20  21  22  23  24
    >>> s = pd.Series([False, True, True, False, True])
    >>> s
    0    False
    1     True
    2     True
    3    False
    4     True
    dtype: bool
    >>> df.loc[s, :]

    Bu indeksleme exception'a yol açacaktır. Ancak örneğin:

    >>> s = df['C'] % 2 == 0
    >>> s
    x     True
    y    False
    z     True
    k    False
    n     True
    Name: C, dtype: bool
    >>> df.loc[s, :]
        A   B   C   D   E
    x   0   1   2   3   4
    z  10  11  12  13  14
    n  20  21  22  23  24

    Burada artık elde edilen Series nesnesinin indeksleriyle DataFrame nesnesinin indeksleri aynıdır. 
#------------------------------------------------------------------------------------------------------------------------------------
  
#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame nesnesi dolaşılabilir bir nesnedir. DataFrame nesnesi dolaşıldığında sütun isimleri (sütunların kendisi değil) elde 
    edilmektedir. Örneğin:

    df = pd.DataFrame({
        'Adı Soyadı': ['Ali Serçe', 'Ayşe Er', 'Hakan Demir', 'Fehmi Uzun', 'Esra Elli'],
        'Boy': [175, 167, 183, 175, 169],
        'Kilo': [74.5, 62.4, 82.4, 92, 71],
        'Cinsiyet': ['Erkek', 'Kadın', 'Erkek', 'Erkek', 'Kadın']
        }, index=['a', 'b', 'c', 'd', 'e'])

    for col in df:
        print(col)

    DataFrame nesnesinin belli bir sütunu doğrudan indeksleme ile dolaşılırsa o sütunun elemanları elde edilir. Zaten bu biçimdeki 
    doğrudan indekslemeden Series nesnesinin elde edildiğini biliyorsunuz. 

    for val in df['Kilo']:
        print(val)

    Doğrudan indesklemede tek bir sütunun belirtidiği durumda elde edilen nesnenin Series nesnesi olduğuna dikkat ediniz. Yani 
    biz burada aslında Series nesnesini dolaşmaktayız.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame nesnesinin satır satır dolaşılmasına sıkça gereksinim duyulmaktadır. Bunu yapmanın birkaç yolu olabilir. Örneğin dolaşımı
    iloc indekslemesi ile aşağıdaki gibi yapabiliriz:

    df = pd.DataFrame({
        'Adı Soyadı': ['Ali Serçe', 'Ayşe Er', 'Hakan Demir', 'Fehmi Uzun', 'Esra Elli'],
        'Boy': [175, 167, 183, 175, 169],
        'Kilo': [74.5, 62.4, 82.4, 92, 71],
        'Cinsiyet': ['Erkek', 'Kadın', 'Erkek', 'Erkek', 'Kadın']
        }, index=['a', 'b', 'c', 'd', 'e'])

    for i in range(len(df)):
        row = df.iloc[i]
        print(row)

    Burada satır numarası ile döngü içerisinde satırları Series nesneleri olarak elde ettik.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında bir DataFrame nesneleri genellikle elle oluşturulmamaktadır. Bir dosyadan hareketle oluşturulmaktadır. Daha önceden de 
    belirttiğimiz gibi CSV dosyaları veri biliminde en fazla kullanılan dosya formatıdır. Pandas'ta read_csv fonksiyonu ile CSV 
    dosyaları bir DataFrame nesnesi biçiminde okunabilmektedir. read_csv fonksiyonu NumPy'ın loadtxt fonksiyonuna göre oldukça 
    yeteneklidir. Fonksiyon pek çok CSV diyaleğini otomatik anlayabilmektedir. read_csv fonksiyonu CSV dosyasındaki başlık kısmını 
    DataFrame nesnesindeki sütun isimleri haline getirmektedir. Fonksiyon otomatik olarak sütunların türlerini CSV dosyasının içeriğinden 
    hreketle belirleyebilmektedir. 

    read_csv fonksiyonun çok fazla sayıda parametresi vardır. Ancak bu parametrelerin dosyanın yol ifadesi dışındaki parametreleri 
    default değerlerle geçilebilir. Çoğu kez programcının yalnızca CSV dosyasının yol ifadesini vermesi yeterli olmaktadır. 
    Fonksiyonun parametik yapısı şöyledir:

    pandas.read_csv(filepath_or_buffer, *, sep=<no_default>, delimiter=None, header='infer', names=<no_default>, 
            index_col=None, usecols=None, dtype=None, engine=None, converters=None, true_values=None, false_values=None, 
            skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, 
            na_filter=True, verbose=<no_default>, skip_blank_lines=True, parse_dates=None, infer_datetime_format=<no_default>, 
            keep_date_col=<no_default>, date_parser=<no_default>, date_format=None, dayfirst=False, cache_dates=True, 
            iterator=False, chunksize=None, compression='infer', thousands=None, decimal='.', lineterminator=None, 
            quotechar='"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, encoding_errors='strict', 
            dialect=None, on_bad_lines='error', delim_whitespace=<no_default>, low_memory=True, memory_map=False, 
            float_precision=None, storage_options=None, dtype_backend=<no_default>)

    Örneğin:

    df = pd.read_csv('data.csv')
    
#------------------------------------------------------------------------------------------------------------------------------------
   
import pandas as pd

df = pd.read_csv('covid-19.csv')

print(df.columns)
print(df.dtypes)

#------------------------------------------------------------------------------------------------------------------------------------
    read_csv fonksiyonun usecols parametresi yine loadtxt fonksiyonunda olduğu gibi okunacak sütunların numaralarını ya da isimlerini 
    bir liste olarak bizden alır. 
#------------------------------------------------------------------------------------------------------------------------------------
import pandas as pd

df = pd.read_csv('covid-19.csv', usecols=[1, 2, 3])
print(df)

df = pd.read_csv('covid-19.csv', usecols=['Confirmed', 'Deaths', 'Recovered'])
print(df)

#------------------------------------------------------------------------------------------------------------------------------------    
    read_csv fonksiyonu tırnakları da sütun ayıracı olarak akıllı bir biçimde anlayabilmektedir. Örneğin aşağıdaki gibi bir 
    "student.csv" isminde bir dosya olsun:

    "Adı, Soyadı", No,Doğum Yeri
    "Ali, Serçe",123,Tarsus
    "Kaan, Aslan",345,Eskişehir
    "Necati, Ergin",764,Giresun
    "Hasan, Kılışçaslan",523,Van
    "Barış, Gök",692,Çorum
    "Gürbüz, Aslan",823,Eskişehir

    Bu dosyada iki tırnak içerisindeki virgüllerin dikkate alınmamasını, iki tırnaklı sütunların tek bir sütun olarak ele alınmasını 
    istemiş olalım. Fonksiyon default durumda bunu akıllı biçimde yapabilmektedir.  Ancak tırnaklama konusunda bazı ayrıntıları 
    belirleyebilmek için "quoting" isimli parametreden de faydalanılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd

df = pd.read_csv('student.csv')
print(df)

#------------------------------------------------------------------------------------------------------------------------------------
                                        51. Ders 20/09/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Dataframe nesnesi istenirse DataFrame sınıfının to_csv metodu ile CSV dosyası olarak da save edilebilir. Yani bu fonksiyon 
    işlevsel olarak read_csv fonksiyonun tersini yapmaktadır. metot default durumda DataFrame'deki satır etiketlerini de dosyaya 
    yazmaktadır. Eğer bu istenmiyorsa index parametresi False olarak geçilmelidir. 
------------------------------------------------------------------------------------------------------------------------------
   
import pandas as pd

df = pd.read_csv('student.csv')

print(df)
print(df.dtypes)

df.to_csv('x.csv', index=False)

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında DataFrame sınıfının to_csv metodunun dışında başka to_xxx metotları da vardır. Örneğin to_dict isimli metot DataFrame 
    nesbesinden Python sözlüğü oluşturmaktadır:

    import pandas as pd

    df = pd.DataFrame({
        'Adı Soyadı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'],
        'No': [32, 167, 35, 87, 46],
        'Cinsiyet': ['Erkek', 'Erkek', 'Erkek', 'Kadın', 'Kadın']
        })

    print(df)

    d = df.to_dict()
    print(d)
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame sınıfının to_sql isimli metodu bizde sırasıyla bir tablo ismi ve bir bağlantı nesnesi alır. DataFrame içerisindeki 
    bilgileri ilgili tabloya yazar. Tablo varsa default durumda metot exception oluşturmaktadır. Ancak metodun if_exists parametresi 
    "replace" ya da "append" de girilebilmektedir. Böylece biz tek hamlede br CSV dosyasını SQL tablosu haline yazabilmeketyiz. 
    Örneğin:

    df = pd.read_csv('student.csv')

    conn = None
    try:
        conn = sqlite3.connect('student.sqlite')
        df.to_sql('Person', conn)
    except sqlite3.Error as e:
        print(e)
    finally:
        if conn:
            conn.close()                 
    conn.close()      

    Burada "student.csv" isimli CSV dosyası önce DataFrame olarak okunmuş sonra tek hamlede DataFrame sınıfının to_sql metodu ile 
    SQLite3 VTYS tablosu biçiminde save edilmiştir. Tabii siz farklı bağlanı nesnelerini vererek istediğiniz VTYS için bu işlemi 
    yapabilirsiniz.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame sınıfının to_json metodu DataFrame içeriğini bir JSON dosyası biçiminde oluşturmaktadır. Örneğin:
    
    df.to_json('student_json')

    DataFrame sınıfının to_excel metodu DataFrame nesnesinden Excel dosyası oluşturmaktadır. Örneğin:

    df.to_excel('student.xlsx')

    Sınıfın to_numpy metodu ise DataFrame nesnesinden NumPy dizisi oluşturmaktadır. Ancak sütunlar farklı türlerdense to_numpy metodu 
    ile oluşturulan DataFrame nesnesinin dtype türü "object" olur. Örneğin:

    df = pd.DataFrame({
        'Adı Soyadı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'],
        'No': [32, 167, 35, 87, 46],
        'Cinsiyet': ['Erkek', 'Erkek', 'Erkek', 'Kadın', 'Kadın']
        })

    a = df.to_numpy()
    print(a, a.dtype)

    Aslında to_numpy metodunda dtype türü belirtilebilmektedir. Ancak sütunlar bu dtype türü ile ifade edilemezse exception oluşacaktır.

    DataFrame sınıfının to_xmkl metodu da DataFRame nesnesinden XML dosyası oluşturmaktadır. XML konusu kursumuzda ayrı bir başlık 
    altında ele alınacaktır. Örneğin:

    df.to_xml('student.xml')

    Burada dikkat edilmesi gereken bir nokta DataFrame nesnesindeki sütun isimlerinin XML'deki tag isimleri haline getirilmesidir. 
    Dolayısıyla örneğin sütun isimlerin boşluklar olursa bundan geçerli bir XML oluşturulamayacaktır. 

    DataFrame sınıfının to_html metodu da benzerdir. DafaFrame nesnesini HTML tablosu haline getirmektedir. Örneğin:

    df.to_html('student.html')

    Ancak metot bir geçerli bir HTML dosyası oluşturmamakta yalnızca bir HTML dosyasına iliştirilebilecek bir tablo oluşturmaktadır. 

    DataFrame sınıının to_string metodu DataFrame nesnesini bir yazı haline getirmektedir. Metot bu yazıyı geri dönüş değeri olarak 
    vermektedir. Örneğin:

    s = df.to_string()

    print(s)

    DataFrame sınıfının diğer to_xxx metotlarını dokmanlardan inceleyebilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
   DataFrame nesneleri üzerinde de Series nesneleri üzerinde yapılan işlemlerin benzerleri yapılabilmektedir. Tabii DataFrame üzerinde 
   işlem yaparken işlemden tüm sütunlar etkilenmektedir. Buradaki metotların bazılarının yine global fonksiyon karşılıkları da vardır. 
   Bu metotlar ve fonksiyonlar axis parametresi alabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------02d

#------------------------------------------------------------------------------------------------------------------------------------
   Örneğin Series sınıfın mean metodu ya da mean fonksiyonu bir Series nesnesindeki değerlerin ortalamasını bize verir. Ancak DataFrame 
   sınıfının mean metodu ya da global mean fonksiyonu axis temelinde bize satır ya da sütun ortalamalarını vermektedir. Tabii bu 
   tür metotlar ve foksiyonlar DataFrame nesnesinin tüm sütunları üzerinde etkili olduğu için sütunların türlerinin ilgili işlemlere 
   uygun olması gerekir. Örneğin biz kişilerin ad ve soyaflarının bulunduğu sütunun ortalamasını alamayız. Bu metot ve fonksiyonlarda 
   eksen belirtilmezse default olarak axis=0 alınmaktadır. Yani sutunsal işlemler yapılmaktadır. Örneğin:

   df = pd.DataFrame({
        'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
        'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
        'Boy': [172, 156, 182, 153, 171]
        })
        

    means = df[['Kilo', 'Boy']].mean()
    stds = df[['Kilo', 'Boy']].std()

    print(means)    
    print('-' * 20)
    print(stds)

    Burada DataFrame nesnesindeki "Adı" sütunu sayısal bilgi içermemektedir. Bu nedenle biz de yalnızca "Kilo" ve "Boy" sütunlarından
    yeni bir DataFrame nesnesi oluşturarak o sütunların ortalamasını ve standart sapmasını elde ettik.
#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd

df = pd.DataFrame({
    'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
    'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
    'Boy': [172, 156, 182, 153, 171]
    })
    
means = df[['Kilo', 'Boy']].mean()
stds = df[['Kilo', 'Boy']].std()

print(means)    
print('-' * 20)
print(stds)

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame sınıfının yine Series sınıfında olduğu gibi min gibi, max, gibi, sum gibi metotları vardır. Bunlar da axis temelinde 
    işlem yapabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd

df = pd.DataFrame({
    'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
    'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
    'Boy': [172, 156, 182, 153, 171]
    })
    
mins = df[['Kilo', 'Boy']].min()
maxs = df[['Kilo', 'Boy']].max()

print(mins)    
print('-' * 20)
print(maxs)

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame nesnesine doğrudan indeksleeme yoluyla atama yapılırsa bu işlem "sütun eklemek" anlamına gelir. Örneğin:

    df = pd.DataFrame({
        'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
        'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
        'Boy': [172, 156, 182, 153, 171]
        })

    Burada DataFrame nesnesinde kişilerin boy ve kiloları vardır. Biz de bu iki bilgiden hareketle kişilerin "vücut kitle endeksini 
    (body mass index)" elde edip bunu bir sütun olarak eklemek isteyelim. Bunu basit bir biçimde şöyle yapabiliriz:

    df['VKE'] = df['Kilo'] / (df['Boy']  / 100) ** 2

    Burada VKE isminde yeni bir sütun oluşturulacaktır. Veri biliminde olan bilgilerden yukarıdaki gibi olmayan sütunların oluşturulması 
    sürecine "özellik mühendisliği (feature engineering)" denilmektedir. Bu yöntemle sütun eklediğimizde her zaman ekleme sona yapılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    İstatistikte veri kümesindeki sayısal değil sınıf belirten yazısal sütunlara "kategorik sütunlar" ya da "nominal sütunlar" denilmektedir. 
    Pek çok veri bilimi ve makine öğrenmesi algoritması yalnızca yalnızca sayısal veriler üzerinde uygulanmaktadır. Bu nedenle uygulamacı
    tarafından kategorik sütunlar önce sayısal biçime dönüştürülmektedir. Eğer sütunda yalnızca iki kategori varsa bunlardan biri 0 
    ile diğeri 1 ile temsil edilebilir. Ancak sütunda ikiden fazla kategori varsa bunlara birer sayı karşı düşürmek çoğu kez iyi 
    bir yöntem değildir. Çünkü sayılar algoritmalar tarafından "büyük", "küçük" ilişkisiyle değerlendirilme eğilimindedir. Bu nedenle
    "büyük" "küçük" ilişkisini kırmak için iki kategoriden daha fazla kategoriye sahip olan sütunlar üzerinde ismine "one-hot-encoder"
    denilen teknik kullanılmaktadır. Bu teknikte veri kğmesine kategori sayısı kadar sütun eklenir. Her bir değer yalnızca bir sütunu 
    1 olan diğer sütunları 0 olan sayılar haline getirilir. Örneğin kişilere üç renk arasında renk tercihi sorulmuş olsun. Renkler 
    Kırmızı, Yeşil ve Mavi olsun. Kişilerin verdiği yanıtların şunlar olduğunu düşünelim:

    Kırmızı
    Mavi
    Kırmızı
    Yeşil
    Mavi
    Kırmızı
    Yeşil

    Bu renk tercihleri one-hot-encoding biçiminde aşağıdaki sayısallaştırılır:

    Renk_Kırmızı       Renk_Yeşil       Renk_Mavi
    1                   0               0
    O                   0               1
    1                   0               0
    0                   1               0
    0                   0               1
    1                   0               0
    0                   1               0

    Bu otomatik olarka yapan Pandas kodu şöyle olabilir:

    df = pd.DataFrame({
        'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
        'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
        'Boy': [172, 156, 182, 153, 171],
        'Renk': ['Kırmızı', 'Yeşil', 'Mavi', 'Yeşil', 'Kırmızı']
        })
       

    for color in df['Renk'].unique():
        df['Renk_' + color] = (df['Renk'] == color).astype('int32')
    df.drop(['Renk'], axis=1)
#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd

df = pd.DataFrame({
    'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
    'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
    'Boy': [172, 156, 182, 153, 171],
    'Renk': ['Kırmızı', 'Yeşil', 'Mavi', 'Yeşil', 'Kırmızı']
    })
    

for color in df['Renk'].unique():
    df['Renk_' + color] = (df['Renk'] == color).astype('int32')
df.drop(['Renk'], axis=1)
    
print(df)

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame üzerinde bir sütun insert etmek için DataFrame sınıfının insert metodu metodu kullanılabilmektedir. insert metodunun 
    birinci parametresi her zaman insert edilecek sütunun indeks numarasını alır. İkinci parametre insert edilecek sütunun ismini 
    (yani etiketini), üçüncü parametre ise sütun bilgilerini almaktadır. insert metodu "in-place" insert işlemi yapmaktadır. Yani 
    DatFrame nesnesinin kendi üzerinde ekleme yapılmaktadır. Örneğin:

    import pandas as pd

    df = pd.DataFrame({
        'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
        'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
        'Boy': [172, 156, 182, 153, 171],
        'Renk': ['Kırmızı', 'Yeşil', 'Mavi', 'Yeşil', 'Kırmızı']
        })
        
    vke = df['Kilo'] / (df['Boy'] / 100) ** 2
    df.insert(3, 'VKE', vke)

    print(df)

    Buradan şöyle bir çıktı elde edilmiştir:

          Adı  Kilo  Boy        VKE     Renk
    0     Ali  48.3  172  16.326393  Kırmızı
    1    Veli  56.7  156  23.298817    Yeşil
    2  Selami  92.3  182  27.864992     Mavi
    3    Ayşe  65.3  153  27.895254    Yeşil
    4   Fatma  72.3  171  24.725557  Kırmızı

    Insert işleminin şöyle yapıldığına dikkat ediniz:

    df.insert(3, 'VKE', vke)

    Burada yeni eklenecek sütun üçüncü indeksli sütun olacaktır. Eklemecek sütunun ismi 'VKE' biçimindedir. 

    Biz bu insert metoduyla bir Python listesi ya da demetini ya da NumPy nesnesini de kullanabiliriz. Yani metodun üçüncü parametresinin 
    Series belirtmesi zorunlu değildir. Ancak eğer insert edilecek bilgi bir Series nesnesi ise bu durumda Series nesnesinin elemanlarının 
    indeksleri ile DataFrame satırlarının indekslerinin aynı olması gerekmektedir. 

    Biz insert metodu ile bir DataFrame nesnesine başka bir DataFrame nesnesini insert edemeyiz. insert metodu tek bir sütunu insert 
    etmek için kullanılmaktadır. Global bir insert fonksiyonu da bulunmamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd

df = pd.DataFrame({
    'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
    'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
    'Boy': [172, 156, 182, 153, 171],
    'Renk': ['Kırmızı', 'Yeşil', 'Mavi', 'Yeşil', 'Kırmızı']
    })
    
vke = df['Kilo'] / (df['Boy'] / 100) ** 2
df.insert(3, 'VKE', vke)

print(df)

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame nesnesine satır eklemnin birkaç yolu vardır. Örneğin loc indekslemesiyle olmayan bir indekse satır bilgisi atanırsa
    bu ekleme anlamına gelmektedir:

   import pandas as pd

    df = pd.DataFrame({
        'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
        'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
        'Boy': [172, 156, 182, 153, 171],
        'Renk': ['Kırmızı', 'Yeşil', 'Mavi', 'Yeşil', 'Kırmızı']
        })
        
    df.loc[5] = ['Kazım', 83, 182, 'Yeşil']
    print(df)

    Burada satrı indeksleri zaten sayısaldır. Dolayısıyla biz de nesnenin sonuna bir satır eklemiş olduk. Ekrana şunlar basılacaktır:

          Adı  Kilo  Boy     Renk
    0     Ali  48.3  172  Kırmızı
    1    Veli  56.7  156    Yeşil
    2  Selami  92.3  182     Mavi
    3    Ayşe  65.3  153    Yeşil
    4   Fatma  72.3  171  Kırmızı
    5   Kazım  83.0  182    Yeşil

    Bu biçimde satır ekleme yalnızca loc indekslemesi ile yapılmaktadır. iloc indekslemesi ile satır eklenememektedir. DataFrame 
    nesnesinde iki satırın arasına yeni bir satır insert etmek için pratik bir metot bulunmamaktadır. Bu işlemler concat fonksiyonuyla 
    yapılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                            52. Ders 21/09/2025 – Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame ve Series nesneleri concat isimli fonksiyonla birleştirilip yeni bir DataFrame nesnesi elde edilebilmektedir. concat 
    fonksiyonun birinci parametresine biz DataFrame ya da Series nesnelerinden oluşan bir liste ya da demet girebiliriz. Fonksiyon 
    bunları bizim belirttiğimiz sırada uç uca ekleyip yeni bir DataFrame nesnesi oluşturmaktadır. concat fonksiyonu sütun birleştirmesi 
    ya da satır birleştirmesi için kullanılabilir. Fonksiyonun axis parametresi vardır. Eğer axis=0 ise satırsal birleştirme, axis=1 
    ise sütunsal birleştirme yapılmaktadır. concat fonksiyonu ile sütunsal birleştirme yapılırken DataFrame ya da Series nesnelerinin 
    satır indekslerinin (yani etiketlerinin) aynı olması gerekir. Eğer satır indeksleri aynı olmazsa bu durumda her uyuşmayan indeks 
    için ayrı ekleme yapılır. Ancak uyuşmayan elemanlar NaN ile doldurulur. Örneğin:

    df = pd.DataFrame({
        'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
        'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
        'Boy': [172, 156, 182, 153, 171],
        'Renk': ['Kırmızı', 'Yeşil', 'Mavi', 'Yeşil', 'Kırmızı']
        })
        
    vke = df['Kilo'] / (df['Boy'] / 100) ** 2
    vke.name = 'VKE'

    df = pd.concat([df['Adı'], vke, df['Renk']], axis=1)
    print(df)

    Bu örnekte biz DataFrame içersindeki "Kilo" ve "Boy" sütunları yerine "VKE (Vüct Kitle Endeksi)" sütununu yerleştirmek yerleştirmek 
    isteyelim. concat işleminin nasıl yapıldığına dikkat ediniz:

    df = pd.concat([df['Adı'], vke, df['Renk']], axis=1)

    Burada df['Adı'], vke ve df['Renk'] birer Series nesnesidir. Bu üç Series nesnesi birleştirilerek br DataFrame oluşturulmuştur. 
    OluşturulaN DataFrame nesnesi şöyledir:

          Adı        VKE     Renk
    0     Ali  16.326393  Kırmızı
    1    Veli  23.298817    Yeşil
    2  Selami  27.864992     Mavi
    3    Ayşe  27.895254    Yeşil
    4   Fatma  24.725557  Kırmızı

    Burada concat fonksiyonun inplace işlem yapmadığına dikkat ediniz. inplace işlemler genel olarak fonksiyonlar yoluyla değil metotlar 
    yoluyla  yapılmaktadır. inplace işlem yapan bir concat metodu yoktur. concat her zaman bize yeni bir DataFrame nesnesi vermektedir. 
    Örneğin:

    s1 = pd.Series([10, 20, 30, 40, 50], name='A')
    df1 = pd.DataFrame({'B': [4, 7, 2, 1, 8], 'C': [52, 12, 54, 23, 32]})
    s2 = pd.Series([10, 20, 30, 40, 50], name='D')

    df_result = pd.concat([s1, df1, s2], axis=1)
    print(df_result)

    Buradan şöyle DataFrame nesnesi elde edilmektedir:

        A  B   C   D
    0  10  4  52  10
    1  20  7  12  20
    2  30  2  54  30
    3  40  1  23  40
    4  50  8  32  50

    Sütunsal ekleme yapılırken eklenecek Series ya da DataFrame nesnelerinin satır indeksleri (yani etiketleri) aynı olmalıdır. Eğer 
    etiketler farklı olursa farklı etiketler de sütun haline getirilir ancak uyuşmayan etiketler NaN olur. Örneğin:

    s = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'], name='A')
    df = pd.DataFrame({'B': [4, 7, 2, 1, 8], 'C': [52, 12, 54, 23, 32]})

    df_result = pd.concat([s, df], axis=1)
    print(df_result)

    Burada s nesnesi ile df nesnesinin satır etiketleri aynı değildir. Elde edilen df_result isimli DataFrame şöyle olacaktır:

          A    B     C
    a  10.0  NaN   NaN
    b  20.0  NaN   NaN
    c  30.0  NaN   NaN
    d  40.0  NaN   NaN
    e  50.0  NaN   NaN
    0   NaN  4.0  52.0
    1   NaN  7.0  12.0
    2   NaN  2.0  54.0
    3   NaN  1.0  23.0
    4   NaN  8.0  32.0

    Görüldüğü gibi birleştirme yine yapılmıştır. Amcak her satır satır etiketi oluşturulan DataFrame nesnesine yerleştirilmiştir. 
    Eğer etiketin diğer birleştirilen nesnelerde karşılığı yoksa ilgili hücrelerde NaN değeri bulunmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    concat ile biz bir DataFrame'e bir satır da ekleyebiliriz. Bu durumda eklemeyi axis=0 (default durum) parametresi ile yapmamız 
    gerekir. Örneğin:
    
    df1 = pd.DataFrame({
        'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
        'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
        'Boy': [172, 156, 182, 153, 171],
        'Renk': ['Kırmızı', 'Yeşil', 'Mavi', 'Yeşil', 'Kırmızı']
        })
    print(df1)  

    df2 = pd.DataFrame({
        'Adı': ['Hüseyin', 'Can'], 
        'Kilo': [82, 75], 
        'Boy': [183, 176], 
        'Renk': ['Kırmızı', 'Yeşil']
        })
    print(df2)

    df_result = pd.concat([df1, df2], axis=0)
    print(df_result)

    Burada df1 ile df2 satırsal biçimde concat işlemine sokulmuştur. Elde edilen DataFrame nesnesine dikkat ediniz:

           Adı  Kilo  Boy     Renk
    0      Ali  48.3  172  Kırmızı
    1     Veli  56.7  156    Yeşil
    2   Selami  92.3  182     Mavi
    3     Ayşe  65.3  153    Yeşil
    4    Fatma  72.3  171  Kırmızı
    0  Hüseyin  82.0  183  Kırmızı
    1      Can  75.0  176    Yeşil

    Burada eklenen satırın indekslerinin yine 0  ve 1 olduğunu görüyorsunuz. Bu durum bazı işlemlerde sorunlara yol açabilmektedir. 
    Bu durumda birleştirmeden sonra concat fonksiyonun satırlara yeniden indeks vermesi için ignore_index parametresi True 
    geçilmelidir. Örneğin:

    df_result = pd.concat([df1, df2], axis=0, ignore_index=True)

    Elde edilen DataFrame nesnesisinin satırları artık sıfırdan numaralandırılacaktır:

            Adı  Kilo  Boy     Renk
    0      Ali  48.3  172  Kırmızı
    1     Veli  56.7  156    Yeşil
    2   Selami  92.3  182     Mavi
    3     Ayşe  65.3  153    Yeşil
    4    Fatma  72.3  171  Kırmızı
    5  Hüseyin  82.0  183  Kırmızı
    6      Can  75.0  176    Yeşil

    DataFrame nesnesine satırsal olarak bir Series nesnesi ekleyebilir miyiz? İşte durum biraz sorunludur. axis=0 yapılsa ve Series 
    nesnesinin index'leri DataFrame sütunlarıyla aynı olsa bile satırsal concat işlemi istenildiği gibi yapılamamaktadıe. Elimizde
    bir Series nesnesi varsa onu DataFrame haline dönüştürüp satırsal ekleme yapmak gerekir. Bir Series nesnesi Series sınıfının 
    to_frame metodu ile DataFrame nesnesi haline getirilebilmektedir. Örneğin:

    >>> s = pd.Series(['Hüseyin', 67.5, 165, 'Yeşil'], index=['Adı', 'Kilo', 'Boy', 'Renk'])
    >>> s
    Adı     Hüseyin
    Kilo       67.5
    Boy         165
    Renk      Yeşil
    dtype: object
    >>> df = s.to_frame()
    >>> df
                0
    Adı   Hüseyin
    Kilo     67.5
    Boy       165
    Renk    Yeşil

    Burada Series nesnesi to_frame metodu ile tek sütundan oluşan DataFrame nesnesi haline getirilmiştir. Ancak yine bu bir satır 
    formunda olmadığı için axis=0 yapılsa bile Series nesnesi düzgün bir biçimde staırsal olarak eklenemeyecektir. Bu DataFrame 
    nesnesini transpoze etmek gerekir. Örneğin:

    >>> df = s.to_frame().T
    >>> df
        Adı  Kilo  Boy   Renk
    0  Hüseyin  67.5  165  Yeşil

    Şimdi artık concat işlemi yapılabilir. Örneğin:

    df_result = pd.concat([df, s.to_frame().T], axis=0, ignore_index=True)


#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd

df = pd.DataFrame({
    'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
    'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
    'Boy': [172, 156, 182, 153, 171],
    'Renk': ['Kırmızı', 'Yeşil', 'Mavi', 'Yeşil', 'Kırmızı']
    })
print(df)  

s = pd.Series(['Hüseyin', 67.5, 165, 'Yeşil'], index=['Adı', 'Kilo', 'Boy', 'Renk'])

df_result = pd.concat([df, s.to_frame().T], axis=0, ignore_index=True)
print(df_result)

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame nesnesinden sütun ya da satır silmek için Series sınıfında olduğu gibi drop metodu kullanılmaktadır. Bu metot bir ya da 
    birden fazla sütun ya da satır silebilmektedir. Silinecek sütun ya da satırın indeksleri (yani etiketleri) metodun ilk parametresinde 
    bir liste biçiminde belirtilir. Yani sütunsal silme yapılacaksa birinci parametre silinecek sütunların isimlerini satırsal silme 
    yapılacaksa birinci parametres silinecek satırlerın indesklerini belirtmelidir. Bu metot her zaman sütun isimleri ya da satır 
    indeksleri ile çalışmaktadır. Yani bu metoda sütun ya da satırların sıra numaraları verilmemektedir. Sütunsal silmelerde axis=1, 
    satırsal silmelerde axis=0 parametresi girilmeildir. Örneğin:

    df = pd.DataFrame({
        'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
        'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
        'Boy': [172, 156, 182, 153, 171],
        'Renk': ['Kırmızı', 'Yeşil', 'Mavi', 'Yeşil', 'Kırmızı']
        })
    print(df)  
    
    Buradaki DataFrame nesnesi şöyledir:

          Adı  Kilo  Boy     Renk
    0     Ali  48.3  172  Kırmızı
    1    Veli  56.7  156    Yeşil
    2  Selami  92.3  182     Mavi
    3    Ayşe  65.3  153    Yeşil
    4   Fatma  72.3  171  Kırmızı    
    
    Biz bu DatafRame nesnesinden "Adı" ve "Renk" sütunlarını atmak isteyelim. Bu işlemi şöyle yapabiliriz:

    df_result = df.drop(['Adı', 'Renk'], axis=1)

    Elde edilen df_result nesnesi şöyle olacaktır:

       Kilo  Boy
    0  48.3  172
    1  56.7  156
    2  92.3  182
    3  65.3  153
    4  72.3  171

    drop metodu default durumda in-place işlem yapmamaktadır. Yani silmeyi nesnenin üzerinde yapmamakta bize silinmiş yeni bir 
    DataFrame nesnesi vermektedir. Eğer in-plcae işlem yapılmak isteniyorsa inplace parametresine True girilmelidir. Örneğin:

    df.drop(['Adı', 'Renk'], axis=1, inplace=True)

    Tabii bu durumda metot None değeriyle geri dönmektedir. 

    Satırsal silme için axis=0 parametresiyle satır eriketleri verilmelidir. Örneğin:

    df.drop([0, 3], axis=0, inplace=True)

    Burada 0 ile 3 indeskine sahip satırlar silinmektedir. 

    Tabii biz aslında dilimleme yaparak belli elemanları seçerek de yeni bir DataFrame nesnesi oluşturabiliriz. Bu işlem de drop
    işlemine oldukça benzemektedir Örneğin DataFrame nesnesmiz aşağıdaki gibi olsun:

          Adı  Kilo  Boy     Renk
    0     Ali  48.3  172  Kırmızı
    1    Veli  56.7  156    Yeşil
    2  Selami  92.3  182     Mavi
    3    Ayşe  65.3  153    Yeşil
    4   Fatma  72.3  171  Kırmızı

    df = df.iloc[:, [1, 2]]

    Biz burada tüm satırları ancak 1 ve 2 numaralı sütunları aldık. Bu bir çeşit silme gibi oldu. Örneğin:

    df = df[df['Boy'] > 170]

    Burada biz boyu 170'ten büyük satırları alarak adeta diğer satırları silmiş olduk. 

    drop metodunda tıpkı Series sınıfında olduğu gibi tek bir sürun ya da satır silineceksa onun bir liste biçiminde belirtilmesine 
    gerek yoktur. Örneğin:
    
    df.drop('Adı', axis=1, inplace=True)

    Burada yalnızca "Adı" sütunu silinmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Veri bilimi ve makine öğrenmesi uygulamalarında kullanılan klasik veri kümelerinden biri de "Titanik" veri kümesidir. Titanik 
    veri kümesinde Titanik yolcularına ilişkin çeşitli bilgiler bulunmaktadır. Bu bilgiler girildiğinde ilgili kişi "Titanik'te olsaydı
    hayatta kalma olasılığı ne olurdu?" sorusuna yanıt aranmaktadır. Titanik veri kğmesi CSV dosyası olarak aşağıdaki bağlantıdan 
    indirilebilir:

    https://www.kaggle.com/datasets/yasserh/titanic-dataset

    Ancak "Kaggle" sitesinden veri kümesi indirebilmek için siteye üyelik gerekmektedir.  Veri kümesindeki sütunların anlamları 
    şöyledir:

    PassengerId:    Yolcuya verilen benzersiz kimlik numarası.
    Survived:	    Yolcunun kurtulup kurtulmadığı: 0 = Hayır, 1 = Evet.
    Pclass:	        Yolcu sınıfı (mevkii): 1 = 1. Mevkii, 2 = 2. Mevkii, 3 = 3. Mevkii. Sosyo-ekonomik durumu da yansıtıyor.
    Name:	        Yolcunun tam adı (çoğu zaman unvan da içeriyor: Mr., Mrs., Miss, Master vb.).
    Sex:	        Cinsiyet (male veya female).
    Age:	        Yolcunun yaşı (bazı kayıtlar eksik).
    SibSp:	        Yolcunun Titanic’teki kardeş ya da eşi sayısı. (Sibling/Spouse)
    Parch:	        Yolcunun Titanic’teki ebeveyn ya da çocuk sayısı. (Parent/Children)
    Ticket:	        Yolcunun bilet numarası.
    Fare:	        Ödenen bilet ücreti (Sterlin cinsinden).
    Cabin:	        Yolcunun kamarası (birçok kayıt eksik).
    Embarked:	    Yolcunun bindiği liman. C = Cherbourg (Fransa), Q = Queenstown (şimdiki Cobh, İrlanda), S = Southampton (İngiltere)

    Veri kümesi eksik veriler de barındırmaktadır. Yani bazı kişilerin bazı sütun verileri yoktur. Bu CSV dosyası aşağıdaki gibi 
    Pandas'ın read_csv fonksiyonuyla DataFrame olarak okunabilir:

    >>> df = pd.read_csv('Titanic-Dataset.csv')
    >>> df
        PassengerId  Survived  Pclass  ...     Fare Cabin  Embarked
    0              1         0       3  ...   7.2500   NaN         S
    1              2         1       1  ...  71.2833   C85         C
    2              3         1       3  ...   7.9250   NaN         S
    3              4         1       1  ...  53.1000  C123         S
    4              5         0       3  ...   8.0500   NaN         S
    ..           ...       ...     ...  ...      ...   ...       ...
    886          887         0       2  ...  13.0000   NaN         S
    887          888         1       1  ...  30.0000   B42         S
    888          889         0       3  ...  23.4500   NaN         S
    889          890         1       1  ...  30.0000  C148         C
    890          891         0       3  ...   7.7500   NaN         Q

    Görüldüğü gibi eksik veriler NaN biçiminde gözükmektedir. İzleyen paragraflarda bazı konularda bu veri kümesisini kullanacağız.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame sınıfının dropna metodu da çok sık kullanılmaktadır. Daha önceden de belirttiğimiz gibi Pandas'ın read_csv fonksiyonu 
    eksik verileri default durumda NaN biçiminde okumaktadır. İşte biz eksik verilerin bulunduğu satırı ya da sütunu tümden atmak 
    isteyebiliriz. dropna metodunun  axis parametresi de vardır. Bu parametre 0 geçilirse eksik verilen bulunduğu satırlar,  1 geçilirse 
    sütunlar atılır. Metodun inplace parametresi default durumda False biçimdedir. Bu durumda metot eksik verilerin bulunmadığı 
    yeni bir DataFrame nesnesi verir. Bu parametre True geçilirse silme işlemi nesnenin üzerinde yapılmaktadır. Örneğin "Titanic" veri 
    kümesini okumuş olalım:

    >>> df = pd.read_csv('Titanic-Dataset.csv')

    Veri kümesindeki satır sayısını len fonksiyonuyla ya da DataFrame sınıfının shape örnek özniteliği öğrenebiliriz:

    >>> len(df)
    891
    >>> df.shape
    (891, 12)

    Şimdi eksik verilerin bulunduğu satırları atmak isteyelim:

    >>> df_result = df.dropna(axis=0)
    >>> df_result
        PassengerId  Survived  Pclass  ...     Fare        Cabin  Embarked
    1              2         1       1  ...  71.2833          C85         C
    3              4         1       1  ...  53.1000         C123         S
    6              7         0       1  ...  51.8625          E46         S
    10            11         1       3  ...  16.7000           G6         S
    11            12         1       1  ...  26.5500         C103         S
    ..           ...       ...     ...  ...      ...          ...       ...
    871          872         1       1  ...  52.5542          D35         S
    872          873         0       1  ...   5.0000  B51 B53 B55         S
    879          880         1       1  ...  83.1583          C50         C
    887          888         1       1  ...  30.0000          B42         S
    889          890         1       1  ...  30.0000         C148         C

    [183 rows x 12 columns]
    >>> df_result.shape
    (183, 12)

    891 satırlık veri kümesi 183 satıra düştü. O halde bu veri kümesinde çok fazla eksik veri vardır. Daha önceden de belirttiğimiz 
    gibi bu tür durumlarda satırları atmak yerine onlar yerine makul değerler yerleştirmek de (imputation) söz konusu olabilir. 
    Pekiyi eksik verilerin bulunduğu satırları değil de sütunları atsaydık ne olurdu? Deneyelim:

    >>> df_result.shape
    (183, 12)
    >>> df_result = df.dropna(axis=1)
    >>> df_result
        PassengerId  Survived  Pclass  ... Parch            Ticket     Fare
    0              1         0       3  ...     0         A/5 21171   7.2500
    1              2         1       1  ...     0          PC 17599  71.2833
    2              3         1       3  ...     0  STON/O2. 3101282   7.9250
    3              4         1       1  ...     0            113803  53.1000
    4              5         0       3  ...     0            373450   8.0500
    ..           ...       ...     ...  ...   ...               ...      ...
    886          887         0       2  ...     0            211536  13.0000
    887          888         1       1  ...     0            112053  30.0000
    888          889         0       3  ...     2        W./C. 6607  23.4500
    889          890         1       1  ...     0            111369  30.0000
    890          891         0       3  ...     0            370376   7.7500

    [891 rows x 9 columns]
    >>> df_result.shape
    (891, 9)

    Görüldüğü gibi 13 sütunluk veri kümesi 9 sütuna inmiştir. O halde yalnızca 4 sütunda eksik veriler bulunmaktadır. Hangi 
    sütunların atıldığını birkaç biçimde öğrenebiliriz. Series sınıfının difference metodu birinde olan diğerinde olmayan elemanları
    bir Series nesnesi biçiminde vermektedir. Örneğin:

    >>> df.columns.difference(df_result.columns)
    Index(['Age', 'Cabin', 'Embarked'], dtype='object')

    Örneğin biz "Age" sütunundaki eksik verileri Series sınıfının fillna metoduyla ortalama değerle doldurabiliriz:

    >>> df_result = df['Age'].fillna(df['Age'].mean)
    >>> df_result
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Eksik veriler üzerinde işlem yapmadan önce sütunlarda kaçar tane eksik verinin bulunduğuna bakılmalıdır. Eksik veriler çok fazlaysa 
    doldurma (imputation) iyi bir seçenek olmaktan çıkmaktadır. Veri bilmcisi bunun için bir eşik değer seçebilir. Series ve DataFrame
    sınıflarının isna metotları bool bir Series ya da DataFrame nesnesine geri dönmektedir. Bu nesnedeki True elemanlar eksik verileri 
    False elemanlar eksik olmayan verileri belirtir. Örneğin:

    >>> df.isna().sum(axis=0)
    PassengerId      0
    Survived         0
    Pclass           0
    Name             0
    Sex              0
    Age            177
    SibSp            0
    Parch            0
    Ticket           0
    Fare             0
    Cabin          687
    Embarked         2

    Burada df.isna metodu ile bool değerlerdne oluşan bir DataFrame elde edilmiştir. Daha sonra sütunsal toplama yapılarak True
    olanların sayısına bakılmıştır. Elde edilen sonua dikkat ediniz. Titanic veri kümesinde 177 kişinin "Age" bilgisi, 687 kişinin 
    "Cabin" bilgisi ve 2 kişinin de "Embarked" bilgisi yoktur. "Cabin" sütunundaki eksiklik çok fazladır. Bu kadar fazla eksikliği 
    olan sütunlarda eksik verilerin doldurulması yerine sütunun tümdem atılması tercih edilebilmektedir. Bu konuda pratik olarak 
    şunlar söylenebilir:

    - %0–5	Stun tutulabilir, eksikler ortalama/medyan/mod ile doldurulabilir.
    - %5–20	Sütunun önemi yüksekse doldurulabilir, değilse atılabilir.
    - %20–50 Çoğu zaman atılma yoluna gidilir.
    - %50+	Sütun tamamen atılır.

    Brada Age sütununu ortalama ile doldurabiliriz ya da tamamen atabiliriz. Doldurma şöyle yapılabilir:

    df['Age'] = df['Age'].fillna(df['Age'].mean())

    Buarada df['Age'] ifadesi ile DataFrame nesnesinin "Age" sütununa ilişkin Series elde edilmiş ve Series sınıfının fillna 
    metodu kullanılmıştır. Tabii elde edilen Series nesnesi yeniden "Age" sütununa atanmıştır.
    
    Aslında DataFrame sınıfının da bir fillna metodu vardır. Bu metodun birinci parametresi bir değer olarak girilirse tüm eksik 
    veriler bu değerle doldurulur. Fakat değişik sütunlar değişik değerlerle de doldurulmak istenebilir. Bunun için fillna metodunun 
    birinci parametresi bir sözmlük olarak girilebilir. Bu sözlüğün anahtarları sütun isimlerinden değerleri de o sütuna odldurulacak 
    değerlerden oluşur. Örneğin:

    >>> df_result = df.fillna({'Age': df['Age'].mean(), 'Embarked': df['Embarked'].mode()})

    Burada biz "Age" sütunundaki eksik verileri o sütunun ortalaması ile, "Embarked" sütunundaki eksik verileri ise o sütundanki
    mod değeri ile doldurkuk. fillna metodunun da inplace parametresi bulunmaktadır. "Cabin sütununda çok fazla eksik veri olduğu 
    için bu sütunu tamamen atabiliriz:

    >>> df_result = df_result.drop('Cabin', axis=1)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame nesnesi üzerinde belirli koşulları sağlayan değerleri elde etmek için Series sınıfında anlattığımız bool indeksleme 
    kullanılabilir. Örneğin Titanic veri kümesinde yaşı 10'dan küçük olan yolculara ilişkin satırları şöyle elde edebiliriz:

    >>> df[df['Age'] < 10]
     PassengerId  Survived  Pclass                                      Name  ...           Ticket     Fare  Cabin  Embarked
    7              8         0       3            Palsson, Master. Gosta Leonard  ...           349909  21.0750    NaN         S
    10            11         1       3           Sandstrom, Miss. Marguerite Rut  ...          PP 9549  16.7000     G6         S
    16            17         0       3                      Rice, Master. Eugene  ...           382652  29.1250    NaN         Q
    24            25         0       3             Palsson, Miss. Torborg Danira  ...           349909  21.0750    NaN         S
    43            44         1       2  Laroche, Miss. Simonne Marie Anne Andree  ...    SC/Paris 2123  41.5792    NaN         C
    ..           ...       ...     ...                                       ...  ...              ...      ...    ...       ...
    827          828         1       2                     Mallet, Master. Andre  ...  S.C./PARIS 2079  37.0042    NaN         C
    831          832         1       2           Richards, Master. George Sibley  ...            29106  18.7500    NaN         S
    850          851         0       3   Andersson, Master. Sigvard Harald Elias  ...           347082  31.2750    NaN         S
    852          853         0       3                   Boulos, Miss. Nourelain  ...             2678  15.2458    NaN         C
    869          870         1       3           Johnson, Master. Harold Theodor  ...           347742  11.1333    NaN         S

    Yaşı 10'dan küçük olan yolcuların yaşlarını ve sağkalım durumlarını şöyle elde edebiliriz:

    >>> df[df['Age'] < 10][['Survived', 'Age']]

         Survived   Age
    7           0  2.00
    10          1  4.00
    16          0  2.00
    24          0  8.00
    43          1  3.00
    ..        ...   ...
    827         1  1.00
    831         1  0.83
    850         0  4.00
    852         0  9.00
    869         1  4.00

    Pekiyi "yaşı 10'dan küçük olan ve hayatını kaybedne yolcuların listesini" nasıl alabiliriz? Bu işlem şöyle şöyle yapılabilir:

    >>> df_result = df[(df['Age'] < 10) & (df['Survived'] == 0)]

    Bu tür filtrelemeler için Pandas'ta DataFrame sınıfında quert isimli güçlü bir metot bulundurumuştur. Bu metot adreta SQL'deki
    SELECT komutu gibi çalışmaktadır. Bu metoda SQL SELECT cümlesi gibi bir yazı girilirse koşulu sağlayan satırlar bir DataFrame 
    biçiminde elde edilebilecektir. Örneğin:

    df_result = df.query('Age < 10 and Survived == 0')

    Burada "yaşı 10'dan küçük ve hayatını kaybetmiş olan" kişiler DataFrame nesnesi biçiminde elde edilmektedir. Eğer bu 
    koşulları sağlayan satırların belli sütunları seçilecekse ayrıca indeksleme yapılmalıdır. Örneğin:

    >>> df_result = df.query('Age < 10 and Survived == 0')[['Age', 'Name']]
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Series ve DataFrame sınıflarının apply isimli metotları da vardır. Bu metotların birinci parametresine bir fonksiyon girilir. 
    Metotlar sütunlardkai değerleri girilen bu fonksiyona parametre yapıp onun geri dönüş değerini bize vermektedir. Örneğin:

    df['Age'] = df['Age'].apply(lambda x: x - 10)

    Burada yolcuların "Age" sütunlarındaki değerler yerine onların 2 eksiği oraya yerleştirilmiştir. DatFrame sınıfının apply metodu 
    axis parametresi de almaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                            53. Ders 27/09/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Series nesnesinde yazı varsa (dtype='object' ya da dtype='string' de olabilir) o Series nesnesinin str isimli özniteliği yazısal 
    bize sütunlar üzerinde işlemler yapabilmemiz için bir nesne vermektedir. Bu nesne Python'daki str nesnesi gibidir. Biz de yazılsa 
    sütunlar üzerinde tipik string işlemlerini yapabilidirn. Örneğin:

    >>> df = pd.read_csv('us-counties.csv')
    >>> df
                date      geoid      county  ... deaths  deaths_avg  deaths_avg_per_100k
    0        2020-01-21  USA-53061   Snohomish  ...      0        0.00                 0.00
    1        2020-01-22  USA-53061   Snohomish  ...      0        0.00                 0.00
    2        2020-01-23  USA-53061   Snohomish  ...      0        0.00                 0.00
    3        2020-01-24  USA-53061   Snohomish  ...      0        0.00                 0.00
    4        2020-01-24  USA-17031        Cook  ...      0        0.00                 0.00
    ...             ...        ...         ...  ...    ...         ...                  ...
    1774199  2021-09-29  USA-69120      Tinian  ...      0        0.00                 0.00
    1774200  2021-09-29  USA-69110      Saipan  ...      0        0.00                 0.00
    1774201  2021-09-29  USA-78030  St. Thomas  ...      1        0.14                 0.28
    1774202  2021-09-29  USA-78020    St. John  ...      0        0.00                 0.00
    1774203  2021-09-29  USA-78010   St. Croix  ...      0        0.14                 0.28

    [1774204 rows x 10 columns]

    >>> df['state']
    0                        Washington
    1                        Washington
    2                        Washington
    3                        Washington
    4                          Illinois
                        ...
    1774199    Northern Mariana Islands
    1774200    Northern Mariana Islands
    1774201              Virgin Islands
    1774202              Virgin Islands
    1774203              Virgin Islands
    Name: state, Length: 1774204, dtype: object

    >>> df['state'].str.len()
    0          10
    1          10
    2          10
    3          10
    4           8
            ..
    1774199    24
    1774200    24
    1774201    14
    1774202    14
    1774203    14
    Name: state, Length: 1774204, dtype: int64

    Burada DataFrame nesnesi ile nesnenin 'state' sütununa ilişkin Series nesnesi elde edilmiştir. Sonra da str özniteliğinden 
    hareketle sütunlardaki eyalet belirten yazıların uzunlukları bulunmuştur. str ile kullanılabilecek bazı metotlar şunlardır:

    ⮞ Dönüştürme / Biçimlendirme

    str.capitalize()
    str.casefold()
    str.lower()
    str.upper()
    str.swapcase()
    str.title()
    str.normalize(form)
    str.strip([chars])
    str.lstrip([chars])
    str.rstrip([chars])
    str.pad(width, side='left', fillchar=' ')
    str.center(width, fillchar=' ')
    str.zfill(width)
    str.wrap(width, ...)

    ⮞ Arama / Koşul

    str.contains(pat, case=True, regex=True)
    str.startswith(pat)
    str.endswith(pat)
    str.match(pat)
    str.fullmatch(pat)
    str.isalnum()
    str.isalpha()
    str.isdigit()
    str.isspace()
    str.islower()
    str.isupper()
    str.istitle()
    str.isnumeric()
    str.isdecimal()
    str.isidentifier()
    str.isascii()

    ⮞ Arama / Konum bulma

    str.find(sub)
    str.rfind(sub)
    str.index(sub)
    str.rindex(sub)
    str.len()
    str.count(pat)

    ⮞ Regex tabanlı işlemler

    str.extract(pat, expand=True)
    str.extractall(pat)
    str.replace(pat, repl, case=True, regex=True)
    str.findall(pat)
    str.get_dummies(sep='|')

    ⮞ Bölme / Parçalama

    str.split(pat=None, n=-1, expand=False)
    str.rsplit(pat=None, n=-1, expand=False)
    str.partition(sep)
    str.rpartition(sep)
    str.slice(start=None, stop=None, step=None)
    str.slice_replace(start=None, stop=None, repl=None)
    str.get(i)

    ⮞ Dizge Manipülasyonu

    str.cat(others=None, sep=None, na_rep=None, join=None)
    str.repeat(repeats)
    str.replace(...)
    str.wrap(width)
    str.translate(table)

    ⮞ Bilgi / Yardımcı

    str.encode(encoding, errors='strict')
    str.decode(encoding, errors='strict')
    str.contains(...)
    str.count(...)

    Örneğin:

    >>> df.query('state.str.len() < 10 & cases_avg > 10')
                date      geoid         county     state  ...  cases_avg_per_100k  deaths  deaths_avg  deaths_avg_per_100k
    788      2020-03-08  USA-36119    Westchester  New York  ...                1.20       0        0.00                 0.00
    906      2020-03-09  USA-36119    Westchester  New York  ...                1.43       0        0.00                 0.00
    1052     2020-03-10  USA-36119    Westchester  New York  ...                1.58       0        0.00                 0.00
    1234     2020-03-11  USA-36119    Westchester  New York  ...                1.64       0        0.00                 0.00
    1455     2020-03-12  USA-36998  New York City  New York  ...                0.16       0        0.00                 0.00
    ...             ...        ...            ...       ...  ...                 ...     ...         ...                  ...
    1774190  2021-09-29  USA-01015        Calhoun   Alabama  ...               91.04       0        3.14                 2.77
    1774193  2021-09-29  USA-01009         Blount   Alabama  ...               59.79       0        1.14                 1.98
    1774194  2021-09-29  USA-01007           Bibb   Alabama  ...               70.17       0        0.43                 1.91
    1774196  2021-09-29  USA-01003        Baldwin   Alabama  ...               29.63       4        3.71                 1.66
    1774197  2021-09-29  USA-01001        Autauga   Alabama  ...               37.59       1        1.00                 1.79

    [399595 rows x 10 columns]
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Python'da istatistiksel grafikler çizmek için en çok kullanılan üç kütüphane "Matplotlib", "Seaborn" ve "Plotly" isimli 
    kütüphaneleridir. Başka alternatifler olsa da bu alternatifler henüz bunlarla rekabet edecek düzeye gelmemiştir. Biz burada 
    Matplotlib üzerinde duracağız. Çünkü en yaygın kullanılan grafik çizme kütüphanesi Matplotlib isimli kütüphanedir. Bu kütüphane 
    temel istatistiksel grafikler çizmek için kullanılmaktadır. Borsalarda kullanılan "mum grafiği (candle stick graphics)" gibi özel 
    amaçla kullanılan grafikler bu kütüphane ile çizilememektedir. 

    Matplotlib Anaconda dağıtımının doğal bir parçası durumundadır. Bu nedenle bu dağıtım install edildiğinde Matplotlib de zaten 
    kurulmuş durumdadır. Ancak diğer dağıtımlarda ve IDE'lerde bu kütüphanenin aşağıdaki gibi ayrıca kurulması gerekir:

    pip install matplotlib

    Kütüphanenin doğrudan çizim için kullanılan alt paketi "pyplot" isimli pakettir. Dolayısıyla genellikle programcılar doğrudan bu 
    paketi kullanırlar. Biz de çizimlerimizde bu paketi aşağıdaki gibi import edeceğiz:

    import matplotlib.pyplot as plt

    matplotlib.pyplot paketi kütüphanein yüksek seviyeli ve kullanıların doğrudan kullandığı en önemli kapetidir. 

    Bu kütüphane "klasik prosedürel teknikle" yani fonksiyonlar yoluyla ya da "nesne yönelimli teknikle" yani sınıfların metotlarını 
    çağırarak da kullanılabilmektedir. Biz önce prosedürel kullanım üzerinde duracağız. Sonra sınıfsal kullanımı ele alacağız. 

    Kütüphanenin dokümantasyonuna aşağıdaki bağlantıdan erişilebilir:

    https://matplotlib.org/stable/index.html
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Matplotlib kütüphanesinde önemli iki kavram vardır: Figür (figure) ve Eksen (axis). Figür eksenleri tutan bir kap gibi (ya da 
    "canvas" da diyebiliriz) düşünülmüştür. Biz çizimleri eksenlere yaparız. En sık karşılaşılan durum bir figüde bir eksen bulunması 
    durumudur. Ancak bir figürde birden fazla eksen de bulunabilir. 

    Çizim işlemleri prosedürel teknikle yapılacaksa zaten bu teknikte işin başında default bir figür ve eksen yaratılmış durumdadır. 
    Dolayısıyla çizimler zaten var olan figür ve eksen üzerine yapılır. Bizim yaratmadığımız zaten işin başında yaratılmış olan bu 
    figür ve eksene "default figür" ve "default eksen" denilmektedir. Çizim fonksiyonları prosedürel teknikte her zaman çizimleri 
    default figürdeki default eksene yapmaktadır. 

    Matplotlib'te değişik grafikler için değişik fonksiyonlar kullanılmaktadır. Çizim işlemlerinden sonra show fonksiyonu çağrılmalıdır. 
    show fonksiyonu görüntülemeyi yapmaktadır. show fonksiyonu çağrıldıktan sonra artık figür ve eksen sıfırlanmış olur. Yani sıfırdan 
    eksene yeni bir çizim yapılabilir. 

    Anaconda'nın Spyder IDE'sinde yapılan çizimlerin doğrudan IPython ekranında görüntülenmesi için yukarıda "Plots" sekmesi seçilip 
    sağ üstteki çizgili menüden Mute inline plotting" unchecked yapılmalıdır. Aksi takdirde çizimler "Plots" sekmesinde görüntülenecektir. 
    Text ekranda komut satırında çizim yapılırken çizimler show fonksiyonu çağrıldığında bir popup pencere üzerinde görüntülenmektedir. 
    Spyder'da "Mute inline plotting" unchecked yapıldığında show fonksiyonu çağrılmadan görüntüleme yapılabilmektedir. Ancak siz 
    her zaman show fonksiyonunu çağırmalısınız. Çünkü show fonksiyonunun başla işlevleri de vardır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    En çok kullanılan çizim fonksiyonu şüphesiz plot isimli fonksiyondur. plot çizgi grafiği çizmektedir. Tipik olarak bu fonksiyon 
    x ve y değerlerini birer liste ya da NumPy dizisi olarak alır. Bu x ve y listelerinin karşılıklı elemanlarını nokta olarak kabul 
    edip onları çizgilerle birleştirir. Tabii bu noktaların sayısı çoksa çizgiler küçük olacak ve çizgiler kırıklı gözükmeyecektir. 
    Örneğin aşağıda bir sinüs eğrisi örneği verilmiştir. Bu örneği NPOINTS değerini gittikçe artırarak deneyiniz. Nokta sayısı arttıkça 
    kırıklı görünüm ortadan kalkacaktır. 

    NPOINTS = 20

    x = np.linspace(-6.28, 6.28, NPOINTS)
    y = np.sin(x)

    plt.plot(x, y)
    plt.show()
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt
import numpy as np

NPOINTS = 20

x = np.linspace(-6.28, 6.28, NPOINTS)
y = np.sin(x)

plt.plot(x, y)
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    show yapana kadar çizdiğimiz tüm grafikler aynı eksende görüntülenir. Matplotlib otomatik olarak her grafiği farklı renkle 
    çizdirmektedir. Yukarıda da belirttiğimiz gibi her show işleminden sonra sıfırdan yeni bir eksen başlatılır. Biz de yeni bir 
    çizime başlamış oluruz. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt
import numpy as np

NPOINTS = 1000

x = np.linspace(-6.28, 6.28, NPOINTS)
y = np.sin(x)

plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
        Aşağıda yine birden fazla çizim aynı eksen üzerine yapılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-6, 6, 100)

y = x ** 2 - 4
plt.plot(x, y)

y = 3 * x - 2
plt.plot(x, y)

y = 0.01 * x ** 3
plt.plot(x, y)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda 2^x üstel fonksiyonunun grafiği çizilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(0, 10, 10000)
y = 2 ** x

plt.plot(x, y)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda sigmoid fonksiyonunun grafiği çizdirilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(-10, 10, 1000)
y = 1 / (1 + np.e ** -x)

plt.plot(x, y)
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir grafik çizdiğimiz zaman grafikte 0 noktası ve eksanlardeki değerler otomatik olarak uygun bir biçimde belirlenmektedir. Yani
    çizdirdiğiniz grafikte beklediğiniz kartezyen koordinat sistemini göremeyebilirsiniz. Default durumda eksenin dört tarafında 
    çizgilerle bir kutu gibi kapatılmaktadır Tabii çizimin kartezyen koordinat sistemi gibi birbirini dik kesen iki doğru üzerinde 
    görünmesini de sağlayabilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Grafiğe çeşitli öğeler ekleyerek grafin daha dolgun gözükmesi sağlanabilmektedir. Örnein grafiğe bir başlık yazısı eklemek için 
    title isimli fonksiyon kullanılmaktadır. Örneğin:

    plt.title('Sigmoid Fonksiyonu')
    x = np.linspace(-10, 10, 1000)
    y = 1 / (1 + np.e ** -x)

    plt.plot(x, y)
    plt.show()

    Burada eksenin üzerinde "Sigmoid Fonksiyonu" yazısı çıkacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Sigmoid function')
x = np.linspace(-10, 10, 1000)
y = 1 / (1 + np.e ** -x)

plt.plot(x, y)
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    title fonksiyonunda loc parametresi başlığın hizalamasında kullanılır. Default durum "center" biçimindedir. Ancak biz bu parametreye 
    "left" ya da "right" girebiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-6, 6, 100)

plt.title("Sinus-Kosinüs Grafiği", loc='left')

y = np.sin(x)
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    title fonksiyonunun pad (padding) parametresi başlık yazısının grafiğin ne kadar yukarısında görüntüleneceğini belirtmektedir. 
    Default durum 6 pixeldir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-6, 6, 100)

plt.title("Sinus-Kosinüs Grafiği", pad=20)

y = np.sin(x)
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    title fonksiyonundaki **kwargs parametresine için sayıda isimli parametre girilebilmektedir. Bu parametreler plt.text fonksiyonunda 
    dokümante edilmiştir. Önemli olanları şunlardır:
    
    color: Yazının rengini belirtir. Renk isim olarak girilebilir. Ya da '#rrggbb' biçiminde hex digitler biçiminde de girilebilir. 
    fontsize: Yazının puntosunu belirler. 
    fontfamily: Yazının font ismini belirtir. 
    fontstyle: 'bold', 'italic' ya da 'normal' olabilir. 
    fontweight: Font'un bold'luk durumu ile ilgilidir. Bu parametreye 'bold', 'semibold', 'heavy', 'extrabold' gibi değerler 
    girilebilmektedir.
    x ve y: Yazının ortasının bulunduüu x ve y pozisyonlarını belirtmektedir. Buradaki grafikteki x ve y koordinatlarıdır. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-6.28, 6.28, 100)

plt.title("Sinus-Kosinüs Grafiği", pad=40, color='red', fontsize=20, fontfamily='arial', fontstyle='italic', fontweight='bold', x=0.5)

y = np.sin(x)
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Hangi grafiğin hangi amaçla kullanıldığını belirten simgelere grafik terminolojisinde "legend" denilmektedir. Legend oluşturmak 
    için legend isimli fonksiyon kullanılmaktadır. Fonksiyona yazılardan oluşan dolaşılabilir bir nesne verilir. Fonksiyon da bu 
    yazılardan hareketle legend'ları oluşturur. legend fonksiyonu grafikler çizildikten sonra (örneğin plot çağrılarından sonra)  
    çağrılmalıdır. Örneğin:

    plt.title('Kosinüs - Hiperbolik Tanjant Fonksiyonları', color='blue')

    x = np.linspace(-10, 10, 1000)
    y = (np.e ** x - np.e ** -x) / (np.e ** x + np.e ** -x) 
    plt.plot(x, y)

    y = np.cos(x)
    plt.plot(x, y)
    plt.legend(['tanh', 'cos'])

    plt.show()
    
    legend bilgisi otomatik olarak grafiğin uygun bir yerine yerleştirilmektedir. Ancak legend fonksiyonunun loc parametresi ile bu 
    yerleşim yerini biz de belirleyebiliriz. loc parametresi 'upper left', 'upper right', 'lower left', 'lower right' , 'upper center' 
    gibi değerler alabilmektedir. Bu parametrenin alabileceği değerlerin listesi şunlardır:

    best
    upper right
    upper left
    lower left
    lower right
    right
    center left
    center right
    lower center
    upper center
    center

    legend fonksiyonunda legend yazıları çeşitli isimli parametrelerle özelleştirilebilmektedir. Bu isimli parametreleri maptlotlib'teki 
    legend fonksiyonun dokümantasyonundan öğrenebilirsiniz. Örneğin yine fontsize parametresi legend yazılarının büyüklüğünü, labelcolor 
    parametresi yazıların renklerini, edgecolor legend kutucuğunun rengini, facecolor kutucuğun zemin rengini belirlemekte kullanılabilir. 
    Örneğin:

    plt.legend(['tanh', 'cos'], facecolor='gray', edgecolor='red')
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Kosinüs - Hiperbolik Tanjant Fonksiyonları', color='blue')

x = np.linspace(-10, 10, 1000)
y = (np.e ** x - np.e ** -x) / (np.e ** x + np.e ** -x) 
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)
plt.legend(['tanh', 'cos'], facecolor='gray', edgecolor='red')

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Grafiğin içerisine ızgara çizgileri grid isimli fonksiyonla yerleştirilebilir. Böylece sanki grafik bir çeşit grafik kağıdına 
    çizilmiş gibi gözükür. grid fonksiyonun ızgara çizgilerinin biçimini belirleyen çeşitli isimli parametreleri vardır. Bu parametreler
    dokümanlardan incelenebilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Kosinüs - Hiperbolik Tanjant Fonksiyonları', color='blue')
plt.grid()

x = np.linspace(-10, 10, 1000)
y = (np.e ** x - np.e ** -x) / (np.e ** x + np.e ** -x) 
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)
plt.legend(['tanh', 'cos'], facecolor='gray', edgecolor='red')

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Çizimdeki x ve y eksenlerine isim vermek için xlabel ve ylabel fonksiyonları kullanılmaktadır. Bu fonksiyonlar da  gösterilecek 
    yazının  biçimleriyle ilgili isimli parametreler almaktadır. Bu parametrelerin tam listesi için title fonksiyonunda belirttiğimiz
    gibi text fonksiyonunun dokğmanlarına başvurabilirsiniz. En çok kullanılan parametreler şunlardır:

    color
    fontsize
    fontfamily
    fontstyle
    fontweight

    Örneğin:

    plt.xlabel('X', fontweight='bold', color='red')
    plt.ylabel('Y', fontweight='bold', color='red')

    Yine fonksiyonların loc parametreleri yazının yerini belirlemekte kullanılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Kosinüs - Hiperbolik Tanjant Fonksiyonları', color='blue')

plt.xlabel('X', fontweight='bold', color='red', loc='center')
plt.ylabel('Y', fontweight='bold', color='red')

plt.grid()
x = np.linspace(-10, 10, 1000)
y = (np.e ** x - np.e ** -x) / (np.e ** x + np.e ** -x) 
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)
plt.legend(['tanh', 'cos'], facecolor='gray', edgecolor='red')

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    x ve y eksenleri için aralık xlim ve ylim fonksiyonlarıyla belirlenebilir. Böyle bir belirleme yapılmadıysa matplotlib bu 
    belirlemeleri kendisi yapmaktadır. Örneğin:

    plt.ylim(-2, 2)
    plt.xlim(-12, 12)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Kosinüs - Hiperbolik Tanjant Fonksiyonları', color='blue')

plt.xlabel('X', fontweight='bold', color='red', loc='center')
plt.ylabel('Y', fontweight='bold', color='red')

plt.ylim(-2, 2)
plt.xlim(-12, 12)

plt.grid()
x = np.linspace(-10, 10, 1000)
y = (np.e ** x - np.e ** -x) / (np.e ** x + np.e ** -x) 
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)
plt.legend(['tanh', 'cos'], facecolor='gray', edgecolor='red')

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Eksenlerdeki tick'lerin yerlerini belirlemek için xticks ve yticks fonksiyonları kullanılmaktadır. Yine xticks ve yticks fonksiyonlarında
    tick'lerin biçimini belirleyen text fonksiyonunda dokümante edilmiş olan isimli parametreler kullanılabilmektedir. Örneğin:

    plt.xticks(range(-12, 13, 2), color='blue', fontsize=9)
    plt.yticks(np.arange(-2, 2, 0.25), color='blue', fontsize=9)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Kosinüs - Hiperbolik Tanjant Fonksiyonları', color='blue')

plt.xlabel('X', fontweight='bold', color='red', loc='center')
plt.ylabel('Y', fontweight='bold', color='red')

plt.ylim(-2, 2)
plt.xlim(-12, 12)

plt.xticks(range(-12, 13, 2), color='blue', fontsize=9)
plt.yticks(np.arange(-2, 2, 0.25), color='blue', fontsize=9)

plt.grid()
x = np.linspace(-10, 10, 1000)
y = (np.e ** x - np.e ** -x) / (np.e ** x + np.e ** -x) 
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)
plt.legend(['tanh', 'cos'], facecolor='gray', edgecolor='red')

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Grafiğin içerisine text isimli fonksiyonla bir yazı yerleştirebiliriz. Bu yazının konumu grafikteki eksen bilgilerine göre ve 
    yazının sol alt köşesi o konumda olacak biçimde belirlenmektedir. Anımsayacağınız gibi biz dah aönce title gibi, xlabels, ylabels
    gibi fonksiyonlarda aslında text fonksiyonundaki parametrelerin geçerli olduğunu beltmiştik. Aşağıdaki dokğmantasyonda text 
    fonksiyonunda kullanabileceğiniz tüm parametreler hakkında bilgiler bulunmaktadır:

    https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.text.html

    Tabii en çok kullanılan text parametreleri şunlardır:

    color
    fontsize
    fontfamily
    fontstyle
    fontweight
    rotation
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Kosinüs - Hiperbolik Tanjant Fonksiyonları', color='blue')

plt.xlabel('X', fontweight='bold', color='red', loc='center')
plt.ylabel('Y', fontweight='bold', color='red')

plt.ylim(-2, 2)
plt.xlim(-12, 12)

plt.xticks(range(-12, 13, 2), color='blue', fontsize=9)
plt.yticks(np.arange(-2, 2, 0.25), color='blue', fontsize=9)

plt.grid()
x = np.linspace(-10, 10, 1000)
y = (np.e ** x - np.e ** -x) / (np.e ** x + np.e ** -x) 
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)
plt.legend(['tanh', 'cos'], facecolor='gray', edgecolor='red')

plt.text(-8.5, 0.25, 'This is a test', fontsize=8, fontweight='bold', rotation=65)
plt.text(-7.6, -0.5, 'Inside Parabol', fontsize=5, fontweight='bold')

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Çizim alanının içerisine ok çizdirebiliriz. Bunun arrow fonksiyonu kullanılır. Bu fonksiyon okun başlangıç ve bitiş koordinatlarını 
    eksen değerleriyle almaktadır.  Örneğin:

    plt.arrow(2, 1.5, -1.7, -0.4, style='round', head_length=0.3, head_width=0.1, color='red', linestyle=':')

    Ok çizerken ilk iki parametre okun başlangıç koordinatlarını belirtmektedir. Diğer iki parametre ise bitiş koordinatlarının deltax
    değerlerini belirtir. (Yani bu koordinatlar ok işaretinin delte değerlerini belirtmektedir.) Buradaki delta değerleir başlangıçtan 
    itibaren x ekseninde ve y ekseninde ne kadar ilerleneceği anlamına gelmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Kosinüs - Hiperbolik Tanjant Fonksiyonları', color='blue')

plt.xlabel('X', fontweight='bold', color='red', loc='center')
plt.ylabel('Y', fontweight='bold', color='red')

plt.ylim(-2, 2)
plt.xlim(-12, 12)

plt.xticks(range(-12, 13, 2), color='blue', fontsize=9)
plt.yticks(np.arange(-2, 2, 0.25), color='blue', fontsize=9)

plt.grid()
x = np.linspace(-10, 10, 1000)
y = (np.e ** x - np.e ** -x) / (np.e ** x + np.e ** -x) 
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)
plt.legend(['tanh', 'cos'], facecolor='gray', edgecolor='red')

plt.text(-8.5, 0.25, 'This is a test', fontsize=8, fontweight='bold', rotation=65)
plt.text(-7.6, -0.5, 'Inside Parabol', fontsize=5, fontweight='bold')
plt.arrow(2, 1.5, -1.7, -0.4, style='round', head_length=0.3, head_width=0.1, color='red', linestyle=':')
plt.text(2, 1.5, 'Tepe noktası', fontsize=8)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Grafiği büyütmek ya da küçültmek için figürün büyütülmesi ya da küçültülmesi gerekir. Bunun için figure isimli fonksiyon ile yeni 
    bir figür yaratılıp o figürün aktif figür olması sağlanabilir. Yeni figür yaratılırken figure fonksiyonun figsize parametresi 
    inch cinsinden iki elemanlı bir demet biçiminde figürün genişlik ve yüksek değerlerini almaktadır. Örneğin:

    plt.figure(figsize=(6, 4))

    facecolor isimli parametresi ile figürün arka plan rengini de değiştirilebilir. Örneğin:

    plt.figure(figsize=(6, 4), facecolor='#FFFFDD')
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.figure(figsize=(6, 4), facecolor='#FFFFDD')
plt.title('Kosinüs - Hiperbolik Tanjant Fonksiyonları', color='blue')

plt.xlabel('X', fontweight='bold', color='red', loc='center')
plt.ylabel('Y', fontweight='bold', color='red')

plt.ylim(-2, 2)
plt.xlim(-12, 12)

plt.xticks(range(-12, 13, 2), color='blue', fontsize=9)
plt.yticks(np.arange(-2, 2, 0.25), color='blue', fontsize=9)

plt.grid()
x = np.linspace(-10, 10, 1000)
y = (np.e ** x - np.e ** -x) / (np.e ** x + np.e ** -x) 
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)
plt.legend(['tanh', 'cos'], facecolor='gray', edgecolor='red')

plt.text(-8.5, 0.25, 'This is a test', fontsize=8, fontweight='bold', rotation=65)
plt.text(-7.6, -0.5, 'Inside Parabol', fontsize=5, fontweight='bold')
plt.arrow(2, 1.5, -1.7, -0.4, style='round', head_length=0.3, head_width=0.1, color='red', linestyle=':')
plt.text(2, 1.5, 'Tepe noktası', fontsize=8)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında bir figürde tek bir eksen bulunmak zorunda değildir. Birden fazla eksen bulundurulabilir. Böylece farklı grafikler yan 
    yana görüntülenebilir. Bu işlem çeşitli biçimlerde yapılabilmektedir. En basit biçim subplot fonksiyonunu kullanmaktır. Bir figürde 
    birden fazla eksen varsa bunların bir tanesi aktif eksendir. Dolayısıyla çizimler aktif eksene yapılırlar. subplot fonksiyonu yeni 
    bir eksen yaratıp onu aktif hale getirmektedir. sublot fonksiyonunundaki ilk iki parametre eksenlerin oluşturacağı matrisin boyutlarını,  
    üçüncü parametre ise bu matristeki hangi eksenin aktif hale getirileceğini belirtmektedir. Burada eksenlerin numaraları 1'den 
    başlatılır ve eksenler satır tabanlı olarak (row-wise) numaralandırılmaktadır. Bir eksen aktif hale getirildiğinde artık yukarıda 
    gördüğümüz çizim ile ilgili fonksiyonların hepsi o eksen üzerinde yapılır. Örneğin plt.title fonksiyonu eksen için bir başlık 
    oluşturmaktadır. Dolayısıyla biz istersek her eksene ayrı bir başlık atayabiliriz. Örneğin:

    plt.subplot(2, 2, 1)

    Burada 2x2'lik bir eksen matrisi oluşturulmuştur. Biz buy matrisin sol üst elemanını aktif hale getirmiş olmaktayz. Buradaki 
    numaralandırma satırsaldır. Örneğin:

    plt.subplot(2, 2, 2)

    Şimdi biz matrisin sağ üst elemanını aktif hale getirmiş olmaktayız. Bunu şekilsle olarak şöyle de gösterbeiliriz:

    plt.subplot(2, 2, 1)            plt.subplot(2, 2, 2)
    plt.subplot(2, 2, 3)            plt.subplot(2, 2, 4)

    Bu tür çizimler yaparken subplot fonksiyonunun ilk parametresini baştan belirlemlisiniz. Bu iki parametreyi aynı tutup üçüncü 
    parametreyi değiştierek çizimleri yapabilirsiniz. Örneğin:

    plt.subplot(2, 2, 1)
    plt.title('Sinüs')
    x = np.linspace(-6.5, 6.5, 1000)
    y = np.sin(x)
    plt.plot(x, y)

    plt.subplot(2, 2, 2)
    plt.title('Cosinüs')
    x = np.linspace(-6.5, 6.5, 1000)
    y = np.cos(x)
    plt.plot(x, y)

    plt.subplot(2, 2, 3)
    plt.title('Parabol')
    x = x = np.linspace(-10, 10, 1000)
    y = x ** 2 - 2 * x + 1
    plt.plot(x, y)

    plt.subplot(2, 2, 4)
    plt.title('Logaritma')
    x = x = np.linspace(-10, 10, 1000)
    y = np.log(x)
    plt.plot(x, y)

#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.figure(figsize=(8, 8))

plt.subplot(2, 2, 1)
plt.title('Sinüs')
x = np.linspace(-6.5, 6.5, 1000)
y = np.sin(x)
plt.plot(x, y)

plt.subplot(2, 2, 2)
plt.title('Cosinüs')
x = np.linspace(-6.5, 6.5, 1000)
y = np.cos(x)
plt.plot(x, y)

plt.subplot(2, 2, 3)
plt.title('Parabol')
x = x = np.linspace(-10, 10, 1000)
y = x ** 2 - 2 * x + 1
plt.plot(x, y)

plt.subplot(2, 2, 4)
plt.title('Logaritma')
x = x = np.linspace(-10, 10, 1000)
y = np.log(x)
plt.plot(x, y)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii biz eksenleri bir döngü içerisinde aktif hale getirip çizimleri yapabiliriz. Örneğin:

    for i in range(1, 10):
        plt.subplot(3, 3, i)
        plt.title(f'X^{i}', fontsize=9, color='red')
        x = np.linspace(-100, 10)
        y = -x ** i
        plt.yticks(fontsize=6)
        plt.xticks(fontsize=6)
        plt.plot(x, y)
    plt.show()
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.figure(figsize=(9, 9))

for i in range(1, 10):
    plt.subplot(3, 3, i)
    plt.title(f'X^{i}', fontsize=9, color='red')
    x = np.linspace(-100, 10)
    y = -x ** i
    plt.yticks(fontsize=6)
    plt.xticks(fontsize=6)
    plt.plot(x, y)
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında subplot fonksiyonun üç parametresi tek parametreli bir int sayı biçiminde de oluşturulabilmektedir. Örneğin:

    plt.subplot(331)        # eşdeğeri plt.subplot(3, 3, 1)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.figure(figsize=(8, 8))

plt.subplot(221)
plt.title('Sinüs')
x = np.linspace(-6.5, 6.5, 1000)
y = np.sin(x)
plt.plot(x, y)

plt.subplot(222)
plt.title('Cosinüs')
x = np.linspace(-6.5, 6.5, 1000)
y = np.cos(x)
plt.plot(x, y)

plt.subplot(223)
plt.title('Parabol')
x = x = np.linspace(-10, 10, 1000)
y = x ** 2 - 2 * x + 1
plt.plot(x, y)

plt.subplot(224)
plt.title('Logaritma')
x = x = np.linspace(-10, 10, 1000)
y = np.log(x)
plt.plot(x, y)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Çizgi grafiği (plot) için kullanılan plot fonksiyonun pek çok parametresi vardır. Çizginin rengi color parametresiyle ayarlanabilir. 
    Eğer renk belirtilmezse plot her çizim için bir paletten farklı bir rengi otomatik biçimde seçmektedir. linewidth parametresi ile
    çizgi kalınlığı değiştirilebilmektedir. marker parametresi noktaların nasıl görüntüleneceğini belirtmektedir. Burada 'o' parametresi 
    küçük bir dairesel simge ile noktaların gösterileceği anlamına gelmektedir. Diğer önemli marker sembolleri şunlardır: 'v', 's', '*', 
    'x'. linestyle parametresi çizginin kesikliliği üzerinde belirleme yapılmasını sağlar. Burada önemli değerler şunlardır: '-', '--', 
    ':', '-.', none. marker'ların büyüklükleri pixel cinsinden markersize parametresiyle ayarlanabilmektedir. Marker'ların zemin 
    renkleri markerfacecolor parametresi çizgi renkleri markeredgecolor parametresiyle ayarlanabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Sinüs')
x = np.linspace(-6.5, 6.5, 10)
y = np.sin(x)
plt.plot(x, y, linewidth=5, marker='o', markerfacecolor='red', markeredgecolor='yellow', markersize=10)
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Çeşitli olguların çubuklarla temsil edildiği grafiklere "çubuk grafikleri (bar charts)" denilmektedir. Tabii çubuk grafikleri 
    aslında matematiksel grafikler değildir. Çubuk grafikleri daha çok betimsel istatistikte kullanılmaktadır. Çubuk grafiklerinde 
    çubukların yüksekliği önemlidir. Çubukların genişliklerinin ve alanlarının genel olarak bir önemi yoktur. Çubukların yükseklikleri 
    olgular arasındaki niceliksel farklılıkları gözle karşılaştırmalı bir biçimde anlamamıza yardımcı olmaktadır. Çubukların genişliklerinin 
    bir önemi yoksa da görüntünün daha güzel gözükmesinde genişlikler katkı sağlayabilmektedir. Çubuk grafikleri bar isimli fonksiyonla 
    oluşturulmaktadır. 

    bar fonksiyonun ilk iki parametresi zorunlu parametrelerdir. Birinci parametre çubukların x eksenindeki orta noktalarını belirten 
    sayılara ilişikin ya da çubukları betimleyen yazılara ilişkin bir liste biçiminde girilebilir. Eğer bu liste string listesi 
    biçimindeyse çubukların orta noktaları 0'dan başlatılır ve birer artırımlı olarak devam ettirilmektedir. Örneğin:

    plt.title('Çubuk Grafiği')
    plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9])
    plt.show()

    Burada x değerleri kişilerin isimlerindne oluşmaktadır. Çubuk grafiklerinde tiğik olarak x değerleri sayıdan ziyade yazı 
    biçiminde girilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.title('Çubuk Grafiği')
plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9])
plt.show()


#------------------------------------------------------------------------------------------------------------------------------------
    Çubukların genişlikleri default olarak 0.8'dir. Ancak biz genişlikleribar fonksiyonunun width parametresiyle değiştirebiliriz. 
    Tabii genişlikleri küçülttükçe çubuk aralarındaki boşluklar artar, genişlikleri büyüttükçe bu boşluklar azalır. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.figure(figsize=(5, 4))
plt.title('Çubuk Grafiği')
plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9], width=0.9)
plt.yticks(range(0, 11))
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    bar fonksiyonun color parametresine bir renk girilirse tüm çubuklar o renkte görüntülenir. Bu parametreye bir renk dizisi de 
    girilebilir. Böylelikle biz her çubuğun rengini ayrı ayrı ayarlayabiliriz. Örneğin:

    plt.figure(figsize=(5, 4))
    plt.title('Çubuk Grafiği')
    plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9], width=0.9, 
            color=['yellow', 'blue', 'brown', 'black', 'magenta', 'red'])
    plt.yticks(range(0, 11))
    plt.show()
#------------------------------------------------------------------------------------------------------------------------------------

iplt.figure(figsize=(5, 4))
plt.title('Çubuk Grafiği')
plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9], width=0.9, 
        color=['yellow', 'blue', 'brown', 'black', 'magenta', 'red'])
plt.yticks(range(0, 11))
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    bar fonksiyonun edgecolor parametresi çubukların çizgi renklerini, linewidth parametresi çubukların çizgi kalınlıklarını ayarlamakta 
    kullanılmaktadır. fill parametresi False geçilirse çubukların içleri hiç boyanmamaktadır. hatch çubukların içlerindeki dolgu biçimlerini
    belirlemekte kullanılmaktadır. Bazı dolgu biçimleri şunlardır: '\\' '/', '|', '+', 'o', 'O', .', '*'. Örneğin:

    plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9], width=0.7, 
            color=['yellow', 'blue', 'brown', 'black', 'magenta', 'red'], edgecolor='black', linewidth=4, hatch='/')
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.figure(figsize=(5, 4))
plt.title('Çubuk Grafiği')
plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9], 
    width=0.7, color=['yellow', 'blue', 'brown', 'green', 'magenta', 'red'], edgecolor='black', linewidth=4, hatch='/')
plt.yticks(range(0, 11))
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    bar fonksiyonunun bottom parametresi çubukların tabalarının y eksenine göre konumunu belirlemekte kullanılır. 0 değeri tabanların 
    x eksenine oturduğu anlamına gelmektedir ve default durumdur. Buradaki değer y eksenindeki skalaya göre belirlenmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.figure(figsize=(5, 4))
plt.title('Çubuk Grafiği')
plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9], 
        width=0.7, color=['yellow', 'blue', 'brown', 'green', 'magenta', 'red'], edgecolor='black', linewidth=4, hatch='/', bottom=1)
plt.yticks(range(0, 11))
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    bottom değeri vererek çizgilerin üst üste gözükmesi sağlanabilmektedir. Bunun bottom değeri tek bir değer olarak değil her 
    çubuk bir liste biçiminde girilmelidir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.figure(figsize=(5, 4))
x = ['A', 'B', 'C']
y1 = [3, 5, 2]
y2 = [2, 3, 4]

plt.bar(x, y1, label='Seri 1')
plt.bar(x, y2, bottom=y1, label='Seri 2')  # y1’in üstüne yerleştir
plt.legend()
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    bar fonksiyonunun align parametresi 'center' ya da 'edge' biçiminde olabilmektedir. Default durum 'center' biçimindedir. Bu parametre
    x değerlerinin çubukların ortasında mı yoksa solunda mı görüntüleneceğni belirtmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.figure(figsize=(5, 4))
plt.title('Çubuk Grafiği')
plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9], 
        width=0.7, color=['yellow', 'blue', 'brown', 'green', 'magenta', 'red'], edgecolor='black', linewidth=4, hatch='/', align='edge')
plt.yticks(range(0, 11))
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Çubukları sola ve sağa yaslamak için yine xlim fonksiyonu ile x eksenindeki limitleri belirlemek gerekebilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.figure(figsize=(5, 4))
plt.title('Çubuk Grafiği')
plt.xlim(0, 6)
plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9], width=0.7, 
        color=['yellow', 'blue', 'brown', 'green', 'magenta', 'red'], edgecolor='black', linewidth=4, hatch='/', align='edge')
plt.yticks(range(0, 11))
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    bar fonksiyonuyla ilgili başka ayrıntı özellikler vardır. Bunlar için Matplotlib dokümanlarına başvurabilirsiniz.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Diğer çok kullanılan grafik türünden biri de "saçılma (scatter)" grafiğidir. Bu grafikte yalnızca noktalar gösterilir. Noktaların 
    dışında başka bir öğe grafikte bulunmaz. Tabii noktalar bir pixel ile değil küçük dairelerle gösterilemektedir. Bu dairelerin 
    büyüklüğü ayarlanabilmektedir. Saçılma grafiği istatistik ve veri biliminde çok sık kullanılmaktadır. Saçılma grafiği bir dağılma 
    ilişkin noktaların gözle kontrol edilebilmesi sıkça kullanılmaktadır. Saçılma grafikleri scatter isimli fonksiyonla çizilmektedir.

    scatter fonksiyonun ilk iki parametresi zorunlu parametrelerdir. Bunlar noktaların x ve y bileşenlerini belirtir. Örneğin:

    x = [4, 34, 21, 17, 8, 42, 19, 62, 23, 30, 55, 20, 15, 20, 55, 10, 32, 13, 50, 40]
    y = [12, 34, 2, 43, 23, 11, 41, 32, 42, 21, 25, 15, 20, 30, 8, 4, 12, 12, 40, 20] 

    plt.title('Saçılma Grafiği')
    plt.scatter(x, y)
    plt.show()

#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

x = [4, 34, 21, 17, 8, 42, 19, 62, 23, 30, 55, 20, 15, 20, 55, 10, 32, 13, 50, 40]
y = [12, 34, 2, 43, 23, 11, 41, 32, 42, 21, 25, 15, 20, 30, 8, 4, 12, 12, 40, 20] 

plt.title('Saçılma Grafiği')
plt.scatter(x, y)
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Saçılma grafiğindeki noktaların renkleri yine color isimli parametresiyle değiştirilebilir. Örneğin:

    plt.scatter(x, y, color='manenta')
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

x = [4, 34, 21, 17, 8, 42, 19, 62, 23, 30, 55, 20, 15, 20, 55, 10, 32, 13, 50, 40]
y = [12, 34, 2, 43, 23, 11, 41, 32, 42, 21, 25, 15, 20, 30, 8, 4, 12, 12, 40, 20] 

plt.title('Saçılma Grafiği')
plt.scatter(x, y, color='magenta')
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında her noktanın rengini istediğimiz gibi de ayarlayabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Scatter Graphics')

x = np.array([1, 5, 7, 3, 9, 12, 5, 25, 7, 19])
y = np.array([10, 21, 17, 7, 24, 21, 9, 14, 11, 1])
plt.scatter(x, y, color=['red', 'green', 'blue', 'blue', 'red', 'green', 'black', 'blue', 'green', 'black'])

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Aynı eksenin üzerine show işlemi yapmadan birden fazla saçılma grafiği çizdirilebilir. Bu durumda plot fonksiyonunda olduğu gibi 
    renkler özellikle belirtilmemişse her scatter için otomatik atanmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

x1 = np.array([1, 5, 7, 3, 9])
y1 = np.array([10, 21, 17, 7, 24])
x2 = np.array([12, 5, 25, 7, 19])
y2 = np.array([21, 9, 14, 11, 1])

plt.title('Scatter Graphics')
plt.scatter(x1, y1)
plt.scatter(x2, y2)
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Bazen farklı kategorik değerlerin farklı renklerle saçılma grafiğinin çizilmesi gerekebilmektedir. Örneğin aşağıdaki gibi 
    bir 'scatter.csv' dosyası olsun:

    kilo,boy,cinsiyet
    72,155,erkek
    87.3,172,erkek
    56.5,167,kadın
    47.3,171,kadın
    67.4,178,kadın
    56.7,174,erkek
    72.3,169,erkek
    78.5,181,kadın
    57.4,164,kadın
    91.6,185,erkek

    Burada yatay eksende "kilo", düşey eksende "boy" özellikleri temsil edilsin. Biz de erkeklerle kadınların noktalarını farklı renklerle
    göstermek isteyelim. Burada bizim cinsiyete göre filtrelemeler yapmamız gerekmektedir:

    df = pd.read_csv('scatter.csv')

    plt.title('Scatter Graphics')
    plt.scatter(df['kilo'][df['cinsiyet'] == 'erkek'],df['boy'][df['cinsiyet'] == 'erkek'])
    plt.scatter(df['kilo'][df['cinsiyet'] == 'kadın'],df['boy'][df['cinsiyet'] == 'kadın'])
    plt.legend(['Erkek', 'Kadın'])

#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd
import matplotlib.pyplot as plt


df = pd.read_csv('scatter.csv')

plt.title('Scatter Graphics')
plt.scatter(df['kilo'][df['cinsiyet'] == 'erkek'],df['boy'][df['cinsiyet'] == 'erkek'])
plt.scatter(df['kilo'][df['cinsiyet'] == 'kadın'],df['boy'][df['cinsiyet'] == 'kadın'])
plt.legend(['Erkek', 'Kadın'])
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    scatter fonksiyonun s isimli parametresi noktalar için çizilen dairenin büyüklüğünü ayarlamak için kullanılmaktadır. Bu değer 
    büyütülürse daireler de büyüyecektir. Yine aslında noktalar için daire yerine marker parametresiyle başka sembollerin de 
    kullanılması sağlanabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('scatter.csv')

plt.title('Scatter Graphics')
plt.scatter(df['kilo'][df['cinsiyet'] == 'erkek'],df['boy'][df['cinsiyet'] == 'erkek'], s=10, marker='v')
plt.scatter(df['kilo'][df['cinsiyet'] == 'kadın'],df['boy'][df['cinsiyet'] == 'kadın'], s = 10, marker='o')
plt.legend(['Erkek', 'Kadın'])

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Grafikteki marker'ın iç rengi facecolor parametresiyle çizgi rengi edgecolor parametresiyle ve çizgi kalınlığı linewidth 
    parametresiyle belirlenebilnektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('scatter.csv')

plt.title('Scatter Graphics')
plt.scatter(df['kilo'][df['cinsiyet'] == 'erkek'],df['boy'][df['cinsiyet'] == 'erkek'], s=10, marker='v')
plt.scatter(df['kilo'][df['cinsiyet'] == 'kadın'],df['boy'][df['cinsiyet'] == 'kadın'], s = 10, marker='o')
plt.legend(['Erkek', 'Kadın'])

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Bazen scatter grafiğinde bazı noktalar da bireysel biçimde belirtilmek istenebilir. Tek bir noktayı çizmek için scatter yerine 
    plot fonksiyonunu da kullanabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Scatter Graphics')

x = np.array([1, 5, 7, 3, 9, 12, 5, 25, 7, 19])
y = np.array([10, 21, 17, 7, 24, 21, 9, 14, 11, 1])
plt.scatter(x, y, s=150, color='blue', linewidth=3, facecolor='yellow')
plt.plot(10, 10, marker='x', markersize=14, color='red')
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    scikit-learn isimli makine öğrenmesi kütüphanesinde sklearn.datasets modülü bazı amaçlar için kullanılan çeşitli rastgele nokta 
    üretme fonksiyonları bulunmaktadır. Örneğin make_blobs isimli fonksiyon bize birbirinden kopuk k tane kümeden oluşan rastgele 
    noktalar vermektedir. Bu fonksiyon bir demete geri döner. Demetin ilk elemanı tüm noktaları barındıran bir NumPy dizisidir. 
    Demetin ikinci elemanı ise bu noktaların hangi sınıfa ait olduğunu belirten 0, 1, 2, ... biçiminde sınıf belirten sayılardna 
    oluşmaktadır. Örneğin:

    >>> from sklearn.datasets import make_blobs
    >>> dataset, labels = make_blobs(50, 2, centers=5)
    >>> dataset
    array([[-8.38325205,  3.60580764],
        [ 4.51867341,  7.4311921 ],
        [ 4.04116666, -3.35058303],
        [ 1.25720406,  6.82407607],
        [-8.25852123,  4.36493465],
        [-7.65490343,  4.29157456],
        [ 8.07471198,  5.79537231],
        [ 8.17025353,  6.93829721],
        [-5.03625673,  5.14028253],
        [-7.10139767,  5.1758152 ],
        [ 0.22094753,  6.75557295],
        [ 0.3818745 ,  6.33642333],
        [ 8.98190368,  7.69854562],
        [-6.79701411,  3.29686245],
        [ 4.9771809 ,  8.35464889],
        [-0.30454456,  2.73473828],
        [ 5.55765397,  9.95039466],
        [ 5.04037074, -4.2944478 ],
        [ 3.25879292,  7.15198822],
        [ 8.42091931,  5.92384327],
        [ 2.1723554 ,  7.36045773],
        [ 4.99566081, -3.56003277],
        [-0.26602114,  6.21918411],
        [ 4.63261427, -5.55274097],
        [-6.66265881,  2.58638149],
        [ 3.07062992, -2.94879771],
        [ 6.49231757,  6.60228816],
        [ 2.17643182,  5.62330393],
        [ 3.03590421, -2.48234133],
        [-7.33916759,  5.41487708],
        [ 6.77615268,  5.18684805],
        [ 4.36859224,  8.46921282],
        [ 4.94523652, -3.9158847 ],
        [ 2.89696602, -2.23439456],
        [ 3.23882866,  7.63115974],
        [ 4.95940036, -3.70769496],
        [ 6.48099217,  8.04609029],
        [ 2.40780885,  7.36819578],
        [ 6.63498939,  7.56139856],
        [ 1.17986973,  6.46382486],
        [ 5.57257106, -0.37931753],
        [-6.77561324,  5.36882706],
        [ 2.00467577,  6.59830384],
        [ 7.71979717,  6.97505674],
        [ 7.48557809,  5.54013869],
        [ 2.94926231,  8.79654149],
        [ 7.17755093,  6.09389411],
        [-6.88144637,  4.83986513],
        [ 7.37322699,  7.96918345],
        [ 8.47948876,  5.10220244]])
    >>> labels
    array([0, 2, 1, 4, 0, 0, 3, 3, 0, 0, 4, 4, 3, 0, 2, 4, 2, 1, 4, 3, 2, 1,
        4, 1, 0, 1, 2, 4, 1, 0, 3, 2, 1, 1, 2, 1, 3, 4, 2, 4, 1, 0, 4, 3,
        3, 2, 3, 0, 2, 3])

    Burada toplam 50 tane noktadan oluşan iki sütunlu rastgele bir veri kümesi oluşturulmuştur. Veri kümesindeki her nokta rastgele
    0, 1, 2, 3, 4 sınıflarından birine atanmıştır. Biz de örneğin her sınıf için ayrı bir renkle saçılma grafiğini şöyle çizdirebiliriz:

    plt.title('Scatter Graphics')
    for i in labels:
        plt.scatter(dataset[labels == i, 0], dataset[labels == i, 1])
    plt.show()
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt
from sklearn.datasets import make_blobs

dataset, labels = make_blobs(50, 2, centers=5)

plt.title('Scatter Graphics')

for i in labels:
    plt.scatter(dataset[labels == i, 0], dataset[labels == i, 1])

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    sklearn.datasets modülü içerisindeki rastgele kümesel veri üreten diğer bir fonksiyon da make_circles isimli fonksiyondur. Bu 
    fonksiyon belli sayıda rastgele değerlerden oluşan iki kümeye ayrılmış rastgele dairesel noktalar üretmektedir. Fonksiyon yine
    ikili bir demete geri dönmektedir. Demetin ilk elemanı veri kğmesini, ikinci elemanı veri kümesindeki noktaların 0 ya da 1 
    biçiminde sınıflarını belirtmektedir. Fonksiyonun factor parametresi kümeler arasındaki dairesel noktaları birbirinden uzaklaştırıp
    yakınlaştırmak için, noise parametresi ise bu daireselliği belli oranlarda bozmak için kullanılmaktadır. Örneğin:

    >>> from sklearn.datasets import make_circles
    >>> dataset, labels = make_circles(50)
    >>> dataset
    array([[-0.74382119,  0.29449964],
        [ 0.5831749 ,  0.54763768],
        [-0.6472136 ,  0.4702282 ],
        [ 0.2472136 , -0.76084521],
        [ 0.87630668,  0.48175367],
        [-0.18738131, -0.98228725],
        [-0.92977649,  0.36812455],
        [ 1.        ,  0.        ],
        [-0.74382119, -0.29449964],
        [-0.9921147 ,  0.12533323],
        [ 0.96858316, -0.24868989],
        [ 0.05023242,  0.79842138],
        [ 0.53582679, -0.84432793],
        [ 0.70104534,  0.38540294],
        [-0.42577929,  0.90482705],
        [-0.34062343,  0.72386164],
        [ 0.96858316,  0.24868989],
        [ 0.77486653,  0.19895191],
        [ 0.72896863,  0.68454711],
        [-0.79369176, -0.10026659],
        [ 0.05023242, -0.79842138],
        [-0.80901699, -0.58778525],
        [ 0.87630668, -0.48175367],
        [-0.34062343, -0.72386164],
        [-0.79369176,  0.10026659],
        [ 0.06279052, -0.99802673],
        [ 0.42866144, -0.67546234],
        [-0.42577929, -0.90482705],
        [ 0.30901699,  0.95105652],
        [ 0.5831749 , -0.54763768],
        [-0.63742399,  0.77051324],
        [ 0.2472136 ,  0.76084521],
        [-0.14990505, -0.7858298 ],
        [ 0.70104534, -0.38540294],
        [-0.92977649, -0.36812455],
        [ 0.30901699, -0.95105652],
        [-0.80901699,  0.58778525],
        [ 0.53582679,  0.84432793],
        [ 0.8       ,  0.        ],
        [ 0.72896863, -0.68454711],
        [-0.14990505,  0.7858298 ],
        [-0.50993919,  0.61641059],
        [-0.18738131,  0.98228725],
        [ 0.42866144,  0.67546234],
        [-0.6472136 , -0.4702282 ],
        [-0.63742399, -0.77051324],
        [ 0.06279052,  0.99802673],
        [-0.9921147 , -0.12533323],
        [ 0.77486653, -0.19895191],
        [-0.50993919, -0.61641059]])
    >>> labels
    array([1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0,
        0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1,
        1, 0, 0, 0, 1, 1], dtype=int64)

    Biz bu rastgele kümesel noktaları saçılma grafiği ile farklı renklerde gösterebiliriz:

    dataset, labels = make_circles(50, factor=0.5, noise=0.04)

    plt.title('Scatter Graphics')
    plt.scatter(dataset[labels == 0, 0], dataset[labels == 0, 1])
    plt.scatter(dataset[labels == 1, 0], dataset[labels == 1, 1])
    plt.show()
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt
from sklearn.datasets import make_circles

dataset, labels = make_circles(50, factor=0.5, noise=0.04)

plt.title('Scatter Graphics')
plt.scatter(dataset[labels == 0, 0], dataset[labels == 0, 1])
plt.scatter(dataset[labels == 1, 0], dataset[labels == 1, 1])
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    scatter fonksiyonunun başka ayrıntı parametreleri de vardır. Bunun için Matplotlib dokümanlarına başvurabiliriniz.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Pasta dilimi grafiği çeşitli olguların bütün içerisindeki oranlarını görsel bir biçimde ifade etmek için kullanılmaktadır. Pasta 
    dilimi grafiği (pie chart) Matplotlib kütüphanesinde pie isimli fonksiyonla çizdirilmektedir. pie fonksiyonun zorunlu birinci 
    parametresi pasta dilimi olarak gösterilecek değerleri belirtmektedir. Fonksiyon kendisi bu değerlerden hareketle orantı kullanarak 
    pasta dilimlerinin büyüklerini belirlemektedir. Programcı isterse fonksiyonun labels parametresi yoluyla her bir pasta diliminin 
    anlamı için br yazının gösterilmesini sağlayabilir. Örneğin:

    plt.title('Pie Charts')
    plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'])
    plt.show()

#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.title('Pie Charts')
plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'])
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Default durumda pasta dilimlerinin renkleri fonksiyonun kendisi tarafından belirlenmektedir. Ancak fonksiyonun colors parametresiyle 
    her pasta diliminin rengini biz ayrı ayrı belirleyebiliriz. Örneğin:

    plt.title('Pie Charts')
    plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'])
    plt.show()
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.title('Pie Charts')
plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'])
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Belli bir pasta diliminin ana pastadan kopuk biçimde gösterilmesi sık karşılaşılan bir durumdur. Bunun için fonksiyonun explode 
    parametresi kullanılmaktadır. Bu parametreye pasta dilimi sayısı kadar değer içeren dolaşılabilir bir nesne girilir. İlgili pasta 
    diliminin explode değeri 0 ise bu pasta dilimi kopu değildir. explode değeri yükseldikte pastanın yarıçapı ile oranlı bir biçimde
    pasta dilimi kopuk gösterilmektedir. Genellikle kopukluk için 0.1 gibi 0.2 gibi değerler dilimi güzel gösteren değerlerdir. 
    Örneğin:

    plt.title('Pie Charts')
    plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], 
            colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'], explode=[0, 0, 0, 0.1, 0, 0]) 
    plt.show()
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.title('Pie Charts')
plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'], explode=[0, 0, 0, 0.1, 0, 0]) 
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    pie fonksiyonun autopct parametresi C'nin printf fonksiyonundaki gibi yer tutucu yazısını alır. Yer tutucular % karakteri ile 
    başlatılırlar. (Gerçekten % karakteri %% ile belirtilir). Örneğin %.2f gibi bir yazı pasta dilimlerinin yüzdesini noktadan sonra 
    iki basamak olarak göstermek için kullanılmaktadır. Örneğin:

    plt.title('Pie Charts')
    plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], 
            colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'], explode=[0, 0, 0, 0.1, 0, 0], autopct='%%%.2f') 
    plt.show()

    Burada noktadan sonra iki basamak olarak değerler pasta dilimlerinin yüzdelik biçimde görüntülenecektir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.title('Pie Charts')
plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], 
        colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'], explode=[0, 0, 0, 0.1, 0, 0], autopct='%%%.2f') 
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Default durumda pasta dilimleri ilk belirtilen dilim 0 derecede olacak biçimde saat yönünün ters yönünde konumlandırılır. Ancak 
    ilk dilimin başlangıç açısı startangle parametresi ile değiştirilebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.title('Pie Charts')
plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], 
        colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'], autopct='%%%.2f', startangle=90) 
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Pasta dilimlerindeki yazıların birtakım özellikleri textprops isimli parametreyle değiştirilebilmektedir. Bu parametre bir sözlük
    biçiminde girilir. Sözlüğün anahtarları text fonksiyonundaki yazı özelliklerini belirten parametre isimlerinin yazılarından, 
    değerleri ise onların değerlerinden oluşmaktadır. Örneğin:

    plt.title('Pie Charts')
    plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], 
            colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'], autopct='%%%.2f', 
            startangle=90, textprops={'fontsize': 8, 'fontweight': 'bold'}) 
    plt.show()
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.title('Pie Charts')
plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], 
        colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'], 
        autopct='%%%.2f', startangle=90, textprops={'fontsize': 8, 'fontweight': 'bold'}) 
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
                                            55.Ders 04/10/2025 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    shadow parametresi dilimleri hafif gölgeli göstermektedir. Özellikle explode edilmiş dilimlerde gölgeli gösterim önemli olabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.title('Pie Charts')
plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], 
        colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'], autopct='%%%.2f', 
        startangle=90, textprops={'fontsize': 8, 'fontweight': 'bold'}, shadow=True) 
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    En çok kullanılan grafiklerden biri de "histogram" denilen grafiktir. İstatistikte, veri biliminde ve makine öğrenmesinde histogram 
    oldukça sık kullanılmaktadır. Histogram bir sıklık grafiğidir. Genellikle kişiler tarafından "çubuk grafiği (bar chart)" ile 
    karıştırılmaktadır. Çubuk grafiğinde çubuklar bir aralık belirtmezler. Bir olgu belirtirler. Ancak histogramda çubuklar bir aralıktaki 
    değerlerin kaç tane olduğunu yani o aralıktaki değerlerin sıklığını göstermek için kullanılmaktadır. Histogramda çubukların yükseklikleri 
    sıklık değerini, genişlikleri de aralığı belirtmektedir. Genellikle çubuklar aralarında boşluk olmadan yan yana gösterilirler. 
    Histogramın çubuk sayısı ayarlanabilmektedir. Örneğin 0 ile 100 arasında 1000 tane değer olsun. Biz bu 1000 değerin histogramını 
    çizerken çubuk sayısını 10'da tutarsak aralıklar da 10 genişlikte olur Ancak çubuk sayısını 20 yaparsak aralık genişlikleri 5 olur. 
    Histogramdaki çubuklara İngilizce "bin" de denilmektedir. 

    Histogram çizmek için hist isimli fonksiyon kullanılmaktadır. Fonksiyonun tek bir zorunlu parametresi vardır. O da x değerlerini 
    almaktadır. Fonksiyonda default çubuk sayısı 10'dur. Ancak biz bins parametresiyle bu çubuk sayısını değiştirebiliriz. Fonksiyon 
    bizim x parametresi olarak girdiğimiz değerlerdeki en büyük ve en küçük değeri tespit eder. O iki değer arasını çubuk sayısına 
    bölerek aralıkları oluşturur. Sonra o aralıklarda kaç değer varsa çubukların yüksekliğini ona göre ayarlar. Örneğin:

    x = [47.3, 59.1, 34.8, 52.6, 63.9, 44.7, 49.8, 70.4, 39.2, 54.0,
        61.7, 56.8, 42.5, 66.9, 50.4, 33.7, 46.1, 77.2, 58.6, 48.3,
        41.9, 65.1, 53.2, 60.8, 72.5, 46.8, 43.4, 50.9, 55.6, 68.0,
        57.9, 47.1, 64.3, 35.6, 52.0, 48.8, 40.2, 73.1, 44.3, 66.0,
        59.7, 54.8, 62.5, 30.9, 71.4, 45.6, 58.1, 49.2, 67.7, 36.4,
        51.3, 63.4, 42.1, 69.8, 56.2, 38.5, 53.9, 75.6, 41.2, 47.9,
        60.1, 64.7, 50.7, 43.8, 70.9, 55.3, 46.5, 39.8, 68.6, 61.0,
        32.7, 49.5, 72.0, 44.9, 58.9, 51.6, 66.5, 37.8, 47.5, 63.0,
        53.5, 48.0, 56.9, 41.7, 71.2, 45.1, 59.4, 50.1, 62.9, 43.2,
        57.6, 34.3, 54.6, 40.8, 69.3, 64.1, 49.0, 60.4, 67.1, 52.9]

    plt.title('Histogram')
    plt.hist(x)
    plt.show()

#------------------------------------------------------------------------------------------------------------------------------------

x = [47.3, 59.1, 34.8, 52.6, 63.9, 44.7, 49.8, 70.4, 39.2, 54.0,
    61.7, 56.8, 42.5, 66.9, 50.4, 33.7, 46.1, 77.2, 58.6, 48.3,
    41.9, 65.1, 53.2, 60.8, 72.5, 46.8, 43.4, 50.9, 55.6, 68.0,
    57.9, 47.1, 64.3, 35.6, 52.0, 48.8, 40.2, 73.1, 44.3, 66.0,
    59.7, 54.8, 62.5, 30.9, 71.4, 45.6, 58.1, 49.2, 67.7, 36.4,
    51.3, 63.4, 42.1, 69.8, 56.2, 38.5, 53.9, 75.6, 41.2, 47.9,
    60.1, 64.7, 50.7, 43.8, 70.9, 55.3, 46.5, 39.8, 68.6, 61.0,
    32.7, 49.5, 72.0, 44.9, 58.9, 51.6, 66.5, 37.8, 47.5, 63.0,
    53.5, 48.0, 56.9, 41.7, 71.2, 45.1, 59.4, 50.1, 62.9, 43.2,
    57.6, 34.3, 54.6, 40.8, 69.3, 64.1, 49.0, 60.4, 67.1, 52.9]

plt.title('Histogram')
plt.hist(x)
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Örneğin biz numpy.random.normal fonksiyonuyla oratalasmı ve standart sapması verilen normal dağılıma uygun n tane rastgele sayı 
    üretebiliriz. Sonra bunların histogramını çizdiğimizde çan eğrisine benzer bir görüntüyle karşılaşırız. Gerçekten de doğada gördüğümüz 
    pek olgu aslında sıklık bakımından "normal dağılım" denilen çan eğrisine benzemektedir. Çan eğrisi ortalama etrafında çok fazla 
    değerin toplandığı ortalamadan iki yönlü uzaklaşıldığında değerlerin azaldığı bir görünümdedir. Örneğin boy, zeka, kilo gibi pek 
    çok özellik normal dağılma eğilimindedir. Yani kişilerin bu özellikleri ortalama etrafında çan eğrisinde olduğu gibi yayılmış 
    durumdadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

x = np.random.normal(0, 1, 10000)

plt.title('Histogram', fontsize=14, fontweight='bold')
plt.hist(x, bins=20)
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    hist fonksiyonun range parametresi anormal değerlerin (outliers) atılması için kullanılmaktadır. Bu parametre ikili bir demet 
    olarak girilir. Fonksiyon bu ikili demetin içinde kalan değerleri dikkate almaktadır. Örneğin:

    plt.hist(x, range=(0, 100))
    
    Yine color parametresi çubukların renklerini ayarlamak için kullanılabilmektedir. orientation parametresi default 'vertical' 
    biçimdedir. Bu parametre 'horizontal' girilirse grafik yana yatmış şekilde görüntülenir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

x = [47.3, 59.1, 34.8, 52.6, 63.9, 44.7, 49.8, 70.4, 39.2, 54.0,
 61.7, 56.8, 42.5, 66.9, 50.4, 33.7, 46.1, 77.2, 58.6, 48.3,
 41.9, 65.1, 53.2, 60.8, 72.5, 46.8, 43.4, 50.9, 55.6, 68.0,
 57.9, 47.1, 64.3, 35.6, 52.0, 48.8, 40.2, 73.1, 44.3, 66.0,
 59.7, 54.8, 62.5, 30.9, 71.4, 45.6, 58.1, 49.2, 67.7, 36.4,
 51.3, 63.4, 42.1, 69.8, 56.2, 38.5, 53.9, 75.6, 41.2, 47.9,
 60.1, 64.7, 50.7, 43.8, 70.9, 55.3, 46.5, 39.8, 68.6, 61.0,
 32.7, 49.5, 72.0, 44.9, 58.9, 51.6, 66.5, 37.8, 47.5, 63.0,
 53.5, 48.0, 56.9, 41.7, 71.2, 45.1, 59.4, 50.1, 62.9, 43.2,
 57.6, 34.3, 54.6, 40.8, 69.3, 64.1, 49.0, 60.4, 67.1, 52.9]

plt.title('Histogram')
plt.hist(x, color='red', orientation='horizontal')
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    hist fonksiyonun burada ele aldığımız özelliklerden daha fazla özellikleri vardır. Bu ayrıntılar için Matplotlib kütüphanesinin
    dokümantasyonuna başvurabilirsiniz.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar Matplotlib kütüphanesini prosedürel biçimde kullandık. Yani bağımsız fonksiyonları çağırarak grafikleri çizdik.
    Aslında bu kütüphane "nesne yönelimli" bir biçimde de yani sınıflar ve onların metotları yoluyla da kullanılabilmektedir. Matplotlib
    kütüphanesinde figür gibi eksen gibi öğeler birer sınıfla temsil edilmiştir. Biz bu sınıflar türünden nesnelerle bu sınıfların 
    metotlarını çağırarak da çizimler yapabiliriz. Genel olarak global fonksiyonlardaki xxx isminin metot karşılığı set_xxx olarak 
    verilmiştir. Tabii prosedürel teknikle nesne yönelimli teknik birlikte de kullanılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Nesne yönelimli kullanımda ilk yapılacak şey figür ve eksen nesnelerinin elde edilmesidir. Prosedürel kullanımda zaten bizim için 
    default birFigure ve  Axes nesnesi yaratılmış durumdadır. Ancak istersek biz subplots fonksiyonu ile ayrı bir figüre nesnesi ve 
    Axes nesnesi oluşturabiliriz. subplots fonksiyonu default argümanlarla çağrılırsa bize ikili bir demet biçiminde bir tane figüre 
    ve onun içerisinde de bir tane eksen nesnesi verilir. Örneğin:

    fig, ax = plt.subplots()

    Burada subplots fonksiyonu bir tane Fıgure nesnesi ve o nesnes içerisinde çizimin yapılacağı bir de Axis nesnesini bir demet
    biçiminde vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

fig, ax = plt.subplots()

#------------------------------------------------------------------------------------------------------------------------------------
    Ancak subplots fonksiyonu belli bir sayıda eksen oluşturacak biçimde de çağrılabilir. Bu durumda eksen nesneleri bir NumPy 
    dizisi olarak verilecektir. Örneğin:

    fig, ax = plt.subplots(3, 3)

    Burada artık ax 3x3'lik her elemanı Axes olan bir NumPy dizisi beelirtmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

fig, ax = plt.subplots(3, 3)

#------------------------------------------------------------------------------------------------------------------------------------
    subplots fonksiyonundan elde ettiğimiz Figure ve Axis nesneleri ile biz artık bu sınıfın metotlarını çağırarak işlemler yapabiliriz. 
    Örneğin Figure nesnesini boyutlandırmak için set_size_inches metodu kullanılmaktadır. 

    fig, ax = plt.subplots(3, 3)
    fig.set_size_inches(6, 4)

    Ya da örneğin figürün zemin rengini değiştirmek için Figure sıfının set_facecolor metodu kullanılabilir. 

    Figure sınıfının pek çok metodu vardır. Bunların listesini aşağıdaki bağlantıdan inceleyebilirsiniz:

    https://matplotlib.org/stable/api/figure_api.html
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

fig, ax = plt.subplots(3, 3)
fig.set_size_inches(6. 4)
fig.set_facecolor('yellow')
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Grafiğe ilişkin önemli unsurların hepsi Axes sınıfının metotları ile oluşturulmaktadır. Örneğin plot, scatter, hist, bar gibi 
    fonksiyonlar nesne yönelimli kullanımda Axes sınıfının metotları durumundadır. Örneğin legend da aslında Axes sınıfının bir 
    metoduyla çıkartılabilmektedir. Çizim sonrasında ayine show işlemi fonksiyon yoluyla yapılmalıdır. Birden falz axis nesnesiyle 
    ile çalışırken çizimde hangi hangi axis nesnesini kullanırsak çizi oraya yapmış oluruz. Örneğin:

    fig.set_size_inches(6, 6)
    fig.set_facecolor('yellow')

    ax[0, 0].set_title('Histogram', fontsize=8, fontweight='bold')
    ax[0, 0].set_xticks(np.arange(-5, 5), labels=[str(label) for label in np.arange(-5, 5)], fontsize=8)
    ax[0, 0].hist(np.random.randn(100))

    ax[0, 1].set_title('Histogram', fontsize=8, fontweight='bold')
    ax[0, 1].set_xticks(np.arange(-5, 5), labels=[str(label) for label in np.arange(-5, 5)], fontsize=8)
    ax[0, 1].hist(np.random.randn(100))

    ax[1, 0].set_title('Sinüs', fontsize=8, fontweight='bold')
    ax[1, 0].set_xticks(np.arange(-5, 5), labels=[str(label) for label in np.arange(-5, 5)], fontsize=8)
    ax[1, 0].plot(np.linspace(-6.28, 6.28, 1000), np.sin(np.linspace(-6.28, 6.28, 1000)))

    ax[1, 1].set_title('Cosinüs', fontsize=8, fontweight='bold')
    ax[1, 1].set_xticks(np.arange(-5, 5), labels=[str(label) for label in np.arange(-5, 5)], fontsize=8)
    ax[1, 1].plot(np.linspace(-6.28, 6.28, 1000), np.cos(np.linspace(-6.28, 6.28, 1000)))
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

fig, ax = plt.subplots(2, 2)

fig.set_size_inches(6, 6)
fig.set_facecolor('yellow')

ax[0, 0].set_title('Histogram', fontsize=8, fontweight='bold')
ax[0, 0].set_xticks(np.arange(-5, 5), labels=[str(label) for label in np.arange(-5, 5)], fontsize=8)
ax[0, 0].hist(np.random.randn(100))

ax[0, 1].set_title('Histogram', fontsize=8, fontweight='bold')
ax[0, 1].set_xticks(np.arange(-5, 5), labels=[str(label) for label in np.arange(-5, 5)], fontsize=8)
ax[0, 1].hist(np.random.randn(100))

ax[1, 0].set_title('Sinüs', fontsize=8, fontweight='bold')
ax[1, 0].set_xticks(np.arange(-5, 5), labels=[str(label) for label in np.arange(-5, 5)], fontsize=8)
ax[1, 0].plot(np.linspace(-6.28, 6.28, 1000), np.sin(np.linspace(-6.28, 6.28, 1000)))

ax[1, 1].set_title('Cosinüs', fontsize=8, fontweight='bold')
ax[1, 1].set_xticks(np.arange(-5, 5), labels=[str(label) for label in np.arange(-5, 5)], fontsize=8)
ax[1, 1].plot(np.linspace(-6.28, 6.28, 1000), np.cos(np.linspace(-6.28, 6.28, 1000)))

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında biz hiç subplots fonksiyonunu kullanmasak da işin başında default bir Figure nesnesi ve Axes nesnesi zaten yaratılmış 
    durumdadır. Default olarak yaratılmış olan bu Figure nesnesini elde etmek için gcf (get current figure) ve default yaratılmış 
    olan Axes nesnesini elde etmek için de gca (get current axis) fonksiyonları kullanılabilmektedir. Örneğin:

    fig = plt.gcf()
    ax = plt.gca()

    fig.set_size_inches((6, 4))
    ax.set_title('Histogram')
    ax.hist(np.random.randn(1000))
    plt.show()

#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-6, 6, 1000)
y = np.sin(x)

fig = plt.gcf()
ax = plt.gca()

fig.set_size_inches((6, 4))
ax.set_title('Sinüs')
ax.plot(x, y)
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.grid(True)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Normal olarak Matplotlib kartezyen koordinat sistemindeki gibi birbirini kesen x ve y ekselerini oluşturmaz. Ancak çizimin koordinat 
    eksenleriyle görüntülenmesini isteyebilirsiniz. Bunun bazı işlemler yapmanız gerekir. Normal olarak bir eksenin kenarlarında dört 
    tane kenar vardır. Bu dört çizgi adeta ekseni bir kuru gibi göstermektedir. İşte bu biz yatay ve düşüy taraftaki kenarlardan ikisini 
    ortaya taşırsak ve kalan ikisini de görünmez hale getirirsek sanki kartezyen koordinat ekseni gibi bir görünrü  elde edebiliriz. 
    Bu kenarlara "spines" debilmektedir. Belli bir kenarı ortaya almak için ilgili kenarı eksen nesnesinin spines metodu ile elde edip 
    ona set_position metodunu uygulamak gerekir. Örneğin:

    ax.spines['left'].set_position('center')

    Burada biz soldaki kenarı ortaya almış olduk. Aşağı kenarı da benzer biçimade aşağıdaki gibi ortaya alabiliriz:

    ax.spines['bottom'].set_position('center')

    Maalesef bu kenarları silmenin pratik bir metodu yoktur. Silme işlemi set_color metodunun None ile çağrılmasıyşa yapılmaktadır. 
    Örneğin:

    ax.spines['right'].set_color(None)
    ax.spines['top'].set_color(None)

    Bu durumda yapılacak işlemler şunlardır:

    fig, ax = plt.subplots(1)

    ax.spines['left'].set_position('center')
    ax.spines['bottom'].set_position('center')
    ax.spines['right'].set_color(None)
    ax.spines['top'].set_color(None)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Örneğin kartezyen koordinat eksenleriyle Gauss eğrisini aşağıdaki gibi
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-6, 6, 1000)
y = np.sin(x)

fig, ax = plt.subplots(1)

ax.spines['left'].set_position('center')
ax.spines['bottom'].set_position('center')
ax.spines['right'].set_color(None)
ax.spines['top'].set_color(None)

fig.set_size_inches((6, 4))
ax.set_title('Sinüs')
ax.plot(x, y)
ax.set_xlabel('X')
ax.set_ylabel('Y')

plt.show()

import numpy as np
import matplotlib.pyplot as plt

def normal_pdf(x, mu=0, sigma=1):
    return (1/(sigma * np.sqrt(2 * np.pi))) * np.exp(-(x-mu) ** 2 / (2 * sigma ** 2))

x = np.linspace(-6, 6, 1000)
y = normal_pdf(x)

fig, ax = plt.subplots(1)

ax.spines['left'].set_position('center')
ax.spines['bottom'].set_position('center')
ax.spines['right'].set_color(None)
ax.spines['top'].set_color(None)

fig.set_size_inches((6, 4))

ax.set_title('Sinüs')
ax.set_xlim(-6, 6)
ax.set_ylim(-0.5, 0.5)

ax.plot(x, y)

ax.set_xlabel('X')
ax.set_ylabel('Y')

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Eğri altını boyamak için Axes sınıfının fill_between isimli metodu kullanılmaktadır. Bu metot aslında bize x ve y nokta çiftlerini 
    alır. Onları çizgilerle birleştirir. Örneğin:

    x = np.linspace(1, 2, 100)
    y = normal_pdf(x)
    ax.fill_between(x, y, color='gray')

    Burada x ve y noktaları arasında dikey çizgiler çizildiğii için sankio alan boyanmış gibi bir etki oluşacaktır. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

def normal_pdf(x, mu=0, sigma=1):
    return (1/(sigma * np.sqrt(2 * np.pi))) * np.exp(-(x-mu) ** 2 / (2 * sigma ** 2))

x = np.linspace(-6, 6, 1000)
y = normal_pdf(x)

fig, ax = plt.subplots(1)

ax.spines['left'].set_position('center')
ax.spines['bottom'].set_position('center')
ax.spines['right'].set_color(None)
ax.spines['top'].set_color(None)

fig.set_size_inches((6, 4))

ax.set_title('Sinüs')
ax.set_xlim(-6, 6)
ax.set_xticks(np.arange(-6, 6))
ax.set_ylim(-0.5, 0.5)
ax.set_yticks(np.arange(-0.5, 0.6, 0.1))
ax.plot(x, y)
x = np.linspace(1, 2, 100)
y = normal_pdf(x)
ax.fill_between(x, y, color='gray')
ax.arrow(3, 0.3, -1.5, -0.20, head_width=0.05, head_length=0.05)

ax.set_xlabel('X')
ax.set_ylabel('Y')

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Matplotlib aslında ayrıntıları olan bir kütüphanedir. Yapmak istediğiniz şey her neyse muhtemelen Matplotlib  içerisinde bunu 
    yapan bir fonksiyon ya da metot bulunuyor olacaktır. Bu konuda LLM'lerden faydalanarak istediğiniz işlemin nasıl yapılacağını 
    öğrenebilirsiniz. Örneğin bulduğunuz bir grafiği ChatGPT gibi bir LLM'e verip "bana bunu çizen Matplotlinb kodunu yazar mısın?" 
    gibi bir prompt girebilirsiniz. Tabii sonra onun yazdığı kod üzerinde değişikler de yapmanız gerekebilir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Thread'ler bir programın (prosesin) ayrı bir biçimde çizelgelenen farklı akışlarıdır. Bir program (proses) çalışmaya tek bir 
    thread'le başlar. Buna prograın (prosesin) ana thread'i (main thread) denilmektedir. Diğer thread'ler daha sonra programcı 
    tarafından yaratılmaktadır. Thread'ler aynı program üzerinde ilerleyen farklı akışlara denilmektedir. Thread'ler işletim sistemlerine
    90'lı yıllarda sokulmuştur. Thread kullanımının mümkün olduğu işletim sistemlerine "çok thread'li (multi-threaded)" işletim sistemleri
    denilmektedir. Windows, Linux, macOS thread kullanımının mümkün olduğu "çok thread'li (multi-threaded)" işletim sistemleridir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Modern çok prosesli ve çok thread'li işletim sistemlerinde programlar "zaman paylaşımlı (time sharing)" bir biçimde çalıştırılmaktadır. 
    İşletim sistemi thread'leri bir kuyrukta tutar. Bu kuyruğua genellikle "çalışma kuyruğu (run queue)" denilmektedir. Sonra kuyruktan 
    bir thread'i alır. Onu CPU'ya atar. O thread'in belli bir süre çalışmasını sağlar. Sonra o süre dolduğunda thread'in çalışmasına ara 
    verir. Sıraki thread'i CPU'ya atar ve çalışma "biraz onu biraz bunu" biçiminde devam ettirilir. Kullanıcılar programların aynı anda 
    çalıştığını sanırlar. Ancak aslında programlar bu biçimde kesikli kesikli çalışmaktadır. Bir thread'in CPU'ya atanıp parçalı bir biçimde 
    çalıştırılması süresine "quanta süresi (time quantum)" denilmektedir. Quanta süresini bitiren (ya da bloke olan) bir thread'in 
    CPU'dan koparılarak sıradaki thread'in CPU'ya atanması sürecine "theradler arası geçiş (context switch)" ya da "görev geçişi (task switch)" 
    denilmektedir. Quanta süreleri işletim sistemi taarafından uygun biçimde belirlenmektedir. 

    Birden fazla CPU'nun ya da çekirdeğin bulunduğu durumda zaman paylaşımlı çalışma benzer biçimde yürütülmektedir. Genellikle işletim 
    sistemleri her CPU ya da çekirdek için ayrı bir çalışma kuyruğu oluştururlar. Böylece toplamda birim zamanda yapılan iş 
    miktarı da artırılmış olur. Bu durumu süpermarketlerdeki birden fazla kasanın bulunmasına benzetebiliriz. Bazı işletim sistemleri 
    tek bir çalışma kuyruğu oluşturup bir CPU ya da çekirdekte thread'ler arası geçiş olacağı zaman o tek kuyruktan çizelgeleme yapmaktadır. 
    Bu tarzda kuyruklar yine gündelik hayatta karşımıza çıkabilmektedir. 

    İşletim sistemlerinde thread'leri CPU kuyruklarına yerleştirilmesi, CPU'ya atanması, thread'ler arası geçiş (context switch) işlemlerini
    yapan alt sisteme "çizelgeleyici (scheduler)" denilmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Python'da thread'ler konusunu ele alacağız. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir işin birden fazla akışa yaptırılması ile ilgili çeşitli terimler kullanılmaktadır. Bazen bu terimler yanlış da anlaşılabilmektedir
    Aşağıda bu terimlerin açıklamalarını yapmak istiyoruz:

    1) Concurrent Computing / Concurrency: Bir işin birden fazla akışa yaptırılmasına yönelik en genel terimdir. Bu bir şemsiye
    terim olarak düşünülebilir. 

    2) Distributed Computing: Bir işin ağ içerisindeki birden fazla bilgisayar tarafından yapılmasına denilmektedir. Burada vurgulanan
    şey işin bilgisayarlara dağıtılıp eşzamanlı biçimde yaptırılmasıdır. 

    3) Parallel Programming (Paralel Programlama): Bir işin aynı makinedeki birden fazla CPU ya da çekirdeklere dağıtılarak eş zamanlı 
    bir biçimde yaptırılma çabasına denilmektedir. Burada vurgulanan şey işin aynı makinede farklı CPU ya da çekirdeklere eş zamanlı 
    yaptırılmasıdır. 

    4) Multi-Threading Programming (Çok Thread'li Programlama): Bit işin thread'ler yoluyla aynı makinede birden fazla akışa yaptırılmasına
    ilişkin çabalara çok thread'li programlama denilmektedir. Thread'ler paralel programlama yapabilmek için de gereken unsurlardır. 
    Çok thread'li programlamada thread'lerin aynı anda birden fazla CPU ya da çekirdekte çalışması zorunlu değildir. Tek işlemcili 
    sistemlerde de çok thread'li programlama yapılabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Modern işletim sistemlerinin çoğu çok prosesli ve çok thread'li çalışmayı mümkün kılmaktadır. Windows, Linux, macOS gibi işletim 
    sistemlerinde hem birden fazla program hem de her programda birden fazla akış bulunabilmektedir. İşletim sistemlerinde çalışmakta 
    olan programlara "proses (process)" denilmektedir. Program terimi "çalıştırılabilen dosyalar için" ya da "programın kaynak kodu" 
    için kullanılan bir terimdir. Bir program çalışmaya başladığında artık ona "proses" denilmektedir. Thread ise bir prosesin 
    akışları için kullanıan bir kavramdır. Proses denildiğinde yalnızca bir akış anlaşılmaz. Proses çalışmakta olan programın 
    bütün bilgilerini temsil etmektedir. Örneğin:

    - Bellekte nerede  bulunduğu
    - Yetki derecesi
    - Açılmış dosyalar
    - Çalışma dizini
    - Kimlik bilgileri
    - Diğer pek çok bilgiler
    
    Gibi bilgiler prosese özgü bilgilerdir. Thread ise yalnızca bir akış belirtmektedir. 

    Bir proses (yani program) tek bir thread ile yaratılmaktadır. Buna porsesin "ana thread'i (main thread)" denilmektedir. Python'da
    biz bir program yukarıdna aşağıya doğru çalışır. İşte bu akış prosesin ana thread'idir. Ana thread'i programcı yaratmaz. Ana 
    thread proses yaratıldığonda otomatik yaratılmaktadır. Prosesin diğer thread'lerini programcı izleyen paragraflarda açıklayacağımız 
    gibi çeşitli fonksiyonlarla yaratıp idare etmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                                56. Ders 05/10/2025 – Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bugün yaygın biçimde kullandığımız Windows, Linux ve macOS gibi işletim sistemleri "zaman paylaşımlı (time sharing)" çalıtırm 
    yöntemini kullanmaktadır. Bu sistemlerde tek bir CPU ya da çekirdek olsa bile bu sistemler aynı anda pek çok thread'i zaman 
    paylaşımlı bir biçimde yani "biraz onu biraz bunu" biçiminde çalıştırmaktadır. Zaman paylaşımlı çalışmada işletim sisteminin 
    çalıştırma birimleri thread'lerdir. İşletim sistemi proseslerin thread'lerini ismine "çalıştırma kuyruğu (run queue)" denilen 
    bir kuyruk sisteminde tutar. Kuyruktan bir thread'i alarak CPU'ya atar. O thread belli bir süre CPU'da çalıştırılır. Bu süre 
    dolduğunda işletim sistemi thread'i CPU'dan alarak kalınan yeri kaydeder, sıradki thread'i CPU'ya atar. Yeniden çalışma sırası 
    ilgili thread'e geldiğinde o thread kaldığı yerden çalışmaya devam ettirilir. Dışarıdan bakıldığında sanki tüm programlar yani 
    thread'leri aynı anda çalışıyormuş gibi bir illüzyon oluşturulmaktadır. Aslında CPU'lar aynı tek bir thread'i çalıştırabilmektedir. 
    Ancak bu zaman paylaşımlı çalışma çok hızlı yapıldığı için "sanki dışarıdan bakıldığında bunlar aynı anda çalışıyormuş" sanılabilmektedir. 

    CPU'ya çalışan thread'in çalışmasına ara verilerek sıradaki thread'in CPU'ya atanarak çalıştırılması sürecine "bağlamsal geçiş
    (context switch)" ya da "threadler arası geçiş (task switch)" denilmektedir. Bağlamsal geçiş belli bir zaman kaybı oluşturmaktadır. 

    Bir thread'in CPU'ya atandaıktan sonra parçalı çalışma süresine "quanta süresi" ya da İngilizce "time quantum" denilmektedir. 
    Quanta süresi çok yükske tutulursa "programların aynı anda çalışıyormuş illüzyonu" bozulabilir. Kullanıcı ile etkileşim konusunda 
    sorunlar ortaya çıkabilir. Quanta süresi çok kısa tutulursa bu durumda da çok fazla thread'ler arası geçiş oluşur. Birim zamanda 
    yapılan iş miktarı (througput) azalır. Bugünkü donanımlarda çalışan Linux sistemleri oralama 60 ms., Windows sistemlerinde ise 
    ortalama 20 ms. quanta süresi kullanmaktadır. Ancak thread'lerin kullandığı quanta süreleri çeşitli koşullara bağlı olarak 
    değişebilmektedir. 

    Bu durumda programımızın iki noktası arasında geçen mutlak zaman çalışma kuyruğundaki therad'lerin sayısına bağlı değişebilmektedir. 
    Bu sistemlerde tüm thread'lerin CPU'yu paylaştığına dikkat ediniz. 

    Pekiyi ya sistemimizde birden fazla CPU ya da çekirdek (core) varsa? Bugün kullandığımız mikroişlemcilerde aynı devre içerisine 
    "çekirdek (core)" adı altında birden fazla CPU yerleştirilmektedir. Biren fazla CPU ya da çekirdek söz konusu olduğunda zaman
    paylaşımlı çalışmada aslında değişen önemli bir nokta yoktur. Bu durumu bir yemekhanede birden fazla koladan yemek verilmesine
    benzetebiliriz. Yine kişiler kurukta bekleyecektir ancak toplamda daha az bekleyecektit. Birdne fazla CPU ya da çekirdeğin 
    bulunduğu durumda işletim sistemleri genellikle her CPU ya da çekirdek için ayrı bir çalıştırma kuyruğu oluşturmaktadır. 
    Ancak yime çalışma zaman paylaşımlı yapılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir programda birden fazla akışın yani thread'in bulunmasının nasıl bir faydası vardır? Başka bir deyişle thread'lere 
    neden gereksinim duyulmaktadır? Thread'lerin kullanılma nedenlerini maddeler halinde şöyle açıklayabiliriz:

    1) Thread'ler arka plan periyodik işlemlerin yapılabilmesi için iyi bir araç oluşturmaktadır. Örneğin bir program çalışırken aynı 
    zamanda saati ekranın bir yerine basacak olsun. Tek bir akışla bu işlemi yapmak çok zordur. Çünkü ana akış input gibi bir fonksiyona 
    girdiğinde artık saati basma imkanı kalmaz. Ana akışın input gibi bir fonksiyona girmese bile hem bir işi yaparken periyok başka 
    bir işlemi yapılması çok zordur. Halbuki çok thread'li programlamada bir thread yaratılır ve arka plan periyodik işlemler bu thread'e 
    havale edilir. Böylece programın ana akışı ilerlemeye devam eder. Ondan bağımsız bir biçimde yaratılan thread periyodik işlemleri 
    yapar. Thread'ler biribinden bağımız olarak sanki ayrı programlarmış gibi çalışmaktadır. Bir thread'in bir noktada beklemesi (teknik 
    olarak "bloke olması") diğer thread'lerin çalışmasını engellemektedir. 

    2) Thread'ler bir işi hızlandırmak için de kullanılmaktadır. Bir işi tek bir akışa yaptırmak yerine biren fazla akışa yaptırabilirsek
    o işin daha hızlı bitirilmesini saplayabiliriz. 

    3) Thread'ler "paralel programlama (parallel programming)" ortamı oluşturmak için de kullanılmaktadır. 

    4) GUI programlama modelinde bir mesaj oluştuğunda bir işlem yapmak istediğimizde o işlemi uzatmamalıyız. Aksi takdirde
    mesaj döngüsü işletilmemiş olur ve program donmuş gibi bir etki oluşur. Bu tür durumlarda bir mesaj oluştuğunda uzun süren bir 
    işlem yapılacaksa bir thread yaratılır, uzun sürecek işlem thread'e havale edilir. Eğer işlem iptal edilecekse o thread öldürülür. 
    Yani GUI programlama modelinde therad'ler bazen mecburen kullanılmaktadır. 

#------------------------------------------------------------------------------------------------------------------------------------
    Python'da thread işlemleri için standart kütüphanedeki threading modülü kullanılmaktadır. Thread yaratmak için threading modülü 
    içerisindeki Thread sınıfı kullanılmaktadır. Thread türünden bir nesne yaratılır. Bu nesne yaratılırken "target" parametresine 
    thread akışının başlatılacağı fonksiyon girlir. Ancak thread akışı thead nesnesi ile start metodunun çağrılmasıyla başlatılır. 
    (time modülünde sleep fonksiyonu hangi thread akışı tarafından çağrılmışsa yalnızca o thread'i bekletmektedir. )

    Thread sınıfının __init__ metodunun target parametresi birinci parametre değildir. Bu nedenle bu parametreyi isimli kullanmalısınız. 
    Örneğin:

    thread = threading.Thread(target=thread_proc)
    thread.start()

    Programın akışı start metodundan hemen çıkarak devam eder. Ancak yeni bir thread yaratılıp sanki bağımsız bir programmış gibi 
    o thread de zaman paylaşımlı biçimde çalıştırılır. Thread'ler belli bir fonksiyondan çalışmaya başlamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

def thread_proc():
    for i in range(10):
        print('other thread')
        time.sleep(1)

thread = threading.Thread(target=thread_proc)
thread.start()

for i in range(10):
    print('main thread')
    time.sleep(1)

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte biz thread akışının başlatılacağı fonksiyonu yukarıda yazmak zorunda kaldık. Böyle bir zorunluluğu ortadan 
    kaldırmak için thread'i yaratan kodu da başka bir fonksiyon içerisine alabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

def main():
    thread = threading.Thread(target=thread_proc)
    thread.start()
    
    for i in range(10):
        print('main thread')
        time.sleep(1)

def thread_proc(): 
    for i in range(10):
        print('other thread')
        time.sleep(1)

main()

#------------------------------------------------------------------------------------------------------------------------------------
    İşletim sistemlerinde genel olarak thread'ler arasında altlık-üstlük ilişkisi yoktur. Bir thread herhangi bir thread akışı 
    içerisinde yaratılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Thread çalışmaya başladığında thread fonksiyonuna parametre de aktarılabilmektedir. Bunun için Thread nesnesi yaratılırken
    Thread sınıfının __init__ metodunda args parametresi kullanılır. args her zaman bir demet olarak girilmektedir. Bu demetteki 
    değerler sırasıyla thread fonksiyonunun parametresine argüman olarak geçirilmektedir.Örneğin:

    thread = threading.Thread(target=thread_proc, args=(10, 20))
    thread.start()
    
    Burada thread_proc fonksiyonun iki parametresi olmalıdır. 10 değeri ilk parametreye 20 değeri de diğer parametreye aktarılarak 
    thread akışı başlatılır.
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

def main():
    thread = threading.Thread(target=thread_proc, args=('Other thread', 10))
    thread.start()
    
    for i in range(10):
        print('Main thread')
        time.sleep(1)

def thread_proc(name, count):
    for i in range(10):
        print(f'{name}: {i}')
        time.sleep(1)
        
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Thread fonksiyonuna parametre ismi belirtilerek de argüman geçilebilir. Bunun için Thread sınıfının kwargs parametresi kullanılmaktadır. 
    Bu parametreye bir sözlük nesnesi girilmelidir. Sözlüğün anahtarları parametre değişkenlerinin isimlerinden değerleri de ona 
    aktarılacak değerlerden oluşmalıdır. Tabii bu durumda thread fonksiyonunun sözlükte belirtilen isimli parametrelere sahip olması 
    gerekir. Yani args parametresi argümanları sırasıyla, kwargs parametresi ise isimli olarak aktarmaktadır. Örneğin:

    thread = threading.Thread(target=thread_proc, kwargs={'name': 'Other thread', 'count': 10})
    thread.start()

    Burada thread_proc fonksiyonun iki parametresi olmalıdır. Birinci parametre name, ikinci parametre count biçiminde isimlendirilmelidir. 

    args parametresi ile kwargs parametresi beraber de kullanılabilir. Bu duurmda önce args parametresi ile pozisyonel bir biçimde
    eşleştirme yapılır. Sonra kwargs parametresi ile isimsel eşleştirme yapılır. Ancak default değer almayan her parametre değişkeni 
    ile bir tane ve yalnızca bir tane argüman eşleştirmesi yapılmak zorundadır. Örneğin:

    thread = threading.Thread(target=thread_proc, args=('Other thread', ), kwargs={'name': 4, 'step': 1, 'stop': 20})
    thread.start()

    Burada 'Other thread' yazısı thread fonksiyonun brinci parametresine aktarılmaktadır. Diğer diğer argümanlar da isimli parametrelere 
    aktarılmaktadır. Yani siz bu durumda thread fonksiyonun aşağıdaki gibi çağrıldığını düşünebilirsiniz:

    thread_proc(*args, **kwargs)
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

def main():
    thread = threading.Thread(target=thread_proc, args=('Other thread', ), kwargs={'start': 4, 'step': 1, 'stop': 20})
    thread.start()
    
    for i in range(10):
        print(f'Main thread: {i}')
        time.sleep(1)

def thread_proc(name, start, stop, step):
    for i in range(start, stop, step):
        print(f'{name}: {i}')
        time.sleep(1)

main()

#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir thread ne zaman sonlanmaktadır? Bir thread en doğal olarak thread fonksiyonunun sona ermesiyle sonlanmaktadır. Bu durum 
    zaten en fazla tavsiye edilen sonlanma biçimidir. Bir thread'in sonlanıp sonlanmadığını anlayabilmek için Thread sınıfının is_alive 
    metodu kullanılmaktadır. Aşağıdaki programda önce bu metot çağrıldığında thread sonlanmamış olacaktır. Ancak daha sonra çağrıldığında 
    thread sonlanmış olacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

def main():
    thread = threading.Thread(target=thread_proc, args=('Other thread', ))
    thread.start()
    
    print('still running' if thread.is_alive() else 'finished')
    time.sleep(10)
    print('still running' if thread.is_alive() else 'finished')
    
def thread_proc(name):
    for i in range(5):
        print(f'{name}: {i}')
        time.sleep(1)

main()

#------------------------------------------------------------------------------------------------------------------------------------
    Maalesef Python'da thread kendi akışı tarafından sonlandırılamamaktadır. (Örneğin diğer dillerdeki kütüphanelerde thread'in kendini 
    sonlandırması için exit benzeri fonksiyonlar bulunmaktadır.) Ancak bir thread'te exception oluşursa ve ele alınmazsa tüm program 
    değil yalnızca o thread yok edilmektedir. O halde kendi thread akışımızı exception yoluyla sonlandırabiliriz. Biz sonlandırmak 
    istediğimiz yerde bir exception oluştururuz. Bunu thread fonksiyonunda yakalayıp thread fonksiyonun bitmesini sağlarız. Örneğin:

    def main():
        thread = threading.Thread(target=thread_proc, args=('Other thread', ))
        thread.start()
        
        for i in range(10):
            print(f'Main thread: {i}')
            time.sleep(1)   

    def thread_proc(name):
        try:
            foo(name)
        except Exception:
            pass

    def foo(name):
        for i in range(100):
            print(f'{name}: {i}')
            if i == 5:
                raise Exception()
            time.sleep(1)

    Burada foo fonksiyonu içerisinde thread'in sonlanması için bir exception raise edilmiştir. Bu exception thread fonksiyonun içerisiden
    ele alınıp thread fonksiyonun bitmesi sağlanmıştır. Yukarıda da belirttiğimiz gibi bir thread akışında exception oluştuğunda tüm 
    program değil yalnızca o thread akışı sonlandırılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

def main():
    thread = threading.Thread(target=thread_proc, args=('Other thread', ))
    thread.start()
    
    for i in range(10):
        print(f'Main thread: {i}')
        time.sleep(1)
    
def thread_proc(name):
    try:
        foo(name)
    except Exception:
        pass

def foo(name):
    for i in range(100):
        print(f'{name}: {i}')
        if i == 5:
            raise Exception()
        time.sleep(1)
        
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir thread'i sonlandırmanın diğer bir yolu da flag değişkeni kullanmaktır. Thread bir flag değişkenine arada bir bakarak işlemini 
    yürütebilir. Thread'i sonlandırmak için bu flag değişkeni uygun biçimde set edilebilir. Tabii bu modeli uygulamak her zaman mümkün 
    değildir.  Örneğin:

    def thread_proc(name):
        i = 0
        while g_flag: 
            print(f'{name}: {i}')
            time.sleep(1)
            i += 1

    Burada g_flag global değişkeni True olduğu sürece döngü yinelenmektedir. Başka bir threda akışı bu global dğeişkeni False değerine
    çekerse döngüden çıkılır fonksiyon dolayısıyla da thread sonlanır. 
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

g_flag = True

def main():
    global g_flag 
    
    thread = threading.Thread(target=thread_proc, args=('Other thread', ))
    thread.start()
    
    for i in range(10):
        print(f'Main thread: {i}')
        if i == 5:
            g_flag = False
        time.sleep(1)
    
def thread_proc(name):
    i = 0
    while g_flag: 
        print(f'{name}: {i}')
        time.sleep(1)
        i += 1
        
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi fonksiyonların yerel değişkenleri fonksiyonun akışı o yerel değişkenin yaratıldığı noktaya geldiğinde yaratılmakta 
    akış fonksiyondan çıktığında da yok edilmektedir. Bu mekanizma "stack" denilen bir kavramla sağlanmaktadır. Yerel değişkenler 
    stack denilen alanda yaratılır. Çok thread'li sistemlerde thread'lerin stack'leri birbirinden ayrılmıştır. Her thread'in ayrı bir 
    stack alanı vardır. Birden fazla thread aynı fonksiyon üzerinde ilerliyor olsa bile her thread o fonksiyondaki yerel değişkenlerin 
    kendine özgü farklı bir kopyasını kullanıyor durumda olmaktadır. Böylece farklı thread'ler aynı fonksiyon üzerinde ilerlese bile 
    yerel değişkenleri bozmazlar. Yerel değişkenlerin her thread için adeta ayrı bir kopyası bulunmaktadır. Örneğin:

    def foo(name):
        i = 0
        while i < 10:
            print(f'{name}: {i}')
            i += 1
            time.sleep(1)

    Bradaki foo fonksiyonunu iki farklı thread çağırmış olsun. Fonksiyondaki i yerel bir değişkendir. Bu nedenle iki farklı thread'in
    i değişkeni aslında farklıdır. Thread'lerden biri bu i değişkeninde değişiklik yaptığında kendi i değişkenini değiştirmiş olur. 
    Diğer thread'teki i değişkeni bu işlemden etkilenmez. 

    Aşağıdaki programda hem ana thread hem de yeni yaratılan thread foo fonksiyonu üzerinde ilerlemektedir. Ancak bu thread'ler foo 
    içerisindeki i değişkenin farklı kopyalarını kullanıyor durumdadırlar.
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

def main():   
    thread = threading.Thread(target=thread_proc, args=('Other thread', ))
    thread.start()
    
    foo('Main thread')
       
def thread_proc(name):
       foo(name)     
       
def foo(name):
    i = 0
    while i < 10:
        print(f'{name}: {i}')
        i += 1
        time.sleep(1)
       
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Fonksiyonların yerel değişkenlerinin stack alanında yaratıldığını, her thread'in de stack alanının farklı olduğunu belirtmiştik.
    Ancak global değişkenler thread'ler tarafından ortak kullanılmaktadır. Yani iki thread aynı global değişkeni kullandığında 
    gerçekten aynı değişkeni kullanmış olurlar. Başka bir deyişle bir thread bir global değişkeni değiştirdiğinde diğer thread onu 
    değişmiş olarak görür. Yukarıda yapmış olduğumuz örnekte i değişkenini global yaparsak iki thread'in de aynı değişkeni kullandığını 
    hemen anlayabiliriz:

    i = 0

    def foo(name):
        global i
        
        while i < 10:
            print(f'{name}: {i}')
            i += 1
            time.sleep(1)
        
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

def main():   
    thread = threading.Thread(target=thread_proc, args=('Other thread', ))
    thread.start()
    
    foo('Main thread')
       
def thread_proc(name):
       foo(name)     
    
i = 0

def foo(name):
    global i
    
    while i < 10:
        print(f'{name}: {i}')
        i += 1
        time.sleep(1)
       
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda Qt'de bir mesaj oluştuğunda uzun bir işlemin thread'e devredilmesine bir örnek verilmiştir. BuradBu örnektea "Ok" düğmesine 
    basıldığında thread yaratılıp uzun süren işlem başlatılmakta "Cancel" düğmesine basıldığında ise yaratılan thread sonlandırılmaktadır. 
    Yani uzun süren işlem bir thread'e devredilip mesaj döngüsünün işletilmesi sağlanmıştır. Bu tür durumlarda thread olmadan işin 
    içindne çıkmak oldukça güçtür. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import threading
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Signal/SLot Mechanism')
                            
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(10, 10, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkHandler)
        
        self.pushButtonCancel = QPushButton('Cancel', self)
        self.pushButtonCancel.setGeometry(120, 10, 100, 100)
        self.pushButtonCancel.clicked.connect(self.pushButtonCancelHandler)
        
    def pushButtonOkHandler(self):
        self.flag = False
        self.thread = threading.Thread(target=self.thread_proc)
        self.thread.start()
        
    def pushButtonCancelHandler(self):
        self.flag = True
        
    def thread_proc(self):
        print('Operation begins...')
        for i in range(1000000000):
            if self.flag:
                break
        print('Operation ends...')
       
app = QApplication(sys.argv)

mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Thread oluşturmanın diğer bir yolu da Thread sınıfından türetme yapmaktır. Aslında Thread sınıfındaki start metodu run isimli metodu 
    çağırmaktadır. Bizim target parametresinde belirttiğimiz fonksiyonu aslında Thread sınıfının run metodu çağırmaktadır. O halde biz 
    Thread sınıfından bir sınıf türetip run metodunu yazarsak start metodunu çağırdığımızda bu rum metodu çalışır. Yani artık adeta 
    thread'imizin çalışmaya başladığı fonksiyon run metodu olur. Örneğin:

    class MyThread(threading.Thread):
        def __init__(self, name, count):
            super().__init__()
            self.name = name
            self.count = count
            
        def run(self):
            for i in range(self.count):
                print(f'{self.name}: {i}')
                time.sleep(1)

    Burada thread sınıfından MyThrad isimli bir sınıf türetilip o sınıfta __init__ ve run metotları yazılmıştır. Artık bu sınıf 
    türünden bir nesne yaratıp onunla start metodu çağrılırsa bu start metodu Thread sınıfındaki run metodunu değil MyThread 
    sınıfındaki run metodunu çağırır. (Taban sınıf ve türemiş sınıfta aynı isimli metotlar varsa ve çağırma türemiş sınıf türünden 
    bir nesneyle yapılıyorsa türemiş sınıftaki metodun çağrılacağını anımsayınız.) Biz artık örneğimizde MyThread türünden bir nesne      
    yaratıp onunla start metodunu çağırabiliriz:

    thread = MyThread('Other thread', 10)
    thread.start()
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

def main():   
    thread = MyThread('Other thread', 10)
    thread.start()
    
    for i in range(10):
        print(f'Main thread: {i}', i)
        time.sleep(1)
    
class MyThread(threading.Thread):
    def __init__(self, name, count):
        super().__init__()
        self.name = name
        self.count = count
        
    def run(self):
        for i in range(self.count):
            print(f'{self.name}: {i}')
            time.sleep(1)
    
main()
<BURADA KALDIK>
#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte Thread sınıfından türetmiş olduğumuz MyThread sınıfı target parametresini Thread sınıfının __init__ metoduna geçirmektedir. 
    Ancak artık target parametresi ile belirtilen fonksiyon çağrılmayacaktır. Çünkü target parametresiyle belirtilen fonksiyonu aslında
    Thread sınıfının run metodu çağırmaktadır. Halbuki aşağıdaki örnekte Thread sınıfının run metodu değil MyThread sınıfının run metodu 
    çalıştırılmaktadır
#------------------------------------------------------------------------------------------------------------------------------------

import threading
import time

class MyThread(threading.Thread):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
    def run(self):
        for i in range(10):
            print(f'Mythread.run: {i}')
            time.sleep(1)

def main():
    mt = MyThread(target=thread_proc)
    mt.start()
   
    for i in range(10):
        print(f'Main Thread: {i}')
        time.sleep(1)
    
def thread_proc():
    for i in range(10):
        print(f'thread_proc: {i}')
        time.sleep(1)
    
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii türetme yapıp yine target parametresi yoluyla belirlediğimiz bir fonksiyonun thread fonksiyonu olmasını sağlayabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import threading
import time

class MyThread(threading.Thread):
    def __init__(self, text, **kwargs):
        super().__init__(**kwargs)
        self.text = text
             
def thread_proc():
    for i in range(10):
        print('Other thread')
        time.sleep(1)
    
mt = MyThread('Other thread', target=thread_proc)
mt.start()
for i in range(10):
    print('Main thread')
    time.sleep(1)

#------------------------------------------------------------------------------------------------------------------------------------
                                                55. Ders 12/07/2023 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Biz kendi sınıfımızdaki run metodunda da super fonksiyonu ile taban sınıfın run metodunu çağırabiliriz. Bu durumda
    target parametresi ile belirtilen fonksiyonu Thread sınıfının run metodu çağırdığına göre yine target parametresi ile belirtilen
    fonksiyon çağrılmış olacaktır. 
#------------------------------------------------------------------------------------------------------------------------------------

import threading

class MyThread(threading.Thread):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
    def run(self):
        print('thread started')
        super().run()
        
def main():
    mt = MyThread(target=foo)
    mt.start()
    
def foo():
    print('foo')
    
main()
    
#------------------------------------------------------------------------------------------------------------------------------------
    Thread sınıfının start metodunun nasıl run metodunu çağırdığı ve bunun nasıl override edildiği aşağıdaki örnekle
    anlaşılabilir.
#------------------------------------------------------------------------------------------------------------------------------------

class Thread:
    def __init__(self, target=None):
        self.target = target
    
    def start(self):
        self.run()
        
    def run(self):
        print('Thread.run running...')
        # new thread calls target
        if self.target:
            self.target()
    
class MyThread(Thread):
    def __init__(self, **kwargs):
        super().__init__()
            
def thread_proc():
    print('thread_proc')
    
mt = MyThread(target=thread_proc)       
mt.start()

class YourThread(Thread):
    def __init__(self):
        super().__init__()
        
    def run(self):
        print('YourThread.run running...')
        
yt = YourThread()
yt.start()

#------------------------------------------------------------------------------------------------------------------------------------
    Bazen bir thraed diğer bir thread sonlanana kadar onu beklemek isteyebilir. Örneğin bir thread bir şeyler yapmaktadır. 
    O şeyleri bitirince thread de sona ermektedir. O halde diğer thread o şeyler yapılana kadar beklemek isteyebilir. 
    İşte Thread sınıfının join isimli metodu ilgili thread akışı bitene kadar join metodunu çağıran thread'i blokede 
    bekletir. (Bloke kavramı izleyen bölümde ele alınmaktadır.) join metoduna istenirse saniye cinsinden bir zaman aşımı (timeout) 
    argümanı geçirilebilmektedir. Bu durumda eğer sonlanması beklenen thread bu zaman aşımına kadar sonlanmazsa join metodu 
    beklemeyi bırakır ve akış devam eder. 
#------------------------------------------------------------------------------------------------------------------------------------

import threading
import time

def main():
    thread = threading.Thread(target=foo, args=('Other thread', 10))
    thread.start()

    print('main thread wait for other thread to finish...')    
    thread.join()
    print('ok, main thread continues...')
    
def foo(name, count):
    for i in range(count):
        print(f'{name}: {i}')
        time.sleep(1)
    
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi programın ana thread'i diğer thread'lerden önce sonlanırsa ne olur? Bazı dillerde ana thread bittiğinde tüm program sonlandırıldığı
    için otomatik olarak diğer thread'ler de sonlandırılmaktadır. Halbuki Python'da durum böyle değildir. Python'da programın ana thread'i sonlansa
    bile program son thread sonlanana kadar devam etmektedir. Yani Python'da program ana thread sonlandığında değil son thread sonlandığında
    sonlanmaktadır. 

    Aşağıdaki örnekte ana thread yaratılan thread'ten daha sonlanmaktadır. Burada program bu thread'le çalışmaya devam edecek bu thread
    sonlandığında sonlanacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

import threading
import time

def main():
    thread = threading.Thread(target=thread_proc)       
    thread.start()
    
    for i in range(5):
        print(f'Main thread: {i}')
        time.sleep(1)
    
def thread_proc():   
    for i in range(10):
        print('Other thread')
        time.sleep(1)
    
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Python'un ana gerçekleştirimi olan CPython yorumlayıcısında GIL (Global Interpreter Lock) denilen problemli bir 
    durum vardır. CPython gerçekleştirimi referans sayacı (reference counting) temelli bir çöp toplayıcı (garbage collection)
    mekanizması kullandığı için maalesef birden fazla thread aynı anda sistem genelinde çalışamamktadır. Tek CPU'lu ya da
    tek çekirdekli sistemlerde zaten böyle bir durum söz konusu olmaz. Ancak günümüzde bilgisayarlarımızda kullandığımız işlemcilerde 
    artık çok sayıda çekirdek bulunmaktadır. Python programımızdaki thread'ler işletim sistemi tarafından farklı çekirdeklerin kuyruklarına 
    atanmış olsalar bile maalesef bu GIL mekanizması nedeniyle gerçek anlamda aynı anda çalışamaktadır. Bu da CPython gerçekleştiriminde 
    paralel programlama yapılamayacağı anlamına gelmektedir. Gerçi üçüncü parti bazı kütüphaneler bazı hilelerle bu GIL mekanizmasını 
    bypass edebilmektedir. Ancak bunun resmi bir yolu bulunmamaktadır. CPython gerçekleştiriminde çalışan programcılar bu problemi çözmeye 
    çalışıyor olsalar da henüz bir sonuca varamamışlardır. Bu GIL problemi Jython, Iron Python gibi gerçekleştirlerde yoktur. 

    GIL yüzünden CPython'da çok thread'li programlama maalesef önemli bir yara almıştır. Biz CPython gerçekleştiriminde programımızda ne 
    kadar çok thread kullanırsak kullanalım. Bu tjread'ler farklı CPU ya da çekirdeklerin kuyruklarına atanmış olsalar bile aynı anda
    çalışamamaktadır. GIL problemi yüzünden çok sayıda thread farklı çekirdekler tarafından aynı anda çalıştırılamadığından çok tread'li 
    programların performansları umulduğu kadar yüksek olmamaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki program CPython gerçekleştirimi ile çalıştırıldığında tek thread'li kod yaklaşık 22 saniye, çok thread'li kod yaklaşık 21
    zaman almıştır. Ancak IronPython gerçekleştirimi ile çalıştırıldığında tk thread'li kod yaklaşık 10 saniye çok thread'li kod yaklaşık
    6 saniye zaman almıştır. IronPython gibi bazı Python gerçekleştirimlerinde "GIL" problemi bulunmamaktadır.  
#------------------------------------------------------------------------------------------------------------------------------------

import threading
import time

def test1(): 
    t1 = time.time()
    for i in range(1_000_000_000):
        pass
    t2 = time.time()
    print(t2 - t1)
        
test1()

def test2():
    t1 = time.time()
    
    thread1 = threading.Thread(target=thread_proc1)
    thread2 = threading.Thread(target=thread_proc2)
    thread3 = threading.Thread(target=thread_proc3)
    thread4 = threading.Thread(target=thread_proc4)
    
    thread1.start()
    thread2.start()
    thread3.start()
    thread4.start()
    
    thread1.join()
    thread2.join()
    thread3.join()
    thread4.join()
    
    t2 = time.time()

    print(t2 - t1)
    
def thread_proc1():
    for i in range(250_000_000):
        pass

def thread_proc2():
    for i in range(250_000_000):
        pass
    
def thread_proc3():
    for i in range(250_000_000):
        pass

def thread_proc4():
    for i in range(250_000_000):
        pass

test2()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir thread çalışırken uzun süre beklemeyi gerektiren dışsal olayı başlatmışsa işletim sistemleri böyle thread'leri geçici olarak 
    çizelgeden (run kuyruğundan) çıkartarak bekleme kuyrukları (wait queues) denilen kuyruklarda bekletmektedir. Örneğin klavyeden 
    okuma yapmak, bir dosyadan okuma yapmak, bir soketten okuma yapmak, time.sleep gibi bir fonksiyonu çağırmak bu biçimde thread'in 
    çizelge dışına çıkartılmasına yol açarak uykuya dalmasına nedne olmaktadır. Bu olayları başlatan thread'ler CPU zamanı harcamasın 
    diye çizelge dışına çıkartılmaktadır. Ancak işletim sistemleri bu olayları arka planda kendisi zler. Bu bekleme sona erdiğinde (
    örneğin klavyeden bir giriş yapıldığında, diskten ilgili bölüm okunduğunda, network kartına bir bildi geldiğinde vs.)
    işletim sistemleri yeniden thread'leri çizelgeye alırlar. Burada bekleme işlemini yapan thread'ler için bir sorun yoktur. 
    Onlar zaten ilgili olay gerçekleşene kadar bekleyeceklerdir. Ancak onların çizelge dışına çıkartılması boşuna CPU zamanın harcanmasını 
    engeller. Dolayısıyla çalışma performansını artırır. Örneğin sistemimizde yüzlerece thread bulunuyor olabilir. Aslında bunların büyük 
    çoğunluğu o anda blokede beklemektedir. Bu nedenle sistem sanıldığı kadar yavaşlamamaktadır. İşte dışsal olay başlatan thread'lerin 
    geçici süre çizelgden (run kuyruğundan) çıkartılmasına ilgili thread'in "bloke olması (blocking)" denilmektedir. 

    Thread'leri "CPU yoğun (CPU bound)" ve "IO Yoğun (IO bound)" olmak üzere ikiye ayırabiliriz. CPU yoğun thread'ler kendisine verilen
    quanta süresinin büyük bölümünü bloke olmadan kullanırlar. Ancak IO yoğun thread'ler kendilerine verilen quanta süresinin çok 
    azını kullanırlar. Genellikle IO yoğun thread'lerle karşılaşılmaktadır. Sistemde çok sayıda IO yoğun thread'in bulunmasının bir zararı yoktur. 
    Ancak çok sayıda CPU yoğun thread sistemde hissedilebilir bir yavaşlık oluşturabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir therad'in yaşam döngüsü nasıldır? Thread yaratılır, quanta kullanmak için CPU'ya atanır. Sonra CPU'dan kopartılıp sonraki quanta
    için çalışma kuyruğunda bekler. Dışsal bir olayı başlattığında çalışma kuyruğundan çıkartılıp blokede bekletilir. Sonra olay gerçekleşince
    bekleme kuyruklarından yeniden çalışma kuyruğuna yerleştirilir. Bu yaşam döngüsünü şekilsel biçimde aşağıdaki gibi ifade edebiliriz:


    Running  ---------> Ready
        |    <--------    |
        |                 |
        -----> Wating -->--  

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Thread'ler konusunun en önemli kısmı "thread senkronizasyonudur". Thread senkronizasyonu birlikte birtakım işleri yapan
    thread'lerin birbirlerini kimi zaman bekleyerek olumsuz durumları bertaraf etmesi anlamına gelmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Thread senkronizasyonundaki en önemli kavramlardan biri "krtik kod (critical section)" denilen kavramdır. Belli bir kod parçasının 
    başından sonuna kadar tek bir thread akışı tarafından çalıştırılması gerektiği durumlarda bu kod kod parçalarına "kritik kod"
    denilmektedir. 

    Kritik kodlarda kritik koda giren thread bu kod içerisinde quanta süresini doldurup kesilebilir. Ancak başka bir thread 
    bu thread çıkmadan kritik koda girmemelidir. Kritik kod başından sonuna kadar kesilmeden çalışma anlamına gelmez. Başından sonuna
    kadar hiç thread'ler arası geçiş olmadan çalışmaya "atomik çalışma" denilmektedir. Kritik kodlara giren thread'ler quanta sürelerini 
    bitirip ya da bloke olup kesilebilirler. Ancak başka thread'ler onlar krtik koddan çıkmadan kritik koda girmemelidirler. 

    Aşağıdaki örnekte iki farklı thread aynı global değişkeni birer milyon kez artırmıştır. Ancak sonuç 2 milyon çıkmayabilecektir.
#------------------------------------------------------------------------------------------------------------------------------------

import threading

count = 0

def main():
    thread1 = threading.Thread(target=thread_proc1)
    thread2 = threading.Thread(target=thread_proc2)
    
    thread1.start()
    thread2.start()
    
    thread1.join()
    thread2.join()
    
    print(count)
    
def thread_proc1():
    global count
    
    for i in range(1000000):
        count += 1

def thread_proc2():
    global count
    
    for i in range(1000000):
        count += 1
    
main()

#------------------------------------------------------------------------------------------------------------------------------------
                                                56. Ders 17/07/2023 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    İki thread'in bir makineyi sırasıyla 1'den 5'e kadar konumlara soktuğunu varsayalım. Örneğin thread'lerden biri makineyi 2 numaralı  
    konuma soktuktan asonra thread'ler arası geçiş oluşup diğer çalışmaya başlarsa ve diğer thread'te bu makineyi kullanırsa makinenin konumu 
    bozulacaktır. Birinci thread yeniden kaldığı yerden çalışmaya devam ettiğinde makineyi 2 numaralı konumda sanacaktır. Ancak makine artık 2 
    numaralı konumda değildir. Aşağıda bu örnek simüle edilmiştir. Bu örnekte aslında olması gereken şey thread'lerden biri makineyi kullanmaya
    başladığı zaman diğerlerinin bu thread kullanımı bitirene kadar bekletilmesidir. 
#------------------------------------------------------------------------------------------------------------------------------------

import time
import random
import threading

def main():
    thread1 = threading.Thread(target=thread_proc1)
    thread2 = threading.Thread(target=thread_proc2)
    
    thread1.start()
    thread2.start()
    
def thread_proc1():
    for _ in range(10):
        run_machine('thread1')
        
def thread_proc2():
    for _ in range(10):
        run_machine('thread2')

def run_machine(name):
    print(f'{name}: 1. Step')
    time.sleep(random.random())
    print(f'{name}: 2. Step')
    time.sleep(random.random())
    print(f'{name}: 3. Step')
    time.sleep(random.random())
    print(f'{name}: 4. Step')
    time.sleep(random.random())
    print(f'{name}: 5. Step')
    time.sleep(random.random())
    print('-------------------------------')
    
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Kritik kodlar flag kullanılarak manuel biçimde oluşturulamazlar. Örneğin aşağıdaki gibi bir kritik kod oluşturulamamaktadır:

    g_flag = False
    ...

    while g_flag:
        pass
    g_flag = True
    ...
    ...             <KRİTİK KOD>
    ...
    g_flag = False
    
    Bu kodda iki önemli kusur vardır:

    1) Thread'ler arası geçiş aşağıda belirtilen noktada olursa birden fazla thread kritik koda girebilir. Yani mekanizma çalışmaz:

     g_flag = False
    ...

    while g_flag:
        pass
    ----->      DİKKAT! Bu noktada thread'ler arası geçiş oluşursa mekanizma çalışmaz!
    g_flag = True
    ...
    ...             <KRİTİK KOD>
    ...
    g_flag = False

    2) Bu kodda bekleme döngü içerisinde CPU zamanı harcanarak yapılmaktadır. Halbuki beklemenin "thread'in çalışma kuyruğundan (run queue)" 
    çıkartılarak bekleme kuyruklarına alınması biçiminde uykuya yatırılarak yapılması gerekir. 

    İşte kritik kodlar ancak işletim sisteminin özel mekanizmalarıyla sağlanabilmektedir. Bu özel mekanizmaları kullanan standrat Python
    sınıfları vardır. 
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    Kritik kod oluşturmanın en  pratik yolu threading modülündeki Lock isimli sınıfı kullanmaktır. Bu sınıf yoluyla kritik kod
    şöyle oluşturulur:

    1) Önce thread'ler yaratılmadan global bir Lock nenesi yaratılmalıdır. (Ya da yerel düzeyde yaratılıp thread'lere parametre olarak da geçirilebilir.)
    Örneğin:

    g_lock = threading.Lock()

    2) Kritik kod aşağıdaki gibi oluşturulur:

    g_lock.acquire()
    ...
    ...     <KRİTİK KOD>
    ...
    g_lock.release()

    Burada thread'lerin aynı lock nesnesini kullanması gerekmektedir. Bunun basit bir yolu Lock nesnesinin global düzeyde oluşturulması olabilir. 
    Diğer bir yolu da thread'lere parametre yoluyla aktarılmasıdır. 

    Thread'lerden biri lock.acquire() metodunu kilit açıksa geçer ve kilidi otomatik olarak kilitler. Başka thread'ler aynı nesneyle
    acquire yapmak istediklerinde bloke olup kilidi almış thread'in kilidi bırakmasını beklerler. Kilidi almış olan thread lock.release() ile
    kilidi bırakır. Bu durumda bekleyen thread'lerden biri kilidi alır. Bekleyenlerden hangisinin kilidi alacağı konusunda bir garanti verilmemektedir. 
    (Yani ilk bekleyenin kilidi alması gibi bir granti söz konusu değildir.)

    Bir thread Lock nesnesini lock acquire metodu ile kilitlemişse başka thread release uygulasa bile kilit açılmaz. Bu durumda 
    exception (RuntimeError) Kilidin açılması kilidi alan thread'in release uygulamasıyla mümkün olmaktadır. Yani kilidin thread temelinde
    sahipliği vardır. Hangi thread aquire yapmış ise o thread release yapabilir. 

    Aşağıdaki daha önce yapmış olduğumuz makine konumlandırma örneği Lock nesnesi ile düzeltilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import time
import random
import threading

g_lock = threading.Lock()

def main():
    thread1 = threading.Thread(target=thread_proc1)
    thread2 = threading.Thread(target=thread_proc2)
    
    thread1.start()
    thread2.start()
    
def thread_proc1():
    for _ in range(10):
        run_machine('thread1')
        
def thread_proc2():
    for _ in range(10):
        run_machine('thread2')

def run_machine(name):
    g_lock.acquire();
    print(f'{name}: 1. Step')
    time.sleep(random.random())
    print(f'{name}: 2. Step')
    time.sleep(random.random())
    print(f'{name}: 3. Step')
    time.sleep(random.random())
    print(f'{name}: 4. Step')
    time.sleep(random.random())
    print(f'{name}: 5. Step')
    time.sleep(random.random())
    print('-------------------------------')
    g_lock.release()
    
main()

#------------------------------------------------------------------------------------------------------------------------------------
    İki thread'in aynı gloıbal değişken üzerinde işlem yapması yukarıda belirtildiği gibi bir senkronizasyon sorununa yol açabilmektedir. 
    Aşağıda bu sorun Lock nesnesiyle giderilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import threading

g_lock = threading.Lock()
g_count = 0

def main():
    thread1 = threading.Thread(target=thread_proc1)       
    thread2 = threading.Thread(target=thread_proc2)       
    
    thread1.start()
    thread2.start()
    
    thread1.join()
    thread2.join()
    
    print(g_count)

def thread_proc1():
    global g_count
    
    for i in range(1000000):
        g_lock.acquire()
        g_count += 1
        g_lock.release()

def thread_proc2():
    global g_count
    
    for i in range(1000000):
        g_lock.acquire()
        g_count += 1
        g_lock.release()

main()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyonun ya da metodun "thread güvenli (thread safe)" olması demek bu fonksiyonun ya da metodun aynı anda birden fazla 
    thread tarafından çağrılması durumunda bir sorunun oluşmaması demektir. Global değişkenleri kullanmayan ve ortak kaynakları kullanmayan 
    fonksiyonlar ve meotlar genel olarak thread güvenlidir. Ancak Python programcısı olarak çok thread'li uygulamalar yaparken kullandığınız 
    kütüphanelerdeki fonksiyonların ve metotların thread güvenli olup olmadığı konusunda bilgi sahibi olmalısınız. Pekiyi foo gibi fonksiyon 
    thread güvenli değilse ancak biz birden fazla thread'ten bu fonksiyonu çağırmak istiyorsak ne olacaktır? Bu durumda programcının kendisi her 
    thread'te bu fonnksiyonu çağırırken lock işlemi yapmalıdır. Örneğin:

    lock.acquire()
    foo()
    lock.release()
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Python'un list gibi, dict gibi, set gibi mutable sınıfları thread güvenli bir biçimde oluşturulmuştur. Yani örneğin iki thread 
    aynı listeye append yaptığında herhangi bir bozulma söz konusu olmaz. Zaten bu sınıflar yazılırken bu durum dikkate alınıp 
    lock senkronizasyonları bunların içerisinde uygulanmıştır. Aşağıdaki programda iki thread aynı global listeye append ile 
    ekleme yapmaktadır. Eğer list sınıfı thread güvenli olmasaydı hemen program çökerdi. Ancak thread güvenli olduğu için 
    program sorunsuz çalışacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

import threading

g_a = []

def main():
    lock = threading.Lock()

    thread1 = threading.Thread(target=thread_proc1, args=(lock,))
    thread2 = threading.Thread(target=thread_proc2, args=(lock,))
    
    thread1.start()
    thread2.start()
    
    thread1.join()
    thread2.join()
    
    print(len(g_a))
     
def thread_proc1(lock):
    for i in range(1000000):
        g_a.append(i)
    
def thread_proc2(lock):
    for i in range(1000000):
        g_a.append(i)
        
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Event senkronizasyon nesneleri belli bir olay gerçekleşene kadar bir thread'i blokede bekletmek için kullanılmaktadır. 
    Nesnenin kullanım şöyledir:

    1) Global düzeyde bir Event nesnesi yaratılır. (Ya da yerel düzeyde yaratılıp thread'lere parametre olarak da geçirilebilir.)
    2) Bekleyecek thread event nesnesinin wait metoduyla beklemeyi yapar. Bu metoda zaman aşımı parametresi (saniye cinsinde) verilebilir. 
    3) Bekleyen thread'i bekleme durumundan çıkartmak için başka bir thread event nesnesi ile sınıfın set metodunu çağırır. 

    Kilit set metodu ile açıldıktan sonra artık wait işlemleri blokeye yol açmaz. Kilidi yeniden kapamak için clear metodu kullanılmalıdır. 
    Tabii diüer thread set işlemini daha önce yapmışsa wait işlemini yapan thread artık beklememektedir. 

    Event senkronizasyon nesneleri tipik olarak iki thread birlikte bir şeyi yaparken birisinin diğerinin bir işlemi bitirmesini 
    beklmesi için kullanılmaktadır. Aşağıda böyle bir örnek verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import threading
import time

g_event = threading.Event()

def main():

    thread1 = threading.Thread(target=thread_proc1)
    thread2 = threading.Thread(target=thread_proc2)
    
    thread1.start()
    thread2.start()
    
    thread1.join()
    thread2.join()
    
def thread_proc1():       
    print('thread-1 waiting for thread2...')
    g_event.wait()
    print('thread-1 continues...')
    
def thread_proc2():
    for i in range(10):
        print('thread-2 running...')
        if i == 5:
            g_event.set()        
        time.sleep(1)

main()

#------------------------------------------------------------------------------------------------------------------------------------
    Semaphore'lar pek çok işletim sisteminde ve framework'te bulundurulan temel senkronizasyon nesnelerinden biridir. Semaphore'lar 
    sayaçlı senkronizasyon nesneleridir. Bir kritik koda en fazla n tane thread akışının girmesini sağlamak kullanılmaktadır. 
    (Biz kritik kod tanımını "başından sonuna kadar tek bir thread akışı tarafından çalıştırılması gereken kodlar" biçiminde yapmıştık. 
    Ancak bu bağlamda da kritik kod terimi kullanılabilmektedir.)
    
    Kullanımı şöyledir:

    1) Global düzeyde bir Semaphore nesnesi yaratılır. (Ya da yerel düzeyde yaratılıp thread'lere parametre olarak da geçirilebilir.)
    Bu noktada semaphoer sayacı belirtilmektedir. Örneğin:

    g_sem = threading.Semaphore(3) 

    2) Kritik kod sınıfın acquire ve release metotları arasında oluşturulmaktadır:

    sem = threading.Semaphore(3)
    ...

    sem.acquire()
    ...
    ...     <KRİTİK KOD>
    ...
    sem.release()

    3) Bir thread akışı acquire netoduna geldiğinde eğer semaphore sayacı sıfırdan büyükse geçiş yapılır ama semaphore sayacı 
    1 eksiltilir. Eğer semaphore sayacı 0 ise acquire metodu thread'i blokede bekletir. Ta ki semaphore sayacı 0'dan büyük olana kadar.
    relese metodu ise semaphore sayacını 1 artırmaktadır. Böylece kritik koda en fazla belirlenen sayıda thread girebilir. Örneğin:

    sem.acquire()
    ...
    ...     <KRİTİK KOD>
    ...
    sem.release()

    Burada başlangıçtaki semaphore sayacının 3 olduğunu varsayalım. Bir thread acquire metoduna gelmiş olsun. Semaphore sayacı 0'dan 
    büyük olduğu için thread bloke olmadan kritik koda girecektir. Ancak semaphore sayacı 1 eksiltilecektir. Başka bir thread de yine
    acquire metodundan geçecektir. Böylece semapore sayacı 1'e düşecektir. Başka bir thread daha acquire metodundan geçecektir. Artık 
    kritik kodda ü threda vardır ve semaphore sayacı 0'a düşmüştür. Artık başka bir threda acquire metoduna geldiğinde blokede bekleyecektir. 
    Ta ki semaphore sayacı 0'dan büyük olana kadar. Eğer kritik koddaki thread'lerden biri release metodunu çağırırsa semaphore sayacı 1 
    artırılır. Artık semaphore sayacı 0'dan büyük olduğu için bekleyen thread kritik koda girebilir. Tabii yine semaphore sayacı 0'a düşecektir. 

    Semaphore sayacı 1 olan semaphore'lara "binary semaphore'lar" denilmektedir. Binary semaphore'lar kullanım bakımından 
    Lock nesnelerine benzemektedir. Ancak Lock nesneleri ile binary Semaphore nesneleri arasında yine de bir fark vardır: 
    Lock nesnelerinde kilit ancak kilidi alan thread tarafından açılabilir. Halbuki Semaphore'larda kilit başka bir thread 
    tarafından release metodu uygulandığında açılabilmektedir Bu özellik de "üretici tüketici problemi" benzeri problemlerin 
    çözümünde kullanılmaktadır. 

    Pekiyi semaphore nesnelerine nedne gereksinim duyulmaktadır? İşte semaphore nesneleri tipik olarak "kaynak paylaştırmak" amacıyla
    kullanılmaktadır. Örneğin elimizde üç tane yazıcı olsun. Biz bu üç yazıcıyı 10 tane thread'in kullanımına sunalım. Bir thread yazıcıyı
    talep ettiğinde ona bu üç yazıcıdan birini tahsis edebiliriz. Diğer bir thread de yazıcıyı talep ettiğinde ona da bir yazıcı tahsis edebiliriz. 
    Başka bir threda yazıcıyı talep ederse ona da kalan son yazıcıyı tahsis ederiz. Artık elimizde yazıcı kalmamıştır. Bu durumda yazıcı talep eden 
    thread'lerin CPU zamanı harcamadna uykuda bekletilmesi gerekir. Ta ki thread'lerden biri yazıcı ile işini bitirene kadar.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Daha önce yapmış olduğumuz makine simülasyonunu bu kez binary semaphore ile yapalım.
#------------------------------------------------------------------------------------------------------------------------------------

import time
import random
import threading

def main():
    sem = threading.Semaphore(1)
    
    thread1 = threading.Thread(target=thread_proc1, args=(sem, ))
    thread2 = threading.Thread(target=thread_proc2, args=(sem, ))
    
    thread1.start()
    thread2.start()
    
def thread_proc1(sem):
    for _ in range(10):
        run_machine('thread1', sem)
        
def thread_proc2(sem):
    for _ in range(10):
        run_machine('thread2', sem)

def run_machine(name, sem):
    sem.acquire();
    print(f'{name}: 1. Step')
    time.sleep(random.random())
    print(f'{name}: 2. Step')
    time.sleep(random.random())
    print(f'{name}: 3. Step')
    time.sleep(random.random())
    print(f'{name}: 4. Step')
    time.sleep(random.random())
    print(f'{name}: 5. Step')
    time.sleep(random.random())
    print('-------------------------------')
    sem.release()
    
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de Semaphore kullanarak kaynak paylaştırma örneği verelim. Elimizde 3 tane (NPRINTERS) yazıcı olsun. Ancak 20 (NTHREADS) 
    thread bu yazıcıları kullanmak için rekabet etsin. Biz bu yazıcıları bir liste içerisinde (g_printers) toplayalım. Thread'ler istedikçe
    bu listeden pop ile onları alıp thread'lere verelim. Therad'ler yazıcıyı kullandıktan sonra onalrı yeniden bu listeye ekleyelim. 
    Böylece bu liste boşta olan yazıcıları tutyor olsun. Toplam 3 yazıcı olduğuna göre ve bizden 20 threda yazıcı talep edeceğine göre 
    elimizde yazıcı kalmayınca diğer thread'leri uykuda bekletmeliyiz. 
#------------------------------------------------------------------------------------------------------------------------------------

import time
import random
import threading

NTHREADS = 20
NPRINTERS = 3

class Printer:
    def __init__(self, number):
        self.number = number
        
    def use(self, name):
        print(f'{name} using printer {self.number}')
        
    def release(self, name):
        print(f'{name} releasing printer {self.number}')

g_sem = threading.Semaphore(NPRINTERS)
g_printers = [Printer(i) for i in range(1, NPRINTERS + 1)]

def main():
    threads = []
    for i in range(NTHREADS):
        thread = threading.Thread(target=thread_proc, args=(f'thread-{i + 1}', ))
        threads.append(thread)
        thread.start()
        
    for thread in threads:
        thread.join()
        
def thread_proc(name):
    for _ in range(3):
        time.sleep(1/random.randint(3, 10))        
        
        print(f'{name} is waiting to get the printer')
        g_sem.acquire()
        
        printer = g_printers.pop(0)
        
        printer.use(name)
        
        time.sleep(1/random.randint(3, 10))        
        
        printer.release(name)
        g_printers.append(printer)
        
        g_sem.release()
        
main()

#------------------------------------------------------------------------------------------------------------------------------------
                                                57. Ders 19/07/2023 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Üretici tüketici problemi (producer-consumer problem) gerçek hayatta en çok karşılaşılan senkronizasyon problemlerinden biridir. 
    Bu problemde bir thread döngü içeisinde bir değer elde eder. Diğer thread bir döngü içerisinde bunu alarak işler. Eğer üretici 
    thred tüketici thread'ten hızlı davranırsa tüketici thread eski bilgiyi almadan üretici thread paylaşılan alana yeni bir bilgi 
    yerleştirerek eski bilgiyi ezebilir. Benzer biçimde tüketici thread de üretici thread'ten hızlı davranırsa üretici thread yeni 
    bir bilgiyi paylaşılan alana koymadan eski bilgiyi yeniden paylaşılan alandan alabilir. Problemde bu durumun engellenmesi gerekir. 
    Yani üretici thread tüketici thread eski bilgiyi almadan paylaşılan alana yeni bilgiyi yerleştirmemeli, tüketi thread de üretici 
    thread yeni bilgiyi almdan eski bilgiyi yeniden almamalıdırç 

    Aşağıdaki örnekte üretici thread 0'dan 100'e kadar (100 dahil değil) değerleri rastgele beklemelerle paylaşılan alana (global değişkene)
    yerleştirmiş, türketici bunları oradan alarak rastgele beklemelerle işlemiş gibi yapmıştır. Bu yukarıda açıkladığımız üretici-tüketici
    problemi için bir simülasyondur. Programın bir çalışmasında tüketicinin aldığı değerler şöyledir:

    None None None 1 1 2 3 3 3 3 4 4 6 7 8 10 10 10 14 15 15 15 17 17 19 19 20 21 23 24 25 27 29 31 32 32 33 34 35 36 37 38 40 40 42 
    43 43 45 45 46 47 49 49 49 50 50 52 53 54 56 60 60 60 62 63 67 68 69 69 71 74 75 75 76 76 76 77 81 81 83 83 84 84 85 88 90 92 92 
    93 95 96 96 97 99 

    Buradan görüldüğü gibi tüketici hem bazı değerleri kaçırmış hem de bazı değerleri birden fazla kez almıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

import random
import time
import threading

g_shared = None

def main():
    producer = threading.Thread(target=producer_thread_proc)
    consumer = threading.Thread(target=consumer_thread_proc)
    
    producer.start()
    consumer.start()
    
    producer.join()
    consumer.join()
            
def producer_thread_proc():
    global g_shared
    
    i = 0
    while True:
        time.sleep(random.random() / 2)
        g_shared = i
        if i == 99:
            break
        i += 1
    
def consumer_thread_proc():
    while True:
        val = g_shared
        time.sleep(random.random() / 2)
        print(val, end = ' ')
        if val == 99:
            break
    print()
              
main()
   
#------------------------------------------------------------------------------------------------------------------------------------
    Üretici-Tüketici problemi tipik olarak semaphore nesneleriyle çzöülmektedir. Üretici ve tüketici için iki ayrı 
    semaphore nesnesi yaratılır. Başlangıçta üretici semaphore'unun değeri 1 olarak, tüketici semaphore'unun değeri ise 0 olarak 
    ayarlanır. Üretici paylaşılan alana bilgi yerleştirince tüketici semaphore'unu tüketici de bilgiyi paylaşılan alanadan alınca 
    üretici semaphore'unu artırır. Problemin çözümünün "sembolik kodu (pseudo code)" şöyledir:

    g_sem_producer = threading.Semaphore(1)
    g_sem_consumer = threading.Semaphore(0)

    ÜRETİCİ

    while True:
        <bilgiyi elde et>
        g_sem_producer.acquire()
        <bilgiyi paylaşılan alaa yerleştir>
        g_sem_consumer.release()

    TÜKETİCİ

    while True:
        g_sem_consumer.acquire()
        <bilgiyi paylaşılan alandan al>
        g_sem_producer.release()
        <bilgiyi kullan>
    
    Burada üreticinin tüketiciyi tüketicinin de üreticiyi blokeden kurtardığına dikkat ediniz. Adeta bir tahteravalli gibi işlemler 
    yürütülmektedir. 

    Yuukarıdaki problem aşağıdaki gibi çözülebilir. 
#------------------------------------------------------------------------------------------------------------------------------------
import random
import time
import threading

g_sem_producer = threading.Semaphore(1)
g_sem_consumer = threading.Semaphore(0)
g_shared = None

def main():
    producer = threading.Thread(target=producer_thread_proc)
    consumer = threading.Thread(target=consumer_thread_proc)
    
    producer.start()
    consumer.start()
    
    producer.join()
    consumer.join()
            
def producer_thread_proc():
    global g_shared
    
    i = 0
    while True:
        time.sleep(random.random() / 2)
        g_sem_producer.acquire()
        g_shared = i
        g_sem_consumer.release()
        if i == 99:
            break
        i += 1
    
def consumer_thread_proc():
    while True:
        g_sem_consumer.acquire()
        val = g_shared
        g_sem_producer.release()
        time.sleep(random.random() / 2)
        print(val, end = ' ')
        if val == 99:
            break
    print()
              
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi üretici-tüketici problemi ile uğraşmaya ne gerek vardır? Neden tek bir thread değeri elde ettikten sonra kendisi işlemeyip başka bir 
    thread'in işlemesi için paylaşılan alana yazmaktadır? Bu işlemin temel amacı hız kazancı sağlamaktır. Bu sayede bir thread yeni bir değeri
    elde ederken diğeri eş zamanlı biçimde onu işleyebilir ve böylece işlemler çok daha hızlı gerçekleştirilebilir. Tabii CPyton dağıtımında
    GIL yüzünden birden fazla CPU ya da çekirdek aynı programın farklı thread'lerini eş zamanlı biçimde çalıştıramamaktadır. Bu durumda 
    hız kazancı umulduğu kadar olmayacaktır. Ancak diğer bazı Python gerçekleiştirimlerinde GIL biçiminde bir problem yoktur.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Üretici-Tüketici probleminde paylaşılan alan tek elemanlık değil birden fazla elamanı içerecek bir kuyruk sistemi olursa toplam 
    bekleme miktarı azaltılır. Çünkü bu durumda üretici thread yalnızca kuyruk doluyken, tüketici thread ise yalnızca kuyruk boşken 
    bekleyecektir.

    Aşağıdaki örnekte liste kullanılarak bir kuyruk sistemi oluşturulmuştur. Bu örnekte üretici semaphore sayacının başlangıçta 1 değerine değil 
    kuyruk uzunluğu değerine kurulduğuna dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------------------

import random
import time
import threading

QUEUE_SIZE = 10

g_sem_producer = threading.Semaphore(QUEUE_SIZE)
g_sem_consumer = threading.Semaphore(0)

g_queue = [None] * QUEUE_SIZE
g_head = 0
g_tail = 0


def main():
    producer = threading.Thread(target=producer_thread_proc)
    consumer = threading.Thread(target=consumer_thread_proc)
    
    producer.start()
    consumer.start()
    
    producer.join()
    consumer.join()
            
def producer_thread_proc():
    global g_tail
    
    i = 0
    while True:
        time.sleep(random.random() / 2)
        g_sem_producer.acquire()
        g_queue[g_tail] = i
        g_tail += 1
        g_tail %= QUEUE_SIZE
        g_sem_consumer.release()
        if i == 99:
            break
        i += 1
    
def consumer_thread_proc():
    global g_head
    
    while True:
        g_sem_consumer.acquire()
        val = g_queue[g_head]
        g_head += 1
        g_head %= QUEUE_SIZE
        g_sem_producer.release()
        time.sleep(random.random() / 2)
        print(val, end = ' ', flush=True)
        if val == 99:
            break
    print()
              
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında kuyruklu üretici-tüketici problemi zaten Python Standart Kütüphanesinde hazır bir biçimde bulunmaktadır. queue modelündeki 
    Queue sınıfı bu iş için kullanılmaktadır. Sınıfın kullanımı şöyledir:

    1) queue.Queue sınıfı türünden global bir nesne yaratılır. Nesne yaratılırken kuyruk uzunluğu verilebilir. Eğer kuyruk uzunluğu 
    verilmezse kuyruk bellek yettiği müddetçe otomatik büyütülmektedir. 

    2) Üretici thread Queue sınıfının put metoduyla kuyruğa eleman ekler. Kuyruk doluysa bu metot blokeye yol açmaktadır. Yani sınıf 
    kendi içerisinde zaten semaphore nesnelerini yaratıp onları kullanarak işlemlerini yapmaktadır.

    3) Tüketici thread kuyruktan queue sınıfının get metoduyla eleman alır. Kuyruk boşsa bu metot blokeye yol açmaktadır.

    Yukarıdaki örneğin hazır queue.Queue sınıfı ile gerçekleştirimi aşağıdaki verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import random
import time
import threading
import queue

g_queue = queue.Queue(10)

def main():
    producer = threading.Thread(target=producer_thread_proc)
    consumer = threading.Thread(target=consumer_thread_proc)
    
    producer.start()
    consumer.start()
    
    producer.join()
    consumer.join()
            
def producer_thread_proc():
    global g_tail
    
    i = 0
    while True:
        time.sleep(random.random() / 2)
        g_queue.put(i)
        if i == 99:
            break
        i += 1
    
def consumer_thread_proc():
    global g_head
    
    while True:
        val = g_queue.get()
        time.sleep(random.random() / 2)
        print(val, end = ' ', flush=True)
        if val == 99:
            break
    print()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında queue modülünde yine semaphore nesneleriyle çalışan senkronize LifoQueue ve PriorityQueue isimli iki sınıf da bulunmaktadır. 
    LIFO kuyruk sistemine halk arasında "stack" denilmektedir. Bu kuyruk sisteminde kuyruğa son yerleştirilen eleman ilk alınmaktadır. 
    LIFO kuyruk sistemiyle gerçek hayatta seyrek de olsa karşılaşılmaktadır. Asansöre binme ve inme sırası LIFO sistemini çağrıştırmaktadır. 
    UNDO mekanizması LIFO kuyruk sistemiyle yapılmaktadır. PriorityQueue denilen öncelik temelli kuruk sistemlerine de gerçek yaşamda 
    karşılaşılmaktadır. Bu kuyruk sistemlerinde kuyruğa yerleştirilen elemanlara birer öncelik derecesi verilir. Kuyruktan eleman alınırken 
    alım sırası bu önceliğe göre yapılır. PeiorityQueue sınıfında put metodu ikili bir demet biçiminde aparametre alır. Demetin ilk elemanı 
    öncelik derecesini, ikinci elemanı kuyruğa yerleştirilecek değeri belirtir. get metodu da yine ikili demet vermektedir. Python'daki 
    PriprityQueue sınıfında düşük değer yüksek öncelik belirtmektedir.  
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda LifoQueue sınıfının kullanımına bir örnek verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import queue

lifoq = queue.LifoQueue()

lifoq.put('ali')
lifoq.put('veli')
lifoq.put('selami')
lifoq.put('ayşe')
lifoq.put('fatma')

while not lifoq.empty():
    val = lifoq.get()
    print(val)

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda PriorityQueue sınıfının kullanımına bir örnek verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import queue

pq = queue.PriorityQueue()

pq.put((1, 'ali'))
pq.put((3, 'veli'))
pq.put((2, 'selami'))
pq.put((10, 'ayşe'))
pq.put((8, 'fatma'))

while not pq.empty():
    prio, val = pq.get()
    print(prio, val)

#------------------------------------------------------------------------------------------------------------------------------------
   Program terimi halk arasında "kaynak kod" anlamında ya da "çalıştırılabilen dosyalar" anlamında kullanılmaktadır. işletim sistemleri 
   dünyasında çalışmakta olan programalara "proses" denilmektedir. Bir program çalıştırıldığında işletim sistemi bir proses oluşturur 
   ve programın çalışmasını sürekli izler. Yani programlar işletim sistemlerinin kontrolü altında çalışmaktadır. 
   
   Bir program başka bir programı çalıştırabilir. Bir programın başka bir programı çalıştırması aslında yeni bir prosesin yaratılması 
   eylemidir. 

   CPython dağıtımında GIL problemi olduğu için çok thread'li uygulamalarda thread'ler birden fazla CPU ya da çekirdekte eş zamanlı olarak 
   çalıştırılamamaktadır. Bu da maalesef daha önceden de belirttiğimiz gibi Python'da thread kullanımını önemli ölçüde olumsuz biçimde
   etkilemektedir. Normalde thread'ler yokken bir iş hızlandırma amacıyla birden fazla prosese yaptırılıyordu. Ancak thread'ler bunun için 
   çok daha iyi bir mekanizma sunmuşlardır. Fakat CPyton'daki GIL yüzünden neredeyse çok prosesli uygulamalar çok thread'li uygulamalardan 
   daha yavaş çalışır durumdadır. Özetle aslında diğer dillerde bir işin farklı prosrslere bölünerek yaptırılması farklı thread'lere bölünerek 
   yaptırılmasından çok daha yavaş sonuç vermektedir. Ancak CPython gerçekleştiriminde GIL yüzünden neredeyse tersi durum daha hızlı bir çalışmaya
   yol açmaktadır. 
   
   Diğer dillerde bir işin proseslere yaptırılması ile thread'lere yaptırılması arasındaki performans farklılığının gerekçesi şunlardır:

   1) Thread'ler proseslere göre daha az sistem kaynağı kullanırlar
   2) Thread'lerin yarılması ve yok edilmesi proseslere göre çok daha hızlı yapılmaktadır.
   3) Prosesler biribirinden izole edilmiştir. Onların haberleşmeleri thread'lerin haberleşmelerinden çok daha zordur. 
    
   Ancak yukarıda da belirttiğimiz gibi CPython gerçekletiriminde adeta ters bir durum vardır. Yani çoğu kez bir işin proseslere yaptırılması GIL yüzünden 
   thread'lere yaptırılmasından daha hızlı sonuç vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
   Bir proses yaratmak (yani bir programı çalıştırmak için) için en çok başvurulan yöntem subprocess modülündeki run fnksiyonunu kullanmaktır. 
   run fonksiyonunun temel kullanımı çok basittir. Fonksiyon birinci parametresiyle bizden çalıştırılacak programı ve onun komut satırı 
   argümanlarını dolaşılabilir bir nesne biçiminde alır ve programı çalıştırır. Eğer komut satırı argümanları kullanılmayacaksa birinci 
   parametreye doğrudan çalıştırılacak programın yol ifadesi de girilebilir. Örneğin:

    subprocess.run(r'c:\windows\notepad.exe')
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

subprocess.run(r'c:\windows\notepad.exe')

#------------------------------------------------------------------------------------------------------------------------------------
    Windows sistemlerinde çalıştırılabilen programın yol ifadesinde '\' UNIX/Linux ve Mac OS X sistemlerinde '/' kullanılmazsa
    dosya PATH çevre değişkeni ile belirtilen yerlerde aranır. PATH çevre değişkeni dizinlerden oluşmaktadır. Dolayısıyla biz 
    run fonksiyonunda dosyanın yol ifadesinde Windows sistemlerinde '\' karakterini UNIX/Linux sistemlerinde '/' karakterini hiç 
    kullanmamışsak bu dosya PATH çevre değişkenindeki dizinlerde sırasıyla aranacaktır. Örneğin Windows'ta kurulum sırasında 
    zaten Windows dizini PATH çevre değişkeninde bulunmaktadır. Bu durumda biz "notepad.exe" programını aşağıdaki gibi de çalıştırabilirdik. 

    subprocess.run('notepad.exe')

    Yani başka bir deyişle run fonksiyonu ile bir programı çalıştırmak istediğimizde eğer program PATH dizinlerinin birinin içerisindeyse 
    onun yalnızca ismini belirtebilriz. Ancak program PATH dizinlerinin herhangi birinin içerisinde değilse onun tüm yol ifadesini belirtmeliyiz. 
    Windows sistemlerinde çalıştırılabilen dosyanın uzantısı belirtilmezse zaten otomatik olarak o isimli ".exe" dosyalar aranmaktadır. Örneğin:

    subprocess.run('notepad')
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

subprocess.run('notepad.exe')

#------------------------------------------------------------------------------------------------------------------------------------
    Windows sistemlerinde subprocess.run fonksiyonunda yol ifadesi girildiğinde "Access denied" biçiminde bir error oluşabilmektedir. 
    Bu muhtemelen bir bug'dır. Bu bug'ın arkasından dolaşmak için (work around)  önce yol ifadesinin bulunduğu dizine geçip sonra 
    yol ifadesi olmadan çalıştırılacak program ismi belirtilebilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess
import os

os.chdir(r'C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\Common7\IDE')
subprocess.run(['devenv.exe'])

#------------------------------------------------------------------------------------------------------------------------------------
                                                    58. Ders 24/07/2023 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Eğer çalıştırılacak programa komut satırı argümanları da verilecekse bu durumda run fonksiyonunda program ismi ve argümanları 
    dolaşılabilir bir nesne biçiminde verilmelidir. Örneğin:

    subprocess.run(['notepad.exe', 'sample.py'])                                                     
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

subprocess.run(['notepad.exe', 'sample.py'])


#------------------------------------------------------------------------------------------------------------------------------------
    Bir Python programını çalıştırmak için import işlemi yapılabilir ya da built-in exec fonksiyonundan faydalanılabilir. 
    Ancak bu yöntemlerde çalıştırılan kod farklı proses tarafından çalıştırılmamaktadır. Aynı proses ve hatta aynı thread 
    tarafından çalıştırılmaktadır. Biz bir python programını subprocess.run fonksiyonu ile tıpkı komut satırında çalıştırdığımız gibi 
    başka bir proses yaratarak çalıştırabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

subprocess.run(['python', 'testprog.py'])

#------------------------------------------------------------------------------------------------------------------------------------
    Proses subprocess.run fonksiyonuyla yaratıldığında akış yaratılan alt proses sonlanmadan run fonksiyonundan çıkmaz. 
    run fonksiyonu CompletedProcess isimli bir sınıf türünden nesneyle geri dönmektedir. 

    Aşağıdaki programda Windows'ta "notepad.exe" programı çalıştırılmıştır. Bu "notepad.exe" programı bitmeden kodun aşağıya
    geçmediğine dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

cp = subprocess.run(['notepad.exe'])
print('completed')

#------------------------------------------------------------------------------------------------------------------------------------
    ComplededProcess sınıfının args örnek özniteliği bizim run fonksiyonuna geçtiğimiz birinci parametreyi (yani kprogram ismini 
    ve komut satırı argümanlarını vermektedir.) Sınıfın returncode isimli örnek özniteliği ise çalıştırılan prosesin "exit kodunu" 
    bize verir. Proseslerin bir tamsayı olan exit kodları vardır. Bu exit kodları proses bittiğinde işletim sistemine iletilir. 
    İşletim sistemi de bu exit kodunu prosesi çalıştıran prosese verir. Exit kodları geleneksel olarak başarılı sonlanmalar için 0, 
    başarısız sonlanmalar için sıfır dışı değerler olarak seçilmektedir.

    Aşağıdaki örnekte notepad.exe progrfamı çalıştırılmış, programın çalışması bitince onun exit kodu yazdırılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

cp = subprocess.run(['notepad.exe', 'sample.py'])
print(cp.args)
print(cp.returncode)

#------------------------------------------------------------------------------------------------------------------------------------
    Bildiğiniz gibi Python programlarında akış dosyanın sonuna geldiğinde program sonlanmaktadır. İşte bu durumda default olarak 
    python programımız 0 exit koduyla sonlanmaktadır. Biz bir Python programını herhangi bir fonksiyon içerisinde o noktada da 
    sonlandırabiliriz. Bunun için sys modülündeki exit fonksiyonu kullanılmaktadır. exit fonksiyonun int türden bir parametresi vardır. 
    Bu parametre sonlandırılan prosesin exit kodunu oluşturur. Python programımız ele alınmayan bir exception ile sonlanmışsa
    bu bir başarısızlık durumu olduğu için 1 exit koduyla proses sonladırılmaktadır.

    Aşağıdaki programda proses foo fonksiyonu içerisinde sonlandırılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys

def foo():
    print('foo')
    sys.exit(0)

print('begins...')
foo()
print()
print('ends...')

#------------------------------------------------------------------------------------------------------------------------------------
    Komut satırında son çalıştırılmış olan prgramın exit kodu alınabilir. Windows sistemlerinde bunun için aşağıdaki komutu kullanabilirsiniz:

    echo %errorlevel%

    UNIX/Linux sistemlerinde aynı şey şöyle yapılmaktadır:

    echo $?
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Spyder IDE'sinde sağ taraftaki komut satırı programına "IPython" denilmektedir. Aslında IPython bağımsız bir projedir. Spyder IDE'sine
    de entegre edilmiştir. IPython'ı Spyder olmadan da yükleyip komut satırındna çalıştırabilirsiniz. Yükleme işlemi pip programı ile 
    aşağıdaki gibi yapılabilir:

    pip install ipython
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    IPython komut satırı progranmının pek çok özelliği vardır. Örneğin hiç dışarı çıkmadan ! öneki getirerek kabuk komutlarını IPython
    içerisinden çalıştırabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Modern işletim sistemlerinde ekran, klavye gibi donanım birimleri özel kodlar tarafından kullanılmaktadır. Bir donanım birimini 
    bu biçimde yöneten ve ona iş yaptıran aşağı seviyeli programlara "aygıt sürücü (device driver)" denilmektedir. Aygıt sürücüler 
    birer dosya gibi kullanılırlar. Yani biz aygıt sürücüleri dosya gibi açarız. Aygıt sürücü dosyasına bir şeyler yazdığımızda 
    yazılanlar aslında aygıt sürücüye gönderilir. Aygıt sürücü gereğini yapar. Bencer biçimde biz bir aygıt sürücü dosyasından 
    okuma yaptığımızda aslında aygıt sürücü kendi yönettiği aygıttan okumayı yaparak bize vermektedir. 
    
    Programalamada ekran ve klavye sözcükleri pek kullanılmaz. Ekran yerine "stdout dosyası", klavye yerine ise "stdin dosyası" 
    denilmektedir. Ekran ve klavye birer aygıt sürücü tarafından kontrol edilmektedir. Yani stdout ve stdin aslında aygıt sürücü 
    dosyalarıdır. Biz Python'da print fonksiyonu ile bir şeyler yazdırmak istediğimizde print fonksiyonu yazdırılmak istenen şeyleri 
    stdout dosyasına yani stdout aygıt sürücüsüne gönderir. Onun ekrana çıkartılması bu aygıt sürücünün görevidir. Aynı şey okuma yaparken
    input fonksiyonunda da benzerdir. 

    İşletim sistemlerinde "IO yönlendirmesi (IO Redirection)" denilen bir olgu vardır. IO yönlendirmesi bir dosyaya yazdığını sanan
    kişilerin ya da bir dosyadan okuma yaptığını sanan kişilerin aslında başka dosyalara yazma ve başka dosyalardan okuma yapması durumudur.
    Örneğin print fonksiyonu stdout dosyasına yazma yapar. Default durumda bu stdout dosyası terminal aygıt sürücüsüne yönlendirilmiştir. 
    Ancak biz stdout dosyasını başka bir yere yönlendirirsek ekrana yazdığımız şeyler aslında yönlendirdiğimiz yere yazılacaktır. 
    Örneğin:

    for i in range(100):
        print(i)

    Buradaki Python programı 0'dan 100'e kadar sayıları ekrana yazmamaktadır, stdout dosyasına yazmaktadır. stdout dosyası default durumda
    ekran işlemlerinş yaoan aygıt sürücüye yönlendirilmiş durumdadır. Bu nedenle bu sayılar ekranda gözükecektir. Ancak biz stdout 
    dosyasını başka bir yagıta ya da diskteki başka bir dosyaya yönlendirebiliriz. Bu durmda bu sayılar ekrana değil o kaynağa yazılacaktır. 
    O halde "print fonksiyonu ekrana yazar" cümlesi yanlıştır. Bunun doğrusu "print fonksiyonu stdout dosyasına yazar" biçimindedir. 
    stdout dosyası ise yaönlendirilebilmektedir. Aynı durum stdin dosyası için de benzerdir. 

    Windows ve UNIX/Linux sistemlerinde komut satırında stdout dosyasını bir disk dosyasına yönlendirmek için ">" sembolü kullanılır. 
    Örneğin:

    python sample.py > x.txt

    Burada artık sample.py dosyasının stdout dosyasına yazdıkları "x.txt" dosyasına yazılacaktır. Windows ve UNIX/Linux sistemlerinde 
    stdin dosyasını yönlendirmek için ise "<" sembolü kullanılır. Örneğin:

    python sample.py < numbers.txt

    Burada aslında "sample.py" programında input fonksiyonu stdin dosyasından okuma yapar. stdin dosyası default durumda klavyeyi 
    kontrol eden aygıt sürücüsüne yönlendirilmiş durumdadır. Ancak biz "<" sembolü ile stdin dosyasını "numbers.txt" dosyasına 
    yönlendirmiş olduk. Artık bu dosyadaki şeyleri sanki biz klavyeden girmişiz gibi bir etki oluşacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    subprocess.run fonksiyonunun stdout ve stdin parametreleri bir dosya nesnesi olarak girilirse çalıştırılan programın stdout ve
    stdin dosyaları ilgili dosyaya yönlendirilmiş olur. 
    
    Aşağıdaki programda "sample.exe" programının ekrana (stdout dosyasına) yazdığı şeyler aslında "test.txt" dosyasına yazılacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

with open('test.txt', 'w') as f:
    cp = subprocess.run(['sample.exe'], stdout=f)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Tabii yukarıdaki işlem aslında bir Python programı üzerinde de uygulanabilirdi. 

    Aşağıdaki örnekte biz python yorumlayıcısı ile "mample.py" programını çalıştırıp onun stdout dosyasını "test.txt"
    yönlendiriyoruz. 
#------------------------------------------------------------------------------------------------------------------------------------

# sample.py

import subprocess

with open('test.txt', 'w') as f:
    cp = subprocess.run(['python.exe', 'mample.py'], stdout=f)

# mample.py

for i in range(100):
    print(i)

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi stdin dosyası klavye (terminal) aygıt sürücüsüne başka bir dosyaya yönlendirilmişse stdin dosyasından 
    okuma programlar o dosyadakileri klavyeden girilmiş gibi ele alırlar. Python'daki input fonksiyonu stdin dosyasından okuma yapmaktadır. 

    Aşağıdaki örnekte biz çalıştırdığımız python programının stdin dosyasını test.txt dosyasına yönlendirdik.
#------------------------------------------------------------------------------------------------------------------------------------

# sample.py

import subprocess

with open('test.txt', 'r') as f:
    cp = subprocess.run(['python.exe', 'mample.py'], stdin=f)

# mample.py 

for i in range(10):
    s = input()
    print(s)

# test.txt

10
20
30
40
50
60
70
80
90
100

#------------------------------------------------------------------------------------------------------------------------------------
    Spyder IDE'sinde biz subprocess.run ile bir programı çalıştırdığımızda maalesef o programın stdout dosyasına yazdığı şeyler IPython 
    konsolunda gözükmemektedir. Ancak PyCharm IDE'sinde böyle bir sorun yoktur. Bu nedenle bu tür denemelerin bazılarını IPython'da ! 
    karakteri ile sanki kabuk üzerindeymişsiniz gibi çalıştırabilirsiniz. Ya da denemelerinizi gerçekten kabuk üzerinden yapabilirsiniz.     
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Artık bir bir programı çalıştıran Python programı yazabildiğimize göre IDE benzeri bir program da yazabiliriz. Örneğin bir C IDE'si 
    yazacak olalım. Bu durumda aslında menüden "Compile" seçildiğinde biz C derleyicisini çalıştırarak kodu derleyebiliriz. Sonra 
    IDE'den "Run" seçildiğinde yine biz derlenmiş programı çalıştırabiliriz. 

    Aşağıdaki örnekte Windows'ta "gcc" isimli C derleyicisi ile bir kod derlenip, derlenmiş olan program çalıştırılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

subprocess.run(['gcc.exe', '-o', 'sample.exe', 'sample.c'])
subprocess.run('sample.exe')

#------------------------------------------------------------------------------------------------------------------------------------    
                                            59. Ders 26/07/2023 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Biz daha önce os odlündeki system fonksiyonunu görmüştük. Bu fonksiyonla komut satırından yapabileceğimiz her şeyi yapıyorduk. 
    Pekiyi bir programı çalıştırmak için os.system ile subprocess.run arasında ne farklılık vardır? Örneğin biz "gcc isimli C derleyicisini" çalıştırarak
     ilgili C programını iki biçimde de derleyebiliriz:

     1) subprocess.run fonksiyonunu kullanarak
     
     import subprocess

    subprocess.run(['gcc.exe', '-o', 'sample.exe', 'sample.c'])
    subprocess.run('sample.exe')

    2) os.system fonksiyonunu kullanarak:

    import os

    os.system('gcc.exe -o sample.exe sample.c')

    Bu iki fonksiyon arasındaki farklılıklar şunlardır:

    - os.system aslında kabuk programını çalıştırıp kabuk programınının komutu çalıştırmasını sağlamaktadır. Halbuki subprocess.run
    doğrudan belli bir programı çalıştırmaktadır. Dolayısıyla os.system aslında toplamda program çalıştırmak için daha yavaş bir
    yöntemdir. 
      
    - os.system fonksiyonu ile komut satırında yapabilecğeimiz her şeyi yapabiliriz. Örneğin:

    os.system('ls -l | wc')

    Burada UNIX/Linux sistemlerinde komut satırından uyguladığımız boru işlemini os.system fonksiyonuna yaptırmış olduk.

    - Tabii asıl olan subprocess.run fonksiyonudur. Biz aslında os.system fonksiyonunun yaptığı şeyin aynısını kabuk programını
    çalıştırarak da yapabiliriz. Örneğin UNIX/Linux sistemlerinde os.system fonksiyonu aşağıdakine benzer yazılmıştır:

    import subprocess

    def system(cmd):
        cp = subprocess.run(['/bin/bash', '-c', cmd])
        return cp.returncode

    system('ls -l')
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Kabuk programlarında iki komut türü vardır: İçsel (internal) ve dışsal (external) komutlar. Eğer bir komut doğurdan kabuğun kendisi 
    tarafından çalıştırılıyorsa bu tür komutlara "içsel komutla" denilmektedir. Eğer komut kabuğun kendisi tarafından değil de kabuğun
    çalıştırdığı bir program tarafından çalıştırılıyorsa bu tür komutlara da "dışsal (external)" komutlar denilmektedir. Windows'un
    "cmd.exe" kabuk programında komutların çok büyük kısmı içsel komutlardır. Örneğin Windows'taki "dir" komutu bir program değildir. 
    cmd.exe programının kendisi tarafından yorumlanıp işletilmektedir. UNIX/Linux sistemlerinde ise tam tersine kabuk komutlarının çok 
    büyük çoğunluğu dışsal komutlardır. Örneğin bash kabuğundaki "ls" komutu aslında bir programdır. Bu komut bu programın çalıştırılmasıyla
    yürütülmektedir. 

    Aşağıda içsel ve dışsal komutların ne olduğunu anlamaya yönelik basit bir komut yorumlayıcı örneği verilmiştir. Bu programı UNIX/Linux 
    ve Windows sistemlerinde çalıştırarak deneyiniz.
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

while True:
    cmd = input('CSD>').split()
    if len(cmd) == 0:
        continue
    match cmd:
        case ['xyz', *args]:
            print('internal xyz command')
        case ['exit']:
            break
        case [*args]:
            try:
                subprocess.run(args)
            except:
                print('bad command!')
           
#------------------------------------------------------------------------------------------------------------------------------------
    subprocess.run fonksiyonunda stdout parametresi özel bir değer olan subprocess.PIPE biçiminde geçilirse bu durumda 
    çalıştırdığımız programın stdout dosyasına yazdıklarını biz CompletedeProcess nesnesinin stdout örnek özniteliğinden 
    alabiliriz. Buradaki CompletedProcess sınıfının stdout örnek özniteliği bize bytes nesnesi vermektedir. Biz o bytes nesnesini 
    decode metoduyla ya da string sınıfının encoding parametreli __init__ metoduyla string nesnesine dönüştürebiliriz. 
    Örneğin:
    
    cp = subprocess.run('ls', stdout = subprocess.PIPE)
    s = cp.stdout.decode()
    print(s)

    Benzer biçimde çalıştırdığımız programın stderr dosyasına yazdıklarını biz CompletedProcess sınıfının stderr örnek özniteliğinden
    elde edebiliriz. Genellikle porgramlar hata mesajlarını stderr dosyasına yazdırırlar. Örneğin biz "gcc" isimli C derleyicisini 
    çalıştırıp eğer bir hata varsa hata yazısını bu yöntemle elde edebiliriz. Bir IDE yazarken derleyici ya da yorunlayıcının 
    hata mesajlarının alınp pencere içerisine basılması bu biçimde sağlanmaktadır. Örneğin:

    import subprocess

    cp = subprocess.run(['gcc', '-o', 'sample', 'sample.c'], stdout = subprocess.PIPE, stderr=subprocess.PIPE)
    stderr_result = cp.stderr.decode()

    print(stderr_result)

    Aağıdaki programda "sample.py" programı "mample.py" programını çalıştırmıştır. Ancak o programın ekrana yazdıklarını 
    alıp kendi ekranına yazdırmıştır. Örneğin IDE'ler aslında buradaki işlemin bir benzerini yapmaktadır. Biz bir Python 
    IDE'sinde programı çalıştır dediğimizde IDE python yorumlayıcısını çalıştırır ancak onun stdout dosyasına yazdıklarını 
    kendi alarak kendi penceresinde gösterir.
#------------------------------------------------------------------------------------------------------------------------------------

# sample.py

import subprocess

cp = subprocess.run(['python', 'mample.py'], stdout=subprocess.PIPE)
s = cp.stdout.decode()
print(s)

# mample.py

for i in range(10):
    print(i)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Aslında subprocess.run fonksiyonu subprocess.Popen isimli bir sınıf nesnesini kullanmaktadır. Yani prosesi çalıştıran asıl
    işlevsellik bu Popen sınıfındadır. Başka bir deyişle aslında subprocess.run bir "sarma (wrapper)" fonksiyondur. 
    subprocess.Popen sınıfının işlevselliği daha fazla olduğu için ayrıntılı işlemlerde subprocess.run yerine bu sınıfın kullanılması 
    tercih edilebilir. Sınıfın temel kullanımı zaten benzedir. 

    Aşağıdaki örnekte subprocess.Poğpen sınıfı kullanılmıştır. Sınıf nesnesi yaratılır yaratılmaz hemen proses çalıştırılır. 
    Ancak Popen sınıfı bu anlamda blokeye yol açmaz. Aşağıdaki örnekte hem programın çalıştırıldığına hem de akışın devam ettiğine 
    dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

popen = subprocess.Popen(['Notepad.exe'])
print('Ok')

#------------------------------------------------------------------------------------------------------------------------------------
    Çalıştırılan proses bitene kadar blokede bekleme yapılmak isteniyorsa Popen sınıfının wait metody kullanılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

p = subprocess.Popen(['Notepad.exe'])
p.wait()
print('Ok')

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında IO yönlendirmeleri subprocess.run yerine doğrudan subprocess.Popen sınıfı kullanılarak daha yeterli düzeyde 
    yapılabilir. Örneğin bu sınıfta stdout parametresi subprocess.PIPE geçilirse Popen sınıfının stdout örnek özniteliği bir
    dosya nesnesi olur. Biz bu dosyadan okuma yaptığımızda aslında çalıştırdığımız prosesin ekrana yazdırdıklarını okumuş oluruz.    
#------------------------------------------------------------------------------------------------------------------------------------

# sample.py 

import subprocess

p = subprocess.Popen(['python.exe', 'mample.py'], stdout=subprocess.PIPE)

s = p.stdout.read().decode()
print(s)

# mample.py 

for i in range(10):
    print(i)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Biz Popen nesnesinin stdout örnek özniteliği ile dosyadan okuma yapmak istediğimizde eğer çalıştırılan proses stdout 
    dosyasına bizim okumak istediğimiz kadar bilgiyi henüz yazmamışsa biz blokede bekleriz. Çünkü boru işlemleri 
    default olarak blokeli işlemlerdir.  

    Aşağıdaki örnekte "sample.py" programı yine "mample.py" programını çalıştırmıştır. "mample.py" programı birer saniye
    bekleyerek stdout dosyasına sayıları yazdırmaktadır. "sample.py" programı eğer p.stdout.read() ile okuma yapsaydı dosya sonuna
    gelene kadar bloke oluşacaktı. Çünkü dosya sonuna gelmek borularda ancak diğer prosesin sonlanmasıyla mümkündür.
    Halbuki burada birer satırlık bilgi okunmuştur. while döngüsündeki not p.poll() işlemi proses sonlanmayana kadar 
    döngüyü devamettirmektedir.  
#------------------------------------------------------------------------------------------------------------------------------------

# sample.py

import subprocess

p = subprocess.Popen(['python.exe', 'mample.py'], stdout=subprocess.PIPE)

while not p.poll():
    s = p.stdout.readline().decode()
    print(s)    

# mample.py

import time

for i in range(10):    
    print(i, flush=True)
    time.sleep(1)

#------------------------------------------------------------------------------------------------------------------------------------
    Normal olarak bir işin birden fazla thread tarafından yapılması hız kazancı sağlar. Ancak CPython gerçekleştirimindeki
    GIL yüzünden çok thread'li çalışma umulduğu kadar hız kazancı sağlamamaktadır. Bir işin farklı thread'ler yaratılarak değil farklı 
    prosesler yaratılarak yapılması alternatif bir yöntemdir. C, C++, Java, C# gibi programlama dillerinde multithreading çözümler 
    multiprocess çözümlere göre çok daha etkindir. Ancak GIL yüzünden CPython gerçekleştiriminde multiprocess çalışma çoğu zaman 
    multithreading çalışmadan daha hızlı olmaktadır. 

    Python'da multiprocess çalışma demekle birden fazla biribirinden bağımsız python yorumlayıcısının ayrı programlar olarak 
    çalıştırılması kastedilmektedir. Daha önceden değindiğimiz gibi nomral olarak multiporocess çalışmanın muştithreading çalışmaya
    göre şu dezavantajları vardır:

    - Prosesler thread'lere göre sistem genelinde daha fazla kaynağın kullanılmasına yol açmaktadır.
    - Proseslerin yaratılması ve yok edilmesi thread'lerin yaratılması ve yok edilmesine göre daha yavaştır. 
    - Thread'ler aynı adres alanı içerisinde çalıştığından dolayı thread'lerin haberleşmesi çok daha kolaydır. Halbuki prosesler 
    pek çok sistemde biribirinden izole edilmiştir. Dolayısıyla proseslerarası haberleşme thread'lerarası haberleşmeden çok daha yavaştır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Standart kütüphanedeki multiprocessing modülünde bulunan Process sınıfı genel kullanım itibari ile threading modülündeki Thread 
    sınıfına benzemektedir. Programcı Process sınıfı türünden bir nesne yaratır. Nesneyi yaratırken yine yeni proses akışının başlatılacağı 
    fonksiyonu target parametresiyle belirtir. Yine args parametresi ile parametre aktarımı yapılır. Proses nesnesine yine bir name 
    parametresi ile isim verilebilir. Prosesi çalıştırmak için yine start metodu, sonlanmasını beklemek için join metodu kullanılmaktadır. 
    join metodu alt processin kaynaklarını da boşaltmaktadır. Yani join metodu çağrıldığında üst proses alt proses eğer sonlanmamışsa sonlana 
    kadar bekler ve onun kaynaklarını boşaltır. Bir alt proses yaratılıp join ile beklenmezse bu tür durumlara UNIX/Linux dünyasında 
    "hortlak proses (zombie process)" denilmektedir. Ancak bazen bir alt proses yaratılıp  onun sonlanmasını beklemek istemeyebiliriz. Bu tür durumlarda
    proses yaratılırken beklemenin yapılmayacağı belirtilmelidir. Bunu Python'da sağlamanın iki yolu vardır. Birinci process sınıfında proses 
    yaratılırken daemon parametresini True geçmektir. İkincisi proses yaratıldıktan sonra daemon örnek özniteliğine False yerleştirmektir. 
        
    Görüldüğü gibi genel çalışma biçimi daha önce görmüş olduğumuz thread'lere benzemektedir. 

    Ancak burada target parametresi ile belirtilen fonksiyonun başka bir Python yorumlayıcısı tarafından tamamen başka bir proses gibi çalıştırıldığına
    dikkat ediniz. Process sınıfı ile işlemler yapılırken __name__ == '__main__' kontrolünün bazı nedenlerden dolayı yapılması gerekmektedir. 
    Biz burada neden programın başlatılacağı yerde bu kontrolün yapılması gerektiğini açıklamayacağız. 
#------------------------------------------------------------------------------------------------------------------------------------

import time
import multiprocessing

def foo(n):
    for i in range(n):
        print(f'Other process: {i}')
        time.sleep(1)

if __name__ == '__main__':
    process = multiprocessing.Process(target=foo, args=(10, ))
    process.start()
    
    for i in range(10):
        print(f'Parent process: {i}')
        time.sleep(1)

#------------------------------------------------------------------------------------------------------------------------------------
    Daha önce CPython'da 1 milyarlık bir döngüyü tek bir thread'le ve 250 milyonluk dört ayrı thread'le dönen bir test
    programı yazmıştık. O programda her iki test de biribirine yakın sonuç vermişti. Aşağıdaki örnekte 1 milyarlık döngü hem tek bir thread'le, 
    hem dört prosesle hem de dört thread'le döndürülmüş ve sonuçlar ekrana (stdout dosyasına) yazdıırlmıştır. Şu sonuçlar elde edilmiştir:

    Singlethreding: 13.071293354034424
    Multiprocessing: 3.864476442337036
    Multithreading: 13.19014859199524
#------------------------------------------------------------------------------------------------------------------------------------

import threading
import multiprocessing as mp
import time

def proc1():
    for i in range(250_000_000):
        pass

def proc2():
    for i in range(250_000_000):
        pass
    
def proc3():
    for i in range(250_000_000):
        pass

def proc4():
    for i in range(250_000_000):
        pass

def test1(): 
    t1 = time.time()
    for i in range(1_000_000_000):
        pass
    t2 = time.time()
    print(f'Singlethreading: {t2 - t1}')
           
def test2():
    t1 = time.time()
    
    process1 = mp.Process(target=proc1)
    process2 = mp.Process(target=proc2)
    process3 = mp.Process(target=proc3)
    process4 = mp.Process(target=proc4)
    
    process1.start()
    process2.start()
    process3.start()
    process4.start()
    
    process1.join()
    process2.join()
    process3.join()
    process4.join()
    
    t2 = time.time()

    print(f'Multiprocessing: {t2 - t1}')
    
def test3():
    t1 = time.time()
    
    thread1 = threading.Thread(target=proc1)
    thread2 = threading.Thread(target=proc2)
    thread3 = threading.Thread(target=proc3)
    thread4 = threading.Thread(target=proc4)
    
    thread1.start()
    thread2.start()
    thread3.start()
    thread4.start()
    
    thread1.join()
    thread2.join()
    thread3.join()
    thread4.join()
    
    t2 = time.time()

    print(f'Multithreading: {t2 - t1}')
    
if __name__ == '__main__':
    test1()
    test2()
    test3()
    
#------------------------------------------------------------------------------------------------------------------------------------
    Thread'lerin haberleşmesi global nesneler yoluyla yapılabilmektedir. Yani bir thread bir global değişkene bir değer yazdığında 
    diğeri onu görebilir. Gerçi bu tür uygulamalarda senkronizasyon da bir problemdir. Ancak haberleşme kısmı thread'lerde global 
    nesneler yoluyla yapılabilmektedir. 

    Aşağıdaki örnekte ana thread bir thread yaratıp bir global değişkeni set etmiştir. Yaratılan thread de aynı global değişkeni 
    görebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import threading
import time

val = 0

def thread_proc():
    time.sleep(1)
    print(val)              # 100
    
thread = threading.Thread(target=thread_proc)
thread.start()
val = 100
thread.join()

#------------------------------------------------------------------------------------------------------------------------------------
    Prosesler ayrı bellek alanlarına sahiptir. Biz multiprocessing.Process sınıfında target parametresiyle proses akışının 
    hangi fonksiyondan başlatılacağını vermekteyiz. Ancak bu fonksiyon başka bir proses tarafından çalıştırılmaktadır. Dolayısıyla 
    aslında global nesneler farklı proseslerin farklı global nesneleri olur. Yukarıdaki örnek proseslerle yapıldığında üst proses
    val değişkenini set ettiğinde alt proses bunu görmeyecektir. Çünkü aslında bu iki prosesin val değişkenleri kendilerine özgü ayrı değişkenlerdir. 
    Bu nedenle prosesleri haberleştirmek için "Queue" gibi "Pipe" gibi "Shared Memory" gibi özel yöntemler kullanılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import multiprocessing
import time

val = 0

def proc():
    time.sleep(1)
    print(val)                  # 0

if __name__ == '__main__'    :
    process= multiprocessing.Process(target=proc)
    process.start()
    val = 100
    process.join()

#------------------------------------------------------------------------------------------------------------------------------------
    Proseslerarası haberleşme threadlerarası haberleşmeden daha maliyetlidir. Proseslerarası haberleşme için multiprocessing
    modülünde çeşitli sınıflar bulundurulmuştur. multiprocessing.Queue sınıfının kullanımı daha önce thread'ler konusunda üretici-tüketici 
    problemi için kullandığımız queue modülündeki Queue sınıfına çok benzemektedir. queue modülündeki Queue sınıfı thread'ler arası 
    bir haberleşme için kullanılırken multiprocessing modülündeki Queue sınıfı proseslerarası haberleşme için kullanılmaktadır.

    Proseslerle üretici-tüketici problemi için aşağıdaki gibi bir örnek verilebilir.
#------------------------------------------------------------------------------------------------------------------------------------

import multiprocessing as mp
import time
import random

def consumer_proc(q):
    while True:
        val = q.get()
        time.sleep(random.random() / 2)
        print(f'{val}', end=' ', flush=True)
        if val == 99:
            break

if __name__ == '__main__':
    q = mp.Queue()            
    cp = mp.Process(target=consumer_proc, args=(q, ))
    cp.start()
    
    i = 0
    while True:
        time.sleep(random.random() / 2)
        q.put(i)
        if i == 99:
            break
        i += 1

    cp.join()
        
#------------------------------------------------------------------------------------------------------------------------------------
    Gerek thread'lerde kullandığımız queue.Queue sınıfı gerekse prosesler için kullandığımız multiprocessing.Queue sınıfı birden fazla 
    tüketici ile çalışabilmektedir. 

    Aşağıdaki örnekte üretici-tüketici problemi iki tane tüketici ile çözülmüştür.Tüketici birden fazla olduğu zaman işlemin ne zaman 
    bitecğini belirlemek ve tüketicileri döngüden çıkartmak ayrı bir sorun olabilir. Çünkü kuyruktaki değere göre prosesler döngüyü 
    sonlandıracaksa bu değer iki tüketici tarafından da alınamamaktadır. Yani tüketicilerden yalnızca biri bu değeir alabilecek ve 
    döngüen çıkabilecektir. Bu tür problemlerin çözümleri için ilave senkronizasyon nesnelerinin (koşul değişkenleri gibi) kullanılması 
    gerekebilir. Aşağıdaki örnekte bu problem ana prosesin işlem bittikten sonra diğer prosesleri kill metoduyla yok etmesiyle sağlanmıştır. 
    Aslında bu sağlam bir çözüm değildir. 
#------------------------------------------------------------------------------------------------------------------------------------

import multiprocessing as mp
import time
import random

def consumer_proc1(q):
    while True:
        val = q.get()
        time.sleep(random.random() / 2)
        print(f'consumer1 ---> {val}')
        if val == 99:
            break

def consumer_proc2(q):
    while True:
        val = q.get()
        time.sleep(random.random() / 2)
        print(f'consumer2 ---> {val}')
        if val == 99:
            break

if __name__ == '__main__':
    q = mp.Queue()            
    cp1 = mp.Process(target=consumer_proc1, args=(q, ))
    cp2 = mp.Process(target=consumer_proc2, args=(q, ))
    
    cp1.start()
    cp2.start()
    
    i = 0
    while True:
        time.sleep(random.random() / 2)
        q.put(i)
        if i == 99:
            break
        i += 1
        
    time.sleep(1)
    cp1.kill()
    cp1.kill()

#------------------------------------------------------------------------------------------------------------------------------------
                                                60. Ders 31/07/2023 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Proseslerarasında haberleşme için diğer bir yöntem de "boru (pipe) haberleşmesi" denilen yöntemdir. Boru haberleşmesi yöntemi multiprocessing 
    modülündeki Pipe isimli sınıf yoluyla uygulanmaktadır. Aslında Pipe kullanımı ile Queue kullanımı ana hatlarıyla biribirine benzemektedir.
    Ancak Queue birden fazla üretici-tüketici prosesler arasında kullanılabilirken Pipe nesneleri iki proses arasında kullanılmaktadır. 
    Genel olarak Pipe kullanımı iki proses arasında haberleşme yapılıyorsa Queue kullanımından daha hızlıdır. Pipe kullanımı şöyledir:

    1) Pipe sınıfı türünden bir nesne yaratılır. Bu nesne bir demet biçiminde iki Conenction nesnesi verir. Borular tek yönlü (unidirectional) 
    ya da çift yönlü (bidiectional) olabilmektedir. Default durumda yaratılan borular çift yönlüdür. Eğer Pipe nesnesi yaratılırken duplex 
    parametresi False geçilirse bu durumda boru tek yönlü olur. Pipe fonksiyonun bize verdiği demetin ilk elemanı okuma yapmak için, ikinci elemanı 
    yazma yapmak için kullanılmaktadır. Çift yönlü borularda her iki taraf da hem okuma hem yazma yapabilmektedir. Programcı bu connection 
    nesnelerinin birini yarattığı prosese geçirir diğerini kendisi kullanır. 

    2) Connection sınıfının send metodu ile boruya bilgi yazılabilir, recv metodu ile borudan bilgi okunabilir. Genel olarak send metodu
    herhangi bir türden bilginin boruya yazılmasını sağlamaktadır. recv metodu da gönderilmiş olan herahngi türden bir bilginin okunmasını 
    sağlamaktadır. 

    Aşağıdaki örnekte iki yönlü bir boru oluşturulmuştur. Üst proses boruya bazı işeyler yazmış alt proses de borudan bunları okumuştur.
#------------------------------------------------------------------------------------------------------------------------------------

import multiprocessing as mp

def proc(conn):
    while True:
        val = conn.recv()
        if val == 'exit':
            break
        print(val)
        
if __name__ == '__main__':
    conn1, conn2 = mp.Pipe()            
    process = mp.Process(target=proc, args=(conn2, ))        
    process.start()
    
    conn1.send('Ali')
    conn1.send([1, 2, 3, 4, 5])
    conn1.send(1.2)
    conn1.send('exit')
    
    process.join()
    
#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte üst proses boruya send metoduyla 0'dan 100'e kadar sayıları yazmakta ve alt proses de bu sayıları recv metoduyla
    okuyup ekrana (stdout dosyasına) yazdırmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import multiprocessing

def proc(conn):
    while True:
        val = conn.recv()
        print(val, end=' ')
        if val == 99:
            break
      
if __name__ == '__main__':
    conn1, conn2 = multiprocessing.Pipe()
    process = multiprocessing.Process(target=proc, args=(conn2, ))
    process.start()
        
    for i in range(100):
        conn1.send(i)

    process.join()
    
#------------------------------------------------------------------------------------------------------------------------------------
    Prosesler arasında bellek izolasyonu olduğu için biz Pipe gibi Queue gibi özel yöntemlerle iki proses arasında veri aktarımı 
    yapmaktayız. İki proses arasında veri aktarımının bir diğer yolu da "shared memory" denilen tekniktir. Python'da "shared memory" 
    Value ve Array sınıflarıyla gerçekleştirilmiştir. Shared memory tekniği aslında zahmetli bir kodlamayı gerektirse de Python'da 
    multiprocessing modülündeki Value ve Array sınıfları ile kolay bir biçimde gerçekleştirilebilmektedir. Value sınıfınun kullanımı 
    şöyleidr:

    1) Value sınıfı türünden bir nesne yaratılır. Nesne yaratırken ona bir "type code" ve nesnenin içereceği ilkdeğer verilir. 
    2) Bu Value nesnesi diğer prosese parametre yoluyla aktarılır. 
    3) Value sınıfının value isimli örnek özniteliği paylaşılan nesneyi temsil eder. Bir proses ona atama yaptığında diğeri onu atanmış 
    görmektedir. Yani bu value özniteliği aslında "shared memory" içerisindeki nesneyi belirtmektedir. 

    Value nesnesi yaratılırken birinci parametrede belirtilen "type code" özel bazı türleri temsil eden yazılardır. Örneğin 
    'i' int türünü 'f' float türünü, 'd' double türünü temsil eder. Value sınıfı temelde C ile yazıldığı için buradaki type code C dilindeki
    türlere ilişkindir. Örneğin Python'un str türüne ilişkin bir type code yoktur. Buradaki 'i', 'f' ve 'd' C'deki türlerdir. C'deki int
    türü Python'daki gibi sınırsız uzunluğa sahip değildir. Genellikle 4 byte uzunluktadır. C'de double türü Python'daki float türüne
    karşı gelmektedir. C'deki float türünün Python'da bir karşılığı yoktur. Ancak tabii bir Value sınıfının value örnek özniteliği ile 
    değeri aldığımızda bu C'deki değer Python türüne dönüştürülerek bize verilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import multiprocessing

def proc(val):
     print(val.value)
     val.value = 200

if __name__ == '__main__' :
    val = multiprocessing.Value('i', 100)
    process= multiprocessing.Process(target=proc, args=(val, ))
    process.start()
    process.join()
    print(val.value)

#------------------------------------------------------------------------------------------------------------------------------------
    multiprocessing modülündeki Array isimli sınıf aslında Value sınıfının dizisel biçimidir. Bir Array nesnesi yaratıldığında bu nesne 
    yaratılan prosese parametre olarak geçilirse proses hem bu değerleri kullanabilir. Hem de bu dizinin elemanlarını değiştirirse diğer 
    proses onları değişmiş görür. Yani paylaşılan bellek alanında bir dizi yaratılmış olur. Array nesnesi yaratılıken de yine bir 
    "type code" belirtilmektedir. Yine buradaki type code C Programlama Dilindeki türlere ilişkindir. 
#------------------------------------------------------------------------------------------------------------------------------------

import multiprocessing

def proc(a):
    for i in range(len(a)):
        print(i)
        a[i] = i * 10
         
if __name__ == '__main__' :
    a = multiprocessing.Array('i', [1, 2, 3, 4, 5])
    process= multiprocessing.Process(target=proc, args=(a, ))
    process.start()
    process.join()
    for x in a:
        print(x)

#------------------------------------------------------------------------------------------------------------------------------------
    Shared memory tekniği işletim sistemleri dünyasında en hızlı proseslerarası haberleşme yöntemidir. Ancak bu yöntem kendi içerisinde 
    bir senkronizasyon içermemektedir. Yani proseslerden biri bu paylaşılan bellek alanına bir şeyler yazdığında diğeri bunu uygun zamanda
    okuması gerekir. Bu biçimde pek çok veri aktarılacaksa "üretici-tükestici" problemi uygulanmalıdır. Ancak zaten modüldeki Queue ve 
    Pipe sınıfları bu tarz bir senkronizasyonu kendiliğinde içermektedir. Python'daki Value ve Array sınıfları genellikle birtakım bilgilerin
    tek seferlik hızlı ve basit bir biçimde aktarılması için kullanılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Proseslerarasında da senkronizasyonlar gerekebilmektedir. Bunun için threading modülündeki senkronizasyon nesnelerinin tamamen benzerleri 
    multiprocessing modülünde de bulundurulmuştur. Yani biz thread'ler arasında kullandığımız senkronizasyon nesnelernin benzerlerini prosesler
    arasında da kullanabilmekteyiz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    threading modülündeki Lock sınıfının tamamen benzeri multiprocessing modülünde de prosesleri senkronize etmek için bulunmaktadır.
    Tabii proseslerarasında kullanım için Lock nesnesinin alt prosese args parametresiyle geçirilmesi gerekmektedir. 

    Aşağıdaki örnekte üst proses alt prosesin kilidi ele geçirmesine izin vermiştir. Alt proses kilidi alarak 5 saniye bekledikten sonra
    kilidi bırakmıştır. Üst proses alt proses kilidi bıraktıktan sonra kilidi alabilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import multiprocessing as mp
import time

def proc(lock):
   lock.acquire()
   print('child process locked')
   time.sleep(5)
   lock.release()
            
if __name__ == '__main__':
    lock = mp.Lock()
    process= mp.Process(target=proc, args=(lock, ))
    process.start()
    time.sleep(1)
    
    lock.acquire()
    print('parent process locked')
    lock.release()
    
    process.join()
   
#------------------------------------------------------------------------------------------------------------------------------------
    Tabii farklı proseslerde senkronizasyonun anlamlı olabilmesi için farklı proseslerin ortak bir kaynağı kullanıyor olması gerekir. 
    Bu ortak kaynak bellekte bir nesne ise bu nesnenin de prosesler arasında paylaşılıyor olması gerekir. 

    Aşağıdaki örnekte multiprocessing.Lock nesnesi kullanılarak kritik kod oluşturulmuştur. Bu koddaki do_something fonksiyonu iki proseste de
    bulunan ancak iki farklı programın çalıştırdığı bir fonksiyondur.
#------------------------------------------------------------------------------------------------------------------------------------

import multiprocessing as mp
import time
import random

def do_something(s, lock):
    lock.acquire()
    print(f'{s}: 1.Step')
    time.sleep(random.random() / 2)
    print(f'{s}: 2.Step')
    time.sleep(random.random() / 2)
    print(f'{s}: 3.Step')
    time.sleep(random.random() / 2)
    print(f'{s}: 4.Step')
    time.sleep(random.random() / 2)
    print(f'{s}: 5.Step')
    time.sleep(random.random() / 2)
    print('---------------------------')
    lock.release()

def proc(lock):
   for i in range(10):
       do_something('Child Process', lock)
         
if __name__ == '__main__':
    lock = mp.Lock()
    process= mp.Process(target=proc, args=(lock, ))
    process.start()
    
    for i in range(10):
        do_something('Parent Process', lock)
    
    process.join()
   
#------------------------------------------------------------------------------------------------------------------------------------
    threading modülündeki event nesnelerinin de multiprocessing modülünde benzeri bulunmaktadır. Tabii yine Event nesnesinin altg prosese
    args parametresiyle aktarılması gerekmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import multiprocessing as mp
import time

def proc(event):
    print('Child process runs...')
    time.sleep(5)
    print('Child reached important point')
    event.set()
    
if __name__ == '__main__':
    event = mp.Event()
    process= mp.Process(target=proc, args=(event, ))
    process.start()
    
    print('Parent waits for child...')
    event.wait()
    print('Ok, parent continues...')
    
    process.join()
    
#------------------------------------------------------------------------------------------------------------------------------------
    Yine threading modülündeki Semaphore sınıfının bir benzeri multiprocessing modülünde de bulundurulmuştur. Aşağıdaki örnekte 
    binary semaphore ile proseslerarasında kritik kod oluşturulmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import multiprocessing as mp
import time
import random

def do_something(s, sem):
    sem.acquire()
    print(f'{s}: 1.Step')
    time.sleep(random.random() / 2)
    print(f'{s}: 2.Step')
    time.sleep(random.random() / 2)
    print(f'{s}: 3.Step')
    time.sleep(random.random() / 2)
    print(f'{s}: 4.Step')
    time.sleep(random.random() / 2)
    print(f'{s}: 5.Step')
    time.sleep(random.random() / 2)
    print('---------------------------')
    sem.release()

def proc(lock):
   for i in range(10):
       do_something('Child Process', lock)
         
if __name__ == '__main__':
    sem = mp.Semaphore(1)
    process= mp.Process(target=proc, args=(sem, ))
    process.start()
    
    for i in range(10):
        do_something('Parent Process', sem)
    
    process.join()
   
#------------------------------------------------------------------------------------------------------------------------------------
    Proseslerarası haberleşme (interprocess communication ya da kısaca IPC) kabaca ikiye ayrılmaktadır. 

    1) Aynı makinenin prosesleri arasında haberleşme
    2) Farklı makinelerin prosesleri arasında haberleşme

    Aynı makinenin prosesleri arasında haberleşmede işletim sistemleri tarafından sunulan "shared memory", "message queue", "pipe" gibi 
    yöntemler kullanılmaktadır. (Biz de multiprocessing modülü sayesinde Python'da yüksek seviyeli bir biçimde bu mekanizmaları 
    kullababilmekteyiz.) 
    
    Farklı makinelerin prosesleri arasında haberleşme için önceden belirlenmiş birtakım kurallara uyulması gerekmektedir. Haberleşmede 
    uyulması gereken kurallara "protokol" denilmektedir. Çeşitli protokol aileleri vardır. Bugün için en yaygın kullanılan protokol ailesi 
    "IP Protokol Ailesi (IP Protocol Family)" denilen ailedir. IP prototokol ailesi aynı zamanda Internet'tin de kullandığı protokol ailesidir. 

    Farklı makinelerin prosesleri arasında uzak mesafe haberleşme ilk kez 1969 yılında denenmiştir. Soğuk savaş yıllarında ABD Savunma Bakanlığına
    bağlı DARPA denilen kurumun ARPA denilen bölümü ismine ARPANET denilen bir proje başlatmıştır. ARPANET ABD savunmasında kullanılan bilgisayarların
    dağıtık hale getirilmesini hedeflemekteydi. Proje ABD Savunma Bakanlığının yanı sıra birkaç üniversite tarafından yürütülmekteydi. Sonraları
    bu ARPANET genişlemeye başladı. ABD'dedeki diğer hükümet kurumları ve üniversiteler bu ağa bağlandılar. O zamanlar bu ağ NCP denilen bir 
    protokol kullanıyordu. ARPANET sonraları Avrupa'ya sıçradı ve 80'li yılların ortalarına doğru Türkiye'ye de geldi. 1983 yılında ARPANET 
    NCP protokolünü bırakarak IP protokol ailesine geçmiştir. ARPANET daha sonraları Internet ismini almıştır. Internet ismi "internetworking"
    sözcüğünden uydurulmuştur. Internetworking ağların birbirlerine bağlanması anlamına gelmektedir. Bugünkü Internet'te aslında çeşitli küçük 
    ağlar birbirleriyle bağlanarak büyük bir ağı oluşturmaktadır. Ağları biribirine bağlamak için "Router" denilen aygıtlar kullanılmaktadır. 
    Bugün evlerimizde kullandığımız modemler aynı zamanda router özelliğine de sahiptir. 

    Protokol aileleri üst üste yığılmış olan protokollerden oluşmaktadır. Her üste yığılmış protokole "katman (layer)" denilmektedir. Her katmandaki 
    protokol "aşağıdaki katmanların zaten var olduğu fikriyle daha yüksek seviyeli" kuralları tanımlamaktadır. Protokol ailelerini oluşturmak 
    için ISO ve bazı kurumlar tarafından ismine "OSI Reference Model" denilen bir model oluşturulmuştur. OSI model bir protokol değildir. 
    Protokol ailelerini oluşturacaklar için bir kılavuz niteliğindedir. OSI modelde toplam 7 katman üst üste yığılmıştır. OSI'nin 7 katmanı
    şöyledir:

    Uygulama Katmanı (Application layer)
    Açıklama Katmanı (Presentation Layer)
    Oturum Katmanı (Session Layer)
    Aktarım Katmanı (Transport Layer)
    Ağ Katmanı (Network Layer)
    Veri Bağlantı Katmanı (Data Link Layer)
    Fiziksel Katman (Physical Layer)

    Fiziksel katman iletişimde kullanılacak tüm donanım birimlerinin speklerini belirtmektedir. Veri Bağlantı Katmanı birimlerin (bilgisayarların) 
    birbirlerini tanımaları için gereken kuralları barındırmaktadır. Veri bağlatı katmanında ağa bağlı her birimin bir fiziksel adresi olmalıdır. 
    Bugün bilgisayarlarımızda kullandığımız Ethernet Kartı diye bilinen network kartlarının protokolü olan Ethernet Protokolü OSI'min Data Link Layer
    katmanına ilişkindir. Ağ Katmanı "internetworking" için gereken ana protokollerin bulunduğu katmandır. IP Protokol ailesindeki IP (Internet Protocol) 
    protokolü OSI'nin "Ağ Katmanına" ilişkn bir protokoldür. Bu katmandaki protokoller artık ağa bağlı birimlere fiziksel değil mantıksal 
    bir adres vermektedir. Bu katmandaki protokoller bilgilerin nasıl paketlere ayrılıp nasıl iletileceği konusundaki ayrıntıları tanımlamaktadır. 
    Aktarım katmanı aynı birime giden paketlerin orada ayrıştırılması ve bir araya getirilmesine ilişkin kuralları tanımlaayan protokolleri içermektedir. 
    Örneğin IP protokol ailesindeki TCP ve UDP tipik olarak Aktarım Katmanı protokolleridir. İletişimde bir "oturum (session)" oluşturmak gerekebilir. 
    Oturum katmanı bunu oluşturmaktadır. Bilgilerin şifrelenemsi, sıkıştırılması gibi faaaliyetler Açıklama Katmanı protokolleri tarafından yapılmaktadır.
    Nihayet uygulama katmanı protokolleri kullanıcının kullandığı programların doğrudan kullandığı protokollerdir. Örneğin IP ailesindeki HTTP, Telnet, 
    SSH, POP3, IMAP gibi protokoller OSI'nin uygulama katmanına ilişkindir. 

    Her ne kadar OSI 7 katmanlı bir protokol ailesi tanımlamışsa da IP Protokol ailesi OSI'nin 7 katmanını kullanmamaktadır. IP protokol ailesi 
    4 katmanlı bir protokol ailesidir. IP Protokol ailesinin temel protokolleri şöyle oluşturulmuştur:


       HTTP, Telnet,                           (OSI'nin Application Layer)
       SSH, Pop3, 
       IMAP, ....                              
         TCP       UDP                         (OSI'nin Transport Layer)
        IP protokolünü                         (OSI'nin Network Layer)
    Ethernet/Wireles Protokolü                 (OSI'nin Physical Layer + Data Link Layer)

    Tabii IP Protokol ailesinde daha pek çok yardımcı protokoller de vardır. Biz yukarıda yalnızca temel protokolleri belirttik. 
    OP Protokolü aileye ismini veren en önemli protokoldür. Bu protokol bilgilerin paketlere ayrılması, rotalanması gibi tanımlamaları 
    barındırmaktadır. IP protokolünde ağa bağlı olan her birime "host" denilmektedir. Her host'un isminme IP numarası denilen mantıksal 
    bir adresi vardır. IP Protokolünün iki önemli versiyonu vardır: IPV4 ve IPV6.  IPV4'te IP numaraları 4 byte uzunluktadır. Anc ak bu 4 byte'lık
    IP numaraları zamanla yetersiz kalmaya başlamıştır. IPV6'da IP numaraları 16 byte uzunluğundadır. Bugün hem IPV4 hem de IPV6 aynı anda
    kullanılmaktadır. Yine ağırlıklı kullanım halen IPV4'tür. 

    TCP (Transmission Control Protocol) IP ailesindeki ağırlıklı kullanılan transport protokolüdür. IP ailesinin HTTP, SSH, Telnet, POP3 gibi 
    protokollerinin hepsi TCP üzerine oturtulmuştur. IP protokol ailesinde doğrudan IP protokolü ile işlemler çok seyrek yapılmaktadır. Genellikle 
    uygulamacılar TCP protokolünü kullanmaktadır. TCP kullanımına halk arasında TCP/IP de denilmektedir. 

#------------------------------------------------------------------------------------------------------------------------------------
                                                    62. Ders 02/08/2023 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    IP protokolünün üzerine TCP (Transmission Control Protocol) ve UDP (User Datagram Protocol) protokolleri oturtulmuşur. Yukarıda da 
    belirttiğimiz gibi ağırlıklı olarak TCP protokolü kullanılmaktadır. TCP "stream tabanlı (stream based)" UDP ise "paket tabanlı (datagram)"
    bir haberleşme sunmaktadır. Stream tabanlı haberleşe demekle "byte'ların kuyruk sistemi gibi sıraya dizildiği ve istenilen miktarda byte'ın
    peşi sıra okunabildiği" hanerleşme modeli anlaşılmaktadır. TCP aslında IP protokolünü kullanır yani TCP ile bilgi gönderilirken aslında 
    bilgi IP paketlerine bölünür bu IP paketleri gönderilir. Ancak IP paketleri peşi sıra gönderilse bile aynı sırada alınmak zorunda değildir. 
    İşte TCP protokolünde bu IP paketleri içerisindeki TCP verileri hedefte yeniden birleştirlerek sanki bir grup byte'mış gibi okunamaktadır. 
    Dolayısıyla biz TCP'de çalışırken "sanki bir byte yığını varmış da oradan sırasıyla istediğimiz byte'ı okuyormuşuz gibi" bir durum 
    oluşturulmaktadır. UDP ise "paket tabanlı (ya da datagram tabanlı)" bir haberleşme sunmaktadır. UDP aslında IP protokolüne benzemektedir. 
    UDP'de gönderen taraf bir grup bilgiyi bir paket olarak gönderir. Alan taraf da bu paketi alır. Alan taraf "önce 5 byte sonra 10 byte 
    gibi okumalar" yapamaz. Alan taraf gelen paketi bütünsel olarak almaktadır. 

    TCP "bağlantılı (connection oriented)" bir protokoldür. TCP ile haberleşmeden önce iki taraf biribirine bağlanır. Burada bağlanmak 
    demekle "iki tarafın birbirlerinin farkında olması ve hangi durumda olduğunu bilmesi" kastedilmektedir. TCP haberleşmesinin başlaması 
    için bir tarafın karşı tarafa bağlanmayı istesi ve karşı tarafın da bunu kabul etmesi gerekir. Bağlantı "client-server" tarzı bir
    haberleşme modelini akla getirmektedir. Client-server çalışma modelinde client önce server'a bağlanır. Sonra server'dan birtakım 
    isteklerde bulunur. Server da bu istekleri yerine getirir. Sonuçları client'a yollar. Bu durumda TCP/IP uygulama yazarken "client" 
    ve "server" olmak üzere iki ayrı programın yazılması gerekmektedir. UDP ise "bağlantısız (connectionless)" bir protokoldür. Bağlantısız 
    protokollerde gönderen ve alan arasında özel bir ilişki yoktur. Gönderen paketi gönderir. Alanın da paketi alıp almadığını bilmez. 

    TCP "güvenilir (reliable)" bir protokoldür. Bir protokolün güvenilir olması demek haberleşme sırasında bazı paketlerin yolda 
    kaybolması durumunda bile bunların yeniden istenerek telafi edilmesi demektir. Gönderen taraf alan tarafın bilgiyi aldığını 
    bilmektedir. Eğer alan taraf bilgiyi almamışsa (örneğin bilgi yolda kaybolmuşsa) gönderen taraf onu yeniden göndererek telafi etmektedir. 
    Güvenilirliğin sağlanması için gönderen ve alan tarafın karşılıklı bir "akış kontrolü (flow control)" uygulaması gerekir. 
    Bir taraf sürekli bilgi gönderdiğinde karşı atarfın tamponu dolarsa gönderen taraf artık blgi göndermeyip onun tanponun uygun biçimde
    boşalmasını beklemektedir. UDP "günenilir olmayan (unreliable)" bir protokdür. UDP'de gönderen paketi gönderir anca alanın bunu alıp 
    almadığını bilmez. Dolayısıyla paket yolda kaybolursa bunun da bir telafisi yapılmaz. 

    TCP protokolü UDP protokolüne göre daha güvenilir ancak daha yavaştır. UDP'de bir akış kontrolü olmadığı için paketlerin karşı 
    tarafta birleştirilmesi gibi işlemler olmadığı için UDP hızlıdır. Ancak UDP'nin güvenilebilir olmaması ve stream tabanlı olmaması 
    onun seyrek kullanılmasına yol açmaktadır. IP protokol ailesinin HTTP gibi, POP3 gibi, IMAP gibi, FTP gibi uygulama katmanı protokolleri 
    hep TCP kullanmaktadır. 
    
    IP protokülünde ağa bağlı olan birimlere "host" denilmektedir. Bir host bir bilgisayar olabileceği gibi bir yazıcı, kamera vs. 
    olabilir. Her host'un bir IP numarası vardır. IP paketleri kaynak host'tan hedef host'a gönderilmektedir. Ancak hedef host'a gelen
    bir IP paketi orada hangi programa iletilecektir? IP protokolü bununla ilgilenmemiştir. İşte bu durum TCP ve UDP protokolerrinde
    "protocol port numarası" denilen yöntemle ele alınmaktadır. TCP ve UDP protokollerinde bir host'a giden bilgiler bilgilere bir 
    port numarası da iliştirilir. Hedef host'a gelen bilgiler o port'la hangi program ilgileniyorsa o programa iletilmektedir. Yani
    "port numarası" adeta bir şirketin "içsel hat numaralarına" benzemektedir. Biz TCP ve UDP'de yalnızca hedef host'un IP numarası 
    ile bilgiyi göndermeyiz. Bilgiyi belli bir host'un belli port'una göndeririz. 

    Port numaraları [0, 65535] arasındadır. İlk 1024 port numarası IP protokol ailesinin uygulama katmanındaki protokolleri için ayrılmıştır. 
    Dolayısıyla programcıların server yazarken ilk 1024 port nmarasını kullanmaması tavsiye edilir. Bu ilk 1024 port numarasına İngilizce
    "well known ports" denilmektedir. Örneğin sizin de duyduğunuz bazı uygulama katmanı protokollerin port numaraları şöyledir:

    HTTP: 80
    FTP: 20, 21
    TFTP: 69
    SSH: 22
    TELNET: 23
    SMTP: 25
    POP3: 110
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Protokol ailelerini işleten kodlar işletim sistemlerinin içerisinde çekirdeğin parçası biçiminde bulunurlar. Ancak onların kullanılabilmesi 
    için kütüphanelere gereksinim vardır. Bunun için kullanılan ve ilk kez BSD UNIX sistemlerinde gerçekleştirilen kütüphaneye "soket kütüphanesi
    (socket library)" denilmektedir. Windows bu BSD soket kütüphanesini kendine özgü değişik bir biçimini de oluşturmuştur. Microsoft'un 
    BSD soket kütüphanesi temel alınarak oluşturduğu bu soket kütüphanesinde "Winsock Kütüphanesi" denilmektedir. 
    macOS sistemleri BSD soket kütüphanesini aynı biçimde desteklemektedir. 

    Soket kütüphanesi Python'da "nesne yönelimli biçimde" bir modül olarak oluşturulmuştur. Python'un bu soket kütüphanesi aslında 
    arka planda UNIX/Linux ve macOS sistemlerinde BSD soket kütüphanesini, Windows sistemlerinde ise Winsock kütüphanesini kullanmaktadır. 
    Başka bir deyişle Python'daki soket kütüphanesi aslında BSD soket kütüphanesini sarmalamaktadır. 

    Yukarıda da belirttiğimiz gibi soket kütüphanesi özellikle IP protokol ailesi için oluşurulmuş bir kütüphane değildir. Soket kütüphanesi 
    protokol aileleri için ortak bir arayüz oluşturmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi TCP/IP soket uygulamalarında "server" ve "client" programların ayrı ayrı yazılması gerekmektedir. 
    Biz burada önce TCP server programının sonra da TCP client programının nasıl yazaılacağını göreceğiz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    TCP server programda tipik olarak işlemler aşağıdaki adımlarla gerçekleştirilir:

    1) Soket nesnesi yaratılır.
    2) Soket bağlanır (bind edilir)
    3) Soket dinleme konumuna sokulur 
    4) Bağlantı istekleri kabul edilir
    5) Gönderme ve alma işlemleri yapılır
    6) Soket hutdown edilir
    7) Soket kapatılır. 

    Soket işlemleri için socket isimli sınıf kullanılmaktadır. soket sınıfının __init__ metodunun parametrik yapısı şöyledir:

    socket(family=socket.AF_INET, type=socket.SOCK_STREAM, proto=0, fileno=None)
    
    Fonksiyonun birinci parametresi hangi protokol ailesi ile çalışılacağını belirtmektedir. Bu parametre socket.AF_INET geçilirse "IPV4" 
    ailesi,  socket.AF_INET6 geçilirse "IPV6" ailesi anlaşılmaktadır. Bu parametrenin default değerinin socket.AF_INET olduğuna dikkat 
    ediniz. Fonksiyonun ikinci parametresi soket türünü belirtmektedir. Bu parametre TCP için socket.SOCK_STREAM, UDP için socket.SOCK_DGRAM 
    girilmelidir. Bu parametrenin de default değerinin socket.SOCK_STREAM biçiminde olduğuna dikkat ediniz. Fonksiyonun üçüncü parametresi
    kullanılacak "aktarım katmanı (transport layer)" protokolünü belirtmektedir. Bu parametre TCP için socket.IPPROTO_TCP, UDP için 
    socket.IPPROTO_UDP biçiminde girilebilir. Aslında fonksiyonun ikinci parametresi zaten IP protokol ailesi için üçüncü parametrenin ne
    olacağını anlatmaktadır. Dolayısıyla IP protokol ilesi içim bu üçüncü parametrenin girilmesine gerek yoktur. Fonksiyonun son parametresi 
    UNIX/Linux sistemlerindeki dosya betimleyicisini alabilmektedir. Bu parametrenin bizim için şu aşamada önemi yoktur. 
    
    Eğer biz TCP/Ip kullanacaksak aslında socket fonksiyonunun iki parametresi uygun değerleri almaktadır. Yani örneğin:

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    ile aslında aşağıdaki çağrı eşdeğerdir:

    sock = socket.socket()

    Biz öneklerimizde okunabilirliği artırmak için açıkça protokol ailesini ve soket türünü belirteceğiz. 

    Soket işlemlerinde hata oluştuğunda built-in OSError isimli sınıfla exception fırlatılmaktadır. Programcı kodunu try-except bloğu içerisine
    yerleştirebilir. Örneğin:

    try:
        socket = socket.socket()
        ...
    except OSError:
        ....

    socket sınıfı "bağlam yönetim protokolünü (context management protocol)" desteklemektedir. Dolayısıyla socket sınıfı with deyimi ile 
    kullanılabilir. Bu durumda with deyiminden çıkışdığında socket nesnesi kapatılacaktır. 
#------------------------------------------------------------------------------------------------------------------------------------

import socket

try:
    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP)
    print('Ok')
except OSError as oserr:
    print(oserr)

#------------------------------------------------------------------------------------------------------------------------------------
    Soket yaratıldıktan sonra bind edilmelidir. Soketin bind edilmesi demek "hangi network kartından gelen bağlantı isteklerinin 
    işleme sokulacağını ve hangi port hedeflenerek gelen bağlantı isteklerinin işleme sokulacağını" belirlemek demektir. bind işlemi
    socket sınıfının bind metoduyla yapılır. bind metodu iki elemanlı bir demeti parametre olarak alır. Demetin birinci elemanı bağlantı 
    istekleri için kullanılacak network kartının IP adresini, ikinci elemanı ise ilgilenilecek port numarasını belirtir. Birinci parametrede 
    boş string "tüm network kartlarından gelen bağlantı isteklerinin kabul edileceğini" belirtir. Örneğin:

    sock.bind(('', 55555))

    Burada server program 55555 port numarası ile kendi bilgisayarındaki tüm network kartından (network interface) gelen bağlantı isteklerini
    değerlendiecektir. 
#------------------------------------------------------------------------------------------------------------------------------------

import socket

PORT_NO = 50500

try:
    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP)
    server_sock.bind(('', PORT_NO))
    print('Ok')
except OSError as oserr:
    print(oserr)

#------------------------------------------------------------------------------------------------------------------------------------
    Soket bind edildikten sonra artık aktif dinleme konumuna sokulmalıdır. Soketin dinlenmesi "bize gelen bağlantı isteklerinin
    işletim sistemi tarafından bizim için kuruklanması" anlamına gelmektedir. Soket dinleme konumuna sokulduğunda artık bizi ilgilendiren 
    bağlantı isteklerini işletim sistemi bize iletecektir. listen işlemi blokeye yol açmaz (yani listen işleminde bi rbekleme olmaz). 
    Çünkü burada gelen bağlantı isteklerinin belirlenmesini bizim programımız değil işletim sisteminin kendisi yapmaktadır. 
    
    Soketi dinleme konumuna sokmak için socket sınıfının listen metodu çağrılır. listen metodunun bir parametresi vardır.
    Bu parametre bağlantı isteklerinin yerleştirileceği kuyruğun uzunluğunu belirtir. Server program yavaş kalırsa yeni bağlantı 
    istekleri bu kuyruğa yazılır. Eğer kuyruk dolarsa bağlantı istekleri kuyruğa yerleştirilemediği bağlantı için başlarısız olur. Bu 
    parametre için değer girilmezse uygun bir kuyruk uzunluğu metot tarafından belirlenmeketdir. Yoğun server'larda bu değerin yüksek 
    tutulması, yoğun olmayan server'larda düşük tutulması uygundur. Ya da bu uzunluğun listen metodu tarafından default alınması 
    yoluna da gidilebilir.  

    Soket dinleme konumuna sokulurken işletim sistemlerinin "firewall" denilen güvenlik mekanizması devreye girebilmektedir. Örneğin 
    Windows sistemlerinde "listen" işlemi yapıldığında işletim sistemi bir popup pencere çıkartmaktadır. Bu popup pencerede kullanıcı 
    durum hakkında bilgilendirilmektedir. Bazı sistemlerde (örneğin centos gibi) port default olarak firewall tarafından engellenmiş 
    olabilmektedir. Bu durumda server programı çalıştırmadan önce programcının firewall'dan ilgili portu açması gerekebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import socket

PORT_NO = 50500

try:
    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP)
    server_sock.bind(('', PORT_NO))
    server_sock.listen(8)
    print('Ok')
except OSError as oserr:
    print(oserr)

#------------------------------------------------------------------------------------------------------------------------------------
    Artık sıra bağlantıların kabul edilmesine gelmiştir. Bu işlem socket sınıfının accept isimli metoduyla yapılır. accept metodu kuyrukta
    bağlantı için bekleyen bir bağlantı isteği varsa hemen o bağlantıyı sağlar. Böylece bloke oluşmaz. Ancak kuyrukta bir bağlantı isteği 
    yoksa bir bağlantı isteği oluşana kadar accpet metodu thread'i blokede bekletmektedir. Yani accept blokeye (beklemeye) yol açabilen bir metottur. 
    accept metodu bağlantıyı sağladıktan sonra bağlanılan client ile konuşmakta kullanılacak bir soketi ve bağlanılan client'a ilişkin bilgileri
    geri döndürür. Yani accept bize yeni bir soket yaratıp vermektedir. Biz her accept metodunu çağırdığımızda o spesifik client ile konuşmakta 
    kullanacağımız ayrı bir soket nesnesi elde ederiz. Her client ile farklı bir soket kullanılarak konuşulmaktadır. İşin başında server 
    programın yarattığı sokete halk arasında "pasif soket (passice socket)" ya da "dinleme soketi (listenining socket)" denilmektedir. 
    Bu soket konuşmakta kullanılmaz yalnızca bağlantı yapmak için kullanılır. accept metodunun verdiği konuşmakta kullanılacak sokete ise 
    halk arasında "aktif soket" denilmektedir. 
    
    accept metodu iki elemanlı bir demet geri döndürmektedir. Demetin ilk elemanı client ile konuşmakta kullanılacak soket, ikinci elemanı ise
    client'ın IP numarası port numarasını belirten iki elemanlı bir demettir. IP adresi ve port numarasında oluşan bilgiye "end point" de denilmektedir. 
    Örneğin:

    client_sock, (client_addr, client_port) = sock.accept()

    accept metodunun geri döndürdüğü "end point"teki IP adresi bir string olarak verilmektedir. Bir IPV4 adresinin bir string olarak
    noktalı biçimde ifade edilmesine İngilizce "dotted decimal format" denilmektedir. Örneğin:

    "192.168.1.1"
    "188.3.183.172"
#------------------------------------------------------------------------------------------------------------------------------------

import socket

PORT_NO = 50500

try:
    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP)
    server_sock.bind(('', PORT_NO))
    server_sock.listen(8)
    print('waiting for connection...')
    client_sock, (client_addr, client_port) = server_sock.accept()
except OSError as oserr:
    print(oserr)

#------------------------------------------------------------------------------------------------------------------------------------
                                        63. Ders 07/08/2023 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Soketten bilgi gönderip soketten bilgi okuma işlemleri ileride ele alınacaktır. Soket işlemleri bittiğinde soketin kapatılması gerekir. 
    Soketi kapatmak için socket sınıfının close metodu kullanılmaktadır. Pasif soketler (dinleme soketleri) doğrudan close ile kapatılabilir. 
    Ancak aktif soketlerin close metodu ile kapatılmadan önce shutdown metodu ile "shutdown" yapılmaları uygundur. Shutdown işlemi sırasında 
    TCP/IP için gereken "el sıkışma (hand shaking)" işlemi yapılır ve iletişim kontrollü bir biçimde sonlandırılır. Bir soketin önce 
    shutdown yapılıp sonra close ile kapatılmasına TCP/IP dünyasında "zarif kapatma (graceful close)" denilmektedir. 

    shudown metodunun bir parametresi vardır. Bu parametre aşağıdaki değerlerden biri biçiminde girilmelidir:
   
    socket.SHUT_RD
    socket.SHUT_WR
    socket.SHUT_RDWR

    Biz bir sokete bilgi gönderdiğimizde (bunun nasıl yapıldığı izleyen paragraflarda ele alınmaktadır) bu bilgi hemen IP paketine
    dönüştülerek yollanmaktadır. Programcının göndermek istediği bilgiler önce "network tamponu (network buffer)" denilen sokete özgü bir 
    tampona çekilir. Sonra işletim sistemi bunu kendi döngüsü içerisinde gönderir. İşte biz soket ile karşı tarafa bir bilgi gönderip 
    hemen arkasından soketi close ettiğimizde close işlemi network tamponuyla birlikte tüm soketin kapatılmasına yol açmaktadır. Yani bu 
    durumda  network tamponunda gönderilmeyi bekleyen bilgiler de gönderilemeyebilecektir. İşte shutdown işlemi socket.SHUT_WR ya da 
    socket.SHUT_RDWR ile yapılırsa bu durumda shutdown metodu network tamponundaki bilgiler karşı tarafa gönderilene kadar küçük bir 
    bloke oluşturacaktır. Bu sayede biz close işlemi yapmadna önce yerel makinemizdeki tüm bilgilerin karşı tarafa gönderildiğinden emin 
    oluruz. socket.SHUT_RD değeri "ben bir daha bu soketten okuma yapmayacağım fakat yazma yapabilirim" anlamına socket.SHUT_WR değeri ise
    "ben bir daha bu sokete yazma yapmayacağım ancak soketten okuma yapabilirim" anlamına gelmektedir. Bu tür shutdown işlemlerine TCP 
    dünyasında "half close" da denilmektedir. shutdown metodunda eğer socket.SHUT_RDWR değeri kullanılırsa bu durumda "artık bir daha 
    soketten okuma ya da sokete yazma" yapılamamaktadır. Tipik olarak shutdown parametresi için socket.SHUT_RDWR kullanılmaktadır. 

    Anımsanacağı gibi "exception güvenli" bir kodlama için genellikle nesneler üzerindeki sonlandırma ve kapatma işlemleri try bloğunun 
    finally kısmında yapılıyordu. Ancak henüz açılmamış bir soketin kapatılması da bir exception oluşmasına yol açmaktadır. Bu nedenle
    socket değişkenlerine başlangıçta None değeri yerleştirip duruma göre bunların shutdown ve close edilmesi uygun olur. Örneğin:
    
    PORT_NO = 55555

    server_sock = None
    client_sock = None

    try:
        server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        ....
        client_sock, (client_addr, client_port) = server_sock.accept()
        ...
    except OSError as e:
        print(e)
    finally:
        if client_sock:
            client_sock.shudown(...)
            client_sock.close()
        if server_sock:
            server_sock.close()
    
#------------------------------------------------------------------------------------------------------------------------------------

import socket

PORT_NO = 55555

server_sock = None
client_sock = None

try:
    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_sock.bind(('', PORT_NO))
    server_sock.listen(8)
    
    print('waiting for client...')
    client_sock, (client_addr, client_port) = server_sock.accept()
    print(f'connected with client {client_addr}:{client_port}')
 
except OSError as e:
    print(e)
finally:
    if client_sock:
        client_sock.shutdown(...)
        client_sock.close()
    if server_sock:
        server_sock.close()
#------------------------------------------------------------------------------------------------------------------------------------
    socket sınıfı "bağlam yönetim protokolünü (context management protocol)" desteklemektedir. Dolayısıyla with deyimi ile kullanılabilir. 
    Bu durumda with deyimi sonlanırken close işlemi otomatik yapılacaktır. Bu tür kodlarda with deyimi daha sade bir yazıma olanak 
    sağlamaktadır. Örneğin:

    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
            ....
            client_sock, (client_addr, client_port) = server_sock.accept()
            with client_sock:
                ...
                client_sock.shutdown(...)
    except OSError as e:
        print(e)
#------------------------------------------------------------------------------------------------------------------------------------

import socket

PORT_NO = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
        server_sock.bind(('', PORT_NO))
        server_sock.listen(8)
        
        print('waiting for client...')
        client_sock, (client_addr, client_port) = server_sock.accept()
        with client_sock:
            print(f'connected with client {client_addr}:{client_port}')
            client_sock.shutdown(socket.SHUT_RDWR)
except OSError as e:
    print(e)
  
#------------------------------------------------------------------------------------------------------------------------------------
    TCP client programın yazımı tipik olarak şu aşamalardan geçilerek gerçekleştirilmektedir:

    1) Client soket nesnesini yaratır.
    2) Client isteğe olarak bind işlemi yapabilir.
    3) Client bağlanma işlemi için connect metodunu çağırır.
    4) Bağlantı sağlandıktan sonra gönderme ve alma işlemleri yapılır
    5) Soket nesnesi ile shutdown metodu çağrılarak zarif sonlanma (graceful close) işlemi başlatılır. 
    6) Soket close metoduyla kapatılır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Her soket bir portla ilişkilendirilir. İlişkilendirme işlemi bind metoduyla yapılmaktadır. Client program bind işlemini yapmak zorunda değildir.
    Bu durumda client programın yarattığı soket connect işlemi sırasında işletim sistemi tarafından boş bir portla ilişkilendirilir. İşletim sisteminin
    client soket için bağlantı sırasında otomatik atadığı porta "ephemeral port" denilmektedir. Genel olarak client'ın bağlanmada kullanacağı 
    soketin port numarasının bir önemi yoktur. Ancak bazı server'lar ya da router'lar kaynak port numarası konusunda bazı koşullar oluşturabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bağlanma işlemi connect metoduyla yapılmaktadır. connect metodu iki elemanlı bir demeti parametre olarak alır. Demetin birinci 
    elemanı server'ın IP adresini, ikinci elemanı port numarasını içermelidir. IPV4'te IP adresleri 4 byte'tır. Bu 4 byte "dotted decimal format"
    denilen noktalarla ayrılmış bir yazı biçiminde verilebilir. Örneğin '5.25.161.169' gibi. IP protokol ailesinde anımsanması kolay olsun diye
    host'lara aynı zamanda isimler de karşılık düşürülmüştür. Ancak protokol her zaman IP numaralarıyla işletilmektedir. Internet içerisinde 
    host'lara karşı gelen IP numaraları DNS (Domain Name Server) denilen server'ların veritabanlarında tutulmaktadır. Dolayısıyla eğer biz bir host
    ismini biliyorsak onu DNS serverler'ına başvurarak IP adresine dönüştürmemiz gerekir. DNS işlemleri için IP protokol ailesinde DNS isimli 
    bir protokol kullanılmaktadır. Tabii programcıların bu DNS protokolünü bilmesine gerek yoktur. Soket sınıfının gethostbyname, gethostbyaddress 
    gibi metotları DNS işlemlerini kendi içerisinde yapmaktadır. Aslında connect metoduna parametre olarak geçtiğimiz demetin birinci elemanı 
    IP adresi yerine doğrudan host ismini de alabilmektedir. Bu durumda connect önce DNS işlemini yapar, host ismini IP adresine dönüştürür
    ondan sonra bağlantı kurmaya çalışır. DNS veritabanlarında host ismiyle IP numaraları birebir bir ilişki içerisinde değildir. Bir host ismi 
    birden fazla IP numarasıyla ilişkilendirilebileceği gibi bir IP numarası birden fazla host ismiyle de ilişkilendirilebilmektedir.   

    IPV4'te 127.0.0.1 adresi özel bir IP adresidir. Bu adrese "loopback address" de denilmektedir. Bu IP adresi hangi biz host'ta çalışıyorsak 
    o host'un IP adresi anlamına gelir. Windows, UNIX/Linux ve macOS sistemlerinde bulunduğumuz makinenin host ismi "localhost" ile de 
    temsil edilmektedir. 

    Biz connect metodunu çağırdığımızda o anda bizim bağlantımızı kabul edecek bir server programın çalışıyor olması gerekir. Aksi 
    takdirde belli bir zaman aşımından (timeout) sonra exception oluşacaktır. Bezner biçimde server program çalıştığı halde listen 
    metodunda belirtilen accept kuyruğu o anda dolmuş da olabilir. Bu durumda connect metodu belli bir süre bekler. Zaman aşımından 
    dolayı olur ve exception oluşur. 
#------------------------------------------------------------------------------------------------------------------------------------

#server.py 

iimport socket

PORT_NO = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
        server_sock.bind(('', PORT_NO))
        server_sock.listen(8)
        
        print('waiting for client...')
        client_sock, (client_addr, client_port) = server_sock.accept()
        with client_sock:
            print(f'connected with client {client_addr}:{client_port}')

            # send/recv işlemleri

            client_sock.shutdown(socket.SHUT_RDWR)
except OSError as e:
    print(e)

# client.py 

import socket

SERVER_NAME = 'localhost'
SERVER_PORT = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
        client_sock.connect((SERVER_NAME, SERVER_PORT))

        # send/recv işlemleri

        client_sock.shutdown(socket.SHUT_RDWR)
except OSError as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Aslında istenirse client programda da bind işlemi yapılabilir. Bu durumda biz belli bir kaynak porttan hedef makineye bağlanabiliriz.
    Ancak genel olarak zorunlu olmadıkça client program bind yapmamlıdır. Bu duurmda işletim sistemi client sokete conenct işlemi sırasında 
    boş bir port numarası atayacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

import socket

PORT_NO = 50500

try:
    client_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP)
    client_sock.bind(('', 3006))
    client_sock.connect(('localhost', PORT_NO))
    print('connected...')

    # send/recv işlemleri
    client_sock.shutdown(SHUT_RDWR)
    client_sock.close()
    
except OSError as oserr:
    print(oserr)
 
#------------------------------------------------------------------------------------------------------------------------------------
    Soketler "full duplex" bir haberleşme sunarlar. Yani client ile server eş zamanlı olarak birbirlerine bilgi gönderip alabilirler. 
    Bilgi göndermek için socket sınıfının send metodu bilgi almak için recv metodu kullanılmaktadır. Her iki metot da "byte" temelinde 
    çalışmaktadır. 
    
    send metoduna biz bir bytes nesnesi veririz. (Anımsanacağı gibi bytes nesneleri bir grup byte'ı temsil etmektedir.) 
    recv metodu da bize okunan byte'ları bytes nesnesi olarak vermektedir. send metodu network tamponuna yazılan byte sayısı ile geri 
    döner. recv metodu da okuyabildiği byte'lardan bytes nesnesi yaparak bize o nesneyi geri verir. Biz send metodu ile n byte göndermek 
    istediğimizde send metodu eğer network tamponunda (yani yerel makinedeki gönderme tamponunda) en az 1 byte yer varsa tampona yazabildiği 
    kadar byte'ı yazar ve yazabildiği byte sayısına geri döner. Yani biz send metodu ile n byte göndermek istediğimizde aslında daha az 
    byte göndermiş olabiliriz. Bunu send metodunun geri dönüş değeri ile anlayabiliriz. send metodu eğer network tamponunda hiç boş 
    yer yoksa en az 1 byte newtwork tamponuna yazana kadar blokede bekler. send metodu geri döndüğünde gönderilmek istenen bilgilerinen 
    az 1 byte'ı network tamponuna yazılmıştır. Ancak bu durum network tamponuna yazılan bilgilerin karşı tarafa gönderildiği anlamına gelmez. 
    send metodu gönderilecekleri network tamponuna yazar ve geri döner. Network tamponundaki bilgilerin TCP/IP pakaeti olarak gönderilmesi 
    belli bir süre sonra (tabii çok uzun bir süre değil) işletim sistemi tarafından yapılmaktadır. Örneğin:

    buf = b'\x01\x02\x\03'
    result = sock.send(buf)

    Burada send ile 3 byte gönderilmek istanmiştir. send metodu eğer network tamponunda hiç boş yer yoksa en az 1 byte yer açılana kadar 
    blokede bekler. Örneğin network tamponunda 2 byte boş yer olsun. Bu duurmda send metodu 3 byte'ı değil iki byte'ı yazarak 2 byte ile 
    geri dönecektir. 

    recv metodu eğer network tamponunda hazırda bulunan hiçbir byte yoksa en az 1 byte okuyana kadar blokeye yol açar. Eğer network tamponunda 
    okunmak için bekleyen en az bir byte bilgi varsa recv parametresiyle belirtilen miktarda byte'ın hepsini okuyana kadar bloke oluşturmaz.
    Okuyabildiği kadar byte'ı okur hemen geri döner. Eğer karşı taraf soketi shutdown ya da close ile kapatmışsa recv boş bir bytes nesnesine
    geri dönmektedir. Yani recv metodunun boş bir bytes nesnesi ile geri dönmesi başarısızlıktan dolayı değil karişı tarafın soketi kapattığından 
    dolayıdır. Nihayet recv metodu bağlantının kopması gibi anormal olaylar karşısında exception fırtlamaktadır. Örneğin:
      
    buf = sock.recv(100)

    Burada biz 100 byte okumak istiyoruz. Eğer okunacak hiçbir byte yoksa recv en az bir byte okuyana blokede bekler. O sırada örneğin porta 
    5 byte gelmiş olsun. Bu durumda recv bu 5 byte'ı okur. 5 byte'tan oluşan bir bytes nesnesi ile geri döner. Yani recv metodunun parametresinde belirttiğimiz
    byte sayısı en fazla okunacak byte'ı belirtmektedir. 

    TCP/IP'de önemli bir noktayı vurgulamak istiyoruz: Bir tarafın tek bir send ile gönderdiği bilgiyi karşı taraf tek bir recv ile 
    okumak zorunda değildir. Biz tek bir send ile 1000 byte bilgi göndermiş olabiliriz. Bu bilgi network tamponunda iki ayrı IP paketi olarak 
    gönderilmiş olabilir. Bu paketlerden biri hedefe geldiğinde recv hemen bunu okuyup 1000 byte'ın bir kısmını elde etmiş olabilir. 
    
    Aşağıdaki örnekte client program server'a bağlanıp ve ona çeşitli yazılar göndermektedir. Tabii soketten bir yazı gönderilmek istenirse 
    yazının önce bytes nesnesine dönüştürülmesi gerekir. Benzer biçimde elde edilen bytes nesnesi de yeniden yazıya dönüştürülebilir. Bir 
    string'in bytes nesnesine dönüştürülmesi için str sınıfının encode metodu, bytes nesnesinin string'e dönüştürülmesi için ise bytes 
    sınıfının decode metodu kullanılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

# server.py

import socket

PORT_NO = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
        server_sock.bind(('', PORT_NO))
        server_sock.listen(8)
        
        print('waiting for client...')
        client_sock, (client_addr, client_port) = server_sock.accept()
        with client_sock:
            print(f'connected with client {client_addr}:{client_port}')
            
            while True:
                b = client_sock.recv(4096)
                s = b.decode()
                if s == 'quit':
                    break
                print(f'{len(b)} btes received: {s}')

                
            client_sock.shutdown(socket.SHUT_RDWR)
except OSError as e:
    print(e)

# client.py 

import socket

SERVER_NAME = 'localhost'
SERVER_PORT = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
        client_sock.connect((SERVER_NAME, SERVER_PORT))
        print('connected...')
        
        while True:
            text = input('Bir yazı giriniz:')
            result = client_sock.send(text.encode())
            print(f'{result} bytes sent')
            if text == 'quit':
                break
        client_sock.shutdown(socket.SHUT_RDWR)
except OSError as e:
    print(e)
 
#------------------------------------------------------------------------------------------------------------------------------------
                                                        64. Ders 09/08/2023 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii client ile server programların aslında aynı dilde yazılması da gerekmez. Çünkü dil ne olursa olsun aslında arka planda aynı
    protokol aynı kurallara göre işletilmektedir. 

    Aşağıdaki örnekte server program python'da client program C#'ya yazılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

# server.py 

import socket

PORT_NO = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
        server_sock.bind(('', PORT_NO))
        server_sock.listen(8)
        
        print('waiting for client...')
        client_sock, (client_addr, client_port) = server_sock.accept()
        with client_sock:
            print(f'connected with client {client_addr}:{client_port}')
            
            while True:
                b = client_sock.recv(4096)
                s = b.decode()
                if s == 'quit':
                    break
                print(f'{len(b)} btes received: {s}')

                
            client_sock.shutdown(socket.SHUT_RDWR)
except OSError as e:
    print(e)
    
// Client.cs 

using System;
using System.Net;
using System.Net.Sockets;
using System.Text;

namespace CSD
{
    class App
    {
        public const string SERVER_NAME = "31.220.81.76";
        public const int PORT = 55555;

        public static void Main()
        {
            Socket clientSock;
            string text;
            byte[] buf;

            try
            {
                using (clientSock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp))
                {
                    clientSock.Connect(new IPEndPoint(IPAddress.Parse(SERVER_NAME), PORT));
                    Console.WriteLine("connected");

                    for (; ; )
                    {
                        Console.Write("Bir yazı giriniz:");
                        text = Console.ReadLine();
                        buf = Encoding.UTF8.GetBytes(text);
                        clientSock.Send(buf);
                        if (text == "quit")
                            break;
                    }
                    clientSock.Shutdown(SocketShutdown.Both);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
            }
        }
    }
}

#------------------------------------------------------------------------------------------------------------------------------------
    Yerel makinede deneyerek çalıştırdığımız client ve server programları Internet ağında da aynı biçimde çalıştırabiliriz. Eğer evinizde
    bir server program bulundurmak istiyorsanız bazı bilgilere sahip olmasınız:

    - Biz evimizde bir yerel ağa (Local Area Network (LAN)) sahbiz. Evimiz içindeki yerel ağı ayrı bir network olarak düşünebiliriz. 
    Evimizdeki bilgisayarların IP numaraları "yerel IP (local IP)" numarasına sahiptir. Biz evimizdeki yerel ağı Internet'e tek bir
    router ile bağlamaktayız. Bizim evimizin Internet'teki adresi bu router'ımızın IP adresidir. Yani evimizde birkaç bilgisayarımız 
    olsa da biz Internet ortamında sanki tek host gibi görünmekteyiz. Router'ımızın Internet'teki IP adresi çeşitli biçimlerde elde edilebilir. 
    Bunun basit bir yolu tarayıcan "whatismyip.com" sitesine girip bakmaktır. Ancak maalesef servis sağlayıcılar  bize hep aynı IP 
    adresini atamamaktadır. Dolayısıyla "whatismyip.com" sitesinden elde edeceğiniz IP adresleri zamanla değişebilecektir. Bu tür IP 
    adreslerine "dinamik ip adresleri" denilmektedir. Servis sağlayıcının bize hep aynı ip adresine vermesini istiyorsanız servis 
    sağlayıcınızla görüşmelisiniz. Ancak servis sağlayıcılar bu işlemi aylık ücret karşılığında yapmaktadır. Statik IP'nin en önemli
    faydası client programların hep IP adresi ile server'larınıza erişebilmesidir. Internet hizmeti veren hosting firmaları zaten 
    hep statik ip vermektedir. 

    - Evimizde bir server oluştururken dikkat edeceğimiz bir nokta da "port yönlendirmesi (port forwarding)" yapmaktır. Dış dünyadan 
    bizim evimizdeki server'a bağlanmak isteyen kişiler bizim rouer IP adresini kullanacaklardır. Oysa server'ımız yerel ağdadır ve onun
    yerel IP'si vardır. İşte bu durumda router'a gelen bağlantı isteklerinin router tarafından yerel ağdaki bilgisayarımıza yönlendirilmesi
    gerekir. Buna port yönlendirmesi denilmektedir. Poer yönlendirmesi yapabilmek için tarayıcıdan router'a erişmek gerekir. Genellikle 
    router adresi yerel ağda "192.168.1.1" biçimindedir. Ancak artık servis sağlayıcılar port yönlendirmesi için statik IP'yi zorunlu
    tutmaktadır. Tabii bir hosting şirketinden VPS ya da "dedicated server" kiralamışsanız böyle port yönlendirmesini yapmanıza gerek 
    kalmayacaktır. Zaten bu tür hosting hizmeti veren şirketler VPS ve "dedicated server'lar" için statik IP adresleri vermektedir.                                          
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Çok client'lı server uygulamalarında server her client için döngü içerisinde accept uygulamalıdır. Ancak çok client'lı server 
    uygulamalarında önemli problem şudur: Server bir client ile bağlandığı zaman onunla nasıl konuşacaktır? Tek bir akış söz konusu 
    olduğunda server yeniden accept metodunda beklerken bloke oluşacağından dolayı daha önce bağlanmış olduğu client'lar ile konuşamaz. 
    Benzer biçimde tek bir akış söz konusu olduğunda bir client için recv yapıldığında eğer o client bir bilgi göndermemişse akış 
    bu sefer de recv metodunda bloke olur. Sonuç olarak tek bir akış ile birden fazla client ile konuşmak mümkün olmaz. O zaman 
    ilk akla gelecek yöntem her client için bağlantı yapıldıktan sonra yeni bir thread yaratmak ve o client ile o thread'in konuşmasını 
    sağlamaktır. Böylece bir thread bloke olsa bile diğer thread'ler bundan etkilenmezler. Çok client'lı server uygulamalarında çeşitli 
    modeller kullanılabilmektedir. Thread modeli basitliği nedeniyle bazı uygulamalarda tercih edilir. Ancak thread modelinin de önemli 
    dezavantajları söz konusu olabilmektedir. 

    Aşağıdaki programda server için thread modeli uygulanmıştır. Bağlantı sağlandığında yeni bir thread yaratılmış ve soket bilgileri bu yeni thread'e
    parametre yoluyla aktarılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

# server.py 

import socket
import threading

PORT_NO = 55555

def main():
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
            server_sock.bind(('', PORT_NO))
            server_sock.listen(8)
            
            while True:
                print('waiting for client...')
                client_sock, (client_addr, client_port) = server_sock.accept()
                print(f'connected with client {client_addr}:{client_port}')
                thread = threading.Thread(target=client_proc, args=(client_sock, client_addr, client_port))
                thread.start()
                
                            
    except OSError as e:
        print(e)

def client_proc(sock, addr, port):
    try:
        with sock:
            while True:
                b = sock.recv(4096)
                s = b.decode()
                print(f'recieved message from client {addr}:{port} ==> "{s}" ')
                if s == 'quit':
                    break
                sock.send(s[::-1].encode())
            sock.shutdown(socket.SHUT_RDWR)
    except OSError as e:
        print(e)
        
main()

# client.py

import socket

SERVER_NAME = 'localhost'
SERVER_PORT = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
        client_sock.connect((SERVER_NAME, SERVER_PORT))
        print('connected...')
        
        while True:
            text = input('Bir yazı giriniz:')
            result = client_sock.send(text.encode())
            if text == 'quit':
                break
            buf = client_sock.recv(4096)
            rev_text = buf.decode()
            print(rev_text)
        client_sock.shutdown(socket.SHUT_RDWR)
except OSError as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
                                                65 .Ders 25/08/2023 - Cuma
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Client'larla konuşmak için thread'ler yerine proseslerden de faydalanabiliriz. Daha önceki konularda da bahsettiğimiz gibi genel 
    olarak prosesler GIL yüzünden thread'lere göre daha iyi performans gösterebilmektedir. Aşağıda çok client'lı uygulama için proses
    modeline bir örnek verilmiştir. Anımsanacağı gibi zaten multiprocessing modülünün kullanımı threading modülüne oldukça benzemektedir. 
    Dolayısıyla biz thread örneğinde küçük değişikliklerle aşağıdaki proses örneğini oluşturduk. 
#------------------------------------------------------------------------------------------------------------------------------------

# server.py

import socket
import multiprocessing

PORT_NO = 55555

def main():
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
            server_sock.bind(('', PORT_NO))
            server_sock.listen(8)
            
            while True:
                print('waiting for client...')
                client_sock, (client_addr, client_port) = server_sock.accept()
                print(f'connected with client {client_addr}:{client_port}')
                process= multiprocessing.Process(target=client_proc, args=(client_sock, client_addr, client_port), daemon=True)
                process.start()
               
    except OSError as e:
        print(e)

def client_proc(sock, addr, port):
    try:
        with sock:
            while True:
                b = sock.recv(4096)
                s = b.decode()
                print(f'recieved message from client {addr}:{port} ==> "{s}" ')
                if s == 'quit':
                    break
                sock.send(s[::-1].encode())
            sock.shutdown(socket.SHUT_RDWR)
    except OSError as e:
        print(e)
       
if __name__ == '__main__':
    main()
 
#client.py

import socket

SERVER_NAME = 'localhost'
SERVER_PORT = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
        client_sock.connect((SERVER_NAME, SERVER_PORT))
        print('connected...')
        
        while True:
            text = input('Bir yazı giriniz:')
            result = client_sock.send(text.encode())
            if text == 'quit':
                break
            buf = client_sock.recv(4096)
            rev_text = buf.decode()
            print(rev_text)
        client_sock.shutdown(socket.SHUT_RDWR)
except OSError as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Bir soket nesnesinden o soketi gören bir dosya nesnesi elde edilebilir. Burada "o soketi gören" demekle o dosya nesnesi ile işlem 
    yaptığımızda aslında ilgili soketle işlem yapılacağını" anlatmak istiyoruz. Soketten dosya nesnesi elde etmek için socket sınıfının 
    makefile isimli metodu kullanılmaktadır. makefile metodunun ilgili parametreleri built-in open fonksiyonun parametreleri gibidir. 
    makefile metodu tek parametreyle çağrılabilir. Bu durumda bu paramere dosyanın açış modunu belirtir. Ancak buradaki açış mode yalnızca
    şu modlardan biri olabilir: 'r', 'w', 'rb', 'wb'. Bu dosya nesnesi yine close edilmelidir. Ancak bu nesnenin close edilmesi socket nesnesinin
    close edilmesi anlamına gelmez. socket nesnesi ayrıca close edilmelidir. Benzer biçimde socket nesnesinin close edilmesi de bu dosya nesnesinin
    close edileceği anlamına gelmemektedir. 

    Pekiyi soket için makefile ile dosya nesnesi oluşturmanın ne faydası vardır? İşte normal soket ile send ve recv metotlarını kullanabiliriz. Bu
    metotlar da byte nesneleriyle çalışmaktadır. Halbuki dosya nesnelerinin kullanımı daha esnektir. Ancak Python'da text dosyalar (yani 'b' belirtilmeden 
    oluşturulan dosyaların) tamponlu çalışmaktadır. Bunun için dosya nesnesinin üzerinde flush uygulanması gerekebilmektedir. 

    Aslında dosyalarda biz dosyaya birşeyler yazdığımızda bu yazılanlar önce bir tamponda biriktirilip tampon dolduğunda asıl hedefe aktarılmaktadır. 
    Bunun nedeni gerçek disk işlemlerinin azaltılmak istenmesidir. İşte makefile ile sokete ilişkin bir dosya nesnesi elde ettiğimizde bu dosya 
    nesnesi ile write yapıldığında yazılmak istenenler arka planda hemen send işlemi ile soketten gönderilmemektedir. Bunlar önce bir tamponda 
    biriktirilip tampon dolduğunda gönderilmektedir. Biz yazılanların hemen gönderilmesini istiyorsak write işleminden sonra flush metodunu 
    çağırmalıyız. flush işlemi tamponda birikenleri o anda hedefe aktarmaktadır. Tabii dosya nesnesi kapatıldığında kapatma sırasında da flush 
    işlemi yapılmaktadır. 

    Aşağıdaki örnekte makefile metodu ile dosya işlemleri yolu ile bir client/server örneği verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

# server.py 

import socket
import threading

PORT_NO = 55555

def main():
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
            server_sock.bind(('', PORT_NO))
            server_sock.listen(8)
            
            while True:
                print('waiting for client...')
                client_sock, (client_addr, client_port) = server_sock.accept()
                print(f'connected with client {client_addr}:{client_port}')
                thread = threading.Thread(target=client_proc, args=(client_sock, client_addr, client_port))
                thread.start()           
                            
    except OSError as e:
        print(e)

def client_proc(sock, addr, port):
    try:
        with sock:
            with sock.makefile('w') as fw, sock.makefile('r') as fr:
                while True:
                    text = fr.readline()[:-1]
                    print(f'recieved message from client {addr}:{port} ==> "{text}"')
                    if text == 'quit':
                        break
                    fw.write(text[::-1] + '\n')
                    fw.flush()
                sock.shutdown(socket.SHUT_RDWR)
    except OSError as e:
        print(e)
        
main()

# client.py

import socket

SERVER_NAME = 'localhost'
SERVER_PORT = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
        
            client_sock.connect((SERVER_NAME, SERVER_PORT))
            print('connected...')
            with client_sock.makefile('w') as fw, client_sock.makefile('r') as fr:
                while True:
                    text = input('Bir yazı giriniz:')
                    fw.write(text + '\n')
                    fw.flush()
                    if text == 'quit':
                        break
                    response = fr.readline()
                    print(response, end='')
                client_sock.shutdown(socket.SHUT_RDWR)
except OSError as e:
    print(e)   
        
#------------------------------------------------------------------------------------------------------------------------------------
    Bir soketten bir satır (yani '\n' görene kadar) bilgi okumak sanıldığı kadar kolay değildir. Çünkü TCP protokolünde bir tarafın 
    send ile gönderdiği bilgileri diğer tarafın tek bir recv ile okuması garanti değildir. Bunlar karşı tarafa farklı TCP paketleri ile
    iletilebilir. Dolayısıyla okuyan taraf bir satırlık bilgiyi birden fazla recv ile okumak zorunda kalabilir. Aynı zamanda gönderen 
    taraf da birden fazla  satırı peş peşe gönderdiğinde alan taraf da bunu tek bir recv ile alabilir. Yani TCP'de birden fazla send 
    işlemi tek bir recv ile de alınabilmektedir. İşte bu nedenlerden dolayı bir satırlık bilginin etkin bir biçimde okunması o kadar 
    kolay değildir. recv metodu ile her defasında birer karakter soketten okunarak bir satır bilgi okunabilir. Ancak bu da yavaş 
    bir yöntemdir dolayısıyla etkin değildir. 
    
    İşte makefile metodu sayesinde soketten bir satır okumak oldukça kolaydır. Çünkü makefile bize bir dosya nesnesi verir. O dosya 
    nesnesi üzerinde readline metodunu uyguladığımızda zaten bu okuma işlemi readline tarafından etkin bir biçimde yapılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Client/Server uygulama geliştirirken client'ın isteklerini server'a iletmesi, server'ın istenilenleri yapması ve sonucu client'a 
    iletmesi gerekir. İşte client ile server arasındaki bu mesajlaşmalar temelde iki biçimde yapılmaktadır:

    1) Yazısal (text) biçiminde
    2) Binary biçimde (yani byte düzeyinde)

    Byte düzeyinde (binary) mesajlaşma daha hızlıdır. Ancak daha zordur ve manuel işlemler için (örneğin telnet gibi bir ortam) uygun olmayabilir. 
    Bu nedenle yazısal mesajlaşmalar daha çok tercih edilmektedir. Gerçekten de IP ailesinin uygulama katmanındaki POP3, SMTP, FTP, TELNET, HTTP gibi 
    protokolleri hep metinsel biçimde mesajlaşma uygulamaktadır. Biz de kursumuzda metinsel mesajlaşmalara ilişkin örnekler vereceğiz. Metinselsel 
    mesajlaşmalarda client ve server birbirlerine "bir satırlık" yazılar göndererek mesajlaşmayı sağlarlar. Gerçekten de IP ailesinin uygulama 
    katmanındaki protokoller böyle birer satırlık bilgilerin gönderilip alınması biçiminde mesajlaşma uygulamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Dört işlem yapan çok client'lı bir client/server uygulama yazmak isteyelim. Bu tür uygulamalar yazılırken önce bir "uygualama katmanı 
    protokolünün tasarlanması" gerekir. Yani client server'a nasıl istekte bulunacak, server bunu nasıl yanıtlayacak? Burada mesajlaşmalar 
    nasıl olacak? Bunların belirlenmesi gerekir. Server'lardan herkesin hizmet alamaması için bir user name/password mekanizmasının oluşturulması 
    ve login işleminin yapılması gerekebilir. TCP/IP'de connect ve accept işlemleriyle fiziksel bağlantı sağlanmaktadır. Client'ın server'a 
    fiziksel biçimde bağlanması ondan hizmet alabileceği anlamına gelmez. Server'ın hizmet vermesi için bir "login" mekanizmasının mantıksal 
    biçimde oluşturulması gerekebilir. Bu login mekanizmasına "mantıksal bağlanma" da diyebiliriz. Böyle bir uygulamanın protokolü aşağıdaki 
    gibi olabilir:

    Client'tan Server'a Gönderilen Mesajlar:

    "LOGIN <user name> <password>\n"
    "LOGOUT\n"
    "ADD <op1> <op2>\n"
    "SUB <op1> <op2>\n"
    "MUL <op1> <op2>\n"
    "DIV <op1> <op2>\n"
    
    Server'dan Client'a Gönderilen Mesajlar:

    "LOGIN_ACCEPTED\n"
    "ERROR <text>\n
    "RESULT <value>\n"
    "LOGOUT_ACCEPTED\n"

    Genel olarak bu tür protokollerde client'ın her mesajına karşılık server da client'a bir mesaj yollamaktadır. Eğer client geçersiz bir 
    mesaj yollarsa ya da client'ın isteği yerine getirilemezse bizim bu örneğimizde server client'a "ERROR hama mesajı\n" biçiminde yazı 
    gönderecwktir. Bu tür protokollerde mesajlaşmalar yazısal düzeyde yapılıyor olsa da gönderilen bu yazılar parse edilerek istenen bilgi
    yazıların içerisinden alınmaktadır. 

    Aşağıda böyle bir program örneği verilmiştir. Örneğimizde client'lara ilişkin "user name ve password" bilgileri "credentials.csv"
    dosyası içerisinde tutulmaktadır. Örnek bir "credentials.csv" dosyası şöyle olabilir:

    kaan,maviay
    ali,ankara
    ahmet,istanbul

    Bu CSV dosyasında her satırda ilgili kullanıcının kullanıcı adı ve parolası bulunmaktadır. Tabii uygulamada aslında kullanıcıların 
    parolalarının kendisi doğrudan dosyalarda bu biçimde saklanmamaktadır. Kullanıcıların parolaları şifrelendikten sonra onların şifrelenmiş
    halleri dosyalarda saklanmaktadır. Kullanıcı login olurken kullanıcının parolası yeniden şifrelenir ve iki şifrelenmiş parolanın eşitliğine
    bakılır. Yani normal olarak aslında server'larda bizim parolalarımızın tutulmaması gerekir. 

    Client program çalıştırıldığında önce klavyeden kullanıcı adı ve parola bilgisini alır. Sonra bunu doğrularsa client server'a mantıksal 
    olarak bağlanmış olur. Bundan sonra artık client bir komut satırında "3 + 4" gini "5 - 3" gibi dörtişelmli bir yazı yazar. Client
    program bu yazıyı uygun bir mesaja dönüştürerek server programa yollar. Server program da client programa sonucu yollar. Client program
    bu sonuç mesajını parse ederek sonucu ekrana yazdırır. Örneğin:

    User name:kaan
    Password:maviay
    Logged in...
    Calc>3 + 2
    5.0
    Calc>5 * 3
    15.0
    Calc>logout
    Logged out

#------------------------------------------------------------------------------------------------------------------------------------

# server.py 

import socket
import threading
import csv

PORT_NO = 50500

users = {}

def main():
    try:
        with open('credentials.csv') as f, socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP) as server_sock:
            for t in csv.reader(f):
                if len(t) != 2:
                    continue
                user_name, password = t
                users[user_name] = password
                
            server_sock.bind(('', PORT_NO))
            server_sock.listen(8)
        
            print('waiting for connection...')
            while True:
                (client_sock, (client_addr, client_port)) = server_sock.accept()
                print(f'connected with client {client_addr}:{client_port}...')
                
                client_thread = threading.Thread(target=client_thread_proc,  args=(client_sock, client_addr, client_port))
                client_thread.start()
                
    except OSError as oserr:
        print(oserr)
            
def client_thread_proc(client_sock, client_addr, client_port):
    try:
        with client_sock, client_sock.makefile('r') as fr, client_sock.makefile('w') as fw:
            if not login_proc(fr, fw):
                client_sock.shutdown(socket.SHUT_RDWR)
                return
     
            while True:
                cmd = fr.readline()
                if cmd == '':
                    break
                cmd = cmd[:-1]
                print(f'Command from {client_addr}({client_port}): {repr(cmd)}')
                
                if not process_cmd(fw, cmd):
                    break
        client_sock.shutdown(socket.SHUT_RDWR)
            
    except OSError:
        pass
    finally:
        print(f'{client_addr}:{client_port} disconnected...')

def process_cmd(fw, cmd):
    cmd_dict = {'ADD': add_proc, 'SUB': sub_proc, 'MUL': mul_proc, 'DIV': div_proc, 'LOGOUT': logout_proc}
    
    params = cmd.split()
    
    if params and (proc := cmd_dict.get(params[0])):
        return proc(fw, cmd, params)
    
    fwrite(fw, f'ERROR Invalid command "{cmd}"\n')    
        
    return True
  
def login_proc(fr, fw):
    cmd = fr.readline()[:-1]
    params = cmd.split()
    if len(params) != 3 or params[0] != 'LOGIN':
        fwrite(fw, f'ERROR Invalid command "{cmd}"\n')
        return False
    
    password = users.get(params[1])
    if  password and password == params[2]:
        fwrite(fw, 'LOGIN_ACCEPTED\n')
        print(f'{params[0]} logged in...')
        return True
    else:
        fwrite(fw, 'ERROR Invalid user name or password\n')
        return False
                 
def add_proc(fw, cmd, params):
    if len(params) != 3:
        fwrite(fw, f'ERROR Invalid command: "{cmd}"\n')
        return True
    
    try:
        val1 = float(params[1])
        val2 = float(params[2])
        result = val1 + val2
        fwrite(fw, f'RESULT {result}\n')
    except ValueError:
        fwrite(fw, f'ERROR incorrect argument: "{cmd}"\n')
        
    return True

def sub_proc(fw, cmd, params):
    if len(params) != 3:
        fwrite(fw, f'ERROR Invalid command: "{cmd}"\n')
        return True
    
    try:
        val1 = float(params[1])
        val2 = float(params[2])
        result = val1 - val2
        fwrite(fw, f'RESULT {result}\n')
    except ValueError:
        fwrite(fw, f'ERROR incorrect argument: "{cmd}"\n')
        
    return True

def mul_proc(fw, cmd, params):
    if len(params) != 3:
        fwrite(fw, f'ERROR Invalid command: "{cmd}"\n')
        return True
    
    try:
        val1 = float(params[1])
        val2 = float(params[2])
        result = val1 * val2
        fwrite(fw, f'RESULT {result}\n')
    except ValueError:
        fwrite(fw, f'ERROR incorrect argument: "{cmd}"\n')
        
    return True
        
def div_proc(fw, cmd, params):
    if len(params) != 3:
        fwrite(fw, f'ERROR Invalid command: "{cmd}"\n')
        return True
    
    try:
        val1 = float(params[1])
        val2 = float(params[2])
        
        if val2 == 0:
            fwrite(fw, f'ERROR Divider shall not be zero: "{cmd}"\n')
            return True
        result = val1 / val2
        fwrite(fw, f'RESULT {result}\n')
    except:
        fwrite(fw, f'ERROR incorrect argument: "{cmd}"\n')
        
    return True
        
def logout_proc(fw, cmd, params):
    if len(params) != 1:
        fwrite(fw, f'ERROR Invalid command: "{cmd}"\n')
        return True
    
    fwrite(fw, 'LOGOUT_ACCEPTED\n')
    print('{params[0]} logged out...')
    
    return False
    
def fwrite(fw, text):
    fw.write(text)
    fw.flush()

main()

# client.py

import socket
import re

PORT_NO = 50500
SERVER = 'localhost'

def main():
    cmd_dict = {'ERROR': error_proc, 'RESULT': result_proc, 'LOGOUT_ACCEPTED': logout_accepted_proc}
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP) as client_sock:
            client_sock.connect((SERVER, PORT_NO))
            with client_sock.makefile('r') as fr, client_sock.makefile('w') as fw:
                if not login_proc(fr, fw):
                    return
                
                while True:
                    cmd_text = input('Calc>').strip()
                    if cmd_text != 'logout':    
                        result, operand1, operand2, operator = parse_input(cmd_text)
                        if not result:
                            print('Invalid input!')
                            continue
                        optext = {'+': 'ADD', '-': 'SUB', '*': 'MUL', '/': 'DIV'}[operator]
                        msg = f'{optext} {operand1} {operand2}\n'
                    else:
                        msg = 'LOGOUT\n'
                        param = None
                    
                    fwrite(fw, msg)
                    
                    response = fr.readline()
                    if not response:
                        break
                    cmd, param = parse_cmd(response)
                    proc = cmd_dict.get(cmd)
                    if not proc:
                        print('Invalid server command: {cmd}')
                        continue
                    if not proc(param):
                        break
                        
            client_sock.shutdown(socket.SHUT_RDWR)
    
    except OSError as oserr:
        print(oserr)
    
def login_proc(fr, fw):
    user_name = input('User name:')
    password = input('Password:')
    
    fwrite(fw, f'LOGIN {user_name} {password}\n')
    response = fr.readline()
    cmd, param = parse_cmd(response)
    
    if cmd != 'LOGIN_ACCEPTED':
        print(f'Error message form server: {param}')
        return False
    
    print('Logged in...')
    
    return True

def error_proc(param):
    match = re.search(':\s*(".*")', param)
    
    msg_text = param[: match.start()]
    msg_cmd = match[1]
    
    print(f'Error message from server: {msg_text} ({msg_cmd})')
    return True
    
def result_proc(param):
    print(param)
    return True
    
def logout_accepted_proc(param):
    print('Logged out')
    return False

def fwrite(fw, text):
    fw.write(text)
    fw.flush()

def get_input(cmd):
    pass

def parse_cmd(s):    
    k = 0
    while k < len(s) and s[k].isspace():
        k += 1
        
    if k == len(s):
        return '', ''
        
    i = k
    while i < len(s) and not s[i].isspace():
        i += 1
    
    cmd = s[k:i]
    if i == len(s):
        return cmd, ''
    
    while i < len(s) and s[i].isspace():
        i += 1
    
    param = s[i:]
    
    return cmd, param.strip()

def parse_input(cmd):
    i = 0
    while i < len(cmd) and '+-*/'.find(cmd[i]) == -1:
        i += 1
        
    if i == len(cmd):
        return False, None, None, None
    
    op1 = cmd[:i].strip()
    op2 = cmd[i + 1:].strip()
    op = cmd[i]
    
    try:
        float(op1)
        float(op2)
    except:
        return False, None, None, None
    
    return True, op1, op2, op
        
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Çok client'lı server uygulamalarında aynı anda birden fazla client ile konuşabilmek için thread modelinin dışında çeşitli modeller
    kullanılabilmektedir. Biz yukarıdaki çok client'lı server örneklerimizde thread modelini ya da benzer proses modelini kullandık. 
    Ancak thread ya da proses modelleri basit olmasına karşın bazı handikapları olan modellerdir. Çok sayıda client söz konusu olduğunda 
    çok fazla sayıda threda ya da prosesin yaratılması ciddi bir sistem kaynağının harcanmasına yol açmaktadır. Bu nedenle client sayısının
    fazla olduğu durumlarda thread ve proses modelleri uygun model olmaktan çıkmaktadır.  
    
    Bu tür modeller şüphesiz işletim sisteminin desteği ile sağlanmaktadır. Genel olarak işletim sistemlerinde buna benzer IO modellerine 
    "asenkron IO (asynchronous IO) ve multiplexed IO modelleri" denilmektedir. Asenkron IO modelleri işletim sisteminden işletim sistemine 
    değişebilmektedir. Çünkü bu konu işletim sisteminin çekirdek gerçekleştirimi ile ilgilidir. Bazı modeller birden fazla işletim sisteminde 
    onların çekirdekleri tarafından gerçekleştirilmiş durumdadır.

    - Windows işletim sisteminde asenkron IO işlemleri için "Overlapped IO", "IO Completion Port" ve "select" modelleri kullanılabilmektedir. 
    Bunlar arasında Windows için en uygun ve en etkin model "IO Completion Port" denilen modeldir. 

    - Linux sistemlerinde "select" modeli, "poll" modeli, "epoll"  modeli ve "asyncio" IO modeli kullanılabilmektedir. Ancak en yüksek performans
    "epoll" modelinden elde edilmektedir. 

    - FreeBSD sistemlerinde "select", "poll" ve "asyncio" modellerinin yanı sıra "kqueue" modeli de kullanılmaktadır. 

    - macOS sistemlerinde de "select" modeli, "poll" modeli ve "kqueue" modelleri kullanılabilmektedir. 

    Python standart kütüphanesinde "select" isimli modülde yukarıdaki asenkron IO modellerinin hepsi bulunmaktadır. Ancak bu modeller
    işletim sisteminin çekirdeğine bağlı olduğu için her işletim sisteminde kullanılamamaktadır. Örneğin epoll modeli Linux için uygun bir
    model olmasına karşın bu model Windows sistemlerinde ya da macOS sistemlerinde bulunmamaktadır. Bu bakımdan nispeten en taşınabilir olan
    model "select" modelidir. Ancak Python standart kütüphanesinde bu aşağı seviyeli asenkron IO modellerini kullanan daha yüksek seviyeli
    "selectors" denilen bir modül de vardır. Biz kursumuzda önce aşağı seviyeli "select" modeli hakkında bilgi vereceğiz. Sonra da yüksek 
    seviyeli "selectors" modelini tanıtacağız. En sonunda da aynı işlemlerin Python diline eklenen "coroutine" mekanizmasıyla gerçekleştirilmesini 
    göreceğiz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                                66. Ders 26/08/2023 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    select modelinde işletim sisteminin "select" isimli bir sistem fonksiyonu bulunur. Programcı bu select fonksiyonuna birden fazla
    soketi verir. (Tabii aslında select fonksiyonu yalnızca soketlerle değil pek çok aygıtla çalışabilmektedir.) select fonksiyonu 
    bu soketleri izler. Eğer soketlerde hiçbir IO olayı yoksa select fonksiyonu thread'i blokede bekletir. Ancak soketlerden en az 
    birinde bir olay olmuşsa (buradaki olay tipik olarak sokete okunacak bilgi gelmesidir) select blokeyi çözer. Böylece select 
    fonksiyonu geri döner. Programcı da hangi soketlerde hangi olayların olduğunu sorgular ve artık bloke oluşmadan işlemlerini yapar. 
    Sonra yeniden select fonksiyonunu çağırır. Yani select fonksiyonu bir döngü içerisinde çağrılmaktadır. Buradaki olay "okuma", 
    "yazma" ya da "exception" işlemleri olabilir. 

    Python'da select modeli şöyle kullanılır:

    1) Bir döngü içerisinde select modülündeki select fonksiyonu çağrılır. Bu fonksiyon tipik olarak üç parametre almaktadır. 
    Fonksiyonun birinci parametresi okuma olayı için izlenecek soket listesini, ikinci parametresi yazma olayı için izlenecek soket listesini, 
    üçüncü parametre ise exception oluşturan eylemler için izlenecek soket listesini belirtir. Genellikle programcılar yalnızca okuma işlemiyle
    ilgilenirler. Dolayısıyla yalnızca fonksiyonun birinci parametresi için liste oluştururlar. İkinci ve üçüncü parametreye boş liste girerler. 
    (Biz burada liste demekle herhangi dolaşılabilir bir nesneyi kastediyoruz. Fonksiyonun bu üç parametresine askında herhangi bir) dolaşılabilir 
    nesne girilebilmektedir.) Fonksiyona isteğe bağlı olarak bir zaman aşımı değeri de son parametrede girilebilmektedir.  Bu durumda fonksiyon 
    soketlerin hiçbirinde bir olay gerçekleşmemişse en kötü olasılıkla burada belirtilen saniye kadar sonra blokeyi çözer. Bu parametrenin 
    girilmemesi zaman aşımı uygulanmayacağı anlamına gelmektedir. Fonksiyonun birinci parametresindeki listeye dinleme soketi (pasif soket) de 
    eklenebilir. Bu durumda bu sokete bir bağlantı isteği geldiğinde bu istek sanki bir okuma olayı gibi değerlendirilmektedir. Programcılar 
    genellikle işin başında bu okuma listesine dinleme soketini yerleştirmektedir. select fonksiyonu üçlü bir demete geri dönmektedir. 
    Demetin birinci elemanı okuma olayı gerçekleşen soketlerin listesini bize verir. Örneğin biz select fonksiyonun birinci parametresine 
    50 tane soket vermiş olalım. Bunların iki tanesine bilgi gemiş olsun. Şimdi select fonksiyonunun geri döndürdüğü demetin ilk elemanında 
    bu iki soketi bulunacaktır. Yani biz bunlardan okuma yapmak istersek artık bloke oluşmayacaktır. Demetin ikinci elemanı yazma olayı 
    gerçekleşen soketleri, üçüncü elemanı ise exception olayı gerçekleşen soketleri belirten listelerdir. Tabii programcı yazma ve exception 
    için zaten boş liste vermişse demetin bu elemanları da boş liste olacaktır. 

    2) select fonksiyonu geri döndüğünde programcı olaya yol açan soketleri gözden geçirerek uygun işlemleri yapmalıdır. Örneğin tipik olarak
    biz soketleri okuma amaçlı izliyorsak bilgi gelen soketler üzerinde recv fonksiyonunu uygulamalıyız. Burada önemli bir nokta dinleme 
    soketi üzerinde okuma olayının gerçekleşip gerçekleşmediğinin sorgulanmasıdır. Eğer dinleme soketi üzerinde okuma olayı gerçekleşmişse 
    bu durum yeni bir client'ın bağlanma isteğini belirtmektedir. Bu durumda bizim dinleme soketi ile accept işlemini yapmamız ve bağlantıdan 
    elde ettiğimiz soketi yeniden okuma olay listesine dahil etmemiz gerekir. 

    3) Bir client soketi kapattığında bu durum select fonksiyonunda sanki okuma olayı gibi ele alınmaktadır. Tabii bu soketten okuma 
    yapıldığında artık 0 byte okunacak yani recv metodu boş bytes nesnesi ile geri dönecektir. Programcının da bu durumda artık o soketi 
    okuma listesinden çıkarması gerekir.  

    Aşağıdaki örnekte aşağı seviyeli select modelinin örnek uygulaması görülmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

# server.py

import socket
import select

PORT_NO = 55555

def main():
    read_socks = []
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
            server_sock.bind(('', PORT_NO))
            server_sock.listen(8)
            
            read_socks.append(server_sock)
            
            print('waiting for client...')
            while True:
                rsocks, _, _ = select.select(read_socks, [], [])
                
                for sock in rsocks:
                    if sock == server_sock:
                         client_sock, (client_addr, client_port) = server_sock.accept()
                         print(f'connected with client {client_addr}:{client_port}')
                         read_socks.append(client_sock)
                    else:
                        text = sock.recv(1024).decode()
                        if len(text):
                            print(text)
                        else:
                            read_socks.remove(sock)
                            sock.close()
    except OSError as e:
        print(e)
        
main()

# client.py 

import socket

SERVER_NAME = 'localhost'
SERVER_PORT = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
        client_sock.connect((SERVER_NAME, SERVER_PORT))
        print('connected...')
        while True:
            text = input('Enter text:')
            client_sock.send(text.encode())
            if text == 'quit':
                break
        client_sock.shutdown(socket.SHUT_RDWR)
        
except OSError as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda verdiğimiz örnekte recv işlemi uyguladığımızda okunan byte'ların hangi client'a ilişkin olduğunu bilmemekteyiz. Bu tür 
    durumlarda bağlanana her client için bir veri yapısı oluşturulup onun bilgileri o veri yapısında saklanabilir. Burada bilgilerin 
    bir sözlük içerisinde bulundurulması uygun olacaktır. Sözlüğün anahtarı soket nesnesinden oluşturulur. (Sokey nesneleri hashable 
    nesnelerdir.) Bunların değerleri de client bilgilerinden oluşturulabilir. 

    Aşağıdaki örnekte bir client bağlantısı sağlandığında client'ın bilgileri sözlüğe ikili demet biçiminde yerleştirilmiş ve sonra
    sözlükten alınarak kullanılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

# server

import socket
import select

PORT_NO = 55555

def main():
    read_socks = {}
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
            server_sock.bind(('', PORT_NO))
            server_sock.listen(8)
            
            read_socks[server_sock] = (None, None)
            
            print('waiting for client...')
            while True:
                rsocks, _, _ = select.select(read_socks, [], [])
                
                for sock in rsocks:
                    if sock == server_sock:
                         client_sock, (client_addr, client_port) = server_sock.accept()
                         print(f'connected with client {client_addr}:{client_port}')
                         read_socks[client_sock] = (client_addr, client_port)
                    else:
                        text = sock.recv(1024).decode()
                        if len(text):
                            client_addr, client_port = read_socks[sock]
                            print(f'"{text}" read from client {client_addr}:{client_port}')
                        else:
                            read_socks.pop(sock)
                            sock.close()
    except OSError as e:
        print(e)
        
main()

# client.py

import socket

SERVER_NAME = 'localhost'
SERVER_PORT = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
        client_sock.connect((SERVER_NAME, SERVER_PORT))
        print('connected...')
        while True:
            text = input('Enter text:')
            client_sock.send(text.encode())
            if text == 'quit':
                break
        client_sock.shutdown(socket.SHUT_RDWR)
        
except OSError as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    Python'da asenkron soket işlemlerini kolaylaştırmak için  kendi içlerinde "select", "poll", "epoll", "kqueue" gibi asenkron IO 
    modellerini kullanan ancak ilgili olay gerçekleştiğinde programcının belirlediği fonksiyonu çağıran daha yüksek seviyeli ismine 
    "selectors" denilen bir modül de bulundurulmuştur. Bu modüldeki SelectSelector arka planda "select" modelini, EPollSelector arka planda 
    "epoll" modelini, PollSelector arka planda "poll" modelini ve KqueueSelector ise arka planda "kqueue" modelini kullanmaktadır. Ayrıca 
    bir de modülde DefaultSelector isimli bir sınıf da vardır. Bu sınıf ilgili sistemdeki en uygun selektör nesnesini seçip kullanmaktadır. 
    Bütün Selector sınıflarının kullanım biçimleri aynıdır. Biz burada en uygun seçenek olan DefaultSelctor nesnesini kullanacağız. 
    Selector nesnelerinin kullanımı şöyledir:

    1) Programcı önce selector nesnesini yaratır. Yukarıda da belirttiğimiz gibi bu nesne tipik olarak DefaultSelector sınıfıyla yaratılmalıdır.
    
    2) Programcı bir soket üzerinde olay gerçekleştiğinde çağrılmasını istediği fonksiyonu selector sınıflarının register metotları ile register ettirir.
    Selector sınıflarının register metotları üç parametreden oluşmaktadır. Birinci parametre izlenecek soketi belirtir. İkinci parametre izlenecek 
    olayı belirtmektedir. Bu olay selectors.EVENT_READ, selectors.EVENT_WRITE ya da selectors.EVENT_READ|selectors.EVENT_WRITE biçiminde girilebilir. 
    Yine dinleme soketi üzerinde okuma olayının takip edilmesi aslında yeni bağlantı isteklerinin takip edilmesi anlamına gelmektedir. register 
    metodunun üçüncü parametresi sonraki maddede açıklanacak olan Selector nesnesiyle çağrılan select metodunun geri döndürdüğü SelectorKey isimli sınıf 
    nesnesinin data örnek özniteliğinden elde edeilecek olan bilgiyi belirtir. Bu üçüncü parametre bir fonksiyon olarak da girilebilir. Bu parametre default 
    olarak None değerini almaktadır. 
    
    3) Programcının bir döngü içerisinde selector nesnesinin select metodunu çağırması gerekir. Bu metot yine eğer register ettirilen soketlerin 
    hiçbirinde bir olay gerçekleşmemişse blokede thread'i bekletir. Ancak bu soketlerden en az birinde bir olay gerçekleşmişse geri dönmektedir. 
    select metodunun geri dönüş değeri iki elemanlı demetlerden oluşan bir listedir. Bu listede gerçekleşen olaylara ilişkin bilgiler bulunmaktadır.
    Listeyi oluşturan demetlerin birinci elemanı SelectorKey isimli bir sınıf türünden bir nesnesidir. Bu demetin ikinci elemanı ise mask elemanıdır. 
    Bu mask elemanı bize olayın türünü vermektedir. Bu olay selectors.EVENT_READ, selectors.EVENT_WRITE ya da bunların her ikisi olabilir. 
    Programcı bu listeyi dolaşıp SelectorKey nesnelerinin içerisinden şu bilgileri alabilir:

    fileobj: Bu örnek özniteliği register fonksiyonuna girilen izlenecek soketi belirtmektedir.
    events: register fonksiyonuna girilen ikinci poarametreyi belirtir. 
    data: register metoduna girilen üçüncü parametreyi belirtmektedir. 

    Programcı accept işleminden elde ettiği soketi de yine register ettirerek izlemeye dahil etmelidir.

    4) Bir client soketin kapatılması yine bir okuma işlemi gibi değerlendirilmektedir. Bu durumda programcının client soketi kapatıp
    onu izlemeden çıkartması gerekir. İzlemeden çıkartma işlemi için Selector sınıflarının unregister metotlareı kullanılmaktadır. 
    Bu metodun parametresi izlemeden çıkartılacak soketi belirtir. 

    5) İşlem bitince selector nesnesi sınıfın close metoduyla kapatılır. Selector sınıfları da bağlam yönetim protokolünü desteklemektedir.

    Aşağıdaki Selector sınıflarının kullanımına bir örnek verilmiştir. Burada register fonksiyonun üçüncü parametresini hiç kullanmadık.
    İzleyen paragrafta bu üçüncü parametrenin naısl kullanılacağına yönelik bir örnek de verilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

# server.py 

import socket
import selectors

PORT_NO = 55555

def main():
    try:
        with selectors.DefaultSelector() as selector:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
                server_sock.bind(('', PORT_NO))
                server_sock.listen(8)
                
                selector.register(server_sock, selectors.EVENT_READ)
                  
                print('waiting for client...')
                while True:
                    result = selector.select()
                    for key, mask in result:
                        if key.fileobj == server_sock:
                            client_sock, (client_addr, client_port) = server_sock.accept()
                            print(f'connected with client {client_addr}:{client_port}')
                            selector.register(client_sock, selectors.EVENT_READ)
                        else:
                            text = key.fileobj.recv(1024).decode()
                            if text:
                                print(text)
                            else:               
                                key.fileobj.close()
                                selector.unregister(key.fileobj)
                                       
    except OSError as e:
        print(e)
        
def accept_proc():
    pass
        
main()

# client.py 

import socket

SERVER_NAME = 'localhost'
SERVER_PORT = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
        client_sock.connect((SERVER_NAME, SERVER_PORT))
        print('connected...')
        while True:
            text = input('Enter text:')
            client_sock.send(text.encode())
            if text == 'quit':
                break
        client_sock.shutdown(socket.SHUT_RDWR)
        
except OSError as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda Selector sınıfının register metodunda üçüncü parametre olarak fonksiyon kullanılmasına örnek verilmiştir. Tabii bu fonksiyonların
    Selector nesnelerine erişmesi gerekmektedir. Bunun bir yolu Selector nesnesini global düzeyde oluşturmak olabilir. Diğer bir yolu ise 
    Selector nesnelerini de bu fonksiyonlara parametre olarak aktarmaktır. Biz aşağıdaki örnekte Selecor nesnelerini ve SelectorKey nesnelerini
    bu fonksiyonlara parametre olarak geçirdik.
#------------------------------------------------------------------------------------------------------------------------------------

# server.py 
import socket
import selectors

PORT_NO = 55555

def main():
    try:
        with selectors.DefaultSelector() as selector:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
                server_sock.bind(('', PORT_NO))
                server_sock.listen(8)
                
                selector.register(server_sock, selectors.EVENT_READ, accept_proc)
                  
                print('waiting for client...')
                while True:
                    result = selector.select()
                    for key, mask in result:
                        key.data(selector, key)
                            
    except OSError as e:
        print(e)
        
def accept_proc(selector, key):
        client_sock, (client_addr, client_port) = key.fileobj.accept()
        print(f'connected with client {client_addr}:{client_port}')
        selector.register(client_sock, selectors.EVENT_READ, read_proc)
                        
def read_proc(selector, key):
    text = key.fileobj.recv(1024).decode()
    if text:
        print(text)
    else:
        print('closed')
        key.fileobj.close()
        selector.unregister(key.fileobj)
        
main()

# client.py

iimport socket

SERVER_NAME = 'localhost'
SERVER_PORT = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
        client_sock.connect((SERVER_NAME, SERVER_PORT))
        print('connected...')
        while True:
            text = input('Enter text:')
            client_sock.send(text.encode())
            if text == 'quit':
                break
        client_sock.shutdown(socket.SHUT_RDWR)
        
except OSError as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
                                                    67. Ders 01/09/2023 - Cuma
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
   
    1) Bunun için bir e-posta sunucu programının bulunuyor olması gerekir. Eğer tüm sistemi siz kuruyorsanız bu sunucuyu (server) 
    da sizin kurmanız gerekmektedir. Zaten Windows sistemlerinde, UNIX/Linux sistemlerinde bu sunucular hazır biçimde bulunmaktadır.
    Tabii eğer domain hizmetini aldığınız bir kurum varsa onlar da zaten e-posta hizmeti vermek için hazır e-posta sunucuları 
    bulundurmaktadır. E-posta gönderebilmek için ya da e-posta alabilmek için bizim e-posta sunucusunun adresini biliyor olmamız 
    gerekir. Gönderme işleminde kullanılacak sunucu ile alma işleminde kullanılacak sunucu farklı olabilmektedir. Örneğin CSD'nin 
    e-posta sunucuna "mail.csystem.org" adresiyle erişilebilmektedir. Bu sunucu hem gönderme hem de alma işlemini yapmaktadır. 
    E-posta gönderebilmek için client ptogram ile server program "SMTP (Simple Mail Transfer Protocol)" denilen bir protokolle
    haberleşmektedir. O halde gönderim için bizim e-posta sunucuna bağlanarak SMTP protokolü ile göndereceğimiz e-postayı ona iletmemiz 
    gerekir.

    2) Biz göndereceğimiz e-postayı SMTP protokolü ile e-posta sunucumuza ilettikten sonra bu sunucu hedef e-posta sunucusuna bu 
    e-postayı yine SMTP protokolü ile iletmektedir. E-postayı alan sunucu bunu bir posta kutusu (mail box) içerisinde saklar. 

    3) Karşı taraftaki client program POP3 ya da IMAP protokolü ile kendi e-posta sunucuna bağlanarak posta kutusundaki e-postayı 
    yerel makineye indirir. 

    client ---SMTP---> e-posta sunucusu ---SMTP--> e-posta sunucusu ---POP3/IMAP---> client

    Görüldüğü gibi POP3 ve IMAP protokolleri e-posta sunucusunun posta kutusundaki zaten gelmiş ve saklanmış olan e-postaları yerel 
    makineye indirmek için kullanılmaktadır.
    
    POP3 protokolü RFC 1939 dokümanlarında açıklanmıştır. Protokol kabaca şöyle işlemektedir:

    1) Client program 110 numaralı (ya da 995 numaralı) porttan server'a TCP ile fiziksel olarak bağlanır. 

    2) Protokolde mesajlaşma tamamen text tabanlı ve satırsal biçimde yapılmaktadır. Satırlar CR/LF karakterleriyle sonlandırılmaktadır. 
    Protokolde client'ın gönderdiği her komuta karşı server bir yanıt göndermektedir. (Fiziksel bağlantı sağlandığında da server 
    bir onay mesajı gönderir.) Eğer yanıt olumluysa mesaj "+OK" ile, eğer yanıt olumsuzsa mesaj "-ERR" ile başlatılmaktadır. Yani 
    server'ın client'a gönderdiği mesajın genel biçimi şöyledir:

    +OK [diğer bilgiler] CR/LF
    -ERR [diğer bilgiler] CR/LF

    3) Fiziksel bağlantıdan sonra client program mantıksal olarak server'a login olmalıdır. Login olmak için önce "user name" sonra da 
    "password" gönderilmektedir. User name ve password gönderme işlemi aşağıdaki iki komutla yapılmaktadır. 

    "USER <user name> CR/LF"
    "PASS <password> CR/LF"

    Kullanıcı adı e-posta adresiyle aynıdır. Örneğin biz "test@csystem.org" için e-posta sunucusuna bağlanıyporsak buradaki kullanıcı 
    ismi "test qcsystem.org" olacaktır. Parola e-postalarınızı okumak için kullandığınız paroladır. Sisteme başarılı bir biçimde login 
    olduğumuzu varsayıyoruz. Tipik olarak server bize şu mesajı iletecektir:

    +OK Logged in.

    password yanlış girilmişse yeniden öce user name ve sonra password gönderilmelidir. 
    
    4) Client program LIST komutunu göndererek e-posta kutusundaki mesaj bilgilerini elde eder. LIST komutuna karşılık server önce aşağıdaki
    gibi bir satır gönderir:

    +OK 6 messages:

    Burada server e-posta kutusunda kaç e-posta olduğunu belirtmektedir. Sonra her e-postaya bir numarara vererek onların byte uzunluklarını 
    satır satır iletir. Komut yalnızca '.' içeren bir satırla son bulmaktadır. Örneğin:

    +OK 6 messages:
    1 1565
    2 5912
    3 11890
    4 4920
    5 9714
    6 4932
    .

    5) Belli bir e-posta RETR komutuyla elde edilmektedr. Bu komuta elde edilecek e-postanın index numarası girilir. Örneğin:

    "RETR 2 CR/LF"

    RETR komutuna karşı server önce aşağıdaki gibi bir satır gönderir:

    +OK 5912 octets

    Burada programcı bu satırı parse ederek burada belirtilen miktarda byte kadar soketten okuma yapmalıdır. Anımsanacağı gibi porttan 
    tam olarak n byte okumak TCP'de tek bir recv ile yapılamamaktadır.   

    6) Mesajı silmek için DELE komutu kullanılır. Komuta parametre olarak silinecek mesajın indeks numarası girilmektedir. Örneğin:

    "DELE 3 CR/LF"

    Bu komut uygulandığında server henüz e-postayı posta kutusundan silmez. Yalnızca onu "silinecek" biçiminde işaretler. Silme işlemi QUIT 
    komutuyla oturum sonlandırıldığında yapılmaktadır. Eğer client silme eyleminden pişmanlık duyarsa RSET komutuyla ilk duruma gelir.
    RSET komutu logout yapmaz. Yalnızca silinmiş olarak işaretlenenlerin işaretlerini kaldırır. 

    7) STAT komutu o anda e-posta kutusundaki e-posta sayısını bize vermektedir. Bu komut gönderildiğinde aşağıdaki gibi bir yanıt
    alınacaktır:

    +OK 5 27043

    Burada server e-posta kutusunda toplam 5 e-postanın bulunduğunu ve bunların byte uzunluklarının da 27043 olduğunu söylemektedir. 

    8) Protocol client programın QUIT komutunu göndermesiyle sonlandırılmaktadır. Örneğin:

    "QUIT CR/LF"

    9) POP3 protokolününde client belli bir süre server'a hiç mesaj göndermezse server client'ın soketini kapatıp bağlantıyı
    koperatmektedır. Her ne kadar RFC 1939'da server'ın en azından 10 dakika beklemesi gerektiği söylenmişse de server'ların 
    çoğu çok daha az bir süre beklemektedir. 

    POP3 protokolünde client programın gönderdiği yazısal komutlar için server programın gönderdiği yanıtlar parse edilerek 
    tam gerektiği kadar okuma yapılabilir. Ancak aşağıraki programda biz basitlik sağlamak amacıyla server'dan gelen mesajları 
    başka bir thread ile ele aldık. 

    Aşağıdaki program POP3 komutlarının manuel bir biçimde uygulanabilmesini sağlamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import socket
import threading
import time

SERVER_NAME = 'mail.csystem.org'
SERVER_PORT = 110

def main():
    
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
            client_sock.connect((SERVER_NAME, SERVER_PORT))
            print('connected...')
            
            thread = threading.Thread(target=thread_proc, args=(client_sock, )) 
            thread.start()
            
            while True:
                time.sleep(1)
                cmd = input('POP3>')
                cmd += '\r\n'
                if cmd == 'quit\r\n':
                    break
                client_sock.send(cmd.encode())
            
            client_sock.shutdown(socket.SHUT_RDWR)
        
    except Exception as e:
        print(e)

def thread_proc(sock):
    try:
        while True:
            b = sock.recv(4096)
            if len(b) == 0:
                break
            response = b.decode()
            print(response, end='')
    except Exception as e:
        print(e)
    
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki programda biz server'a TCP ile bağlanıp ona CR/LF ile biten satırlar gönderip onun bize gönderdiği satırları yazdırdık. 
    Aslında bu işlemi yapan zaten "telnet" denilen bir protokol ve bir client program vardır. Telnet protokolü TCP ile karşı tarafa bağlanıp
    oradan gelen yazıları alır. telnet client programı da gelen yazları ekrana yazdırmaktadır. telnet client programının kullanımı şöyledir:

    telnet <host> <port>

    Linux ve macOS sistemlerinde zaten telnet programı default biçimde bulunmaktadır. Ancak Windows sistemlerinde Telnet programını 
    yükleyebilmek için "Programlar ve Özellikler / Windows Özelliklerini Aç ya da Kapat" seçeneğinden Telnet'in seçilmesi gerekir.   
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında Python'un standart kütüphanesinde POP3 protokolünü uygulayan "poplib" isimli hazır modül bulunmaktadır. Bu modülün içerisindeki 
    POP3 isimli sınıf zaten yukarıda açıkladığımız komutları server'a gönderip onun yanıtlarını bize vermektedir. Sınıf şöyle kullanılmaktadır:

    1) Programcı e-posta sunucusunun adresini ve port numarasını vererek POP3 sınıfı türünden nesne yaratır. Ancak __init__ metodu henüz 
    TCP bağlantısını kurmamaktadır.

    2) Programcı POP3 sınıfının user ve pass_ (pass bir anahtar sözcüktür bu nedenle sonuna alt tire eklenmiştir) metotlarıyla login olur. 
    TCP bağlantısı user metodu çarıldığında sağlanmaktadır. user ve pass_ metotları karşı taraftan gelen yanıta ilişkin byte nesneleriyle geri döner. 

    3) list komutu için list metodu kullanılmaktadır. Bu metot bize üç elemanlı bir demet verir. Demetin ilk elemanı LIST komutunun yanıtındaki 
    ilk satırdır. İkinci elemanı bytes nesnelerinden oluşan bir listedir. Üçüncü elemanı ise server'ın bize verdiği e-posta listesindeki byte 
    sayısıdır (Bu sayıya ilk satırdaki byte'lar dahil değildir ancak sonraki satırlardaki CR/LF'ler de bu sayıya dahildir.)

    4) Belli bir mesajı elde etmek için yine sınıfın retr metodu kullanılır. Bu metot da yine üçlü bir demete geri döner. Demetin ilk elemanı 
    yanıtın ilk satırını, diğer elemanı e-posta içeriğini ve son elemanı da ilk satırdan sonraki toplam byte sayısını vermektedir. 
    Burada mesaj içeriği satırlan oluşan bir liste biçiminde verilmiştir. 

    5) Belli bir e-postayı silmek için dele metodu, silinenleri silinmemiş hale getirmek için rset metodu kullanılmaktadır. 

    6) İşlem bittiğinde quit metoduyla iletişim sonlandırılır. 

    Aşağıdaki örnekte bir e-posta sunucusuna POP3 protokolü ile bağlanılıp oradan e-postalar çekilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import poplib

try:
    pop3 = poplib.POP3('mail.csystem.org', 110)
    
    pop3.user('test@csystem.org')
    pop3.pass_('TheBeatles-1962')
    response, msg_list, total_bytes = pop3.list()
    
    for index, size in (b.decode().split() for b in msg_list):
        _, content, _ = pop3.retr(index)
        print(content)
        print('-----------------------------------------------------')
        
    pop3.quit()
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    GMail çok kullanılan bir e-posta hizmetidir. gmail'in e-posta sunucusunun adresi "pop.gmail.com" biçimindedir. Ancak GMail SSL kullandığı
    için GMail'den e-posta okumak için POP3 sınıfı yerine POP3_SSL sınıfı kullanılmalıdır. GMail'in POP3 server'ı 995 numaralı portu kullanmaktadır. 
    Ancak GMail son zamanlarda POP3 erişimini isteğe bağlı hale getirmiştir. Bu nedenle E-Posta hesabına girilip e-posta hesabının "POP3" 
    erişimine e-posta hesabının açılması gerekmektedir. E-Posta hesabının POP3 protokolüne açılması için GMail'den Ayarlara girilir. Oradan 
    üst menüden "Yönlendirme ve POP/IMAP" seçilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import poplib

try:
    pop3 = poplib.POP3_SSL('pop.gmail.com', 995)
    
    pop3.user('csystem1903@gmail.com')
    pop3.pass_('TheLongAndWindingRoad-1969')
    response, msg_list, total_bytes = pop3.list()
    
    for index, size in (b.decode().split() for b in msg_list):
        _, content, _ = pop3.retr(index)
        print(content)
        print('-----------------------------------------------------')
        
    pop3.quit()
except Exception as e:
    print(f'Error: {e}')

#------------------------------------------------------------------------------------------------------------------------------------
    POP3 ya da IMAP protokolü ile e-postaları elde etmek oldukça kolaydır. Ancak asıl zor olan kısım e-posta içerisindeki bilgilerin 
    parse edilmesi ve uygun biçimde gösterilmesidir.
    
    POP3 ve IMAP protokolleri e-postayı yazısal olarak gönderip almaktadır. Pekiyi bir e-postanın içerisinde resim varsa, ses versa yani 
    başka türden bilgiler varsa bu iletim nasıl yapılmaktadır? İşte e-postadaki yazı olmayan olmayan öğeler aslında yazısal biçime dönüştürülüp 
    gönderilmektedir. Alınan e-posta yazısının içerisinde hangi parçanın hangi türden bilgiyi içerdiği bilgisi MIME denilen bir formata 
    göre kodlanmaktadır. MIME (Multipurpose Internet Mail Extensions) çeşitli öğelerin yazısal olarak kodlanması için kullanılan bir tekniktir. 
    O halde e-postanın yazısını alan programcı bunu MIME standardına göre parse etmelidir. Bu parse işlemi şöyle yapılmaktadır:

    1) Programcı email.parser modülündeki Parser sınıfı türünden ya da BytesParser nesnesi türünden bir nesne yaratır.
    
    2) Parser nesnesi ile sınıfın parserbytes metodunu çağırır. Bu metot e-posta mesajının içeriğini parametre olarak almaktadır. Bu metot 
    bize e-posta mesajını temsil eden Message türünden bir nesne vermektedir. 

    3) Artık programcı bu Message türünden MIME kodlanmış mesajın birden fazla parçadan oluşup oluşmadığını kontrol etmelidir. MIME mesajları 
    "text/plain", "text/html", "image/jpeg", "image/gif" gibi parçalardan oluşmaktadır (Tüm MIME türlerini Internet'te bulabilirsiniz.)

    4) Eğer mesaj birden fazla parçadan oluşuyorsa bu parçalar Message sınıfının walk isimli metoduyla elde edilebilir. Mesajın tamamı Message isimli 
    sınıfla temsil edilmiştir. Ancak onun parçaları da Message isimli sınıfla temsil edilmiştir. Programcının artık walk işlemiyle ilgili parçanın türünü 
    tespit etmesi gerekir. Bunun için Message sınıfının get_content_type isimli metodu kullanılmaktadır. 

    5) Mesajın türü tespit edildikten sonra o türün bilgileri Message sınıfının get_payload metodu ile elde edilir. 

    6) E-posta mesajındaki From, To, Subject gibi başlık alanlarını Message sınıfının [...] operatör metodu ile elde edebiliriz. 

#------------------------------------------------------------------------------------------------------------------------------------

import poplib
from email.parser import BytesParser
from PIL import Image

pop3 = poplib.POP3('mail.csystem.org')

pop3.user('test@csystem.org')
pop3.pass_('Csystem-1993')
response, msg_list, total_bytes = pop3.list()

parser = BytesParser()

for index, size in (b.decode().split() for b in msg_list):
    _, content, _ = pop3.retr(index)
    b = b'\n'.join(content)
    message = parser.parsebytes(b)
    
    from_text = message['From']
    subject_text = message['Subject']
    to_text = message['To']
    
    print(f'From: {from_text}')
    print(f'Subject: {subject_text}')
    print(f'To: {to_text}')
    for part in message.walk():
        part_type = part.get_content_type()
        if part_type == 'text/plain':
            text = part.get_payload()
            print(f'Plain Text: {text}')
        elif part_type == 'text/html':
            text = part.get_payload()
            pass
        elif part_type == 'image/jpeg':
            file_name = part.get_filename() 
            data = part.get_payload(decode=True)
            
            with open(file_name, 'wb') as f:
                f.write(data)
          
            """
            image = Image.open(file_name)
            image.show()
            """
    print('-------------------------------------------')            
        
pop3.quit()

#------------------------------------------------------------------------------------------------------------------------------------
                                                        68. Ders 02/09/2023 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    E-Posta göndermek için SMTP (Simple Mail Transport Protocol) isimli uygulama katmanı protokolü kullanılmaktadır. Bu protokol de
    yazısal tabanlıdır. Tipik olarak client program e-posta sunucusuna TCP ile fiziksel olarak bağlanır. Sonra mantıksal biçimde login 
    olur. Daha sonra da e-posta mesajını bir yazı olarak karşı tarafa gönderir. Bu e-posta yazısı bir başlık içermektedir. Başlık ile 
    posta içeriği arasında bir satır boşluk bırakılır. E-Posta içeriği karmaşık öğelere sahip olabilir. Bu durumda içerik MIME olarak kodlanır. 
    SMTP protokolünün güncel versiyonu RFC 5321'de dokğmante edilmiştir:
    
    https://datatracker.ietf.org/doc/html/rfc5321

    SMTP'de de client'ın her bir komutuna karşılık server bir yanıt vermektedir. Verilen yanıtın birer sayısal kodu ve içeriği vardır. 

    Biz bir kullanıcı olarak bir başkasına e-posta gönderebilmek için e-postamızı kendi smtp sunucumuza göndeririz. Bu sunucu e-postayı 
    karşı atarafın sunucusuna göndermektedir. Yani biz e-postayı aslında kendimiz doğrudan karşı tarafa göndermemekteyiz. Bu işlemi 
    bizim hizmet aldığımız sunucu yapmaktadır. 

    Python'da e-posta göndermek için smtplib isimli bir modül bulundurulmuştur. Tipik olarak yapılması gerekenler şunlardır:

    1) Önce SMTP sınıfı türünden ya da SMTP_SSL sınıfı türünden bir nesne yaratılır. Bu sınıfların __init__ metotları bizden e-posta sunucusunun 
    adresini ve port numarasını almaktadır. SMTP protokolünün orijinal port numarası 25'tir. Ancak bugün e-posta sunucuları şifrelemeyi de 
    sağlayan e-postalar için genel olarak 587 portunu kullanmaktadır. E-Posta sunucunuzun hangi portu kullandığını öğrenmelisiniz. Örneğin:

    smtp = smtplib.SMTP('mail.csystem.org', 587)

    2) Bundan sonra programcının SMTP nesnesi yoluyla sınıfın login metodunu çağırarak e-posta sunucusuna mantıksal olarak bağlanması gerekir. 
    login metodu kullanıcı adı ve parolayı parametre biçiminde almaktadır. Örneğin:

    smtp.login('test@csystem.org', 'TheBeatles-1962')

    3) Artık e-posta mesajının metni oluşturulur. SMTP protokolünde aslında e-posta tek bir yazıdan oluşmaktadır. Yazının başında bir başlık 
    kısmı bulunur. Başlık kısmının genel formatı şöyledir:

    FROM: <kimden>
    TO: <kime>
    SUBJECT: <konu>
    DATE: <tarih>

    Bu başlık kısmından sonra bir satır boşluk bırakılmalıdır. Ondan sonra da mesaj metni bulundurulur. Buradaki FROM ve TO alıcının gördüğü 
    bilgilerdir. Yani kullnıcı aslında sanki e-postayı başka birisi göndermiş gibi yapabilir. Örneğin:

    mail_text = """FROM: ali@csystem.org
    TO: csystem1903@gmail.com
    SUBJECT: Test
    DATE: 02/09/2023
                
    This is test
    """

    4) Bundan sonra e-posta SMTP sınıfının sendmail metoduyla yollanır. Bu metot üç parametre almaktadır. Metodun birinci parametresi 
    yollayan kişinin e-posta adresini, ikinci parametresi hedef e-posta adresini ve üçüncü parametresi de e-posta metnini almaktadır. 
    Eğer e-posta birden fazla kişiye yollanacaksa bu durumda metodun ikinci parametresi dolaşılabilir bir nesne (örneğin bir liste) olmalıdır. 
    Birinci parametrede belirtilen e-posta adresi aslında zarfın üzerinde yazılan adrestir. Yani eğer e-posta gönderilemezse bu adrese 
    bildirimde bulunulacaktır. Mesaj başlığında FROM ve TO kısmı tamamen alıcının göreceği bilgilerden oluşmaktadır. Yani bu kısımdaki 
    bu bilgiler doğrulanmamaktadır. Örneğin:

    smtp.sendmail('test@csystem.org', ['csystem1903@gmail.com', 'aslank@csystem.org'], mail_text)

    5) Nihayetinde e-posta gönderimi bittikten sonra sınıfn quit metoduyla işlemler sonlandırılır.

   Aşağıda e-posta göndermeye bir örnek verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import smtplib 

try:
    smtp = smtplib.SMTP('mail.csystem.org', 587)
    smtp.login('test@csystem.org', 'TheBeatles-1962')
    mail_text = """FROM: ali@csystem.org
TO: csystem1903@gmail.com
SUBJECT: Test
DATE: 02/09/2023
CC: aslank@csystem.org;
               
This is test
"""
    
    smtp.sendmail('test@csystem.org', ['csystem1903@gmail.com', 'aslank@csystem.org'], mail_text)
    smtp.quit()
    
except Exception as e:
    print(e)
 
#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi göndereceğimiz e-posta içerisinde yazının dışında başka şeyler de olmasını istiyorsak ne yapmamız gerekir? İşte bu durumda
    POP3 protokolünde de gördüğümüz gibi e-posta içeriğini yazısal biçimde MIME olarak ifade etmemiz gerekir. Bu amaçla email modülünde
    çeşitli sınıflar bulundurulmuştur. Bunun için şu işlemler yapılmalıdır:

    1) Önce email.mime.multipart modülündeki MIMEMultipart isimli sınıf türünden bir nesne yaratılır. Bu nesne parçalardan oluşan e-postanın tamamını 
    temsil etmektedir. Bu nesne üzerinde as_string metodu tüm MIME dokümanını yazısal olarak, as_bytes metodu ise byte dizisi olarak bize 
    vermektedir. E-postaya ilişkin FROM, To, Subject bilgileri bu MimeMultipart nesnesinin [...] operatörü yolu ile belirtilmektedir. 
    Örneğin:

    mime_multipart = MIMEMultipart()
    mime_multipart['From'] = 'test@csystem.org'
    mime_multipart['To'] = 'test@csystem.org;aslank@csystem.org'
    mime_multipart['Subject'] = 'MIME Test E-Postası'

    2) Daha sonra çeşitli modüllerde bulunan MIMEText, MIMEImage, MIMEAudio, MIMEApplication gibi sınıflar yoluyla e-postanın ilgili kısımları 
    MIME olarak ifade edilir. Bu kısımlar ana e-postaya MIMEMultipart nesnesinin attach metodu çağrılarak eklenmektedir. Örneğin:

    text_msg1 = """
    Bugün hava çok güzeldi. Ben de parka gittim. Orada dinlendim.
    """

    mime_text1 = MIMEText(text_msg1)
    mime_multipart.attach(mime_text1)

    with open('AbbeyRoad.jpg', 'rb') as f:
        image_data = f.read()
    
        mime_image = MIMEImage(image_data)
        mime_image.add_header('Content-Disposition', 'attachment', filename='AbbeyRoad.jpg')
#------------------------------------------------------------------------------------------------------------------------------------

import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.image import MIMEImage
from email.mime.text import MIMEText

smtp = smtplib.SMTP('mail.csystem.org', 587)

response_code, response_text = smtp.login('test@csystem.org', 'Csystem-1993')

mime_multipart = MIMEMultipart()
mime_multipart['From'] = 'test@csystem.org'
mime_multipart['To'] = 'test@csystem.org;aslank@csystem.org'
mime_multipart['Subject'] = 'MIME Test E-Postası'

text_msg1 = """
Bugün hava çok güzeldi. Ben de parka gittim. Orada dinlendim.
"""

mime_text1 = MIMEText(text_msg1)
mime_multipart.attach(mime_text1)

with open('AbbeyRoad.jpg', 'rb') as f:
    image_data = f.read()
   
mime_image = MIMEImage(image_data)
mime_image.add_header('Content-Disposition', 'attachment', filename='AbbeyRoad.jpg')

text_msg2 = """
Bu resmi de yolluyorum. Bu fotoğraf Londra'da Abbey Road denilen semtte çekilmiştir.'
"""

mime_text2 = MIMEText(text_msg2)
mime_multipart.attach(mime_text2)

mime_multipart.attach(mime_image)

result = smtp.sendmail('test@csystem.org', ['test@csystem.org', 'aslank@csystem.org'], mime_multipart.as_string())

smtp.quit()

#------------------------------------------------------------------------------------------------------------------------------------
    Gmail yoluyla e-posta gönderilecekse SMTP server adresi olarak "gmail.smtp.com" kullanılmalıdır. GMail SSL kullanmaktadır. Dolayısıyla 
    SMTP nesnesini SMTP_SSL sınıfı ile yaratmalıyız. Gmail SMTP için 465 numaralı portu kullanmaktadır. 

    Aşağıda Gmail ile e-posta gönderme örneği verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.image import MIMEImage
from email.mime.text import MIMEText

smtp = smtplib.SMTP('mail.csystem.org', 587)

response_code, response_text = smtp.login('test@csystem.org', 'TheBeatles-1962')

mime_multipart = MIMEMultipart()
mime_multipart['From'] = 'test@csystem.org'
mime_multipart['To'] = 'csystem1903.gmail.com;aslank@csystem.org'
mime_multipart['Subject'] = 'MIME Test E-Postası'

text_msg1 = """
Bugün hava çok güzeldi. Ben de parka gittim. Orada dinlendim.
"""

mime_text1 = MIMEText(text_msg1)
mime_multipart.attach(mime_text1)

with open('AbbeyRoad.jpg', 'rb') as f:
    image_data = f.read()
   
mime_image = MIMEImage(image_data)
mime_image.add_header('Content-Disposition', 'attachment', filename='AbbeyRoad.jpg')

text_msg2 = """
Bu resmi de yolluyorum. Bu fotoğraf Londra'da Abbey Road denilen semtte çekilmiştir.'
"""

mime_text2 = MIMEText(text_msg2)
mime_multipart.attach(mime_text2)

mime_multipart.attach(mime_image)

result = smtp.sendmail('test@csystem.org', ['csystem1903@gmail.com', 'aslank@csystem.org'], mime_multipart.as_string())

smtp.quit()

#------------------------------------------------------------------------------------------------------------------------------------
                                                69. Ders 08/09/2023 - Cuma
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    UDP (User Datagram Protocol) anımsanacağı gibi "bağlantısız (connectionless)", "datagram tabanlı (datagram)", "güvenilir olmayan (unreliable)"
    ancak hızlı bir protokoldür. TCP'ye göre oldukça seeyrek kullanılmaktadır. Özellikle periyodik uzun olmayan mesajların hızlı iletilmesi 
    gerektiğinde tercih edilmektedir. Bu protokolde bir bağlantı yapılmadığı için akış kontrolü uygulanmaz. Gönderici taraf bilginin karşı 
    tarafa gidip gitmediğini bilemez. Zaten bu mekanizmalardan yoksun olması onu hızlı yapmaktadır. UDP haberleşme paket tabanlıdır. Buradaki
    pakete "datagram" da denilmektedir. Paket tabanlı haberleşmede bir taraf diğer tarafa bir grup bilgiyi bir paket olarak gönderir. Karşı 
    taraf da bunu paket olarak alır. 

    Anımsanacağı gibi TCP client-server tarzı bir çalışma modelini bize uygulatmaktadır. TCP'de bağlantıyı kabul eden (accept yapan) tarafa
    "server", bağlantı kurmak isteyen tarafa ise "client" denilmektedir. UDP bağlantısız bir protokol olduğuna göre burada client ve server 
    rolleri açık değildir. Ancak yine de genel olarak mesajları alıp iş yapan tarafa "server", mesaj gönderen tarafa ise "client" denilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    UDP server programın organizasyonu şöyledir:

    1) Server program önce bir UDP soketi yaratır. UDP soket yaratılırken soket fonksiyonun ikinci parametresi socket.SOCK_DGRAM geçilmelidir. 
    Üçüncü parametre girilmeyebilir ya da socket.IPPROTO_UDP biçiminde girilebilir. Örneğin:

    server_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)

    2) Server program soket bind etmelidir. Her ne kadar bir bağlantı olmasa da client programlar datagram paketlerini gönderirken bir IP adresi 
    ve portu belirtirler. Yani server program yine bir portla kendisini ilişkilendirmelidir. 

    3) Artık server Socket sınıfının recvfrom isimli metoduyla gelen datagram paketini elde edebilir. recvfrom metodu default durumda blokeye 
    yol açmaktadır. Yani herhangi bir kişiden paket gelene kadar recvfrom akışı bekletmektedir. Metodun birinci parametresi mesajın uzunluğunu 
    belirtir. Eğer mesaj uzunluğu için girilen parametre gönderilen UDP paketinin uzunluğundan kısa ise default durumda belirtilen 
    sayıda byte kırpılararak okuma yapılmaktadır. İkinci parametre mesajın alınma biçimine ilişkin bazı flag değerlerini alabilmektedir. 
    İkinci parametre hiç girilmeyebilir. recvfrom metodunun geri dönüş değeri iki elemanlı bir demettir. Demetin birinci elemanı UDP 
    paketindeki bilgileri içeren bytes nesnesdir. Demetin ikinci elemanı da iki elemanlı bir demettir. Bu iki elemanlı demetin ilk elemanı 
    paketi gönderen tarafın IP adresini, ikinci elemanı ise kaynak port numarasını belirtmektedir. Bu durumda recvfrom metodu aşağıdaki 
    gibi kullanılmalıdır:

    b, (ip, port) = server_sock.recvfrom(8192)
    
    4) Server işlemler bitirince açtığı soketi kapatmalıdır. UDO soketlerde shutdown işlemi yoktur. 

    Aşağıda bir UDP server örneği verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

PORT_NO = 55555

import socket

try:  
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as server_sock:
        server_sock.bind(('', PORT_NO))
        
        print('waiting datagrams...')
        while True:
            b, (ipaddr, port) = server_sock.recvfrom(8192)
            print(f'Message received from {ipaddr}:{port} "{b.decode()}"')
            
except OSError as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    UDP client programın da organizasyonu şöyledir:

    1) UDP client program da önce bir UDP soket yaratır. Yine soket yaratılırken soket türü socket.SOCK_DGRAM girilmelidir. 

    2) Client program isteğe başlı olarak bind işlemi yapabilir. Örneğin client belli bir yerel porttan bilgiyi göndermek 
    isteyebilir. Ancak genel olarak böyle bir durum sıklıkla arzu edilmemektedir. 

    3) Client server'a socket sınıfının sendto metoduyla UDP paketini gönderir. sendto metodunun iki parametresi vardır. (sendto üç 
    parametreli bir biçimde de kullanılabilmektedir. Bu durumda metot bir flags parametresi de alır.) Metodun birinci parametresi 
    gönderilecek UDP paketini oluşturan bytes nesnesidir. İkinci parametre server IP adresi ve port numarasını içeren iki elemanlı bir 
    demettir. Örneğin:

    sock.sendto(b, (SERVER_NAME, PORT_NO))

    4) Client işlemn bitince close metodu ile soketi kapatmalıdır. 

    Aşağıda örnek client program verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

SERVER_NAME = '127.0.0.1'
PORT_NO = 55555

import socket

try:  
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as client_sock:
        while True:
            text = input('Message Text:')
            client_sock.sendto(text.encode(), (SERVER_NAME, PORT_NO))
            if text == 'quit':
                break
            
except OSError as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Tabii aslında recvform ve sendto metotları hem client hem de server program tarafından uygulanabilir. Örneğin server recvfrom 
    metodu ile client'tan bir bilgi alıp ona sento metoduyla yanıtı yollayabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

# server.py

PORT_NO = 55555

import socket

try:  
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as server_sock:
        server_sock.bind(('', PORT_NO))
        
        print('waiting datagrams...')
        while True:
            b, (ipaddr, port) = server_sock.recvfrom(8192)
            text = b.decode()
            print(f'Message received from {ipaddr}:{port} "{text}"')
            if text != 'quit':
                rev_text = text[::-1]
                server_sock.sendto(rev_text.encode(), (ipaddr, port))
            
except OSError as e:
    print(e)
    
# client.py 

SERVER_NAME = '127.0.0.1'
PORT_NO = 55555

import socket

try:  
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as client_sock:
        while True:
            text = input('Message Text:')
            client_sock.sendto(text.encode(), (SERVER_NAME, PORT_NO))
            if text == 'quit':
                break
            b, (ipaddr, port) = client_sock.recvfrom(8192)
            print(f'Message received from server: {b.decode()}')
            
except OSError as e:
    print(e)       

#------------------------------------------------------------------------------------------------------------------------------------
    UDP server programlarında server'a pek çok client UDP paketi gönderiyor olabilir. Server bir UDP paketini aldığında onu kendisi işlerse
    yeni gelen paketleri kaçırabilir. Kaçırmanın ötesinde paketi gönderen client yanıtı geç alabilir. Bu tür durumlarda server UDP paketini
    aldıktan sonra onun işlemesini bir thread'e havale edebilir. Bu tür thread'lerin o anda yaratılması yavaşlığa yol açmaktadır. Aynı durum 
    TCP uygulamalarında da karşımıza çıklabilmektedir. TCP server bir client'tan bilgiyi aldığında eğer thread modelini kullanmıyorsa
    bilgiyi işlerken gecikmeye yol açabilir. İşte bu tür durumlarda genel olarak "thread havuzu (thread pool)" denilen mekanizma kullanılmaktadır. 
    TCP ya da UDP server bilgiyi okuduğunda ona yanıt vermek için bir thread (ya da process) yaratırsa bu thread'in yaratılma ve yok edilme
    işlemindeki zamansal maliyet faydayı ortadan kaldırabilmektedir. Thread havuzları bu bu maliyeti elimine etmek için düşünülmüş bir 
    organizasyondur. Thread havuzunda zaten yaratılmış olan belli miktarda thread suspend durumda havuzda bekletilmektedir. Server 
    bilgiyi işlemek için havuzdaki zaten yaratılmış ama suspend durumda olan thread'leri kullanır. Böylece gelen mesajın işlenmesi hızlıca 
    yapılabilmektedir. Java, .NET, Qt gibi framework'lerdeki thread havuzları duruma göre suspend durumdaki thread sayısını otomatik artırıp 
    azaltabilmektedir. 

    CPython yorumlayıcısında GIL yüzünden thread'ler bu bakımdan etkin biçimde kullanılamamaktadır. Daha önceden de görüldüğü gibi thread yerine
    çoğu kez aslında yüksek maaliyeti olan proses yaratmak CPython için daha iyi bir çözüm olabilmektedir. Pyton'a belli bir süreden sonra 
    proses temelinde çalışan bir thread havuzu mekanizması ilkel düzeyde de olsa eklenmiştir. Ancak programcı zaten üretici-tüketici 
    problemleri için hazır bulundurulmuş Queue sınıfından da bu bağlamda faydalanabilir. Yani örneğin belli miktarda proses (ya da thread) 
    yaratılıp ortak bir Queue nesnesini kullanabilir. Böylece server gelen isteği kuyruğa atar. Client'ların herhangi biri kuyruktan mesajı 
    alarak işleyebilir. Tabii proseslerle çalışma thread'lerle çalışmaya göre bazı sıkıntılara da sahiptir. Python'da ayrıca ThreadPoolExecutor 
    isimi thread havuzu düşünülmüş thread mekanizmasını kullanan bir sınıf da bulunmaktadır. Ancak bu sınıf CPython yorumlayıcında CPU 
    yoğun işlemlerde GIL yüzünden zayıf bir performans göstermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Soket işlemlerini bitirdikten sonra şimdi Python standart kütüphanesindeki itertools modülünde buunan bazı yardımcı fonksiyonları 
    göreceğiz. Ancak ondan önce Python kursunda görmüş olduğumuz birkaç fonksiyonu hatırlatmak istiyoruz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi map built-in fonksiyonu bir fonksiyon ve bir dolaşılabilir nesneyi alıp bize bir dolaşım nesnesi veriyordu. Bu 
    dolaşım nesnesini dolaştığımızda aslında biz map fonksiyonuna verdiğimiz dolaşılabilir nesnenin yine  map fonksiyonuna verdiğimiz fonksiyona 
    sokulmasından elde edilen geri dönüş değerlerini elde ederiz. Tabii benzer işlem içlemlerle ya da üretici ifadelerle de yapılabilmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

def foo(x):
    return x * x

a = [1, 2, 3, 4, 5]

m = map(foo, a)

for x in m:
    print(x, end=' ')
    
print()

# eşdeğeri 

for x in (foo(y) for y in a):
    print(x, end=' ')

#------------------------------------------------------------------------------------------------------------------------------------
    Örneğin map fonksiyonuyla biz yazıların uzunluklarını kısa bir ifadeyle elde edebiliriz.
#------------------------------------------------------------------------------------------------------------------------------------

names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']    

for x in map(len, names):
    print(x, end= ' ')

#------------------------------------------------------------------------------------------------------------------------------------
    map fonksiyonu üretici bir fonksiyon olarak çok basit biçimde aşağıdaki gibi yazılabilir.
#------------------------------------------------------------------------------------------------------------------------------------

def mymap(f, iterable):
    for elem in iterable:
        yield f(elem)
    
names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

a = list(mymap(len, names))
print(a)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Bu tür fonksiyonları üretici fonksiyon olarak değil de dolaşılabilir bir sınıf olarak yazmak daha hızlı bir çalışmaya yol açmaktadır. 
    Gerçekten de standart kütüphanede map aslında bir sınıf olarak yazılmıştır. Aşağıda map fonksiyonunun bir sınıf olarak yazımına 
    örnek verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

class mymap:
    def __init__(self, f, iterable):
        self.f = f
        self.iterator= iter(iterable)
   
    def __iter__(self) :
       return self
       
    def __next__(self):
        return self.f(next(self.iterator))
       
names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

iterator = mymap(len, names)
a = list(iterator)          
print(a)

a = list(iterator)          
print(a)
    
#------------------------------------------------------------------------------------------------------------------------------------
    filer isimli built-in fonksiyon benzer biçimde çalışmaktadır. Ancak fonksiyonun geri dönüş değeri True olan elemanları bize verir. 
    filter fonksiyonu da bize dolaşılabilir bir nesne vermektedir. Tabii filter eşdeğeir de yine bir üretici ifade ile oluşturulabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']    

for x in filter(lambda x: len(x) > 4, names):
    print(x, end= ' ')
    
print()

# eşdeğeri 

for x in (y for y in names if len(y) > 4):
    print(x, end= ' ')

#------------------------------------------------------------------------------------------------------------------------------------
    filer fonksiyonu da basit bir biçimde üretici fonksiyonla aşağıdaki gibi yazılabilir.
#------------------------------------------------------------------------------------------------------------------------------------

def myfilter(f, iterable):
    for elem in iterable:
        if f(elem):
            yield elem
       
names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

for name in filter(lambda s: s[0] == 'a', names)    :
    print(name)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Tabii filter fonksiyonu da aslında bir sınıf biçiminde yazılmıştır. Aşağıda filet fonksiyonunun dolaşılabilir bir sınıf biçiminde 
    yazımına örnek verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

class myfilter:
    def __init__(self, f, iterable):
        self.f = f
        self.iterator = iter(iterable)
        
    def __iter__(self):
        return self
    
    def __next__(self):
        while True:
            val = next(self.iterator)
            if self.f(val):
                return val
            
names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

for name in myfilter(lambda s: s[0] == 'a', names)    :
    print(name)
 
#------------------------------------------------------------------------------------------------------------------------------------
    Built-in zip fonksiyonu ise dolaşılabilir nesneleri alarak onların karşılıklı elemanlarından oluşan demetleri veren bir dolaşım nesnesi
    geri döndürmektedir. unzip işlemi de yine zip fonksiyonu ile yapılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

a = [1, 2, 3, 4, 5]
b = ['ali', 'veli', 'selami', 'ayşe', 'fatma', 'süleyman']

z = zip(a, b)

for x, y in z:
    print(x, y)
    
c = list(zip(a, b))
print(c)

numbers, names = zip(*c)
print(numbers)
print(names)
    
#------------------------------------------------------------------------------------------------------------------------------------
    İşte itertools modülü içerisinde built-in map, filter, zip gibi fonksiyonlara bezner bazı dolaşılabilir nesnelerle kullanılabilen faydalı 
    fonksiyonlar bulunmaktadır.

    itertools modülündeki accumulate fonksiyonu bir dolaşılabilir nesneyi alır bize başka bir dolaşım nesnesi verir. Biz accumulate 
    fonksiyonun verdiği dolaşım nesnesini dolaştığımızda elemanların kümülatif toplamlarını elde ederiz. Fonksiyonunun parametrik yapısı 
    şöyledir:

    itertools.accumulate(iterable, func = operator.add, *, initial = None)

    Fonksiyon tipik olarak tek argümanla çağrılmaktadır. Örneğin:

    a = [1, 2, 3, 4, 5]

    Buradaki kümülatif toplamlar sırasıyla 1, 3, 6, 10 ve 15'tir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

a = [1, 2, 3, 4, 5]

result = itertools.accumulate(a)

for x in result:
    print(x, end=' ')       # 1 3 6 10 15

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte isimlerin karakter uzunluklarının kümülatif toplamları bir liste olarak elde edilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

a = list(itertools.accumulate(map(len, names)))    
print(a)

#------------------------------------------------------------------------------------------------------------------------------------
    accumulate fonksiyonun initial parametresi ilk toplam değerini belirtmektedir. Dolaşım sırasında önce initial parametresiyle belirtilen 
    değer elde edilir. Sonra dolaşıldıkça bu değerin üzerine eklenen değerler elde edilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

a = [1, 2, 3, 4, 5]

result = itertools.accumulate(a, initial=10)

for x in result:
    print(x, end=' ')       # 10 11 13 16 20 25

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında accumulate fonksiyonun ikinci parametresi iki parametreli bir fonksiyon olarak da girilebilir. Bu durumda bu fonksiyonun 
    ilk parametresi kümülatif değer, ikinci parametresi dolaşılabilir nesnedeki sıradaki değerdir. Böylece biz örneğin kümülatif toplamları 
    değil, kümülatif çarpımları da bulabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

a = [1, 2, 3, 4, 5]

result = itertools.accumulate(a, lambda cum, x: cum * x, initial=10)

for x in result:
    print(x, end=' ')   # 10 10 20 60 240 1200 
    
#------------------------------------------------------------------------------------------------------------------------------------
    Tabii biz fonksiyon girdiğimizde initial parametresini kullanmak zorunda değiliz. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

a = [1, 2, 3, 4, 5]

result = itertools.accumulate(a, lambda cum, x: cum * x)

for x in result:
    print(x, end=' ')   # 1 2 6 24 120 
    
#------------------------------------------------------------------------------------------------------------------------------------
    Python'un "Standard Library" dokümanında accumulate fonksiyonun muhtemel gerçekleştirimi aşağıdaki gibi verilmiştir:
#------------------------------------------------------------------------------------------------------------------------------------

def accumulate(iterable, func=lambda cum, val: cum + val, *, initial=None):
    it = iter(iterable)
    total = initial
    if initial is None:
        try:
            total = next(it)
        except StopIteration:
            return
    yield total
    for element in it:
        total = func(total, element)
        yield total
        
result = accumulate(a, lambda cum, x: cum * x)

for x in result:
    print(x, end=' ')   # 10 10 20 60 240 1200 
    
#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki chain isimli fonksiyon bizden birden fazla dolaşılabilir nesneyi parametre olarak alır. Sonra bize yeni bir 
    dolaşım nesnesi verir. chain fonksiyonun verdiği dolaşım nesnesi dolaşıldığında sanki bizim fonksiyona verdiğimiz dolaşılabilir nesneler
    tek bir dolaşılabilir nesneymiş gibi sırasıyla dolaşılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

a = [1, 2, 3, 4, 5]
b = ('ali', 'veli', 'selami')
c = 'ankara'

result = itertools.chain(a, b, c)    
for x in result:
    print(x, end=' ')    # 1 2 3 4 5 ali veli selami a n k a r a 

#------------------------------------------------------------------------------------------------------------------------------------
    Standart Kütüphane dokümantasyonunda muhtemel bir gerçekleştirim aşağıdaki gibi verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

def chain(*args):
    for iterable in args:
        for x in iterable:
            yield x
            
result = chain(a, b, c)    
for x in result:
    print(x, end=' ')       # 1 2 3 4 5 ali veli selami a n k a r a 

#------------------------------------------------------------------------------------------------------------------------------------
    Her ne kadar dokümantasyonda chain fonksiyonun muhtemel gerçekleştirimi üretici fonksiyon biçiminde verilmişse de aslında CPython'da
    gerçekleştirim chain isimli bir dolaşılabilir sınıf biçiminde yapılmıştır. Aşağıda chain işlemini yapan dolaşılabilir bir sınıf 
    örneği de verilmiştir.     
#------------------------------------------------------------------------------------------------------------------------------------

class chain:
    def __init__(self, *args):
        self.args = args
        self.iterator = iter(self.args[0]) if args else iter(args)
        self.index = 0
        
    def __iter__(self):
        return self
    
    def __next__(self):
        try:
            result = next(self.iterator)
        except StopIteration:
            self.index += 1
            if self.index < len(self.args):
                self.iterator = iter(self.args[self.index])
                result = next(self.iterator)
            else:
                raise StopIteration
        
        return result

a = [1, 2, 3, 4, 5]
b = ('ali', 'veli', 'selami')
c = 'ankara'
d = [1.2, 3.4, 5.5]

result = chain(a, b, c, d)    
for x in result:
    print(x, end=' ')
       
#------------------------------------------------------------------------------------------------------------------------------------
    Ayrıca chain isimli sınıfın from_iterable isimli bir static metodu da vardır. Bu metodun farkı iterable nesneleri ayrı nesneler olarak değil
    tek bir iterable nesne biçiminde almasıdır. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

a = [1, 2, 3, 4, 5]
b = ('ali', 'veli', 'selami')
c = 'ankara'
d = [1.2, 3.4, 5.5]

iterables = [a, b, c, d]
result = itertools.chain.from_iterable(iterables)  
  
for x in result:
    print(x, end=' ')

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii aslında biz aynı şeyi chain fonksiyonunu çağırırken *'lı argüman kullanarak da sağlayabiliriz.
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

a = [1, 2, 3, 4, 5]
b = ('ali', 'veli', 'selami')
c = 'ankara'
d = [1.2, 3.4, 5.5]

iterables = [a, b, c, d]
result = itertools.chain(*iterables)  
  
for x in result:
    print(x, end=' ')

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda yazdığımız sınıfa fromm_iterable metodunu aşağıdaki gibi ekleyebiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

class chain:
    def __init__(self, *args):
        self.args = args
        self.iterator = iter(self.args[0]) if args else iter(args)
        self.index = 0
        
    def __iter__(self):
        return self
    
    def __next__(self):
        try:
            result = next(self.iterator)
        except StopIteration:
            self.index += 1
            if self.index < len(self.args):
                self.iterator = iter(self.args[self.index])
                result = next(self.iterator)
            else:
                raise StopIteration
        
        return result
    
    @staticmethod
    def from_iterable(itreables):
        return chain(*iterables)

a = [1, 2, 3, 4, 5]
b = ('ali', 'veli', 'selami')
c = 'ankara'
d = [1.2, 3.4, 5.5]

result = chain.from_iterable(iterables)    
for x in result:
    print(x, end=' ')

#------------------------------------------------------------------------------------------------------------------------------------ 
                                                        70. Ders 15/09/2023 - Cuma        
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki combinations isimli fonksiyonu biz aslında Python derslerinde görmüştük. Bu fonksiyon bir dolaşılabilir nesnenin 
    n'li kombinasyonlarını demet olarak veren bir dolaşım nesnesi vermektedir. Örneğin [1, 2, 3, 4, 5] gibi dolaşılabilir bir nesnede 
    3'lü kombinasyonlar şöyle elde edilebilir:

    a = [1, 2, 3, 4, 5]
    result = itertools.combinations(a, 3)
    for x in result:
        print(x)
#------------------------------------------------------------------------------------------------------------------------------------

import itertools 

s = 'ABCDEF'

iterator = itertools.combinations(s, 3)

for t in iterator:
    print(*t, sep='')
    
#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki permutations isimli fonksiyon da combinations fonksiyonuyla aynı parametrelere sahiptir. Ancak iterable nesnenin
    permütasyonlarını elde etmekte kullanılır. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools 

s = 'ABCDEF'

iterator = itertools.permutations(s, 3)

for t in iterator:
    print(*t, sep='')
    
#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki combinations_with_replacement isimli fonksiyon yine dolaşılabilir nesnenin kombinasyonlarını verir ancak 
    kombinasyonlar aynı elemanladan da oluşabilmektedir. Örneğin 'ABC' yazısının bu biçimdeki ikili kombinasyonları AA AB AC BB BC CC 
    biçimindedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

s = 'ABC'
result = itertools.combinations_with_replacement(s, 3)
for x in result:
    print(x)
     
#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki compress isimli fonksiyon bizden iki dolaşılabilir nesne alır. İkinci dolaşılabilir nesne bool değerler içerir. 
    (Eüer bu nesnedeki değerler bool türden değilse bool türe fonksiyon tarafından dönüştürülmektedir.) Fonksiyon bize bir dolaşım nesnesi  
    verir. Ancak bu dolaşım nesnesi dolaşıldığında ikinci dolaşılabilir nesnedeki True olan elemanlara karşı gelen birinci dolaşılabilir 
    nesnedeki elemanlar elde edilecektir. Fonksiyona girilen iki dolaşılabilir nesnenin aynı uzunlukta olması gerekmez. Kısa olan bittiğinde 
    işlem bitirilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

s = ['ali', 'veli', 'selami', 'ayşe', 'fatma']
selector = [True, False, True, True, False]

result = itertools.compress(s, selector)            # ali selami ayşe 
for x in result:
    print(x, end=' ')
     
#------------------------------------------------------------------------------------------------------------------------------------
    Her ne kadar standart kütüphanedeki compress bir sınıf olarak yazılmışsa da standart kütüphane dokümantasyonunda muhtemel bir 
    gerçekleştirim aşağıdaki gibi verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

def compress(data, selectors):
    return (d for d, s in zip(data, selectors) if s)       
        
s = ['ali', 'veli', 'selami', 'ayşe', 'fatma']
selector = [True, False, True, True, False]

result = compress(s, selector)    # ali selami ayşe 
for x in result:
    print(x, end=' ')
           
#------------------------------------------------------------------------------------------------------------------------------------
    compress fonksiyonunu biz de dolaşılabilir bir sınıf biçiminde aşağıdaki gibi yazabiliriz.
#------------------------------------------------------------------------------------------------------------------------------------

class compress:
    def __init__(self, iterable, selectors):
        self.iterable = iterable
        self.selectors = selectors
        self.zipped = zip(self.iterable, self.selectors)
        
    def __iter__(self):
        return self
    
    def __next__(self):
        while True:
            x, y = next(self.zipped)
            if y:
                return x
        
s = ['ali', 'veli', 'selami', 'ayşe', 'fatma']
selector = [True, False, True, True, False]

result = compress(s, selector)    # ali selami ayşe 
for x in result:
    print(x, end=' ')
    
#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki count fonksiyonu belli bir değerden başlayarak belli artımlarla sonsuz döngü içerisinde değer veren bir
    dolaşım nesnesi vermektedir. Artım değeri belirtilmezse default 1'dir. Başlangıç değeri verilmezse default 0'dır. Bu fonksiyonun 
    sonsuz döngü oluşturduğuna dikkat ediniz. Sizin bir biçimde bu döngüyü kırmanız gerekebilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

c = itertools.count(10, 2)

for x in c:
    print(x, end=' ')
    if x == 50:
        break

#------------------------------------------------------------------------------------------------------------------------------------
    count fonksiyonun muhtemel gerçekleştirimi standart kütüphane dokümanlarında aşağıdaki gibi verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

def count(start=0, step=1):
    n = start
    while True:
        yield n
        n += step
        
for x in count():
    print(x, end=' ')        
    if x == 10:
        break

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii count fonksiyonu aslında standart kütüphanede üretici fonksiyon olarak değil bir sınıf olarak yazılmıştır. count fonksiyonunu
    sınıf biçiminde aşağıdaki gibi yazabiliriz.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    count fonksiyonun muhtemel gerçekleştirimi standart kütüphane dokümanlarında aşağıdaki gibi verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

class mycount:
    def __init__(self, start = 0, step = 1):
        self.n = start
        self.step = step
        
    def __iter__(self):
        return self
    
    def __next__(self):
        self.n += self.step
        return self.n - self.step
        
names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

for t in zip(names, mycount(0, 0.5)):
    print(t)
    
#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki cycle isimli fonksiyon parametresiyle aldığı dolaşılabilir nesneyi tekrara tekrar sonsuz döngü içerisinde 
    dolaşan bir dolaşım nesnesi verir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

s = 'ABC'

result = itertools.cycle(s)

for index, x in enumerate(result):
    print(x, end=' ')
    if index == 10:
        break

#------------------------------------------------------------------------------------------------------------------------------------
    Python standart kütüphanesinde fonksiyonun muhtemel bir gerçekleştirimi aşağıdaki gibi verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------
    
def cycle(iterable):
    saved = []
    for element in iterable:
        yield element
        saved.append(element)
    while saved:
        for element in saved:
              yield element
    
s = 'ABC'

for index, x in enumerate(cycle(s)):
    print(x, end=' ')
    if index == 10:
        break

#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki filterfalse isimli fonksiyon iki parametre almaktadır. Birinci parametre bool değere geri dönen bir fonksiyondur.
    İkinci parametre dolaşılabilir bir nesnedir. Fonksiyon bize dolaşılabilir bir nesne verir. Bu nesne dolaşıldığında sırasıyla 
    ikinci parametresindeki dolaşılabilir nesnedeki elemanlar birinci parametresindeki fonksiyona sokulur, False olanlar bize verilir. 
    Aslında bu fonksiyon built-in fileter fonksiyonunun tersini yapmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

def predicate(name):
    return len(name) > 4

for name in itertools.filterfalse(predicate, names):
    print(name, end=' ')    # ali veli ayşe 

#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki islice isimli fonksiyon bizden dolaşılabilir bir nesneyi ve start, stop, step değerlerini parametre olarak alır. 
    Bize yeni bir dolaşım nesnesi verir. Fonksiyonun verdiği dolaşım nesnesini dolaştığımızda fonksiyonda belirttiğimiz start değerinden 
    başlayarak, step artırımlarla stop değerine kadar ana dolaşılabilir nesnedeki elemanlar elde edilir. Bu fonksiyon özellikle elimizdeki 
    dolaşılabilir nesnenin belli bir kısmının dolaşılmasında kullanılmaktadır. islice fonksiyonun dolaşılabilir nesne parametresi dışındaki 
    parametrelerinin kullanımı tamamen range fonksiyonundaki gibidir. Yani fonksiyona yalnızca start değeri girilirse bu değer stop değeri 
    gibi kabul edilmektedir. Eğer start değeri girilip stop değeri de girilirse bu durumda start değerinden stop değerine kadar elemanlar 
    elde edilir. stop değeir None olarak girilirse "sonuna kadar" anlamına gelmektedir. Örneğin:
    
    >>> s = 'abcdefghijklmn'
    >>> import itertools
    >>> for c in itertools.isclice(s, 5): print(c)
    ...
    a
    b
    c
    d
    e
    >>> for c in itertools.islice(s, 5, None): print(c)
    ...
    f
    g
    h
    i
    j
    k
    l
    m
    n
    >>> for c in itertools.islice(s, 5, 10, 2): print(c)
    ...
    f
    h
    j
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

s = {10, 20, 30, 40, 50, 60}
a = [3, 6, 8, 3, 8, 9]
m = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

result = itertools.islice(s, 3)
for x in result:
    print(x, end=' ')       # 50 20 40 sıra belli değil
    
print()

result = itertools.islice(a, 3)
for x in result:
    print(x, end=' ')       # 3 6 8 
    
print()
    
result = itertools.islice(m, 3)
for x in result:
    print(x, end=' ')       # ali veli selami 
    
#------------------------------------------------------------------------------------------------------------------------------------
    Built-in min ve max fonksiyonlarının bir benzerini yazmaya çalışalım. Bu fonksiyonlar dolaşılabilir bir nesnenin en küçük ve en büyük elemanlarını
    geri döndürmektedir. En küçük ve en büyük sayıyı bulma algoritmasında ilk sayı en büyük ya da en küçük kabul edilir. Sonra 
    ondan daha büyük ya da daha küçük varsa o değer saklanır. Burada biz manuel iteratör işlemiyle bunu sağlayabiliriz. 
    Nesneyi bir kez iterate ederiz ve ilk elemanı elde ederiz. Geri kalan elemanları for döngüsüyle dolaşabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

def mymax(iterable):
    iterator = iter(iterable)       # iterator = iterable.__iter()
    maxval = next(iterator)         # iterator.__next__()
    
    for x in iterator:
        if x > maxval:
            maxval = x
            
    return maxval

s = {56, 34, 12, 63, 8, 41}

result = mymax(s)
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki programı deneme amacıyla itertools.islice ile yapmak isteyelim.
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

def mymax(iterable):
    maxval = list(itertools.islice(iterable, 1))[0]
    
    for x in itertools.islice(iterable, 1, None):
        if x > maxval:
            maxval = x
            
    return maxval

s = {56, 34, 12, 63, 8, 41}

result = mymax(s)
print(result)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Hiç itertools.islice kullanmadan herhangi bir dolaşılabilir nesnenin ilk n tane elemanını dolaşmak istersek bildiğimiz yöntemlerle
    bunu nasıl yapabiliriz. İlk akla gelen enumerate fonksşyonunu kullanmak olabilir:

    for index, val in iterable:
        if index == 5:
            break
        print(val)

    zip fonksiyonu "kısa olan kadar" işleme izin verdiğine göre zip fonksiyonunu da kullanbiliriz. Örneğin:

    for _, val in zip(range(5), iterable):
        print(val)

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Örneğin bir dolaşılabilir nesnenin başından ve sonundan n tane elemanı görüntülemek isteyelim. Dolaşılabilir nesnenin __len__ metodunun bulunduğunu 
    varsayalım. Böyle bir fonksiyonu aşağıdaki gibi yazabiliriz.    
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

def disp_head_tail(iterable, n = 5):
    for x in itertools.islice(iterable, n):
        print(x, end=' ')
    
    print('... ', end='')
    
    for x in itertools.islice(iterable, len(iterable) - 5, None):
        print(x, end=' ')
    
    print()
    
s = {12, 45, 23, 11, 8, 67, 34, 23, 98, 46, 79, 34, 36, 90, 23, 78}

disp_head_tail(s)

a = [12, 45, 23, 11, 8, 67, 34, 23, 98, 46, 79, 34, 36, 90, 23, 78]

disp_head_tail(a)
        
#------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi itertools.cycle fonksiyonu bir dolaşılabilir nesneyi alarak onu tekrar tekrar sonsuz döngü içerisinde dolaşıyordu.
    Biz bu fonksiyonla itertools.islice fonksiyonunu bir arada kullanabiliriz.  
#------------------------------------------------------------------------------------------------------------------------------------

import itertools
   
s = {12, 45, 23, 11, 8}

for x in itertools.islice(itertools.cycle(s), 8):
    print(x, end= ' ')

#------------------------------------------------------------------------------------------------------------------------------------
    Benzer biçimde belli bir değerden belli artırımlarla sonsuz döngü içeisinde değer veren itertools.count fonksiyonu itertools.islice 
    ile birlikte kullanılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools
   
for x in itertools.islice(itertools.count(10, 2), 10):
    print(x, end= ' ')      # 10 12 14 16 18 20 22 24 26 28 

#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki product isimli fonksiyon bizden bir grup dolaşılabilir nesneyi ayrı argümanlarla alır. Bunların kartezyen 
    çarpımlarını oluşturup demet biçiminde bize veren bir dolaşım bir nesne geri döndürür. Örneğin:

    a = ['ali', 'veli']
    b = [10, 20]

    for t in itertools.product(a, b):
        print(t)

    işleminden şöyle bir çıktı elde edilecektir:

    ('ali', 10)
    ('ali', 20)
    ('veli', 10)
    ('veli', 20)

    Burada product fonksiyonuna verdiğimiz argümanlar üç tane olsaydı bize verilen dolaşım nesnesi dolaşıldıkça üç elemenalı
    demetler elde edilecekti.
#------------------------------------------------------------------------------------------------------------------------------------

import itertools
   
a = ['ali', 'veli', 'selami']
b = [10, 20, 30]

iterable = itertools.product(a, b)

for t in iterable:
    print(t)

print()
    
c = ['ankara', 'izmir', 'bursa']

iterable = itertools.product(a, b, c)

for t in iterable:
    print(t)

#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki repeat fonksiyonu bir nesneyi ve tekrar sayısını parametre olarak alır ve bize bir dolaşım nesnesi verir. 
    Fonksiyonun bize verdiği dolaşım nesnesini dolaştığımızda o tekrar sayısı kadar nesneden elde ederiz. Eğer fonksiyonun ikinci parametresi 
    None olarak girilirse bize sonsuz döngü içerisinde aynı değerleri verir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools
   
s = 'ankara'

for x in itertools.repeat(s, 3):
    print(x, end=' ')           # ankara ankara ankara 

#------------------------------------------------------------------------------------------------------------------------------------
    Standart kütüphane dokümanlarında repeat fonksiyonunun muhtemel gerçekleştirimi aşağıdaki gibi verilmiştir. Fonksiyonun ikinci parametresi olan 
    tekrar sayısı girilmezse fonksiyon sonsuz sayıda tekrar yapmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

def repeat(val, times=None):
    if times is None:
        while True:
            yield val
    else:
        for _ in range(times):
            yield val
        
s = 'ankara'

for x in repeat(s, 3):
    print(x, end=' ')           # ankara ankara ankara 
        
#------------------------------------------------------------------------------------------------------------------------------------
    Her ne kadar standart kütüphanedeki muhtemel gerçekleştirim üretici fonksiyon biçiminde verilmişse de CPython yorumlayıcısında 
    repeat bir sınıf biçiminde yazılmıştır. Aşağıda sınıfsal yazımı verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools
   
class repeat:
    def __init__(self, val, times=None):
        self.val = val
        self.times = times
        self.count = 0
        
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.count == self.times:
            raise StopIteration
        self.count += 1
        
        return self.val
        
s = 'ankara'

for x in repeat(s, 3):
    print(x, end=' ')           # ankara ankara ankara 
    
#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki takewhile isimli fonksiyon bizden bir fonksiyon ve bir de dolaşılabilir nesne alır. Bize bir dolaşım nesnesi
    verir. Onun verdiği dolaşım nesnesini dolaştığımızda orijinal dolaşılabilir nesnedeki elemanları elde ederiz. Ancak bu elemanlar 
    bizim birinci parametreyle verdiğimiz fonksiyona sokulup bu fonksiyon True geri döndürmüşse verilmektedir. Eleman fonksiyona sokulup
    ilk False elde edildiğinde tüm işlem sonlandırılır. Başka bir deyişle bu fonksiyon bizim veridğimiz fonksiyon False döndürene kadar 
    dolaşılabilir nesnenin elemanlarını bize vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools
   
a = [12, 24, 46, 8, 9, 40, 21]

for x in itertools.takewhile(lambda x: x % 2 == 0, a):
    print(x, end=' ')       # 12 24 46 8 
    
#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki startmap fonksiyonu tamamen built-in map fonksiyonu gibidir. Ancak starmap fonksiyonunda dolaşılabilir nesne 
    dolaşılabilir nesnelerden oluşmalıdır. Bu durumda starmap fonksiyonundaki fonksiyona bu dolaşılabilir nesnenin elemanları olan dolaşılabilir 
    nesne *'lı argüman biçiminde aktarılmaktadır. map ve starmap fonksiyonlarının üretici fonksiyon olarak muhtemel gerçekleştirimi aşağıdaki 
    gibi olabilir:

    def map(f, iterable):
        for x in iterable:
            yield f(x)

    def starmap(f, iterable):
        for x in iterable:
            yield f(*x)

#------------------------------------------------------------------------------------------------------------------------------------

import itertools
   
a = [12, 24, 46, 8, 9, 40, 21]

iterable = map(lambda x: x * x, a)
for x in iterable:
    print(x, end=' ')
    
a = [(1, 2), (3, 4), (5, 6)]

iterable = map(lambda t: t[0] + t[1], a)
for x in iterable:
    print(x, end=' ')

a = [(1, 2), (3, 4), (5, 6)]

iterable = itertools.starmap(lambda x, y: x + y, a)
for x in iterable:
    print(x, end=' ')

#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki tee isimli fonksiyon bir dolaşılabilir nesneyi alıp bize bir demet biçiminde n tane dolaşım nesnesi vermektedir. 
    Görnüşte fonksiyon anlamsız gibi gelebilmektedir. Ancak iter fonksiyonuyla bir iterator elde edilmişse bu iterator bir kez dolaşıldığında
    artık sona gelinir ve bir daha dolaşılamaz. İtertör nesnelerinin de dolaşılabilir olduğunu anımsayınız. Örneğin:

    >>> a = [1, 2, 3]
    >>> iterator = iter(a)
    >>> list(iterator)
    [1, 2, 3]
    >>> list(iterator)
    []
    >>> import itertools
    >>> a = [1, 2, 3]
    >>> iterator = iter(a)
    >>> t = itertools.tee(a, 3)
    >>> list(t[0])
    [1, 2, 3]
    >>> list(t[1])
    [1, 2, 3]
    >>> list(t[2])
    [1, 2, 3]

    Özetle tee fonksiyonu bir kez dolaşıldığında biten bir iteratör varsa onu n kez dolaşabilmek için kullanılmaktadır
#------------------------------------------------------------------------------------------------------------------------------------

import itertools
   
a = [12, 24, 46, 8, 9, 40, 21]

iterator = iter(a)
for i in itertools.tee(a, 3):
    print(list(i))

#------------------------------------------------------------------------------------------------------------------------------------
                                                    71. Ders 16/09/2023 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi Python'da dilin içerisine entegre edilmiş olan bazı veri yapıları bulunmaktadır. Programcılar pek çok işleminde
    bunları kullanırlar: list, tuple, set, dict, str. Ancak bu veri yapıları bazı tür uygulamalar için yetersiz olabilmektedir. İşletim
    standart kütüphanedeki "collections" isimli modülde bazı ek veri yapıları da bulundurulmuştur.     
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    collections modülü içerisindeki built-in olmayan veriyapılarına yönelik önemli bir sınıf "deque" isimli sınıftır. "deque" sözcüğü 
    "double-ended queue" sözcüklerinden kısaltılarak uydurulmuştur ve "dek" biçiminde telaffuz edilmektedir. deque sınıfı aslında list 
    sınıfına çok benzemektedir. list sınıfında sona eleman çok hızlı eklenir. Ancak başa ve araya ekleme (insert), baştaki ve aradaki 
    elemanın silinmesi göreli olarak yavaştır. Çünkü başa ve araya eleman ekleme sırasında elemanlar mecburen kaydırılır (buna "expand" 
    işlemi denilmektedir), eleman silme işleminde de elemanlar benzer bir işlemle daraltılmaktadır (buna da "shrink" işlemi denilmektedir). 
    Bazı uygulamalarda veri yapısının başına ve sonuna eleman ekleme çok karşılaşılan bir işlemdir. Benzer biçimde baştan ve sonran eleman 
    silinmesi de bazen gerekebilmektedir. İşte "deque" denilen veri yapısının başına ve sonuna çok hızlı eleman eklenebilmekte aynı zamanda
    başından ve sonundan çok hızlı eleman silinebilmektedir. Algoritmalar dünyasında bir döngü ile yapılan işlemlere O(N) karmaşıklıkta 
    işlemler denir. Döngü olmadan yapılan işlemlere ise O(1) karmaşıklıkta işlemler denilmektedir. İşte listelerde sona ekleme ve sondan 
    eleman silme O(1) karmaşıklıkta yapılabildiği halde başa eleman ekleme ve baştan eleman silme ancak O(N) karmaşıklıkta yapılabilmektedir.
    Halbuki deque veri yapısında hem sona hem de başa eleman O(1) karmaşıklıkta eklenebilmekte ve hem baştan hem de sondan eleman O(1) 
    karmaşıklıkta silinebilmektedir. O halde özel bazı uygulamalarda iki taraftan da ekleme ve silme çokça yapılıyorsa list yerine deque 
    veri yapısının kullanılması uygun olur. 

    Şüphesiz deque veri yapısı list veri yapısından daha uygun gibi gözküyor olsa da aslında deque veri yapısının da list veri yapısına göre
    bazı dezavantajları söz konusudur. Genel olarak yalnızca sona eklemenin yapıldığı durumlarda list veri yapısı hem daha hızlı hem de 
    daha az yer kaplamaktadır.

    Aslında deque sınıfı kullanım bakımından list sınıfına çok benzemektedir. list sınıfının metotlarının çoğu deque sınıfında da vardır. 
    Ancak deque sınıfında sona ekleme yapan append metodunun yanı sıra başa ekleme yapan appendleft metodu da bulunmaktadır. Benzer biçimde 
    deque sınıfında extend metodunun yanı sıra extendleft isimli metot da bulunmaktadır. list sınıfının pop metodu herhangi bir indeksteki 
    elemanı silmek için kullanılıyordu. Eğer pop metoduna argüman geçmezsek bu metot son elemanı siliyordu. Ancak deque sınıfının pop metodu 
    zaten parametresizdir, her zaman son elemanı siler. Ayrıca deque sınıfında parametresiz popleft isimli bir metot da vardır Bu metot ilk 
    elemanı silmektedir.
    
    Tabii deque sınıfında da istenilen indeksteki elemanlara listelerde olduğu gibi [...] operatörü ile erişilebilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import collections

d = collections.deque()

d.append(1)
d.append(2)
d.appendleft(3)
d.appendleft(4)
   
d.extend([10, 20, 30])
d.extendleft([40, 50, 60])

for x in d:
    print(x, end=' ')           # 60 50 40 4 3 1 2 10 20 30 
    
print()

for i in range(len(d)):
    print(d[i], end=' ')        # 60 50 40 4 3 1 2 10 20 30 

print()

d.popleft()
d.pop()

print(d)                        # deque([50, 40, 4, 3, 1, 2, 10, 20])

#------------------------------------------------------------------------------------------------------------------------------------
    deque sınıfının döndürme (rotate) işlemi yapan rotate bir metodu vardır. rotate işlemi bir kez yapıldığında en sağdaki eleman en sola 
    alınır ve diğer elemanlar bir kaydırılır. Örneğin deque içerisinde şu elemanlar olsun:

    10 20 30 40 50 

    Bir kez rotate işlemi yapalım:

    50 10 20 30 40

    rotate işlemi birden fazla kez de yapılabilir. Şimdi yukarıdaki değerleri 2 kez rotate yapalım:

    30 40 50 10 20

    Aslında bir kez rotate yapmak d.appendleft(d.pop()) ile aynı anlamdadır. Bu biçimdeki rotate işlemine sağa rotate işlemi denilmektedir. 
    rotate metodunun parametresi default olarak 1 değerindedir. 
  
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
d = coll.deque([10, 20, 30, 40, 50])

print(d)        # deque([10, 20, 30, 40, 50])

d.rotate(1)     # sağa bir kez döndürme

print(d)        # deque([50, 10, 20, 30, 40])

d.rotate(3)

print(d)        # deque([20, 30, 40, 50, 10])

#------------------------------------------------------------------------------------------------------------------------------------
    rotate metodunun parametre negatif girilirse sola döndürme uygulanır. Aslında bu işlem d.append(d.popleft()) işlemi ile eşdeğerdir. 
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
d = coll.deque([10, 20, 30, 40, 50])

print(d)            # deque([10, 20, 30, 40, 50])

d.rotate(-1)        # sola bir kez döndürme

print(d)            # deque([20, 30, 40, 50, 10])

d.rotate(-3)

print(d)            # deque([50, 10, 20, 30, 40])

#------------------------------------------------------------------------------------------------------------------------------------
    deque nesnesini yaratırken maxlen parametresi de verebiliriz. Eğer bu parametre verilirse deque nesnesi maksimum belirtilen uzunlukta 
    olabilir. Bu durumda uzunluk yetmezse sona ekleme durumunda baştaki eleman, başa ekleme durumunda sondaki eleman deque'ten atılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
d = coll.deque([10, 20, 30, 40], 5)

print(d)            # deque([10, 20, 30, 40], maxlen=5)

d.append(50)

print(d)            # deque([10, 20, 30, 40, 50], maxlen=5)

d.append(60)

print(d)            # deque([20, 30, 40, 50, 60], maxlen=5)

d.append(70)

print(d)            # deque([20, 30, 40, 50, 60], maxlen=5)

d.appendleft(80)

print(d)            # deque([80, 30, 40, 50, 60], maxlen=5)

#------------------------------------------------------------------------------------------------------------------------------------
    maxlen parametresi dolaşılabilir bir nesnenin sondaki n değerinin elde edilmesinde kullanılabilir. Örneğin dosyalar dolaşılabilir 
    nesnelerdir. Dosya nesnesi dolaşıldığında dosyanın satırları elde edilir. (Bu satırların sonlarında '\n' karakteri bulunmaktadır.)
    O halde deque nesnei ile biz örneğin bir dosyanın sonundaki n tane satırı elde edebiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
with open('student.csv') as f:
    d = coll.deque(f, 5)
    print(d)
    for x in d:
        print(x, end='')
        
#------------------------------------------------------------------------------------------------------------------------------------
    Örneğin biz tek sayıları bir dizinin başına, çift sayıları sonuna eklemek isteyelim. Bu iş için deque oldukça verimlidir. Aşağıdaki
    örnekte 100 tane rastgele sayı üretilerek deque içerisine bu biçimde yerleştirilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import collections
import random

d = collections.deque()

for i in range(100):
    val = random.randint(0, 1000)
    if val % 2 == 0:
        d.append(val)
    else:
        d.appendleft(val)
        
print(d)
    
#------------------------------------------------------------------------------------------------------------------------------------
    deque ile FIFO ya da LIFO kuyruk sistemleri de yapılabilir. Biz daha önce queue ve multiprocessing modülleri içerisindeki Queue 
    sınıflarını görmüştük. Ancak bu Queue sınıfları "üretici-tüketici" problemi için düşünülmüş olan "senkronize" bir kuyruk sistemlerini 
    oluşturmaktadır. Dolayısıyla daha önce görmüş olduğumuz Queue sınıfları "multi-threaded" ve "multi-processing" uygulamalar için düşünülmüştür. 
    Tabii biz bu Queue sınıfını thread'siz (single-threaded) programlarda da kullanabiliriz. Ancak bu durumda performas düşer. İşte collections 
    modülündeki deque sınıfı sayesinde FIFO ve LIFO kuyruk sistemleri kolayca oluşturulabilmektedir. Örneğin biz bir deque nesnesi yaratıp 
    elemanları bu nesnenin sonuna ekleyip başında alırsak ya da başına ekleyip sonundan alırsak bir FIFO kuyruk sistemi oluşturmuş oluruz. 
    Dolayısıyla Python'un standart kütüphanesinde ayrı bir kuyruk ya da stack veri yapısı yoktur. Zaten bu veri yapıları deque kullanılarak 
    gerçekleştirilebilmektedir. 

    Bilindiği gibi FIFO kuyruk sistemleri bilgileri sırası bozulmadan geçici olarak saklamak amacıyla kullanılmaktadır. Aşağıdaki 
    örnekte 1'den 100' kadar sayılar bir kuyruk sistemine eklenip geri alınmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
q = coll.deque()

for x in range(100):
    q.append(x)
    
while len(q):
    val = q.popleft()
    print(val, end=' ')

#------------------------------------------------------------------------------------------------------------------------------------
    LIFO kuyruk sistemlerine "stack" sistemleri de denilmektedir. Doğadaki bazı olaylarda stack yapısı gözlenmektedir. Örneğin üst üste 
    tabakları koyduğumuzda önce en son koyduğumuzu önce alırız. Bir asansöre binenler geri çekildiği için son binen önce iner. Programalamada 
    stack sistemi pek çok yerde kullanılmaktadır. Örneğin "undo" mekanizması bir stack sistemi gibi çalışır. Yani biz "undo" yaptığımızda 
    son yaptığımız değişikliği geri alırız. Ya da örneğin parsing algoritmalarında stack kullanılmaktadır. Stack bir şeyi ters yüz etmek 
    için de kullanılmaktadır. 
    
    Python'da bir stack sistemi deque sınıfı kullanılarak gerçekleştirilebilir. Örneğin biz başa ekleyip baştan alma ya da sona ekleyip sondan 
    alma işlemi ile bir stack veri yapısını gerçekleştirilebiliriz.
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
q = coll.deque()

for x in range(100):
    q.appendleft(x)
    
while len(q):
    val = q.popleft()
    print(val, end=' ')
    
#------------------------------------------------------------------------------------------------------------------------------------
    collections modülü içerisindeki diğer bir nesne tutan sınıf da ChainMap isimli sınıftır. ("Chain" zincir anlamına, "Map" ise bu bağlamda 
    sözlük (dictionary) anlamına gelmektedir.) Biz ChainMap nesnesine birden fazla sözlük veriririz. Sonra bu ChainMap üzerinde anahtara 
    dayalı arama yaptığımızda (bunun için yine [...] operatöryle ya da get metodu kullanılabilir) nesne bizim verdiğimiz sözlüklere sırasıyla 
    bakar ve ilk bulduğu sözlükteki değeri bize verir. Böylece ChainMap nesnesi bir "scope" mantığını pratik bir biçimde oluşturmak için kullanılır. 
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
d = {'ali': 10, 'veli': 20, 'selami': 30}
k = {'ayşe': 40, 'ali': 50, 'fatma': 60}
m = {'selami': 70, 'sacit': 80, 'hasan': 90}

cm = coll.ChainMap(d, k, m)

val = cm['selami']
print(val)          # 30

val = cm['hasan']
print(val)          # 90

val = cm['ali']
print(val)          # 10

val = cm.get('sacit')
print(val)          # 80

val = cm.get('süleyman')
print(val)          # None

#------------------------------------------------------------------------------------------------------------------------------------
    Burada önemli anımsatma yapmak istiyoruz. Eskiden Python'daki built-in dict sınıfında dict nesnesi dolaşılırken ya da anahtarlar 
    keys metodu ile elde edilirken anahtarların elde edilme sırası belirli değildi. Ancak Python 3.7 ile artık sözlük nesnesi dolaşılırken 
    anahtarlar sözlüğe eklenme sırasına göre elde edilmektedir. Yani artık bir sözlüğü dolaşırken anahtarlar kesinlikle biz onları 
    hangi sırada eklediysek o sırada elde edilecektir. 
#------------------------------------------------------------------------------------------------------------------------------------

d = {'zeynep': 10, 'ali': 20, 'selami': 30}
d['sacit'] = 40
d['ayşe'] = 50
d['fatma'] = 60

d.update([('gürbüz', 70), ('necati', 80)])

for key in d.keys():
    print(key, end=' ')     # 3.7 ve sonrasında zeynep ali selami sacit ayşe fatma gürbüz necati 
    
for value in d.values():
    print(value, end=' ')     # 3.7 ve sonrasında 10 20 30 40 50 60 70 80 

#------------------------------------------------------------------------------------------------------------------------------------
    ChainMap nesnesi dolaşıldığında ya da keys ve values metotlarıyla anahtar ve değerler elde edildiğinde her zaman son sözlükten ilk 
    sözlüğe doğru bir dolaşma yapılmaktadır. Örneğin ChamMap nesnesi ChanMap(d, k, m) biçiminde oluşturulmuş olsun. Biz bu sözlüğü 
    dolaştığımızda önce m nesnesinin anahtarları, sonra k nesnesinin anahtarları sonra da d nesnesinin anahtarları elde edilecektir. 
    Python 3.7 ve sonrasında sözlük içerisindeki anahtarlarında düz sırada elde edildiğine dikkat ediniz. Ayrıca dolaşım sırasında 
    sözlüklerde birden fazla aynı anahtar varsa yalnızca ilk karşılaşan sözlükteki anahtar verilmektedir. ChainMap sınıfının values 
    metodu ile değerler elde edilirken önce anahtarlar yukarıda belirtilen kurala göre elde edilir. Sonra o anahtarlara ilişkin değerler 
    düz sırada elde edilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
d = {'ali': 10, 'veli': 20, 'selami': 30}
k = {'ayşe': 40, 'ali': 50, 'fatma': 60}
m = {'selami': 70, 'sacit': 80, 'hasan': 90}

cm = coll.ChainMap(d, k, m)

for key in cm.keys():
    print(key, end = ' ')       # sondan başa selami sacit hasan ayşe ali fatma veli 

print()

for val in cm.values():
    print(val, end = ' ')       # 30 80 90 40 10 60 20 

print()
    
# yukarıdakinin eşdeğeri

for key in cm.keys():
    val = cm[key]
    print(val, end = ' ')        # 30 80 90 40 10 60 20  

#------------------------------------------------------------------------------------------------------------------------------------
    Bir ChainMap nesnesine ekleme yapıldığında ekleme her zaman ilk sözlük nesnesine yapılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
d = {'ali': 10, 'veli': 20, 'selami': 30}
k = {'ayşe': 40, 'ali': 50, 'fatma': 60}
m = {'selami': 70, 'sacit': 80, 'hasan': 90}

cm = coll.ChainMap(d, k, m)

cm['hüseyin'] = 100
cm['jale'] = 200

print(cm)
print(d)        # {'ali': 10, 'veli': 20, 'selami': 30, 'hüseyin': 100, 'jale': 200}

#------------------------------------------------------------------------------------------------------------------------------------
    Benzer biçimde ChainMap sınıfından pop metoduyla eleman silinmek istendiğinde silme her zaman sanki yalnızca birinci sözlük varmış 
    gibi yapılmaktadır. (Yani silinecek anahtar birinci sözlükte yoksa ancak diğer sözlğklerin birinde varsa pop başarısız olmaktadır.)
    Başka bir deyişle eleman ekleme ve silme işlemlerinde sanki yalnızca ilk sözlük varmış gibi işlem yürütülmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
d = {'ali': 10, 'veli': 20, 'selami': 30}
k = {'ayşe': 40, 'ali': 50, 'fatma': 60}
m = {'selami': 70, 'sacit': 80, 'hasan': 90}

cm = coll.ChainMap(d, k, m)

print(cm)

cm.pop('selami')

print(cm)

val = cm.pop('sacit', 'Not Found')
print(val)          # Not Found

#------------------------------------------------------------------------------------------------------------------------------------
    ChainMap sınıfının maps örnek özniteliği bizim nesne yaratılırken verdiğimiz sözlükleri bize bir liste biçiminde verir. parents 
    örnek özniteliği ilk sözlük dışındaki tüm sözlükleri bize bir liste olarak vermektedir. Sınıfın new_child metodu bazı "scope" uygulamalarında
    nesneye yeni bir sözlüğün eklenmesi amacıyla bulundurulmuştur. Metot yeni bir ChainMap nesnesi yaratır ve bizim verdiğimiz sözlüğü
    bu yeni ChainMap nesnesinin başına ekler. Dolayısıyla cm bir ChainMap nesnesi ve d de bir sözlük nesnesi belirtmek üzere aşağıdaki iki
    ifade eşdeğerdir:

    child = cm.new_child(d) 
    child = ChainMap(d, *d.maps)

    new_child metodu parametresiz de kullaılabilir. Bu durumda boş bir sözlük eklenir. 
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
d = {'ali': 10, 'veli': 20, 'selami': 30}
k = {'ayşe': 40, 'ali': 50, 'fatma': 60}
m = {'selami': 70, 'sacit': 80, 'hasan': 90}

cm = coll.ChainMap(d, k, m)

print(cm)

child = cm.new_child({'kazım': 100, 'levent': 110})     # eşdeğeri child = ChainMap({'kazım': 100, 'levent': 110}, *cm.maps)
print(child)
              
#------------------------------------------------------------------------------------------------------------------------------------
    collections modülündeki OrderedDict sınıfı bir çeşit sözlük nesnesi oluşturuyordu. Ancak bu sözlük nesnesi dolaşıldığında dolaşım
    eklenme sırasına göre yapılıyordu. Fakat zaten artık Python 3.7 ile birlikte built-in dict sınıfı da bu özelliğe sahip olmuştur. 
    Bu nedenle OrderedDict sınıfının birkaç önemsiz özelliğinin dışında bir önemi kalmamıştır. Fakat geçmişe doğru uyumun korunması 
    için bu sınıf muhafaza edilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    collections modülünde namedtuple isimli önemli bir fonksiyon vardır. Bu fonksiyon "isimli demet (named tuple)" oluşturmak için 
    kullanılmaktadır. İsimli demet bir demetin bütün özelliklerini kapsayan ancak demet elemanlarına köşeli parantez operatörünün yanı 
    sıra isimlerle de erişmeyi sağlayan ve bunu yaparken de nesne üzerinde ek bir maaliyet oluşturmayan sınıflardır. Aslında isimli 
    demetler built-in tuple sınıfından türetme yapılarak da manuel biçimde oluşturulabilmektedir. Buna ilişkin bir örneği izleyen bölümlerde 
    vereceğiz. Ancak manuel oluşturma zahmetlidir ve modüldeki namedtuple fonksiyonu bunu otomatize etmektedir. İsimli bir demete benzer 
    işlevsellik normal sınıflarla da verilebilir. Örneğin:

    class Point:
        def __init__(self, x, y):
            self.x = x
            self.y = y

    pt = Point(10, 20)

    print(pt.x, pt.y)

    Ancak normal sınıfların bazı ek maaliyetleri vardır ve aynı zamanda genellik de sağlanamamaktadır. Oysa isimli demetler maaliyetsiz bir biçimde 
    gerçekleştirilmektedir. 

    Bir isimli demet namedtuple fonksiyonu ile oluşturulur. Bunun için fonksiyonun birinci parametresine oluşturulacak sınıfın metadata 
    ismi verilir. Bu isim bizim için önemli olmasa da bazı ileri uygulamalarda gerekebilmektedir. Bu isim istenirse ilgili sınıf türünden 
    nesne ile __class__ örnek özniteliği ile elde edilebilir. namedtuple sınıfının ikinci elemanı demet elemanlarının isimlerini içeren 
    dolaşılabilir bir nesne olmalıdır. Biz namedtuple fonksiyonunun geri dönüş değerini bir değişkene atarız. Artık o değişken bir sınıf 
    ismi gibi nesne yaratmakta kullanılabilir. Normalde metadata ismi ile bu isim farklı olabilir. Ancak genellikle programcılar aynı 
    isimleri kullanmaktadır. namedtuple fonksiyonunun bize verdiği sınıf aslında built-in tuple sınıfından türetilmiş bir sınıftır. 
    Dolaysıyla bu sınıf türünden nesne yaratıldığında aslında demetin tüm işlevselliği kullanılabilir. Ek olarak tabii elemanlara isimlerle
    de erişebiliriz. Örneğin:

    import collections as coll

    Point = coll.namedtuple('Point', ['x', 'y'])

    pt = Point(3, 5)
    print(pt.x, pt.y)
    print(pt[0], pt[1])

    Görüldüğü gibi burada namedTuple fonksiyonun geri döndürdüğü değer bir değişkene atanmış o değişken de sanki bir sınıf gibi kullanılmıştır. 
    Örneğimizdeki Point sınıfı aslında tuple sınıfından türetilmiş durumdadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
Point = coll.namedtuple('Point', ['x', 'y'])

t = Point(10, 20)

print(t[0], t[1])           # 10 20
print(t.x, t.y)             # 10 20

print(Point.__bases__)      # (<class 'tuple'>,)

#------------------------------------------------------------------------------------------------------------------------------------
                                                72. Ders 22/09/2023 - Cuma
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    namedtuple fonksiyonunun birinci parametresiyle verdiğimiz isim aslında yaratılan nesnenin türüne ilişkin sınıfın ismidir. Örneğin:

    import collections as coll

    Z = coll.namedtuple('Complex', ['real', 'imag'])

    z = Z(10, 2)

    Burada z "Complex" isimli sınıf türündendir. Ancak bu sınıfın type nesne referansını gösteren değişken Z ismindedir. Complex sınıfı 
    tuple sınıfından türetilmiş durumdadır. Durumu şekilsel olarak şöyle gösterebiliriz:

    Z ----> type (nesnesi Complex sınıfı türünden tuple sınıfından türetilmiş)

    Yani yukarıdaki isimli demet oluşturma ifadesinde aslında tuple sınıfından türetilmiş olan Complex isimli bir sınıf oluşturulmuştur.
    Ancak bu sınıfın referansı Z değişkeninde tutulmaktadır. Bu durum izleyen paragraflarda ele alacağımız "meta sınıflar" konusundan sonra
    daha iyi anlaşılacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll

Z = coll.namedtuple('Complex', ['real', 'imag'])

z = Z(10, 2)
print(z.real, z.imag)

print(type(z))              # Complex
print(type(Z))              # type
print(type(z).__bases__)    # (tuple,)

#------------------------------------------------------------------------------------------------------------------------------------
    İsimli demetler pek çok kütüphanede özellikle fonksiyonların geri dönüş değerlerinde kullanılmaktadır. Örneğin ikinci derece bir 
    denklemin köklerini veren getroots isimli bir fonksiyon olsun. Biz bu fonksiyonu normal demet yerine sisimli bir demetle geri 
    döndürebiliriz. Aşağıda buna ilişkin bir örnek verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import collections 
import math

def getroots(a, b, c):
    delta = b ** 2 - 4 * a * c
    if delta < 0:
        return None
    x1 = (-b + math.sqrt(delta)) / (2 * a)
    x2 = (-b - math.sqrt(delta)) / (2 * a)
    
    Roots = collections.namedtuple('Roots', ['x1', 'x2'])
    return Roots(x1, x2)

result = getroots(1, 0, -4)
if result:
    print(result.x1, result.x2)

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi aslında biz isimli bir demet etkisini oluşturacak bir sınıf yazabiliriz. Aşağıda buna bir örnek verilmiştir. 
    Ancak böyle bir etki sınıfla oluşturulurken isimli demete göre arka planda daha fazla maaliyet oluşmaktadır.

    class Point:
        def __init__(self, x, y):
            self.x = x
            self.y = y
            
        def __getitem__(self, index):
            if index == 0:
                return self.x
            if index == 1:
                return self.y
            
            raise IndexError()
            
#------------------------------------------------------------------------------------------------------------------------------------

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
    def __getitem__(self, index):
        if index == 0:
            return self.x
        if index == 1:
            return self.y
        
        raise IndexError()
        
pt = Point(10, 20)
print(pt[0], pt[1])
print(pt.x, pt.y)

#------------------------------------------------------------------------------------------------------------------------------------
    İsimli demetler yaratılırken demet elemanlarının isimleri tek bir string biçiminde de verilebilir. Bu durumda isimler boşluk veya 
    virgüllerle ayrılmalıdır. Örneğin:

    Roots = collections.namedtuple('Roots', 'x1 x2') 

    Burada isimli demetin elemanlarının isimleri x1 ve x2 biçimindedir. Yani bu işlem aşağıdkaiyle eşdeğerdir:

    Roots = collections.namedtuple('Roots', ['x1', 'x2']) 

#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll

Roots = coll.namedtuple('Roots', 'x1 x2')

r = Roots(1, 2)
print(r.x1, r.x2)

#------------------------------------------------------------------------------------------------------------------------------------
    collections modülündeki Counter isimli sınıf bir çeşit sözlük sınıfıdır. Zaten bu sınıf dict sınıfından türetilmiştir. Sınıfın amacı
    varlıkların sayısını tutmaktır. Tipik olarak nesne dolaşılabilir bir nesneyle yaratılır. Böylece nesne o dolaşılabilir nesnedeki elemanların
    sayılarını tutar hale gelir. Counter nesnesiyle elde edilen sözlüğün anahtarları dolaşılabilir nesnedeki elemanlar, değerleri ise 
    onların sayılarıdır. Örneğin:

    import collections 

    c = collections.Counter('ankara')
    print(c)        # Counter({'a': 3, 'n': 1, 'k': 1, 'r': 1})

    Counter sınıfı dict sınıfından türetildiği için tamamen dict sınıfının bütün işlevselliğini barındırmaktadır. Yani örneğimizdeki 
    c nesnesi bir çeşit sözlük nesnesidir. Sözlüklerdeki tüm metotları biz Counter nesnesi ile de kullanabiliriz.  
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll

c = coll.Counter('ankara')
print(c)        # Counter({'a': 3, 'n': 1, 'k': 1, 'r': 1})

c = coll.Counter([1, 2, 1, 2, 1, 2, 4, 5, 5, 2, 6, 3, 6])
print(c)        # Counter({1: 3, 2: 2})

for key, value in c.items():
    print(key, '=>', value)

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Counter nesnesi bir sözlükle de oluşturulabilmektedir. Bu durumda değerler ve onların sayıları sözlükle elde edilmiş olur. Örneğin:

    c = collections.Counter({'x': 5, 'y': 3, 'z': 2})

#------------------------------------------------------------------------------------------------------------------------------------

import collections 

c = collections.Counter({'x': 5, 'y': 3, 'z': 2})

print(c)

#------------------------------------------------------------------------------------------------------------------------------------
    Counter sınıfının elements isimli metodu bize bir dolaşım nesnesi vernektedir. Bu nesne dolaşıldığında nesnenin tuttuğu elemanlar 
    belirtilen sayıda bize verilmektedir. Örneğin:

    c = collections.Counter({'x': 5, 'y': 3, 'z': 2})
    e = c.elements()
    a = list(e)
    print(a)        # ['x', 'x', 'x', 'x', 'x', 'y', 'y', 'y', 'z', 'z']

#------------------------------------------------------------------------------------------------------------------------------------

import collections 

c = collections.Counter({'x': 5, 'y': 3, 'z': 2})
e = c.elements()
a = list(e)
print(a)        # ['x', 'x', 'x', 'x', 'x', 'y', 'y', 'y', 'z', 'z']
    
#------------------------------------------------------------------------------------------------------------------------------------
    Counter sınıfının most_common metodu en çok yinelenen ilk n değeri demetlerden oluşan bir liste biçiminde vermektedir. Eğer metot
    argümansız çağırılırsa bütün değerler bu biçimde verilmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll

c = coll.Counter('abrakadabra')
mc = c.most_common(3)
print(mc)       # [('a', 5), ('b', 2), ('r', 2)]

mc = c.most_common()
print(mc)       # [('a', 5), ('b', 2), ('r', 2), ('k', 1), ('d', 1)]

#------------------------------------------------------------------------------------------------------------------------------------
    Counter sınıfının total metodu toplam eleman sayısını bize vermektedir. Ancak bu metot Python 3.10 ile eklenmiştir. (Spyder kullanıyorsanız
    sol üst köşeden Spyder'ın kullandığı Python versiyonuna dikkat ediniz.)
#------------------------------------------------------------------------------------------------------------------------------------
    
import collections 

c = collections.Counter({'a': 5, 'b': 3, 'c': 2})

print(c)                # 3
print(c.total())        # 10    

#------------------------------------------------------------------------------------------------------------------------------------
    dict sınıfının update metodu eklenecek elemanlar zaten sözlükte varsa yalnızca bunların değerlerini güncellemektedir. Ancak Counter 
    sınıfının update metodu dolaşılabilir bir nesne ya da sözlük alabilir. Bu durumda metot üzerine ekleme yapmaktadır. Yani sanki anahtarın 
    sayaçları artmış gibi bir etki oluşmaktadır. Halbuki Counter sınıfının [...] operatörü ile atama yapıldığında davranış böyle değildir. 
    Eski sayaç değeri kaybedilip yeni değer set edilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------
    
import collections as coll

c = coll.Counter([1, 2, 2, 1, 2, 2, 3, 2, 3, 3])
print(c)        # Counter({2: 5, 3: 3, 1: 2})

c.update([1, 1, 2, 2])
print(c)        # Counter({2: 7, 1: 4, 3: 3})

c.update({2:100})
print(c)        # Counter({2: 107, 1: 4, 3: 3})

c[2] = 10
print(c)        # Counter({2: 10, 1: 4, 3: 3})

#------------------------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi bir Python listesi ya da demeti aslında değerlerin adreslerini tutmaktadır. Bu tutuş biçimi dinamik tür sistemine 
    uygun ve heterojen nesnelerin tutulmasına olanak sağlıyor olsa da fazla yer kaplaması ve elemanlara yavaş erişilmesi gibi dezavantajları 
    da beraberinde getirmektedir. array modülündeki array isimli sınıf aynı türden nesneleri etkin bir biçimde depolamak ve onlara hızlı 
    bir biçimde erişebilmek için bulundurulmuştur. array sınıfı "aynı türden bir grup değeri C Programlama Dilindeki diziler gibi" tutmaktadır.
    Solayısıyla array nesnesinin içerisindeki elemanlar list ve tuple sınıflarında olduğu gibi adres tutmazlar doğrudan değerleri tutarlar. 

    array nesneleri NumPy kütüphanesindeki ndarray nesnelerine benzemektedir. Anımsanacağı gibi ndarray nesnelerinin de bir dtype türü vardı. 
    Bu nesneler de elemanların adreslerini değil doğurdan kendisi tutuyordu. İşte array nesneleri aynı türden değerlerin etkin bir biçimde
    tutulması ve onlara hızlı bir biçimde erişilmesini mümkün hale getirmektedir. Ancak array nesneleri ndarray nesneleri gibi karşılıklı 
    elemanlar üzerinde vektörel işlem yapma yeteneğine sahip değildir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    array nesnesi yaratılırken onun türü de belirtilir. Çünkü bir array nesnesi hep aynı türden değerleri tutmak zorundadır. array nesnesinin 
    tuttuğu değerlerin türleri C Programlama Dili temel alınarak belirlenmiştir. Bu tür array nesnesi yaratılırken belirtilmektedir. Türler şöyledir:

    Tür Temsili         C'deki Tür

    'b'                 signed char
    'B'                 unsigned char
    'u'                 wchar_t
    'h'                 signed short int
    'H'                 unsigned short int
    'i'                 signed int
    'I'                 unsigned int
    'l'                 signed long int
    'L'                 unsigned long int
    'q'                 signed long long int
    'Q'                 unsigned long long int
    'f'                 float
    'd'                 double 

    C Programlama Dilindeki yukarıdaki türlerin uzunlukları aslında char dışında sistemden sisteme değişebilmektedir. Ancak tipik durum şöyledir:

    char, unsigned char             ---> 1 byte'lık tamsayı türü
    short, unsigned short           ---> 2 byte'lık tamsayı türü
    int, unsigned int               ---> 4 byte'lık tamsayı türü
    long, unsigned long             ---> 4 ya da 8 byte'lık tamsayı türü
    long long, unsigned long long   ---> 8 byte'lık tamsayı türü
    float                           ---> 4 byte'lık gerçek sayı türü 
    double                          ---> 8 byte'lık gerçek sayı türü (Python'daki float)

    Bir array nesnesini yaratırken onun türünü ve isteğe bağlı olarak onun tutacağı değerleri verebiliriz. Örneğin:

    import array 

    a = array.array('i', [1, 2, 3, 4, 5])

    print(a)            # array('i', [1, 2, 3, 4, 5])

    Yukarıda da belirttiğimiz gibi array sınıfı bizzat değerlerin kendisini tutmaktadır. Yani list ve tuple sınıflarında olduğu gibi 
    onların adreslerini tutmamaktadır. Ancak tabii gibi array nesnesi hep aynı türden değerleri tutabilmektedir. 

    Aslında NumPy kütüphanesindeki ndarray sınıfı da benzer biçimde bir temsil kullanmaktadır. Buradaki array sınıfının NumPy'daki 
    ndarray sınıfıyla bir rekabeti yoktur. NumPy kütüphanesi oldukça geniş ve vektörel işlem yapma yeteneğine sahiptir. NumPy'daki 
    dtype da aslında yukarıda türleri belirtmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import array 

a = array.array('i', [1, 2, 3, 4, 5])

print(a)            # array('i', [1, 2, 3, 4, 5])

#------------------------------------------------------------------------------------------------------------------------------------
    Bir array nesnesi oluşturulduktan sonra bu nesnenin kullanımı list nesnelerinin kullanımına çok benzemektedir. Yani array nesneleri 
    adeta elemanları aynı türdne olan, az yer kaplayan ve hızlı işlem yapılabilen listeler gibidir. Örneğin:

    - array nesnesi de "değiştirilebilir (mutable)" türlendendir. 
    - array nesnesinin elemanlarına yine [...] operatörü ile erişilebilir. 
    - Dilimleme listelerde olduğu gibidir. Dilimlemede yine değerlerin kopyaları çıkartılmaktadır. (NumPy'da dilimleme işleminden bir view
    nesnesi elde edildiğini anımsayınız.)
    - array sınıfı fa dolaşılabilir bir sınıftır. 
    - array nesnesi len fonksiyonuna sokulabilir. 
    - count metodu yine belli bir elemanın sayısını bize verir. 
    - append metodu dizinin sonuna ekleme yapar. 
    - extend metodu bir dolaşılabilir nesnenin içerisindekileri diziye ekler.
    - Yine pop metodu belli bir indeksteki elemanı silmek kullanılır
    - Yine remove metodu elemanı arar ve bulursa ilk bulduğu elemanı siler. Eleman yoksa exception oluşur. 
    - in ve not in operatörleri yine "içinde var mı" kontrolünü yapar.
    - insert metodu yine belli bir elemanı belli bir indekse insert etmektedir. 
    - Yine reverse metodu "inplace" biçimde diziy tersyüz etmektedir. 
    - indeks metodu yine bir elemanı arar, onun ilk bulunduğu yerin indeks numarasını verir. Eleman yoksa exception oluşmaktadır. 
    - tolist metodu array içerisindeki elemanları bize Python listesi biçiminde verir. 
    - tobytes metodu dizinin içerisindeki değerleri bir bytes nesnesi olarak bize verir. 
    - array sınıfının typecode isimli örnek özniteliği dizinin türünü bize verir. 
    - itemsize örnek özniteliği dizinin tuttuğu bir elemanın byte uzunluğunu bize vermektedir. 
    - Elimizde bir byte dizisi varsa biz bu byte dizisini bir array nesnesi haline getirebiliriz. 
    - Elimizde bir bytes nesnesi varsa onun içeriğini frombytes metodu ile Array nesnesine ekleyebiliriz. 
    - fromlist metodu bir Python listesini alıp onun elemanlarını array nesnesine eklemektedir. 

#------------------------------------------------------------------------------------------------------------------------------------

import array 

a = array.array('i', [10, 20, 30, 40, 50])

print(a[2])     # 30

a[2] = 100
print(a)        # array('i', [10, 20, 100, 40, 50])

b = a[2:4]
print(b)        # array('i', [100, 40])

for x in a:
    print(x, end=' ')       # 10 20 100 40 50 
print()

a.append(60)
print(a)        # array('i', [10, 20, 100, 40, 50, 60])

a.extend([70, 80, 90])
print(a)        # array('i', [10, 20, 100, 40, 50, 60, 70, 80, 90])

a.pop(2)
print(a)        # array('i', [10, 20, 40, 50, 60, 70, 80, 90])

a.remove(60)
print(a)        # array('i', [10, 20, 40, 50, 70, 80, 90])

a.insert(1, 100)
print(a)        # array('i', [10, 100, 20, 40, 50, 70, 80, 90])

a.reverse()
print(a)        # array('i', [90, 80, 70, 50, 40, 20, 100, 10])

result = a.index(100)
print(result)   # 6

x = a.tolist()
print(x)        # array('i', [90, 80, 70, 50, 40, 20, 100, 10])

y = a.tobytes()
print(y)        # b'Z\x00\x00\x00P\x00\x00\x00F\x00\x00\x002\x00\x00\x00(\x00\x00\x00\x14\x00\x00\x00d\x00\x00\x00\n\x00\x00\x00'

print(a.typecode)       # i

print(a.itemsize)       # 4

b = b'\x10\x00\x00\x00'  # 16 sayısının byte karşılığı
a.frombytes(b)
print(a)                # array('i', [90, 80, 70, 50, 40, 20, 100, 10, 16])

a.fromlist([100, 200, 300])
print(a)                # array('i', [90, 80, 70, 50, 40, 20, 100, 10, 16, 100, 200, 300])

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii biz bir array nesnesin bir elemanına o tür ile temsil edilemeyen bir değeri atayamayız. 
#------------------------------------------------------------------------------------------------------------------------------------

import array 

a = array.array('i', [10, 20, 30, 40, 50])

a[1] = 12.3     # exception oluşur

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    C, C++, Java, C# gibi pek çok dilde "enumaration (sayımlama), kısaca enum" denilen türler bulunmaktadır. Enum türleri aslında bu dllerde 
    birtakım sayıların isimsel olarak temsil edilmesini sağlamak için kullanılmaktadır. Bazen kısıtlı sayıda seçeneğe sahip olan olgular 
    söz konusu olabilir ve bunların tamsayılarla ifade edilmesi gerekebilir. Genel olarak yazılar pek çok durumda kategori belirten değerlerin 
    temsil edilmesinde hem zamansal bakımdan hem de hata kontrolü bakımından uygun olmayabilmektedir. 

    Python'da bir enum türü yoktur. Ancak standart kütüphanede enum türünü temsil eden enum isimli modülün içerisinde Enum isimli bir 
    sınıf bulundurulmuştur. 

    Python'da enumaration kullanımı şöyledir: Programcı önce enum.Enum sınıfından bir sınıf türetir. Türemiş sınıfta enum sabitlerini 
    isim = değer biçiminde sınıf değişkeni (sınıf özniteliği) olarak oluşturur. Sonra sınıf ismi ve nokta operatörü ile bu enum sabitlerine 
    erişir. Örneğin:

    class Direction(enum.Enum):
        Up = 0
        Right = 1
        Down = 2
        Left = 3

    Burada biz Direction isimli bir enum oluşturmuş olduk. Bu enum elemanlarına Direction.Up, Direction.Right, Direction.Down, Direction.Left
    biçiminde erişebiliriz. Pekiyi bunu sağlama için neden enum.Enum sınıfından türetme yapılmaktadır? Aynı işlemleri aşağıdaki gibi 
    yapamaz mıydık?

    class Direction:
        Up = 0
        Right = 1
        Down = 2
        Left = 3

    İşte eğer bu biçimde enum oluşturmaya çalışsaydık burada sınıf değişkenleri bir sabit gibi ele alınmazdı. Bu değişkenlere atamaya 
    yapılabilirdi. Halbuki artık bu değişkenlere atama yapılamamaktadır. Ayrıca eğer enum oluşturmayı yukarıdaki gibi yapmış olsaydık 
    bir int değer ile enum değerini karşılaştırıp işleme sokabilirdik. Halbuki enum.Enum sınıfından türetme yaptığımızda ancak aynı 
    türden iki enum değerini anlamlı olarak karşılaştırabilmekteyiz. 
#------------------------------------------------------------------------------------------------------------------------------------

import enum

class Direction(enum.Enum):
    Up = 0
    Right = 1
    Down = 2
    Left = 3
    
def move(direction):
    if direction == Direction.Up:
        print('yukarıya gidiyor')
    elif direction == Direction.Right:
        print('sağa gidiyor')
    elif direction == Direction.Down:
        print('aşağıya gidiyor')
    elif direction == Direction.Left:
        print('sola gidiyor')
        
move(Direction.Left)
move(Direction.Right)
move(Direction.Up)
move(Direction.Down)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir enum değişkeninin değeri Enum sınıfının value özniteliği ile elde edilebilmektedir. Örneğin:

    d = Direction.Right
    print(d.value)

    Enum değerinin ismi ise sınıfın name isimli özniteliği ile elde edilebilmektedir. Örneğin:

    d = Direction.Right
    print(d.name)           # Right

    Enum sınıfından türetilmiş olan sınıf türünden nesne yaratırken enum değeri verilebilir. Örneğin:

    e = Direction(2)
    print(e.name)           # Down

    Türetilerek yaratılmış enum sınıf türleri "dolaşılabilir" nesnelerdir. Dolaşıldıkça enum sabitleri elde edilmektedir. Örneğin:

    for x in Direction:
        print(x)

    enum sınıf ismi ile [...] operatörü kullanılırsa köşeli parantez içerisine enum sabitlerinin ismi yazı olarak verildiğinde onun değerini de 
    elde edebiliriz. Örneğin:
        
    x = Direction['Right']    
    print(x)

    Bütün bu olanaklar aslında taban Enum sınıfında sağlanmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import enum

class Direction(enum.Enum):
    Up = 0
    Right = 1
    Down = 2
    Left = 3
    
d = Direction.Down
print(d.value)      # 2
print(d.name)       # Down

k = Direction(2)
print(k)            # Direction.Down

for x in Direction:
    print(x, end=' ')   # Direction.Up Direction.Right Direction.Down Direction.Left 
print()

result = Direction['Down']
print(result)       # Direction.Down

#------------------------------------------------------------------------------------------------------------------------------------
    Standart kütüphanedeki "fonksiyonel programlama (functional programming)" paradigmasını desteklemek amacıyla itertools modülünün 
    yanı sıra functools isimli bir modül de bulundurulmuştur. functools modülü genel olarak dekoratör biçiminde kullanılmaya uygun 
    olan fonksiyonlardan ve sınıflardan oluşmaktadır.  
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    functools modülü içerisindeki cache isimli dekoratör fonksiyonu bir fonksiyonun bir argümanla çağrılması durumunda bu argümanla geri 
    dönüş değerini bir yerde saklar. Fonksiyon ikinci kez aynı argümanla çağrıldığında boşuna fonksiyonu çağırmadan doğrudan bize geri 
    dönüş değerini verir. Örneğin:

    import functools

    @functools.cache
    def foo(a):
        print('foo called')
        return a * a

    result = foo(10)        # fonksiyon gerçekten çağrılacak
    print(result)

    result = foo(15)        # fonksiyon gerçekten çağrılacak
    print(result)

    result = foo(10)        # fonksiyon çağrılmadan hemen 100 değerini verecek, çünkü daha önce 10 ile çağrıldığında 100 verilmişti
    print(result)

#------------------------------------------------------------------------------------------------------------------------------------

import functools

@functools.cache
def foo(a):
    print('foo called')
    return a * a

result = foo(10)
print(result)

result = foo(15)
print(result)

result = foo(10)
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    functools.cache dekoratörü birden fazla parametre alan fonksiyonlarda da kullanılabilir. Bu durumda geri dönüş değerinin cache'ten 
    alınması için tüm argümanların aynı olması gerekir. 
#------------------------------------------------------------------------------------------------------------------------------------

import functools

@functools.cache
def foo(a, b):
    print('foo called')
    return a + b

result = foo(2, 3)
print(result)

result = foo(4, 6)
print(result)

result = foo(2, 3)
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
                                    73. Ders 23/09/2023 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    functools.cache dekoratörü argüman değeri ile geri dönüş değeri arasında ilişki kurmaktadır. Yani cache sisteminin bir sözlükle 
    gerçekleştirildiğini varsayarsak burada anahtar argüman, değer ise geri dönüş değeridir. Eğer fonksiyon argümana bağlı bir geri 
    dönüş değerine sahip değilse ya da fonksiyon içerisinde bir "yan etki" oluşturacak başka işlemler yapılıyorsa bu dekoratör
    kullanılmamalıdır. 
#------------------------------------------------------------------------------------------------------------------------------------

import functools
import random

@functools.cache
def foo(a):
    print('foo called')
    return random.randint(0, 100)
    
result = foo(5)
print(result)           # 81, rastgele bir değer

result = foo(5)         
print(result)           # 81 çünkü fonksiyon çağrılmıyor

#------------------------------------------------------------------------------------------------------------------------------------
    functools modülü içerisindeki cache dekoratörünün bir benzeri basit bir biçimde aşağıdaki gibi yazılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import functools

class mycache:
    def __init__(self, f):
        self.f = f
        self.d = {}
        
    def __call__(self, *args):
        if result := self.d.get(args):
            return result
            
        val = self.f(*args)
        self.d[args] = val
        
        return val
      
@mycache
def foo(a):
    print('foo called')
    return a

val = foo(10)
print(val)
val = foo(20)
print(val)
val = foo(10)
print(val)

#------------------------------------------------------------------------------------------------------------------------------------
    functools modülündeki lru_cache isimli dekoratör aslında tamamen cache dekoratörü gibidir. Bunun tek farkı son maxsize tane değeri 
    tutmasıdır. Bu maxsize değeri belirtilmezse default 128 alınmaktadır. Buradaki LRU öneki "Least Recently Used" anlamına gelmektedir. 
    Yani son zamanlarda en az kullanılanın cache'ten atılacağını belirtir. Cache'te olan eski bir öğeyi kullanırsak bu öğre son zamanlarda
    kullanıldığı için öne çekilir ve cache'ten atılmaz. Örneğin cache uzunluğu 3 olsun biz de fonksiyonu sırasıyla şu argümanlarla çağırmış 
    olalım:

    val = foo(10)   
    print(val)      # foo çağrılır, 10

    val = foo(20)
    print(val)      # foo çağrılır, 20

    val = foo(30)
    print(val)      # foo çağrılır, 30

    val = foo(10)   
    print(val)      # foo çarıllmaz, 10

    val = foo(40)   
    print(val)      # foo çağrılır, 40 ve 20 cache'ten atılır

    val = foo(10)   
    print(val)      # foo çağrılmaz, 10

    val = foo(20)   # foo çarılır, 20
    print(val)

    Burada cache sırasıyla 10, 20, 30 yerleştirilmiştir. cache'in sonunda 10 vardır. Yeni bir eleman cache'e alınacaksa 10 çıkartılacaktır. 
    Ancak burada 10 değeri eklendikten sonra kullanılmış (cache hit) ve cache'te öne çekilmiştir. Böylece cache'ten atılacak olan değer
    artık 20 olacaktır. Görüldüğü gibi LRU cache algoritmasında her kullanılan eleman cache'te öne çekilmekte ve son zamanlarda en az kullanılan 
    cache'e arkada kalıp atılmaya aday olmaktadır. 
 #------------------------------------------------------------------------------------------------------------------------------------

import functools

@functools.lru_cache(3)
def foo(a):
    print('foo called')
    return a

val = foo(10)   
print(val)      # foo çağrılır, 10

val = foo(20)
print(val)      # foo çağrılır, 20

val = foo(30)
print(val)      # foo çağrılır, 30

val = foo(40)   
print(val)      # foo çağrılır, 40 ve 10 cache'ten atılır

val = foo(10)   
print(val)      # foo çağrılır, 10

val = foo(40)   # foo çağrılmaz, 40
print(val)

#------------------------------------------------------------------------------------------------------------------------------------
    functools modülündeki total_ordering dekoratörü bir sınıfa iliştirilebilir. Bu dekoratör < ve == operatör metotları bulunan sınıfta
    diğer operatör metotlarını bunları kullanarak yazmaktadır. Böylece biz bir sınıf için yalnızca bu iki operatör metodunu yazabiliriz. 
    Örneğin elimizde < ve == işlemini yapabilen metotlar varsa biz >= işlemini bunları kullanarak yapabiliriz. 
        
    Aşağıdaki örnekte Number sınıfı < ve == operatör metotlarını bulundurmuştur. Diğer karşılaştırma operatör metotları dekoratör tarafından 
    bunlar oluşturulacaktır. 
#------------------------------------------------------------------------------------------------------------------------------------

import functools

@functools.total_ordering
class Number:
    def __init__(self, val):
        self.val = val
        
    def __lt__(self, number):
        print('lt')
        return self.val < number.val
    
    def __eq__(self, number):
        print('eq')
        return self.val == number.val
   
x = Number(10)
y = Number(10)

if x <= y:
    print('ok')
else:
    print('not ok')
    
print('----------------')

x = Number(10)
y = Number(10)

if x > y:
    print('ok')
else:
    print('not ok')

#------------------------------------------------------------------------------------------------------------------------------------
    functools modülündeki partial isimli fonksiyon bir fonksiyonu ve ilk n tane argüman değerini parametre olarak alır ve bize 
    başka bir fonksiyon verir. Biz onun verdiği fonksiyonu çağırırken ilk n parametre için argüman girmeyiz. Yalnızca geri kalan k tane 
    parametre için argüman gireriz. İlk n tane parametre için argüman bizim partial fonksiyonuna verdiğimiz argüman olur. 
#------------------------------------------------------------------------------------------------------------------------------------

import functools

def foo(a, b, c):
    print(a, b, c)

bar = functools.partial(foo, 100, 200)

bar(20)         # 100 200 20
bar(30)         # 100 200 30

#------------------------------------------------------------------------------------------------------------------------------------
    functools modülündeki partialmethod isimli fonksiyon da partial fonksiyonu gibidir. Ancak sınıfın bir metodunu alarak onun ilk n 
    parametresi için yerleştirme yapar. Bu fonksiyon kullanılırken tipik olarak fonksiyonun geri döndürdüğü değer sınıtaki bir sınıf
    değişkenine (class attribute) atanmalıdır. Örneğin:

    class Sample:
        def foo(self, a, b, c):
            print(a, b, c)
            
        bar = functools.partialmethod(foo, 100, 200)

#------------------------------------------------------------------------------------------------------------------------------------

import functools

class Sample:
    def foo(self, a, b, c):
        print(a, b, c)
        
    bar = functools.partialmethod(foo, 100, 200)
    
s = Sample()

s.foo(10, 20, 30)       # 10 20 30
s.bar(10)               # 100 200 10

#------------------------------------------------------------------------------------------------------------------------------------
    functools modülündeki reduce fonksiyonu aslında itertools modülündeki accumulate fonksiyonuna çok benzemektedir. Ancak reduce fonksiyonu
    accumulate gibi her değeri değil yalnızca sonuç değerini bize verir. reduce fonksiyonunun birinci parametresi bir fonksiyon olmalıdır. 
    Bu fonksiyon bir önceki değerle yeni sıradaki değer argüman yapılıp çağrılmaktadır. 

    Aşağıdaki örnekte her iki fonksiyon da birlikte kullanılmıştır. itertools.accumulate bize bir itertor nesnesi verirken functools.reduce 
    bize tek bir değer vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

iterator = itertools.accumulate([1, 2, 3, 4, 5], lambda a, b: a + b)

for x in iterator:
    print(x)
    
import functools

result = functools.reduce(lambda total, item: total + item, [1, 2, 3, 4, 5])
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Bilindiği Python'da tüm atamalar aslında adres atamasıdır. Örneğin:

    a = [1, 2, 3, 4, 5] 
    b = a

    Burada b = a atamasıyla yeni bir nesne yaratılmamaktadır. a ve b aynı nesnenin adreslerini tutmaktadır. Yani a is b True verir. 

    Biz bazen değiştirilebilir nesnelerin yeni kopyasını oluşturmak isteyebiliriz. Çünkü birinin bozulması durumunda diğerinin 
    değerini korunması gerekebilir. Tabii temel türlerde olduğu gibi değiştirilemez türlerin kopyasının oluşturulmasının bir anlamı yoktur. 
    Örneğin bir string "değiştirilemez (immutable)" bir nesnedir. Bizim onun kopyasını oluşturmamızın bir anlamı yoktur. 
    
    Python'da değiştirilebilir olan list gibi, set gibi, dict gibi sınıflara ilişkin nesnelerin kopyalarını çıkartmak için zaten bu 
    sınıflarda copy isimli metotlar bulunmaktadır. Örneğin:

    >>> a = [1, 2, 3, 4, 5]
    >>> id(a)
    1954630234624
    >>> b = a.copy()
    >>> b
    [1, 2, 3, 4, 5]
    >>> id(b)
    1954630260032
    >>> a = {'ali': 10, 'veli': 20, 'selami': 30}
    >>> b = a.copy()
    >>> id(a)
    1815000300928
    >>> id(b)
    1815000319488
    >>> a = {1, 2, 3, 4, 5}
    >>> b = a.copy()
    >>> id(a)
    1814999063840
    >>> id(b)
    1814999060704

    Yine dilimleme, ve yineleme (repition) gibi işlemlerin aslında kopya yoluyla yapıldığını anımsayınız. 
    
    Ancak biz kendi sınıfımızın kopyasını da oluşturmak isteyebiliriz. İşte bunun için copy modülünde copy ve deepcopy isimli iki fonksiyon 
    bulundurulmuştur. copy fonksiyonu "sığ kopyalama (shallow copy)", deepcopy fonksiyonu ise "derin kopyalama (deep copy)" işlemi yapmaktadır. 
    Sığ kopyalama ana nesnenin kopyasının çıkartılması ama elemanlar için kopya çıkartılmaması anlamına gelir. Derin kopyalama ise 
    "özyinelemeli (recursive)" biçimde tüm nesnenin kopyalarının çıkartılmasını sağlamaktadır. 

    Örneğin biz Sample sınıfı türünden bir nesnenin elemanlarını değiştirmeden önce onun bir kopyasını çıkartarak eski halini saklamak 
    isteyebiliriz:

    import copy 
    ....
    s = Sample(10, 20)
    k = copy.copy()
    
#------------------------------------------------------------------------------------------------------------------------------------

import copy 

class Sample:
    def __init__(self, a, b):
        self.a = a
        self.b = b
        
    def __repr__(self):
        return f'a = {self.a}, b = {self.b}'
    
s = Sample(10, 20)
print(s)

k = copy.copy(s)

s.a = 100
s.b = 200

print(s)
print(k)

print(f'id(s): {id(s)}')
print(f'id(k): {id(k)}')

#------------------------------------------------------------------------------------------------------------------------------------
                                                    74. Ders 29/09/2023 – Cuma
#------------------------------------------------------------------------------------------------------------------------------------


#------------------------------------------------------------------------------------------------------------------------------------
    Sığ kopyalamada yalnızca ana nesnenin kopyası çıkartılmaktadır. Dolayısıyla ana nesnenin bir örnek özniteliği "değiştirilebilir (mutable)"
    bir nesne ise bu nesnenin kopyası çıkartılmaz. Derin kopyalama daha fazla zaman alan ve daha fazla bellek kullanan bir kopyalama biçimidir. 
    Bu nedenle programcı gerekmediği durumda derin kopyalama yapmamalıdır. Sığ kopyalamayı tercih etmelidir.  
    
    Aşağıdaki örnek Sample sınıfının bir örnek özniteliği bir listedir. Sığı kopyalama yapıldıktan sonra bu listenin elemanları değiştirilirse 
    bundan diğer kopya da etkilenecektir. 
#------------------------------------------------------------------------------------------------------------------------------------

import copy

class Sample:
    def __init__(self, *args):
        self.a = list(args)
        
    def square(self):
        for i in range(len(self.a)):
            self.a[i] *= self.a[i] 
            
    def __repr__(self):
        s = ''
        for x in self.a:
            if s != '':
                s += ', '
            s += str(x) 
        return s
              
s = Sample(1, 2, 3, 4)
print(s)
k = copy.copy(s)
print(k)

s.square()
print(s)
print(k)

print('---------------------------')

s = Sample(1, 2, 3, 4)
print(s)
k = copy.deepcopy(s)
print(k)

s.square()
print(s)
print(k)

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii derin kopyalama sırasında değiştirilemez türlere ilişkin elemanların kopyaları çıkartılmamaktadır. Zaten değiştirilemez
    türlerin kopyasının çıkartılmasının bir anlamı da yoktur.

    Aşağıdaki örnekte Sample sınıfının int türden değiştirilemez bir örnek özniteliği vardır. Bu durumda Sample nesnesinin sığ ya da 
    derin kopyalama yöntemiyle kopyalanması arasında bir fark yoktur. 
#------------------------------------------------------------------------------------------------------------------------------------

import copy

class Sample:
    def __init__(self, a):
        self.a = a
            
s = Sample(10)
k = copy.deepcopy(s)

print(id(s), id(k))
print(id(s.a), id(k.a))

#------------------------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi Python'un float türü IEEE 754 formatını kullanmaktadır. Zaten bugün hemen her CPU gerçek sayıları bu formatta ele 
    alıp eletrik devreleriyle işlem yapmaktadır. Dolayısıyla float türü de bu bağlamda doğal ve hızlı bir türdür. Ancak maalesef IEEE 754
    fotmatının (genel olarak floating point formatların) "yuvarlama hatası (rounding error)" denilen bir problemi vardır. Yuvarlama 
    hatası bazı noktalı sayıların tam olarak ifade edilemeyip ancak onlara yakın bir sayının ifade edilebilmesiyle oluşan hatadır. 
    Yuvarlama hataları pek çok uygulamada önemsiz olarak değerlendirilebilir. Ancak muhasebe gibi, finans gibi, savunma sanayi gibi, 
    uzay hesapları gibi kritik uygulamalarda yuvarlama hataları hiç istenmeyebilir. İşte Python'un standart kütüphanesinde decimal 
    isimli modüldeki Decimal sınıfı yuvarlama hatasına maruz kalmadan noktalı sayılarla işlemlerin yapılabilmesi için düşünülmüştür. 

    Bir Decimal nesnesi "bir string'le", "int bir değerle" ya da "float bir değerle" oluşturulabilmektedir. Decimal sınıfının çeşitli 
    operatör metotları vardır. Bu operatör metotları sayesinde Decimal türden iki nesne sanki float türünden iki nesneymiş gibi işlemlere 
    sokulabilmektedir. Örneğin:

    >>> import decimal
    >>> a = decimal.Decimal('0.3')
    >>> b = decimal.Decimal('0.2')
    >>> c = a - b
    >>> print(c)
    0.1
    >>> a = 0.3
    >>> b = 0.2
    >>> c = a - b
    >>> c
    0.09999999999999998

    Bu örnekte Decimal nesnenin yuvarlama hatasına yol açmadığına ancak float türün yuvarlama hatasına yol açabildiğine dikkat ediniz.     
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii bir Decimal nesnenin float bir değerle oluşturulması kullanım alanı bakımından uygun olmayabilir. Örneğin:

    >>> a = Decimal(1.2)
    >>> a
    Decimal('1.1999999999999999555910790149937383830547332763671875')
    >>> b = Decimal('1.2')
    >>> b
    Decimal('1.2')

    Genel olarak biz iki Decimal nesneyi ya da bir Decimal nesneyle bir int nesneyi işleme sokabiliriz. Ancak bir Decimal nesneyle bir 
    float nesneyi ya da bir Decimal nesneyle bir string'i işleme sokamayız. Bir Decimal nesneyle bir int nesne işleme sokulduğunda sonuç 
    Decimal türden elde edilir. Bunu sembolik olarak şöyle belirtebiliriz:

    Decimal <op> Decimal    => Decimal
    Decimal <op> int        => Decimal
    Decimal <op> float      Geçersiz!  
    Decimaş <op> str        Geçersiz!
    
    Örneğin:

    >>> a = Decimal('1.2')
    >>> b = a + 10
    >>> b
    Decimal('11.2')
    >>> a + 3.2
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: unsupported operand type(s) for +: 'decimal.Decimal' and 'float'
    >>> a + '1.2'
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: unsupported operand type(s) for +: 'decimal.Decimal' and 'str'

    Bir Decimal nesne float türüne, int türüne ve bool türüne döüştürülebilir. Çünkü Decimal sınıfı için bu dönüşümleri yapabilecek 
    __float__, __int__ ve __bool__ operatör metotları bulundurulmuştur. Örneğin:

    >>> d = Decimal('3.141592653589793238462643')
    >>> d
    Decimal('3.141592653589793238462643')
    >>> float(d)
    3.141592653589793
    >>> int(d)
    3
    >>> bool(d)
T   True

    Normal olarak math modülündeki fonksiyonların Decimal türü ile kullanımı konusunda Standart Kütüphane dokümanlarında bir belirleme 
    yapılmamıştır. Eskiden bu fonksiyonların Decimal türü ile kullanımlarında sorun oluşuyordu. Ancak bu fonksiyonlar daha sonraları 
    kendi içlerinde argümanları float türüne dönüştürmeye başlamıştır. Bu nedenle Decimal türler de math modülündeki fonksiyonlar 
    tarafından kullanılabilir duruma gelmiştir. Ancak bu durum Standart Kütüphanede dokümante edilmemiştir. Bu nedenle Decimal türünü 
    math modülündeki fonksiyonlarla doürudan kullanmayınız. Tabii bir Decimal nesnesini float türüne dönüştürerek math modülündeki 
    fonksiyonlarla kullanabiliriz. Ancak  Decimal sınıfında da math modülündeki işlemleri sqrt, ln, log10 gibi metotlar bulundurulmuştur. 
    Tabii bu metotların geri dönüş deperleri Decimal türdendir. Örneğin:

    >>> d = Decimal('3.141592653589793238462643')
    >>> math.sqrt(d)
    1.7724538509055159
    >>> d.sqrt()
    Decimal('1.772453850905516027298167375')
    >>> math.log10(d)
    0.49714987269413385
    >>> d.log10()
    Decimal('0.4971498726941338543512682353')

#------------------------------------------------------------------------------------------------------------------------------------

from decimal import Decimal

d = Decimal(2)

result = d.sqrt()
print(result)

result = d.ln()
print(result)

result = d.log10()
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Decimal modülündeki Decimal sınıfı ile işlemler yapılırken bazı belirlemelere uyulmaktadır. Bu belirlemelere "context" denilmektedir. 
    Bu belirlemeler getcontext() fonksiyonu ile elde edilebilir. context nesnesi getcontext fonksiyonuyla elde edildikten sonra nesne 
    üzerinde değişikler yapılabilmektedir. getcontext ile alınan bağlam nesnesi "thread temelinde singleton" bir nesnedir. Yani bu 
    nesnenin toplamda her thread için tek bir kopyası vardır. Biz aynı thread'te birden fazla kez getcontext fonksiyonunu çağırsak bile 
    bu fonksiyon bize hep aynı değeri verir. Bağlam nesnesi getcontext fonksiyonuyla alınıp onun belli elemanları değiştirilebilir. 
    Ya da istenirse yeni context nesnesi oluşturulup setcontext fonksiyonuyla bu nesne set edilebilir. Bağlam nesnesinin en önemli 
    elemanlarından biri "prec" elemanıdır. Bu prec elemanı Decimal sayıların işlem duyarlılığını belirtmektedir. Bu elemanın default 
    değeri 28'dir. Bu değer Decimal sayının toplam mantisini (yani tam kısmı ve noktalı kısmının toplam basamak sayısını) belirtmektedir.
    Örneğin:

    >>> import decimal
    >>> d = decimal.Decimal(3)
    >>> d.sqrt()
    Decimal('1.732050807568877293527446342')
    >>> c = decimal.getcontext()
    >>> c.prec = 100
    >>> d.sqrt()
    Decimal('1.732050807568877293527446341505872366942805253810380628055806979451933016908800037081146186757248576')

    prec elemanının değerini değiştirdiğimizde Decimal nesne yine bizim verdiğimiz duyarlılıkta sayıyı tutar. Bu prec elemanı işlem 
    sonucundaki elde edilen Decimal nesne üzerinde etkili olmaktadır. Örneğin:

    >>> import decimal
    >>> decimal.getcontext().prec = 3
    >>> x = decimal.Decimal('1.234567')
    >>> x
    Decimal('1.234567')
    >>> x + 1
    Decimal('2.23')

    Buradaki yuvarlama da aslında birkaç seçenekten biri olarak seçilebilir. Yuvarlamanın biçimi bağlam nesnesinin rounding elemanı 
    ile belirlenmektedir. Bu eleman default olarak decimal.ROUND_HALF_EVEN biçimindedir. ROUND_HALF_EVEN durumunda sayı yuvarlanacağı 
    zaman yuvarlama yerinde 5 varsa ve başka bir digit yoksa bu durumda sayının noktadan sonraki kısmı çift olacak biçimde yuvarlanır. ROUND_HALF_UP 
    durumunda ise klasik biçimde [0,4] aşağıya, [5, 9] yukarıya yuvarlanmaktadır. Örneğin:

    >>> import decimal
    >>> decimal.getcontext().prec=3
    >>> d = decimal.Decimal('1.265')
    >>> d + 0
    Decimal('1.26')
    >>> decimal.getcontext().rounding = decimal.ROUND_HALF_UP
    >>> d + 0
    Decimal('1.27')

    Python'un built-in round fonksiyonu da buradaki ROUND_HALF_EVEN gibi çalışmaktadır. Örneğin:

    Decimal('1.27')
    >>> f = 1.265
    >>> round(f, 2)
    1.26
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Rasyonel sayılar a ve b birer tamsayı ve b 0'a eşit olmamak üzere olmak üzere a / b biçiminde yazılan sayılardır. Matematikte rasyonel 
    sayılar kümesi tamsayılar kümesini kapsamaktadır. Python'un standart kütüphanesindeki fractions isimli modülde Fraction isimli sınıf 
    rasyonel sayıları temsil etmektedir. Bir Fraction nesnesi pay ve payda belirtilerek yaratılabilir. Örneğin:

    from fractions import Fraction

    x = Fraction(3)       # 3/1 ile aynı anlamda
    y = Fraction(2, 3)    # 2/3 ile aynı anlamda

    İngilizce "pay" sözcüğü "numerator" sözcüğü ile "payda" sözcüğü "denominator" sözcüğü ile ifade edilmektedir. Bir Fraction nesnesi 
    float bir nesneyle de yaratılabilmektedir. Örneğin:

    x = Fraction(0.5)

    Birs string'ten de Fraction nesnesi oluşturulabilmektedir. Örneğin:

    x = Fraction('1/2')

    Fraction sınıfının pek çok operatör metodu rasyonel sayı işlemlerini yapmaktadır. math modülündeki matematiksel fonksiyonlar da 
    Fraction nesneleri ile çalışmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

from fractions import Fraction

x = Fraction(1, 2)
print(x)

y = Fraction(1, 3)
print(y)

result = x + y
print(result)       # 5/6

result = x + y * 2
print(result)       # 7/6

result = x ** 2
print(result)       # 1/4

import math

result = math.sqrt(x)
print(result)       # 0.7071067811865476

result = math.sin(x)
print(result)       # 0.479425538604203

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Fraction nesnesindeki pay ve payda değerleri numerator ve denominator öznitelikleri ile elde edebilir. 
#------------------------------------------------------------------------------------------------------------------------------------
    
from fractions import Fraction

x = Fraction(1, 2)
print(x.numerator, x.denominator)

#------------------------------------------------------------------------------------------------------------------------------------
    Fraction sınıfının as_integer_ratio metodu bize rasyonel sayının pay ve paydasını iki tane int değerden oluşan bir demet olarak verir. 
    Örneğin:

    >>> from fractions import Fraction
    >>> x = Fraction(1, 2)
    >>> a, b = x.as_integer_ratio()
    >>> a
    1
    >>> b
    2

    Biz Fraction sınıfında bir float sayı verdiğimizde sınıf bunu otomatik olarak rasyonel sayı biçimine getirmektedir. Ancak biz 
    limit_denominator metodu ile bu sayıların basamaklarını sınırlandırabiliriz. Örneğin:

    >>> from fractions import Fraction
    >>> Fraction('3.1415926535897932')
    Fraction(7853981633974483, 2500000000000000)
    >>> Fraction('3.1415926535897932').limit_denominator(1000)
    Fraction(355, 113)
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Nesne Yönelimli Programlama Tekniğinde (NYPT) "soyut sınıf (abstract class)" kendisinden nesne yaratılamayan içerisindeki soyut 
    metotları sınıftan türetme yapan kişilerin yazmak (override etmek) zorunda olduğu özel sınıflardır. Soyut sınıflar "bir kontrat 
    oluşturmak" için, "arayüz oluşturmak için", birtakım minimal gereksinimlerin karşılanması için kullanılabilmektedir. Java ve C# 
    gibi dillerdeki "arayüzler (interface)" benzer amaçla kullanılıyor olsa da soyut sınıflardan farklıdır. Bu dillerde arayüzler 
    veri elemanlarına (fields) sahip olamazlar ve soyut olmayan metot içeremezler. Halbuki soyut sınıflar veri elemanlarına (fields)
    sahip olabilmekte ve soyut olmayan metotlar içerebilmektedir. 

    Bir soyut sınıfı Python'da oluşturabilmek için abc isimli modüldeki ABC sınıfından faydalanılmaktadır. (Buradaki abc ismi "abstract 
    base class sözcükleriden" kısaltılmıştır.) Programcı abc.ABC sınıfından türetme yaparsa türettiği sınıf soyut sınıf olur. Örneğin:

    import abc

    class Sample(abc.ABC):
        pass

    Bir soyut sınıf soyut metotları oluşturmak için kullanılmaktadır. Yani biz bir soyut sınıfa soyut metot yerleştirmezsek soyut sınıf 
    oluşturmamızın bir anlamı kalmaz. Bir soyut sınıfa soyut metot yerleştirmek için soyut metodun abc.abstractmethod dekoratörü ile 
    dekore edilmesi gerekmektedir. Örneğin:

    import abc

    class Sample(abc.ABC):
        def foo(self):
            print('foo')
        
        @abc.abstractmethod
        def bar(self):
            pass

    Soyut sınıftaki soyut metot normal bir metot gibi suit içerebilir. Örneğin:

    import abc

    class Sample(abc.ABC):
        def foo(self):
            print('Sample.foo')
        
        @abc.abstractmethod
        def bar(self):
            print('abstract bar')

    Soyut bir sınıfa soyut bir metot yerleştirilirse artık o soyut sınıf türünden nesneler yaratılamaz. Örneğin:

    s = Sample()            # exception oluşur

    Soyut bir sınıfın kendisi bir işe yaramaz. Ondan türetme yapılması ve taban sınıftaki soyut metotların türemiş sınıfta yazılması 
    (override edilmesi) gerekir. Örneğin:

    import abc

    class Sample(abc.ABC):
        def foo(self):
            print('foo')
        
        @abc.abstractmethod
        def bar(self):
            pass
        
    class Mample(Sample):
        pass

    Ancak soyut bir sınıftan türetme yapıldığında türemiş sınıf taban soyut sınıftaki soyut metotları barındırmazsa türemiş sınıf da 
    soyut olur ve türemiş sınıf türünden de nesneler yaratılamaz. Yukarıdaki örneğimizde Mample sınıfı Sample soyut sınıfındaki bar 
    isimli soyut metodu tanımlamamıştır. O halde bu Mample sınıfı da soyut bir sınıftır. Biz Mample sınıfı türünden de nesneler 
    yaratamayız. Örneğin:

    m = Mample()        # exception oluşur

    Şimdi Mample sınıfına bar metodunu ekleyelim:

   import abc

    class Sample(abc.ABC):
        def foo(self):
            print('foo')
        
        @abc.abstractmethod
        def bar(self):
            pass
        
    class Mample(Sample):
        def bar(self):
            print('Mample.bar')
     
    Şimdi artık Mample sınıfı türünden nesneler yaratabiliriz:

    m = Mample()        # geçerli
    m.bar()
    m.foo()

    Görüldüğü gibi artık türemiş Mample sınıfı türünden nesneler yaratabilmekteyiz. 

    Yukarıda da belirttiğimiz gibi bir soyut sınıftan türetme yapıldığında türemiş sınıfın soyutluktan kurtulup somut (concrete) 
    hale gelebilmesi için taban soyut sınıftaki bütün soyut metotları barındırması gerekir. Örneğin:

  import abc

    class Sample(abc.ABC):
        def foo(self):
            print('foo')
        
        @abc.abstractmethod
        def bar(self):
            pass
        
        @abc.abstractmethod
        def tar(self):
            pass
        
    class Mample(Sample):
        def bar(self):
            print('Mample.bar')
            
    m = Mample()

    Burada Mample sınıfı Sample sınıfından türetilmiştir. Ancak Sample sınıfındaki yalnızca bar soyut metodunu barındırmıştır. Bu 
    durumda Mample sınıfı da soyuttur. Mample sınıfı türünden de nesneler yaratamayız. Örneğin:

    m = Mample()            # exception oluşur

    Ancak buradaki Mample sınıfı Sample sınıfınındaki bar ve tar soyut metotlarının  her ikisini barındırırsa (override ederse) Mample
    sınıfı somut hale getirilebilir. Örneğin:

    import abc

    class Sample(abc.ABC):
        def foo(self):
            print('foo')
        
        @abc.abstractmethod
        def bar(self):
            pass
        
        @abc.abstractmethod
        def tar(self):
            pass
        
    class Mample(Sample):
        def bar(self):
            print('Mample.bar')
            
        def tar(self):
            print('Mample.tar')
            
    m = Mample()
    m.foo()
    m.bar()
    m.tar()

#------------------------------------------------------------------------------------------------------------------------------------    
                                             75. Ders 30/09/2023 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Python'da "meta class" konusu genellikle programcıların doğrudan kullanmadığı nispeten kişilere soyut gelen bir konudur. Ancak 
    ayrıntılı birtakım modüllerin yazılması gerektiği durumlarda meta. "meta class" konusundan faydalanılması gerekebilmektedir. Meta 
    sözcüğü "bir olgunun kendisini betimleyen olgular için" kullanılmaktadır. Örneğin "meta data" data'yı betimleyen data anlamındadır. 
    Yani bir verinin neresinde ne olduğunu anlatan verilerdir. "Meta language" dilleri betimleyen dildir. İşte Python'daki "meta class" 
    kavramı da benzerdir. Türkçe'de meta sözcüğünün karşılığı olarak genellikle "üst" sözcü kullanılmaktadır. Ancak bir "meta class" 
    terimi için "meta sınıf" terimini kullanacağız.

    Python'da yorumlayıcı bir sınıf tanımlamasıyla karşılaştığında önce type sınıfı türünden bir nesne yaratır. Sonra bu nesnenin içerisine
    sınıfın içerisindeki bilgileri yerleştirir. Sonra da bu nesnenin adresini sınıf ismiyle belirtilen değişkene atar. Örneğin:

    class Sample:
        pass

    Burada Sample aslında type türünden bir sınıf nesnesini belirtmektedir. Sample değişkeninin diğer değişeknlerden bir farkı yoktur. Örneğin:

    >>> class Sample:
    ...     pass
    ...
    >>> type(Sample)
    <class 'type'>
    >>> id(Sample)
    1971454719296
    >>> print(Sample)
    <class '__main__.Sample'>
    
    Tabii Sample sınıfı türünden bir nesne yatattığımızda onun türü  artık Sample olacaktır. Örneğin:

    >>> class Sample:
    ...     pass
    ...
    >>> type(Sample)
    <class 'type'>
    >>> s = Sample()
    >>> type(s)
    <class '__main__.Sample'>

    Yani burada Sample değişkeni type türündedir, s değişkeni ise Sample türündendir. 

    Sınıf isimleri sıradan birer değişken olduğuna göre başka değişkenlere atanabilirler. Örneğin:

    >>> class Sample:
    ...     pass
    ...
    >>> Mample = Sample
    >>> s = Mample()
    >>> print(s)
    <__main__.Sample object at 0x000001EE96089ED0>

    Burada biz Sample değişkenini Mample değişkenine atadık. Böylece aslında Sample değişkeni ile Mample değişkeni aynı type nesnesini
    gösterir hale geldi. Nesneyi Sample() biçiminde yaratmakla Mample() biçiminde yaratmak arasında bir fark kalmadı.

    Python'da type sınıfında olduğu gibi bir sınıfın bilgilerini tutan sınıfa "meta sınıf (meta class)" denilmektedir. type bir meta 
    sınıftır. Bir sınıf tanımladığımızda yorumlayıcı default olarak meta sınıf olarak type sınıfını kullanmaktadır. Ancak biz kullanılacak
    meta sınıfı değiştirebiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Öncelikle default meta sınıf olan tope sınıfı hakkında bazı bilgiler vermek istiyoruz. type fonksiyonunu biz bir değişkenin türünü
    elde etmek için kullanmıştık. Örneğin:

    >>> a = 10
    >>> type(a)
    <class 'int'>

    type fonksiyonu aslında bize ilgili değişkenin türüne ilişkin sınıf bilgilerinin yerleştirilmiş olduğu type nesne referansını vermektedir. 
    Yukarıdaki örnekte type(a) ile int aynı anlamdadır. Çünkü int fdeğişkeni aslında int isimli sınıfın bilgilerinin tutulduğu type nesnesinin
    adresini tutan bir değişkendir. type(a) ifadesi de bize aynı nesnenin adresini vermektedir. O halde type(a) ile verilen adres ile int 
    değişkeninin içerisindek adres aynı type nesnesi göstermektedir. Yorumlayıcı her sınıf için yalnızca bir tane type nesnesi oluşturmaktadır. 
    Örneğin:

    >>> a = 10
    >>> t = type(a)
    >>> t is int
    True
    >>> id(t)
    140704769070640
    >>> id(int)
    140704769070640

    Aynı durum bizim oluşturduğumuz sınıflar için de geçerlidir. Örneğin:

    >>> class Sample:
    ...     pass
    ...
    >>> s = Sample()
    >>> t = type(s)
    >>> t is Sample
    True

    type sınıfının __str__ ve __repr__ metotları o type nesnesi içerisinde hangi sınııfn bilgileri varsa bize o sınııfn ismini bir string
    olarak vermektedir. Örneğin:

    >>> class Sample:
    ...     pass
    ...
    >>> print(Sample)
    <class '__main__.Sample'>
    >>> print(repr(Sample))
    <class '__main__.Sample'>

    Bu nedenle biz bir sınıf türünden değişkeni type fonksiyonuna sokup onu yazdırdığımızda o değişkenin türü ekrana çıkmaktadır. Örneğin:

    >>> s = Sample()
    >>> print(type(s))
    <class '__main__.Sample'>

    Mademki yorumlayıcı bir sınıf tanımlaması gördüğünde aslında type sınıfı türünden bir nesne yaratmaktadır. O halde biz de hiç 
    sınıf tanımlaması yapmadan type sınıfı türünden bir nesne yaratırsak aslında bir sınıf oluşturmuş oluruz. İşte type fonksiyonu üç 
    argümanla çağrılırsa (yani type sınıfının __init__ metodu üç argümanla çağrılırsa) type fonksiyonu bize yeni bir type nesnesi yaratır 
    ve o type nesnesinin nesne  adresini verir. O halde bir sınıf yaratmak için sınıf tanımlamak yerine biz doğrudan bu işi type fonksiyonuyla 
    da yapabiliriz. Zaten yorumlayıcı bir sınıf tanımlamasını gördüğünde aslında kendisi type fonksiyonunu çağırıp sınıfı oluşturmaktadır. 

    type fonksiyonun bir argümanla çağrılmasıyla üç argümanla çağrılması arasındaki önemli farka dikkat ediniz. type fonksiyonu bir argümanla 
    çağrıldığında bize o argümanın ilişkin olduğu sınıfın type nesnesinin adresini vermektedir. Ancak type fonksiyonu üç argümanla çağrılırsa 
    bu bir "sınıf yaratma" anlamına gelmektedir. type fonksiyonunun üç argümanı şunları belirtmelidir:

    type(sınıf_isim, taban_sınıflarını_belirten_demet, sınıfın_elemanlarını belirten_sözlük)

    Taban sınıflar bir demet biçiminde verilmelidir. Burada boş demet geçilse bile yine sınıf object sınıfından türetilmiş olacaktır. 
    Sınıfın elemanları ise bir sözlük biçiminde verilmelidir. Aslında Python yorumlayıcısı da bir sınıfla karşılaştığında zaten o sınıfı type 
    fonksiyonuyla yaratmaktadır. Sınıfın elemanları type nesnesinin içerisindeki bir sözlükte tutulmaktadır. Örneğin:

    class Sample:
        x = 10
        def foo(self, a):
            return a * a

    Böyle bir sınıf bildirimini gören yorumlayıcı aslında type fonksiyonu ile şöyle bir nesne yaratmaktadır:

    Sample = type('Sample', (object, ), {'x': 10, 'foo': foo})

    Mademki yorumlayıcı bir sınıf tanımlamasını gördüğünde type sınıfı türünden bir nesne yaratmaktadır. O halde aslında aynı şeyi biz de yapabiliriz:

    def foo(self, a):
        return a * a

    Sample = type('Sample', (object, ), {'x': 100, 'foo': foo})

    s = Sample()

    print(s.x)
    result = s.foo(4)
    print(result)

#------------------------------------------------------------------------------------------------------------------------------------

def foo(self, a):
    return a * a

Sample = type('Sample', (object, ), {'x': 100, 'foo': foo})

s = Sample()

print(s.x)
result = s.foo(4)
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir sınıf için yaratılan type nesnesinin içerisinde hangi elemanlar vardır? Aslında type sınıfının kendisi de objet sınıfından 
    türetilmiştir. Bu nedenle type nesnesinin içerisinde object sınıfının elemanları olacaktır. Örneğin:

    >>> type.__bases__
    (<class 'object'>,)
    >>> dir(type)
    ['__abstractmethods__', '__annotations__', '__base__', '__bases__', '__basicsize__', '__call__', '__class__', '__delattr__', '__dict__
    ', '__dictoffset__', '__dir__', '__doc__', '__eq__', '__flags__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', 
    '__init_subclass__', '__instancecheck__', '__itemsize__', '__le__', '__lt__', '__module__', '__mro__', '__name__', '__ne__', '__new__', '__or__', 
    '__prepare__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__ror__', '__setattr__', '__sizeof__', '__str__', '__subclasscheck__', 
    '__subclasses__', '__subclasshook__', '__text_signature__', '__weakrefoffset__', 'mro']
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında yorumlayıcı bir sınıf nesnesinin içerisine __dict__ isimli bir sözlük elemanı yerleştirmektedir. Yani type fonksiyonuyla verilen
    sözlük istenirse sınfın __dict__ elemanı ile elde edilebiilir. __dict__ bir sınıf değişkenidir. Bu nedenle sınıf ismiyle ya da o sınıf türünden 
    bir değişkenle kullanılablir.  Örneğin:

    class Sample:
        def foo(self):
            pass
    
        def bar(self):
            pass
        
    x = 10
        
    d = Sample.__dict__
    print(d)

    Buradan şöyle çıktı elde edilmiştir:

    {'__module__': '__main__', 'foo': <function Sample.foo at 0x00000214C935E280>, 'bar': <function Sample.bar at 0x00000214C935E040>, 
    'x': 10, '__dict__': <attribute '__dict__' of 'Sample' objects>, '__weakref__': <attribute '__weakref__' of 'Sample' objects>, 
    '__doc__': None}

    Burada __doc__ ve __weakref__ gibi bizim bulundurmadığımız iki elemanı da görüyorsunuz. __doc__ sınıfın doküman yazısını belirtir. 

    Tabii aslında bir sınıf türünden nesnenin içerisine de bir __dict__ elemanı yerleştirilmektedir. Örneğin:

    def foo(self):
        pass

    d = {'x': 10, 'foo': foo}
    Sample = type('Sample', (object, ), d)

    s = Sample()
    print(s.__dict__)

    Burada ekrana şunlar basılmıştır:

    {'x': 10, 'foo': <function foo at 0x0000014FA81C3640>, '__module__': '__main__', '__dict__': <attribute '__dict__' of 'Sample' objects>,
     '__weakref__': <attribute '__weakref__' of 'Sample' objects>, '__doc__': None}
    {}

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                                76. Ders 06.10.2023 - Cuma
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi a bir sınıf türünden değişken olmak üzere a(...) biçiminde bir ifade yazdığımızda aslında bu ifade a.__call__(...) 
    anlamına gelmekteydi. Yani bir sınıf türünden değişkeni (...) operatörü ile kullandığımızda aslında o değişkenin ilişkin olduğu
    sınıfın __call__ metodu çağrılmaktadır. O halde bir sınıf türünden nesne yaratma işlemi de aslında type sınıfının __call__ metodu ile
    yapılmaktadır. Örneğin:

    class Sample:
        pass

    s = Sample()        # Sample type türünden olduğuna göre nesne type sınıfının __call__ metodu tarafından yaratılır. 

    Burada Sample aslında type türünden bir nesneyi göstermektedir. O halde Sample(...) işleminde aslında type sınıfının __call__ metodu
    çağrılacaktır. Başka bir deyişle aslında nesneyi yaratmaktan sorumlu olan ana mekanizma type sınıfının __call__ metodudur.
    
    Pekiyi type sınıfının __call__ metodu nesneyi nasıl yaratmaktadır? İşte type sınıfının __call__ metodu önce sınıf nesnesini bellekte 
    yaratmak için söz konusu sınıfın ile __new__ isimli statik metodu çağırmaktadır. Eğer bu __new__ metodu ilgili sınıf türünden bir type 
    nesnesi verirse bu durumda o nesneyle bu kez __init__ metodunu çağırmaktadır. Yani tasarımda nesnenin bellekte tahsis edilmesi ile tahsis 
    edilmiş nesneye ilkdeğerlerinin verilmesi biribirinden ayrılmıştır. __new__ metodu nesneyi tahsis etmek için kullanılırken __init__ 
    metodu tahsis edilmiş nesne üzerinde birtakım ilkdeğerlerin verilmesi için kullanılmaktadır. Bu durumda type sınıfının nesne yarqatımını 
    yapan __call__ metodu nesneyi şöyle yaratmaktadır:

    1) Önce sınıf türüyle __new__ static metodunu çağırır. Tahsisat bu metot tarafından yapılmalıdır. bu noktada yaratılmak istenen sınıfın 
    __new__ metodu çağrılmaktadır.

    2) __new__ metodunun geri döndürdüğü nesne eğer __call__ metodunun çağrıldığı nesne türündense bu kez __init__ metodunu çağırmaktadır. 
    
    Yani type sınıfının __call__ metodu temsili olarak şöyle yazılmıştır:

    class type:
        def __call__(self, *args, **kwargs):
            if self.__new__ is not object.__new__:
                o = self.__new__(self, *args, **kwargs)
            else:
                o = object.__new__(self)

            if o is self:
                o.__init__(*args, **kwargs)
            return o

    Buradan görüldüğü gibi bir nesne yaratılırken aslında önce o sınıfın static __new__ isimli static metodu çağrılmaktadır. O metodun geri 
    döndürdüğü nesne eğer tahsis edilmek istenen sınıf türündense o nesne ile __init__ çağrılmaktadır. Pekiyi programcı kendi sınıfı 
    için __new__ metodunu yazmazsa ne olur? Bu tür durumda bildiğiniz gibi o sınıfın __new__ metodu olan ilk taban sınıfın __new__ metodu 
    çağrılacaktır. Aslında tüm tahsisatlar eninde sonunda object sınıfının __new__ metoduyla yapılmaktadır. Programcı kendi sınıfında __new__ 
    metodunu yalnızca "araya girmek" için yazar (override eder). Programcı da aslında kendi yazdığı __new__ metodunda super().__new__(cls) 
    çağrısıyla tahsisatın object sınıfının __new__ metodu tarafından yapılmasını sağlar. Örneğin:

    class Mample():
        pass

    class Sample:
        @staticmethod
        def __new__(cls, *args, **kwargs):
            print('araya giriyoruz')
            return super().__new__(cls)
        
        def __init__(self, a, b):
            print('__init__ called')
        
    s = Sample(10, 20)

    Pekiyi __new__ metodu nasıl ve neden yazılır? __new__ metodu static bir metot olmalıdır. __new__ metodunun birinci parametresi tahsis 
    edilecek sınıf türünden type nesnesini belirtir.   type sınıfının __call__ metodu __new__ metoduna nesne yaratılırken kullanılan bütün 
    argümanları geçirdiği için __new__ metodunun parametrik yapısının bu argümanları alacak biçimde *args ve **kwargs parametrelerine de 
    sahip olması gerekir. Bu durumda __new__ metodunun tipik parametrik yapısı şöyle oluşturulmalıdır:

    def __new__(self, *args, **kwargs):
        pass

    Yukarıda da belirttiğimiz gibi programcı yalnızca araya girme işlemi yapmalıdır. Gerçek nesne her zaman eninde sonunde object.__new__ 
    metoduyla yaratılmak zorundadır. Ancak bu noktada bir ayrıntıta dikkatinizi çekmek istiyoruz. object sınıfının __new__ metodunun tek 
    parametresi vardır. Yani *args, **kwargs parametrleri yoktur. Dolayısıyla __new__ metodunu yazdığımız sınıf başka bir sınıftan türetilmişse
    taban sınıfın __new__ metodunu çağırırken dikkat ediniz. Eğer taban sınıfta __new-_ metodu yazılmamışsa object sınıfının __new__ metdou
    çağrılacaktır.

    Bazı ileri uygulamalarda __new__ metodunun programcı tarafından yazılması gerekebilmektedir. Örneğin singleton kalıbı Python'da __new__ 
    metodu yoluyla sağlanabilir. NYPT'de bir tasarım kalıbı olarak "singleton" bir sınıf türünden toplamda tek bir nesnenin var olmasını 
    sağlayan  kalıptır. Programcı birden fazla nesne yarattığını sansa bile aslında toplamda tek bir nesne yaratılmaktadır. İşte biz de 
    singleton kalıbını aşağıdaki gibi oluşturabiliriz:

    class Sample:
        _obj = None
        
        @staticmethod
        def __new__(cls, *args, **kwargs):
            if Sample._obj is None:
                Sample._obj = super().__new__(cls)
                
            return Sample._obj
        
        def __init__(self):
            print('__init__')
        
    s = Sample()
    print(id(s))

    k = Sample()
    print(id(k))

    m = Sample()
    print(id(m))

    __new__ içerisinde nesne daha önce yaratılmışsa yaratılmış olan nesne verilmektedir. Nesne daha önce yaratılmamışsa gerçekten 
    yaratılmaktadır. 

    Singleton nesnenin dekoratör yoluyla da yazılmasını sağlayabiliriz. Bunun klasik yolu dekoratör sınıfında __call__ metodunda nesne 
    yaratımını yapmaktadır. Örneğin:
    
    class singleton:
        def __init__(self, cls):
            self.cls = cls
            self._obj = None
            
        def __call__(self, *args, **kwargs):
            if self._obj is None:
                self._obj = self.cls(*args, **kwargs)
            
            return self._obj
    
    @singleton
    class Test:
        pass

    t1 = Test()
    print(id(t1))

    t2 = Test()
    print(id(t2))

    t3 = Test()
    print(id(t3))

    Sınıf dekoratörleri yokken aynı işlem türtetme yoluyla da yapılabiliyordu:

        class Singleton:
        _obj = None
        
        @staticmethod
        def __new__(cls, *args, **kwargs):
            if Singleton._obj is None:
                Singleton._obj = super().__new__(cls)
                
            return Singleton._obj
        
        def __init__(self):
            print('__init__')
        

    class Sample(Singleton):
        pass

        
    s = Sample()
    print(id(s))

    k = Sample()
    print(id(k))

    m = Sample()
    print(id(m))
    
    Bazen __new__ metodu içerisinde programcı başka bir sınıf türünden nesneyi tahsis edip verebilir. 

    class A:
        def __init__(self):
            print('A.__init__')
            
    class B:
        def __init__(self):
            print('B.__init__')
            
    class Sample:
        @staticmethod
        def __new__(cls, name=None):
            if name == 'A':
                return A()
            elif name == 'B':
                return B()
            elif name is None:
                return super().__new__(cls)
    
        def __init__(self):
            print('__init__  called')
            
    s = Sample('B')     # Aslında B nesneyi yaratılacak, Sample.__init__ çağrılmayacak
    print(type(s))

    s = Sample('A')     # Aslında A nesneyi yaratılacak, Sample.__init__ çağrılmayacak
    print(type(s))

    s = Sample()     # Sample türünden nesne yaratılır, Sample sınıfının __init__ metodu çağrılır 
    print(type(s))

#------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi yorumlayıcı bir sınıf tanımlamasıyla karşılaştığında önce type sınıfı türünden bir nesne yaratıyordu ve sınıfın 
    bilgilerini bu nesnenin içerisine yerleştiriyordu. Sonra da bu nesnenin adresini sınıf ismi olan değişkene atıyordu. B urada type 
    sınıfı bir meta senıfıtr. Sınıfları temsil eden sınıflara meta sınıf denilmektedir. 
    
    Eğer isterse yorumlayıcının sınıf tanımlamasını gördüğünde yaratacağı nesnenin türünü değiştirebilir. Yani meta sınıf type sınıfı yerine 
    başka bir sınıf da olabilmektedir. Meta sınıfı değiştirmek için sınıfı oluştururken  parantezler içerisinde "metaclass = <meta_sınıf>" 
    yazılmalıdır. Örneğin:
    
    class Sample(metaclas=MyMetaClass):
        pass

    Buradaki metaclass normal olarak type sınıfından türetilmelidir. Örneğin:

    class MyMetaClass(type):
        pass

    Daha önceden de belirttiğimiz gibi bir sınıf nesnesi yaratıldığında aslında yorumlayıcı metaclass sınıfına ilişkin bir nesne 
    yaratmaktadır. Eğer metaclass belirtilemzse type sınıfına ilişkin nesne yaratılır. Eğer metaclass belirtilirse metaclass türünden 
    nesne yaratılır. Yukarıda da belirttiğimiz gibi bu yaratım sırasında yorumlayıcı sınıf ismini bir string olarak, sınıfın taban 
    sınıflarını bir demet olarak ve sınıfın içerisindeki elemanları bir sözlük nesnesi olarak parametre yapıp metaclass sınıf nesnesini 
    yaratmaktadır. Yani yaratım adeta şöyle yapılmaktadır:

    metaclass(sınıf_isim, taban_sınıflar, sınıfın_elemanları)

    Dolayısıyla eğer biz meta sınıfımız için __init__ metodu yazacaksak bu __init__ metodunun self dışında üç parametresi olmalıdır. 
    Ancak aslında yaratımda type sınıfı kullanılacağı için bu parametrelerin super fonksiyonuyla type sınıfına aktarılması gerekir. 
    Örneğin:

    class MyMetaClass(type):
        def __init__(self, name, bases, namespace):
            super().__init__(name, bases, namespace)
            print('MyMetaClass instance created...')

    class Sample(metaclass=MyMetaClass):
        pass

    Bu program çalıştırıldığında ekranda "MyMetaclass instance created..." yazısı çıkmalıdır. Tabii biz meta sınıfımız için 
    __init__ metodunu yazmazsak type sınıfının __init__ metodu çağrılacaktır. Bu metot da normal yaratımı yapacaktır. Örneğin:

    class MyMetaClass(type):
        pass

    class Sample(metaclass=MyMetaClass):
        pass
        
    s = Sample()

    print(type(Sample))     # __main__.MyMetaClass
    print(type(s))          # <class '__main__.Sample'>

    Meta sınıfların type sınıfından türetilme zorunda olduğuna dikkat ediniz. Çünkü nesnelerin yaratılması gibi işlevsellikler type
    sınıfında bulunmaktadır. Bizim yukarıdaki örneğimizde MyMetaClass isimli sınıfımız zaten type sınıfının bütün işlevselliğini 
    barındırmaktadır. Ancak ondan fazlalıkları vardır.
#------------------------------------------------------------------------------------------------------------------------------------
    
class MyMetaClass(type):
    def __init__(self, name, bases, namespace):
        super().__init__(name, bases, namespace)
        print('MyMetaClass instance created')

class Sample(metaclass=MyMetaClass):
    pass

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii meta sınıfı değiştirdiğimiz sınıfımız başka bir sınıftan türetilmiş olablilir. Bu durumda metaclass belirlemesinin parantez
    içerisinde sonda yapılması gerekir. Örneğin:

    class MyMetaClass(type):
        def __init__(self, name, bases, namespace):
            super().__init__(name, bases, namespace)
            print('MyMetaClass instance created')

    class Sample:
        pass

    class Mample(Sample, metaclass=MyMetaClass):
        pass

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi meta sınıflar hangi tüdendir? Örneğin:

    class MyMetaClass(type):
        pass

    class Sample(metaclass=MyMetaClass):
        pass

    s = Sample()

    Burada s Sample sınıfı türündendir. Sample MyMetaClass türündendir. Pekyi MyMetaClass hangi türdendir? MyMetaClass default olarak 
    type türündendir. Tabii aslında o da bşka meta sınıf türünden olabilirdir. 
    
    Burada yorumlayıcı MyMetaClass tanımlamasını gördüğünde type sınıfı türünden bir nesne yaratmaktadır. Bu yaratım sırasında da yine 
    sınıfın __new__ ve __init__ metotları devreye girecektir. Sınra yorumlayıcı Sample sınıfını gördiğinde bu kez MyMetaClass türünden 
    bir nesne yaratmaktadır. Yorumlayıcı s = Sample() biçiminde Sample sınıfı türünden bir nesne yaratılmak istendiğinde bu kez MyMetaClass
    sınıfının __call__ metodunu çağıracaktır. MyMetaClass sınıfı type sınıfından türetildiği için nesnenin yaratılması sırasında yine 
    Sample sınıfının __new__ ve __init__ metotları çağrılacaktır. Özetle türler şöyledir:

    MyMetaClass -----> type
    Sample -----> MyMetaClass
    s ----> Sample
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                                77. Ders 13.10.2023 - Cuma
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi meta sınıflar neden kullanılır? Yani biz neden bir sınıfın type sınıfından değil de kendi sınıfımızdan oluşturulmasını 
    isteriz? İşte aslında meta sınıflar Python'da nadiren programcılar tarafından kullanılmaktadır. Bunlar genellikle bazı framework'leri 
    geliştirenler" tarafından ileri amaçlarla kullanılırlar. Örneğin yorumlayıcı bir sınıfı yaratırken meta sınıflar sayesinde biz  
    araya girip o sınıfa bazı elemanlar ekleyebiliriz. Tabii yorumlayıcı da meta sınıf nesnesini aslında type sınıfı türünden yaratmaktadır. 
    Yani bizim meta sınıfımız da aslında type türündendir. O halde meta sınıf nesnesi yaratılırken meta sınıf olarak belirttiğimiz sınıfın 
    __new__ ve __init__ metotları çağrılacaktır. Biz de bu metotlarda sınıfa birtakım elemanlar yerleştirebiliriz. Aşağıdaki örnekte meta 
    sınıfın __init__ metodunda yeni yaratılan sınıf nesnesi için x ve foo isimli iki öznitelik yerleştirilmiştir. Burada foo fonksiyonu 
    bir metot gibi işlev görecektir. 
#------------------------------------------------------------------------------------------------------------------------------------

class MyMetaClass(type):
    def __init__(self, name, bases, namespace):
        super().__init__(name, bases, namespace)
        self.foo = foo
        self.x = 123

def foo(self):
    print('foo')
    
class Sample(metaclass=MyMetaClass):
    pass

s = Sample()
s.foo()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında yukarıdaki gibi araya girerek sınıfa eleman ekleme biçimindeki uygulamalar sınıf dekoratörleriyle de belli biçimlerde 
    yapılabilir. Ancak sınıf dekoratörlerinin çeşitli kısıtları vardır. Aşağıdaki örnekte bir sınıf dekoratörü yoluyla yukarıdaki gibi 
    sınıfa yine foo ve x elemanları eklenmiştir. foo bir metot gibi kullanılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

def foo(self):
    print('Ok')

def SampleDecorator(cls):
    cls.x = 10
    cls.foo = foo
    return cls
        
@SampleDecorator  
class Sample:
    pass

s = Sample()
print(Sample.x)
s.foo()

#------------------------------------------------------------------------------------------------------------------------------------
    Sınıf yaratımında araya girmek için meta sınıflar ve dekoratörler benzer amaçlarla kullanılabiliyor olsa da meta sınıflar 
    daha kapsamlı olanaklara sahiptir. Örneğin biz yazdığımız sınıfı print ettiğimizde istediğimiz bir yazının çıkmasını isteyelim. 
    Bu işlemi aşağıdaki gibi yapamayız:

    def foo(self):
        print('Ok')

    def SampleDecorator(cls):
        cls.__str__ = lambda self: 'this is a test'
        return cls
        
    @SampleDecorator  
    class Sample:
        pass

    print(Sample)

    s = Sample()                # <class '__main__.Sample'>
    print(s)                    # this is a test

    Burada biz sınıfa yerleştirmiş olduğumuz __str__ metodu sınıfın kendisini yazdırılırken devreye girmemektedir. O sınıf türünden 
    bir değişken yazdırılırken devreye girmektedir. Çünkü burada biz yarattığımız bir meta sınıf türünden nesnenin içerisine bu metodu
    yerleştirmiş olduk. Halbuki bizim bunu yapabilmemiz için bizzat meta sınıfın içerisine bunu yerleştirmemiz gerekir. Bunun için 
    bizim __str__ metodunu meta sınıfın içerisine yazmamız gerekir. Örneğin:

    class MyMetaClass(type):
        def __str__(self):
            return 'this is a test'
            
    class Sample(metaclass=MyMetaClass):
        pass
    
    print(Sample)       # this is atest

    Burada Sample değişkeni artık type türünden değil MyMetaClass türündendir. Dolayısıyla artık Sample değişkeni print 
    edildiğinde bu __str__ çağrılacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

class MyMetaClass(type):
    def __str__(self):
        return 'this is a test'

class Sample(metaclass=MyMetaClass):
    pass

print(Sample)

#------------------------------------------------------------------------------------------------------------------------------------
    Python'un 3'lü versiyonlarıyla birlikte "tür açıklamaları (type annotations)" konusu çeşitli ayrıntılarla dile eklenmiştir. Ancak bu 
    ekleme versiyondan versiyona genişletilerek bugünkü son haline getirilmiştir. Dolayısıyla biz güncel son durumdaki tür açıklamaları 
    üzerinde duracağız. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Python dinamik tür sistemine sahip olduğu için değişkenlerin, fonksiyon parametrelerinin, fonksiyonların geri dönüş değerlerinin 
    türleri değişebilmektedir. Dinamik tür sistemine sahip programlama dillerinde en önemli sorunlardan biri tür kontrolünün çalışma 
    zamanı sırasında yapılmasıdır. Örneğin bir fonksiyon yanlış türden bir argümanla çağrıldığında problem kod çalışırken akış o 
    noktaya geldiğinde ortaya çıkmaktadır. Bu da kodu yazanın çok dikkatli olmasını gerektirmektedir. İşte tür açıklamaları bir değişkenin 
    niyet edilen türünün program çalışmadan önce üçüncü parti araçlar tarafından kontrol edilmesini sağlamak amacıyla dile eklenmiştir. 
    Tür açıklamaları  yorumlayıcı için bir direktif ya da kontrol sağlamamaktadır. Yalnızca insanlar ve üçüncü parti statik analiz araçları 
    için kontrol imkanları sunmaktadır. Başka bir deyişle tür açıklamaları tamamen yorumlayıcı tarafından görmezden gelinmektedir. 

    Aşağıdaki banner fonksiyonuna dikkat ediniz:

    def banner(s, ch='-'):
        print(ch * len(s))
        print(s)
        print(ch * len(s))

    Bu fonksiyonun bir string ile çağrılması gerekir. Eğer bu fonksiyon bir string ile çağrılmazsa muhtemelen bir exception oluşacaktır.
    Pekiyi dalgın bir programcı bu fonksiyonu aşağıdaki gibi int bir değerle çağıramaz mı?

    banner(123)

    İşte bu durumda yukarıda da belirttiğimiz gibi kod çalışırken exception oluşacaktır (çünkü int türü len fonksiyonuna sokulamaz). 
    Eğer biz yukarıdaki fonksiyonu örneğin bir listeyle çağırırsak exception oluşmaz ancak fonksiyon istediğimizi de yapmaz. Aslında 
    bu durum exception oluşmasından da kötüdür. 

    Pekiyi biz bir Python programında yukarıdaki gibi hataları nasıl tespit edebiliriz? Bu tür hatalar yazılımın iyi bir biçimde test 
    edilmesiyle büyük ölçüde düzeltilebilmektedir. Sonraki konuda göreceğimiz "birim testleri (unit testing)" test süreci bunun için 
    kullanılabilir. İşte tür uyumluluğu üçüncü parti statik analiz araçları tarafından da belirli koşullar sağlanırsa tür açıklamaları 
    sayesinde kontrol edilebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Tür kontrolü için kullanılan statik analiz araçlarının en yaygınları şunlardır: mypy, Pytype, Pyright, Pyre. Biz kursumuzda mypy
    kullanacağız. mypy programını şöyle kurabilirsiniz:

    pip install mypy

    Bu analiz araçlarının tür kontrollerini yapabilmesi için kodun "tür açıklamaları (type annotations)" ile oluşturulmuş olması gerekir. 
    Bu nedennle bizim tür açıklamalarının nasıl oluşturulacağını bilmemiz gerekmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Tür açıklamalarının genel biçimi şöyledir:

    <değişken_ismi>: <ifade> [= <ilkdeğer>]

    Aslında tür açıklamaları daha genel olarak düşünülmüştür. Yukarıdaki genel biçimde "ifade" yerine tür bilgisi yazılırsa (int, str, 
    float gibi tür isimleri Python'da birer ifadedir) tür açıklaması yapılmış olur. Aslında bu açıklamalar tür açıklaması biçiminde 
    olmak zorunda değildir. Ancak pratikte açıklamaların (annotations) en yaygın kullanımı tür açıklamaları biçimindedir. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Global ya da yerel değişkenlere tür açıklaması yazılırken onun ilkdeğer verilerek yaratılması zorunlu değildir. Örneğin:

    x: int

    x = 10
    print(x)

    x = 2.3
    print(x)

    Burada x değişkenin int türden olduğu belirtilmiştir. Biz bir değişkeni tür açıklamasıyla aşağıdaki gibi belirtmiş olalım:

    a: int

    Burada biz bu a değişkenini yaratmış değiliz. Yani a değişkenini henüz kullanamayız. Ancak Python yorumlayıcısı bunun bir tür 
    açıklaması olduğunu anlar ve bunun için herhangi bir error mesajı vermez. Ancak bir değişkeni yaratmadan aşağıdaki gibi bir 
    kullanım geçerli değildi:

    a
    
    Python'da bu tür etkisiz kodların oluşturulmasının yasak olmadığını anımsayınız. Ancak buradaki sorun a'nın yaratılmamış olmasıdır. 
    
    Yukarıda da belirttiğimiz gibi bir program çalıştırılırken Python yorumlayıcısı tür açıklamalarını dikkate almaz. Bu tür açıklamaları 
    üçüncü parti programlar tarafından (örneğin mypy) dikkate alınmaktadır. Yukarıdaki "sample.py" dosyasını mypy ile şöyle işleme sokabiliriz:

    mypy sample.py

    Burada mypy şöyle bir çıktı oluşturmuştur:

    C:\Study\Python>mypy sample.py
    sample.py:6: error: Incompatible types in assignment (expression has type "float", variable has type "int")
    Found 1 error in 1 file (checked 1 source file)

    Tabii biz tür açıklaması yaparken oma değer atayarak değişkeni yaratabiliriz. Örneğin:

    x: int = 10
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Tür açıklamaları IDE'lere entegre edilmiş araçlar tarafından da dikkate alınabilmektedir. Örneğin PyCharm IDE'sinde "Code/Inspect Code" 
    menüsü ile tür kontrolü yapılabilir. Mypy aynı zamanda PyCharm IDE'sine bir plugin olarak eklenebilmektedir. Ancak henüz Spyder 
    IDE'sine entegre edilmiş bir araç yoktur. Visual Studio Code IDE'sine de bir plugin olarak mypy eklenebilmektedir. 

    mypy programı başarısız olursa sıfırı dışında bir exit kodu üretmektedir. Başarı durumunda mypy programının exit kodu 0'dır. Örneğin:

    C:\Study\Python>mypy sample.py
    sample.py:3: error: Incompatible types in assignment (expression has type "float", variable has type "int")  [assignment]
    Found 1 error in 1 file (checked 1 source file)

    C:\Study\Python>echo %errorlevel%
    1

    Ancak örneğin:

    C:\Study\Python>mypy sample.py
    Success: no issues found in 1 source file

    :\Study\Python>echo %errorlevel%
    0

    Nöylece build araçları ya da programcının oluşturduğu make dosyaları önce mypy programını çalıştırıp eğer bir hata varsa programı
    hiç çalıştırmayabilirler. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Parametre değişkenlerine tür açıklaması yapılırken aynı sentaks kullan kullmaktadır. Örneğin:

    def banner(s: str, ch: str = '-'):
        print(ch * len(s))
        print(s)
        print(ch * len(s))
    
    banner('ankara')
    banner(123)

    Bu programı mypy programına sokalım:

    
    C:\Study\Python>mypy sample.py
    sample.py:7: error: Argument 1 to "banner" has incompatible type "int"; expected "str"
    Found 1 error in 1 file (checked 1 source file)

    Görüldüğü gibi mypy fonksiyonun yanlışlıkla int bir değerle çağrıldığını tespit edip bize bildirebilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------  
                                    78. Ders 14/10/2023 – Cumartesi 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Fonksiyonun geri dönüş değeri hakkında açıklama oluşturmak için -> sembolü kullanılmaktadır. Örneğin:

    def square(a: int) -> int:
        return a * a

    Burada biz fonksiyonun parametresinin int türden geri dönüş değerinin de int türden olması gerektiğini belirtiyoruz. Şimdi "sample.py"
    programının aşağıdaki gibi olduğunu kabul edelim:

    def square(a: int) -> int:
        return a * a

    result = square(1.2)
    print(result)

    Programı mypy'a sokalım:

    C:\Study\Python>mypy sample.py
    sample.py:4: error: Argument 1 to "square" has incompatible type "float"; expected "int"
    Found 1 error in 1 file (checked 1 source file)

    Şimdi program şöyle olsun:

    def square(a: int) -> int:
        return a * a

    result: str

    result = square(1)
    print(result)

    Buradaki hata square'in geri dönüş değrinin str türünden bir değişkene atanmasıdır. Bu kodu aşağıdaki gibi mypy'a sokalım:

    C:\Study\Python>mypy sample.py         
    sample.py:6: error: Incompatible types in assignment (expression has type "int", variable has type "str")
    Found 1 error in 1 file (checked 1 source file)

#------------------------------------------------------------------------------------------------------------------------------------

 #------------------------------------------------------------------------------------------------------------------------------------
    Biz bir değişkenin kendi sınıfımı türünden olmasını sağlayabiliriz. Örneğin:

    class Sample:
        pass

    def foo(a: Sample):
        print(a)
        
    s = Sample()

    foo(s)

    Burada foo fonksiyonu Sample sınıfı türünden parametre almaktadır. Biz onu başka türden başka türden bir argümanla çağırırsak
    mypy hata verecektir. Tabii türemiş sınıf taban sınıf gibi de kullanılabildiği için biz buradaki foo fonksiyonuna Sample sınıfından 
    türetilmiş bir sınıf türünden swğişkwn sw gwçwbiliriz. Örneğin:

    class Sample:
        pass

    class Mample(Sample):
        pass

    def foo(a: Sample):
        print(a)
        
    m = Mample()

    foo(m)

    Burada mypy herhangi bir hata mesajı vermeyecektir. 
 #------------------------------------------------------------------------------------------------------------------------------------

class Sample:
    pass

class Mample(Sample):
    pass

def foo(a: Sample):
    print(a)
    
m = Mample()

foo(m)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir değişken liste türünden olması gerekiyorsa list biçiminde tür açıklaması yapılabilir. Örneğin:

    def foo(a: list):
        pass

    Burada a parametre değişkeni elemanları herhangi bir biçimde olan bir list nesnesini alabilir. Ancak istersek listenin elemanlarının
    belli bir türdne olmasını da sağlayabiliriz. Örneğin:

    a: list[int]

    Burada a int eşemanlardan oluşan bir liste olmalıdır. Örneğin:

    a = [1, 2, 'ali']

    Böyle bir atama mypy tarafından hata olarak değerlendirilecektir. 
    
    Mypy gibi araçların "statik kontrol araçları" olduğuna dikkat ediniz. Bu tür statik kod analizi yapan araçlar programı çalıştırarak 
    bir kontrol yapamadığı için her türlü ihlali kontrol edememektedir. Örneğin:

    def foo(x):
        x.append(1.2)

    a: list[int]

    a = [1, 2, 3, 4]

    foo(a)

    print(a)

    Burada foo fonksiyonunun a listesine ekleme yaptığını dolayısıyla kuralın ihlal edildiğini mypy gibi statik analiz araçları 
    genellikle tespit edememektedir. Örneğin:

    def foo(a: list[int]):
        pass

    Burada foo parametre olarak int değerlerden oluşan bir liste almak zorundadır. Örneğin "sample.py" programı şöyle olsun:

    def foo(a: list[int]):
        pass

    foo([10, 20])
    foo([10, 20.1])

    Burada ilk foo çağrısı geçerli olduğu halde ikinci foo çağrısı geçersizdir.  Programı mypy'a sokalım:

    C:\Study\Python>mypy sample.py
    sample.py:6: error: List item 1 has incompatible type "float"; expected "int"
    Found 1 error in 1 file (checked 1 source file)

    list, tuple, dict gibi türlerin köşeli parantezlerle tür açıklamalarında kullanılabilmesi Python 3.9 ile eklenmiştir. Python 8.8 
    ve öncesinde  tür açıklamaları için typing modülü içerisiside List isimli bir sınıf bulunuyordu. Bu sınıf liste işlemlerini yapmaz 
    yalnızca tür açıklamaları için bulundurulmuştur. Örneğin:

    from typing import List

    def foo(a: List[int]):
        pass

    foo([10, 20])

    Artık programcıların tür açıklamaları için List sınıfı yerine doğrudan list sınıfını kullanması tavsiye edilmektedir. Örneğin:

    def foo(a: list[int]):
        pass

    foo([10, 20])

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Benzer biçimde set ve tuple sınıfları da tür açıklamaları için kullanılabilmektedir. Örneğin:

    def foo(s: set):
        pass

    Burada s set türünden olmalıdır. Örneğin:

    def bar(t: tuple):
        pass

    Burada da t tuple türünden olmalıdır.

    Tabii tıpkı list örneğinde olduğu gibi aslında biz bu set ve tuple türlerinin elemanları hakkında da açıklama yapabiliriz. Örneğin:

    def foo(s: set[int]):
        pass

    Burada s int değerleri tutan bir küme olmalıdır. Demetlerde elemanların türleri sırasıyla tek tek belirtilebilmektedir. Örneğin:

    def foo(t: tuple[int, str]):
        pass

    Burada t parametre değişkenine iki elemanlı demetler atanmalıdır. Bu demetlerin birinci elemanları int türden ikinci elemanları str 
    türünden olmalıdır. Örneğin:

    foo((10, 'ankara'))

    Şimdi fonksiyunu şöyle çağıralım:

    foo((10, 20))

    Mypy şöyle bir hata verecektir:

    C:\Study\Python> mymy sample.py
    sample.py:4: error: Argument 1 to "foo" has incompatible type "tuple[int, int]"; expected "tuple[int, str]"  [arg-type]
    Found 1 error in 1 file (checked 1 source file)

    set ve tuple türlerinin bu biçimde doğrudan kullanılması Python 3.9 ile birlikte mümkün hale getirilmiştir. Python 3.8 ve aşağısında 
    bunların yerine typing modülündeki Set ve Tuple sınıfları kullanılıyordu. Bu sınıflar gerçek set ve tuple sınıfları değildir. Yalnızca 
    tür açıklamaları için bulundurulmuş olan sınıflardır. Ancak yukarıda da belirttiğimiz gibi Python 3.9 ile artık bu sınıfların 
    kullanılmasına gerek kalmamıştır. Örneğin:

    from typing import Set, Tuple

    def foo(s: Set[int]):
        pass

    def bar(t: Tuple[int, str]):
        pass

    foo({1, 2, 3})
    bar((10, 'ankara'))

    Örneğin:

    from typing import Set, Tuple

    def foo(s: Set[int]):
        pass

    def bar(t: Tuple[int, str]):
        pass

    s: Set[int] = {1, 2, 3}
    t: Tuple[int, str] = 10, 'ankara'

    foo(s)
    bar(t)

    Demetler için şöyle bir sentaks da eklenmiştir. Eğer demetleri belirtirken yalnızca tek tür belirtirsek ve sonra da ... (ellipsis)
    getirirsek bu durum ilk belirttiğimiz türden olmak koşulu ile demetin istenildiği sayıda elemandan oluşabileceği anlamına gelir. Örneğin:

    def foo(t: tuple[int, ...]):
        pass

    Burada aşağıdaki çağrılar tür açıklamalarına uygundur:

    foo((10, 20, 30))
    foo((10, 20))

    Ancak aşağıdaki çağrımlar tür açıklamalarına uygun değildir:

    foo((10.2, 20, 'ali'))
    foo(('veli', 'selami'))

    Bu tür durumlarda boş demetler de soruna yol açmamaktadır 

    Köşeli parantez içerisinde birden fazla türden sonra ... kullanımının böyle bir anlamı yoktur. 

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Sözlüklerde de tür açıklamaları benzer biçimde dict sınıfı ile yapılabilmektedir. Örneğin:

    def foo(d: dict):
        pass

    Bu durumda fonksiyonun d parametre değişkenine bir sözlük geçirilmelidir. Ancak sitenirse yine köşeli parantezler içerisinde sözlüğün
    anahtar ve değer türleri ayrı ayrı belirtilebilir. Örneğin:

    def foo(d: dict[int, str]):
        pass
    
    Burada sözlüğün anahtarları int, değerleri ise str türünden olmalıdır. Aşağıdkai çağırda mypy bir hata rapor etmeyecektir:

    d = {10: 'ali', 20: 'veli', 30: 'selami'}

    foo(d)

    Python 3.8 ve öncesinde bu işlem typing modülü içerisindeki Dict sınıfı ile yapılıyordu. Örneğin:

    from typing import Dict

    def foo(d: Dict[int, str]):
        pass

    d = {10: 'ali', 20: 'veli', 30: 'selami'}

    foo(d)

    Ancak artık bu Dict sınıfına gerek kalmamıştır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    typing modülündeki Any sınıfı tür açıklamalarında "herhangi bir tür olabilir" anlamına gelmektedir. Any kullanmak bazı durumlarda 
    gereksidir. Örneğin:

    def foo(a: Any):
        pass

    Biz zaten burada tür açıklaması yapmasaydık da mypy tarafından foo herhangi bir tür olarak kabul edecekti. Yani aşağıdaki fonksiyon 
    yukarıdakiyle eşdeğerdir:

    def foo(a):
        pass
    
    Örneğin:

    def bar(a: list[Any]):
        pass
    
    Burada da aslında yalnızca list biçiminde tür açıklaması yapsaydık da değişen bir şey olmayacaktı:

    def bar(a: list):
        pass

    Ancak bazı durumlarda Any gerçekten gerekebilmektedir. Örneğin:

    from typing import Any

    def foo(d: dict[int, Any]):
        pass

    Burada artık foo fonksiyonun parametresi sözlük olmalıdır. Ancak sözlüğün anahtarları int olmak zorundayken değeri herhangi bir türden
    olabilir. Örneğin aşağıdaki çağrı tür açıklamalarına uygundur:

    foo({10: 'ali', 20: 100, 30: 2.3}) 

    Örneğin:

    def foo(t: tuple[int, Any, float]):
        pass

    Burada parametre değişkeni olan t için bizim üç elemanlı bir demet geçirmemiz gerekir. Bu demetin ilk elemanı int türden, üçüncü elemanı
    float türden ancak ikinci elemanı herhangi bir türden olabilir. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyonun geri dönüş değerinin olmadığı ya da None olduğunu belirtmek için tür açıklamalarında None kullanılmalıdır. Örneğin:

    def foo() -> None:
        pass

    Biz burada foo fonksiyonunu geri dönüş değeri varmış gibi kullanırsak mypy bu durumu error ile rapor edecektir. Örneğin:

    result = foo()

    Burada mypy şöyle bir error rapor eder:

    C:\Study\Python> mymy sample.py
    sample.py:4: error: "foo" does not return a value
    Found 1 error in 1 file (checked 1 source file)

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    typing modülündeki Optional ilgili türden ya da None (NoneType türünden) anlamına gelmektedir. Örneğin:

    from typing import Optional

    a: Optional[int]

    Burada biz a'ya int ya None atayabiliriz. Ancak başka bir türden değer atayamayız. Örneğin:

    from typing import Optional

    def foo(a: int) -> Optional[int]:
        if a > 0:
            return a
        
        return None

    result: Optional[int] = foo(10)
    print(result)

    Aşağıda ikinci derece denklemin köklerini bulan bir fonksiyon tür açıklamaları kullanılarak yazılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

import math
from typing import Optional

def get_roots(a: float, b: float, c: float) -> Optional[tuple[float, float]]:
    delta: float = b ** 2 - 4 * a * c
    if delta < 0:
        return None
    
    x1 = (-b + math.sqrt(delta)) / (2 * a)
    x2 = (-b - math.sqrt(delta)) / (2 * a)
    
    return x1, x2

result: Optional[tuple[float, float]] = get_roots(1, 0, -4)    
if result:
    print(result[0], result[1])
else:
    print('Kök yok')

#------------------------------------------------------------------------------------------------------------------------------------
                                        79. Ders 21/10/2023 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir değişkene bir fonksiyon gibi çağrılabilecek (callable) bir değişken  atanacaksa tür açıklamasında typing modülündeki Callable 
    sınıfı kullanılmaktadır. Örneğin:

    from typing import Callable

    def foo():
        print('foo')

    class Sample:
        def __call__(self):
            print('Sample.__call__')

    f: Callable

    f = foo         # haata yok, f'ye çağrılabilir (callable) bir nesne atanmış

    f()

    s = Sample()

    f =  s          # hata yok, s çağrılabilir bir nesne

    f()

    Örneğin:

    from typing import Callable

    def square(a: int) -> int:
        return a * a

    def foo(f: Callable, val: int):
        result = f(val)
        print(result)
        
    foo(square, 10)

    Burada bar fonksiyonun parametresi bir fonksiyon nesnesi (callable herhangi bir nesne) olabilir. 
       
    Ancak istenirse değişkene atanacak çağrılabilen nesnenin parametrik yapısı ve geri dönüş değeri için de tür açıklaması yapılabilmektedir. 
    Bu Callable sınıfına köşeli parantezleri içerisinde "bir liste biçiminde parametre türleri, sonra da geri dönüş değerinin türü" belirtilir.
    Örneğin:

    from typing import Callable

    def foo(a: int, b: str) -> int:
        return a + int(b)
        
    f: Callable[[int, str], int]

    Burada f değişkenine parametreleri sırasıyla int ve str olan geri dönüş değeri ise int olan çağrılabilen nesneler atanabilir. Eğer 
    buna uygun atama yapılmazsa mypy hata verecektir. Örneğin:
    
    f = foo

    result: int = f(10, 20)
    print(result)

    Burada tür açıklamasına uyulmamıştır. mypy şöyle bir hata rapor etmektedir:

    sample.py:22: error: Argument 2 to "foo" has incompatible type "int"; expected "str"  [arg-type]
    Found 1 error in 1 file (checked 1 source file)

    Örneğin:

    def square(a: int) -> int:
        return a * a

    def foo(f: Callable[[int], int], val: int):
        result = f(val)
        print(result)
        
    foo(square, 10)

    Burada foo fonksiyonunun birinci parametresi "pareametresi int, geri dönüş değeri int olan" bir fonksiyon nesnesi almaktadır. 
    Örneğimizde bu tür açıklamasına uyulduğuna dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    typing modülü içerisindeki Union isimli sınıf birden fazla türü belirtmek için kullanılmaktadır. Örneğin:

    a: Union[int, str]

    Burada a'ya int ya da str türündne nesneler atanabilir. Yani a bu iki türden değeri de kabul etmektedir. Örneğin:

    from typing import Union

    a : Union[int, str]

    a = 10
    print(a)

    a = 'ali'
    print(a)

    Burada a'ya yapılan atamalar tür açıklamasıyla uyumludur. Ancak örneğin:

    a = 2.3
    print(a)

    Burada a'ya yapılan atama tür açıklamasıyla uyumlu değildir. Örneğin:

    from typing import Union

    def foo(a: Union[int, str]):
        pass

    Burada aşağıdaki iki çağrı tür açıklamalarıyla uyumludur.

    foo(10)
    foo('ali')

    Ancak aşağıdaki çağrı tür açıklamalarıyla uyumsuzdur:

    foo(1.2)

    Python 3.10 ile birlikte Union işlemi '|' operatörü ile de yapılır hale getirilmiştir. Örneğin:

    def foo(a: int|str):
        pass

    Bu açıklama aşağıdakiyle tamamen eşdeğerdir:

    def foo(a: Union[int, str]):
        pass
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Bazen bir değişkene ilişkin tür açıklamasını başka bir tür açıklaması ile değiştirmek isteyebiliriz. Aslında ikinci kez tür açıklaması 
    yapmak Python yorumlayıcısı tarafından geçerlidir. Örneğin:

    a: int
    # ....

    a: float
    # ...

    Ancak mypy bu durumu eror olarak değerlendirir. 

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    typing modülü içerisindeki cast fonksiyonu atanan değişken üzerinde tür açıklaması yapılmasına olanak sağlayan bir fonksiyondur.     
    cast fonksiyonu birinci parametre olarak bir tür açıklamasını, ikinci parametre olarak bir değeri almaktadır. Bu değer açıklanmış 
    bir değişken de olabilir. 
    
    Biz cast fonksiyonu sayesinde bir değişkene hem bir açıklama yapıp hem de bir değer arayabiliriz. Örneğin:

    a: float = 12.2
    b = cast(int, a)

    Örneğimizde b değişkeni artık int olarak açıklanmış durumdadır. Burada önemli bir nokta cast fonksiyonun bir açıklama amacıyla 
    kullanılmasıdır. cast fonksiyonu bir dönüştürme yapmaz. Örneğimizd eher ne kadar b int olarak açıklanmışsa da içerisinde yine 12.2
    değeri bulunacaktır. Yani biz burada b'ye hem bir float değer atamış olduk hem de a'yı int olarak açıklamış olduk. 

    Yorumlayıcı cast işleminde dönüştürme yapmamaktadır. . Örneğin:

    from typing import cast

    a: float = 12.2

    b = cast(str, a)

    print(b, type(a))       # 12.2 <class 'float'>

    Burada b str olarak açıklanmıştır ancak b içerisine float bir değer atanmıştır.
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Bir değişkenin dolaşılabilir bir tür olduğu typing modülündeki Itearable sınıfı ile açıklanmaktadır. Örneğin:

    from typing import Iterable

    def foo(a: Iterable):
        pass

    Aşağıdaki çağrılar argüman olarak dolaşılabilir nesneler kullanıldığı için tür açıklamasına uygundur. Örneğin:

    foo(range(10))
    foo([1, 2, 3, 4, 5])
    foo('ankara')

    Örneğin:

    def gen():
        for i in range(10):
            yield i

    foo(gen())

    Üretici fonksiyonlar da dolaşılabilir nesneler olduğu için yukarıdaki tür açıklamasına uygundur. Ancak aşağıdaki çağrılarda argümanlar 
    dolaşılabilir nesne belirtmediği için tür açıklamasına uygun değildir:

    foo(10)

    class Sample:
        pass

    s = Sample()
    foo(s)

    Iterable sınıfı da köşeli parantezler içerisinde tür alabilmektedir. Örneğin Iterable[int] biçiminde bir açıklama değişkenin dolaşılabilir
    nesne alacağını ancak bu nesne dolaşıldıkça int nesnelerin elde edileceğini belirtmektedir. Örneğin:

    def foo(a: Iterable[int]):
        pass

    Burada aşağıdaki gibi bir çağrı tür açıklamasına uygundur:

    foo([1, 2, 3, 4, 5])

    Çünkü fonksiyona geçirilen dolaşılabilir nesnenin elemanları int türdendir. Ancak aşağıdaki bir çağrı tür açıklamasına uygun değildir:

    foo([1, 2, 3., 4, 5.0])

    Örneğin:

    a: Iterable[int|str]

    Burada a değişkenine elemanları int ya da float olabilen dolaşılabilir nesneler atanabilir. Dolayısıyla aşağıdaki atama tür 
    açıklamasına uygundur:
    
    a = [1, 2, 3, 4, 'ankara', 'izmit']

    Örneğin:

    a: Iterable[tuple[int, str]]

    Burada a değişkenine demetlern oluşan dolaşılabilir bir nesne atanabilir. Ancak bu demetlerin de ilk elemanları int ikinci elemanları 
    str türünden olmak zorundadır. Örneğin aşağıdaki atama tür açıklamasına uygundur:

    a = [(6, 'Anakara'), (26, 'Eskişehir'), (35, 'İzmir')]
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Tür açıklamaları iç içe yapıldığı zaman biraz karmaşık bir görüntü oluşturabilmektedir. Bu biçimdeki tür açıklamalarını oluştururken
    parantezlere dikkat ediniz. Örneğin:

    from typing import Callable, Iterable

    def foo(a: Iterable[tuple[Callable[[int, int], int], float]]):
            pass

    Burada a değişkeninin parametresi dolaşılabilir bir nesne olmalıdır. Bu dolaşılabilir nesne bize iki elemanlı demet vermelidir. 
    Demetin birinci elemanı parametreleri int, int olan, geri dönüş değeri nit olan bir çağrılabilir nesneden ikinci elemanı ise 
    float bir nesneden oluşmalıdır.  
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------

    typing modülü içerisindeki Sequence sınıfı da string gibi liste gibi __getitem__, __len__ metotları bulunan "reversible" "seqeunce" türlerini
    belirtmek için kullanılmaktadır. Anımsanacağı gibi tipi tipik "seuqence" türleri "list, range, tuple, str" türleridir. dict türünün __getitem__ 
    metodu olsa da dict türü bir "seauence türü değildir. Örneğin:

    from typing import Sequence

    def foo(a: Sequence[int]):
        pass

    Burada biz foo fonksiyonunu bir listeyle, bir demetle, string'le ya da bir range nesnesiyle çağırabiliriz. Bu durumda tür açıklamasına 
    uygun çağrılar oluşturulmuş oluruz. Örneğin:

    foo([1, 2, 3, 4, 5])
    foo('ali')
    foo(range(10))

    Ancak örneğin biz buradaki foo fonksiyonunu bir kümeyle ya da sözlükle çarırsak bu durum tür açıklamasıyla uyumlu olmaz:

    foo({1, 2, 3, 4, 5})
    foo({1: 'ali', 2: 'veli'})
    
    Squence sınıfı için köşeli parantezler içerisinde tür de belirtilebilir. Örneğin:

    def foo(a: Sequence[int]):
        pass

    Burada a parametre değişkenine biz int elemanlardna oluşan bir "sequence türü" geçirebiliriz. Örneğin:

    foo([1, 2, 3, 4, 5])
    foo(range(100))

    Çağrıları tür açıklamasına uygundur. Ancak örneğin:

    foo(['ali', 'veli', 'selami'])

    çağrısı tür açıklamasına uygun değildir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------    
                                                    80. Ders 27/10/2023 – Cuma
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Yazılımda test süreçleri ürün geliştirmenin önemli bir aşamasını oluşturmaktadır. Programcılar kodlama yaparken böcekler oluşturabilir. 
    Bu böcekler de nihai ürünün kimi zaman yanlış çalışmasına yol açabilir. Bozuk yazılımların kullanıcılara dağıtılmasının önemli 
    zararları vardır. Aslında bu süreç imalat sektöründeki sürece benzemektedir. Bozuk bir ürün kullanıcıya satıldıktan sonra mağduriyetin 
    giderilmesi uzun bir zaman alabilmektedir. Bunun için servis oluşturulmakta, bozuk ürünler maaşlı çalışan kişiler tarafından test edilmekte,
    duruma göre ürün tamir edilmekte ya da yenisi ile değiştirilmektedir. Bu tür durumlardaki en önemli sorunlardan biri müşteri memnuniyetinin 
    önemli ölçüde zarar görmesidir. Bazı yazılımlarda yazılımın doğru çalışması çok daha önemlidir. Yani bazı yazılımlarda "hata toleransı" 
    çok düşük olabilir. Araştırmalar programcının yaptığı hataların en az %5-%7'sinin tüm test süreçlerini geçerek nihai ürüne yansıdığını 
    göstermektedir. Yine araştırmalar bozuk bir yazılımın müşterinin eline geçtikten sonra düzeltilmesinin çok maliyetli olduğunu göstermektedir. 

    Eskiden yazılımda test süreçleri bir "lüks olarak" değerlendiriliyordu. Bu nedenle yalnızca büyük firmalar test departmanları bulunduruyordu. 
    Ancak günümüzde artık yazılımda kalite bilinci çok daha fazla artmış ve test süreçleri çok daha bilinir hale gelmiştir. 

    Yazılımda test süreçleri için çeşitli stratejiler kullanılabilmektedir. Ancak test işlemi en alt düzeyde programcının kendi yazdığı 
    kodları test etmesi ile başlar. Bu sürece "birim testleri (unit testing)" denilmektedir. Yani örneğin programcı bir fonksiyon yazmış olsun. Bu fonksiyon
    doğru çalışmakta mıdır? İşte buna yönelik yapılan testlere "birim testleri (unit testing)" denilmektedir. Yazılım parçaları bir araya 
    getirilir. Bu bir araya getirilme işlemi sonucunda genellikle bu parçalar yeniden test edilir. Buna da "entegrasyon testi (integration testing)" 
    denilmektedir. Yazılımın önemli parçalarına modül de denilmektedir. Modüller de ayrı ayrı test edilebilmektedir. Buna da "modül testleri" 
    denmektedir. Nihayet tüm ürün oluşturulur ve ürün bir bütün olarak test edilir. Buna da genellikle "kabul testleri (acceptance testing)" 
    denir. Ürün bütün olarak önce kurumun test departmanı tarafından test edilir. Genellikle test departmanı tarafından yapılan bu testlere 
    "alfa testi (alpha testing)" denmektedir. Sonra ürün seçilmiş bazı son kullanıcılara dağıtılır ve gerçek hayat testine sokulur. Buna da 
    "beta testi (betta testing)" denilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi yazılımlar nasıl test edilmektedir? Manuel yöntem çoğu kez yetersiz bir yöntemdir. Yazılımda manuel test yöntemi kullanılıyor 
    olsa da asıl testler "test işlemini yapan kodlarla" yapılmaktadır. Yani yazılımlar çeşitli aşamalarda oluşturulan ortamlarda özel 
    yazılmış kodlarla test edilmektedir. Bazı yazılımlar normal koşullarda sorunsuz çalışırken özel koşullarda ya da uç noktalarda 
    bozukluklar ortaya çıkartabilmektedir. Yazılımın zor koşullar oluşturularak test edilmesine "stres testleri (stress testing)" denilmektedir. 

    Bir programcı için en önemli test aşaması "birim testleridir". Çünkü programcının kendi yazdığı kodların programcı tarafından daha 
    birinci elden test edilmesi en önemli aşamalardan bir tanesidir. Yukarıda da belirtildiği gibi aslında nihai ürünün bozuk olmasının 
    en önemli sebeplerinden biri programcının hatalı kodlama yapmasıdır. 

    Biz kursumuzda "birim test süreci için" assert deyimi ve unittest modülünün kullanımları üzerinde duracağız. Diğer test süreçleri
    özel bir konudur ve kursumuzun kapsamı dışındadır. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    assert İngilizce bu bağlamda "iddia etmek", "ileri sürmek" gibi bir anlama gelmektedir. assert deyiminin genel biçimi şöyledir:

    assert <ifade> [, <ifade (string)>]

    assert anahtar sözcüğünün yanında doğru ya da yanlış olabilen bir ifade bulunması gerekir. Bu ifade bir iddia belirtmektedir. Eğer 
    iddia doğruysa akış normal olarak devam eder. Ancak iddia yanlışsa "AssertionError" isimli bir exception oluşur. Örneğin:

    def foo(a):
        assert a > 0
        print(a)

    Burada foo fonksiyonunun içerisinde "parametrenin sıfırdan büyük olduğu iddiası" vardır. Eğer bu iddia doğru ise bir sorun oluşmaz 
    akış devam eder. Eğer iddia yanlış ise AssertionError isimli bir exception oluşacaktır. Örneğin:

    foo(10)         # iddia doğru, bir şey olmaz
    foo(-10)        # iddia geçersiz! exception oluşur

    Pekiyi assert gibi bir deyime gerçekten gereksinim var mıdır? Biz aynı etkiyi kendimiz if deyimiyle oluşturamaz mıydık?

    def foo(a):
        if not a > 0:
            raise AssertionError
        print(a)

    İşte buradaki kod yukarıdaki ile eş anlamlı gibi gözükse de aslında başka önemli bir nokta daha vardır. Bir Python programı
    çalıştırılırken eğer "-O seçeneği" kullanılırsa program içerisindeki tüm assert deyimleri yorumlayıcı tarafından sanki yokmuş gibi 
    koddan kaldırılmaktadır. Başka bir deyişle -O ile Python programını çalıştırdığımızda assert deyimleri görmezden gelinmektedir. Böylece biz 
    performans gerekçesiyle tüm assert işlemlerinden basit bir biçimde kurtulabiliriz. Eğer aynı kontrolleri if ile yapsaydık -O ile bu 
    if'lerden kurtulamazdık. Örneğin:

    # sample.py 

    def foo(a):
        assert a > 0
        print(a)

    foo(-10)

    Burada normal bir çalışmada AssertionError oluşacaktır. Ancak komut satırından programı aşağıdaki gibi çalıştırdığımızda exception 
    oluşmayacaktır:

    python -O sample.py

    Çünkü bu durumda Python yorumlayıcıları assert deyimleri sanki kodda yokmuş gibi kodu çalıştırmaktadır.    
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Bir program için iki versiyonun bulunduğunu varsayabiliriz: Debug ve Release (Production) versiyonları. Programın debug versiyonu
    programı geliştirirken nihai üründe gerekmeyen birtakım test kontrolleri içeren versiyonlarıdır. Programcı geliştirmesini debug
    versiyonunda yapmaktadır. Release versiyonu ise hatasız olduğuna inanılan programın gereksiz test kontrollerinden arındırılmış 
    biçimidir.  Son kullanıcılar kullanıcılar programın release versiyonunu kullanacaklardır. 

    İşte Python'da assert kontrollerinin koda dahil edildiği versiyon programın debug versiyonu -O seçeneği ile assert kontrollerinin 
    koddan çıkartıldığı versiyon ise release versiyonudur. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Pekiyi assert deyiminin faydası nedir? Programcı kodunu geliştirirken pek çok yere assert deyimi sayesinde sanki gereksiz gerekebilecek
    iddialar yerleştirir. Eğer bu iddialar doğrulanmazsa programcı birtakım şeylerin ters gittiğini düşünüp yapmış olduğu bug hakkında 
    bir ip ucu elde eder. Eğer geliştirme sırasında hiç AssertionError oluşmazsa bu durumda kodun sağlam olduğunu düşünür ancak bu gereksiz 
    kontrollerden kodunu arındırmak için onu -O seçeneği ile çalıştırır. Yani başka bir deyişle aslında kodu geliştirirken assert deyimlerini 
    kullanır ancak çalıştırırken bu assert deyimlerini -O seneği ile koddan kaldırır. 

    Programcı kodunu geliştirirken saçma gibi gözükse bile pek çok yere assert deyimlerini yereştirir. Böylece eğer testler sırasında 
    AssertionError oluşursa bir "bug" olduğunu anlar ve bir ip ucu elde ederek bug'ı düzeltir. Ancak assert deyimlerini koddan hiç çıkartmaz. 
    Çünkü buna gerek yoktur. Zaten programı çalıştırırken -O seçeneği ile tek hamlede bu gereksiz assert deyimlerinden kullanıcı kurtulmaktadır.
    Örneğin çerçeve çizen bir fonksiyonu yazıp kodun çeşitli yerlerinde çağıran programcı parametreler üzerinde iddialarda bulunabilir. Böylece 
    kodunun başka yerlerinde bu fonksiyonu yanlış parametrelerle çağırdığını geliştirme aşamasında anlayabilir:

    def draw_rect(x1, y1, x2, y2):
        assert x1 < x2
        assert y1 < y2
        assert x1 >= 0 and x2 >= 0 and y1 >= 0 and y2 >= 0
        
        print('çerçeve çiziliyor')
   
    Bu fonksiyonda x1, y1 çerçevenin sol üst köşe koordinatlarını x2, y2 ise sağ alt köşe koordinatlarını belirtmektedir. Eğer biz 
    kodumuzda bu fonksiyonu kullanırken ona yanlışlıkla hatalı argümanlar geçmişsek kodu geliştirirken bunu assert deyimleri sayesinde 
    anlayabiliriz. Ancak bu kontroller sağlam çalışan bir program için gereksizdir. O halde programı kullanıcıya teslim ederken onun 
    programı -O ile çalıştırmasını sağlamalıyız.
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki genel biçimde de görüldüğü gibi assert deyiminde iddianın yanına virgül atomu ile başka bir ifade de yerleştirilebilir. 
    Bu ifade genellikle bir string olur. Bu string AssertionError sınıf nesnesine argüman olarak geçirilmektedir. Yani buradaki yazı 
    kod assert işlemine takıldığında ekranda görüntülenecek olan mesajı belirtmektedir. Örneğin:

    def foo(a):
        assert a > 0, 'paramter must be positive'
        print(a)

    foo(-10)

    Buarada kod çalıştırıldığında aşağıdaki gibi bir exception mesajı verilecektir:
    
    AssertionError: paramter must be positive
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi assert deyimi programın debug versiyonunda devreye giren ancak release versiyonunda devreye girmeyen 
    kontroller oluşturmaktadır. Eğer programcı her zaman kontrolün çalıştırılmasını istiyorsa bunu assert deyimi ile değil manuel biçimde 
    if deyimleriyle yapmalıdır. 

    Ayrıca Python'da assert deyimlerinden kurtulmak için -O seçeneğinin yanı sıra PYTHONOPTIMIZE isimli bir çevre değişkeni de kullanılabilmektedir. 
    Bu çevre değişkenine herhangi bir yazı kaşı getirilirse artık Python yorumlayıcıları sanki kodu -O seçeneği ile çalıştırmışız gibi 
    davranmaktadır. Örneğin Windows sistemlerinde bu işlemi şöyle yapabiliriz:

    C:\Python>set PYTHONOPTIMIZE=optimize
    C:\Python>python sample.py

    UNIX/Linux ve macOS sistemlerinde de aynı işlem şöyle yapılabilir:

    $ export PYTHONOPTIMIZE=optimize
    $ python sample.py

    Bu çevre değişkeni açılan terminale ilişkindir. Dolayısıyla terminal kapatıldığında bu etki de ortadan kaldırılacaktır. Ancak 
    terminal kapatılmadan etkinin ortadan kaldırılması için bu çevre değişkenine atanan değerin yok edilmesi gerekir. Bu işlem Windows'ta
    şöyle yapılmaktadır:

    set PYTHONOPTIMIZE=

    Aynı işlem UNIX/Linux ve macOS sistemlerinde de şöyle yapılmaktadır:

    PYTHONOPTIMIZE=

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Python'da "tür açıklamaları (type annotation)" ve assert deyiminin dışında test süreci için en kapsamlı araç "unittest" modülü
    içerisindeki birim testine (unittesting) yönelik hazırlanmış mekanizmadır. Burada birim testlerinin Python'da nasıl yapıldığını 
    açıklayacağız.

    Birim testleri son 20 yıldır yaygın kullanılan test mekanizmalarındadır. Buradaki "birim (unit)" kodu oluşturan küçük parçaları 
    anlatmaktadır. Bu küçük parçalar da genellikle fonksiyonlar ve metotlar biçiminde karşımıza çıkmaktadır. Birim testlerinde programcı
    çeşitli "test durumları (test cases)" oluşturarak kendi yazdığı kodu kendisi kodla test etmektedir. Ancak bu test işlemi geliştirme 
    işlemini sekteye uğratmayacak biçimde özel birim testi mekanizmalarıyla yapılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Birim testleri için Python'un standart kütüphanesinde "unittest" isimli bir modül bulundurulmuştur. Programcı test işlemleri için 
    "test durumları (test cases)" oluşturur. Test durumları unittest.TestCase isimli bir sınıftan türetilen sınıflar biçiminde oluşturulmalıdır. 
    Örneğin:

    class MyTestCase(unittest.TestCase):
        pass

    Sonra yapılacak testler bu sınıfın metotları biçiminde oluşturulur. Ancak sınıfın tüm metotları test metodu olmak zorunda değildir. 
    Test metotları "test" önekiyle başlatılarak isimlendirilmelidir. Örneğin:

    class MyTestCase(unittest.TestCase):
        def test_max(self):
            pass
        
        def test_sort(self):
            pass
        
    Burada başı "test" öneki ile başlayan test fonksiyonları programcı tarafından serbest bir biçimde yazılır. Eğer bu kodlar uzun sürerse 
    programcı sınıfa başı "test" ile başlamayan yardımcı metotlar yerleştirilebilir. Test metotlarını da bu yardımcı metotları çağırarak 
    yazabilir. Bizim unittest.TestCase sınıfından türeterek oluşturduğumuz sınıftaki başı "test" ile başlayan metotlara "test" ya da "test 
    metotları" denilmektedir. Bir TestCase içerisinde istenildiği kadar test bulundurulabilir. 

    unittest modülü içerisindeki isimlendirmeler "deve notasyonu (camel casting)" kullanılarak yapılmıştır. Bir testin doğruluğu için aşağıdaki
    assert metotları bulundurulmuştur. Bu metotlar TestCase sınıfının metotlarıdır. Dolayısıyla test metotları içerisinde self ile çağrılmalıdır:

    assertEqual(a, b)
    assertNotEqual(a, b)
    assertTrue(x)
    assertFalse(x)
    assertIs(a, b)
    assertIsNot(a, b)
    assertIsNone(x)
    assertIsNotNone(x)
    assertIn(a, b)
    assertNotIn(a, b)
    assertIsInstance(a, b)
    assertNotIsInstance(a, b)
    assertAlmostEqual(a, b)
    assertNotAlmostEqual(a, b)
    assertGreater(a, b)
    assertGreaterEqual(a, b)
    assertLess(a, b)
    assertLessEqual(a, b)
    assertRegex(s, r)
    assertNotRegex(s, r)
    assertCountEqual(a, b)
    assertMultiLineEqual(a, b)
    assertSequenceEqual(a, b)
    assertListEqual(a, b)
    assertTupleEqual(a, b)
    assertSetEqual(a, b)
    assertDictEqual(a, b)
    ...

    assert metotlarının tam listesini "Python Standard Library" dokümanlarından elde edebilirisiniz. 

    Programcı test fonksiyonlarının içerisinde testlerini yukarıdaki assert metotlarını kullanarak yapar. En sonunda test durumlarını
    (test cases) çalıştırmak için unittest modülündeki main fonksiyonu çalıştırır. Bu main fonksiyonu unitest.TestCase sınıflarından türetilmiş
    tüm test durum sınıflarını belirler ve onların "test" ismi ile başlayan metotlarını çağırır. Test metotlardaki assert çağrılarında 
    belirtilen iddia yanlış ise bu durumda ilgili test "hatalı (fail)" ilan edilir. 
    
    En sonunda main fonksiyonu bütün testlerin sonuçlarına ilişkin bir rapor çıkarmaktadır. Programcı da bu raporu inceleyerek testlerin 
    neden başarısız olduğunu araştırır ve kodundaki hataları düzeltir.

    Bir test fonksiyonu içerisinde birden fazla assert metodu kullanılabilir. Bunlardan biri başarısız olursa test orada sonlandırılmaktadır. 
    Yani test raporu tüm assert'lere bakılarak verilmez. İlk başarısız olan assert işleminde test fonksiyonu başarısız ilan edilmektedir. 

    Birim testi yaparken test senaryolarını düzgün bir biçimde oluşturmalısınız. Tüm test senaryolarını baştan bir dokümana yazıp 
    sonra koda dökebilirsiniz. Bir kodu test ederken sağlam çalıştığına güvendiğiniz başka fonksiynları ve sınıfları kullanabilirsiniz.

    Aşağıdaki örnekte programcı "mylib.py" kütüphanesini geliştirirken aynı zamanda onu test emek istemektedir. mylib.py dosyasında bir 
    sequence dizilimin en büyük elemanını bulan getmax isimli fonksiyon ve onu in-place biçimde sıraya dizen bsort isimli fonksiyon 
    bulunmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

# mylib.py

def getmax(sequence):
    if len(sequence) == 0:
        return None
    
    maxval = sequence[0]
    
    for i in range(1, len(sequence)):
        if sequence[i] > maxval:
            maxval = sequence[i]
            
    return maxval

def bsort(sequence):
    for i in range(len(sequence) - 1):
        for k in range(len(sequence) - i - 1) :
            if sequence[k] > sequence[k + 1]:
                sequence[k], sequence[k + 1] = sequence[k + 1], sequence[k]      
        
# test.py

import mylib
import unittest
import random
    
class MyTestCase(unittest.TestCase):
    def test_getmax(self):
        self.assertEqual(mylib.getmax([3, 5, 7, 2, 9]), 9)
        self.assertEqual(mylib.getmax([10, 45, 23, -4, 56]), 56)
        self.assertEqual(mylib.getmax([1, 2, 3, 4, 5, 6, 7, 8]), 8)
        self.assertEqual(mylib.getmax([-1, -2, -3, -4, -5]), -1)
                
    def test_getmax_none(self):
        self.assertIsNone(mylib.getmax([]))
        
    
    def test_random(self):
        for i in range(100):
            a = [random.randint(0, 100000) for i in range(1000)]
            self.assertEqual(max(a), mylib.getmax(a))
            
    def test_sort(self):
        a = [5, 4, 3, 2, 1]
        mylib.bsort(a)
        self.assertEqual(a, [1, 2, 3, 4, 5])
        
        a = [1, 1, 1, 1, 1, 1]
        mylib.bsort(a)
        self.assertEqual(a, [1, 1, 1, 1, 1, 1])
        
        a = [-5, -3, -6, -1]
        mylib.bsort(a)
        self.assertEqual(a, [-6, -5, -3, -1])
        
        for i in range(100):
            a = [random.randint(0, 100000) for i in range(1000)]
            b = a.copy()
            
            mylib.bsort(a)
            b.sort()
            
            self.assertEqual(a, b)
        
        a = []
        
        mylib.bsort(a)
        self.assertEqual(a, [])
        
unittest.main()

#------------------------------------------------------------------------------------------------------------------------------------
                                                81. Ders 03/11/2023 – Cuma
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    unittest modülünün main fonksiyonuna biz tüm test case'leri değil istediklerimizi de parametre olarak verebiliriz. Fonksiyon default 
    durumda tüm TestCase sınıflarının tüm testlerini çalıştırmaktadır. Bunun için main fonksiyonunun defaultTest parametresine TestCase 
    sınıfının ismi girilebilir. Örneğin:

    unittest.main(defaultTest='MyTestCase')

    Bireden fazla test case'leri çalıştırabilmek için ise defaultTest parametresi TestCase sınıflarının isimlerini içeren dolaşılabilir bir 
    nesne biçiminde girilmelidir. Örneğin:

    unittest.main(defaultTest=['SortTestCase', 'MaxTestCase'])

    Benzer biçimde main fonksiyonu türettiğimiz TestCase sınıfının belli bir  sınıfının belli bir test fonksiyonunu da çalıştırabilir. Bunun 
    için yazısal biçimde test sınıfı ve nokta ile test metodu belirtilmelidir. Örneğin:

    unittest.main(defaultTest='MyTestCase.test_max')

    Benzer biçimde yine birden fazla metot da dolaşılabilir bir nesne ile belirtilebilmektedir. Örneğin:

    unittest.main(defaultTest=['MaxTestCase.test_getmax', 'SortTestCase.test_sort'])
#------------------------------------------------------------------------------------------------------------------------------------
    
    import mylib
import unittest
import random
    
class MaxTestCase(unittest.TestCase):
    def test_getmax(self):
        self.assertEqual(mylib.getmax([3, 5, 7, 2, 9]), 9)
        self.assertEqual(mylib.getmax([10, 45, 23, -4, 56]), 56)
        self.assertEqual(mylib.getmax([1, 2, 3, 4, 5, 6, 7, 8]), 8)
        self.assertEqual(mylib.getmax([-1, -2, -3, -4, -5]), -1)
                
    def test_getmax_none(self):
        self.assertIsNone(mylib.getmax([]))
        
    def test_random(self):
        for i in range(100):
            a = [random.randint(0, 100000) for i in range(1000)]
            self.assertEqual(max(a), mylib.getmax(a))
    
class SortTestCase(unittest.TestCase)        :
    def test_sort(self):
        a = [5, 4, 3, 2, 1]
        mylib.bsort(a)
        self.assertEqual(a, [1, 2, 3, 4, 5])
        
        a = [1, 1, 1, 1, 1, 1]
        mylib.bsort(a)
        self.assertEqual(a, [1, 1, 1, 1, 1, 1])
        
        a = [-5, -3, -6, -1]
        mylib.bsort(a)
        self.assertEqual(a, [-6, -5, -3, -1])
        
        for i in range(100):
            a = [random.randint(0, 100000) for i in range(1000)]
            b = a.copy()
            
            mylib.bsort(a)
            b.sort()
            
            self.assertEqual(a, b)
        
        a = []
        
        mylib.bsort(a)
        self.assertEqual(a, [])
        
        unittest.main(defaultTest=['MaxTestCase.test_getmax', 'SortTestCase.test_sort'])

#------------------------------------------------------------------------------------------------------------------------------------
    unittest modülündeki main fonksiyonu her test metodu için ilgili TestCase sınıfınından ayrı bir nesne yaratmaktadır. 
    Bazen test metotlarından önce birtakım hazırlık işlemlerinin yapılması gerekebilmektedir. Bunun için her test metodu çağrılmadan 
    önce otomatik olarak TestCase sınıfının setUp isimli metodu çağrılmaktadır. Programcı da bu setUp metodunda test öncesinde yapılması 
    gereken bazı şeyleri yapabilir. Programcı her test fonksiyonundan önce değil de toplamda bir kez hazırlık işlemi yapacaksa 
    bu durumda setUpClass metodunu kullanmalıdır. setUpClas metodu bir sınıf metodudur. Eğer programcı sınıfın __init__ metodu iiçerisinde
    birtakım hazırlık işlemlerini yapmak istiyorsa bu durumda __init__ metodu için *args ve **kwargs parametrelerini girmeli ve taban sınıfın
    __init__ metounu bu parametrelerle *'lı bir biçimde çağırmaıdır. Örneğin: 
    
    class MaxTestCase(unittest.TestCase):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            # ....

    setUp metodu her test fonksiyonu çalıştırılmadan önce çalıştırılan metottur. setUp metodu test fonksiyonu için bazı önişlemlerin
    yapılmasını sağlamak amacıyla bulundurulmuştur. İşte her test fonksiyonu çalıştırıldıktan sonra tearDown isimli metot da çalıştırılmaktadır. 
    Böylece programcı eğer setUp metodunda birtakım tahsisatlar yapmışsa tearDown metodunda bunları geri alabilir. 

    Aşağıdaki programı çalıştırınız ve kaç kere __init__ metotlarının ve setUp metotlarının çağrıldığına dikkat ediniz.         
 #------------------------------------------------------------------------------------------------------------------------------------
    
def mymax(iterable):
    it = iter(iterable)  # iterable.__iter__()
    try:
        mval = next(it)
    except:
        raise ValueError('maxval() arg is an empty sequence')
    for x in it:
        if x > mval:
            mval = x
            
    return mval

def mysort(a):
    for i in range(len(a) - 1):
        for k in range(len(a) - i - 1):
            if a[k] > a[k + 1]:
                a[k], a[k + 1] = a[k + 1], a[k]
        
import unittest
import random
import copy
                 
class MyTestCase(unittest.TestCase):
    def __init__(self, *args):
        super().__init__(*args)
        print(args)
        self.count = 1000000
        
    def setUp(self):
        random.seed(12345)
        
    def test_max(self):
        for _ in range(self.count):
            a = random.sample(range(1000), 10)
            self.assertEqual(max(a), mymax(a))
         
    def test_sort(self):
        for _ in range(self.count):
            a = random.sample(range(1000), 10)
            b = copy.copy(a)
            a.sort()
            mysort(b) 
          
            self.assertEqual(a, b)

unittest.main()

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
def mymax(iterable):
    it = iter(iterable)  # iterable.__iter__()
    try:
        mval = next(it)
    except:
        raise ValueError('maxval() arg is an empty sequence')
    for x in it:
        if x > mval:
            mval = x
            
    return mval

def mysort(a):
    for i in range(len(a) - 1):
        for k in range(len(a) - i - 1):
            if a[k] > a[k + 1]:
                a[k], a[k + 1] = a[k + 1], a[k]
        
import unittest
import random
import copy
import csv
                 
class MyTestCase(unittest.TestCase):
    def __init__(self, *args):
        super().__init__(*args)
        self.count = 1000000
        
    def setUp(self):
        random.seed(12345)
        self.f = open('test.csv')
        
    def tearDown(self):
        self.f.close()
    
        
    def test_max(self):
        for _ in range(self.count):
            a = random.sample(range(1000), 10)
            self.assertEqual(max(a), mymax(a))
            
        a = [[int(c) for c in line] for line in csv.reader(self.f)]
        self.assertEqual(max(a), mymax(a))
            
    def test_sort(self):
        for _ in range(self.count):
            a = random.sample(range(1000), 10)
            b = copy.copy(a)
            a.sort()
            mysort(b) 
          
            self.assertEqual(a, b)
            
        a = [[int(c) for c in line] for line in csv.reader(self.f)]
        self.assertEqual(max(a), mymax(a))
                
if __name__ == '__main__':
    unittest.main()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında projelerde test kodlarının gerçek kodlarla aynı dosyada bulundurulması iyi bir teknik değildir. Genellikle programcı test 
    kodlarını asıl kodlardan ayırır. Örneğin projemzin ismi project olmak üzere biz projemizin tüm kodlarını bir dizinde toplayabiliriz. 
    Bu dizinde Src ve Test isimli iki dizin oluşturabiliriz. Asıl kodlarımızı src dizininin içerisinde test kodlarını ise test dizininin 
    içerisinde bulundurabiliriz:

    Project 
        Src
        Test

    Tabii burada Test dizininin içerisindeki test modüllerinin src dizinindeki test edilecek modüllere erişebilmesi gerekir. Maalesef bunun 
    pratik bir yolu yoktur. En normal yöntem sys.path listesine buradaki Src dizinini eklemek olabilir. 

    Aşağıdaki örnekte Test dizini içeriside test.py ve test.csv dosyaları bulundurulmuştur. Src dizinin içerisinde de mymax ve mysort 
    fonksiyonlarının bulunduğu bir util.py dosyası vardır:

      Project 
        Src
            util.py
        Test
            test.py
            test.csv

#------------------------------------------------------------------------------------------------------------------------------------

# Proejct/Src/util.py

def mymax(iterable):
    it = iter(iterable)  # iterable.__iter__()
    try:
        mval = next(it)
    except:
        raise ValueError('maxval() arg is an empty sequence')
    for x in it:
        if x > mval:
            mval = x
            
    return mval

def mysort(a):
    for i in range(len(a) - 1):
        for k in range(len(a) - i - 1):
            if a[k] > a[k + 1]:
                a[k], a[k + 1] = a[k + 1], a[k]
        
# Project/Test/test.py

import sys

sys.path.append('../src')
import util

import unittest
import random
import copy
import csv
                
class MyTestCase(unittest.TestCase):
    def __init__(self, *args):
        super().__init__(*args)
        self.count = 1000000
        
    def setUp(self):
        random.seed(12345)
        self.f = open('test.csv')
        
    def tearDown(self):
        self.f.close()
    
    def test_max(self):
        for _ in range(self.count):
            a = random.sample(range(1000), 10)
            self.assertEqual(max(a), util.mymax(a))
            
        a = [[int(c) for c in line] for line in csv.reader(self.f)]
        self.assertEqual(max(a), util.mymax(a))
            
    def test_sort(self):
        for _ in range(self.count):
            a = random.sample(range(1000), 10)
            b = copy.copy(a)
            a.sort()
            util.mysort(b) 
          
            self.assertEqual(a, b)
            
        a = [[int(c) for c in line] for line in csv.reader(self.f)]
        self.assertEqual(max(a), util.mymax(a))

    unittest.main()

#------------------------------------------------------------------------------------------------------------------------------------
    Python'un standart kütüphanesindeki modüller (yani .py dosyaları) bilindiği gibi birtakım faydalı fonksiyonları ve sınıfları bulundurmaktadır. 
    Ancak bu modüllerin bazıları aynı zamanda bir program gibi de çalıştırılabilmektedir. Yani bu modüllerin bazıları hem bir kütüphane gibi 
    kullanılmakta hem de bir program gibi çalıştırılmaktadır. Tabii bu modüllerdeki programlar bu modülleri yazanlar tarafından aşağıdaki 
    gibi bir kontrolle çalıştırılmıştır:

    # söz konusu modül
    ...
    ...
    ...
    if __name__ == '__main__:
        ....

    Mademki bazı kütüphane modülleri aynı zamanda birer program gibi çalıştırılabilmektedir. Pekiyi onları program gibi nasıl çalıştırabiliriz?
    Öncelikle çalıştırma için modüle ilişkin .py dosyalarının nerede olduğunu bilmemiz gerekir. Kurulum programı Python'ı kurarken bunları 
    bazı dizinlerin içerisine çekmektedir. Her ne kadar bunların yerlerini biz bulabilirsek de buradaki programları bu yöntemle çalıştırmak 
    zahmetlidir. Mademki Python yorumlayıcısı zaten bunların yerlerini bilmektedir. O halde bizim Python yorumlayıcısına bunu bildirmemiz 
    yeterli olacaktır. Bu işlem de Python yorumlayıcısının komut satırında -m seçeneği ile yapılmaktadır. Örneğin:
    
    python -m <modül_ismi> [argüman_listesi]

    Burada -m ve modül isminden sonraki komut satırı argümanları doğrudan bu modül programına komut satırı argümanı olarak aktarılır. 
    Özetle eğer biz Python'un standart kütüphanesindeki bir modülde bulunan programı -m seçeneği ile çalıştırırız.     
#------------------------------------------------------------------------------------------------------------------------------------
  
#------------------------------------------------------------------------------------------------------------------------------------
    unittest modülü de hem bir kütüphane hem de bir program gibi davranmaktadır. unitest modülüne yerleştirilmiş olan program aslında 
    unittest.main fonksiyonunu çağırmaktadır. Bu durumda biz istersek unit test işlemlerini komut satırından da yapabiliriz. 

    Aşağıdaki örnekte test.py içerisinden unittest.main çağrısı kaldırılmıştır. Artık test kodu aşağıdaki gibi komut satırından da 
    çalıştırılabilir:

    python -m unittest test

    Alında çalıştırma sırasında modüldeki belli bir test case ya da test case içerisindeki belli bir test metodu da belirtilebilir. Örneğin:

    python -m unittest test.MyTestCase
    python -m unittest test.MyTestCase.test_max

#------------------------------------------------------------------------------------------------------------------------------------

import sys

sys.path.append('../src')
import util

import unittest
import random
import copy
import csv
                
class MyTestCase(unittest.TestCase):
    def __init__(self, *args):
        super().__init__(*args)
        self.count = 1000000
        
    def setUp(self):
        random.seed(12345)
        self.f = open('test.csv')
        
    def tearDown(self):
        self.f.close()
     
    def test_max(self):
        for _ in range(self.count):
            a = random.sample(range(1000), 10)
            self.assertEqual(max(a), util.mymax(a))
            
        a = [[int(c) for c in line] for line in csv.reader(self.f)]
        self.assertEqual(max(a), util.mymax(a))
            
    def test_sort(self):
        for _ in range(self.count):
            a = random.sample(range(1000), 10)
            b = copy.copy(a)
            a.sort()
            util.mysort(b) 
          
            self.assertEqual(a, b)
            
        a = [[int(c) for c in line] for line in csv.reader(self.f)]
        self.assertEqual(max(a), util.mymax(a))

#------------------------------------------------------------------------------------------------------------------------------------
    Üçüncü parti kütüphaneler ve paketler ve programlar başka kütüphanelere ve paketlere bağımlı olabilirler. Çünkü programcılar başka 
    kütüphanelerden faydalanıp kendi kütüphanelerini ve programlarını yazmaktadır. Üstelik programcılar kendi kütüphanelerini ya da 
    programlarını yazarken başka kütüphanelerin belli versiyonlarını kullanmış olabilirler. Kütüphanelerin yeni versiyonları çıktıkça bunlar 
    eskiye doğru uyumu oratadan kaldırabilmektedir. Yani bazen bir kütüphanenin yeni versiyonu eski versiyonu gibi kullanılamamaktadır. 
    Bu durumda biz üçüncü parti bir kütüphaneyi ya da paketi yüklediğimizde o paket kendi kullandığı kütüphanelerin son versiyonunu yükleyecektir. 
    Bu da paketin çalışmasını olumsuz yönde etkileyebilecektir. Örneğin bir makine öğrenmesi programı Tensorflow isimli kütüphanenin 1'li 
    versiyonu kullanıalrak yazılmış olabilirken diğer bir program 2'li TensorFlow kütüphanesinin 2'li versiyonları kullanılarak yazılmış 
    olabilir. Biz aynı makineye bu iki versiyonu birlikte yükleyemeyiz. Değişik kütüphanelerin ve programların değişik kütüphane versiyonlarını 
    kullanması önemli bir sıkıntıdır. Pekiyi bu sıkıntıyı giderebilmek için ne yapabiliriz? İşte bunun için Python dünyasında "sanal ortam 
    (virtual envirionment)" denilen bir kavram oluşturulmuştur. 

    Sanal ortam (virtual environment) adeta makinemizdeki ayrı bir python kurulumu gibi etki oluşturmaktadır. Her sanal ortam ayrı bir 
    Python kurulumu temsil ettiği için birinde pip programı ile yüklenen paket ona özgü olmaktadır. Her sanal ortam birbirlerinden 
    izole edilmiştir. Örneğin biz bir samal ortama Python yorumlayıcısının 3.5 sürümünü, TensorFlow kütüphanesinin 1.4 sürümünü yükleyebiliriz. 
    Diğer bir sanal ortama ise Python yorumlayıcısının 3.10 sürümünü, TensorFlow kütüphanesinin ise 2.1 sürümünü yükleyebiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir sanal ortam yaratmak için standart kütüphanedeki venv modülü kullanılmaktadır. Bu modül bir program gibi de çalıştırılabilmektedir. 
    Sanal ortam yaratmanın tipik biçimi şöyledir:

    python -m venv <sanal_ortamın_ismi>

    Sanal ortam oluşturulduğunda bizim vermiş olduğumuz isimle bir dizin yaratılır. Yaratılan dizinin içerisinde "include" ve "lib" dizinleri 
    bulunur. Ayrıca Windows sistemlerinde "Scripts" isimli bir dizin UNIX/Linux ve macOS sistemlerinde "bin" isimli bir dizin daha vardır. 
    "Scripts" ya da "bin" dizinlerinin içerisinde "activate" ve "deactivate" isimli iki shell script bulunmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Sanal ortamı Windows'ta aktive etmek "Scripts" dizinine geçilip  "activate" scriptinin çalıştırılması gerekmektedir. Bunun için cd 
    komutunu kullanabilirsiniz. Dizine geçtikten sonra doğrudan komut satırından "activate" yazıp ENTER tuşuna basabilirsiniz.  Örneğin:

    C:\Users\kaanaslan\Study\Python-App>python -m venv myenv

    C:\Users\kaanaslan\Study\Python-App>cd myenv

    C:\Users\kaanaslan\Study\Python-App\myenv>dir
    Volume in drive C has no label.
    Volume Serial Number is 8E44-2FDB

    Directory of C:\Users\kaanaslan\Study\Python-App\myenv

    09.09.2022  20:27    <DIR>          .
    09.09.2022  20:27    <DIR>          ..
    09.09.2022  20:27    <DIR>          Include
    09.09.2022  20:27    <DIR>          Lib
    09.09.2022  20:27                92 pyvenv.cfg
    09.09.2022  20:27    <DIR>          Scripts
                1 File(s)             92 bytes
                5 Dir(s)  165.163.900.928 bytes free

    C:\Users\kaanaslan\Study\Python-App\myenv>cd Scripts

    C:\Users\kaanaslan\Study\Python-App\myenv\Scripts>activate

    (myenv) C:\Users\kaanaslan\Study\Python-App\myenv\Scripts>

    Sanal ortamın aktive edildiği prompt'taki en soldaki parantezden belli olmaktadır. Bu parantezin içerisinde sanal ortamın isminin
    bulunduğuna dikkat ediniz. Aslında bu dizin ile isim farklı da olabilmektedir. Bunun için sanal ortam yaratılırken --prompt <isim> 
    argümanı kullanılmalıdır. Örneğin:

    python -m venv myenv --prompt csd
        
    Windows'ta sanal ortamı deactivate etmek için herhangi bir yerde "deactivate" yazılıp ENTER tuşuna basılır. Yani "deactivacate" 
    komutu için "Scripts" dizininde olmak gerekmemektedir. Örneğin:

    (myenv) C:\Users\kaanaslan\Study\Python-App\myenv\Scripts>deactivate

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux ve macOS sistemlerinde sanal ortamı aktive etmek için "bin" dizinine geçilip "activate" scripti aşağıdaki gibi 
    çalıştırılmalıdır:

    source activate

    Örneğin:

    $ python3 -m venv myenv
    $ cd myenv
    $ ls
    bin        include        lib        pyvenv.cfg
    $ cd bin
    $ source activate
    
    Bu sistemlerde de sanal ortamı deactivate etmek için herhangi bir yerde "deactive" yazıp ENTER tuşuna basabiliriz. Örneğin:

    $ deactivate
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Bir sanal ortam oluşturup onu aktive ettiğimizde biz artık bağımısız bir Python kurulumunun içinde gibi oluruz. Dolayısıyla sanal 
    ortamımız aktive edildiğinde artık pip programı o sanal ortama install işlemi yapar. Bundan diğer sanal ortamlar ve ana kurulum 
    etkilenmez. Sanal ortamı silmek için tek yapılacak şey o dizini silmektir. Örneğin:

    c:\Users\kaanaslan\Study\Python-App\myenv\Scripts>activate

    (myenv) c:\Users\kaanaslan\Study\Python-App\myenv\Scripts>pip install numpy
    Collecting numpy
    Downloading numpy-1.23.3-cp39-cp39-win_amd64.whl (14.7 MB)
        |████████████████████████████████| 14.7 MB 6.4 MB/s
    Installing collected packages: numpy
    Successfully installed numpy-1.23.3
    WARNING: You are using pip version 21.2.3; however, version 22.2.2 is available.
    You should consider upgrading via the 'C:\Users\kaanaslan\Study\Python-App\myenv\Scripts\python.exe -m pip install --upgrade pip' command.

    Bu örnekte gördüğünüz gibi biz NumPy'ı aslında ana kuruluma değil "myenv" isimli sanal ortama kurduk. pip programı indirdiği paketleri 
    lib dizini içerisindeki "site-packages" dizinine kopyalamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Anaconda dağıtımında sanal ortamlar GUI arayüzü ile oluşturulabilmektedir. Anaconda Navigator'da "Environments" sekmesine gelindiğinde
    O anda yaratılmış olan sanal ortamlar görüntülenmektedir. Burada biz fare ile tıklayarak bir sanal ortamı aktive edebiliriz.
    Aşağıdaki kısımda yeni bir sanal ortamı yaratıp silmek için düğmeler bulunmaktadır. Anaconda dağıtımı yükdiğinde "base(root)" isimli
    default bir sanal ortam otomatik olarak oluşturulmaktadır. Her sanal ortama Spyder IDE'sinin yeniden kurulması gerekir. 

    PyCharm da benzer bir biçimde çalışmaktadır. Biz PyCharm'da daha önce oluşturmuş olduğumuz bir sanal ortamı proje olarak açabiliriz. 
    PyCharm'da bir proje yaratılırken her zmana bir sanal ortam da yaratılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Python kurulumunda (bu bir sanal ortam da olabilir) kurulmuş bütün paketlerin versiyon listesisini elde etmek için şu komut 
    uygulanmalıdır:

    pip freeze

    Burada install edilmiş olan paketler ekrana yazdırılır. Onun bir dosyaya yazdırılmasını istiyorsanız ">" karakteriyle "io yönlendirmesi" 
    uygulamalısınız:

    pip freeze > plist.txt

    Artık biz yukarıdaki komutla o andaki python kurulumunun (bu bir sanal ortam da olabilir) install etmiş olduğu tüm paketleri versiyon 
    numaralarıyla birlikte "plist.txt" isminde bir dosyaya yerleştirmiş olduk. Artık pip programı ile bu dosyadan hareketle tün bu paketleri 
    başka bir kuruluma (bu başka kurulum bir sanal ortam da olabilir) -r seçeneği ile install edebiliriz. -r seçeneğinin yanına 
    oluşturmuş olduğumuz dosyanın yol ifadesi getirilmelidir. Örneğin:

    pip install -r plist.txt 

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Bir programı bağımsız çalıştırılabilir (executable) bir program haline getirebilmek için çeşitli üçüncü parti araçlar kullanılabilmektedir. 
    Bunlardan biri "pyinstaller" denilen araçtır. Bunun indirilip kurulması şöyle yapılabilir:

    pip install PyInstaller

    Bu biçimde kurulum yapıldığında pyinstaller Python'un standard kütüphanelerinin bulunduğu dizine kurulmaktadır. Dolayısıyla pyinstaller 
    -m seçeneği ile çalıştırılmalıdır. 

    Aslında pyinstaller programına başka alternatifler de vardır. Örneğin:

    py2exe
    PyOxidizer
    autopy2exe
    cx_freeze

    Ancak biz burada en yaygın kullanılan araç olan pyinstaller üzerinde duracağız.
    
    Artık bir Python programından "çalıştırılabilir (executable)" bir dosya elde edilebilir. Tek yapılacak şey şudur:

    python -m PyInstaller sample.py --onefile

    Eğer burada bir sorun çıkarsa --noupx seöeneğini de ekleyebilirisniz:

    python -m PyInstaller sample.py --onefile --noupx

    Burada sample.py dosyası çalıştırılmak istenen programı belirtmektedir. Tabii bir program çok fazla dosyadan oluşabilir. 
    Yani bu dosyalar import edilerek kullanılmış olabilir. Biz pyinstaller programına akışın başlatılacağı ana dosyayı veririz. 
    pyinstaller bu dosyayı inceler. Bu dosyadakilerden hareketle python yorumlayıcısı dahil olmak üzere her şeyi tek bir çalıştırılabilir
    dosyanın içerisine yerleştirir. Artık yalnızca bu dosya taşınsa bile program çalıştırılabilir. Yukarıdaki işlemden sonra bir 
    "build" bir de "dist" dizinleri oluşturulacaktır. Çalıştırılabilen program "dist" dizinin içerisine çekilir. 

    Eğer pyinstaller çalıştırılırken --onefile seçeneği girilmezse bu durumda dist dizinin içerisinde tek bir dosya değil bir grup dosya 
    yaratılır. Tabii bu dizin kopyalanırsa program çalıştırılabilir. Ancak burada tek bir dosya söz konusu değildir. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
                                                81. Ders 10/11/2023 - Cuma
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    XML (Extensible Markup Language) dokümanları kodlamak, iletmek ve yeniden oluşturmak için kullanılan genel bir doküman formatıdır. 
    XML belli bir konuya yönelik değildir. Herhangi bir konudaki verilerin kodlanması için genel kuralları içerir. Böylece biz örneğin 
    biyomedikal verilerini, veritabanı kayıtlarını, bir IDE'nin ayarlarını vs. XML kullanarak kodlayabiliriz. XML genel bir kodlama 
    formatıdır. Dolayısıyla spesifik bir alana yönelik değildir. XML yalnızca kodlamaya ilişkin kurallara sahiptir. Kodlanan içeriğin 
    ne anlama geldiğine yönelik kurallara sahip değildir. Yani birtakım verileri XML kullanarak text formatında saklayabilirisniz. 
    Ancak bunların ne anlam ifade ettiğini siz bilirsiniz. Örneğin bir IDE proje ayarlarını XML olarak bir dosyaya kaydediyor olabilir. 
    Ancak neyi nasıl kaydettiğini biz XML dosyasına bakarak anlayamayız. Onun semantiğine ilişkin dokümanları incelememeiz gerekir. 

    XML WWW Konsorsiyumu tarafından geliştirilmiştir. ECMA tarafından da standardize edilmiştir. Orijinal dokümanlara aşağıdaki bağlantıdan
    erişebilirniz:

    https://www.w3.org/TR/REC-xml/

    XML dokümanı elemanlaran oluşur. Bir eleman "başlangıç tag'ı (starting tag)" ve "bitiş tag'i (ending tag)" ile belirtilir. Başlangıç 
    ve bitiş tag'larının arasında "içerik (content)" bulunabilmektedir. Örneğin:

    <student>Ali Serçe</student>

    İçerik kısmında boşluklar bırakılırsa bu boşluklar da içeriğe dahil olmaktadır. Örneğin:

    <atasözü> üzüm üzüme baka baka kararır </atasözü>

    Burada içerik " üzüm üzüme baka baka kararır " biçimindedir. 

    Tag'lar açısal parantezler içerisinde yazılır. Bitiş tag'ında / karakteri ve başlangıç tag'ı boşuksuz biçimde bulundurulur. İçerik 
    herhangi bir biçimde oluşturulabilir. Tag isimleri tamamen dokümanı oluşturanın istediği gibi belirleyebileceği isimlerdir. 
    
    Başlangıç tag'ında istenirse "öznitelikler (attributes)" de bulundurulabilir. Öznitelikler isim="değer" biçiminde belirtilir. 
    '=' karakterinin iki yanında boşluklar bırakılabilir. Değer ise her zaman iki tırnak içerisine alınmak zorundadır. Özellikler arasında 
    istenildiği kadar SPACE, TAB ve ENTER karakteri bırakılabilir. Ancak ',' kullanılamaz. Örneğin:

    <student name="Ali Serçe" no="123">Murat Atılgan İlkokulu</student>

    Eğer eleman içeriğe sahip değilse bitiş tag'ı yazılmadan başlangıç tag'ının sonunda "/>" karakterleri ile eleman yazımı bitirilebilir. 
    Örneğin:

    <student name="Ali Serçe" no="123" />

    Yukarıdaki eleman aşağıdaki ile eşdeğerdir:

    <student name="Ali Serçe" no="123"></student>

    Başlangıç tag'ında "<" ile tag ismi bitişik yazılmalıdır. Ancak bundan sonra başlangıç tag'ını bitiren ">" karakteri öncesinde boşluklar 
    olabilmektedir. Örneğin:

    <student     >

    Bu geçerli bir başlangıç tag'ıdır. Bitiş tag'ında "/" ve isim bitişik olmak zorundadır. Ancak bitiş tag'ını bitiren ">" karakterinden önce 
    yine boşluklar olabilir. Örneğin:

    </student    >

    Bu da geçerli bir bitiş tag'ıdır. Tabii normalde uygulamacı bu gereksiz boşlukları kullanmaz. Örneğin:

    <student>content</student>

    Özellik belirtirken '=' karakterinin iki yanında boşluk bırakılabilir. Örneğin:

    <student name   =    "Ali Serçe">

    Bu yazım geçerlidir. Tabii normalde böyle bir şeyi yapmanız için gerekçeniz yoktur. 

    XML formatı hem insanlar tarafından text editörlerle hem de programlar tarafından otomatik biçimde oluşturulabilmektedir. XML dosyaları 
    genellikle prgramlar tarafından okunup parse edilerek kullanılmaktadır.

    Bir XML dosyasının başında kesinlikle XML versiyonunu belirten aşağıdaki tag bulunmak zorudadır:

    <?xml version="1.0"?>

    Şu anda XML'in son versiyonu (hala) 1.0'dır. 

    Her ne kadar XML'in henüz başka bir versiyonu olmasa da bu satırın dokümanın başında bulunması ileriye doğru uyumu korumak için 
    gereklidir. XML dokümanlarınızı "doğrulamak (validate etmek)" için çeşitli araçlar vardır. Google'da "xml validation tools" yazdığınızda 
    pek çok online araçla karşılaşacaksınız.

    Bir XML dökümanında bir tane kök eleman eleman bulunur. Bir elemanın içerik kısmında başka elemanlar bulunabilmektedir. Böylece doküman
    hiyerarşik veriler için kullanılabilir. Örneğin:

    <?xml version="1.0"?>

    <students>
        <student>Ali Serçe</student>
        <student>Kaan Aslan</student>
        <student>NEcati Ergin</student>
    </students>

    Burada kök eleman <students> elemanıdır. Bu eleman <student> elemanlarını içermektedir. Burada <student> elemanları aslında <students>
    elemanının içerik kısmındadır.
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    XML dokümanlarını parse etmek için genel olarak üç mimari kullanılmaktadır:

    1) DOM Parser Mimarisi
    2) SAX Parser Mimarisi
    3) ElementTree Mimarisi

    Hepsinin belli avantajları ve dezavantajları olmakla birlikte en çok tercih edilen ElemenTree parser'larıdır. Biz de burada bu 
    parser'ı tanıtacağız. Python'un standart kütüphanesi bu üç parser mimarisini de desteklemektedir. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    ElementTree parser'ı default durumda tüm XML dosyasını başından sonuna okur ve ondan sonra işleme sokar. Ancak bu modül bloke olmadan 
    parça parça işlem yapabilme yeteneğine de sahiptir. Bu parser Python'un standart kütüphanesinde xml.etree modülünde bulunmaktadır. 

    ElemenTree praser'ını kullanmak için önce ElemenTree sınfını from import ile import edebiliriz:

    from xml.etree import ElementTree

    Parse işlemi bu sınıfın static parse isimli metoduyla yapılmaktadır. Bu parse metodu dosyan ın yol ifadesini alabilir ya da open fonksiyonuyla 
    açılmış olan dosya nesnesini paramatre olarak alabilmektedir. Örneğin:

    from xml.etree import ElementTree 

   tree = ElementTree.parse('sample.xml')

   Ya da örneğin:

    from xml.etree import ElementTree 

    with open('sample.xml') as f:
        tree = ElementTree.parse(f)

    static parse metodu bize ElemenTree sınıfı türünden bir nesne verir. Biz de artık bu sınıfın metotlarını kullanarak işlemlerimizi yaparız. 
    parse metodunun bize verdiği ElementTree nesnesi tüm ağacı temsil etmektedir. 

    XML dokümanlarında başlangıç tag'ı, içerik ve bitiş tag'ının oluşturduğu topluluğa "eleman (element)" denilmektedir. ElementTree 
    mimarisinde tüm ağaç ElementTree sınıfı ile temsil edilirken elemanlar Element sınıfıyla temsil edilmektedir. XML dokümanlarında bir 
    elemanın diğer elemanları içerebildiğine dikkat ediniz. Örneğin:

    <?xml version="1.0"?>
    <data>
        <country name="Liechtenstein">
            <rank>1</rank>
            <year>2008</year>
            <gdppc>141100</gdppc>
            <neighbor name="Austria" direction="E"/>
            <neighbor name="Switzerland" direction="W"/>
        </country>
        <country name="Singapore">
            <rank>4</rank>
            <year>2011</year>
            <gdppc>59900</gdppc>
            <neighbor name="Malaysia" direction="N"/>
        </country>
        <country name="Panama">
            <rank>68</rank>
            <year>2011</year>
            <gdppc>13600</gdppc>
            <neighbor name="Costa Rica" direction="W"/>
            <neighbor name="Colombia" direction="E"/>
        </country>
    </data>

    Burada "data" elemanı "country" elemanlarını "country" elemanları da "rank", "year", "gdppc", "neighbor" elemanlarını içermektedir. 
    Biz bu XML dosyasını "sample.xml" ismiyle kaydedip örneklerde kullanacağız. 

    parse işleminden sonra ilk yapılacak şey kök elemanı elde etmektir. Yukarıdaki örnekte kök eleman "data" isimli elemandır. Bunun için
    ElementTree nesnesi ile sınıfın getroot metodu çağrılır. Örneğin:

    from xml.etree import ElementTree

    tree = ElementTree.parse('sample.xml')
    root = tree.getroot()

    Burada root değişkeni artık Elemant türündendir. Element nesnesinin üç önemli özniteliği vardır: tag, attrib ve text. tag özniteliği 
    string olarak tag'ın ismini, text özniteliği içerik yazısını ve attrib özniteliği de tag'a ilişkin özellikleri bir sözlük biçiminde 
    vermektedir. Sözlüğün anahtarları özelliklerin isimlerinden değerleri de özelliklere '=' ile atanan yazılardan oluşmaktadır. Örneğin:

    <student name="Ali Serçe" no="1234">Ümraniye</student>

    Bu elemanın "tag" özniteliği bize "student" yazısını, text özniteliği "1234" yazısını ve attrib özniteliği ise {'name': 'Ali Serçe', 'no': '1234'}
    sözlük nesnesini vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Bir Element nesnesi aynı zamanda dolaşılabilir bir nesnedir. Biz Element nesnesini dolaşırsak yukarıdan aşağıya doğru onun bütün 
    doğrudan alt elemanlarını elde ederiz. Örneğin:

    from xml.etree import ElementTree

    tree = ElementTree.parse('sample.xml')
    root = tree.getroot()

    for element in root:
        print(element.tag, element.attrib)
   
    Buradan şu çıktı elde edilmiştir:

    country {'name': 'Liechtenstein'}
    country {'name': 'Singapore'}
    country {'name': 'Panama'}

    Element sınıfının iter isimli metodu bize dolaşılabilir bir nesne verir. Ancak iter metodunun verdiği nesneyi dolaştığımızda 
    biz yalnızca doğrudan alt elemanları değil yukarıdan aşağıya doğru kendisi de dahil tüm alt elemanları elde ederiz. Örneğin:

    from xml.etree import ElementTree 

    tree = ElementTree.parse('sample.xml')
    root = tree.getroot()
    
    for element in root.iter():
        print(element.tag, element.attrib)
        
    Buradan şöyle bir çıktı elde edilmiştir:

    data {}
    country {'name': 'Liechtenstein'}
    rank {}
    year {}
    gdppc {}
    neighbor {'name': 'Austria', 'direction': 'E'}
    neighbor {'name': 'Switzerland', 'direction': 'W'}
    country {'name': 'Singapore'}
    rank {}
    year {}
    gdppc {}
    neighbor {'name': 'Malaysia', 'direction': 'N'}
    country {'name': 'Panama'}
    rank {}
    year {}
    gdppc {}
    neighbor {'name': 'Costa Rica', 'direction': 'W'}
    neighbor {'name': 'Colombia', 'direction': 'E'}

    Pekiyi ağaç üzerinde spesifik elemanları nasıl elde edebiliriz? İlk akla gelen yöntem her elemanı elde ederken aynı zamanda 
    tag özelliğine bakmak olabilir. Örneğin:

    from xml.etree import ElementTree

    tree = ElementTree.parse('sample.xml')
    root = tree.getroot()

    for element in root.iter():
        if element.tag == 'year':
            print(element.tag, '=>', element.text)

    Buradan şöyle bir sonuç elde edilmiştir:

    year => 2008
    year => 2011
    year => 2011

    Aslında bunu yapmak için Element sınıfında findall isimli bir metot da bulundurulmuştur. Ancak findall metodu doğrudan alt 
    elemanları aramaktadır. findall bize elemanları bir liste olarak verir. Örneğin:

    result = root.findall('year')

    Burada findall hiçbir eleman bulamayacaktır. Çünkü kök eleman olan "data" yalnızca "country" elemanlarına sahiptir. findall 
    XPATH özelliğini desteklemektedir. XPATH XML ağacını sanki dizin ağacı gibi ifade etmek için kullanılan bir gösterim biçimidir. 
    XPATH ifadesine "./" ile başlamak en yaygın durumdur. Buradaki "./" o andaki eleman anlamına gelir. Örneğin "./country/year" 
    XPATH ifadesi "country" elemanının altındaki "year" elemanlarını bulur. Örneğin:

    from xml.etree import ElementTree

    tree = ElementTree.parse('sample.xml')
    root = tree.getroot()

    for element in root.findall('./country/year'):
        print(element.tag, '=>', element.text)
        
    XPATH'te ".//" ifadesi altındaki tüm elemanlar anlamına gelmektedir. Örneğin ".//year" ilgili elemanın altındaki tüm elemanlar 
    içerisinde "year" tag'larını bize verir. 

    findall bize tüm elemanları bulur, onu bir listeye doldurur ve listeyi bize verir. Halbuki bu işlemin iteratör yoluyla yapılması 
    kimi zaman daha az maliyetli olabilmektedir. İşte findall metodunun iteratörlü versiyonu iterfind ismindedir. iterfind bize 
    dolaşılabilir bir nesne verir. Dolayısıyla biz elemanı döngü içerisinde tek tek elde ederiz. Örneğin:

    from xml.etree import ElementTree

    tree = ElementTree.parse('sample.xml')
    root = tree.getroot()

    for element in root.iterfind('./country/year'):
        print(element.tag, '=>', element.text)

    Element sınıfının find isimli metodu yalnızca koşula uygun ilk elemanı bize verir. Örneğin:

   from xml.etree import ElementTree

    tree = ElementTree.parse('sample.xml')
    root = tree.getroot()

    element = root.find('.//year')
    print(element.tag, '=>', element.text)
    
    Şöyle bir sonuç elde edilecektir:

    year => 2008
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------








