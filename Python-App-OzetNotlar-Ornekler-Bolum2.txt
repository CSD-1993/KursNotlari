                                            C ve Sistem Programcıları Derneği

                                                   Python Uygulamaları 

                                         Sınıfta Yapılan Örnekler ve Özet Notlar 
                                                         2. Bölüm
        
                                                    Eğitmen: Kaan ASLAN   
                
                Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.
                Kaynak belirtmek için aşağıdaki referansı kullanabilirsiniz:           

                Aslan, K. (2025), "Python Uygulamaları Kursu", Sınıfta Yapılan Örnekler ve Özet Notlar, 
                    C ve Sistem Programcıları Derneği, İstanbul.

                        (Notları sabit genişlikli font kullanan programlama editörleri ile açınız.)
                            (Editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz.)

                                        Son Güncelleme: 29/12/2025 - Pazartesi


#------------------------------------------------------------------------------------------------------------------------------------
                                        43. Ders 23/08/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Python genel amaçlı bir programlama dili olmasının yanı sıra makine öğrenmesi, veri bilimi ve matematiksel alanlarda da çok tercih 
    edilmektedir. Ancak Python saf haliyle veri işleme (data processing) konusunda bazı yeteneklerden yoksundur. Veri işleme konusunda 
    kullanılan programlama dilleri genellikle "vektörel işlem" yapma yeteneğine sahiptir. Vektörel işlem demekle biz iki dizinin 
    karşılıklı elemanlarının kolay bir biçimde işleme sokulabilmesini anlatmak istiyoruz. Örneğin Matlab (ya da Open source versiyonu 
    olan Octave) gibi R gibi diller ve ortamlar bu vektörel işlem yapma yeteneğine sahiptir. Vektörel işlem yapabilme yeteneği matematiksel 
    ve istatistiksel pek çok işlemi kısaltmaktadır. Başka bir deyişle matematiksel ve istatiksel konularda kolaylık sağlayan dillerde
    vektörel işlem yapma önemli bir ortak özelliktir.

    Python'a vektörel işlem yapma yeteneğini kazandırmak için bazı üçüncü parti kütüphaneler oluşturulmuştur. Bunların en çok kullanılanı 
    "NumPy" isimli kütüphanedir. NumPy Python'da en çok kullanılan kütüphanelerden biridir. Bazı gerekçelerle Python standart kütüphanesine 
    dahil edilmemiş olsa da standart kütüphendeki pek çok modülden çok daha yoğun kullanılmaktadır. (NumPy hızlı güncellenmektedir. 
    Standart kütüphaneye dahil edilmesinin hantallığa yol açacağı düşünülmüştür.) Numpy kütüphanesi adeta Python'u R ya da Matlab 
    gibi bir dil haline getirmektedir. Numpy C'de yazılmış bir kütüphanedir. Kütüphane paralel programlama tekniklerini kullanmamakla 
    birlikte modern işlemcilerin SIMD (Single Instruction Multiple Data) komutlarını da kullanarak etkin bir biçimde gerçekleştirilmiştir. 
    Dolayısıyla Numpy işlemlerinin Python diline kıyasla daha hızlı yapılacağı söylenebilir. (Örneğin biz bir NumPy fonksiyonunu 
    çağırdığımızda aslında rka planda bir C fonksiyonu çalıştırılmaktadır. Dolayısıyla işlemler adeta C hızında yapılmaktadır.)

    Peki Python'u NumPy kütüphanesi ile R'laştırmak yerine doğrudan R ya da Matlab kullanmak daha uygun değil midir? Matlab ve 
    R genel amaçlı diller değildir. Bunlar uzmanlığı programlama olmayan kişilere yönelik hazırlanmış ortamlar ve dillerdir. Halbuki 
    Python genel amaçlı bir programlama dilidir. Python'un genel amaçlı olması nümerik analiz, veri bilimi ve makine öğrenmesi gibi 
    alanlarda da R ve Matlab'ten daha fazla tercih edilmesine yol açmıştır. (Matlab isimli dil ve ürün "Mathworks" isimli bir firmanın 
    mülkiyetindedir. Dolayısıyla ücretlidir. Tabii Matlab'in de çeşitli açık kaynak kodlu biçimleri zamanla oluşturulmuştur. R ise 
    açık kaynak kodlu bir dildir.) 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy kütüphanesi pip programıyla aşağıdaki gibi indirilip kurulabilir:

    pip install numpy

    Anaconda dağıtımında NumPy ve pek çok yaygın kütüphane zaten kurulum sırasında pakete dahil edilmektedir. Yani Anconda için NumPy'ı 
    indirip kurmamıza gerek yoktur. 

    Genellikle NumPy programcıları bu kütüphaneyi np ismiyle import etmektedir. Örneğin:

    import numpy as np

    Projenin ana web sayfası "numpy.org" biçimindedir. Orijinal dokümanlara aşağıdaki bağlantıdan erişilebilirsiniz:

    https://numpy.org/doc/

    Kütüphanenin API referansına da aşağıdaki bağlantıdan erişebilirsiniz:

    https://numpy.org/doc/stable/reference/index.html#reference
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Python'a vektörel işlem yapma yeteneği bir sınıf ile kazandırılabilir. Yani örneğin biz bir sınıf yazabiliriz. Bu sınıf için 
    __add__ gibi, __mul__ gibi operatör metotlarını bulundurabiliriz. Bu operatör metotları da listenin karşılıklı elemanlarını işleme 
    sokabilir. 

    Aşağıda bu fikrin uygulanmasına yönelik örnek bir kod bulunmaktadır. Ancak tamamen Python dünyasında kalarak bu tür vektörel 
    işlemleri yapan bir sınıf oluşturmak işlemlerin yavaş yapılmasına yol açacaktır. Oysa sayısal analiz işlemlerinde işlem yükü 
    oldukça fazla olduğu için bu tür vektörel işlemlerin mümkün olduğunca hızlı bir biçimde yapılması istenir. 
#------------------------------------------------------------------------------------------------------------------------------------

class ndarray:
    def __init__(self, array = None):
        if array:
            self.array = array
        else:
            self.array = []
        
    def __add__(self, nd):
        if isinstance(nd, int):
            new_nd = ndarray()            
            for i in range(len(self.array)):
                new_nd.array.append(self.array[i] + nd)
            return new_nd
            
        if len(self.array) != len(nd.array):
            raise ValueError('arrays are not the same size')

        new_nd = ndarray()            
        for i in range(len(self.array)):
            new_nd.array.append(self.array[i] + nd.array[i])
            
        return new_nd
    
    def __mul__(self, nd):
        if len(self.array) != len(nd.array):
            raise ValueError('arrays are not the same size')

        new_nd = ndarray()   
        for i in range(len(self.array)):
            new_nd.array.append(self.array[i] * nd.array[i])
                        
        return new_nd
    
    def __repr__(self):
        return str(self.array)    
        
x = ndarray([1, 2, 3, 4, 5])
y = ndarray([10, 20, 30, 40, 50])
z = ndarray([5, 2, 3, 1, 6])

k = (x + y) * z
print(k)

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy kütüphanesinin ana veri yapısı ndarray isimli sınıftır. Tıpkı yukarıdaki örnekte olduğu gibi ndarray isimli sınıfa pek çok 
    operatör metodu eklenmiş ve ndarray nesneleri vektörel işlem yapabilir hale getirilmiştir. Tabii NumPy'ın ndarray sınıfı ve diğer 
    global fonksiyonlar yukarıda da belirttiğimiz gibi C'de yazılmış durumdadır. Byunlar işlemcilrin özel SIMD komutlarını da kullanmaktadır. 
    NumPy kütüphanesinin ndarray sınıfının yetenekleri oldukça geniştir. Dolayısıyla NumPy kütüphanesini iyi bir biçimde öğrenmek için
    bu ndarray isimli sınıfın nasıl kullanıldığını öğrenmek gerekir. 

    NumPy kütüphanesi bazı bakımlardan eleştirilebilir. Bir işlemin çok değişik biçimlerde yapılabilmesi öğrenmeyi ve akılda tutmayı 
    zorlaştırmakta ve programcıları tereddüte sevk edebilmektedir. Kütüphanenin API tasarımı kanımızca daha iyi yapılabilirdi.

    Yukarıda da belirttiğimiz gibi NumPy'daki ana veri yapısı ndarray sınıfıdır. ndarray nesnelerine "NumPy dizisi (NumPy array)" de 
    denilmektedir. Biz de kursumuzda bazen "ndarray nesnesi" bazen de "NumPy dizisi" terimini kullanacağız.  
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Numpy'da ilk öğrenilecek şey ndarray nesnesinin (yani NumPy dizisinin) oluşturulmasıdır. Bunun çeşitli yolları vardır. NumPy dizisi
    oluşturmanın en temel yolu array isimli fonksiyonu kullanmaktadır. array fonksiyonu bir dolaşılabilir nesneyi alıp ondan bir 
    numpy dizisi (yani ndarray nesnesi) oluşturmaktadır. Örneğin biz bu fonksiyona parametre olarak bir Pyton listesi, bir Python demeti 
    ya da bir range nesnesi verebiliriz.Örneğin:

    a = np.array([10, 20, 30, 40, 50])
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([1, 2, 3, 4, 5])
print(a, type(a))

#------------------------------------------------------------------------------------------------------------------------------------
    Biz argüman olarak array fonksiyonuna dolaşılabilir nesnelerden oluşan dolaşılabilir nesneler verirsek array fonksiyonu bize 
    çok bıyutlu bir ndarray nesnesi verir. Tipik olarak çok boyutlu diziler Python'daki liste listeleri verilerek yaratılabilmektedir. 
    Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi Python'daki list, tuple, dict gibi veri yapıları aslında değerlerin kendisini tutmamaktadır. Değerlerin tutulduğu 
    nesnelerin adreslerini tutmaktadır. Bu biçimdeki çalışma yoğun sayısal işlemleri oldukça hantal hale gelmektedir. Bu nedenle NumPy 
    dizileri değerleri Python'un listeleri gibi değil C Programlama Dilindeki diziler gibi tutmaktadır. Örneğin:

    a = np.array([1, 2, 3, 4, 5])

    Burada a değişkenin gösteridiği NumPy dizisi tamamen C'deki gibi bir dizidir. Yani NumPy dizisinin elemanları dizi elemanlarına
    ilişkin nesnelerin adreslerini değil doğrudan değerlerin kendisini tutmaktadır. Bu nedenle NumPy dizileri (yani ndarray nesneleri) 
    birkaç istisna durum dışında homojendir. Yani NumPy dizilerinin elemanları genel olarak aynı türdendir. NumPy dizileri Python'daki 
    türler türünden elemanları değil C Programlama Dilindeki türler türünden elemanları tutarlar. Bir NumPy dizisinin tuttuğu elemanların 
    türlerine bu NumPy dizisinin dtype türü denilmektedir. Örneğin bir NumPy dizisinin dtype türü "float32" ise bu C'deki 32 bitlik 
    gerçek sayı türü olan "float" anlamına gelmektedir. Ya da örneğin bir NumPy dizisinin dtype türü "uint64" ise bu C'deki "unisgned 
    long long int" türüne karşılık gelmektedir.  C'de de veri türleri Python'dan çok daha çeşitlidir. İzleyen paragraflarda bir NumPy 
    dizisinin türlerinin neler olabileceğini listeleyeceğiz. 

    NumPy dizilerinin dtype bilgisi sınıfın dtype isimli örnek özniteliğinden elde edilebilir. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a.dtype
    dtype('int32')
    >>> b = np.array([1, 2.2, 4, 5.2, 7])
    >>> b.dtype
    dtype('float64') 

    Bir NumPy dizisinin dtype bilgisini elde ettiğimizde bu bilgi NumPy içerisindeki bir dtype sınıfı türünden olur. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([1, 2, 3.4, 4.7, 5])

print(a.dtype)

#------------------------------------------------------------------------------------------------------------------------------------
    array fonksiyonu ile bir NumPy dizisi yaratılırken eğer dtype belirtilmezse default durumda array fonksiyonu eğer tüm değerler 
    Python int türündense ve önce int32 sonra int64 türlerinden hangisi yeterliyse diziyi o dtype türünden yaratmaktadır. Ancak 
    değerlerden en az biri Python'un float türündense bu durumda diziyi float64 dtype türüyle yaratmaktadır. Örneğin:

    >>> a = np.array([1, 2, 3, 4, 5])
    >>> a.dtype
    dtype('int32')
    >>> a = np.array([3000000000, 2, 3, 4, 5])
    >>> a.dtype
    dtype('int64')
    >>> a = np.array([1, 2, 3., 4, 5])
    >>> a.dtype
    dtype('float64')
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    array fonksiyonuyla NumPy dizisi (ndarray nesnesi) yaratılırken yaratılacak NumPy dizisinin C'deki dtype türü array fonksiyonun 
    dtype parametresi ile açıkça belirlenebilir. array fonksiyonunun dtype parametresi string biçiminde girilebilir. Yukarıda da 
    belirtitğimiz gibi aslında her dtype türü NumPy içerisinde bir sınıfla temsil edilmiştir. dtype için doğrudan np.float32 gibi, 
    np.float64 gibi sınıf isimleri de kullanılabilir. Her ne kadar C'de float64 türü (yani double türü) yaygın kullanılıyorsa da pek 
    çok sayısal analiz uygulamalarında ve makine öğrenmesi uygulamalarında büyük diziler söz konusu olduğu için float32 dtype tercih 
    edilmektedir. Örneğin:

    >>> a = np.array([1, 2, 3, 4, 5], dtype='float64')
    >>> a
    array([1., 2., 3., 4., 5.])
    >>> a.dtype
    dtype('float64')
    >>> b = np.array([1, 2, 3, 4, 5], dtype=np.int8)
    >>> b
    array([1, 2, 3, 4, 5], dtype=int8)
    >>> b.dtype
    dtype('int8')
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2.3, 3], [4, 5, 6]], dtype='float32')
print(a, a.dtype)

import numpy as np

b = np.array([[1, 2.3, 3], [4, 5, 6]], dtype=np.float32)
print(b, b.dtype)

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy dizilerinde kullanabileceğimiz dtype türlerinin önemli olanları şunlardır: 

    bool_ /bool8 : bool türü
    byte / int8 : Bir byte'lık işaretli tamsayı türü
    ubyte / uint8 : Bir byte'lık işaretsiz tamsayı türü
    short / int16 : İki byte'lık işaretli tamsayı türü
    ushort / uint16: İki byte'lık işaretsiz tamsayı türü
    int : Platforma bağlı olarak dört byte ya da 8 byte'lık işaretli tamsayı türü.
    uint : Platforma bağlı olarak dört byte ya da 8 byte'lık işaretsiz tamsayı türü.
    int32 : Dört byte'lık işaretli tamsayı türü
    uint32 : Dört byte'lık işaretsiz tamsayı türü
    int64 : Sekiz byte2lık işaretli tamsayı türü
    uint64 : Sekiz byte'lık işaretsiz tamsayı türü
    float32 / single : Dört byte'lık gerçek sayı türü
    float64 / float / double : Sekiz byte'lık gerçek sayı türü
    str : Yazı turan tür
    object: Heterojen tür

    Diğer türler için Numpy dokümantasyonlarına başvurabilirsiniz. 

    NumPy'da çokça dtype türü olduğu halde en fazla kullanılan dtype türleri "float32", "float64", "int32" ve "uint8" türleridir. 
    NumPy default olarak noktalı sayılar için "float64" türünü, tamsayılar için "int32" türünü kullanmaktadır. Bir NumPy dizisi bu 
    türlerdense print edilirken genel olarak dtype türü gösterilmemektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisi ndarray sınıfının __init__ metoduyla da oluşturulabilir. Bu durumda oluşturulan NumPy dizisi çöp değerler (Yani 
    dizi için bellek alanında eskiden kalmış ratgele değerler) iöermektedir. __init__ metodunun birinci parametresi oluşturulacak NumPy 
    dizisinin boyutlarını bir demetle alır. (Tek boyut için demet kullanmaya gerek yoktur.) Yine yaratım sırasında dtype belirtilebilir. 
    Örneğin:

    Örneğin:

    >>> a = np.ndarray(10, dtype=np.int8)
    >>> a
    array([111,   0, 117,   0, 100,   0,  45,   0, 115,   0], dtype=int8)
    >>> b = np.ndarray((3, 3), dtype=np.int8)
    >>> b
    array([[114,   0, 111],
        [  0, 103,   0],
        [114,   0,  97]], dtype=int8)

    NumPy dizilerinin ndarray sınıfının __init__ metoduyla yaratılması pek tavsiye edilen bir yöntem değildir. 
#------------------------------------------------------------------------------------------------------------------------------------
    
import numpy as np

a = np.ndarray((3, 3), dtype='float32')     # a 3x3'lük çöp değerlerden oluşan bir numpy dizisi
print(a, a.dtype)

#------------------------------------------------------------------------------------------------------------------------------------
    İçi sıfırlarla dolu NumPy dizileri oluşturulabilir. Bunun için zeros fonksiyonu kullanılmaktadır. zeros fonksiyonun birinci parametresi
    yine Numpy dizisinin boyutlarını (shape) belirtir. Genel olarak yaratıcı fonksiyonlardaki boyut belirten shape parametresi bir demet 
    olarak girilir. Ancak demet yerine shape parametresi için int türden düz bir sayı sayı girlirse bu durumda tek boyutlu dizi yaratılır. 
    Örneğin:

    >>> a = np.zeros(10, dtype='int8')
    >>> a
    array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=int8)
    >>> b = np.zeros((10, 10), dtype=np.float32)
    >>> b
    array([[0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]], dtype=float32)
#------------------------------------------------------------------------------------------------------------------------------------
    
import numpy as np

a = np.zeros(10, dtype='int32')
print(a)

b = np.zeros((5, 5), dtype=np.float32)
print(b)

#------------------------------------------------------------------------------------------------------------------------------------
    ones isimli fonksiyon içi 1'lerle dolu bir NumPy dizisi oluşturmaktadır. Yine fonksiyonun birinci parametresi oluşturulacak dizinin 
    boyutlarını, dtype parametresi ise dtype türünü belirtir.  Örneğin:

    >>> a = np.ones(10, dtype='int32')
    >>> a
    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
#------------------------------------------------------------------------------------------------------------------------------------
    
import numpy as np

a = np.ones((3, 3), dtype='uint32')        # 3x3'lük uint32 türünden birlerle dolu dizi
print(a, a.dtype)

#------------------------------------------------------------------------------------------------------------------------------------
    full isimli fonksiyon NumPy dizisini bizim istediğimiz değerle doldurarak yaratır. (Yani zeros ve ones fonksiyonlarının genel 
    biçimidir.) Bu fonksiyonun yine birinci parametresi NumPy dizisinin boyutlarını, ikinci parametresi doldurulacak değerleri 
    belirtmektedir. Fonksiyonda yine dtype belirtilebilir. Örneğin:

    >>> a = np.full(10, 5, dtype='int8')
    >>> a
    array([5, 5, 5, 5, 5, 5, 5, 5, 5, 5], dtype=int8)
    >>> b = np.full((5, 5), 1.2, dtype='float32')
    >>> b
    array([[1.2, 1.2, 1.2, 1.2, 1.2],
        [1.2, 1.2, 1.2, 1.2, 1.2],
        [1.2, 1.2, 1.2, 1.2, 1.2],
        [1.2, 1.2, 1.2, 1.2, 1.2],
        [1.2, 1.2, 1.2, 1.2, 1.2]], dtype=float32)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.full((3, 3), 10, dtype=np.float32)

print(a, a.dtype)

#------------------------------------------------------------------------------------------------------------------------------------
    empty isimli fonksiyon içi herhangi bir biçimde doldurulmamış olan çöp değerlerden oluşan NumPy dizisi oluşturmaktadır. Zaten 
    yukarıda da belirttiğimiz gibi ndarray sınıfı türünden nesne yaratırken de aynı biçimde çöp değerlerden oluşan MumPy dizisi 
    yaratılabiliyordu. Bazen programcı bir NumPy dizisi oluşturup onun içini doldurabilmektedir. İşte bu tür durumlarda zeros gibi 
    bir fonksiyonunun sıfırlama sırasında zaman kaybetmesi istenmeyebilir. Ancak tabii bu tür zaman kayıpları genel olarak Python 
    dünyasında önemli kabul edilmemektedir. Örneğin:

    a = np.empty(10, dtype=np.int32)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.empty(10, dtype='uint8')

print(a, a.dtype)

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda görmüş olduğumuz fonksiyonların _like son ekli biçimleri de vardır. Yani zeros_like, ones_like, empty_like, full_like 
    gibi. Bu fonksiyonlar parametre olarak bir NumPy dizisini alır. Yaratılacak NumPy dizisinin boyutlarını ve dtype özelliğini 
    parametresiyle aldığı dizideki gibi yapar. Örneğin elimizde 2x4'lük float32 değerlerinden oluşan bir NumPy dizisi olsun. Biz de 
    zeros_like fonksiyonu ile 2x4'lük float32 değerlerine sahip ancak içi 0'lardan oluşan bir numpy dizisi yaratmak isteyebiliriz:

    >>> a = np.array([[1, 2, 3, 4], [5, 6, 7, 8]], dtype='float32')
    >>> b = np.zeros_like(a)
    >>> b
    array([[0., 0., 0., 0.],
        [0., 0., 0., 0.]], dtype=float32)

    Bu _like sonekli fonksiyonlarda biz dtype da belirtebiliriz. Bu durumda oluşturulacak NumPy dizisinin dtype özelliği diziden değil 
    bizim belirttiğimiz türden olur. Örneğin:

    >>> a = np.array([[1, 2, 3, 4], [5, 6, 7, 8]], dtype='float32')
    >>> b = np.zeros_like(a, dtype='float64')
    >>> b
    array([[0., 0., 0., 0.],
        [0., 0., 0., 0.]])
    >>> b.dtype
    dtype('float64')    
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6]], dtype=np.float32)

print(a, a.dtype)

b = np.zeros_like(a)
print(b, b.dtype)

#------------------------------------------------------------------------------------------------------------------------------------
    Rastgele değerlerden NumPy dizisi oluşturabilmek için numpy.random modülünde çeşitli fonksiyonlar bulundurulmuştur. Örneğin 
    numpy.random.random fonksiyonu belli bir boyutta 0 ile 1 arasında rastgele gerçek sayı değerleri oluşturmaktadır. Bu fonksiyon 
    dtype parametresine sahip değildir. Her zaman float64 olarak NumPy dizisini yaratmaktadır. Fonksiyonun boyut belirten bir parametresi 
    vardır. Örneğin:

    >>> a = np.random.random((5, 5))
    >>> a
    array([[0.82089125, 0.08025651, 0.73226155, 0.06222221, 0.12049264],
        [0.43171059, 0.45946347, 0.2128061 , 0.5012849 , 0.82467442],
        [0.90062584, 0.82899044, 0.14757077, 0.82961189, 0.67917696],
        [0.60761068, 0.60724418, 0.69019941, 0.73556308, 0.25155426],
        [0.4610114 , 0.25969294, 0.09778555, 0.54427295, 0.9985059 ]])
#------------------------------------------------------------------------------------------------------------------------------------

a = np.random.random((3, 3))
print(a)  

#------------------------------------------------------------------------------------------------------------------------------------
    numpy.random.randint fonksiyonu [low, high) aralığında rastgele tamsayı değerlerinden oluşan NumPy dizisi yaratmaktadır. Bu 
    fonksiyonun üçüncü parametresi yaratılacak NumPy dizisinin boyutunu almakatdır. Bu parametre girilmezse tek bir değer üretilmektedir. 
    Örneğin:

    >>> a = np.random.randint(10, 20, (5, 5), dtype='int8')
    >>> a
    array([[11, 18, 10, 18, 13],
        [16, 15, 12, 18, 12],
        [14, 11, 12, 17, 18],
        [10, 18, 18, 14, 19],
        [10, 16, 17, 14, 14]], dtype=int8)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.random.randint(0, 10, (3, 3), dtype='int32')
print(a)

#------------------------------------------------------------------------------------------------------------------------------------
    arange fonksiyonu Python'un built-in range fonksiyonuna oldukça benzemektedir. Ancak arange bize dolaşılabilir bir nesne vermez. 
    Doğrudan bir NumPy dizisi verir. start, stop, step parametreleri range fonksiyonunda olduğu gibidir. Python'un range fonksiyonundaki 
    start, stop ve step değerlerinin int türünden olması gerektiğini anımsayınız. Halbuki NumPy'daki arange fonksiyonunda parametreler
    float türünden de (yani noktalı sayılar da) olabilir. Böylelikle biz arange ile noktasal artırımlarla bir NumPy dizisi oluşturabiliriz.
    arange fonksiyonu dtype parametresi de alabilmektedir. Ancak bu fonksiyon her zaman tek boyutlu bir diziyi bize verir. Örneğin:

    >>> a = np.arange(-1, 1, 0.1)
    >>> a
    array([-1.00000000e+00, -9.00000000e-01, -8.00000000e-01, -7.00000000e-01,
        -6.00000000e-01, -5.00000000e-01, -4.00000000e-01, -3.00000000e-01,
        -2.00000000e-01, -1.00000000e-01, -2.22044605e-16,  1.00000000e-01,
         2.00000000e-01,  3.00000000e-01,  4.00000000e-01,  5.00000000e-01,
         6.00000000e-01,  7.00000000e-01,  8.00000000e-01,  9.00000000e-01])
    >>> b
        array([0.       , 1.1      , 2.2      , 3.3000002, 4.4      , 5.5      ,
       6.6000004, 7.7000003, 8.8      , 9.900001 ], dtype=float32)

    Fonksiyonda dtype belirtilmezse eğer start, stop, step tamsayı türlerindense default dtype türü np.int32, bunlardan biri float 
    türündense default dtype np.float64 alınmaktadır.

    arange fonksiyonunu kullanırken dikkat etmek gerekir. Çünkü noktasal artırımlar, noktasal start ve stop değerleri yuvarlama 
    hatalarından dolayı beklenenden fazla ya da az sayıda eleman üretebilir. (Örneğin 0.1 artırımlarla ilerleken yuvarlama hatasından 
    dolayı stop değerine çok yakın ama ondan küçük bir değer oluşabilir ve bu değer de dizi içinde bulunabilir.) Zaten Python'daki 
    built-in range sınıfının tamsayı değerler almasının nedeni de budur. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.arange(0, 100, 2, dtype='float32')
print(a)

a = np.arange(0, 0.8, 0.1, dtype='float32')
print(a)

#------------------------------------------------------------------------------------------------------------------------------------
    arange fonksiyonun yukarıda belirtilen probleminden dolayı noktasal artırım için genellikle programcılar linspace fonksiyonunu
    tercih ederler. Bu fonksiyon start, stop ve num parametrelerine sahiptir. Fonksiyon her zaman start ve stop değerlerini de içerecek 
    biçimde eşit aralıklı num tane değeri oluşturarak onu bir NumPy dizisi olarak vermektedir. linspace ile elde edilecek eleman sayısı 
    belli olduğu için arange fonksiyonu yerine genellikle programcılar bunu tercih etmektedir. linspace fonksiyonun dtype parametresi 
    de vardır. Bu parametre için argüman girilmezse default dtype türü np.float64 olarak alınmaktadır.  Örneğin:

    >>> a = np.linspace(0, 10, 10)
    >>> a
    array([ 0.        ,  1.11111111,  2.22222222,  3.33333333,  4.44444444,
            5.55555556,  6.66666667,  7.77777778,  8.88888889, 10.        ])
    >>> a = np.linspace(0, 10, 11)
    >>> a
    array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.])
    >>> a = np.linspace(0, 1, 20, dtype='float32')
    >>> a
    array([0.        , 0.05263158, 0.10526316, 0.15789473, 0.21052632,
        0.2631579 , 0.31578946, 0.36842105, 0.42105263, 0.47368422,
        0.5263158 , 0.57894737, 0.6315789 , 0.68421054, 0.7368421 ,
        0.7894737 , 0.84210527, 0.8947368 , 0.94736844, 1.        ],
        dtype=float32)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.linspace(0, 10, 5)
print(a)

a = np.linspace(0, 10, 20, dtype='float32')
print(a)

#------------------------------------------------------------------------------------------------------------------------------------
    Burada özellikle linspace(0, 5, 5) gibi çağrıdan [0, 1, 2, 3, 4, 5] değerlerinin elde edilmeyeceğine dikkat ediniz. Eğer bu 
    değerler elde edilmek isteniyorsa bu durumda num parametresi 6 olarak girilmelidir.  Örneğin:

    >>> a = np.linspace(0, 5, 5)
    >>> a
    array([0.  , 1.25, 2.5 , 3.75, 5.  ])
    >>> a = np.linspace(0, 5, 6)
    >>> a
    array([0., 1., 2., 3., 4., 5.])
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.linspace(0, 5, 5)
print(a)

a = np.linspace(0, 5, 6)
print(a)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisinin boyutlarını (yani kaça kaçlık olduğunu) nesnenin shape isimli özniteliği ile elde edebiliriz. shape özniteliği 
    bize boyutları belirten bir demet vermektedir. Örneğin:

    >>> a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
    >>> a
    array([[ 1,  2,  3,  4],
        [ 5,  6,  7,  8],
        [ 9, 10, 11, 12]])
    >>> a.shape
    (3, 4)
    >>> a.shape[0]
    3
    >>> a.shape[1]
    4

    Bir NumPy dizisinin kaç boyutlu olduğu bilgisini nesnenin dmim özniteliğindne elde edebiliriz. Örneğin:

    >>> a = np.random.random((3, 5, 7))
    >>> a.ndim
    3

    Tabii aslında a.ndim ile len(a.shape) aynı değeri vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6]], dtype=np.float32)

print(a.shape)
print(a.shape[0], a.shape[1])

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisine len fonksiyonunu uygularsak o bize en dıştaki boyutu verir. Örneğin:

    >>> a = np.random.random((3, 5, 7))
    >>> len(a)
    3

    Dizideki toplam eleman sayısı nesnenin size özniteliği ile elde edilmektedir. Örneğin:

    >>> a.size
    105
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy'da belli bir işi yapmanın birden fazla yöntemi olabilmektedir. Örneğin bazı işlemler doğrudan ndarray sınıfının metotlarıyla,
    bazı işlemler ise numpy modülündeki fonksiyonlarla yapılabilmektedir. NumPy'da belki bir tasarım kusuru olarak şöyle üç durum 
    söz konusudur:

    - Bazı ndarray metotlarının aynı isimli np modülünde global fonksiyon karşılıkları vardır.
    - Bazı ndarray metotlarının aynı isimli np moüdlünde global fonksiyon karşılıkları yoktur.
    - Bazı global fonksiyonların ise ndarray sınıfında bir metot karşılıkları yokturç
    
    Örneğin a bir ndarray nesnesi foo da yapılacak işlemi belirten bir isim olsun biz bu işlemi ndarray sınıfının foo metoduyla şöyle 
    yapabiliriz:

    a.foo(...)

    Ancak aynı işlem foo isimli global fonksiyonla da yapılabilmektedir:

    np.foo(a, ...)

    İki kullanım biçimi arasındaki farka dikkat ediniz. a.foo(...) çağrısında zaten foo a nesnesi üzerinde işlem yapacaktır. (Buradaki 
    a nesnesinin foo metoduna self parametresi olarak aktarılacağına dikkat ediniz.) Ancak np.foo fonksiyonu işlem yapacağı nesneyi 
    bizden parametre olarak almaktadır. Ancak her türlü işlem için hem ndarray sınıfında bir metot hem de global bir fonksiyon 
    bulunmamaktadır. Bazı işlemler için yalnızca numpy modülünde fonksiyon bulundurulmuştur. Bunların bir metot karşılığı yoktur. 
    Bazı işlemler için de yalnızca ndarray içerisinde metot bulundurulmuştur. Bunların da fonksiyon karşılıkları yoktur. Bazı işlemler 
    için de yukarıda belirttiğimiz gibi hem metotlar hem de fonksiyonlar bulunmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisinin boyutları değiştirilebilir. Bunun için ndarray sınıfının reshape metodu ya da reshape fonksiyonu kullanılabilmektedir.
    Metot da fonksiyon da orijinal dizinin shape özelliğini değiştirmez bize belirlediğimiz shape türünden yeni bir "view" nesnesi 
    verir. Default durumda ndarray elemanları C Programlama Dilindeki gibi satırsal biçimde belleğe tek boyutlu olarak yerleştirilmektedir.
    reshape işlemi de bellekteki duruma göre yapılmaktadır. Örneğin aşağıdaki gibi bir NumPy dizisi bulunuyor olsun:

    1 2 3 4 
    5 6 7 8 

    Bu dizi aslında C'de bellekte zaten tek boyutlu biçimde aşağıdaki gibi tutulmaktadır:

    1 2 3 4 5 6 7 8 
    
    Şimdi biz bu diziyi 4x2 olarak reshape yaparsak dizi şu hale gelir:

    1 2
    3 4
    5 6
    7 8

    Yani reshape işlemini şöyle düşünmelisiniz: Sanki önce çok boyutlu dizi tek boyuta dönüştürülüp, yeniden yeni boyuta dönüştürülmektedir. 
    reshape işleminden yeni bir kopya elde edilmemektedir. Aynı dizinin yeni bir görüntüsü yani bir "view" nesnesi elde edilmektedir. 

    >>> a = np.random.randint(0, 100, (5, 4))
    >>> a
    array([[27, 32, 69,  5],
        [92, 69, 31, 16],
        [60, 97, 25, 72],
        [72, 53, 82, 14],
        [20, 84, 67, 23]])
    >>> b = a.reshape(2, 10)
    >>> b
    array([[27, 32, 69,  5, 92, 69, 31, 16, 60, 97],
        [25, 72, 72, 53, 82, 14, 20, 84, 67, 23]])
    >>> c = np.reshape(a, (4, 5))
    >>> c
    array([[27, 32, 69,  5, 92],
        [69, 31, 16, 60, 97],
        [25, 72, 72, 53, 82],
        [14, 20, 84, 67, 23]])

    reshape işleminin yeni bir dizi yaratmadığına dikkat ediniz. Aslında reshape edilmemiş dizi ile reshape edilmiş dizi aynı dizidir. 
    Örneğin:

    >>> a = np.arange(20)
    >>> b = a.reshape(5, 4)
    >>> a
    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19])
    >>> b
    array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11],
        [12, 13, 14, 15],
        [16, 17, 18, 19]])
    >>> b[1, 1] = 1000
    >>> a
    array([   0,    1,    2,    3,    4, 1000,    6,    7,    8,    9,   10,
            11,   12,   13,   14,   15,   16,   17,   18,   19])

    reshape metodunu kullanırken boyutlar demet olarak verilmek zorunda değildir. Ancak demet olarak da (aslında dolaşılabilir bir 
    nesne olarak da) verilebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2, 3, 4], [5, 6, 7, 8]], dtype=np.float32)

print(a)

result = a.reshape((4, 2))
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtitğimiz gibi reshape metodu ya da reshape fonksiyonu bize bir "view" nesnesi vermektedir. Python'da "view" nesnesi 
    demekle "asıl verilere referans eden nesneler" anlaşılmaktadır. Yani bir view nesnesi üzerinde değişiklik yapılırsa aslında 
    değişiklik asıl nesne üzerinde yapılmış olur, ana nesne üzerinde değişiklik yapılırsa bunddan "view" nesnesi de etkilenir. 
    Örneğin:

    >>> a = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
    >>> a
    array([[ 1,  2,  3,  4],
        [ 5,  6,  7,  8],
        [ 9, 10, 11, 12]])
    >>> b = a.reshape(4, 3)
    >>> b
    array([[ 1,  2,  3],
        [ 4,  5,  6],
        [ 7,  8,  9],
        [10, 11, 12]])
    >>> a[0, 0] = 100
    >>> b
    array([[100,   2,   3],
        [  4,   5,   6],
        [  7,   8,   9],
        [ 10,  11,  12]])
    >>> b[1, 2] = 200
    >>> a
    array([[100,   2,   3,   4],
        [  5, 200,   7,   8],
        [  9,  10,  11,  12]])

    reshape işleminde yeniden boyutlandırma yapılırken orijinal eleman sayısı elde edilmelidir. Örneğin elimizde 5x4'lük bir NumPy 
    dizisi olsun. Biz bu diziyi 2x10'luk hale getirebiliriz. 1x20'lik hale de getirebiliriz. Ancak 3x6'lık hale getiremeyiz. Örneğin:

    >>> a = np.random.randint(0, 100, (5, 4))
    >>> a
    array([[53, 80, 87, 24],
        [35, 48, 36, 57],
        [18, 83, 54, 69],
        [51,  4, 73, 98],
        [70, 37, 61, 93]])
    >>> b = a.reshape(3, 6)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    ValueError: cannot reshape array of size 20 into shape (3,6)

    reshape metodunda ve fonksiyonunda argüman bir demet olarak (aslında dolaşılabilir nesne olarak) girilmeyip tek bir int değer 
    girilirse bu durumda dizi tek boyuta dönüştürülür. Örneğin:

    >>> a = np.random.randint(0, 100, (5, 4))
    >>> a
    array([[52, 93, 89, 94],
        [32,  0, 88, 76],
        [54, 75, 81, 37],
        [28, 61, 49, 38],
        [ 4, 64, 90, 72]])
    >>> b = a.reshape(20)
    >>> b
    array([52, 93, 89, 94, 32,  0, 88, 76, 54, 75, 81, 37, 28, 61, 49, 38,  4,
        64, 90, 72])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy metotları ve fonksiyonlarının zincir (chain) oluşturacak biçimde kullanılmasıyla sık karşılaşılmaktadır. Örneğin:

    >>> a = np.arange(20).reshape(5, 4)
    >>> a
    array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11],
        [12, 13, 14, 15],
        [16, 17, 18, 19]])

    Burada arange fonksiyonu ile verilen NumPy dizisi o dizi üzerinde doğrudan reshape metodu çağrılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    reshape fonksiyonunda ya da metodunda argümanlardan yalnızca biri -1 olarak girilebilir. Bu durumda bu argümanın değeri dizinin 
    boyutlarına göre otomatik biçimde belirlenir. Örneğin:

    >>> a = np.random.randint(0, 100, (5, 4))
    >>> a
    array([[47, 95, 52, 91],
        [12, 41, 34, 45],
        [69, 15, 47, 33],
        [37, 28,  0, 56],
        [99, 29, 85, 74]])

    Burada 5x4'lük bir NumPy dizisi oluşturulmuştur. Biz bu diziyi aşağıdaki gibi reshape etmek isteyelim:

    >>> b = a.reshape(10, -1)

    Burada -1 yerine gelebilecek tek uygun değer 2'dir. O halde buraya 2 yazılmış olduğu varsayılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında reshape işlemi asıl dizi üzerinde (yani "in-place" biçimde) de onun shape örnek özniteliğine yeni bir demet atayarak da 
    yapılabilmektedir. Burada atanan değerin bdolaşılabilir bir nesne olması gerekir. Örneğin:

    >>> a = np.random.randint(0, 100, (5, 4))
    >>> a
    array([[89, 31, 87, 92],
        [ 3, 59, 49, 73],
        [85, 57, 31, 90],
        [62, 66, 53, 10],
        [45, 12, 21, 87]])
    >>> a.shape = (2, 10)
    >>> a
    array([[89, 31, 87, 92,  3, 59, 49, 73, 85, 57],
        [31, 90, 62, 66, 53, 10, 45, 12, 21, 87]])
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2, 3, 4], [5, 6, 7, 8]], dtype=np.float32)

print(a)
a.shape = (4, 2)
print(a)

#------------------------------------------------------------------------------------------------------------------------------------
    Çok boyutlu dizilerin tek boyutlu hale getirilmesi sık gereksinim duyulan bir işlemlerdendir. Örneğin elimizde 5x4'lük bir NumPy 
    dizisi olsun. Biz de bunu tek boyutlu bir dizi haline getirmeye çalışalım. Tabii bu işlemi reshape metoduyla ya da fonksiyonuyla 
    yapabiliriz. Örneğin:

    >> a = np.random.randint(0, 100, (5, 4))
    >>> a
    array([[39, 48, 33, 13],
        [95, 61, 38, 51],
        [27, 28, 26, 56],
        [32, 29, 55, 16],
        [12, 29, 34, 62]])

    >>> b = a.reshape(20)
    >>> b
    array([39,  48,  33,  13,  95,  61,  38,  51,  27,  28,  26,  56,  32,
        29,  55,  16,  12,  29,  34,  62])

    Ancak bu işlem için ravel isimli bir metot ve aynı isimli global bir fonksiyon da bulundurulmuştur. ravel bize reshape işleminde 
    olduğu gibi bir view nesnesi vermektedir. Örneğin:

    >>> b = a.ravel()
    >>> b
    array([39, 48, 33, 13, 95, 61, 38, 51, 27, 28, 26, 56, 32, 29, 55, 16, 12,
        29, 34, 62])
    >>> b[0] = 100
    >>> a
    array([[100,  48,  33,  13],
        [ 95,  61,  38,  51],
        [ 27,  28,  26,  56],
        [ 32,  29,  55,  16],
        [ 12,  29,  34,  62]])

    Aynı işlem flatten isimli metot ya da fonksiyonla da yapılabilmektedir. Ancak flatten metodu ya da fonksiyonu bir view nesnesi 
    vermez. Gerçek nesnenin bir kopyasını vermektedir. Örneğin:

    >>> a = np.random.randint(0, 100, (5, 4))
    >>> a
    array([[11, 90, 36,  4],
        [22, 26,  8, 48],
        [35, 79, 50, 18],
        [25, 52, 94, 26],
        [36, 83, 90, 21]])
    >>> b = a.flatten()
    >>> b
    array([11, 90, 36,  4, 22, 26,  8, 48, 35, 79, 50, 18, 25, 52, 94, 26, 36,
        83, 90, 21])
    >>> b[0] = 100
    >>> a
    array([[11, 90, 36,  4],
        [22, 26,  8, 48],
        [35, 79, 50, 18],
        [25, 52, 94, 26],
        [36, 83, 90, 21]])
    >>> a[0, 0] = 200
    >>> b
    array([100,  90,  36,   4,  22,  26,   8,  48,  35,  79,  50,  18,  25,
            52,  94,  26,  36,  83,  90,  21])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisi tek boyutlu ya da çok boyutlu olabilir. Hatta boyutsuz NumPy dizileri de söz konusu olabilir. Ancak bu durumda 
    dizi tek bir eleman içerebilir. Yani tek bir değer sanki bir dizi değil de bağımısz tek bir değer gibi ndarray nesnesi biçiminde 
    de ifade edilebilmektedir. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> a.shape
    (3, 3)
    >>> b = np.array([1, 2, 3, 4, 5])
    >>> b
    array([1, 2, 3, 4, 5])
    >>> b.shape
    (5,)
    >>> c = np.array(123)
    >>> c
    array(123)
    >>> c.shape
    ()
    >>> c.ndim
    0
    >>> type(c)
    <class 'numpy.ndarray'>

    Tek bir değerden oluşan ndarray nesnelerinin boyutunun olmadığına dikkat ediniz. Biz böyle NumPy dizilerine "boyutsuz NumPy dizileri"
    diyeceğiz. Bu tür durumlarda dizi içerisindeki değer item metodu ile, tür dönüştürmesi ile ya da [()] ifadesi ile elde edilebilir. 
    Örneğin:

    >>> a = np.array(100)
    >>> a
    array(100)
    >>> int(a)
    100
    >>> a[()]
    100
    >>> a.item()
    100

    item metodu yalnızca tek elemana sahip NumPy dizilerinde ya da boyutsuz değer içeren NumPy dizilerinde kullanılabilir.
    Bu metodun global bir fonksiyon karşılığı yoktur.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                        44. Ders 24/08/2025 – Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisi ndarray sınıfının tolist metodu ile Python listesine de dönüştürülebilir. Örneğin:

    >>> a = np.arange(20).reshape(5, 4)
    >>> a
    array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11],
        [12, 13, 14, 15],
        [16, 17, 18, 19]])
    >>> b = a.tolist()
    >>> b
    [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19]]
    >>> a = np.random.random((2, 3))
    >>> a
    array([[0.89825016, 0.64433664, 0.07580248],                
        [0.62594548, 0.48109102, 0.08182892]])
    >>> b = a.tolist()
    >>> b
    [[0.8982501574859335, 0.644336642866961, 0.07580248213618257], [0.6259454839761603, 0.4810910207754172, 0.08182892407036302]]

    Tabii aslında zaten list sınıfının __init__ metoduna biz dolaşılabilir bir nesne verdiğimizde metot onu dolaşarak ondan 
    list nesnesi oluşturabilmektedir. Bu durumda a bir NumPy dizisi belirtmek üzere a.tolist() işlemi ile list(a) işlemi arasında 
    işlevsel bir fark yoktur. 

    Python'daki range fonksiyonu ile biz noktalı artırımlar oluşturamıyorduk. Noktalı artırımlarla Python listesini arange 
    fonksiyonu ile şöyle elde edebiliriz:

    >>> a = np.arange(0, 1, 0.1).tolist()
    >>> a
    [0.0, 0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9]
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[4, 2, 3], [7, 1, 9], [5, 10, 6]], dtype='float32')

b = a.tolist()
print(b, type(b))       # [[4.0, 2.0, 3.0], [7.0, 1.0, 9.0], [5.0, 10.0, 6.0]] <class 'list'>

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Numpy dizisinin elemanlarına [] operatörüyle erişilebilmektedir. Eğer dizi çok boyutluysa erişim köşeli parantez içerisinde 
    her boyut için virgüllerle ayrılmış indeks belirtilerek yapılmaktadır. Örneğin:

    >>> a = np.arange(20).reshape((5, 4))
    >>> a
    array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11],
        [12, 13, 14, 15],
        [16, 17, 18, 19]])
    >>> a[2, 3]
    11
    >>> a[0, 0]
    0

    Tabii elemana erişirken boyut dikkate alındığında sınır dışına çıkılıyorsa IndexError exception'ı oluşmaktadır. Örneğin:

    >>> a = np.arange(20).reshape((5, 4))
    >>> a
    array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11],
        [12, 13, 14, 15],
        [16, 17, 18, 19]])
    >>> a[2, 3]
    11
    >>> a[0, 0]
    0

    Erişim işleminde tıpkı Python listelerinde olduğu gibi negatif indeksler de kullanılabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy dizileri değiştirilebilir (mutable) nesnelerdir. Biz bir NumPy dizisinin belli bir elemanını değiştirebiliriz.  Örneğin:

    >>> a = np.arange(20).reshape((5, 4))
    >>> a
    array([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11],
        [12, 13, 14, 15],
        [16, 17, 18, 19]])
    >>> a[2, 3] = 100
    >>> a
    array([[  0,   1,   2,   3],
        [  4,   5,   6,   7],
        [  8,   9,  10, 100],
        [ 12,  13,  14,  15],
        [ 16,  17,  18,  19]])

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Köşeli parantez operatörü ile elemana erişirken n boyutlu bir NumPy dizisinde köşeli parantez içerisine k < n biçiminde k tane 
    index girilebilir. Bu durumda geri kalan elemanlar bir NumPy dizisi olarak elde edilecektir. Örneğin 3x3'lük bir a dizimiz olsun. 
    Biz de erişimi a[1] biçiminde yaparsak a dizisinin 1'inci indeksli satırınaki tüm değerleri NumPy dizisi olarak bir view nesnesi 
    biçiminde elde ederiz. Örneğin:

    >>> a = np.arange(9).reshape(3, 3)
    >>> a
    array([[0, 1, 2],
        [3, 4, 5],
        [6, 7, 8]])
    >>> a[1]
    array([3, 4, 5])

    Başka bir deyişle biz n boyutlu bir NumPy dizisinin elemanına erişirken k < n tane indeks verebiliriz. Bu durumda diğer boyutların 
    tüm elemanları elde edilmektedir. Örneğin:

   >>> a = np.arange(27).reshape(3, 3, 3)
    >>> a
    array([[[ 0,  1,  2],
            [ 3,  4,  5],
            [ 6,  7,  8]],

        [[ 9, 10, 11],
            [12, 13, 14],
            [15, 16, 17]],

        [[18, 19, 20],
            [21, 22, 23],
            [24, 25, 26]]])
    >>> a[1]
    array([[ 9, 10, 11],
        [12, 13, 14],
        [15, 16, 17]])
    >>> a[1, 2]
    array([15, 16, 17])
    >>> a[1, 2, 2]
    17

    Bu örnekte biz 3x3x3'lük bir NumPy dizisi oluşturduk. Biz bu diziyi "her biri 3x3'lük olan 3 elemanı bir dizi" gibi düşüneneliriz.
    Buradaki a[1] erişimi aslında 3 elemanlı 3x3'lük dizinin 1'inci indeksli dizisi anlamına gelmektedir. a[1, 2] erişimi ise 3x3'lük 
    3 tane dizinin 1'inci indeksteki dizisinin 2'inci indeksteki satırı anlamına gelmektedir. Tabii bu erişimlerin hepsi bize birer 
    view nesnesi vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.arange(27).reshape((3, 3, 3))
print(a)

b = a[1]
print(b)

c = a[1, 2]
print(c)

d = a[1, 2, 2]
print(d)

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy dizileri üzerinde dilimleme (slicing) yapılabilir. Dilimleme işleminde tamamen Python listelerindeki semantik uygulanmaktadır. 
    Dilimleme her boyut için ayrı ayrı yapılabilmektedir. Dilimleme işleminden yeni bir NumPy dizisi view nesnesi olarak elde edilmektedir. 
    Dilimleme ilk boyuttan başlanarak boyut boyut gerçekleştirilmektedir. Örneğin a dizisi 10x10'luk boyutunda olsun:
    
    >>> a = np.arange(100).reshape((10, 10))
    >>> a
    array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14, 15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
        [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],
        [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
        [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],
        [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],
        [70, 71, 72, 73, 74, 75, 76, 77, 78, 79],
        [80, 81, 82, 83, 84, 85, 86, 87, 88, 89],
        [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]])
 
    Biz burada  a[2:5, 4:7] dilimlemesi yapmak isteyelim. Bu işlem NumPy tarafından şöyle yürütülmektedir:

    1) Önce a[2], a[3] ve a[4] satırları elde edilir:

     20, 21, 22, 23, 24, 25, 26, 27, 28, 29
     30, 31, 32, 33, 34, 35, 36, 37, 38, 39
     40, 41, 42, 43, 44, 45, 46, 47, 48, 49

    2) Sonra bu elde edilen satırlardan 4, 5 ve 6 indeksle sütunlar elde edilir:

    24, 25, 26
    34, 35, 36
    44, 45, 46

    Şimdi bu işlemi komut satırında gerçekleştirelim:

    >>> a[2:5, 4:7]
    array([[24, 25, 26],
        [34, 35, 36],
        [44, 45, 46]])

    Dilimleme işleminde aynı boyutta bir dizi elde edildiğine dikkat ediniz. 

    Şimdi tersten gidelim. Elimizde 3x3x3'lük üç boyutlu bir NumPy dizisi olsun:

    >>> a = np.arange(27).reshape((3, 3, 3))
    >>> a
    array([[[ 0,  1,  2],
            [ 3,  4,  5],
            [ 6,  7,  8]],

        [[ 9, 10, 11],
            [12, 13, 14],
            [15, 16, 17]],

        [[18, 19, 20],
            [21, 22, 23],
            [24, 25, 26]]])

    Biz bu diziden aşağıdaki kısmı elde etmek isteyelim:

    19, 20
    22, 23
    
    Burada önce bizim son diziyi elde etmemiz gerekir:

    >>> a[2:3]
    array([[[18, 19, 20],
            [21, 22, 23],
            [24, 25, 26]]]),

    Sonra bu dizi içerisindeki 0'ınci ve 1'inci satırları elde etmemiz gerekir:

    >>> a[2:3, 0:2]
    array([[[18, 19, 20],
            [21, 22, 23]]])

    Nihayet buradaki 1'inci ve 2'inci sütunları elde etmemiz gerekir:

    >>> a[2:3, 0:2, 1:3]
    array([[[19, 20],
            [22, 23]]])

    Burada biz yine üç boyutlu bir dizi elde ettik. Eğer bunu iki boyuta indirgemek istiyorsak reshape yapmamız gerekir. 
    Örneğin:

    >>> a[2:3, 0:2, 1:3].reshape((2, 2))
    array([[19, 20],
        [22, 23]])

    
    Dilimleme işleminde Python listelerinde oldupu gibi negatif indeksler de kullanılabilmektedir. 

    Aşağıdaki örnekte 4X5'lik bir NumPy dizisinde satır ve sütun üzerinde ayrı ayrı dilimleme yapılarak bu NumPy dizisinden bir alt 
    dizi elde edilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]], dtype=np.float32)

print(a)

b = a[1:3, 1:3]
print(b)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir resim aslında pixel'lerden oluşmaktadır. Resim eğer renkli ise her pixel RGB biçiminde üç ayrı byte'tan oluşur. Ancak ".png"
    formatına ilişkin resimlerin her pixel'i transparanlık bilgisini de içerdiği için dört byte'tan oluşmaktadır. Eğer elimizde 
    ".jpg" gibi, ".bmp" gibi, ".png" gibi bir resim dosyası varsa o resmin pixel'lerini bir NumPy dizisi biçiminde elde etmenin 
    birkaç yolu vardır. (Bu dosyaları open fonksiyonuyla açıp okumaya çalışmayınız. Çünkü bu dosyaların ieçrisinde başka birtakım 
    metadata bilgileri de vardır.) Kurusumuzda izleyen bölümlerde göreceğimiz Matplotlib kütüphanesindeki imread isimli fonksiyon 
    resim dosyasının yol ifadesini alarak onun pixel'lerini bize NumPy dizisi biçiminde vermektedir. Örneğin:

    from matplotlib.pyplot import imread

    data = imread('AbbeyRoad.jpg')

    Burada data 3 boyutlu bir NumPy dizisidir. Biz data[x, y] biçiminde bir erişim yaparsak resmin RGB bilgilerine ilişkin 3 elemanlı 
    bir NumPy dizisi elde ederiz. Aslında aynı işlem "Python Image Library (PIL ya da PILLOW)" denilen bir kütüphane ile de yapılabilmektedir:

    from PIL import Image

    image = Image.open('AbbeyRoad.jpg')
    data = np.array(image)

    Peki elimizde RGB renklerine ilişkin pixel'lerden oluşan bir NumPy dizisi varsa bu resmi nasıl çizdirebiliriz? Bunun da birkaç 
    yolu vardır. Örneğin bu işlem Matplotlib kütüphanesindeki imshow fonksiyonu ile yapılabilir:

    from matplotlib.pyplot import imread, imshow

    data = imread('AbbeyRoad.jpg')
    imshow(data)

    Ancak imshow fonksiyonu resmi kendisi boyutlandırarak çizdirmektedir. Yani resmi orijinal boyutuyla görüntülemek biraz zahmetlidir. 
    Elimizdkei NumPy dizisine ilişkin resmi görüntülemenin diğer bir yolu da yine PIL kütüphensini kullanmaktadır. Örneğin:

    from PIL import Image

    image = Image.fromarray(data)
    image.show()

    Ancak show metodu resmi IPython konsolunda değil default ilişkilendirilmiş programla göstermektedir. Biz elimizdeki Image nesnesi 
    içerisind ebulunan resmi Image sınıfının save metodula save edebiliriz. Örneğin:

    image.save('Clpped-AbbeyRoad.jpg')

    Bir resim üzerinde işlemler aslında resmin pixelleri üzerinde yapılmaktadır. Biz resmin pixel'lerini NumPy dizisi halinde elde
    ettikten sonra artık onu dilimleyerek resmin belirli kısımlarını atabiliriz. Ya da satırları yer değiştirerek resmi ters yüz 
    edebiliriz. Örneğin:

    data = imread('AbbeyRoad.jpg')
    clipped_data = data[30:-30, 30:-30, :]
 #------------------------------------------------------------------------------------------------------------------------------------

from matplotlib.pyplot import imread, imshow

data = imread('AbbeyRoad.jpg')
clipped_data = data[30:-30, 30:-30, :]

from PIL import Image

image = Image.fromarray(clipped_data)
image.show()

image.save('Clpped-AbbeyRoad.jpg')

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtildiği gibi elemana erişim sırasında ilk k tane boyut için indeks girilmiş ancak geri kalan indeksler girilmemişse 
    aslında girilmeyen indekslerin hepsi işleme dahil edilmektedir. Örneğin elimizde iki boyutlu a isimli bir NumPy dizisi olsun. Bu durumda 
    a[1] biçiminde bir erişim a[1, :] anlamına gelmektedir. Ya da örneğin b üç boyutlu bir NumPy dizisi olsun. Bu durumda b[k] gibi 
    bir ifade ile b[k, :, :] ifadesi eşdeğerdir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]], dtype=np.float32)

val = a[1]
print(val)

val = a[1, :]
print(val)

val = a[:, 4]
print(val)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir numpy dizisinin elemanları [] operatörü ile elde edildiğinde ürünün boyutuna dikkat ediniz. Örneğin iki boyutlu matristen 
    bir satırı ya da sütunu çektiğimizde elde ettiğimiz dizi tek boyutlu olmaktadır. Ancak biz iki boyutlu matrisin belli bir kısmını 
    dilimleyerek çektiğimizde elde edilen dizi iki boyutlu olmaktadır. Başka bir deyişle çok boyutlu bir diziden elde edilen dizi 
    duruma göre tek boyutlu ya da çok boyutlu olabilmektedir. Dilimleme bize her zaman aynı boyutta bir NumPy dizisi vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Biz bir NumPy dizisinin tek bir elemanını elde ettiğimizde bu eleman Python türünden int, float ya da bool olmaz. C Programlama 
    Dilindeki türlerden (yani dtype türlerinden olur.) Buna NumPy'da skaler de denilmektedir. Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3))
    >>> a
    array([[83, 60, 50],
        [ 5, 28, 98],
        [34, 39, 56]])
    >>> x = a[0, 0]
    >>> x
    83
    >>> type(x)
    <class 'numpy.int32'>

    Burada a dizinin [0, 0] indeksindeki eleman elde edildiğinde elde edilen bu değer numpy.int32 isimli bir türdendir. Bu türler 
    tür dönüştürmesi yapılarak Python'un orijinal türlerine dönüştürülebilir. Örneğin:

    >>> int(x)
    83

    NumPy'daki skaler nesneleri biz aritmetik işlemlere sokarsak yine Python türünden değil NumPy'daki skaler türden değer elde ederiz. 
    Örneğin:

    >>> x = np.float32(3.14)
    >>> x
    3.14
    >>> type(x)
    <class 'numpy.float32'>
    >>> y = x + 2
    >>> y
    5.140000104904175
    >>> type(y)
    <class 'numpy.float64'>
#------------------------------------------------------------------------------------------------------------------------------------
import numpy as np

a = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]], dtype=np.float32)

val = a[1]
print(type(val), val.shape)     # <class 'numpy.ndarray'> (5,)

val = a[:, 4]
print(type(val), val.shape)     # <class 'numpy.ndarray'> (4,)

val = a[2:4, 1:3]
print(type(val), val.shape)     # <class 'numpy.ndarray'> (2, 2)

val = a[3, 4]
print(type(val), val.shape)     # <class 'numpy.float32'> ()

x = val + 2
print(type(x), x.shape)         # <class 'numpy.float64'> ()

y = float(x)
print(type(y))                  # <class 'float'>            

#------------------------------------------------------------------------------------------------------------------------------------
    Dilimleme sırasında bir "view" nesnesinin elde edildiğine dikkat ediniz.Yani dilim üzerinde işlem yapıldığında bundan ana nesne, 
    ana nesne üzerinde işlem yapıldığında bundan dilimlenmiş nesne etkilecektir. Örneğin:

    >>> a = np.arange(100).reshape((10, 10))
    >>> a
    array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14, 15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
        [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],
        [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
        [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],
        [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],
        [70, 71, 72, 73, 74, 75, 76, 77, 78, 79],
        [80, 81, 82, 83, 84, 85, 86, 87, 88, 89],
        [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]])
    >>> b = a[4:6, 2: 7]
    >>> b
    array([[42, 43, 44, 45, 46],
        [52, 53, 54, 55, 56]])
    >>> a[4, 2] = 100
    >>> b
    array([[100,  43,  44,  45,  46],
        [ 52,  53,  54,  55,  56]])
    >>> b[0, 0] = 200
    >>> a
    array([[  0,   1,   2,   3,   4,   5,   6,   7,   8,   9],
        [ 10,  11,  12,  13,  14,  15,  16,  17,  18,  19],
        [ 20,  21,  22,  23,  24,  25,  26,  27,  28,  29],
        [ 30,  31,  32,  33,  34,  35,  36,  37,  38,  39],
        [ 40,  41, 200,  43,  44,  45,  46,  47,  48,  49],
        [ 50,  51,  52,  53,  54,  55,  56,  57,  58,  59],
        [ 60,  61,  62,  63,  64,  65,  66,  67,  68,  69],
        [ 70,  71,  72,  73,  74,  75,  76,  77,  78,  79],
        [ 80,  81,  82,  83,  84,  85,  86,  87,  88,  89],
        [ 90,  91,  92,  93,  94,  95,  96,  97,  98,  99]])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Programcı bazen bir view nesnesi elde etmek istemeyebilir. Gerçekten orijinal nesnenin bir kopyasını oluşturmak isteyebilir. 
    Bunun için ndarray sınıfının copy metodu ya da copy fonksiyonu kullanılabilir. Örneğin:

    >>> a = np.arange(25).reshape((5, 5))
    >>> a
    array([[ 0,  1,  2,  3,  4],
        [ 5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14],
        [15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24]])
    >>> b = a.copy()
    >>> b
    array([[ 0,  1,  2,  3,  4],
        [ 5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14],
        [15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24]])
    >>> a[0, 0] = 100
    >>> b
    array([[ 0,  1,  2,  3,  4],
        [ 5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14],
        [15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24]])

    Burada biz a nesnesinin aynı değerleri içeren bir kopyasını oluşturduk. Artık iki kopya birbirinden farklıdır. Birinde yapılan 
    değişiklik diğerini etkilemeyecektir. Tabii dilimleme yapıldıktan sonra da copy metodu çağrılabilir. Örneğin:

    >>> a = np.arange(25).reshape((5, 5))
    >>> a
    array([[ 0,  1,  2,  3,  4],
        [ 5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14],
        [15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24]])
    >>> b = a[2:4, 1:3].copy()
    >>> b
    array([[11, 12],
        [16, 17]])
    >>> a[2, 2] = 100
    >>> b
    array([[11, 12],
        [16, 17]])
    >>> b[0, 0] = 200
    >>> a
    array([[  0,   1,   2,   3,   4],
        [  5,   6,   7,   8,   9],
        [ 10,  11, 100,  13,  14],
        [ 15,  16,  17,  18,  19],
        [ 20,  21,  22,  23,  24]])
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]], dtype=np.float32)

b = a.copy()

a[0, 0] = 100

print(a)
print(b)

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi biz bir NumPy dizisinden tek bir eleman çektiğimizde o bir NumPy dizisi olmaz, bir NumPy dtype 
    değeri olur. Aslında dtype türleri de birer sınıf belirtmktedir ve biz o sınıflar türünden de nesneler yaratabiliriz. Örneğin:

    x = np.float32(10)

    Biz buradan C'deki "float" türüne ilişkin (yani 4 byte uzunlukta gerçek sayı türüne ilişkin) bir nesne elde etmiş olduk. Örneğin:

    >>> x = np.float32(3.14)
    >>> x
    3.14
    >>> type(x)
    <class 'numpy.float32'>
     >>> float(x)
    3.140000104904175
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

x = np.float32(10)
print(x, type(x))      # 10.0 <class 'numpy.float32'> 

#------------------------------------------------------------------------------------------------------------------------------------
    Elimizde bir NumPy skaleri (yani dtype nesnesi) varsa o nesnenin içerisindeki değeri Python türü olarak iki biçimde elde edebiliriz:
    Python türüne tür dönüştürmesi yaparak ya da dtype sınıflarının item metotlarını kullamak. Örneğin:

    >>> x = np.float32(3.14)
    >>> float(x)
    3.140000104904175
    >>> x.item()
    3.140000104904175
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

x = np.float32(10)
print(x, type(x))

y = x.item()
print(y, type(y))

x = np.int8(3)
print(x, type(x))

y = x.item()
print(y, type(y))

#------------------------------------------------------------------------------------------------------------------------------------
   İki NumPy dizisi ya da skaleri işleme sokulduğunda bunların dtype türleri aynı ise sonuç olarak elde edilen dtype türü de aynı 
   olur. Örneğin:

    >>> a = np.array([1, 2, 3], dtype=np.float32)
    >>> b = np.array([1, 2, 3], dtype=np.float32)
    >>> c = a + b
    >>> c.dtype
    dtype('float32')

    Farklı dtype türlerine ilişkin diziler de işleme sokulabilirler. Bu durumda şu kurallar işletilmektedir:

    1) İki NumPy dizisinin dtype türü de tamsayı türlerine ilişkinse ürün büyük tamsayı türünden olur. Örneğin:

    >>> a = np.array([1, 2, 3], dtype=np.int8)
    >>> b = np.array([1, 2, 3], dtype=np.int64)
    >>> c = a + b
    >>> c.dtype
    dtype('int64')

    2) Dizilerden biri işaretli dtype türünden diğeri ise işaretsiz dtype türünden ise elde edilecek ürün bu türleri kapsayan daha 
    büyük ilk işaretli türden olmaktadır. Örneğin:

    >>> a = np.array([1, 2, 3], dtype=np.uint8)
    >>> b = np.array([1, 2, 3], dtype=np.int8)
    >>> c = a + b
    >>> c.dtype
    dtype('int16')

    3) Dizilerden birinin dtype türü tamsayı türünden diğerinin dtype türü gerçek sayı türünden ise ürün gerçek sayı türüne ilişkin 
    dtype türünden olur. Örneğin:

    >>> a = np.array([1, 2, 3], dtype=np.int8)
    >>> b = np.array([1, 2, 3], dtype=np.float32)
    >>> c = a + b
    >>> c.dtype
    dtype('float32')
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi dilimleme işlemi her zaman bir NumPy view nesnesinin elde edilmesine yol açmaktadır. Ancak dilimleme 
    olmaksızın belli bir elemana erişildiğinde dtype türlerine ilişkin bir skaler nesne elde edilmektedir. Bu dtype nesneleri bir view 
    belirtmezler. Örneğin:

    >>> a = np.array([1, 2, 3], dtype='int32')
    >>> x = a[0]

    Biz burada x'e atama yaptığımızda zaten Python dinamik tür sistemine sahip bir programlama dili olduğu için artık x yeni atanan 
    değer türünden olur. Örneğin:

    >>> x = 12
    >>> type(x)
    <class 'int'>
    >>> a
    array([1, 2, 3])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Peki elimizde bir ndarray nesnesi (yani NumPy dizisi) varsa, biz bu ndarray nesnesinin bir view belirtip belirtmediğini nasıl 
    anlarız? Bunun birkaç yolu vardır. En dolaysız yolu nesnenin base isimli örnek özniteliğine bakmaktır. Eğer nesne bir view nesnesi 
    değil de gerçek bir nesne ise base örnek özniteliği None değerini verecektir. Eğer nesne bir view nesnesi ise base örnek özniteliği 
    gerçek nesnenin referansını verecektir. (View nesneleri aslında bir biçimde gerçek nesnenin adresini ve onun hangi kısmına 
    referans edildiği bilgisini tutmaktadır.) Örneğin:

    >>> a = np.array([[1, 2, 3], [5, 6, 7], [7, 8, 9]], dtype='float32')
    >>> a
    array([[1., 2., 3.],
        [5., 6., 7.],
        [7., 8., 9.]], dtype=float32)
    >>> b = a[1:, 1:]
    >>> b
    array([[6., 7.],
        [8., 9.]], dtype=float32)
    >>> print(b.base)
    [[1. 2. 3.]
    [5. 6. 7.]
    [7. 8. 9.]]
    >>> print(a.base)
    None
    >>> id(a)
    1897598332432
    >>> id(b)
    1897598330320
    >>> id(b.base)
    1897598332432
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

print(a.base)       # None

b = a[1, :]

print(id(a))
print(id(b.base))

print(a is b.base)      # True

#------------------------------------------------------------------------------------------------------------------------------------
   Aşağıdaki örnekte aslında elde edilen a nesnesi bir view nesnesidir:

   >>> a = np.arange(20).reshape(5, 4)
    >>> a.base
    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19])
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.arange(0, 20, dtype='float32').reshape(4, 5)
print(a.base is None)       # False

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisi dolaşılabilir bir nesneyle indekslenebilir. Bu durumda ilgili indeksteki elemanlar bir NumPy dizisi biçiminde elde 
    edilmektedir. Örneğin:

    >>> a = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])
    >>> a
    array([ 10,  20,  30,  40,  50,  60,  70,  80,  90, 100])
    >>> b = a[[1, 4, 6]]
    >>> b
    array([20, 50, 70])

    Burada biz a deizinin sırasıyla 1, 4, ve 6 numaralı indekslerindeki elemanlardna oluşan bir NumPy dizisi elde etmiş olduk. 
    Tabii biz aynı indeksi birden fazla kez kullabiliriz. Örneğin:

    >>> a = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])
    >>> a[[3, 4, 3, 1]]
    array([40, 50, 40, 20])
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])

b = a[[2, 5, 3, 1]]
print(b)                # [30 60 40 20]

#------------------------------------------------------------------------------------------------------------------------------------
    Demetlerin köşeli parantezdeki özel anlamını anımsayınız. Python'da her zaman a[x, y, z] sentaksı ile a[(x, y, z)] sentakı aynı 
    anlamdadır. Bu nedenle dolaşılabilir nesnenin demet biçiminde oluşturulması error'e yol açabilecektir. Örneğin:

    >>> a = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])
    >>> b = a[(1, 4, 6)]
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    IndexError: too many indices for array: array is 1-dimensional, but 3 were indexed
        
    Fakat yine biz bu tür durumlarda demet kullanabiliriz. Ancak demetten sonra ekstra bir ',' atomu da sentaksta kullanılmalıdır. 
    Örneğin:

    >>> b = a[(1, 4, 6), ]
    >>> b
    array([20, 50, 70])

    Anımsanacağı gibi Python'da genel olarak "virgüllü listelerde (comma separeted lists)" son bir virgül atomu hataya yol açmamaktadır. 
    Örneğin:

    x = [10, 20, 30, ]
    y = 10, 20, 30, 

    Yani biz bir  NumPy dizisinin tek bir elemanına erişirken de eksta ',' atomu kullanırsak bu sentaks bakımından geçerlidir. İndekslemede 
    kullanılan bu ekstra ',' aslında indeksin bir demet olduğunu belirtmektedir. Yani örneğin a[1, ] ifadesi aslında a[(1, )] ifadesi ile 
    eşdeğerdir. Yukarıda da belirtildiği gibi NumPy dizileri demetle indekslenebilmektedir. Ancak Python listeleri demetlerle indekslenemez. 
    Örneğin:

    >>> a = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])
    >>> a[1]
    20
    >>> a[1, ]
    20
    >>> a[(1, )]
    20

    Bir NumPy dizisini dolaşılabilir bir nesneyle indekslediğimizde elde edilen dizi bir view belirtmemektedir. Örneğin:

    >>> a = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])
    >>> a
    array([ 10,  20,  30,  40,  50,  60,  70,  80,  90, 100])
    >>> b = a[[1, 3, 5]]
    >>> print(b.base)
    None
    >>> c = a[[1, 2, 3]]
    >>> print(c.base)
    None
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])

b = a[(2, 5, 3, 1),]
print(b)                # [30 60 40 20]

#------------------------------------------------------------------------------------------------------------------------------------
                                            45. Ders 30/08/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Çok boyutlu dizilerde de her boyut için dolaşılabilir bir nesne ile indeks belirtilebilir. Bu durumda indekslerdeki dolaşılabilir 
    nesnelerin elemanlarının eşit uzunlukta olması gerekir. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> b = a[[0, 2], [1, 2]]
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> b
    array([2, 9])

    Burada dilimleme yapılmamaktadır. a[[0, 1], [1, 2]] ifadesini görenler sanki burada "0 ve 2 indeksli satırların, 1 ve 2 indeksli sütunların
    seçildiğini" sanabilmektedir. Halbuki burada aslında a[0, 1] ve a[2, 2] elemanları seçilmiştir. Örneğin:

    >>> a = np.random.randint(0, 100, (10, 10))
    >>> a
    array([[90, 43, 86, 40, 96, 68, 75, 36, 63, 30],
        [85,  8, 59, 43, 43, 60,  2, 21, 80, 50],
        [49, 71, 58, 54, 60, 94, 49, 58, 73, 27],
        [95, 95, 31, 67,  5, 42, 14, 71, 66, 57],
        [17, 37, 50, 44, 35, 88,  3,  7, 53, 66],
        [84, 50, 41, 18,  8, 50, 93, 99, 49, 47],
        [18, 62, 29, 44, 23, 80, 35, 98, 26, 59],
        [59, 44, 20, 75, 19, 93, 80, 54, 75, 10],
        [21, 24, 77, 66, 28, 40, 61, 52, 80, 78],
        [56, 66, 68, 98, 45, 56, 39, 16, 62, 93]])
    >>> a[[3, 6, 8, 2], [1, 7, 4, 6]]
    array([95, 98, 28, 49])

    Burada [3, 1], [6, 7], [8, 4], [2, 6] elemanları seçilmiştir.

    İndeksleme sırasında bir indeks dolaşılabilir nesneyse diğer indeksler dilimleme yoluyla da belirtilebilir. Örneğin:

    >>> a[[3, 6, 8, 2], :]
    array([[95, 95, 31, 67,  5, 42, 14, 71, 66, 57],
        [18, 62, 29, 44, 23, 80, 35, 98, 26, 59],
        [21, 24, 77, 66, 28, 40, 61, 52, 80, 78],
        [49, 71, 58, 54, 60, 94, 49, 58, 73, 27]])
    >>> a[[3, 6, 8, 2], 2:5]
    array([[31, 67,  5],
        [29, 44, 23],
        [77, 66, 28],
        [58, 54, 60]])

    Dilimlemede dilimleme sonucunda elde edilen elemanlar herhangi bir sayıda olabilir. Örneğin:

    >>> import numpy as np
    >>> a = np.arange(100).reshape((10, 10))
    >>> a
    array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14, 15, 16, 17, 18, 19],
        [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
        [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],
        [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
        [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],
        [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],
        [70, 71, 72, 73, 74, 75, 76, 77, 78, 79],
        [80, 81, 82, 83, 84, 85, 86, 87, 88, 89],
        [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]])

    >>> a[[3, 5, 1, 6], 2:5]
    array([[32, 33, 34],
        [52, 53, 54],
        [12, 13, 14],
        [62, 63, 64]])

    Burada 5, 5, 1 ve 6 satırlarının 2, 3, ve 4'üncü sütunları elde edilmiştir. 

    Boyutların hepsinde dolaşılabilir nesne ya da dilimleme yapılması zorunlu değildir. Boyutlarda tek bir sayı da belirtilebilir. Örneğin:

    >>> a[[3, 6, 8, 2], 2]
    array([31, 29, 77, 58])

    Yukarıda da belirttiğimiz gibi birden fazla indekste dolaşılabilir nesne kullanılacaksa bunların eleman sayısının aynı olması 
    gerekmektedir. Örneğin:

    >>> a[[3, 6, 8, 2], [2, 5]]
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    IndexError: shape mismatch: indexing arrays could not be broadcast together with shapes (4,) (2,)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.arange(100).reshape(10, 10)

print(a)
             
b = a[[1, 2, 4], [1, 4, 6]]         # a[1, 1], a[2, 4], a[4, 6]
print(b)

b = a[[1, 2, 4], 5]                 # a[1, 5], a[2, 5], a[4, 5]
print(b)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisine bool indeksleme uygulanabilir. bool indeksleme için dizi uzunluğu ve boyutu kadar bool türden dolaşılabilir 
    bir nesne kullanılır. Bu dolaşılabilir nesnedeki True olan elemanlara karşı gelen dizi elemanları elde edilmektedir. Örneğin:

    array([ 10,  20,  30,  40,  50,  60,  70,  80,  90, 100])
    >>> a[[True, False, True, True, False, True, True, False, True, True]]
    array([ 10,  30,  40,  60,  70,  90, 100])

    Tabii çok boyutlu NumPy dizilerinde de benzer biçimde bool indeksleme yapılabilmektedir. Bu durumda her boyut için ayrı bir dolaşılabilir 
    bool nesne verilir. Elde edilecek değerler Bu bool nesnelerdeki True olan boyutların kesişimlerindeki değerler olacaktır. 
    Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> a[[True, False, True], [False, True, True]]
    array([2, 9])

    Buradaki seçim mantığı şöyledir: Önce True olan satır ve sütunların yerine onların indeks numaraları yerleştirilir. Sonra daha önce
    gördüğümüz gibi sanki birden fazla boyutta dolaşılabilir nesnede indeks varmış gibi işlem yapılır. Örneğin:

    a[[True, False, True], [False, True, True]]

    Bu işlemin eşdeğeri şöyledir:

    a[[0, 2], [1, 2]]

    Bu da a[0, 2] ve a[2, 2] elemanları anlamına gelmektedir. Tabii bu biçimdeki indekslemede boyutlardaki True elemanlarının sayısının 
    aynı olması gerekir. Örneğin:

    a[[True, True, False], [False, True, True]]

    Bu indekslemenin eşdeğeri şöyledir:

    a[[0, 1], [1, 2]]

    Bu da şu dizinin elde edilmesine yol açacaktır:

    array([2, 6])

    Çok boyutlu NumPy dizileri aynı boyuttaki bool türden NumPy dizileri ile indekslenebilmektedir. Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3))
    >>> a
    array([[47, 88, 61],
        [13, 54, 89],
        [33, 33, 16]])
    >>> b = np.array([[True, False, True], [True, True, False], [False, False, True]])
    >>> a[b]
    array([47, 61, 13, 54, 16])

    Ancak çok boyutlu NumPy dizileri bool türden liste listeleriyle (yani iki boyutlu listelerle) indekslenememektedir. Örneğin:

    >>> b = [[True, False, True], [True, True, False], [False, False, True]]
    >>> a[b]
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    IndexError: too many indices for array: array is 2-dimensional, but 3 were indexed

    Çok boyutlu NumPy dizilerine bool indeksleme uyguldadınızda elde edilen ürünün tek boyutlu olduğuna dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bool indeksleme filtreleme yapmak için çokça kullanılmaktadır. Anımsanacağı gibi bir NumPy dizisi skaler işlemlere sokulduğunda 
    aslında dizinin her elemanı işleme sokulmaktadır. a bir NumPy dizisi olmak üzere biz a > 40 gibi bir işlem yaparsak burada dizinin 
    her elemanı 40'tan büyük mü diye kontrol yapılacak ve dizi uzunluğu kadar uzunlukta bool türden bir NumPy dizisi elde edilecektir. 
    Örneğin:

    >>> a = np.array([32, 45, 12, 67, 18, 41, 92, 9, 12])
    >>> a
    array([32, 45, 12, 67, 18, 41, 92,  9, 12])
    >>> a > 40
    array([False,  True, False,  True, False,  True,  True, False, False])

    İşte bu tür karşılaştırma operatörlerinden elde edilen diziler bool indekslemede kullanılırsa "belli koşulu sağlayan elemanlar" 
    filtrelenebilir. Örneğin:

    >>> a[a > 40]
    array([45, 67, 41, 92])
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([3, 5, 34, 12, 9, 37, 32, 10])

result = a > 15
print(result)           # [False False  True False False  True  True False]

b = a[result]           
print(b)                # [34 37 32]

b = a[a > 15]           # a dizisi içerisindeki 15'ten büyük olan değerler elde ediliyor
print(b)                # [34 37 32]

#------------------------------------------------------------------------------------------------------------------------------------
    Örneğin bir NumPy dizisinin ortalamadan küçük elemanlarını a[a > np.mean(a)] ifadesi ile elde edebiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([3, 5, 34, 12, 9, 37, 32, 10])

print(np.mean(a))

result = a[a < np.mean(a)]
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Örneğin bir NumPy dizisinin çift elemanlarını da aynı biçimde elde edebiliriz.
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([3, 5, 34, 12, 9, 37, 32, 10])

print(np.mean(a))

result = a[a % 2 == 0]
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Köşeli parantez içerisindeki "... (ellipsis)" sentaksı "ondan önceki ve sonraki eksenlerin hepsi dahil edilecek" anlamına 
    gelmektedir. Örneğin a dizisinin 4 boyutlu olduğunu düşünelim. a[k, ...] ifadesi tamamen a[k, :, :, :] ile eşdeğerdir. Örneğin 
    a[1, ..., 3] ifadesi ise a[1, :, : 3] ile eşdeğerdir. a[1, 2, ..., 5] ifadesi a[1, 2, :, 5] ile eşdeğerdir. Ancak ellipsis köşeli 
    parantez içerisinde yalnızca bir kez kullanılabilir. Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3, 3))
    >>> a
    array([[[57, 31, 50],
            [12, 82, 96],
            [83,  5, 48]],

        [[92, 50, 83],
            [28, 62, 20],
            [28, 97, 38]],

        [[78, 91, 48],
            [76,  9, 54],
            [43, 59, 76]]])
    >>> b = a[..., 2]
    >>> b
    array([[50, 96, 48],
        [83, 20, 38],
        [48, 54, 76]])
    >>> b = a[:, :, 2]
    >>> b
    array([[50, 96, 48],
        [83, 20, 38],
        [48, 54, 76]])
    >>> b = a[2, ...]
    >>> b
    array([[78, 91, 48],
        [76,  9, 54],
        [43, 59, 76]])
    >>> b = a[2, :, :]
    >>> b
    array([[78, 91, 48],
        [76,  9, 54],
        [43, 59, 76]])

#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.arange(27).reshape(3, 3, 3)

print(a)
print('----------------')

b = a[1, ...]       # eşdeğeri a[1, :, :]
print(b)

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında NumPy'da yukarıda ele almadığımız değişik dtype türleri de vardır. Ancak bu konunun ayrıntılarına burada girmeyeceğiz.
    Değişik türler array fonksiyonunda hiç dtype belirtilmeden bir araya getirilirse array fonksiyonu eğer mümkünse bunların hepsini 
    yazıya dönüştürüp sanki birer yazı gibi saklamaktadır. Örneğin:

    >>> a = np.array([1, 'ankara', True])
    >>> a
    array(['1', 'ankara', 'True'], dtype='<U11')

    Burada "<U11" dtype türü "Unicode UTF-16 karakterlerindenden oluşan her bir eleman için 11 karakter yer ayrılmış olan" bir dtype 
    türünü temsil etmektedir. Buradaki '<' karakteri "little endian" anlamına gelmektedir. 

    Bir NumPy dizisinin her elemanı bir Python nesnesinin adresini de tutabilir. Bu aslında bir çeşit Python listesi gibi bir durum 
    oluşturur. Bunun için dtype türü object olarak belirtilir. Bu object türü bir yazı olarak ya da doğrudan Python'daki object sınıf 
    ismi olarak kullanılabilir. (Ancak np.object biçiminde belirleme eskiden kullanılıyordu sonradan "deprecated" yapıldı. Artık Python'daki 
    object ismi kullanılmaktadır.) Örneğin:

    >>> a = np.array([12, 34.5, 'ankara'], dtype=object)
    >>> a
    array([12, 34.5, 'ankara'], dtype=object)
    >>> type(a[0])
    <class 'int'>
    >>> type(a[1])
    <class 'float'>
    >>> type(a[2])
    <class 'str'>
#------------------------------------------------------------------------------------------------------------------------------------

a = np.array([[1, 2, 'Erkek'], [4, 5, 'Kadın'], [3, 6, 'Erkek'], [5, 8, 'Kadın']], dtype=object)
print(a, a.dtype)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisini transpoze etmek için ndarray sınıfının transpose isimli metodu ya da transpose fonksiyonu kullanılmaktadır. 
    Aynı zamanda ndarray nesnesinin T isimli öniteliği de transpose matrisini bize vermektedir. Yani a isimli NumPy dizisinin 
    transpose  matrisi aşağıdaki gibi üç biçimde elde edilebilir:

    b = a.transpose()
    b = np.transpose(a)
    b = a.T

    Transpoze işlemi her zaman bir view nesnesi oluşturularak yapılmaktadır. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> b = a.transpose()
    >>> b
    array([[1, 4, 7],
        [2, 5, 8],
        [3, 6, 9]])
    >>> b.base
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> c = np.transpose(a)
    >>> c
    array([[1, 4, 7],
        [2, 5, 8],
        [3, 6, 9]])
    >>> c.base
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> d = a.T
    >>> d
    array([[1, 4, 7],
        [2, 5, 8],
        [3, 6, 9]])
    >>> d.base
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Çok boyutlu dizilerin transpoze edilmeleri eksen temelinde yapılmaktadır. Yani hangi boyutların hangi boyutlarla transpoze edileceği 
    ayrı ayrı belirtilebilmektedir. Örneğin a üç boyutlu bir NumPy dizisi olsun. a.transpose([1, 2, 0]) işlemi ile eski 1'inci eksen 
    artık 0'ıncı eksen eski 1'inci eksen artık 1'inci eksen ve eski 0'ıncı eksen artık 2'inci eksen olur. Yani transpoze işlemi sırasındaki 
    taşıma şöyle yapılır:

    a[i, j, k] --> a[J, k, i]

    Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3, 3))
    >>> a
    array([[[51, 90, 29],
            [ 7, 20, 73],
            [33, 89, 21]],

        [[12, 41, 70],
            [29, 35, 13],
            [92, 26, 61]],

        [[21, 82, 33],
            [ 3,  3, 44],
            [22, 42, 37]]])
    >>> a.transpose([1, 2, 0])
    array([[[51, 12, 21],
            [90, 41, 82],
            [29, 70, 33]],

        [[ 7, 29,  3],
            [20, 35,  3],
            [73, 13, 44]],

        [[33, 92, 22],
            [89, 26, 42],
            [21, 61, 37]]])
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2], [4, 5], [7, 8]], dtype='float32')
print(a, a.shape, end='\n\n')

b = np.transpose(a)

print(b, b.shape, end='\n\n')
print(b.base is None)       # False

#------------------------------------------------------------------------------------------------------------------------------------
    İki NumPy dizisi üzerinde toplama, çarpma, çıkarma, bölme ya da karşılaştırma gibi işlemler yapıldığında aslında ndarray sınıfının 
    operatör metotları çağrılmaktadır. Bu operatör metotları da NumPy dizilerinin karşılıklı elemanları üzerinde işlemler yapmaktadır. 
    Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> b = np.array([[3, 1, 4], [1, 5, 9], [2, 6, 5]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> b
    array([[3, 1, 4],
        [1, 5, 9],
        [2, 6, 5]])
    >>> c = a * b
    >>> c
    array([[ 3,  2, 12],
        [ 4, 25, 54],
        [14, 48, 45]])
    >>> d = a + b
    >>> d
    array([[ 4,  3,  7],
        [ 5, 10, 15],
        [ 9, 14, 14]])
        
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype='float32')
b = np.array([[2, 1, 4], [1, 3, 5], [1, 1, 2]], dtype='float32')

c = a + b
print(c)

c = a * b
print(c)

c = a / b
print(c)

c = a - b
print(c)

#------------------------------------------------------------------------------------------------------------------------------------
    İki NumPy dizisinin işleme sokulabilmesi için bunların boyutlarının aynı olması gerekir. Ancak boyutları aynı olmayan NumPy dizileri 
    eksen temelinde de işlemlere sokulabilmektedir. Bu tür işlemlere İngilizce "broadcasting" denilmektedir. Örneğin 3 elemanlı bir NumPy 
    dizisi 3x3'lük bir numpy dizisi ile işleme sokulabilir. Bu durumda aslında 3 elemanlık dizi bu 3x3'lük matrisin her satırı ile işleme 
    sokulacaktır. İşte bu duruma "broadcasting" denilmektedir. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> b = np.array([1, 3, 5])
    >>> c = b + a
    >>> c
    array([[ 2,  5,  8],
        [ 5,  8, 11],
        [ 8, 11, 14]])

    Broadcasting sütun temelinde de yapılabilmektedir. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> b = np.array([[1], [3], [5]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> b
    array([[1],
        [3],
        [5]])
    >>> c = b + a
    >>> c
    array([[ 2,  3,  4],
        [ 7,  8,  9],
        [12, 13, 14]])

    Tabii * ve / operatörlerinin bu bağlamda değişme özellikleri vardır. Yani yukarıdaki örneklerde operand'ları yer değiştirdiğimizde de
    aynı sonuçları buluruz. 

    a ve b dizilerine broadcasting ile işlemlere sokalım. Burada a dizisi n boyutlu k dizisi de k < n olmak üzere k boyutlu olsun. 
    a dizisinin son k tane boyutunun b dizisinin k tane boyutuyla aynı olması gerekir. Bu durumda bu durumda broadcasting a dizisinin 
    ilk n - k boyurunun b diziisyle işleme sokulması biçiminde gerçekleşmektedir. Örneğin a dizisi 5x3x2 boyutunda b dizisi de 3x2 
    boyutunda olsun. Bu durumda a disizinin ilk boyutuna ilişkin 5 dizi b ile işleme sokulacaktıri. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([1, 2, 3])
b = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype='float32')

c = a + b
print(c, end='\n\n')

c = a * b
print(c)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir skaler bir NumPy dizisi ile işleme sokulabilir. Bu da bir çeşit "broadcasting" işlemidir. Bu durumda skaler NumPy dizisinin 
    her elemanıyla işleme sokulmuş olur. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> b = 2 * a
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> b
    array([[ 2,  4,  6],
        [ 8, 10, 12],
        [14, 16, 18]])
    >>> b = a * 2
    >>> b
    array([[ 2,  4,  6],
        [ 8, 10, 12],
        [14, 16, 18]])

#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype='float32')

c = 3 * a
print(c, end='\n\n')

#------------------------------------------------------------------------------------------------------------------------------------
    İki NumPy dizisinin çarpılmasının bir matris çarpımı olmadığına dikkat ediniz. Bu durumda iki dizinin karşılıklı elemanları 
    birbirleriyle çarpılmaktadır. Eğer gerçekten matris çarpımının yapılması isteniyorsa matmul isimli fonksiyon ya da @ operatörü 
    kullanılmalıdır. @  operatörü Python'a 3.5 versiyonuyla eklenmiştir. Bu operatör aslında sınıfın __matmul__ metodunu çağırmaktadır. 
    Yani a @ b işlemi ile a.__matmul__(b) işlemi eşdeğerdir. Bilindiği gibi iki matris çarpılabilmesi için soldaki matris sütun sayısının
    sağdaki matrisin satır sayısına eşit olması gerekir. Matris çarpımının sonucunda elde edilen matris soldaki matrisin satır sayısı 
    ve sağdaki matrisin sütun sayısı boyutunda olur. Yani örneğin mxn boyutlu bir matiris ile nxk boyutlu bir matris çarpılabilir. 
    Çarpım sonucunda mxk boyutunda bir matris elde edilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2, 1], [3, 1, 2], [1, 3, 2]])
b = np.array([[3, 2, 1], [1, 1, 1], [1, 2, 3]])
             
c = np.matmul(a, b)
print(c)

c = a @ b
print(c)

#------------------------------------------------------------------------------------------------------------------------------------
    Matris çarpımını andıran ismine "dot product" denilen bir işlem de vardır. Dot product iki dizinin karşılıklı elemanlarının 
    çarpılarak toplanması anlamına gelmektedir. Dot product işlemi dot isimli fonksiyonla ya da ndarray sınıfının  dot metoduyla yapılabilmektedir. Örneğin:

    >>> a = np.array([1, 2, 3, 4, 5])
    >>> b = np.array([3, 2, 4, 1, 2])
    >>> c = np.dot(a, b)
    >>> c
    33
    >>> c = a.dot(b)
    >>> c
    33

    Eğer diziler iki boyutlu ise dot product işlemi matris çarpımı gibi yapılmaktadır. Dot product işlemi özellikle "yapay sinir 
    ağlarında" yaygın kullanılan bir işlemdir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy kütüphanesi veri bilimi, istatikl ve makine öğrenmesi alanlarında sıkça kullanılmaktadır. İstatistikte bir varlığa (entity)
    ilişkin özellikler birbirinden farklı olabilmektedir. Örneğin bir kişinin boy uzunluğu, kilosu, yaşı farklı türden niceliklerdir. 
    İşte varlıklara ilişkin onların farklı özelliklerinin oluşturduğu topluluğa "veri kümesi (data set)" ya da "veri tablosu (data table)" 
    denilmektedir. Veri kümeleri ya da veri tabloları daha önce görmüş olduğumuz veritabanı tablolarına oldukça benzemektedir. 
    
    Bir veri kümesindeki satırlara genellikle "satır (row)" denir. Sütunlara ise "sütun (column) ya da daha sıklıkla "özellik (feature)" 
    denilmektedir. Örneğin kişilerin boy uzunluklarından, kilolarından ve yaşlarından oluşan aşağıdaki gibi bir veri kümesi bulunyor 
    olsun:
    
    Boy     Kilo    Yaş
    182     90      42
    178     82      34
    168     71      37
    ...     ...     ...

    Burada "Boy", "Kilo" ve "Yaş" sütunları bu veri kümesinin özelliklerini oluşturmaktadır. 

    İstatistikteki veri kümeleri NumPy'da iki boyutlu NumPy dizileriyle temsil edilmektedir. Bu tür veri kümelerinde sütun temelinde 
    ya da satır temelinde istatistiksel işlemlerin yapılması istenebilmektedir. Örneğin yukarıdaki veri kümesinde biz kişilerin boy 
    ortalamalarını, kilo ortalamalarını ve yaş ortalamalarını bulmak isteyebiliriz. Bunun için sütun temelinde işlemlerin yapılması 
    gerekmektedir. İşte bir matirisin satırları üzerinde ya da sütunları üzerinde işlemler yapmaya "eksenli işlemler" denilmektedir. 
    NumPy'da pek çok fonksiyonun ve metodun "axis" isimli eksen belirten bir parametresi vardır. Bu axis parametresi işlemlerin satır 
    temelinde mi sütun temelinde mi yapılacağını belirtir. Tabii aslında NumPy dizileri üç boyutlu ya da daha fazla boyutlu da olabilir. 
    Bu durumda eksen işlemleri diğer boyutlara göre de yapılabilir. Ancak uygulamada genellikle iki boyutlu NumPy dizileri üzerinde işlemler 
    yoğun bir biçimde yapılmaktadır. 
    
    
    Yukarıda pek çok NumPy fonksiyonunun bir axis parametresi olduğunu belirtmiştik. Örneğin sum isimli fonksiyonun parametrik sayısı 
    şöyledir:

    numpy.sum(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)

    Görüldüğü gibi fonksiyonun bir axis parametresi vardır. 
    
    Eğer fonksiyonlar ve metotlarda axis parametresi girilmezse (yani default bırakılırsa) fonksiynlar ve metotlar genellikle tüm 
    elemanları işleme sokmaktadır. Örneğin:

    >>> dataset = np.array([[182, 90, 42], [178, 82, 34], [168, 71, 27]])
    >>> dataset
    array([[182,  90,  42],
        [178,  82,  34],
        [168,  71,  27]])
    >>> np.sum(dataset)
    874

    Burada axis belirtilmediği için matrisin tüm elemanlarının toplamı elde edilmiştir. Peki axis paramtresi nasıl girilmelidir?
    axis parametresine 0'dan itibaren dizinin boyut sayısından 1 eksiğine kadar tamsayılar girilebilir. Örneğin iki boyutlu bir NumPy 
    dizisi için axis parametresine 0 ya da 1 girebiliriz. Üç boyutlu bir NumPy dizisi için axis parametresine 0, 1 ya da 2 girebiliriz. 
    Axis numaralandırması indekslemedeki sıraya göre yapılmaktadır. Örneğin iki boyutlu a isimli bir NumPy dizisi olsun. Bu dizinin bir 
    elemanına biz a[i, k] biçiminde erişiriz. İşte bu 02ıncı indeksle (i indeksi) belirtilen eksen 0'ıncı eksen, birinci indeksle belirtilen 
    eksen ise (k indeksi) 1'inci eksendir. Eğer a dizisi üç boyutlu olsaydı biz dizinin bir elemanına a[i, k, j] biçiminde erişirdik. 
    Bu durumda ilk index 0'ıncı eksene, ikinci indeks 1'inci eksene ve üçüncü indeks 2'inci eksene ilişkin olurdu.

    İşte eksensel işlemler yaparken işlemlerde hangi eksen değiştilerek işlem gerçekleşiyorsa axis parametresi o ekseni belirtiecek biçimde 
    verilmelidir. Aşağıdaki veri tablosuna bir daha bakınız:

    Boy     Kilo    Yaş
    182     90      42
    178     82      34
    168     71      37
    ...     ...     ...

    Biz burada sütunsal ortalamaları bulmak istiyorsak bunun için satır indekslerini değiştiririz. Yani a[i, k] erişimlerinde k'yı 
    sabit tutarsak i'leri değiştirerek sütunların ortalamalarını elde ederiz. O halde burada sütunsal işlemler için axis parametresi 
    axis=0 biçiminde girilmelldir. Eğer biz satırsal ortalamalrı bulmak isteseydik a[i, k] erişimlerinde k'ları değiştirmemiz gerekirdi. 
    Çünkü a[i, k] erişimlerinde i sabit olmak üzere biz k indeksini değiştirerek satırların sütunlarını elde ederiz. Bu nedenle atırsal 
    işlemler için axis parametresini axis=1 biçiminde kullanmamız gerekir. Yani işlemde hangi eksende değişiklik yapılarak işlem 
    yürütülecekse axis parametresi o ekseni belirtecek biçimde girilmelidir. 

    Bir NumPy dizisine satır ya da sütun eklemek, bir NumPy dizisinden satır ya da sütun silmek söz konusu olduğunda eksen parametresi 
    değişikliğin etki edeceği boyut biçiminde girilmelidir. Örneğin amacımız iki boyutlu bir NumPy dizisine satır eklemek ya da ondan 
    satır silmek olsun. Bu durumda bu işlemden satır sayısı yani 0'ıncı eksen etkilenecektir. O halde bizim ilgili fonksiyonu axis=0
    parametresi ile çağırmamız gerekir. Ancak iki boyutlu NumPy dizisine bir sütun ekleyecek ya ondan bir sütun silecek olsaydık bu 
    durumda axis parametresini axis=1 biçiminde girmemiz gerekirdi. 

    Yukarıdaki durum NumPy'a yeni başlayanlarda bir kafa karışıklığı oluşturabilmektedir. Biz iki boyutlu diziler axis işlemlerinin 
    özetini şöyle ifade edebiliriz:

    - İki boyutlu dizilerde sütunsal işlemler için axis=0, satırsal işlemler için axis=1 girilmelidir. 
    - İki boyutlu dizilerde satır ekleme ve silme işlemlerinde axis=0, sütun ekleme ve silme işlemlerinde axis=1 girilmelidir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi N boyutlu bir NumPy dizisinde indeksleme yapılırken girilen değerler sırasıyla axis numaralarını 
    vemektedir. Örneğin üç boyutlu bir a dizisinde belli bir indekse a[i, k, n] gibi üç indeksle erişiriz. Buradaki i indeksiyle 
    belirttiğimiz ilk boyut axis = 0'dır. k indeksi ile belirttiğimiz ikinci boyut axis=1'dir. Nihayet n indeksiyle belirttiğimiz 
    üçüncü boyut ise axis=2'dir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi eksensel işlemler yapan bazı fonksiyonlara ve metotlara değinelim:

    - sum fonksiyonu ve ndarray sınıfınıun sum metodu eksensel toplama işlemi yapmaktadır. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> result = np.sum(a, axis=1)
    >>> result
    array([ 6, 15, 24])
    >>> result = np.sum(a, axis=0)
    >>> result
    array([12, 15, 18])
    >>> result = np.sum(a)
    >>> result
    45
    >>> result = a.sum(axis=1)
    >>> result
    array([ 6, 15, 24])
    >>> result = a.sum(axis=0)
    >>> result
    array([12, 15, 18])
        
    - mean isimli fonksiyon ve ndarray sınıfının mean metodu eksen temelinde aritmetik ortalama işlemi yapmaktadır. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> result = np.mean(a, axis=0)
    >>> result
    array([4., 5., 6.])
    >>> result = a.mean(axis=0)
    >>> result
    array([4., 5., 6.])

    - Median işlemi median fonksiyonu ile yapılmaktadır. (ndarray sınıfının böyle bir metodu yoktur.) Eğer değerler çift ise ortadaki 
    iki değerin aritmetik ortalaması median olarak elde edilmektedir. Örneğin:

    >>> a = np.random.randint(0, 100, (10, 10))
    >>> a
    array([[58, 14, 13, 19, 76, 50, 78, 82, 63, 77],
        [77, 11, 28, 32, 65, 74,  4, 54, 53, 79],
        [32, 23, 91, 89, 12, 71, 31, 46, 69, 30],
        [94, 50,  8, 76, 28, 32, 63, 76, 97, 74],
        [97, 58, 36, 56,  5,  7, 47, 15, 16, 95],
        [29, 25, 83, 72, 31, 17, 90, 34, 57, 37],
        [18, 92, 98, 92, 62, 97, 94, 69, 12, 38],
        [54, 49, 54, 41, 18, 91, 65, 70, 49, 42],
        [51, 27, 95, 55, 74, 52, 85, 95, 15, 24],
        [90, 28, 42, 33, 89,  2, 58, 54, 53,  7]])
    >>> result = np.median(a, axis=0)
    >>> result
    array([56. , 27.5, 48. , 55.5, 46.5, 51. , 64. , 61.5, 53. , 40. ])

    - Standart sapma hesabı için std isimli fonksiyon ya da ndarray sınıfının std metodu, varyans hesabı için var isimli fonksiyon ya da ndarray 
    sınıfının var metodu kullanılmaktadır. Burada default olarak bölüm n değerine yapılır. Bu fonksiyonların ve metotların ddof parametreleri 
    bölümün "n - ddof" olarak yapılmasını sağlamaktadır. Bu metotlarda ve fonksiyonlarda ddof için default değer 0'dır. Eğer n-1'e bölme 
    yapılmak isteniyorsa ddof=1 girilmelidir. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> result = np.std(a, axis=0)
    >>> result
    array([2.44948974, 2.44948974, 2.44948974])

    >>> result = np.var(a, axis=0)
    >>> result
    array([6., 6., 6.])
    >>> result = a.std(axis=0)
    >>> result
    array([2.44948974, 2.44948974, 2.44948974])
    >>> result = a.var(axis=0)
    >>> result
    array([6., 6., 6.])

    - max ve min fonksiyonları ve ndarray sınıfının min ve nax metotları eksensel en büyük ve en küçük değerleri bulmaktadır. Örneğin:

    >>> a = np.array([[1, 6, 3], [4, 8, 2], [1, 2, 9]])
    >>> a
    array([[1, 6, 3],
        [4, 8, 2],
        [1, 2, 9]])
    >>> result = np.max(a, axis=0)
    >>> result
    array([4, 8, 9])
    >>> result = np.max(a, axis=1)
    >>> result
    array([6, 8, 9])
    >>> result = np.max(a)
    >>> result
    9
    >>> result = a.max(axis=0)
    >>> result
    array([4, 8, 9])
    >>> result = a.min(axis=0)
    >>> result
    array([1, 2, 2])

    Ayrıca NumPy'da bir de maximum ve minimum isimli iki fonksiyon vardır. (ndarray sınıfının maximum ve minimum isimli metotları 
    yoktur.) Ancak bu fonksiyonlar karşılık ikş ya da fazla değerin ya da karşılıklı iki ya da daha fazla NumPy dizisinin maksimum 
    ve minimum elemanlarını bulmaktadır. Bu fonksiyonların axis parametreleri yoktur. Örneğin:

    >>> result = np.maximum(10, 5)
    >>> result
    10
    >>> result = np.maximum([1, 3, 7], [2, 1, 9])
    >>> result
    array([2, 3, 9])

    - arxmax ve argmin fonksiyonları ve ndarray sınıfının argmax ve argmin metotları eksen temelinde en büyük ve en küçük elemanları 
    değil onların indekslerini vermektedir. Bu işlem özellikle makine öğrenmesinde yaygın biçimde kullanılmaktadır. Örneğin:

    >>> a = np.array([[1, 9, 3], [8, 7, 1], [6, 4, 5]])
    >>> a
    array([[1, 9, 3],
        [8, 7, 1],
        [6, 4, 5]])
    >>> result = np.argmax(a, axis=0)
    >>> result
    array([1, 0, 2], dtype=int64)
    >>> result = a.argmax(axis=0)
    >>> result
    array([1, 0, 2], dtype=int64)
    >>> result = a.argmin(axis=0)
    >>> result
    array([0, 2, 1], dtype=int64)

    -  prod fonksiyonu  ve ndarray sınıfının prod metodu eksen temelinde çarpım değerlerini elde etmek için kullanılmaktadır. 
    Örneğin:

    >>> a = np.array([[1, 9, 3], [8, 7, 1], [6, 4, 5]])
    >>> a
    array([[1, 9, 3],
        [8, 7, 1],
        [6, 4, 5]])  
    >>> result = np.prod(a, axis=0)
    >>> result
    array([ 48, 252,  15])
    >>> result = a.prod(axis=0)
    >>> result
    array([ 48, 252,  15])

    - cumsum isimli fonksiyon ve ndarray sınıfının metodu kümülatif toplamlardan oluşan numpy dizisi vermektedir. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> result = np.cumsum(a, axis=0)
    >>> result
    array([[ 1,  2,  3],
        [ 5,  7,  9],
        [12, 15, 18]])
    >>> result = a.cumsum(axis=0)
    >>> result
    array([[ 1,  2,  3],
        [ 5,  7,  9],
        [12, 15, 18]])

    -  sort fonksiyonu ve ndarray sınıfının sort metodu axis temelinde sıraya dizme işlemi yapar. Bu fonksiyonda axis için değer girilmezse 
    default olarak son eksen değeri alınır. sort fonksşyonu in-place işlem yapmamakta ancak sort metodu in-place işlem yapmaktadır. Örneğin:

    >>> a = np.random.randint(0, 100, (10, 10))
    >>> a
    array([[ 8,  7, 38,  8, 40, 78, 39, 19, 93, 21],
        [99, 23, 65, 80, 90, 90, 83, 61, 78, 44],
        [78, 48, 58, 28, 41, 12, 88,  8, 26, 70],
        [ 6, 31, 51, 71, 75, 14, 60, 81, 93, 50],
        [ 4, 92, 72, 89, 80, 94, 70, 16, 17, 90],
        [40, 27,  2, 10,  8, 29, 71, 34, 34, 92],
        [82, 97, 15, 90, 57, 42, 33, 91, 11, 20],
        [47, 10, 43, 95, 40, 67, 88, 68, 53, 44],
        [86, 17, 16, 18, 87, 75,  6, 49, 23, 31],
        [96, 37, 33, 13, 67,  7, 70,  0, 86, 13]])
    >>> result = np.sort(a, axis=0)
    >>> result
    array([[ 4,  7,  2,  8,  8,  7,  6,  0, 11, 13],
        [ 6, 10, 15, 10, 40, 12, 33,  8, 17, 20],
        [ 8, 17, 16, 13, 40, 14, 39, 16, 23, 21],
        [40, 23, 33, 18, 41, 29, 60, 19, 26, 31],
        [47, 27, 38, 28, 57, 42, 70, 34, 34, 44],
        [78, 31, 43, 71, 67, 67, 70, 49, 53, 44],
        [82, 37, 51, 80, 75, 75, 71, 61, 78, 50],
        [86, 48, 58, 89, 80, 78, 83, 68, 86, 70],
        [96, 92, 65, 90, 87, 90, 88, 81, 93, 90],
        [99, 97, 72, 95, 90, 94, 88, 91, 93, 92]])
    >>> result = np.sort(a)
    >>> result
    array([[ 7,  8,  8, 19, 21, 38, 39, 40, 78, 93],
        [23, 44, 61, 65, 78, 80, 83, 90, 90, 99],
        [ 8, 12, 26, 28, 41, 48, 58, 70, 78, 88],
        [ 6, 14, 31, 50, 51, 60, 71, 75, 81, 93],
        [ 4, 16, 17, 70, 72, 80, 89, 90, 92, 94],
        [ 2,  8, 10, 27, 29, 34, 34, 40, 71, 92],
        [11, 15, 20, 33, 42, 57, 82, 90, 91, 97],
        [10, 40, 43, 44, 47, 53, 67, 68, 88, 95],
        [ 6, 16, 17, 18, 23, 31, 49, 75, 86, 87],
        [ 0,  7, 13, 13, 33, 37, 67, 70, 86, 96]])
    
    - argsort fonksiyonu ve ndarray sınıfının argsort metodu dizinin kendisini değil indekslerini sıraya dizer ve sıraya 
    dizilmiş indeks dizisi ile geri döner. Yani hem fonksiyon hem de metot in-place işlem yapmamaktadır.Örneğin:

    >>> a = np.random.randint(0, 100, (10, 10))
    >>> a
    array([[52, 68, 19, 79, 88, 17, 58, 39, 48, 24],
        [89, 61, 50, 69, 50, 79, 53, 40,  4, 85],
        [23, 45, 43,  3, 97, 41, 62, 97, 20, 41],
        [40, 22, 94, 34, 60,  2, 25, 44,  0, 65],
        [29, 28, 23, 55, 31, 86, 89, 37, 31, 46],
        [37, 68, 55, 13, 32, 55,  4, 31, 24, 21],
        [80, 54, 59, 78, 50, 64, 51, 73, 28, 77],
        [43, 15, 99, 36, 36, 98, 79, 87, 21,  3],
        [23, 62, 93, 79, 94,  5, 16, 36, 20, 95],
        [ 4, 26, 92, 71, 66, 23, 11, 99, 66, 98]])
    >>> result = np.argsort(a, axis=0)
    >>> result
    array([[9, 7, 0, 2, 4, 3, 5, 5, 3, 7],
        [2, 3, 4, 5, 5, 8, 9, 8, 1, 5],
        [8, 9, 2, 3, 7, 0, 8, 4, 2, 0],
        [4, 4, 1, 7, 1, 9, 3, 0, 8, 2],
        [5, 2, 5, 4, 6, 2, 6, 1, 7, 4],
        [3, 6, 6, 1, 3, 5, 1, 3, 5, 3],
        [7, 1, 9, 9, 9, 6, 0, 6, 6, 6],
        [0, 8, 8, 6, 0, 1, 2, 7, 4, 1],
        [6, 0, 3, 0, 8, 4, 7, 2, 0, 8],
        [1, 5, 7, 8, 2, 7, 4, 9, 9, 9]], dtype=int64)
    >>> result = a.argsort(axis=0)
    >>> result
    array([[9, 7, 0, 2, 4, 3, 5, 5, 3, 7],
        [2, 3, 4, 5, 5, 8, 9, 8, 1, 5],
        [8, 9, 2, 3, 7, 0, 8, 4, 2, 0],
        [4, 4, 1, 7, 1, 9, 3, 0, 8, 2],
        [5, 2, 5, 4, 6, 2, 6, 1, 7, 4],
        [3, 6, 6, 1, 3, 5, 1, 3, 5, 3],
        [7, 1, 9, 9, 9, 6, 0, 6, 6, 6],
        [0, 8, 8, 6, 0, 1, 2, 7, 4, 1],
        [6, 0, 3, 0, 8, 4, 7, 2, 0, 8],
        [1, 5, 7, 8, 2, 7, 4, 9, 9, 9]], dtype=int64)

    NumPy kütüphanesinde çok fazla fonksiyon ve ndarray sınıfının metodu bulunmaktadır. NumPy dokümanlarından bunlara gerektiğinde 
    başvurabilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy kütüphanesinde bir NumPy dizisinin her elemanı üzerinde işlem yapan ancak axis parametresine sahip olmayan pek çok klasik 
    matematiksel fonksiyon ve ndarray sınıfının metodu da vardır. Bunlardan bazıları şunlardır: sqrt, square, power, log, log10, log2, 
    round, exp, sin, cos, tan, arcsin, arccos, arctan, lcm (okek), gcd (obeb). Örneğin karekök gibi, sin, cos gibi işlemler zaten 
    birdne değer üzerinde uygulanan işlemler değildir. Dolayısıyla bunların eksensel yapılması söz konusu olamaz. Örneğin:

    >>> a = np.random.random((5, 5))
    >>> a
    array([[0.7697629 , 0.94185538, 0.39760624, 0.89994749, 0.03884618],
        [0.95536686, 0.57196936, 0.1364953 , 0.63398182, 0.52060019],
        [0.46564122, 0.94068844, 0.20854218, 0.77252757, 0.62490003],
        [0.12142791, 0.8926136 , 0.62890967, 0.37622973, 0.71989936],
        [0.52172981, 0.20142574, 0.08345288, 0.24866786, 0.04276729]])
    >>> result = np.sin(a)
    >>> result
    array([[0.695965  , 0.80865099, 0.38721243, 0.78329427, 0.03883641],
        [0.81652559, 0.54128901, 0.13607185, 0.5923575 , 0.4974009 ],
        [0.44899584, 0.80796394, 0.20703389, 0.69794758, 0.5850162 ],
        [0.12112973, 0.77871412, 0.58826339, 0.36741652, 0.659309  ],
        [0.49838056, 0.20006645, 0.08335605, 0.24611301, 0.04275425]])
    >>> result = np.power(a, 2)
    >>> result
    array([[0.59253492, 0.88709155, 0.15809072, 0.80990548, 0.00150903],
        [0.91272584, 0.32714895, 0.01863097, 0.40193295, 0.27102455],
        [0.21682174, 0.88489475, 0.04348984, 0.59679884, 0.39050004],
        [0.01474474, 0.79675904, 0.39552737, 0.14154881, 0.51825508],
        [0.272202  , 0.04057233, 0.00696438, 0.0618357 , 0.00182904]])
    >>> result = np.log(a)
    >>> result
    array([[-0.26167274, -0.05990354, -0.92229312, -0.10541887, -3.24814547],
        [-0.04565986, -0.55866985, -1.9914651 , -0.455735  , -0.65277293],
        [-0.76433986, -0.06114329, -1.56761393, -0.25808759, -0.4701636 ],
        [-2.1084345 , -0.11360149, -0.46376764, -0.97755534, -0.32864386],
        [-0.65060542, -1.60233452, -2.48347311, -1.39163717, -3.1519818 ]])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi Python operatörleri de NumPy dizilerine uygulandığında karşılıklı elemanlar üzerinde işlemler 
    yapar. Aslında bunların fonksiyon karşılıkları da vardır. Tabii bunlar da axis parametresi almamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[8, 2, 18], [11, 23, 5], [1, 4, 32]], dtype=np.float32)
b = np.array([[1, 3, 5], [1, 4, 3], [1, 4, 2]], dtype=np.float32)

c = a * b
print(c)

c = np.multiply(a, b)
print(c)

#------------------------------------------------------------------------------------------------------------------------------------
    where isimli fonksiyon tipik olarak bir bool dizi ve iki de dizi parametresi almaktadır. Bu bool dizinin uzunluğunun bu iki dizinin
    uzunluğu kadar olması gerekir. Bu fonksiyon eğer bool dizideki eleman True ise birinci dizideki elemanı, False ise ikinci dizideki 
    elemanı vermektedir. Örneğin:

    >>> a = np.array([3, 6, 3, 8, 9, 5, 8])
    >>> b = np.array([8, 4, 2, 7, 5, 6, 4])
    >>> a
    array([3, 6, 3, 8, 9, 5, 8])
    >>> b
    array([8, 4, 2, 7, 5, 6, 4])
    >>> result = np.where([True, False, True, True, False, True, False], a, b)
    >>> result
    array([3, 4, 3, 8, 5, 5, 4])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii aslında where fonksiyonun birinci parametresi genellikle koşul operatörü ile oluşturulmaktadır. where fonksiyonu çok boyutlu 
    dizilerde de benzer biçimde kullanılabilir. Örneğin:

    >>> a = np.array([3, 6, 3, 8, 9, 5, 8])
    >>> b = np.array([8, 4, 2, 7, 5, 6, 4])
    >>> a
    array([3, 6, 3, 8, 9, 5, 8])
    >>> b
    array([8, 4, 2, 7, 5, 6, 4])
     >>> result = np.where(a > 4, a, b)
    >>> result
    array([8, 6, 2, 8, 9, 5, 8])

    Burada eğer a dizisindeki eleman 4'ten büyük ise a dizisindeki eleman, değilse b dizisindeki eleman elde edilmiştir. 

    Aslında where fonksiyonunun parametreleri bir skaler de olabilir. Bu durumda koşulun sağlandığı ya da sağlanmadığı elemanlar 
    belli değerlerle doldurulmuş olur. Örneğin:

    >>> a = np.random.randint(0, 100, 10)
    >>> b = np.random.randint(0, 100, 10)
    >>> a
    array([12, 57, 78, 57, 35, 23, 31, 70, 27, 66])
    >>> b
    array([ 4,  7, 49, 44,  5, 55, 47, 15,  8, 76])
    >>> result = np.where(a > 50, a, -1)
    >>> result
    array([-1, 57, 78, 57, -1, -1, -1, 70, -1, 66])

    Burada a'daki 50'den büyük elemanlar için a'daki değer, 50'den küçük elemanlar için -1 değeri elde edilmektedir. 
        
    where fonksiyonu aslında parametresiz de kullanılabilmektedir. Bu durumda koşulu sağlayan dizi elemanlarının indeksleri 
    elde edilmektedir. Örneğin:

    >>> a = np.random.randint(0, 100, 10)
    >>> a
    array([56, 65, 62, 34, 69, 56,  9, 36, 50,  1])
    >>> result = np.where(a > 50)
    >>> result
    (array([0, 1, 2, 4, 5], dtype=int64),)

    Burada a dizisinde 50'dem büyük olan değerlerin indeksleri elde edilmiştir. Tabii biz NumPy dizilerini dolaşılabilir nesnelerle 
    indeksleyebildiğimize göre buran elde edilen result dizisiyle de indeksleyebiliri<. Örneğin:

    >>> a[result]
    array([56, 65, 62, 69, 56])

    where fonksiyonun bir metot karşılığı yoktur. Parametresiz where fonksiyonu nasıl yazılmış olabilir? En basit yazım yöntemi 
    dizi içerisindeki True olan değerlerin indesklerini elde etmektir. Örneğin:

    def mywhere(condition):
        return [index for index, val in enumerate(condition) if val]
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    clip fonksiyonu ve ndarray sınıfının clip metodu bizden bir NumPy dizisi ve min, max değerlerini almaktadır. Fonksiyon min 
    değerinden düşük olanları min değerine, max değerinden büyük olanları ise max değerine çekerek bize yeni bir NumPy dizisi verir. 
    min ve max arasındaki değerlere dokunmaz. Yani clip fonksiyonu ile elde edilen dizi kesinlikle [min, max] arası değerlere sahip 
    olacaktır. Örneğin:

    >>> a = np.random.randint(0, 10, 10)
    >>> a
    array([9, 7, 5, 4, 8, 3, 5, 0, 1, 1])
    >>> result = np.clip(a, 4, 7)
    >>> result
    array([7, 7, 5, 4, 7, 4, 5, 4, 4, 4])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy dizilerine satır ve sütun eklemek isteyebiliriz. Pek çok veri analizi uygulamasında bu tür işlemler gerekebilmektedir. Örneğin
    elimizdeki veri tablosunda kişilerin boy ve kiloları sütunlar halinde bulunuyor olabilir. Biz de bu boy ve kilo bilgisinden hareketle
    tabloya "vücut kitle endeksi (body mass index)" sütunu eklemek isteyebiliriz. Ya da örneğin veri tablosunda kişilerin isimleri de 
    olabilir. İsimlerin veri analizinde önemi olmadığı için bu isim sütununu silmek isteyebiliriz. 

    Ancak maalesef bu tür işlemler NumPy'da göreli olarak yavaştır. Çünkü bu tür işlemlerde çoğu durumda "view" oluşturulamamaktadır. 
    Dolayısıyla programcının bir döngü içerisinde bir NumPy dizisine sürekli satır eklemesi gibi işlemler (böyle şeyleri Python listeleri 
    üzerinde yapmıştık) iyi teknik kabul edilmemektedir. Bu tür durumlarda programcının mümkün olduğu kadar işin başında NumPy dizisinin 
    boyutlarını tespit etmeye çalışması ve diziyi işin başında bir kez zeros gibi bir fonksiyonla yaratması ve döngü içerisinde satır, 
    sütun eklemek yerine satır güncellemesi yapması uygundur. Tabii her zaman işin başında bir dizinin boyutlarını belirleme olasılığımız 
    olmayabilir. NumPy dizileri üzerinde "in-place" işlemler genellikle yapılamamaktadır. Bu nedenle genellikle bu tür işlemler dizinin 
    kendi üzerinde yapılmaz, işlem sonucunda bu işlemlerin yapılmış olduğu yeni bir dizi elde edilir.

    Daha önceden de belirttiğimiz gibi NumPy'da ekleme ve silme gibi işlemlerde axis paraetresi bu işlemin sonucunda değişikliğin 
    oluştuğu ekseni belirtmektedir. Örneğin biz iki boyutlu bir NumPy dizisine satır eklemek istersek burada satır bu dizinin ilk 
    boyutu üzerinde değişiklik yaratır. Bu nedenle satır ekleme işleminde axis=0 girilmelidir. Sütun eklemelerinde ise axis=1 olmalıdır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisine eksensel bir ekleme (örneğin satır, sütun eklemesi için) append fonksiyonu kullanılır. append her zaman NumPy 
    dizisinin yeni bir kopyasını oluşturur. Yani in-place işlem yapmaz. append fonksiyonunun birinci parametresi eklemenin yapılacağı 
    NumPy dizisini, ikinci parametresi eklenecek değerlerin bulunduğu NumPy dizisini belirtmektedir. append fonksiyonunda biz her zaman 
    ana diziyle aynı satır ya da sütun sayısına sahip bir dizi eklemeliyiz. Örneğin iki bir boyutlu bir diziye tek bir satır ekleyeceksek 
    bu satırın sanki tek satırlık bir matris gibi olması gerekir. Benzer biçimde iki boyutlu bir diziye tek bir sütun ekleyeceksek bu 
    sütunun sanki tek sütunlu bir matris biçiminde olması gerekir. Örneğin:

    >> a = np.random.randint(0, 100, (5, 5))
    >>> a
    array([[84, 39, 66, 84, 47],
        [61, 48,  7, 99, 92],
        [52, 97, 85, 94, 27],
        [34, 97, 76, 40,  3],
        [69, 64, 75, 34, 58]])
    >>> b = np.append(a, [[1], [2], [3], [4], [5]], axis=1)
    >>> b
    array([[84, 39, 66, 84, 47,  1],
        [61, 48,  7, 99, 92,  2],
        [52, 97, 85, 94, 27,  3],
        [34, 97, 76, 40,  3,  4],
        [69, 64, 75, 34, 58,  5]])
    >>> b = np.append(a, [[1, 2, 3, 4, 5]], axis=0)
    >>> b
    array([[84, 39, 66, 84, 47],
        [61, 48,  7, 99, 92],
        [52, 97, 85, 94, 27],
        [34, 97, 76, 40,  3],
        [69, 64, 75, 34, 58],
        [ 1,  2,  3,  4,  5]])

    Burada matrise sütun eklerken eklenecek sütunun bir sütun vektörü biçiminde satır eklerken eklenecek satırın bir satır vektörü 
    biçiminde verildiğine dikkat ediniz. Eklenecek NumPy dizisi orijinal dizi ile aynı boyutsal değerde olmalıdır. (Yani örneğin iki
    boyutlu bir NumPy dizisine iki boyutlu bir NumPy dizisi ekleyebiliriz.)

    Tek hamlede birden fazla satır ve sütun da eklenebilir. Örneğin:

    >>> a
    array([[84, 39, 66, 84, 47],
        [61, 48,  7, 99, 92],
        [52, 97, 85, 94, 27],
        [34, 97, 76, 40,  3],
        [69, 64, 75, 34, 58]])

    >>> b = np.append(a, np.array([[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]]), axis=1)
    >>> b
    array([[84, 39, 66, 84, 47,  1,  1],
        [61, 48,  7, 99, 92,  2,  2],
        [52, 97, 85, 94, 27,  3,  3],
        [34, 97, 76, 40,  3,  4,  4],
        [69, 64, 75, 34, 58,  5,  5]])

    Burada tek hemlede iki sütun eklenmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Mademki append bizden aynı boyutta bir dizi istemektedir. O zaman onu aynı boyuta getirmek için reshape işlemi yapabiliriz. 
    Örneğin:

  >>> a
    array([[84, 39, 66, 84, 47],
        [61, 48,  7, 99, 92],
        [52, 97, 85, 94, 27],
        [34, 97, 76, 40,  3],
        [69, 64, 75, 34, 58]])
    >>> b = np.append(a, np.array([1, 2, 3, 4, 5]).reshape(-1, 1), axis=1)
    >>> b
    array([[84, 39, 66, 84, 47,  1],
        [61, 48,  7, 99, 92,  2],
        [52, 97, 85, 94, 27,  3],
        [34, 97, 76, 40,  3,  4],
        [69, 64, 75, 34, 58,  5]])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    append işleminde eksen belirtilmezse (axis parametresinin default değeri None biçimindedir). Eklemenin yapılacağı dizi ve eklenecek 
    dizi önce flatten işlemiyle tek boyuta indirgenir. Sonra işlem yapılır. Bu işleme bazen seyrek de olsa gereksinim duyulmaktadır. 
    Bu durumda append yapılacak değerler herhangi bir boyutta girilebilir. Zaten bu değerler de flatten işlemine sokulmaktadır. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> b = np.array([10, 20, 30])
    >>> b
    array([10, 20, 30])
    >>> result = np.append(a, b)
    >>> result
    array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 20, 30])

    >>> b = np.array([[10], [20], [30]])
    >>> result = np.append(a, b)
    >>> result
    array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 20, 30])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında append fonksiyonun concatenate isminde daha genel bir biçimi de vardır. concatenate fonksiyonu birden fazla NumPy dizisini 
    bir dizi ya da demet olarak alır onları peşi dıra brirleştirir, birleştirilmiş diziyle geri döner. concatenate fonksiyonun da 
    axis parametresi vardır. eğer sütunsal ekleme yapılıyorsa dizilerin satır uzunluklarının, satırsal ekleme yapılıyorsa dizilerin 
    sütun uzunluklarının aynı olması gerekir. Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3))
    >>> b = np.random.randint(0, 100, (3, 2))
    >>> c = np.random.randint(0, 100, (3, 1))
    >>> a
    array([[10, 22, 77],
        [18, 15, 27],
        [30, 52, 70]])
    >>> b
    array([[26, 80],
        [ 6, 14],
        [75, 54]])
    >>> c
    array([[71],
        [ 1],
        [43]])
    >>> result = np.concatenate((a, b, c), axis=1)
    >>> result
    array([[10, 22, 77, 26, 80, 71],
        [18, 15, 27,  6, 14,  1],
        [30, 52, 70, 75, 54, 43]])

    Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3))
    >>> b = np.random.randint(0, 100, (2, 3))
    >>> c = np.random.randint(0, 100, (1, 3))
    >>> a
    array([[58, 55, 25],
        [50, 84, 56],
        [49, 12, 18]])
    >>> b
    array([[81,  1, 51],
        [44, 48, 56]])
    >>> c
    array([[91, 49, 86]])
    >>> result = np.concatenate((a, b, c), axis=0)
    >>> result
    array([[58, 55, 25],
        [50, 84, 56],
        [49, 12, 18],
        [81,  1, 51],
        [44, 48, 56],
        [91, 49, 86]])

    concatenate fonksiyonunda axis belirtilmezse default durumda axis boyut sayısından bir eksik alınmaktadır. (Yani örneğin iki 
    boyutlu eklemelerde default durum axis=0 biçimindedir.) axis belirtilmediği durumda flatten işlemi yapılmamaktadır. Aslında 
    NumPy'ın kaynak kodlarına bakıldığında append fonksiyonunun zaten concatenate kullanılarak yazıldığı görülmektedir:

    def append(arr, values, axis=None): 
        arr = asanyarray(arr)
        if axis is None:
            if arr.ndim != 1:
                arr = arr.ravel()
            values = ravel(values)
            axis = arr.ndim-1
        return concatenate((arr, values), axis=axis)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    append ve concatenate fonksiyonlarına benzer hstack ve vstack fonksiyonları da vardır. Bu fonksiyonlar da aslında concatenate 
    kullanılarak yazılmıştır. hstack(t) çağrısı concatenate(t, axis=1) ile vstack(t) çağrısı da concatenate(t, axis=1) çağrısı ile 
    yaklaşık eşdeğerdir. Yani hstack sütun eklemelerde vstack ise satır eklemelerde kullanılır. Yine eklenecek değerler bu fonksiyonlara
    demet ya da dizi biçiminde verilmektedir. Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3))
    >>> b = np.random.randint(0, 100, (3, 2))
    >>> c = np.random.randint(0, 100, (3, 1))
    >>> a
    array([[ 3, 67, 11],
        [21, 89, 98],
        [ 3, 11,  3]])
    >>> b
    array([[94,  6],
        [ 9, 87],
        [14, 83]])
    >>> c
    array([[70],
        [12],
        [54]])
    >>> result = np.hstack((a, b, c))
    >>> result
    array([[ 3, 67, 11, 94,  6, 70],
        [21, 89, 98,  9, 87, 12],
        [ 3, 11,  3, 14, 83, 54]])
    >>> result = np.concatenate((a, b, c), axis=1)
    >>> result
    array([[ 3, 67, 11, 94,  6, 70],
        [21, 89, 98,  9, 87, 12],
        [ 3, 11,  3, 14, 83, 54]])

    vstack ise satır eklemelerinde kullanılmaktadır. Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3))
    >>> b = np.random.randint(0, 100, (2, 3))
    >>> c = np.random.randint(0, 100, (1, 3))
    >>> a
    array([[27, 38, 17],
        [61, 74, 99],
        [99, 65, 47]])
    >>> b
    array([[16,  5, 86],
        [46, 15, 59]])
    >>> c
    array([[40, 25, 45]])
    >>> result = np.vstack((a, b, c))
    >>> result
    array([[27, 38, 17],
        [61, 74, 99],
        [99, 65, 47],
        [16,  5, 86],
        [46, 15, 59],
        [40, 25, 45]])
    >>> result = np.concatenate((a, b, c), axis=0)
    >>> result
    array([[27, 38, 17],
        [61, 74, 99],
        [99, 65, 47],
        [16,  5, 86],
        [46, 15, 59],
        [40, 25, 45]])   
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    hstack ve stack fonksiyonlarına benzer column_stack ve row_stack isimli fonksiyonlar da vardır. Bu fonksiyonlar tek boyutlu 
    ya da iki boyutlu NumPy dizilerini demet olarak almaktadır. Bunlara demetler tek boyutlu dizi olarak da verilebilmektedir. Bunlar 
    her zaman iki boyutlu dizi vermektedir. Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3))
    >>> a
    array([[77,  8, 78],
        [ 6, 65, 94],
        [70, 40, 74]])
    >>> b = np.array([1, 2, 3])
    >>> b
    array([1, 2, 3])
    >>> c = np.column_stack((a, b))
    >>> c
    array([[77,  8, 78,  1],
        [ 6, 65, 94,  2],
        [70, 40, 74,  3]])

    Örneğin:

    >>> a = np.random.randint(0, 100, (3, 3))
    >>> a
    array([[76, 76, 25],
        [ 7, 13, 44],
        [ 1, 41, 78]])
    >>> a = np.array([1, 2, 3])
    >>> b = np.array([4, 5, 6])
    >>> c = np.array([7, 8, 9])
    >>> a
    array([1, 2, 3])
    >>> b
    array([4, 5, 6])
    >>> c
    array([7, 8, 9])
    >>> result = np.column_stack((a, b, c))
    >>> result
    array([[1, 4, 7],
        [2, 5, 8],
        [3, 6, 9]])

    Tabii girdiğimiz parametrelerin birer NumPy dizisi olamsı da zorunlu değildir. Örneğin:

    >>> result = np.column_stack((a, b, c))
    >>> result
    array([[1, 4, 7],
        [2, 5, 8],
        [3, 6, 9]])
    >>> result = np.column_stack(([1, 2, 3], [4, 5, 6], [7, 8, 9]))
    >>> result
    array([[1, 4, 7],
        [2, 5, 8],
        [3, 6, 9]])
    
    Burada bir noktaya dikkat ediniz. Bu fonksiyonlar her zaman bir boyutlu ya da iki boyutlu dizilerden oluşan demet ya da dizileri 
    alarak her zaman iki boyutlu diziler vermektedir. row_stack fonksiyonu da benzerdir:

    >>> result = np.row_stack(([1, 2, 3], [4, 5, 6], [7, 8, 9]))
    >>> result
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])

    Bu fonksiyonlarda da axis parametresinin olmadığına dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------------------
<BURADA KALDIM>
#------------------------------------------------------------------------------------------------------------------------------------
    insert isimli fonksiyon bizden bir NumPy dizisini, insert edilecek pozisyonu ve insert edilecek değerleri almaktadır. Insert işlemi
    insert edilmek istenen değerler insert pozisyonunda olacak biçimde diğer değerlerin kaydırılması yoluyla yapılmaktadır. Ancak 
    insert fonksiyonunda insert edilecek dizi append fonksiyonunda olduğu gibi oluşturulmamaktadır. insert fonksiyonunda insert edilecek 
    dizi dolaşıldığında satırlara ya da sütunlara insert edilecek değerler elde edilmelidir. Dolayısıyla insert edilecek dizi tek boyutlu 
    olarak da verilebilir. axis parametresi 0 girilirse satır, 1 girilirse sütun insert edilmektedir. Örneğin:

    >>> b = np.random.randint(0, 100, (3, 2))
    >>> a = np.random.randint(0, 100, (3, 5))
    >>> a
    array([[92, 75, 10,  3, 45],
        [58, 59, 23, 25, 27],
        [57,  3, 99, 78, 85]])
    >>> b = np.array([1, 2, 3])
    >>> result = np.insert(a, 2, b, axis=1)
    >>> result
    array([[92, 75,  1, 10,  3, 45],
        [58, 59,  2, 23, 25, 27],
        [57,  3,  3, 99, 78, 85]])
    >>> a = np.random.randint(0, 100, (3, 5))
    >>> a
    array([[59, 48, 56, 87, 87],
        [ 4, 69, 56, 60,  9],
        [66, 33, 69,  9, 79]])
    >>> result = np.insert(a, 1, [10, 20, 30, 40, 50], axis=0)
    >>> result
    array([[59, 48, 56, 87, 87],
        [10, 20, 30, 40, 50],
        [ 4, 69, 56, 60,  9],
        [66, 33, 69,  9, 79]])

    Görüldüğü gibi bir matrise satır ve sütun insert ederken biz insert edilecek diziyi tek boyutlu olarak verdik. Eğer birden 
    fazla satır ya da sütun insert edilecekse bu satır ya da sütun bilgileri her zaman iki boyutlu dolaşılabilir bir nesne biçiminde 
    verilmelidir. insert fonksiyonu girilen bu nesneyi dolaşarak insert edilecek satır ya da sütunları elde eder. Örneğin:

    >>> a = np.random.randint(0, 100, (3, 5))
    >>> a
    array([[28, 66, 10,  3, 48],
        [ 3, 23, 91, 55, 34],
        [37, 49, 87, 85, 25]])
    >>> b = np.array([[10, 20, 30], [40, 50, 60]])
    >>> b
    array([[10, 20, 30],
        [40, 50, 60]])
    >>> result = np.insert(a, 2, b, axis=1)
    >>> result
    array([[28, 66, 10, 40, 10,  3, 48],
        [ 3, 23, 20, 50, 91, 55, 34],
        [37, 49, 30, 60, 87, 85, 25]])
    >>> b = np.array([[10, 20, 30, 40, 50], [60, 70, 80, 90, 100]])
    >>> b
    array([[ 10,  20,  30,  40,  50],
        [ 60,  70,  80,  90, 100]])
    >>> result = np.insert(a, 1, b, axis=0)
    >>> result
    array([[ 28,  66,  10,   3,  48],
        [ 10,  20,  30,  40,  50],
        [ 60,  70,  80,  90, 100],
        [  3,  23,  91,  55,  34],
        [ 37,  49,  87,  85,  25]])

    insert işleminde insert edilecek değer bir skaler de olabilir. Bu durumda ilgili satır ya da sütun o değerle doldurulur. 
    Örneğin:
    
    >>> a = np.random.randint(0, 100, (3, 5))
    >>> a
    array([[17, 58, 66, 45, 10],
        [ 8, 96, 25, 99, 67],
        [65,  7, 70, 99, 97]])
    >>> result = np.insert(a, 2, 0, axis=1)
    >>> result
    array([[17, 58,  0, 66, 45, 10],
        [ 8, 96,  0, 25, 99, 67],
        [65,  7,  0, 70, 99, 97]])
    >>> a
    array([[17, 58, 66, 45, 10],
        [ 8, 96, 25, 99, 67],
        [65,  7, 70, 99, 97]])
    >>> result = np.insert(a, 1, 0, axis=0)
    >>> result
    array([[17, 58, 66, 45, 10],
        [ 0,  0,  0,  0,  0],
        [ 8, 96, 25, 99, 67],
        [65,  7, 70, 99, 97]])

    Bu yöntemle birden fazla satır ya da sütun da insert edilebilir. Ancak yine bunların iki boyutlu tek elemandan oluşan diziler
    biçiminde verilmesi gerekir. Örneğin:

    >>> a = np.random.randint(0, 100, (3, 5))
    >>> a
    array([[39, 82, 92, 38,  5],
        [ 9, 40, 68, 87, 21],
        [89, 50, 36, 44, 92]])
    >>> result = np.insert(a, 1, [[0], [1]], axis=1)
    >>> result
    array([[39,  0,  1, 82, 92, 38,  5],
        [ 9,  0,  1, 40, 68, 87, 21],
        [89,  0,  1, 50, 36, 44, 92]])
    >>> result = np.insert(a, 1, [[0], [1]], axis=0)
    >>> result
    array([[39, 82, 92, 38,  5],
        [ 0,  0,  0,  0,  0],
        [ 1,  1,  1,  1,  1],
        [ 9, 40, 68, 87, 21],
        [89, 50, 36, 44, 92]])

    Burada 0'larla ve 1'lerle dolu iki sütun ve satır insert edilmiştir. 

    Insert işleminde de axis belirtilmezse önce insert işleminin uygulanacağı dizi flatten yapılıp tek boyuta dönüştürülür, sonra insert 
    o noktaya yapılır. Örneğin:

   >>> a = np.random.randint(0, 100, (3, 5))
    >>> a
    array([[99, 83, 81, 61, 14],
        [78, 23, 62, 28, 80],
        [24, 15, 49, 80, 84]])
    >>> result = np.insert(a, 3, [10, 20, 30])
    >>> result
    array([99, 83, 81, 10, 20, 30, 61, 14, 78, 23, 62, 28, 80, 24, 15, 49, 80,
        84])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisinden belli elemanlar silinebilir. Bunun için delete fonksiyonu kullanılmaktadır. Bu fonksiyonun bir metot karşılığı 
    yoktur. delete fonksiyonunda silinecek NumPy dizisi, silinecek elemanın indeksi ve eksen bilgisi girilmektedir. Eğer axis parametresi 
    için argüman girilmezse önce dizi flatten yapılıp sonra işleme sokulmaktadır. Silme işlemi sonucunda her zaman yeni bir dizi elde
    edilmektedir. Yani bu fonksiyonun bize verdiği nesneler view belirtmemektedir. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> result = np.delete(a, 1, axis=1)
    >>> result
    array([[1, 3],
        [4, 6],
        [7, 9]])
    >>> result.base

    delete fonksiyonu ile birden fazla satır ya da sütun da silinebilmektedir. Bunun için satır ve sütun numaraları bir demet ya da 
    liste biçiminde verilmelidir. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> result = np.delete(a, [1, 2], axis=1)
    >>> result
    array([[1],
        [4],
        [7]])
    >>> a
    array([[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]])
    >>> result = np.delete(a, [0, 2], axis=0)
    >>> result
    array([[4, 5, 6]])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Son 20 yıldır giderek artan bir biçimde "veri bilimi (data science)" terimi kullanılmaya başlanmıştır. Veri bilimi "verileri 
    analiz etme, onlardan faydalı içgörüler elde etme, sonuç çıkarma ve kestirim yapma" amacıyla uygulanan yöntemleri ve süreçleri 
    betimlemektedir. Aslında veri biliminin uğraş alanına benzeyen "veri analizi (data analytics)" genel olarak "istatistik" denilen 
    bilimin bir alt dalı idi. Ancak son 20 yıldır veriler üzerinde bilgisayar programlaması yoluyla klasik istatistikte yapılmayan 
    pek çok işlemler yapılmaya başlanmıştır. İşte "veri bilimi" terimi adeta uygulamalı istatistiğin bilgisayar bilimleri ile iç içe 
    geçmiş bir biçimini anlatmaktadır. Programlama ile veri analizine yönelik uygulamalar artık "veri bilimi uygulamaları" biçiminde 
    ele alınmaya başlanmıştır. Verilerin bilgisayar yardımıyla analiz edilmesi ve faydalı birtakım çıkarımların yapılması veri biliminin 
    önemli bir alanını oluşturmaktadır.   
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Veri bilimi uygulamalarında analiz edilecek veriler şu biçimlerde bulunabilmektedir:

    - Dosyalar içerisinde
    - Veritabanlarının içerisinde
    - Sürekli gelen bir akış içerisinde (örneğin TCP portundan gelen veriler gibi)

    Ancak en çok karşılaşılan durum analiz edilecek verilerin dosyalar içerisinde bulunmasıdır. Peki verilerin içerisinde bulunduğu 
    dosyalar hangi formattadır? İşte en yaygın kullanılan format "CSV (Comma Seperated Values)" denilen formattır. Bu formatta satırların 
    sütunları ',' karakterleriyle satırlar da '\n' (LF) ya da '\r' ve '\n' (CR/LF) karakterleriyle birbirinden ayrılmaktadır. CSV 
    formatında virgüllerden sonra boşluk bırakılmadığına dikkat ediniz. Örneğin:

    1.2,3,5.7,4
    3.2,16,5.6,8
    1.2,7,3.6,8
    ...

    CSV formatında dosyanın başında bir başlık kısmı da bulunabilmektedir. Bu başlık kısmı sütunların ne anlama geldiğine ilişkin 
    sütun isimlerinden oluşmaktadır. Örneğin:

    no,boy,kilo
    1,172,72.3
    2,182,85.2
    3,168,71.6
    ...

    CSV bir text formattır. Dolayısıyla biz bir CSV dosyasını editöre çekip onun üzerinde değişiklikler yapabiliriz. CSV formatı 
    herhangi bir kurum tarafından standardize edilmiş bir format değildir. Format içerisinde çeşitli belirsizlikler vardır. Bu nedenle 
    CSV formatının çeşitli biçimleri (diyalekleri) bulunmaktadır.

    Daha önceden de belirttiğimiz gibi istatistikte ve veri analizinde veriler "veri kümeleri (datasets)" biçiminde ifade edilmektedir. 
    ("Veri kümesi" yerine "veri tablosu (data table)" terimi de kullanılmaktadır.) Bir veri kümesi matrisel bir biçimde satırlardan 
    ve sütunlardan oluşmaktadır. Veri kümesindeki sütunlara "sütun (column)" ya da "özellik (feature)" satırlara ise "satır (row)" 
    ya da "kayıt (record)" denilmektedir. 

    Veri kümelerinin dosyada saklanmasına ilişkin "HDF (Hierachical Data Format)" gibi çeşitli "binary" formatlar da bulunmaktadır. 
    Biz kursumuzda yalnızca CSV formatı üzerinde duracağız. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Peki veri kümeleri nasıl oluşturulmaktadır? Veri kümelerini oluşturmak için verilerin toplanması gerekir. Veri toplama işleminin
    birkaç tipik yöntemi vardır:

    - Veriler anket (survey) yoluyla toplanabilir.
    - Veriler zaten bir biçimde doğal akış içerisinde oluşmuş olabilir. (Örneğin sosyal ağlardaki yazışmalar birer veri olarak zaten 
    sosyal ağın organizasyonu yapan kişiler tarafından veritabanlarında saklanmaktadır.)
    - Veriler otomatik olarak sensörlerden elde ediliyor olabilir. Günümüzde verilerin önemli bir kısmı bu biçimde otomatik elde 
    edilmektedir.
    - Bazen veriler çeşitli kurumlar tarafından (örneğin istatistik kurumları) zaten elde edilmiş durumdadır. Kişiler de o kurumlardan 
    ilgili veri kümelerini alabilmektedir. 

    Örnek veri kümeleri Internet'te pek çok kaynaktan elde edilebilir. Son yıllarda "kaggle.com" isimli organizasyon bu bakımdan çok
    kullanılır hale gelmiştir. Kaggle, Google tarafından makine öğrenmesi uygulamalarını teşvik etmek amacıyla oluşturulmuş olan bir 
    organizasyondur.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    NumPy'da CSV gibi text tabanlı dosyalardan verileri okuyarak bir NumPy dizisi biçiminde bize veren loadtxt isimli bir fonksiyon 
    vardır. Veri bilimcisi bu fonksiyonu çok sık kullanmaktadır. 

    loadtxt fonksiyonunun birinci parametresi okunacak dosyanın yol ifadesini alır. Fonksiyonun ikinci parametresi dtype türünü  
    belirtmektedir. dtype türü belirtilmezse default olarak np.float64 alınmaktadır. Bu dtype türü okunan bilgilerin hangi dtype 
    türüne ilişkin bir NumPy dizisi olarak verileceğini belirtmektedir. Fonksiyonun skiprows parametresi dosyanın başından itibaren 
    kaç satırın atlanacağını belirtmektedir. Eğer CSV dosyasında bir başlık kısmı varsa skiprows=1 yapılarak bu başlık kısmı atlanmalıdır. 
    Fonksiyonun delimiter parametresi değerlerin ayrıştırılacağı karakteri belirtmektedir. loadtxt fonksiyonu yalnızca CSV dosyalarını 
    değil değerlerin başka ayrıraçlarla ayrıldığı dosyaları da okuyabilmektedir. CSV dosyalarını okumak için delimiter parametresi 
    delimiter=',' biçiminde girilmelidir. Eğer delimiter parametresi girilmezse default ayıracın boşluk karakterleri olduğu kabul 
    edilmektedir.
    
    Aşağıdaki gibi "points.csv" isminde bir CSV dosyamız olsun:

    x,y
    10,23
    5,9
    6.1,8.7
    12,81
    4.2,9.3
    11,27
    32,72
    12.3,7.8

    Dosyayı şöyle okuyabiliriz:

   dataset = np.loadtxt('point.csv', dtype=np.float32, delimiter=',', skiprows=1)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

dataset = np.loadtxt('point.csv', dtype=np.float32, delimiter=',', skiprows=1)
print(dataset)

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte eğer "points.csv" dosyasında satırların sütunları boşluklarla ayrılmış olsaydı "delimiter" parametresine bir 
    şey girmememiz gerekmeyecekti. Çünkü bu durumda değerler arasındaki tüm boşluk karakterleri atılmaktadır. Örneğin "points.txt" 
    dosyası aşağıdaki gibi olsun:

    x,y
    10 23
    5 9
    6.1 8.7
    12 81
    4.2 9.3
    11 27
    32 72
    12.3 7.8

    Bu durumda okuma şöyle yapılmalıdır:

    dataset = np.loadtxt('points.txt', dtype=str, skiprows=1)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

dataset = np.loadtxt('points.csv', skiprows=1)
print(dataset)

#------------------------------------------------------------------------------------------------------------------------------------
    Pek çok veri kümesinde bazı sütunlar yazısal (kategorik) bazı sütunlar sayısal biçimdedir. Örneğin zambaklara ilişkin bilgilerin 
    bulunduğu "iris.csv" dosyasının içeriği şöyledir:

    sepal_length,sepal_width,petal_length,petal_width,species
    5.1,3.5,1.4,0.2,Iris-setosa
    4.9,3,1.4,0.2,Iris-setosa
    4.7,3.2,1.3,0.2,Iris-setosa
    4.6,3.1,1.5,0.2,Iris-setosa
    5,3.6,1.4,0.2,Iris-setosa
    5.4,3.9,1.7,0.4,Iris-setosa
    4.6,3.4,1.4,0.3,Iris-setosa
    5,3.4,1.5,0.2,Iris-setosa
    4.4,2.9,1.4,0.2,Iris-setosa
    4.9,3.1,1.5,0.1,Iris-setosa
    5.4,3.7,1.5,0.2,Iris-setosa
    4.8,3.4,1.6,0.2,Iris-setosa
    ...

    Bu biçimde yalnızca sayısal bilgi içermeyen sütunların bulunduğu CSV dosyaları dtype=np.float32 gibi nümerik dtype belirtilerek 
    okunamaz. Bu tür dosyalar ancak dtype türü object ya da str biçiminde belirtilerek okunabilmektedir. Ancak bu durumda da okuma 
    sonucunda yazılardan oluşan bir NumPy dizisi elde edilir. Yazılardan oluşan NumPy dizilerini de sayısal biçime dönüştürmek oldukça 
    zahmetlidir. Örneğin:

    dataset = np.loadtxt('iris.csv', delimiter=',', dtype=str, skiprows=1)

    Burada okuma sonucunda elde edilen NumPy dizisi yazılardan oluşmaktadır:

    array([['5.1', '3.5', '1.4', '0.2', 'Iris-setosa'],
       ['4.9', '3', '1.4', '0.2', 'Iris-setosa'],
       ['4.7', '3.2', '1.3', '0.2', 'Iris-setosa'],
       ['4.6', '3.1', '1.5', '0.2', 'Iris-setosa'],
       ['5', '3.6', '1.4', '0.2', 'Iris-setosa'],
       ['5.4', '3.9', '1.7', '0.4', 'Iris-setosa'],
       ['4.6', '3.4', '1.4', '0.3', 'Iris-setosa'],
       ['5', '3.4', '1.5', '0.2', 'Iris-setosa'],
       ['4.4', '2.9', '1.4', '0.2', 'Iris-setosa'],
       .....
    )
    
    Peki o zaman bu tür dosyalar nasıl okunacaktır?
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                            47. Ders 06/09/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    loadtxt fonksiyonunun usecols parametresine dolaşılabilir bir nesne girilir. Bu parametre dosyadan hangi sütunların elde edileceğini 
    belirtir. Biz veri tablolarındaki yalnızca bazı sütunları almak isteyebiliriz. İlk sütun 0 numaralı sütundur. Böylece okunmak 
    istenen sütunlar fonksiyona bir liste biçiminde (genel olarak dolaşılabilir bir nesne biçiminde) girilebilir. Örneğin:

    dataset = np.loadtxt('iris.csv', delimiter=',', dtype=np.float32, skiprows=1, usecols=[0, 1, 2, 3])

    Burada "iris.csv" veri kümesindeki zambakların türünü belirten son sütun okunmamıştır. (Bu son sütunun indeks numarası 4'tür. Bizim 
    bu sütunu okumaya dahil etmediğimize dikkat ediniz.)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de Covid-19 salgınındaki çeşitli bilgileri barındıran "country_wise_latest.csv" isimli veri kümesinde loadtxt fonksiyonu 
    ile okuma yapalım. "country_wise_latest.csv" veri kümesini aşağıdaki bağlantıdan indirebilirsiniz:

    https://www.kaggle.com/datasets/imdevskp/corona-virus-report

    Bu veri kümesi aşağıdaki gibi bir içeriğe sahiptir:

    Country/Region,Confirmed,Deaths,Recovered,Active,New cases,New deaths,New recovered,Deaths / 100 Cases,Recovered / 100 Cases,
    Deaths / 100 Recovered,Confirmed last week,1 week change,1 week % increase,WHO Region
    Afghanistan,36263,1269,25198,9796,106,10,18,3.5,69.49,5.04,35526,737,2.07,Eastern Mediterranean
    Albania,4880,144,2745,1991,117,6,63,2.95,56.25,5.25,4171,709,17.0,Europe
    Algeria,27973,1163,18837,7973,616,8,749,4.16,67.34,6.17,23691,4282,18.07,Africa
    Andorra,907,52,803,52,10,0,0,5.73,88.53,6.48,884,23,2.6,Europe
    Angola,950,41,242,667,18,1,0,4.32,25.47,16.94,749,201,26.84,Africa
    Antigua and Barbuda,86,3,65,18,4,0,5,3.49,75.58,4.62,76,10,13.16,Americas
    ...
    
    Biz bu veri tablosundan Confirmed, Deaths, Recovered, Active sütunlarındaki bilgileri almak isteyelim. Bu sütunların indeks 
    numaraları 1, 2, 3, 4 biçimindedir. Okuma işlemi aşağıdaki gibi yapılabilir:

    >>> dataset = np.loadtxt('country_wise_latest.csv', delimiter=',', dtype=np.float32, skiprows=1, usecols=[1, 2, 3, 4])
    >>> dataset
    array([[3.626300e+04, 1.269000e+03, 2.519800e+04, 9.796000e+03],
        [4.880000e+03, 1.440000e+02, 2.745000e+03, 1.991000e+03],
        [2.797300e+04, 1.163000e+03, 1.883700e+04, 7.973000e+03],
        [9.070000e+02, 5.200000e+01, 8.030000e+02, 5.200000e+01],
        [9.500000e+02, 4.100000e+01, 2.420000e+02, 6.670000e+02],
        [8.600000e+01, 3.000000e+00, 6.500000e+01, 1.800000e+01],
        [1.674160e+05, 3.059000e+03, 7.257500e+04, 9.178200e+04],
        [3.739000e+04, 7.110000e+02, 2.666500e+04, 1.001400e+04],
        ...

    Şimdi veri tablosundaki ilk ve son sütunu atarak geri kalan sütunları almak isteyelim. Bu veri tablosunda toplam 15 sütun vardır. İşlemi 
    şöyle yapabiliriz:

   >>> dataset = np.loadtxt('country_wise_latest.csv', delimiter=',', dtype=np.float32, skiprows=1, usecols=range(1, 14))
    >>> dataset
    array([[3.6263e+04, 1.2690e+03, 2.5198e+04, ..., 3.5526e+04, 7.3700e+02,
            2.0700e+00],
        [4.8800e+03, 1.4400e+02, 2.7450e+03, ..., 4.1710e+03, 7.0900e+02,
            1.7000e+01],
        [2.7973e+04, 1.1630e+03, 1.8837e+04, ..., 2.3691e+04, 4.2820e+03,
            1.8070e+01],
        ...,
        [1.6910e+03, 4.8300e+02, 8.3300e+02, ..., 1.6190e+03, 7.2000e+01,
            4.4500e+00],
        [4.5520e+03, 1.4000e+02, 2.8150e+03, ..., 3.3260e+03, 1.2260e+03,
            3.6860e+01],
        [2.7040e+03, 3.6000e+01, 5.4200e+02, ..., 1.7130e+03, 9.9100e+02,
            5.7850e+01]], shape=(187, 13), dtype=float32)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

dataset = np.loadtxt('country_wise_latest.csv', delimiter=',', dtype=np.float32, skiprows=1, usecols=[1, 2, 3, 4])
print(dataset)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir veri tablosunda bazı sütunlarda sayısal bilgiler de yazısal bilgiler bulunuyor olabilir. İstatistikte kategori belirten 
    sütunlara "kategorik sütunlar" ya da "nominal sütunlar" denilmektedir. Örneğin yukarıdaki "country_wise_latest.csv" dosyasının 
    ilk sütunu vakalara ilişkin ülkeleri belirtmektedir. Veri analizi yapılırken bu tür kategorik sütunların 0, 1, 2, 3... biçiminde 
    sayısal hale dönüştürülmesi gerekebilmektedir. (Aslında genellikle bu tür sütunlar "one-hot-encoding" denilen yöntemle sayısal biçime 
    dönüştürülmektedir.) Bu tür yazısal sütunların olduğu veri tablolarını loadtxt ile okurken dtype türü default olarak float64 olduğu 
    için okuma soruna yol açacaktır. Burada uygulanacak yöntemlerden biri yukarıda da belirttiğimiz gibi dtype=object ya da dtype=str 
    ile okuma yapmaktır. Ancak bu durumda loadtxt tüm sütunları yazısal biçime dönüştürecektir. Yani bu yöntemde biz dosyayı okumuş oluruz 
    fakat onu istediğimiz hale getirmemiz zor olur. 

    Aşağıdaki gibi "persons.csv" isminde bir dosya bulunuyor olsun:

    kilo,boy,yaş,cinsiyet
    67.2,172,43,kadın
    87.2,183,52,erkek
    32,142,9,erkek
    90,168,48,kadın
    ...

    Biz bu dosyayı dtype=float32 biçiminde okuyamayız. dtype=object ya da dtype=str biçiminde okursak tüm sütunlar yazı gibi 
    okunacaktır. Halbuki bizim yapmak istediğimiz şey kadın=0, erkek=1 gibi bu kategorik sütunu sayısal biçime dönüştürmektir. İşte 
    bunu yapmanın birkaç yolu vardır. loadtxt fonksiyonunun "converters" parametresi bir sözlük nesnesi olarak girilir. Bu sözlüğün 
    anahtarları sütun numaralarını, değerleri çağrılacak fonksiyonları belirtir. loadtxt tarafından dosya okunurken ilgili sütun 
    verisi bir str nesnesi olarak bu fonksiyona parametre yapılır, bu fonksiyonun geri dönüş değeri o sütunun değeri gibi okunur. 

    Yukarıdaki dosyayı okurken cinsiyet sütununu kadın=0, erkek=1 biçiminde sayısallaştırmak isteyelim. Bu işlemi aşağıdaki gibi 
    yapabiliriz. Ancak CSV dosyasında Türkçe karakterler varsa loadtxt fonksiyonunun encoding parametresini 'utf-8' yapmalısınız. 
    Yani özetle CSV dosyası hangi encoding'e göre oluşturulmuşsa o encoding'e göre okuma yapılmalıdır. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

def gender_converter(gender):
    return {'erkek': 0, 'kadın': 1}[gender]
    
dataset = np.loadtxt('persons.csv', delimiter=',', dtype=np.float32, skiprows=1, encoding='utf-8', converters={3: gender_converter})
print(dataset)

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte daha önce üzerinde çalıştığımız "iris.csv" veri kümesindeki zambak türüne ilişkin dönüştürme uygulanmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

def iris_converter(iris):
    return {'Iris-setosa': 0, 'Iris-versicolor': 1, 'Iris-virginica': 2}[iris]
    
dataset = np.loadtxt('iris.csv', delimiter=',', dtype=np.float32, skiprows=1, encoding='utf-8', converters={4: iris_converter})
print(dataset)

#------------------------------------------------------------------------------------------------------------------------------------
    loadtxt fonksiyonunun max_rows parametresi okunacak satır sayısını belirtmektedir. Böylece biz skiprows ve max_rows parametrelerini 
    ayarlayarak dosyanın ilgili kısmını okuyabiliriz.
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

def iris_converter(iris):
    return {'Iris-setosa': 0, 'Iris-versicolor': 1, 'Iris-virginica': 2}[iris]
    
dataset = np.loadtxt('iris.csv', delimiter=',', dtype=np.float32, skiprows=1, max_rows=10, encoding='utf-8', converters={4: iris_converter})
print(dataset)

#------------------------------------------------------------------------------------------------------------------------------------
    Maalesef loadtxt fonksiyonu farklı diyaleklere sahip olan CSV dosyalarını okuyamamaktadır. Örneğin bir sütun iki tırnaklı ise 
    bazı CSV okuyucuları bu iki tırnağın içindekileri dikkate almadan o iki tırnağın tamamını sütun bilgisi olarak okumaktadır. 
    Ancak loadtxt bunu yapamamaktadır. Bu tür durumlarda CSV dosyalarının önce loadtxt tarafından okunabilecek hale getirilmesi gerekir.
    
    Aslında loadtxt fonksiyonu ileride göreceğimiz Pandas kütüphanesinin read_csv fonksiyonuna göre oldukça zayıf kalmaktadır. Pandas'ın
    read_csv fonksiyonu pek çok CSV diyalektini otomatik olarak anlayabilmekte ve farklı sütun yapılarını farklı türlerden olacak biçimde
    tablo biçiminde (buna Pandas'ta DataFrame denilmektedir) okuyabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    loadtxt fonksiyonun tersini de yapmak isteyebiliriz. Örneğin bir NumPy dizisini bir CSV ya da text dosya olarak diskte saklamak 
    isteyebiliriz. Bunun için savetxt fonksiyonu kullanılmaktadır. Bu fonksiyonun birinci parametresi save edilecek dosyanın yol 
    ifadesini, ikinci parametresi NumPy dizisini belirtir. Yine bu fonksiyonda da delimiter parametresi bulunmaktadır. Fonksiyon 
    default durumda sayıları üstel formatta dosyaya yazmaktadır. fmt parametresi C dilindeki printf fonksiyonunun format parametresi 
    gibi girilebilir. (Örneğin "%d" 10'luk sistemde yuvarlayarak yazdırma anlamındadır. %.5f noktadan sonra 5 basamak yazdır anlamına 
    gelir). Fonksiyonun header parametresi ilk satıra yazdırılacak yazının belirlenmesinde kullanılabilir. Ancak default durumda bu 
    yazının başına # karakteri getirilmektedir. Bu istenmiyorsa comments='' girilmelidir. Başlık kısmında Türkçe karakterler kullanılacaksa 
    yine encoding'e dikkat edilmelidir. Pek çok editörün default durumda "utf-8" encoding'ine göre save işlemi yaptığını anımsayınız. 
    BOM marker eklemek için encoding='utf-8-sig' biçiminde encoding belirtilebilir. Örneğin:

    import numpy as np

    data = np.random.randint(0, 100, (10, 10))
    np.savetxt('numbers.csv', data, delimiter=',', fmt='%.0d', header='A,B,C,D,E,F,G,H,I,J', comments='')

    Buradan aşağıdaki gibi bir CSV dosyası elde edilmiştir:

    A,B,C,D,E,F,G,H,I,J
    91,29,99,65,33,18,10,30,5,79
    56,86,56,17,38,95,56,1,10,99
    93,88,90,97,93,16,67,0,71,29
    3,8,83,88,74,78,80,93,11,60
    66,60,51,83,79,77,18,72,62,91
    90,93,58,67,32,45,66,96,60,76
    81,2,28,74,74,31,75,48,99,86
    35,96,59,60,1,57,7,28,64,94
    13,29,75,8,10,53,43,25,63,9
    95,15,96,10,98,32,9,48,53,46
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    loadtxt fonksiyonunun binary okuma yapan load isimli, savetxt fonksiyonunun binary yazma yapan save isimli biçimleri de vardır. 
    Bu fonksiyonlar NumPy tarafından oluşturulan ".npy" dosya formatı biçiminde okuma yazma yaparlar. Binary okuma yazma aslında çok 
    tercih edilen bir biçim değildir. Daha çok veri bilimi uygulamalarında text tabanlı CSV dosyası ve türevleri kullanılmaktadır. Ancak 
    dosyalar çok büyük ise text dosyalar çok yer kaplar hale gelmektedir. Bu tür durumlarda binary dosyalar tercih edilebilmektedir. 
    save ve load fonksiyonlarının delimiter gibi, header gibi, fmt gibi parametreleri yoktur. Örneğin:

    import numpy as np

    data = np.random.randint(0, 100, (10, 10))
    np.save('numbers.npy', data)

    data2 = np.load('numbers.npy')
    print(data2)

    save işlemi ile oluşturulan ".npy" dosyasını text editörde açmaya çalışmayınız. Binary dosyaların içerisinde yazılar olmadığı 
    için anlamlı şeyler göremezsiniz.
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

data = np.random.randint(0, 100, (10, 10))
np.save('numbers.npy', data)

data2 = np.load('numbers.npy')
print(data2)
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi Python'da bir sınıf nesnesi bool türüne dönüştürüldüğünde eğer sınıfın ya da onun taban sınıfının __bool__ 
    metodu özel olarak yazılmamışsa True değeri elde edilmektedir. Bir NumPy dizisi bool türüne dönüştürülürse bu durum yanlış anlaşılmalara 
    yol açabileceği için ndarray sınıfının __bool__ metodunda exception fırlatılmıştır. Yani biz bir ndarray nesnesini bool türüne 
    dönüştüremeyiz. if, while gibi deyimler bu dönüştürmeyi yaptıklarına göre biz NumPy dizilerini bu deyimlerdeki kontrol ifadesi 
    olarak kullanamayız.
#------------------------------------------------------------------------------------------------------------------------------------
   
import numpy as np

a = np.array([1, 2, 3, 4, 5])

if a:                   # exception oluşacak!
    print('True')
else:
    print('False')

#------------------------------------------------------------------------------------------------------------------------------------
    Bir NumPy dizisinin içerisindeki her elemanı bool türüne dönüştürüp bunların hepsi True ise True değerini veren en az bir tanesi 
    False ise False değerini veren all isimli bir fonksiyon vardır. Bu fonksiyon aynı zamanda ndarray sınıfının metodu olarak da
    yazılmıştır. Örneğin:

    data = np.array([1, 2, 3, 4, 5])
    result = data.all()
    print(result)           # True

    data = np.array([1, 2, 0, 4, 5])
    result = data.all()
    print(result)           # False
    
    Örneğin biz bir NumPy dizisini bir değerle karşılaştırdığımızda aslında onun her elemanını o değerle karşılaştırmış oluruz. 
    Sık yapılan bir hata doğrudan bu karşılaştırmanın sonucunun bool olduğunu sanmaktır. Bu durumda yukarıda da belirttiğimiz gibi 
    exception oluşacaktır. Örneğin:

    import numpy as np

    data = np.array([18, 21, 15, 40])

    if data > 10:                     # exception
        print('Yes')
    else:
        print('No')
        
    Burada programcılar "sanki dizinin her elemanı 10'dan büyük mü" karşılaştırmasını yaptıklarını sanmaktadır. Oysa data > 10 
    işleminden bir NumPy dizisi elde edilmektedir. Bu NumPy dizisi de bool türüne dönüştürülemez. Burada exception oluşacaktır. 
    Bu işlemin aşağıdaki gibi yapılması gerekirdi:

    import numpy as np

    data = np.array([18, 21, 15, 40])

    if (data > 10).all():                     
        print('True')
    else:
        print('False')

    Burada nokta operatörünün önceliği yüksek olduğu için karşılaştırma operatörü paranteze alınmıştır. Bu tür durumlarda metot yerine 
    fonksiyon kullanımını tercih edebilirsiniz. Örneğin:

    if np.all(a > 10):                     
        print('True')
    else:
        print('False')
    
    any isimli fonksiyon ise dizi içerisinde bool türüne dönüştürülen elemanlardan en az bir tanesi True ise True değerini hepsi False 
    ise False değerini vermektedir. Örneğin:

    data = np.array([18, 21, 15, 40])

    if np.any(data > 10):                     
        print('True')
    else:
        print('False')

    Burada dizi elemanlarından en az bir tanesi 30'dan büyükse any metodu True değerine aksi takdirde False değerine geri dönecektir. 
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    NumPy'da iki NumPy dizisinin eşitliği aşağıdaki gibi karşılaştırılamaz:

    if a == b:          # exception oluşur
        pass

    Burada a ve b bir NumPy dizisi olduğuna göre a == b işleminden her elemanı bool türden olan bir NumPy dizisi elde edilecektir. 
    Dolayısıyla yukarıda belirttiğimiz sorun ortaya çıkacaktır. O halde bu işlem aşağıdaki gibi yapılmalıdır:

    if np.all(a == b):
        pass

    Özetle a ve b biçiminde iki NumPy dizisinin karşılıklı elemanlarının eşitliğini kontrol etmek için np.all(a == b) ifadesi 
    kullanılmalıdır. 
#------------------------------------------------------------------------------------------------------------------------------------
   
import numpy as np

a = np.array([18, 21, 15, 40])
b = np.array([18, 21, 15, 40])

if a == b:
    print('a == b')
else:
    print('a != b')
   
#------------------------------------------------------------------------------------------------------------------------------------
    NumPy kütüphanesinde linalg isimli pakette temel lineer cebir işlemlerini yapan fonksiyonlar bulunmaktadır. Örneğin det isimli 
    fonksiyon kare matrisin determinantını hesaplar:

    >>> a = np.array([[1, 2, 7], [4, 1, 6], [4, 8, 9]])
    >>> result = np.linalg.det(a)
    >>> result
    133.0
    >>> a = np.array([[1, 2, 7], [2, 4, 14], [4, 8, 9]])
    >>> result = np.linalg.det(a)
    >>> result
    0.0
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np

a = np.array([[1, 2, 3], [4, 2, 1], [6, 9, 3]])

b = np.linalg.det(a)
print(b)

#------------------------------------------------------------------------------------------------------------------------------------
    inv isimli fonksiyon matris tersini bulmaktadır. Örneğin:

    >>> a = np.array([[1, 2, 3], [4, 2, 1], [6, 9, 3]])
    >>> a
    array([[1, 2, 3],
        [4, 2, 1],
        [6, 9, 3]])
    >>> result = np.linalg.inv(a)
    >>> result
    array([[-0.05263158,  0.36842105, -0.07017544],
        [-0.10526316, -0.26315789,  0.19298246],
        [ 0.42105263,  0.05263158, -0.10526316]])
#------------------------------------------------------------------------------------------------------------------------------------
   
import numpy as np

a = np.array([[1, 2, 3], [4, 2, 1], [6, 9, 3]], dtype=np.float64)

b = np.linalg.inv(a)
print(b)

c = np.matmul(a, b)
print(c)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir lineer denklem sistemi AX = b biçiminde ifade edilebilir. Örneğin:

   3x1 - 2x2 + x3 = 2
   -x1 + 2x2 - x3 = 0
   x1 + x2 + x3 = 6

    Bu denklem sisteminde A matrisi şöyledir:

     3  -2  1
    -1  2  -1
     1  1   1

    b matrisi de şöyledir:

     1
     0
    13

    Denklemin çözümü şöyle yapılabilir:

    A⁻¹AX = A⁻¹b
    X = A⁻¹b
    
    Yani aslında X değerleri A'nın tersinin b ile çarpımı biçiminde bulunabilir. Tabii buradaki çarpım matris çarpımıdır. Örneğin:

    >>> A = np.array([[3, -2, 1], [-1, 2, -1], [1, 1, 1]])
    >>> b = np.array([[2], [0], [6]])
    >>> A
    array([[ 3, -2,  1],
        [-1,  2, -1],
        [ 1,  1,  1]])
    >>> b
    array([[2],
        [0],
        [6]])
    >>> np.linalg.inv(A) @ b
    array([[1.],
       [2.],
       [3.]])

    Bu tür durumlarda sütun vektörlerini yazmak zor olduğu için reshape işleminden faydalanabilirsiniz:

    >>> A = np.array([[3, -2, 1], [-1, 2, -1], [1, 1, 1]])
    >>> b = np.array([2, 0, 6]).reshape(-1, 1)
    >>> np.linalg.inv(A) @ b
    array([[1.],
        [2.],
        [3.]])
#------------------------------------------------------------------------------------------------------------------------------------ 

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında yukarıdaki işlemi tek hamlede yapan solve isimli bir fonksiyon vardır. Örneğin:

    >>> A = np.array([[3, -2, 1], [-1, 2, -1], [1, 1, 1]])
    >>> b = np.array([2, 0, 6]).reshape(-1, 1)
    >>> np.linalg.solve(A, b)
    array([[1.],
        [2.],
        [3.]])
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Matematikte birtakım problemler iki biçimde çözülebilmektedir:

    1) Sembolik yöntemle
    2) Nümerik yöntemle

    Sembolik yönteme "kapalı (closed)" yöntem de denilmektedir. Bu yöntemde problem genellikle fonksiyon olarak verilir. Çözüm de 
    bir fonksiyon olarak istenir. Örneğin f(x) = 3x² - 5x + 10 gibi bir fonksiyon olsun. Bu fonksiyonun türevini biz yine bir 
    fonksiyon olarak elde etmek istiyorsak sembolik ya da kapalı yöntemi kullanmış oluruz. Ancak bu fonksiyonun belli bir noktadaki 
    türevinin değerini elde etmek istediğimizde bu işlem sembolik olarak da nümerik olarak da yapılabilir. Bazı problemler yalnızca 
    nümerik yöntemlerle çözülebilmektedir. Örneğin 5'inci dereceden daha büyük denklemlerin sembolik çözümü oluşturulamamaktadır. 
    Pek çok optimizasyon probleminin de sembolik çözümü mümkün değildir. Okullarda genellikle sembolik yöntemler üzerinden matematik 
    anlatılmaktadır. Her ne kadar mühendislik ve bazı bölümlerde "nümerik analiz" adı altında dersler olsa da bunlara yeterli önem 
    verilmemektedir. 

    Python'da sembolik bir biçimde matemetiksel işlemler yapan en önemli kütüphane "SymPy" ("Symbolic Python" sözcüklerinden kısaltma) 
    denilen kütüphanedir. Nümerik işlemler için ise en yaygın kullanılan kütüphane "SciPy" ("Scientific Python" sözcüklerinden kısaltma)
    kütüphanesidir. Matematiksel ve istatistiksel yöntemlerle makine öğrenmesi uygulamaları için "scikit-learn" isimli kütüphane, 
    yapay sinir ağları ve derin öğrenme için ise "TensorFlow", "PyTorch" ve "Theano" isimli kütüphaneler yaygın biçimde kullanılmaktadır. 
    Doğal dil işleme (NLP) işlemleri için ise "Hugging Face" isimli kütüphane ilk seçeneklerdendir. Tabii kütüphanelerin başka 
    alternatifleri de vardır. Ancak sözünü ettiğimiz bu kütüphaneler bu amaçlar için kullanılan en yaygın kütüphanelerdir. 

    Taban Kütüphaneler ===> NumPy, Pandas
    Sembolik Matematik ===> SymPy
    Nümerik Matematik ===> SciPy
    İstatistiksel ve Matematiksel Makine Öğrenmesi Uygulamaları ===> scikit-learn
    Yapay Sinir Ağları ve Derin Öğrenme ===> TensorFlow, PyTorch, Theano
    Doğal Dil İşleme ===> Hugging Face

    Bu bölümde SymPy kütüphanesinin kullanımı üzerinde duracağız. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi Python'da sembolik yöntemlerle matematiksel işlem yapan en yaygın kütüphane SymPy kütüphanesidir. 
  
    SymPy kütüphanesinin dokümantasyonu aşağıdaki adreste bulunmaktadır:

    https://docs.sympy.org/latest/index.html

    Anaconda dağıtımında SymPy zaten dağıtımın kendi içerisinde bulunmaktadır. Ancak diğer dağıtımlarda bunun pip programı ile kurulması 
    gerekir:

    pip install sympy

    Biz burada bu kütüphaneyi sp ismiyle import edeceğiz:

    import sympy as sp
#------------------------------------------------------------------------------------------------------------------------------------
 
#------------------------------------------------------------------------------------------------------------------------------------
    SymPy'da önce fonksiyonları oluşturan x, y gibi değişkenlerin birer sembol olarak ifade edilmesi gerekir. Bunun için SymPy'da 
    Symbol isimli bir sınıf kullanılmaktadır. Symbol sınıfı bizden sembolün ismini parametre olarak almaktadır. Her ne kadar aslında 
    SymPy sınıf nesneleri üzerinde işlem yapıyorsa da görüntüleme aşamasında bizim verdiğimiz sembol yazısını kullanmaktadır. Örneğin:

    >>> x = sp.Symbol('x')
    >>> x
    >>> type(x)
    <class 'sympy.core.symbol.Symbol'>

    Tabii sembole verdiğimiz isim ile onu atadığımız değişkenin isminin aynı olması gerekmez. Ancak kafa karışıklığı oluşmasın isteniyorsa
    Python'daki değişken ismiyle sembole verilen isim aynı yapılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------
   
import sympy as sp

x = sp.Symbol('x')
print(x, type(x))       # x <class 'sympy.core.symbol.Symbol'>

#------------------------------------------------------------------------------------------------------------------------------------
                                                48. Ders 07/09/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Symbol sınıfıyla oluşturulan sembollerin birtakım özellikleri vardır. Bu özellikler Symbol nesnesi yaratılırken isimli parametrelerle 
    belirlenebilmektedir. Bu isimli parametreler şöyledir:

    real
    imaginary
    positive
    negative
    odd
    even
    prime
    finite
    infinite

    Örneğin:

    x = sp.Symbol('x', real=True)

    İlgili özelliklerin olup olmadığı aşağıdaki özniteliklerle test edilebilir:

    is_real
    is_imaginary
    is_positive
    is_negative
    is_odd
    is_even
    is_prime
    is_finite
    is_infinite

    Örneğin:

    x = sp.Symbol('x', real=True)

    result = x.is_real

    result burada True olacaktır.

    Başlangıçta bu özniteliklerin çoğu False değerdedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Sembollerin görüntülenmesi eğer grafik bir ekranda matematiksel bir biçimde yapılmak isteniyorsa bu durumda işin başında aşağıdaki 
    çağrı yapılmalıdır:

    sp.init_printing()

    Buradaki sp.init_printing() çağrısı komut satırında değişkenin ismi yazıldığındaki görüntü üzerinde etkili olmaktadır. Yani başka 
    bir deyişle bu çağrı __repr__ metodunu oluşturmaktadır. Değişkenler print edildiğinde yine text karakterlerle print edilmektedir. 
    Tabii matematiksel ifadelerin grafik ekranda görüntülenebilmesi için ortamın da buna uygun olması gerekmektedir. Örneğin Spyder
    içerisindeki IPython ortamı böyle grafiksel gösterimlere uygundur. Ancak komut satırlarında grafiksel görüntüleme yapılmadığı 
    için semboller Unicode çizim karakterleriyle görüntülenmeye çalışılmaktadır.

    Eğer Spyder IDE'sindeki IPython konsolunda matematiksel ifadeleri programlama yoluyla görüntülemek istiyorsanız bu IPython 
    konsoluna özgü display fonksiyonunu aşağıdaki gibi kullanabilirsiniz:

    from IPython.display import display

    display(expression)
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x = sp.Symbol('x', infinite=True)
y = sp.sqrt(x ** 2 + 5 * x)

print(y)
display(y)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir grup sembol tek hamlede symbols isimli fonksiyonla yaratılabilmektedir. symbols fonksiyonu bizden sembol isimlerine ilişkin 
    bir yazı alır. Bu yazıdaki sembol isimleri boşluklarla ya da virgüllerle ayrılmış olabilir. symbols fonksiyonu bize Symbol 
    nesnelerinden oluşan bir demet vermektedir. Biz bu demeti açıp (unpack yapıp) değişkenlere atayabiliriz. Örneğin:

    x, y, z, k = result = sp.symbols('x y z k')

    Burada biz tek hamlede dört sembol yaratmış olduk.
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp

x, y, z, k = sp.symbols('x, y, z, k')

print(x, y, z, k)

#------------------------------------------------------------------------------------------------------------------------------------
    Fonksiyonlarda geçen sabit değerler de aslında SymPy'da sınıflarla temsil edilmiştir. Örneğin Integer isimli sınıf tamsayı 
    sabitini SymPy sabiti biçiminde tutmaktadır. Örneğin:

    a = sp.Integer(3)

    Buradaki sabit bir string olarak da verilebilirdi:

    a = sp.Integer('3')

    Benzer biçimde float değerler de Float isimli bir sınıfla temsil edilebilmektedir. Örneğin:

    b = sp.Float('1.23456')

    Buradaki parametre string olarak girildiğinde bir yuvarlama hatası oluşmayacaktır. Ancak parametre bir float biçiminde de 
    girilebilir:

    b = sp.Float(1.23456)
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x = sp.Symbol('x')
a = sp.Float('3.456789')

y = a * x ** 2
display(y)

#------------------------------------------------------------------------------------------------------------------------------------
    Bazı özel değerler özel bazı değişken isimleriyle temsil edilmiştir. Örneğin e sayısı sp.E ile, pi sayısı sp.pi ile, sonsuz değeri
    sp.oo ile temsil edilmiştir. Diğer özel değerlerin temsili için SymPy dokümanlarına başvurabilirsiniz. Örneğin:

    >>> sp.pi
    π
    >>> sp.E
    ℯ
    >>> sp.oo
    ∞
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x = sp.pi
display(x)

x = sp.E
display(x)

x = sp.oo
display(x)

#------------------------------------------------------------------------------------------------------------------------------------
   Bir Symbol nesnesi operatörlerle işleme sokulabilmektedir. Bu durumda operatör fonksiyonları devreye girer ve bize çeşitli sınıflar 
   türünden nesneler verir. Örneğin biz sembolü başka bir sembolle ya da sabitle topladığımızda bize Add isimli bir sınıf türünden 
   nesne verilmektedir. Bir sembolü başka bir sembolle ya da bir sabitle çarptığımızda bize Mul isimli bir nesne verilmektedir. Aslında 
   bu sınıfların hepsi Expr isimli bir sınıftan türetilmiştir. Böylece matematiksel ifadeler kütüphane içerisinde içsel olarak bir 
   ağaçla temsil edilebilmektedir:

   Basic (en üst sınıf)
  └── Expr (ifadeler için)
      ├── Add (toplama işlemleri)
      ├── Mul (çarpma işlemleri)  
      ├── Pow (üs alma işlemleri)
      └── diğer matematiksel işlemler
      
   Örneğin:

    >>> x, y = sp.symbols('x, y')
    >>> z = x * y
    >>> type(z)
    <class 'sympy.core.mul.Mul'>
    >>> z = x * y + 2
    >>> type(z)
    <class 'sympy.core.add.Add'>
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp

x = sp.Symbol('x')

result = x * 2
print(result, type(result))     # 2*x <class 'sympy.core.mul.Mul'>

result = x + 2
print(result, type(result))     # x + 2 <class 'sympy.core.add.Add'>

result = x ** 2
print(result, type(result))     # x**2 <class 'sympy.core.power.Pow'>

#------------------------------------------------------------------------------------------------------------------------------------
    Peki işlemler sonucunda elde edilen Add, Sub, Mul türünden sınıf nesnelerin anlamı nedir? İşte SymPy aslında bir ifadeyi bir 
    ağaç biçiminde tutmaktadır. Örneğin:

    result = 3 * x + 2

    Burada aslında result nesnesi bu ifadeyi temsil eden ağacın kök düğümüdür. Bu kök düğüm Add sınıfı türündendir. Add sınıfı iki 
    ayrı düğümün adresini tutmaktadır. Bunlardan biri Mul düğümü diğeri de 2 değerini temsil eden Integer düğümüdür:

                             Add
                Mul                       Integer(2)
    Integer(3)       Symbol(x)

    Programcının aslında bu işlemin ağaç bakımından detaylarını bilmesine gerek yoktur. Programcı yalnızca şunu bilmelidir: Aslında 
    bir ifade oluşturduğumuzda bu ifade bir ağaç veri yapısı biçiminde bellekte oluşturulmaktadır ve o ağacın köküne ilişkin bir 
    nesne bize verilmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    İfadelerin sadeleştilmesi simplify isimli fonksiyonla yapılmaktadır. Örneğin:

    >>> x = sp.Symbol('x')
    >>> exp = (3 * x ** 2 - 3 * x) / (3 * x)
    >>> sp.simplify(exp)
    x - 1
    
    Örneğin ifademiz (x ** 2 - 1) / (x + 1) olsun. Bu ifade sadeleştirilirse (x - 1) elde edilecektir:

    >>> x = sp.Symbol('x')
    >>> exp = (x ** 2 - 1) / (x + 1)
    >>> sp.simplify(exp)
    x - 1

    Örneğin:

    >>> exp = ((x ** 2 - x - 12) / (x ** 2 + 8 * x + 15) ) / ((x ** 2 - 5 * x + 4) / (x ** 2 + 3 * x - 10))
    >>> sp.simplify(exp)
    x - 2
    ─────
    x - 1
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x = sp.Symbol('x')
exp = (x ** 2 - 1) / (x + 1)
result = sp.simplify(exp)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda 2 * sin(x) * cos(x) ifadesinin sin(2x) biçiminde sadeleştirildiğini göreceksiniz:

    >>> x = sp.Symbol('x')
    >>> exp = 2 * sp.sin(x) * sp.cos(x)
    >>> sp.simplify(exp)
    sin(2⋅x)

#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x = sp.Symbol('x')
exp = 2 * sp.sin(x) * sp.cos(x)
result = sp.simplify(exp)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda ÖSS sınavında çıkmış olan bir sadeleştirme sorusu çözülmüştür.
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x, y = sp.symbols('x, y')
expression = ((x ** 2 + x - 6) / (x **  2 + 3 * x - 10)) * ((x ** 2 - x * y + 5 * x - 5 * y) / (x ** 2 + x * y + 3 * x + 3 * y))
result = sp.simplify(expression)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
     Aşağıda başka bir ÖSS sadeleştirme sorusu çözülmüştür.
#------------------------------------------------------------------------------------------------------------------------------------

    import sympy as sp
    from IPython.display import display

    sp.init_printing()

    x, y = sp.symbols('x, y')
    expression = ((x / (1 + x)) - (1 / (1 - x))) / ((1 / (1 + x)) + (x / (1 - x)))
    result = sp.simplify(expression)
    display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    expand fonksiyonu simplify fonksiyonunun adeta ters işlemini yapmaktadır. Yani fonksiyon çarpım ifadelerini açar. Örneğin:

    >>> x = sp.Symbol('x')
    >>> exp = (x - 1) * (x + 1)
    >>> sp.expand(exp)
    2
    x  - 1

    Örneğin:

    >>> x = sp.Symbol('x')
    >>> exp = (x - 1) ** 3 * (x - 1)
    >>> sp.expand(exp)
    4      3      2
    x  - 4⋅x  + 6⋅x  - 4⋅x + 1

#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x, y = sp.symbols('x, y')

exp = (x - y) ** 2 + 3 * (x + y) ** 2
result = sp.expand(exp)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında expand fonksiyonlarının özel biçimleri vardır. Bunlar ilgili konuda açım uygularlar. Örneğin biz trigonometrik bir açım 
    yapacaksak expand_trig fonksiyonunu kullanırız. Yani aslında expand fonksiyonu bu özel fonksiyonları kullanıp daha karmaşık açımları 
    yapmaya çalışmaktadır. expand ile yapamadığınız işlemleri bunlarla yapabilirsiniz. Bunların listesi şöyledir:

    expand_log
    expand_mul
    expand_multinomial
    expand_complex
    expand_trig
    expand_power_base
    expand_power_exp
    expand_func

#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x = sp.Symbol('x')
exp = sp.sin(2 * x)

result = sp.expand_trig(exp)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Örneğin logaritmik açım için expand_log fonksiyonu kullanılır.
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

x = sp.Symbol('x')
expression = sp.log(2 * x)
result = sp.expand_log(expression)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Çarpanlara ayırma da çok karşılaşılan işlemlerdendir. Bu işlem factor isimli fonksiyonla yapılmaktadır. Örneğin:

    >>> x = sp.Symbol('x')
    >>> exp = x ** 2 - 1
    >>> sp.factor(exp)
    (x - 1)⋅(x + 1)

#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x = sp.Symbol('x')
exp = x ** 2 - 1
result = sp.factor(exp)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda daha karmaşık bir çarpanlara ayırma örneği verilmiştir:

    >>> x = sp.Symbol('x')
    >>> exp = x ** 3 + 6 * x ** 2 + 5 * x
    >>> sp.factor(exp)
    x⋅(x + 1)⋅(x + 5)

#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

sp.init_printing()

x = sp.Symbol('x')
exp = x ** 3 + 6 * x ** 2 + 5 * x
result = sp.factor(exp)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir ifadenin sonucunu hesaplamak için subs (substitute) isimli metot kullanılmaktadır. Metodun basit kullanımında birinci parametre
    değeri yerleştirilecek değişkeni, ikinci parametre onun değerini belirtir. Örneğin:

    >>> x = sp.Symbol('x')
    >>> exp = 3 * (x - 1) ** 3 + 2
    >>> exp.subs(x, 2)
    5
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp

x = sp.Symbol('x')
exp = 3 * (x - 1) ** 3 + 2
result = exp.subs(x, 2)
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Eğer ifadede birden fazla değişken için yerleştirme yapılması isteniyorsa bu durumda dolaşılabilir bir nesne içerisinde iki 
    elemanlı dolaşılabilir nesnelerin kullanılması gerekir (örneğin iki elemanlı demetlerden oluşan listeler gibi). Örneğin:

    >>> x, y = sp.symbols('x y')
    >>> exp = 3 * (x - 1) ** 2 + 2 * (y + 1) ** 3
    >>> exp.subs([(x, 2), (y, 1)])
    19

#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp

x = sp.Symbol('x')
y = sp.Symbol('y')

exp = x ** 2 - 3 * y + 2
result = exp.subs([(x, 1), (y, 2)])

print(result)       # -3
    
#------------------------------------------------------------------------------------------------------------------------------------
   evalf isimli metot sp.pi gibi sp.e gibi özel değerleri sayısal değerlerle değiştirir. Ancak ifade içerisindeki sembollere
   dokunmaz. subs metodu ise özel değerleri açmamaktadır. Bu nedenle bazen bu iki metodun bir arada kullanılması gerekebilmektedir. 
   Örneğin:

   >>> x = sp.Symbol('x')
    >>> exp = 2 * x * sp.pi + 3 - 2 * sp.E - x
    >>> exp.subs(x, 2)
    -2⋅ℯ + 1 + 4⋅π
    >>> exp.subs(x, 2).evalf()
    8.12980695744108
    >>> exp.evalf()
    5.28318530717959⋅x - 2.43656365691809
    >>> exp.evalf().subs(x, 2)
    8.12980695744108
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp

x, y, z = sp.symbols('x, y, z')

f = sp.pi * x ** 2 - 3 * y + 2 * z
result = f.subs([(x, 2), (y, 3), (z, -1)])
print(result)

result = f.subs([(x, 2), (y, 3), (z, -1)]).evalf()
print(result)

f = sp.log(x ** 2)

result = f.subs(x, 2).evalf()
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    lambdify isimli fonksiyon bizden sembolü ve ifadeyi argüman olarak alır. Bize bir Python fonksiyonu verir. Biz artık o fonksiyonu 
    çağırdığımızda adeta evalf ve subs işlemleri yapılıp bunun sonucu elde edilmiş olacaktır. Yani biz bu fonksiyon sayesinde SymPy 
    dünyasından çıkıp Python dünyasına geri dönebiliriz. lambdify fonksiyonu bizden değişkeni ve ifadeyi parametre olarak 
    alır. Örneğin:

    x = sp.Symbol('x')
    exp = 3 * x ** 2 - sp.pi + 2
    f = sp.lambdify(x, exp)

    result = f(3)
    print(result)

    Burada lambdify fonksiyonun nasıl çağrıldığına dikkat ediniz:

    f = sp.lambdify(x, exp)

    Biz bu çağrıda fonksiyona şunları demekteyiz: "Ben bana verdiğin fonksiyona x için bir argüman gireceğim. Sen bu argümanı x olarak 
    kabul edip bu ifadeye sok ve ifadeden elde edilen geri dönüş değerini bana ver". Örneğimizdeki lambdify fonksiyonunun verdiği 
    fonksiyonun nasıl çağrıldığına dikkat ediniz:

    result = f(3)

    Aslında biz buradan 3 * 9 - pi + 2 değerini elde etmiş olacağız. 

    Eğer ifadede birden fazla değişken varsa bu değişkenlerin lambdify fonksiyonun birinci argümanında demet biçiminde verilmesi 
    gerekir. Örneğin:

    x, y, z = sp.symbols('x y z')
    exp = 3 * x ** 2 - 5 * y + z

    f = sp.lambdify((x, y, z), exp)

    result = f(1, 2, 3)
    print(result)           # -4

#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp

x, y, z = sp.symbols('x y z')
exp = 3 * x ** 2 - 5 * y + z

f = sp.lambdify((x, y, z), exp)

result = f(1, 2, 3)
print(result)           # -4

#------------------------------------------------------------------------------------------------------------------------------------
    Sembolik (belirsiz) türev alma işlemi matemetikte sıkça karşımıza çıkmaktadır. Bir fonksiyonun belli bir noktadaki türevinin 
    sayısal değerinin bulunması çeşitli "nümerik analiz" yöntemleriyle kolay bir biçimde elde edilebilmektedir. Ancak bir fonksiyonun 
    türev fonksiyonunu sembolik bir biçimde elde etmek matematikte daha sık kullanılmaktadır. SymPy'da türev işlemi için diff isimli 
    fonksiyon bulundurulmuştur. diff fonksiyonunun birinci parametresi türevi alınacak ifadeyi, ikinci parametresi türevin hangi 
    değişkene göre alınacağını belirtmektedir. Örneğin:

    >>> x = sp.Symbol('x')
    >>> f = 3 * x ** 5 - 5 * x ** 3 + 2 * x - 1
    >>> sp.diff(f, x)
        4       2
    15⋅x  - 15⋅x  + 2

    Örneğin:

    >>> x = sp.Symbol('x')
    >>> f = 3 * sp.sin(x) ** 2
    >>> sp.diff(f, x)
    6⋅sin(x)⋅cos(x)
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

x = sp.Symbol('x')
f = 3 * x ** 5 - 5 * x ** 3 + 2 * x - 1

result = sp.diff(f, x)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Çok değişkenli fonksiyonlarda türev değişkenlerin herhangi birine göre alınabilmektedir. Bu durumda diğer değişkenler sanki sabit 
    sayılarmış gibi işleme sokulmaktadır. Buna "kısmi türev (partial derivative)" denilmektedir. Özellikle doğrusal olmayan optimizasyon 
    problemlerinde çok değişkenli fonksiyonların her değişkene göre parçalı türevleri alınarak bir vektör elde edilmektedir. Bu vektöre 
    "gradyen vektör" denilmektedir. Bu gradyen vektör fonksiyonun maksimum ve minimum noktalarını bulmak için kullanılmaktadır. 

    SymPy'da parçalı türevler yukarıdaki gibi uygulanmaktadır. Tabii istenirse önce bir değişkene göre türev alıp sonra başka 
    değişkene göre de türev alınabilir. Örneğin:

    >>> x, y = sp.symbols('x y')
    >>> f = 3 * x ** 2 * 2 * y - 5 * x * y + 2

    Burada f fonksiyonu iki değişkenli bir fonksiyondur. Biz bu fonksiyonun x'e göre parçalı türevini alalım. Matematikte parçalı 
    türevler matematikte ∂f/∂x biçiminde gösterilmektedir. 

    >>> sp.diff(f, x)
    12⋅x⋅y - 5⋅y

    Şimdi de aynı fonksiyonun y'ye göre türevini alalım. Yani ∂f/∂y işlemini yapalım:

    >>> sp.diff(f, y)
       2
    6⋅x  - 5⋅x

    Şimdi de önce x'e göre sonra y'ye göre parçalı türev alalım. Yani ∂²f/∂y∂x işlemini yapalım. Bunu tek hamlede aşağıdaki gibi 
    yapabiliriz:

    >>> sp.diff(f, x, y)
    12⋅x - 5
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

x, y = sp.symbols('x y')

f = 3 * x ** 2 * 2 * y - 5 * x * y + 2

result = sp.diff(f, x)
print(result)

result = sp.diff(f, y)
display(result)

result = sp.diff(f, x, y)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Sembolik integralin (belirsiz integral de denilmektedir) matematikte yaygın bir kullanım alanı vardır. Grafiksel olarak integral 
    eğri altında kalan alanı veren bir işlemdir. SymPy'da integrate fonksiyonu ile belirsiz integral işlemleri yapılabilmektedir. 
    integrate fonksiyonunun kullanılması diff fonksiyonundaki gibidir. Aşağıda f(x) = (x - 1) fonksiyonunun integrali bulunmuştur:

    >>> x = sp.Symbol('x')
    >>> f = x - 1
    >>> sp.integrate(f, x)
     2
    x
    ── - x
    2
#------------------------------------------------------------------------------------------------------------------------------------

import sympy as sp
from IPython.display import display

x = sp.Symbol('x')

f = x - 1

result = sp.integrate(f, x)
display(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Python'da istatistik, veri bilimi ve makine öğrenmesi alanlarında yaygın biçimde kullanılan Pandas kütüphanesini ele 
    alacağız. Pandas kütüphanesi NumPy kütüphanesinin üzerine oturtulmuştur. Kütüphane NumPy kütüphanesinin sunduğu pek çok olanağa
    sahiptir. Pandas'ın en önemli özelliği farklı türlerden sütunlara sahip veri kümelerini DataFrame adı altında temsil edebilmesidir. 
    NumPy'da bir NumPy dizisinin tüm elemanlarının aynı dtype türünden olması gerektiğini anımsayınız. Halbuki istatistikte, veri biliminde
    ve makine öğrenmesinde kullanılan veri kümeleri farklı sütun türlerine sahip olabilmektedir. Örneğin sütunlardan biri kişilerin 
    boy uzunluklarını, diğeri yaşlarını, diğeri kilolarını ve diğeri de cinsiyetlerini belirtiyor olabilir. NumPy kısmında bu tür 
    CSV dosyalarının NumPy dizisi haline getirilmesinin ne kadar zor olduğunu görmüştük. İşte Pandas bize farklı sütun türlerine 
    sahip veri kümeleri üzerinde çalışma olanağı sağlamaktadır. Pandas kütüphanesi aslında uygulamacılar tarafından NumPy kütüphanesinden
    daha yaygın kullanılmaktadır. Birtakım işlemler yapıldıktan sonra Pandas nesneleri NumPy dizilerine dönüştürülüp işlemlere 
    NumPy ile de devam edilebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
   Pandas kütüphanesi Anaconda dağıtımında dağıtımla birlikte zaten kurulmuş durumdadır. Ancak yeni bir sanal ortam oluşturduğunuzda 
   Pandas kurulumunu pip programı ile aşağıdaki gibi yapabilirsiniz:

   pip install pandas

   Pandas kütüphanesi programcılar tarafından geleneksel olarak pd ismiyle import edilmektedir. Örneğin:

   import pandas as pd 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Pandas'ta sütunlardan ve satırlardan oluşan veri kümeleri DataFrame isimli bir sınıf ile temsil edilmektedir. Veri kümesindeki 
    belli bir sütun ise Series isimli sınıfla temsil edilmiştir. Yani DataFrame sınıfını Series nesnelerini tutan bir sınıf gibi 
    düşünebiliriz. Biz kursumuzda önce Series sınıfını ele alıp inceleyeceğiz. Pandas'ın temel yeteneklerini bu sınıf üzerinde 
    tanıtacağız. Sonra DataFrame sınıfını ele alıp açıklayacağız. Pandas büyük ölçüde Series ve DataFrame sınıflarının kullanımı 
    ile ilgilidir.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Series nesnesi dolaşılabilir bir nesne ile Series sınıfının __init__ metoduyla oluşturulabilir. Buradaki dolaşılabilir nesne 
    bir Python listesi, demeti olabileceği gibi bir NumPy dizisi de olabilir. Örneğin:

    >>> s = pd.Series([1, 2, 3, 4, 5])
    >>> s
    0    1
    1    2
    2    3
    3    4
    4    5
    dtype: int64
    >>> a = np.random.rand(10)
    >>> s = pd.Series(a)
    >>> s
    0    0.839374
    1    0.494721
    2    0.386717
    3    0.095209
    4    0.163746
    5    0.549368
    6    0.453674
    7    0.052371
    8    0.868359
    9    0.038974
    dtype: float64
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import pandas as pd

s = pd.Series([1, 2, 3, 4, 5, 6])
print(s)

a = np.array([1, 2, 3, 4, 5])
s = pd.Series(a)
print(s)

#------------------------------------------------------------------------------------------------------------------------------------
   Series nesnelerinin de tıpkı NumPy dizilerinde olduğu gibi bir dtype türü vardır. Bir Series nesnesi yaratılırken nesnenin dtype 
   türü dtype parametresiyle belirtilebilir. Pandas'a özgü ayrı dtype türleri yoktur. Aslında Pandas Series bilgilerini NumPy dizisi 
   olarak saklamaktadır. Dolayısıyla Series nesnesi yaratılırken dtype bilgisi NumPy'ın dtype türü olarak belirtilir. Örneğin:
 
    >>> s = pd.Series([1, 2, 3, 4, 5], dtype=np.float32)
    >>> s
    0    1.0
    1    2.0
    2    3.0
    3    4.0
    4    5.0
    dtype: float32

   Tabii burada dtype belirtilirken np.float32 gibi bir ifade kullanılacaksa NumPy kütüphanesinin de import edilmesi gerekir. Ancak 
   bunun yerine programcı dtype türünü NumPy'da olduğu gibi yazısal da belirtebilmektedir. Bu durumda NumPy kütüphanesinin import 
   edilmesine gerek kalmaz. Örneğin:

    >>> s = pd.Series([1, 2, 3, 4, 5], dtype='float32')
    >>> s
    0    1.0
    1    2.0
    2    3.0
    3    4.0
    4    5.0
    dtype: float32

   Eğer Series nesnesi zaten NumPy dizisi ile oluşturuluyorsa ve dtype belirtilmemişse NumPy dizisindeki dtype bilgisi kullanılır. Diğer 
   durumlarda NumPy'da olduğu gibi eğer Series fonksiyonuna verilen tüm elemanlar int türündense dtype türü 'int64' olarak en az bir 
   eleman float türündense 'float64' olarak alınmaktadır. Örneğin:

   >>> a = np.array([1, 2, 3, 4, 5], dtype='float32')
   >>> a
    array([1., 2., 3., 4., 5.], dtype=float32)
    >>> s = pd.Series(a)
    >>> s
    0    1.0
    1    2.0
    2    3.0
    3    4.0
    4    5.0
    dtype: float32

    >>> s = pd.Series([1, 2, 3, 4, 5])
    >>> s
    0    1
    1    2
    2    3
    3    4
    4    5
    dtype: int64
    >>> s = pd.Series([1.2, 2, 3, 4, 5])
    >>> s
    0    1.2
    1    2.0
    2    3.0
    3    4.0
    4    5.0
    dtype: float64

    Series nesneleri tek boyutlu bir kavram belirtmektedir. Dolayısıyla biz çok boyutlu bir NumPy dizisini Series nesnesi haline getiremeyiz.
    
    Series sınıfının yine dtype isimli örnek özniteliği bize Series nesnesinin dtype bilgisini vermektedir. Örneğin:

    >>> s = pd.Series([1, 2, 3, 4, 5], dtype='float32')
    >>> s
    0    1.0
    1    2.0
    2    3.0
    3    4.0
    4    5.0
    dtype: float32
    >>> s.dtype
    dtype('float32')

    Yukarıda da belirttiğimiz gibi Series nesnesi yaratılırken verilen değerlerin normal olarak tek boyutlu olması gerekir. Ancak biz 
    Series fonksiyonuna bir liste listesi gibi iki boyutlu bir nesne verirsek bu durumda aslında Series nesnesi tek boyutlu olur. 
    Onun her elemanı bir listeyi tutar hale gelir. Böyle Series nesnelerinin dtype türü de object olmak zorundadır. object dtype türü 
    ile "elemanları farklı türlerden olabilen" Series nesneleri oluşturulabilmektedir. Örneğin:

    >>> s = pd.Series([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    >>> s
    0    [1, 2, 3]
    1    [4, 5, 6]
    2    [7, 8, 9]
    dtype: object

    Örneğin:

    >>> s = pd.Series(['ali', 3.5, 123])
    >>> s
    0    ali
    1    3.5
    2    123
    dtype: object

    Ancak genel olarak Series nesnelerinin bu biçimde object türü altında farklı nesneleri tutması arzu edilen bir durum değildir. 

    Yukarıda da belirttiğimiz gibi Series nesnesinin yaratımında çok boyutlu NumPy dizileri kullanılamamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import pandas as pd

s = pd.Series([1, 2.4, 3, 4, 5, 6])
print(s.dtype)          # float64

a = np.array([1, 2, 3, 4, 5], dtype=np.float32)
s = pd.Series(a)
print(s.dtype)          # float32

s = pd.Series([1, 2, 3, 4, 5], dtype='float64')
print(s.dtype)          # float64

#------------------------------------------------------------------------------------------------------------------------------------
                                            49. Ders 13/09/2025 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir CSV dosyasından hareketle bir DataFrame nesnesi elde edildiğinde DataFrame nesnesinin bazı sütunları yazı içerebilmektedir. 
    Yani Series nesnelerinin dtype türünün nümerik değil yazısal olması durumuyla sık karşılaşılmaktadır. Bu tür durumlarda genellikle
    Series nesnesinin dtype türü "object" biçiminde karşımıza çıkar. Ancak yazıları saklamak için aslında "string" dtype türü daha 
    uygundur. Bu "string" dtype türünü Python'un "str" türü ile karıştırmayınız. Ancak yine de yazıların object dtype türü ile 
    karşımıza çıkmasında bir sakınca yoktur. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Series nesnesi sütun değerlerinin yanı sıra aynı zamanda index değerlerine de sahiptir. Index değerleri belirtilmediyse 0'dan 
    başlayan ardışıl tamsayılar index değeri olarak kullanılır. Örneğin:

    >>> import pandas as pd
    >>> s = pd.Series([10, 20, 30, 40, 50], dtype='float32')
    >>> s
    0    10.0
    1    20.0
    2    30.0
    3    40.0
    4    50.0
    dtype: float32

    index'leri istediğimiz biçimde set etmek için Series nesnesi yaratılırken (yani Series sınıfının __init__ metodunda) index 
    parametresini kullanabiliriz. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'], dtype='float32')
    >>> s
    a    10.0
    b    20.0
    c    30.0
    d    40.0
    e    50.0
    dtype: float32

    index parametresi bir liste, demet gibi dolaşılabilir bir nesne biçiminde girilebilir. Ancak string'ler dolaşılabilir bir nesne 
    olduğu halde biz string giremeyiz. Aşağıdaki yaratım exception oluşturur:

    s = pd.Series([10, 20, 30, 40, 50], index='abcde', dtype='float32')

    Ancak bu işlemi şöyle yapabiliriz:

    s = pd.Series([10, 20, 30, 40, 50], index=list('abcde'), dtype='float32')
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Series nesnesinin index bilgisini almak için index özniteliği kullanılabilir. Aynı zamanda index özniteliğine biz daha sonra değer 
    de atayabiliriz. Bu durumda index bilgisini değiştirmiş oluruz. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], dtype='float32')
    >>> s
    0    10.0
    1    20.0
    2    30.0
    3    40.0
    4    50.0
    dtype: float32
    >>> s.index
    RangeIndex(start=0, stop=5, step=1)
    >>> s.index = ['a', 'b', 'c', 'd', 'e']
    >>> s
    a    10.0
    b    20.0
    c    30.0
    d    40.0
    e    50.0
    dtype: float32

    Ancak index bilgisinin belli bir elemanına değer atayamayız. Örneğin:

    >>> s.index[2] = 'x'
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "C:\Users\aslan\AppData\Local\Programs\Python\Python312\Lib\site-packages\pandas\core\indexes\base.py", line 5383, in __setitem__
        raise TypeError("Index does not support mutable operations")
    TypeError: Index does not support mutable operations

    Yukarıda da belirttiğimiz gibi genellikle index değerleri dizi indeksleri gibi 0'dan itibaren tamsayılar biçiminde karşımıza 
    çıkmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    Series nesnelerinin elemanlarına erişmek için üç yol vardır. Series nesnesi s olmak üzere:

    1) Doğrudan köşeli parantez operatörü ile. Yani s[...] biçiminde.
    2) loc özniteliği ve köşeli parantez operatörü ile. Yani s.loc[...] biçiminde
    3) iloc özniteliği ve köşeli parantez operatörü ile. Yani s.iloc[...] biçiminde

    Biz s[...] erişimine  doğrudna indeksleme, s.loc[...] erişimine loc indekslemesi ve s.iloc[...] erişimine ise iloc indekslemesi 
    diyeceğiz. 

    Series nesneleri "değiştirilebilir (mutable)" nesnelerdir. Bir Series nesnesine erişip onu değiştirebiliriz. 

    Series nesnelerinin index belirten eğerlerine) "etiket (label)" de denilmektedir. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=['ali', 'veli', 'selami', 'ayşe', 'fatma'], dtype='float32')
    >>> s
    ali       10.0
    veli      20.0
    selami    30.0
    ayşe      40.0
    fatma     50.0
    dtype: float32

    Burada indeks belirten "ali", "veli", "selami", "ayşe" ve "fatma" değerlerine "etiket (label)" de denilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    Doğrudan köşeli parantez ile elemana erişmede köşeli parantez içerisindeki değerin önce etiket olup olmadığına bakılır. Eğer 
    bu değer bir etiket ise o etiketin değerine erişilir. Eğer köşeli parantez "içerisindeki değer bir etiket değilse ve etiketlerin 
    hiçbiri int türden değilse" bu durumda ilk eleman sıfır olmak üzere sıra numarasıyla erişim yapılır. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'], dtype='float32')
    >>> s
    a    10.0
    b    20.0
    c    30.0
    d    40.0
    e    50.0
    dtype: float32
    >>> s['c']
    30.0
    >>> s[3]
    40.0

    Ancak sayısal olmayan etiketlere sayısal bir indeks ile doğrudna köşeli parantezle erişmek "deprecated" yapılmıştır. Yeni Pandas
    sürümlerinde "deprecated" uyarısı verilmektedir. Dolayısıyla ileride doğrudan s[...] eişimi ile s.loc[...] erişimi arasında bir 
    fark kalmamaktadır. 

    Doğrudan indekslemede eğer index olarak kullanılan etiketlerde sayısal değerler varsa bu durumda doğrudan köşeli parantez ile 
    sırasal erişim yapılamamktadır. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=['ali', 'veli', 1, 'selami', 'ayşe'], dtype='float32')
    >>> s
    ali       10.0
    veli      20.0
    1         30.0
    selami    40.0
    ayşe      50.0
    dtype: float32
    >>> s[1]
    30.0
    >>> s[0]
    Traceback (most recent call last):
    File "C:\ProgramData\Anaconda3\lib\site-packages\pandas\core\indexes\base.py", line 3361, in get_loc
        return self._engine.get_loc(casted_key)
    File "pandas\_libs\index.pyx", line 76, in pandas._libs.index.IndexEngine.get_loc
    File "pandas\_libs\index.pyx", line 108, in pandas._libs.index.IndexEngine.get_loc
    File "pandas\_libs\hashtable_class_helper.pxi", line 5198, in pandas._libs.hashtable.PyObjectHashTable.get_item
    File "pandas\_libs\hashtable_class_helper.pxi", line 5206, in pandas._libs.hashtable.PyObjectHashTable.get_item
    KeyError: 0

    Tabii asıl olan elemanlara etiketler kullanılarak erişilmesidir. 

    Yukarıda da belirttiğimiz gibi eskiden doğrudan indeksleme "eğer böyle bir etiket varsa o etiketin belirttiği 
    değere eriş, yoksa sırasal eriş" anlamına geliyordu. Ancak artık doğrudan indeksleme ile "sırasal erişme"
    "deprecated" yapıldığı için ver ileride kaldırılabileceği için doğrudan indeksleme ile izleyen paragraflarda 
    açıklayacağımız loc indekslemesi arasında bir fark kalmamıştır.
----------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    s.loc[...] biçimindeki loc indekslemesinde erişimde her zaman köşeli parantez içerisindeki ifadenin bir etiket belirtmesi gerekir.  
    Yani bu indekslemede her zaman etiket dikkate alınmaktadır. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=list('abcde'), dtype='float32')
    >>> s
    a    10.0
    b    20.0
    c    30.0
    d    40.0
    e    50.0
    dtype: float32

    Burada indeksler birer harften oluşmaktadır. Biz bu Series nesnesinin elemanına s.iloc[...] ile erişeceksek köşeli parantezlerin
    içerisine etiket yerleştirmeliyiz. Sıra numarası yerleştiremeyiz. Örneğin:

    >>> s.loc['a']
    10.0
    >>> s.loc['e']
    50.0

    Yani loc özniteliği ile erişimde köşeli parantez içerisinde her zaman etiket bulundurulması gerekmektedir. Yukarıda da belirttiğimiz
    gibi eskiden doğrudan indeksleme ile loc indekslemesi arasında fark vardı. Ancak yukarıda belirttiğimiz "deprecated" durum yüzünden
    artık bir fark kalmamıştır. 

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    s.iloc[...] biçimindeki iloc indekslemesinde köşeli parantez içerisine her zaman sıra numarası belirten int bir değer yerleştirilmek 
    zorundadır. Erişim de her zaman listelerde olduğu gibi elemanın indeks numarasına göre yapılır. iloc indekslemesinde köşeli parantez 
    içerisine etiket yerleştiremeyiz. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=list('abcde'), dtype='float32')
    >>> s[2]
    30.0
    >>> s[3]
    40.0
    >>> s.iloc['e']
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "C:\Users\CSD\anaconda3\lib\site-packages\pandas\core\indexing.py", line 967, in __getitem__
        return self._getitem_axis(maybe_callable, axis=axis)
    File "C:\Users\CSD\anaconda3\lib\site-packages\pandas\core\indexing.py", line 1517, in _getitem_axis
        raise TypeError("Cannot index by location index with a non-integer key")
    TypeError: Cannot index by location index with a non-integer key

    Özetle biz erişimi s.loc biçiminde yapıyorsak köşeli parantez içerisine etiket yerleştirmek zorundayız. Biz erişimi s.iloc[...] 
    biçiminde yapıyorsak köşeli parantez içerisine sıra numarası yerleştirmek zorundayız. Ancak biz erişim s[...] biçiminde yapıyorsa 
    köşeli parantez içerisine etiket ya da sıra numarası yerleştirebiliriz. Ancak bu sıra numarası eğer hiçbir eleman int türden değilse 
    kullanılabilmektedir. Fakat "deprecated" meslesi yüzünden artık s[...] erişimi ile s.loc[...] erişimi arasında bir fark kalmayacaktır. 
    Genellikle programcılar s.loc[...] ve s.iloc[...] erişimlerini kullanırlar.

    Yukarıda da belirttiğimiz gibi default durumda zaten etiketler 0'dan itibaren tamsayılar biçiminde karşımıza çıkmaktadır. Bu 
    durumda loc indekslemesiyle iloc indeskelemesi arasında bir farklılık oluşmamaktadır. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50])
    >>> s
    0    10
    1    20
    2    30
    3    40
    4    50
    dtype: int64
    >>> s.loc[3]
    np.int64(40)
    >>> s.iloc[3]
    np.int64(40)
    >>> s[3]
    np.int64(40)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Doğrudan, loc ile ya da iloc ile indeksleme yaparken birden fazla index dolaşılabilir bir nesne biçiminde verilebilir. Bu durumda 
    o indeksteki elemanlardan bir Series nesnesi elde edilmektedir. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'], dtype='float32')
    >>> s[[1, 3, 4]]
    b    20.0
    d    40.0
    e    50.0
    dtype: float32
    >>> s[['c', 'a', 'e']]
    c    30.0
    a    10.0
    e    50.0
    dtype: float32
    >>> s.loc[['a', 'e', 'b']]
    a    10.0
    e    50.0
    b    20.0
    dtype: float32
    >>> s.iloc[[1, 3, 2]]
    b    20.0
    d    40.0
    c    30.0
    dtype: float32

    Bu tür erişimlerden bir view nesnesi elde edilmemektedir. Yeni bir Series nesnesi elde edilmektedir.  Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], dtype='float32')
    >>> s
    0     10.0
    1     20.0
    2     30.0
    3     40.0
    4     50.0
    5     60.0
    6     70.0
    7     80.0
    8     90.0
    9    100.0
    dtype: float32
    >>> k = s.iloc[[3, 5, 7]]
    >>> k
    3    40.0
    5    60.0
    7    80.0
    dtype: float32
    >>> k[0] = 1000
    >>> s
    0     10.0
    1     20.0
    2     30.0
    3     40.0
    4     50.0
    5     60.0
    6     70.0
    7     80.0
    8     90.0
    9    100.0
    dtype: float32

    Bu örnekte k'da değişiklik yapıldığında s'te bu değişiklik görülmemektedir. O halde burada bir view nesnesi söz konusu değildir. 

    Anımsanacağı gibi Python'da a[(1, 2, 3, 4, 5)] iafdesi ile a[1, 2, 3, 4, 5] şfadesi tamamen aynı anlama gelmektedir. Pandas'ta 
    a[1, 2, 3, 4, 5] gibi bir erişim çok boyutlu erişim anlamına geldiği için biz birden çok indeksi köşeli parantez içerisinde demet
    biçiminde veremeyiz. 

    Doğrudan indekslemede hem etiket hem de sıra numarası bir arada kullanılamz. Ancak bunlardan biri kullanılabilir. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'], dtype='float32')
    >>> k = s[['b', 'a', 'e']]
    >>> k
    b    20.0
    a    10.0
    e    50.0
    dtype: float32
    >>> k = s[[1, 3, 0]]
    >>> k
    b    20.0
    d    40.0
    a    10.0
    dtype: float32
    >>> k = s[['a', 3, 0]]
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
        
    File "C:\Users\CSD\anaconda3\lib\site-packages\pandas\core\indexes\base.py", line 5845, in _raise_if_missing
        raise KeyError(f"{not_found} not in index")
    ...
    KeyError: '[3, 0] not in index'

    Tabii yukarıda da belirtitğimiz gibi zaten doğrudan indeksleme artık loc indekslemesi ile aynı anlama gelmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd

s = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'], dtype='float32')
print(s)          

result = s[[1, 3, 4]]
print(result)

result = s[['a', 'c', 'd']]
print(result)

result = s.loc[['a', 'd', 'e']]
print(result)

result = s.iloc[[1, 3, 4]]
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Birden çok elemana erişerek atama da yapılabilmektedir. Bu durumda bu işlemden ilgili indekslerdeki tüm eelmanlar etkilenir. 
    Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], dtype='float32')
    >>> s[[3, 5, 7]] = 1000
    >>> s
    0      10.0
    1      20.0
    2      30.0
    3    1000.0
    4      50.0
    5    1000.0
    6      70.0
    7    1000.0
    8      90.0
    9     100.0
    dtype: float32
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Doğrudan, loc ile ya da iloc ile bool indeksleme de yapılabilmektedir. Yani biz bir Series nesnesinin belli elemanlarını bool 
    değerlerden oluşan dolaşılabilir bir nesne ile elde edebiliriz. Bu durumda True olan indekslere karşı gelen elemanlar elde edilmektedir. 
    bool indeksleme söz knusu olduğunda indesklemnin doğrudan, loc ile ya da iloc ile yapılması arasında bir farklılık oluşmamaktadır. 
    Yani bool indeskleme doğrudan, loc ile ya da iloc ile yapılabilmektedir. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'], dtype='float32')
    >>> s[[True, False, True, True, False]]
    a    10.0
    c    30.0
    d    40.0
    dtype: float32
    >>> s.loc[[True, False, True, True, False]]
    a    10.0
    c    30.0
    d    40.0
    dtype: float32
    >>> s.iloc[[True, False, True, True, False]]
    a    10.0
    c    30.0
    d    40.0
    dtype: float32
    
    NumPy dizilerinde olduğu gibi bool indekslemenin en önemli faydası filtreleme yapılabilmesidir. Belli koşulu sağlayan elemanlar 
    bu biçimde elde edilebilmektedir. Sonraki paragraflarda da ele alacağımız gibi bir Series nesnesi üzerinde karşılaştırma operatörlerini 
    uygularsak bool bir Series nesnesi elde ederiz. Örneğin:

    >>> s > 30
    a    False
    b    False
    c    False
    d     True
    e     True
    dtype: bool

    Bu sayede buradan elde edilen bool türden Seris nesnesi Series nesnesini filtrelemek için bool indekslemede kullanılabilir. 
    Örneğin:    

    >>> s[s > 30]
    d    40.0
    e    50.0
    dtype: float32
    >>> s.loc[s > 30]
    d    40.0
    e    50.0
    dtype: float32
    >>> s.iloc[s > 30]

    Ancak özel bir durum olarak dtype türü bool olan Series nesnesi ile iloc indekslemesi yapılamamakatdır. Örneğin:

    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "C:\ProgramData\Anaconda3\lib\site-packages\pandas\core\indexing.py", line 931, in __getitem__
        return self._getitem_axis(maybe_callable, axis=axis)
    File "C:\ProgramData\Anaconda3\lib\site-packages\pandas\core\indexing.py", line 1552, in _getitem_axis
        self._validate_key(key, axis)
    File "C:\ProgramData\Anaconda3\lib\site-packages\pandas\core\indexing.py", line 1400, in _validate_key
        raise ValueError(
    ValueError: iLocation based boolean indexing cannot use an indexable as a mask
#------------------------------------------------------------------------------------------------------------------------------------
 
import pandas as pd

s = pd.Series([3, 56, 12, 34, 21], dtype='float32')

k = s[s > 20]
print(k)

#------------------------------------------------------------------------------------------------------------------------------------
    Series nesnesinin içerisindeki değerler nesnenin values özniteliği ile bir NumPy dizisi olarak elde edilebilmektedir. Aslında 
    Series nesneleri, zaten değerleri NumPy dizisi içerisinde tutmaktadır. values elemanı da bize doğrudan aslında bu diziyi verir. 
    Bu dizide değişiklik yaptığımızda Series nesnesinin elemanında değişiklik yapmış oluruz. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], dtype='float32')
    >>> a = s.values
    >>> s
    0    10.0
    1    20.0
    2    30.0
    3    40.0
    4    50.0
    dtype: float32
    >>> a
    array([10., 20., 30., 40., 50.], dtype=float32)
    >>> a[0] = 100
    >>> s
    0    100.0
    1     20.0
    2     30.0
    3     40.0
    4     50.0
    dtype: float32

    Yani values örnek özniteliği zaten Series nesnesinin içerisinde tutulan NumPy dizisinin adresini bize vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------
  
import pandas as pd

s = pd.Series([3, 56, 12, 34, 21], dtype='float32')

a = s.values

print(a)

a[2] = 1000

print(s)

#------------------------------------------------------------------------------------------------------------------------------------
    Series nesnesinin sonuna eleman eklemek için eskiden Series sınıfının append metodu kullanıyordu. Sonra bu metot kaldırıldı. Artık 
    Series nesnesinin sonuna ekleme için concat fonksiyonu kullanılmaktadır. Aslında concat fonksiyonu DataFrame nesneleriyle de çalışmaktadır. 
    Biz burada concat fonksiyonuna Series nesnelerinden oluşan bir demet veriririz. Fonksiyon da bu Series nesnelerini birleştirerek 
    yeni bir Series nesnesi verir. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], dtype='float32')
    >>> k = pd.Series([100, 200], dtype='float32')
    >>> result = pd.concat((s, k))
    >>> result
    0     10.0
    1     20.0
    2     30.0
    3     40.0
    4     50.0
    0    100.0
    1    200.0
    dtype: float32

    Burada iki Series nesnesinin etiketlerinin de birleştirmeye dahil edildiğine dikkat ediniz. Böylece sonuçta aynı etiketlere sahip 
    elemanlardan oluşan bir Series nesnesi elde edilebilmektedir. Böylesi bir durumda etiket verilerek indeksleme yapıldığında (yani 
    doğrudan ya da loc indekslemesi yapıldığında) aynı değerden oluşan birden fazla eleman elde edilmektedir. Örneğin:
    
   >>> result[0]
    0     10.0
    0    100.0

    >>> result.loc[1]
    1     20.0
    1    200.0
    dtype: float32

    Ancak iloc indekslemesinde sıra numarası veridliği için ve her elemanın sıra numarası farklık olduğu için elemanlara tek tek 
    erişilebilmektedir. Örneğin:

    >>> result
    0     10.0
    1     20.0
    2     30.0
    3     40.0
    4     50.0
    0    100.0
    1    200.0
    dtype: float32
    >>> result.iloc[0]
    10.0
    >>> result.iloc[5]
    100.0

    concat işlemiyle elde edilen Series nesnesine yeniden sıfırdan indeks atayabilmek için concat fonksiyonunda ignore_index parametresi 
    True geçilmelidir:

   >>> s = pd.Series([10, 20, 30, 40, 50], dtype='float32')
    >>> k = pd.Series([100, 200], dtype='float32')
    >>> result = pd.concat((s, k), ignore_index=True)
    >>> result
    0     10.0
    1     20.0
    2     30.0
    3     40.0
    4     50.0
    5    100.0
    6    200.0
    dtype: float32
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    concat biçiminde bir fonksiyon varsa da araya eleman eklemek için bir insert fonksiyonu bulunmamaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Series nesnesinden eleman silmek için Series sınıfının drop metodu kullanılmaktadır (drop isimli bir fonksiyon yoktur). Bu metot 
    her zaman etiket temelinde çalışır. Hiçbir zaman sıra numarasıyla çalışmaz. Biz tek bir etiket de kullanabiliriz. Bir grup etiketi 
    dolaşılabilir bir nesne biçiminde de metoda verebiliriz. Metot default durumda "inplace" silme işlem yapmaz. Bize silinmiş yeni bir 
    Series nesnesi verir. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'], dtype='float32')
    >>> s
    a    10.0
    b    20.0
    c    30.0
    d    40.0
    e    50.0
    dtype: float32
    >>> result = s.drop('b')
    >>> result
    a    10.0
    c    30.0
    d    40.0
    e    50.0
    dtype: float32
    >>> result = s.drop(['a', 'e'])
    >>> result
    b    20.0
    c    30.0
    d    40.0
    dtype: float32

    inplace işlem yapmak için mettota inplace isimli bir parametre bulundurulmuştur. Bu parametre True geçilirse silme işlemi nesnenin
    kendi üzerinde yapılmaktadır. Tabii bu durumda metot herhangi bir değerle geri dönmez. Geri dönüş değeri olarak None değeri elde 
    edilir. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'], dtype='float32')
    >>> s
    a    10.0
    b    20.0
    c    30.0
    d    40.0
    e    50.0
    dtype: float32
    >>> s.drop(['a', 'e'], inplace=True)
    >>> s
    b    20.0
    c    30.0
    d    40.0
    dtype: float32
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Series nesnelerine isim de verilebilmektedir. Bunun için Series nesnesi yaratılırken name isimli parametre kullanılır. Daha sonra 
    biz bu ismi sınıfın name elemanı ile alıp istersek değiştirebiliriz. 

    >>> s = pd.Series([10, 20, 30, 40, 50], name='My Series', dtype='float32')
    >>> s
    0    10.0
    1    20.0
    2    30.0
    3    40.0
    4    50.0
    Name: My Series, dtype: float32
    >>> s.name = 'Your Series'
    >>> s
    0    10.0
    1    20.0
    2    30.0
    3    40.0
    4    50.0
    Name: Your Series, dtype: float32

    İsim verilmiş Series nesneleri DataFrame sütunu haline getirildiğinde bu isim DataFrame içerisindeki sütun ismi halinegekmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd

s = pd.Series([3, 56, 12, 34, 21], dtype='float32', name='Numbers')

print(s)

print(s.name)

s.name = 'Test Numbers'
print(s)

#------------------------------------------------------------------------------------------------------------------------------------
    Series sınıfının size örnek özniteliği bize nesnedeki eleman sayısını verir. Tabii biz bu eleman sayısını built-in len fonksiyonuyla 
    da elde edebiliriz. Benzer biçimde sınıfın shape isimli örnek özniteliği bize Series nesnesinin bouyutlarını bir demet biçiminde 
    vermektedir. Yukarıda da belirttiğimiz gibi Series nesneleri genellikle tek boyutlu olur. Örneğin:

    >>> s = pd.Series([10, 20, 30, 40, 50], name='Numbers', dtype='float32')
    >>> s
    0    10.0
    1    20.0
    2    30.0
    3    40.0
    4    50.0
    Name: Numbers, dtype: float32
    >>> len(s)
    5
    >>> s.size
    5
    >>> s.shape
    (5,)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    İki Series nesnesinin karşılıklı elemanlarını işleme sokabiliriz. Bu konuda davranış NumPy kütüphanesine benzerdir. Zaten Pandas 
    neredeyse vektörel işlem yapma bakımından NumPy kasamaktadır. Örneğin:

    >>> s = pd.Series([5, 10, 15, 20, 35], dtype='float32')
    >>> k = pd.Series([1, 2, 3, 4, 5], dtype='float32')
    >>> s
    0     5.0
    1    10.0
    2    15.0
    3    20.0
    4    35.0
    dtype: float32
    >>> k
    0    1.0
    1    2.0
    2    3.0
    3    4.0
    4    5.0
    dtype: float32
    >>> result = s + k
    >>> result
    0     6.0
    1    12.0
    2    18.0
    3    24.0
    4    40.0
    dtype: float32
    >>> result = s * k
    >>> result
    0      5.0
    1     20.0
    2     45.0
    3     80.0
    4    175.0
    dtype: float32
    >>> result = s > k
    >>> result
    0    True
    1    True
    2    True
    3    True
    4    True
    dtype: bool

    Burada karşılıklı elemanlardan kastedilen şey aslında indeks uyuşmasıdır. Elemanların sıra numarası ne olursa olsun etiketleri 
    uyuşanlar kendi aralarında işleme sokulmaktadır. Etiketleri uyuşmayanlar işlem sonucunda NaN biçiminde elde edilir. Yani işlem 
    sonucunun şöyle edildiğini varsayabilirsiniz: Önce sol taraftaki operand'ın tüm etiketleri, sonra sağ taraftaki operand'ın tüm 
    etiketleri peşi sıra uç uca eklenir. Uyuşan etiketler işleme sokulup sonuç o etiket ile oluşturulur, uyuşmayan etiketler işlem 
    sonucunda NaN biçiminde elde edilir. Burada etiket uyuşmasında karşılıklı elemanların uyuşmasına değil etiketlerin uyuşmasına 
    bakılmamaktadır. Yani uyuşum için etiketlerin karşılıklı uyuşumu önemli değildir. 

    import pandas as pd

    >>> a = pd.Series([1, 2, 3], index=['a', 'b', 'c'])
    >>> b = pd.Series([10, 20, 30])
    >>> c = a + b
    >>> c
    a   NaN
    b   NaN
    c   NaN
    0   NaN
    1   NaN
    2   NaN
    dtype: float64
    >>> a = pd.Series([1, 2, 3], index=['a', 'b', 'c'])
    >>> b = pd.Series([1, 2, 3], index=['x', 'b', 'y'])
    >>> c = a + b
    >>> c
    a    NaN
    b    4.0
    c    NaN
    x    NaN
    y    NaN
    dtype: float64
    >>> a = pd.Series([1, 2, 3], index=['a', 'b', 'c'])
    >>> b = pd.Series([10, 20, 30], index=['x', 'y', 'a'])
    >>> c = a + b
    >>> c
    a    31.0
    b     NaN
    c     NaN
    x     NaN
    y     NaN
    dtype: float64

    Aslında NumPy'ın aksine Pandas'ta iki Series nesnesi üzerinde işlem yapılırken bu nesnelerin aynı uzunluğa sahip olması da 
    gerekmemektedir. Örneğin:

    >>> s = pd.Series([1, 2, 3, 4, 5], dtype='float32')
    >>> k = pd.Series([10, 20, 30], dtype='float32')
    >>> result = s + k
    >>> result
    0    11.0
    1    22.0
    2    33.0
    3     NaN
    4     NaN
    dtype: float32
    
    Burada s ve k'nın ilk üç etiketi uyuştuğu için toplanmıştır. Ancak s'teki fazlalık NaN biçiminde sonuca yansıtılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Series sınıfının pek çok faydalı metodu vardır. Bu metotlar bize yaptıklar işlem sonucunda yeni bir Series nesnesi verirler. Aslında 
    bu metotlar NumPy metotlarına çok benzemektedir. Anımsanacağı gibi NumPy'da pek çok işlem hem metotlarla hem de fonksiyonlarla 
    yapılabilmektedir. Ancak Pandas'ta ağırlıklı olarak metotlar kullanılmaktadır. Yani pek işlem yalnızca metotlarla yapıkmaktadır. 
    Pek çok işlemin fonksiyon karşılığı yoktur. Tabii metotlar bize genel olarak yeni bir Series nesnesi oluşturup vermektedir. 

    - abs metodu elemanların mutlak değerlerini elde eder. add metodu karşılıklı elemanları toplar (yani + operatörü ile yapılanı yapar). 
    Örneğin:

    >>> s = pd.Series([3, -7, 7, 4 -3])
    >>> k = s.abs()
    >>> k
    0    3
    1    7
    2    7
    3    1
    dtype: int64

    - min ve max metotları nesnesi içerisindeki en küçük ve en büyük elemanları bize verir. 

    - sort_values metodu sıraya dizme ilmei yapar. Bu metodun inplace parametresi de vardır. Örneğin:

    >>> s = pd.Series([4, 18, -4, 54, 10])
    >>> s
    0     4
    1    18
    2    -4
    3    54
    4    10
    dtype: int64
    >>> s.sort_values()
    2    -4
    0     4
    4    10
    1    18
    3    54

    - argmax, argmin, argsort metotoları sırasıyla en büyük elemanın indeksini, en küçük elemanın indeksini ve sort edilme durumundaki 
    indeksleri vermektedir. Örneğin:

    >>> s.argsort()
    0    3
    1    2
    2    1
    3    4
    4    0
    dtype: int64

    Diğer önemli bazı metotlar da şunlardır:

    - count
    - mean
    - std
    - var
    - mode
    - median
    - cumsum
    - unique

    unique metodu nesnedeki tek elemanları elde eder. Yani yineleyen elemanlardan kurtulmak için metot kullanılabilir. Ancak Pandas'ın
    uniuque metodu NumPy'ın unique fonksiyonu gibi sıraya dizmew işlemi yapmamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Series nesnesinin dtype türünü değiştirmek isteyebiliriz. Bunun için astype metodu kullanılmaktadır. astype metodu bize 
    belirttiğimiz türden yeni bir Series nesnesi vermektedir. Örneğin:

    >>> s = pd.Series([12, 8, 4, 2, 9], dtype='float32')
    >>> k = s.astype('int32')
    >>> k
    0    12
    1     8
    2     4
    3     2
    4     9
    dtype: int32

    C'de None biçiminde bir tür yoktur. Python'daki None değeri Numpy ve Pandas'ta eğer dtype 'float32' ya da 'float64' ise 
    NaN (Not a Number) ile ifade edilmektedir. Eğer nesnenin dtype türü tamsayı türlerine ilişkinse zaten NaN değeri söz konusu olamaz. 
    
    - count metodu Nan olmayan elemanların sayısını vermektedir. Örneğin:

    >>> s = pd.Series([10, None, 30, None, 50], dtype='float32')
    >>> result = s.count()
    >>> result
    3

    - dot isimli metot "dot product" yapmaktadır. Yani karşılıklı (etiket bakımından uyuşan) elemanların çarpımını bulmaktadır. Örneğin:

    >>> a = pd.Series([1, 2, 3], dtype='float32')
    >>> b = pd.Series([4, 5, 6], dtype='float32')
    >>> c = a.dot(b)
    >>> c
    32.0
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir veri kümesi üzerinde çalışırken çeşitli biçimlerde "eksik verilerle" karşılaşabiliriz. Örneğin bir anket uygulamasında kişiler
    bazı sorulara yanıt vermek istememiş olabilir. Ya da verilerin sensörlerle elde edildiği durumda sensör arızalarından dolayı bazı 
    veriler elde edilememiş olabilir. Bu tür durumlarda çeşitli yöntemler izlenebilmektedir. Eksik verilerin tamamen atılması (bir veri 
    tablosu söz konusuysa eksik verilerin bulunduğu satırın atılması) ya da eksik verilerin diğer verilerden hareketle doldurulması (
    buna İngilizce "imputation"   denilmektedir) sık kullanılan yöntemlerdendir. Pandas'ta eksik veirler Series ya da DataFrame nesnelerinde 
    NaN ile görüntülenmektedir. 
    
    - Series sınıfında eksik verilerin ele alınmasına yönelik çeşitli metotlar da bulundurulmuştur. dropna metodu eksik verileri atmak 
    için kullanılmaktadır. Yani NaN değerleri Series nesnesinden silinir. Metot bize eksik değerleri silinmiş olan yeni bir Series 
    nesnesi verir. Örneğin:

    >>> s = pd.Series([3, None, 7, 9, None, 10], dtype='float32')
    >>> s
    0     3.0
    1     NaN
    2     7.0
    3     9.0
    4     NaN
    5    10.0
    dtype: float32
    >>> result = s.dropna()
    >>> result
    0     3.0
    2     7.0
    3     9.0
    5    10.0
    dtype: float32

    dropna metodunun inplace parametresi True geçilirse eksik verilerin silinmesi inplace olarak yapılmaktadır. 

    fillna isimli metot eksik verileri (yani NaN olan elemanları) spesifik bir değerle doldurmaktadır. Örneğin biz eksik verileri 
    aşağıdaki gibi ortalamayla doldurabiliriz:

    >>> s = pd.Series([3, None, 7, 9, None, 1], dtype='float32')
    >>> s
    0    3.0
    1    NaN
    2    7.0
    3    9.0
    4    NaN
    5    1.0
    dtype: float32
    >>> s.fillna(s.mean())
    0    3.0
    1    5.0
    2    7.0
    3    9.0
    4    5.0
    5    1.0
    dtype: float32

    mean metodunun eksik verileri hesaba katmadığına dikkat ediniz. Yukarıdaki s nesnesinin mean ile alınan ortalaması bu yüzden 
    5 çıkmıştır. Bu netodun da inplace parametresi bulunmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
   - Series sınıfının isna ya da isnull metodu metodu Nan olanların True olduğu Nan olmayanların False olduğu bir Series nesnesi 
    vermektedir. Bu sayede biz NaN değerler üzerinde filtreleme işlemleri yapabiliriz. isna ile isnaull arasında hiçbir farklılık 
    yoktur. Örneğin:

    >>> s = pd.Series([1, 2, None, 2, None, 5, None], dtype=np.float32)
    >>> s
    0    1.0
    1    2.0
    2    NaN
    3    2.0
    4    NaN
    5    5.0
    6    NaN
    >>> s[s.isna()]
    2   NaN
    4   NaN
    6   NaN
    dtype: float32
    >>> s = pd.Series([1, 2, None, 2, None, 5, None], dtype=np.float32)
    >>> s[~s.isna()]
    0    1.0
    1    2.0
    3    2.0
    5    5.0
    dtype: float32

    Son örnekteki ~ operatörü bool türdne Series nesnesindeki True değerleri False, False değerleri True yapmaktadır. 

    Örneğin biz eksik verilerin sayısını şöyle elde edebiliriz:

    >>> s = pd.Series([1, 2, None, 2, None, 5, None], dtype=np.float32)
    >>> s.isna().sum()
    np.int64(3)
#------------------------------------------------------------------------------------------------------------------------------------    

#------------------------------------------------------------------------------------------------------------------------------------
    - hist isimli metot histogram çizmektedir. Ancak histogram için arka planda Matplotlib kütüphanesini kullanmaktadır. Örneğin:

    import pandas as pd
    import numpy as np

    s = pd.Series(np.random.randn(1000))

    s.hist()

    Burada önce standart normal dağılılma ilişkin rastgele değerler elde edilmiş sonra o değerlerden bir Series nesnesi oluşturularak 
    Series sınıfının hist metodu ile histogram çizilmiştir. Eğer komut satırında aynı şeyi yapacaksanız matplotlib kütüphanesinin show
    metodunu da çağırmalısınız. Örneğin:

    >>> import pandas as pd
    >>> import numpy as np
    >>> import matplotlib.pyplot as plt
    >>> s = pd.Series(np.random.randn(1000))
    >>> s.hist()
    <Axes: >
    >>> plt.show()

    Histogramdaki çubuk sayısı hist parametresi ile ayarlanabilmektedir. Default çubuk sayısı 10 tandedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                            50.Ders 14/09/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------    
    - Series sınıfının median, mean, mode, std ve var metotları klasik istatistiksel işlemleri yapmaktadır. Bu metotlar NaN değerler 
    sanki yokmuş gibi davranmaktadır. Örneğin:

    >>> s = pd.Series([1, 2, 3, 5, 8, 9, 4, 5, 2, 5])
    >>> s.mean()
    4.4
    >>> s.median()
    4.5
    >>> s.mode()
    0    5
    dtype: int64
    >>> s.std()
    2.590581230363393
    >>> s.var()
    6.711111111111112

    Ancak Pandas'taki std ve var metotları standart sapma ve varyans hesaplarken n değerine değil n - 1 değerine bölme yapmaktadır. 
    Aslında bu metotlar n - ddof değerine bölüm uygulamaktadır. Default ddof değeri 1'dir. Eğer bu metotların NumPy kütüphanesinde 
    olduğu gibi n'e bölme yapmasını istiyorsanır ddof parametresine 0 girmelisiniz. Örneğin:

    >>> s = pd.Series([1, 2, 3, 5, 8, 9, 4, 5, 2, 5])
    >>> s.std()
    2.590581230363393
    >>> s.std(ddof=0)
    2.4576411454889016
    >>> a = s.to_numpy()
    >>> a
    array([1, 2, 3, 5, 8, 9, 4, 5, 2, 5], dtype=int64)
    >>> a.std()
    2.4576411454889016
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Series sınıfının values örnek özniteliği bize Series nesnesi içerisindeki değerleri bir NumPy dizisi olarak veriyodu. Aynı işlem 
    Series sınıfının array örnek özniteliği ile de yapılabilmektedir. array örnek özniteliği aynı NumPy dizisine referans eden başka 
    bir sınıf türünden nesne vermektedir. 

    >>> b = s.array
    >>> id(b)
    1689465751568
    >>> b[3] = 1000
    >>> s
    0       1.0
    1       2.0
    2     100.0
    3    1000.0
    4       5.0
    dtype: float32

    array özniteliği ile values özniteliği birbirine çok benzemektedir. array özniteliği gerçek bir NumPy dizisi vermez. Pandas içeisinde 
    sarmalanmış olan bir dizi vermektedir. 

    Series sınıfının to_numpy metodu values örnek özniteliği gibidir. Ancak to_numpy değişik seçeneklere de sahiptir. Default durumda 
    to_numpy metodu ile values örnek özniteliği aynı Numpy dizisini vermektedir. Fakat örneğin to_numpy metodunda copy=True geçilirse 
    metot bize kopyalama yaparak başka bir Numpy dizisi verir. Örneğin:

    >>> s = pd.Series([1, 2, 3, 4, 5], dtype='float32')
    >>> a = s.values
    >>> a
    array([1., 2., 3., 4., 5.], dtype=float32)
    >>> id(a)
    1689358507664
    >>> b = s.to_numpy()
    >>> b
    array([1., 2., 3., 4., 5.], dtype=float32)
    >>> id(b)
    1689358507664
    >>> c = s.to_numpy(copy=True)
    >>> c
    array([1., 2., 3., 4., 5.], dtype=float32)
    >>> id(c)
    1689358507856
    >>> c[2] = 1000
    >>> s
    0    1.0
    1    2.0
    2    3.0
    3    4.0
    4    5.0
    dtype: float32

    Özetle bir Series nesnesi içerisindeki değerleri NumPy dizisi olarak almak istersek values örnek özniteliğini ya da to_numpy 
    metodunu kullanabiliriz.

    Eğer Series nesnesi içerisindeki değerleri bir Python listesi biçiminde elde etmek istersek Series sınıfının to_list metodunu 
    kullanabiliriz. Tabii to_list her çağrıldığında aslında bize farklı bir list nesnesi verecektir. Örneğin:

    >>> s = pd.Series([1, 2, 3, 4, 5], dtype='float32')
    >>> s
    0    1.0
    1    2.0
    2    3.0
    3    4.0
    4    5.0
    dtype: float32
    >>> a = s.to_list()
    >>> a
    [1.0, 2.0, 3.0, 4.0, 5.0]
    >>> id(a)
    1689468256384
    >>> b = s.to_list()
    >>> id(b)
    1689466572096

    NumPy'da da tolist isimli (isimde alt tire olmadığına dikkat ediniz) bir metodun olduğunu anımsayınız.
#------------------------------------------------------------------------------------------------------------------------------------
 
#------------------------------------------------------------------------------------------------------------------------------------
    Series sınıfının daha pek çok faydalı metodu vardır. Bu metotları Pandas dokümanlarından inceleyebilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Pandas'taki en önemli veri yapısı DataFrame denilen veri yapısıdır. DataFrame tipik olarak istatistiksel veri kümelerini temsil 
    etmek için düşünülmüştür. DataFrame nesnesinin sütunlardan oluşan matrisel bir yapısı vardır. Aslında DataFrame nesnesi Series 
    nesnelerinden oluşmaktadır. Yani DataFrame nesnelerinin sütunları Series nesneleridir. Başka bir deyişle DataFrame nesnesi Series
    nesnelerinin yan yana dizilmesinden oluşmaktadır.

    NumPy dizilerinin elemanları aynı türden olur. Her ne kadar elemanları aynı türden olmayan NumPy dizileri de oluşturulabiliyorsa 
    da (örneğin dtype='object' alınarak) bu biçimde NumPy dizilerinin uygulamada kullanımı yoktur. Pandas kütüphanesinin en önemli 
    özelliği sütunları farklı türlerden olabilen, ismine DataFrame denilen veri yapısına sahip olmasıdır. İstatistik ve veri bilimindeki 
    "veri kümeleri (datasets)" de zaten böyle bir yapıya sahiptir. Bu bakımdan veri kümeleri ilişkisel veritabanlarındaki tablolara 
    da benzetilebilir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir DataFrame nesnesi tipik olarak DataFrame sınıfının __init__ metodu yoluyla oluşturulur. DataFrame sütunlardan oluşmaktadır. 
    DataFrame nesnelerinde hem satırların hem de sütunların etiketleri (yani indeksleri) vardır. Bir DataFrame nesnesinde satır etiketleri 
    index parametresiyle, sütun etiketleri ise columns parametresiyle belirlenebilmektedir. Genellikle satırlar Series nesnelerinde 
    olduğu gibi sayısal indeks biçiminde sütunlar ise birer yazı biçiminde karşımıza çıkar. 
    
    DataFrame nesnesi iki boyutlu bir Python listesi ile oluşturulabilir. Bu durumda listenin içerisindeki her liste bir satırı 
    belirtmektedir. Eğer index parametresi ve columns parametresi belirtilmezse oluşturulan DataFrame nesnesinin satır etiketleri 
    ve sütun etiketleri 0, 1, 2, ... biçiminde sayısal değerlerden oluşturulur Örneğin:

    >>> df = pd.DataFrame([[10, 20, 30], [40, 50, 60], [70, 80, 90]])
    >>> df
        0   1   2
    0  10  20  30
    1  40  50  60
    2  70  80  90

    Biz satırlara ilişkin etiketleri index parametresiyle, sütunlara ilişkin etiketleri ise columns parametresiyle belirleyebiliriz. 
    Örneğin:

    >>> df = pd.DataFrame([[10, 20, 30], [40, 50, 60], [70, 80, 90]], index=['a', 'b', 'c'], columns=['X', 'Y', 'Z'])
    >>> df
        X   Y   Z
    a  10  20  30
    b  40  50  60
    c  70  80  90
    
    Ancak yukarıda da belirttiğimiz gibi genellikle DataFRame nesnelerinin sütunlarına yazısal etiketleri (yani isimler) iliştirilir 
    ancak satırlarına etiket iliştirilmez. Satırlar default olarak sayısal biçimde karşımıza çıkar.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii DataFrame nesneleri aslında farklı türlere sütunlardan oluşturulabilir. Örneğin:

    >>> df = pd.DataFrame([['Ali Serçe', 'Erkek', 172, 72], ['Fehmi Ak', 'Erkek', 182, 92], ['Ayşe Er', 'Kadın', 168, 68]], 
    columns=['Adı Soyadı', 'Cinsiyet', 'Boy', 'Kilo'])
    >>> df
    Adı Soyadı Cinsiyet  Boy  Kilo
    0  Ali Serçe    Erkek  172    72
    1   Fehmi Ak    Erkek  182    92
    2    Ayşe Er    Kadın  168    68

    Bir DataFrame nesnesi iki boyutlu bir NumPy dizisi ile de yaratılabilir. Örneğin:

   >>> a = np.random.randint(0, 100, (10, 5))
    >>> a
    array([[57, 61,  0, 88, 72],
        [10, 47, 38, 19, 79],
        [79, 51, 14, 50, 88],
        [36, 47,  8, 52, 67],
        [25, 88, 42, 46, 42],
        [37, 98, 36, 96, 69],
        [82, 97, 14, 53, 92],
        [43, 89, 57, 62, 94],
        [21, 65, 26, 80, 40],
        [86, 91, 91, 10, 16]])
    >>> df = pd.DataFrame(a, columns=['A', 'B', 'C', 'D', 'E'])
    >>> df
        A   B   C   D   E
    0  57  61   0  88  72
    1  10  47  38  19  79
    2  79  51  14  50  88
    3  36  47   8  52  67
    4  25  88  42  46  42
    5  37  98  36  96  69
    6  82  97  14  53  92
    7  43  89  57  62  94
    8  21  65  26  80  40
    9  86  91  91  10  16    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame nesnesi bir sözlük ile de yaratılabilir. Bu durumda sözlüğün anahtarları sütun isimlerini, değerleri de sütunlardaki 
    değerleri belirtir. Örneğin:

    >>> d = {'Adı Soyadı': ['Kaan Aslan', 'Ali Serçe', 'Ayşe Er'], 'Boy': [182, 174, 168], 'Kilo': [78, 69, 56]}
    >>> d
    {'Adı Soyadı': ['Kaan Aslan', 'Ali Serçe', 'Ayşe Er'], 'Boy': [182, 174, 168], 'Kilo': [78, 69, 56]}
    >>> df = pd.DataFrame(d)
    >>> df
    Adı Soyadı  Boy  Kilo
    0  Kaan Aslan  182    78
    1   Ali Serçe  174    69
    2     Ayşe Er  168    56

    Görüldüğü gibi sözlüğün anahtarları sütun isimleri haline gelmiştir. Örneğimizde sözlüğün değerlerinin bir liste biçiminde 
    oluşturulduğuna dikkat ediniz. Bu listenin elemanları ilgili sütunun satır değerlerini belirtmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir DataFrame nesnesinin sütunları farklı türlerden olabilir. Örneğin:

    >>> d = {'a': np.array([1, 2, 3], dtype='float32'), 'b': np.array([4, 5, 6], dtype='int32'), 
        'c': np.array([True, False, True], dtype='bool')}
    >>> df = pd.DataFrame(d)
    >>> df
        a   b     c
    0  1.0  4   True
    1  2.0  5  False
    2  3.0  6   True

    Örneğin:

    >>> df = pd.DataFrame({'A': np.array([1, 2, 3], dtype='int32'), 'B': np.array(['X', 'Y', 'Z'], dtype='str'), 
        'C': np.array([1.2, 4.5, 7.8], dtype='float32')})
    >>> df
    A  B    C
    0  1  X  1.2
    1  2  Y  4.5
    2  3  Z  7.8

    Bir DataFrame nesnesinin sütunları farklı türlerden olabileceğine göre bu durumda DataFrame nesnesi için tek bir dtype türünden 
    bahsedilemez. Çünkü her sütunun ayrı bir dtype türü vardır. İşte DataFrame sınıfının dtypes örnek özniteliği bize bir Series 
    nesnesi olarak tüm sütunların türlerini vermektedir. Örneğin:

    >>> d = {'a': np.array([1, 2, 3], dtype='float32'), 'b': np.array([4, 5, 6], dtype='int32'), 
        'c': np.array([True, False, True], dtype='bool')}
    >>> df = pd.DataFrame(d)
    >>> df.dtypes
    a    float32
    b      int32
    c       bool
    dtype: object

    Burada Series nesnesinin elemanlarının etiketleri DataFrame nesnesinin sütunlarından değerleri ise onların dtype 
    türlerinden oluşmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    Bir DataFrame nesnesinin elemanlarına erişebiliriz. İndeksleme işlemi Series nesnelerinde olduğu gibi üç yolla yapılmaktadır. 
    df değişkeninin DataFrame türünden olduğunu varsayalım:

    1) df[...] biçiminde indeksleme. Buna "doğrudan indeksleme" diyeceğiz. 
    2) df.loc[...] biçiminde indeksleme. Buna "loc indekslemesi" diyeceğiz.
    3) df.iloc[...] iloc biçiminde indeksleme. Buna da "iloc indekslemesi" diyeceğiz. 
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    Doğrudan df[...] biçiminde indeskelemede biz sütunları elde ederiz. Bu durumda indeks olarak sütun etiketlerinin (yani isimleri)
    verilmesi gerekir. (Sütun indeksleri kullanılamamaktadır.) Eğer doğrudan indekslemede tek bir sütun belirtiliyorsa bu durumda 
    bize o sütun bir Series nesnesi biçiminde verilir. Örneğin:

   >>> df = pd.DataFrame({
    ...     'Adı Soyadı': ['Ali Serçe', 'Ayşe Er', 'Hakan Demir', 'Fehmi Uzun', 'Esra Elli'],
    ...     'Boy': [175, 167, 183, 175, 169],
    ...     'Kilo': [74.5, 62.4, 82.4, 92, 71],
    ...     'Cinsiyet': ['Erkek', 'Kadın', 'Erkek', 'Erkek', 'Kadın']
    ...     })
    >>> s = df['Boy']
    >>> s
    0    175
    1    167
    2    183
    3    175
    4    169
    Name: Boy, dtype: int64
    >>> type(s)
    <class 'pandas.core.series.Series'>
    >>> s = df['Cinsiyet']
    >>> s
    0    Erkek
    1    Kadın
    2    Erkek
    3    Erkek
    4    Kadın
    Name: Cinsiyet, dtype: object
    >>> type(s)
    <class 'pandas.core.series.Series'>

    Doğrudan indekslemede bir liste biçiminde birden fazla sütun da belirtilebilir. Bu durumda bize Series nesnesi değil DataFrame nesnesi 
    verilir. Örneğin:

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    0    Ali Serçe  175  74.5    Erkek
    1      Ayşe Er  167  62.4    Kadın
    2  Hakan Demir  183  82.4    Erkek
    3   Fehmi Uzun  175  92.0    Erkek
    4    Esra Elli  169  71.0    Kadın
    >>> result = df[['Kilo', 'Cinsiyet']]
    >>> result
    Kilo Cinsiyet
    0  74.5    Erkek
    1  62.4    Kadın
    2  82.4    Erkek
    3  92.0    Erkek
    4  71.0    Kadın
    >>> type(result)
    <class 'pandas.core.frame.DataFrame'>

    Birden fazla sütunun artık Series belirtmediğine DatFrame belirttiğine dikkat ediniz.
    
    Bir DataFrame nesnesinin doğrudan indekslenmesiyle elde edilen Series nesneleri aslında view belirtmektedir. Ancak bu view 
    nesnelerinin güncellenmesi tavsiye edilmemektedir. Ancak doğrudan indekslemeden elde edilen DataFrame nesneleri bir view belirtmemektedir. 
    Örneğin:
   
    >>> a = np.arange(50).reshape((10, 5))
    >>> df = pd.DataFrame(a, columns=['A', 'B', 'C', 'D', 'E'])
    >>> df
        A   B   C   D   E
    0   0   1   2   3   4
    1   5   6   7   8   9
    2  10  11  12  13  14
    3  15  16  17  18  19
    4  20  21  22  23  24
    5  25  26  27  28  29
    6  30  31  32  33  34
    7  35  36  37  38  39
    8  40  41  42  43  44
    9  45  46  47  48  49
    >>> s = df['C']
    >>> s
    0     2
    1     7
    2    12
    3    17
    4    22
    5    27
    6    32
    7    37
    8    42
    9    47
    Name: C, dtype: int32
    >>> s[0] = 100
    >>> df
        A   B    C   D   E
    0   0   1  100   3   4
    1   5   6    7   8   9
    2  10  11   12  13  14
    3  15  16   17  18  19
    4  20  21   22  23  24
    5  25  26   27  28  29
    6  30  31   32  33  34
    7  35  36   37  38  39
    8  40  41   42  43  44
    9  45  46   47  48  49

    Bu örnekte s değişkenine atadığımız Series nesnesi üzerinde değişiklik yaptığımızda bundan asıl DataFrame nesnesinin etkilendiğine
    dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    loc indekslemesinde her zaman etiketler kullanılmaktadır. İndeksleme köşeli parantezler içerisinde yallnızca satır etiketi verilerek 
    yapılırsa o satırın tüm sütun elemanları bir Series nesnesi biçiminde elde edilmektedir. Tabii sütunların türleri farklı olabileceğine 
    göre elde edieln Series nesnesinin de dtype türü object olur. Örneğin:

    >>> df = pd.DataFrame({
    ...     'Adı Soyadı': ['Ali Serçe', 'Ayşe Er', 'Hakan Demir', 'Fehmi Uzun', 'Esra Elli'],
    ...     'Boy': [175, 167, 183, 175, 169],
    ...     'Kilo': [74.5, 62.4, 82.4, 92, 71],
    ...     'Cinsiyet': ['Erkek', 'Kadın', 'Erkek', 'Erkek', 'Kadın']
    ...     }, index=['a', 'b', 'c', 'd', 'e'])

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın
    
    >>> df.loc['d']
    Adı Soyadı    Fehmi Uzun
    Boy                  175
    Kilo                92.0
    Cinsiyet           Erkek
    Name: d, dtype: object

    Burada df['d'] ifadesi ile biz DataFrame nesnesinin 'd' etiketli satırını bir Series nesnesi olarak elde ettik. Elde edilen Series
    nesnesinin etiketleri sütun isimlerinden değerleri de o satırdaki o sütunlara karşı gelen değerlerden oluşmaktadır. 

    loc indekslemesinde biz [] operatörünün içerisine satırlar için birden fazla birden fazla etiket de girebiliriz. Bu durumda tabii
    birden fazla satır elde edileceği için bize bir DatFarme nesnesi verilecektir. Örneğin:

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın

    >>> df.loc[['b', 'd']]
    Adı Soyadı  Boy  Kilo Cinsiyet
    b     Ayşe Er  167  62.4    Kadın
    d  Fehmi Uzun  175  92.0    Erkek
    
    Pandas indekslemelerinde tek bir satır ya da sütunun Series nesnesi olarak ancak birden fazla satır ya da sütunun DataFrame nesnesi 
    olarak verildiğine dikkat ediniz. 

    loc indesklemesinde satırı belirttikten sonra sütun belirlemesi de yapabiliriz. Bu durumda DataFrame içerisindeki belli bir hücrenin
    içerisindeki değer elde edilir. Tabii loc indekslemesinde her zaman satır ve sütunlardaki etiketlerin kullanılması gerekmektedir. 
    Örneğin:

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın
   
    >>> df.loc['d', 'Kilo']
    92.0
    >>> df.loc['a', 'Cinsiyet']
    'Erkek'

    Sütunlarda da birden fazla sütun seçilebilir. Örneğin:

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın

    >>> df.loc['c', [['Boy', 'Kilo']]
    >>> df.loc['c', ['Boy', 'Kilo']]
    Boy      183
    Kilo    82.4
    Name: c, dtype: object

    Hem satırda hem de sütunda birdeh fazla elema seçilebilir. Örneğin:

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın

    >>> df.loc[['a', 'd'], ['Boy', 'Kilo']]
    Boy  Kilo
    a  175  74.5
    d  175  92.0

    İndekslemelerde dilimleme de yapılabilir. Köşeli parantezler içerisinde satırlar ya da sütunlarda ya da her ikisinde dilim 
    ifadesi kullanılabilir. Ancak dilimleme yine her zaman etiketlerle yapılmak zorundadır. loc indekslemesindesk, dilimlerdeki 
    bitiş etikei dilimlemeye dahildir. Örneğin:

        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın

    >>> df.loc['a':'d']
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek

    Burada indeksleme sütun belirtilmemiştir. O halde satırların tüm sütunları elde edilmektedir. 'd' satırının da dilimlemeye dahil 
    olduğuna dikkat ediniz. Örneğin:

    >>> df.loc['a':'d', 'Boy':'Cinsiyet']
    Boy  Kilo Cinsiyet
    a  175  74.5    Erkek
    b  167  62.4    Kadın
    c  183  82.4    Erkek
    d  175  92.0    Erkek

    Tüm satırları ya da tüm sütunları belirtmek için yine ':' operatörü tek başına kullanılabilir. Örneğin:

    >>> df.loc[:, ['Boy', 'Cinsiyet']]
    Boy Cinsiyet
    a  175    Erkek
    b  167    Kadın
    c  183    Erkek
    d  175    Erkek
    e  169    Kadın

    loc indekslemesinde step miktarı da sayısal biçimde belirtilebilir. Örneğin:

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın

    >>> df.loc['a':'e':2]
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    c  Hakan Demir  183  82.4    Erkek
    e    Esra Elli  169  71.0    Kadın

    Burada 'a' satırından 'e' satırına ikişer atlamalı dilimleme yapılmıştır.

    loc indekslemesinde bool indeksleme de yapılabilir. Örneğin:

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın

    >>> df[[True, False, True, False, True]]
        Adı Soyadı  Boy  Kilo Cinsiyet
        a    Ali Serçe  175  74.5    Erkek
        c  Hakan Demir  183  82.4    Erkek
        e    Esra Elli  169  71.0    Kadın

    Tabii bool indeskleme sayesinde filtreleme de yapılabilmektedir. Örneğin biz kilosu 80'in yukarısında olan satırları şöyle elde
    edebiliriz:

    >>> df.loc[df['Kilo'] > 80]
        Adı Soyadı  Boy  Kilo Cinsiyet
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek

    Burada df['Kilo'] > 80 ifadesi ile bool bir Series nesnesi elde edilmektedir. Bu bool türden Series nesnesi loc indekslemesinde 
    kullanılmıştır. Örneğin:

    >>> df.loc[df['Kilo'] > 80, ['Adı Soyadı', 'Kilo']]
    Adı Soyadı  Kilo
    c  Hakan Demir  82.4
    d   Fehmi Uzun  92.0

    Burada Kilosu 80'den büyük olan Kişilerin "Adı Soyadı" ve "Kilo" bilgileri elde edilmiştir.

    loc indekslemesinde her zaman etiketler kullanılmaktadır. Tabii satır etiketleri default durumda sayısal bir biçimde bulunduğundan
    kişiler loc indeskelemesiyle sayısal indeksleme yaptığını sanabilmektedir. Örneğin:

    >>> df = pd.DataFrame({
    ...     'Adı Soyadı': ['Ali Serçe', 'Ayşe Er', 'Hakan Demir', 'Fehmi Uzun', 'Esra Elli'],
    ...     'Boy': [175, 167, 183, 175, 169],
    ...     'Kilo': [74.5, 62.4, 82.4, 92, 71],
    ...     'Cinsiyet': ['Erkek', 'Kadın', 'Erkek', 'Erkek', 'Kadın']
    ...     })

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    0    Ali Serçe  175  74.5    Erkek
    1      Ayşe Er  167  62.4    Kadın
    2  Hakan Demir  183  82.4    Erkek
    3   Fehmi Uzun  175  92.0    Erkek
    4    Esra Elli  169  71.0    Kadın
    
    >>> df.loc[3]
    Adı Soyadı    Fehmi Uzun
    Boy                  175
    Kilo                92.0
    Cinsiyet           Erkek
    Name: 3, dtype: object
    
    >>> df.loc[1:4]
        Adı Soyadı  Boy  Kilo Cinsiyet
    1      Ayşe Er  167  62.4    Kadın
    2  Hakan Demir  183  82.4    Erkek
    3   Fehmi Uzun  175  92.0    Erkek
    4    Esra Elli  169  71.0    Kadın

    Burada loc indekslemesinde yine etiketler kullanılmıştır. Ancak etiketler zaten default durumda birer sayı belirtmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    iloc indekslemesinde her zaman etiketler değil indeks numaaları kullanılmak zorundadır. İndeksleme biçimi loc indekslemesi gibidir. 
    iloc indekslemesinin loc indeskelemesinden farkı indeks olarak etiketlerin değil sayıların kullanılmasıdır. Örneğin:

    >>> df = pd.DataFrame({
    ...     'Adı Soyadı': ['Ali Serçe', 'Ayşe Er', 'Hakan Demir', 'Fehmi Uzun', 'Esra Elli'],
    ...     'Boy': [175, 167, 183, 175, 169],
    ...     'Kilo': [74.5, 62.4, 82.4, 92, 71],
    ...     'Cinsiyet': ['Erkek', 'Kadın', 'Erkek', 'Erkek', 'Kadın']
    ...     }, index=['a', 'b', 'c', 'd', 'e'])
    
    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın

    >>> df.iloc[2]
    Adı Soyadı    Hakan Demir
    Boy                   183
    Kilo                 82.4
    Cinsiyet            Erkek

    Burada df.iloc[2] indekslemesinde satırların etiketleri dikkate alınmamaktadır. Bu indeksleme ile 2 numaralı satır elde 
    edilmektedir. Örneğin:

    >>> df.iloc[[1, 3, 2]]
        Adı Soyadı  Boy  Kilo Cinsiyet
    b      Ayşe Er  167  62.4    Kadın
    d   Fehmi Uzun  175  92.0    Erkek
    c  Hakan Demir  183  82.4    Erkek
    
    Burada 1, 3 ve 2 numaralı satırlar elde edilmiştir. 

    iloc indekslemesinde sütun için yine isimler değil numaralar kullanılmak zorundadır. Örneğin:

    >>> df.iloc[[1, 3], [2, 3]]
    Kilo Cinsiyet
    b  62.4    Kadın
    d  92.0    Erkek
            
    iloc indesklemesinde de yine dilimleme yapılabilmektedir. Ancak dilimlerdeki başlangıç ve bitim indeks numaralarından oluşmak 
    zorundadır. Ancak bitim indeksleri dilimlemeye dahil değildir. Örneğin:

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın

    >>> df.iloc[2:4, 1:3]
    Boy  Kilo
    c  183  82.4
    d  175  92.0

    Burada tıpkı Python'da olduğu artık bitim indeksinin dilimlemeye dahil edilmediğine dikkat ediniz. Örneğin:

    >>> df.iloc[:, 2:4]
    Kilo Cinsiyet
    a  74.5    Erkek
    b  62.4    Kadın
    c  82.4    Erkek
    d  92.0    Erkek
    e  71.0    Kadın

    Burada tüm satırların 2înci ve 3'üncü indeksli sütunları elde edilmiştir. 

    iloc indekslemesinde negatif indekslemenin de kullanılabildiğine dikkat ediniz. Örneğin:

    >>> df
        Adı Soyadı  Boy  Kilo Cinsiyet
    a    Ali Serçe  175  74.5    Erkek
    b      Ayşe Er  167  62.4    Kadın
    c  Hakan Demir  183  82.4    Erkek
    d   Fehmi Uzun  175  92.0    Erkek
    e    Esra Elli  169  71.0    Kadın

    >>> df.iloc[-1]
    Adı Soyadı    Esra Elli
    Boy                 169
    Kilo               71.0
    Cinsiyet          Kadın
    Name: e, dtype: object
    
    >>> df.iloc[:-2, 2:4]
    Kilo Cinsiyet
    a  74.5    Erkek
    b  62.4    Kadın
    c  82.4    Erkek

    iloc indeskelemesinde de step miktarı da belirtilebilir. Örneğin:

    >>> df.iloc[1:5:2, :]
    Adı Soyadı  Boy  Kilo Cinsiyet
    b     Ayşe Er  167  62.4    Kadın
    d  Fehmi Uzun  175  92.0    Erkek

    iloc indekslemesinde de bool indeksleme yapılabilmektedir. Örneğin:

    >>> a = np.arange(25).reshape(5, 5)
    >>> df = pd.DataFrame(a, columns=list('ABCDE'), index=list('xyzkn'))
    >>> df
        A   B   C   D   E
    x   0   1   2   3   4
    y   5   6   7   8   9
    z  10  11  12  13  14
    k  15  16  17  18  19
    n  20  21  22  23  24
    >>> k = df.iloc[[False, True, True, False, True]]
    >>> k
        A   B   C   D   E
    y   5   6   7   8   9
    z  10  11  12  13  14
    n  20  21  22  23  24
    
    Bool indekslemede loc ile iloc arasında küçk bir fark vardır. Biz iloc ile bool indekslemede Series nesnelerini kullanamayız ancak 
    loc indekslemesinde kullanabiliriz. Bu özelliği Series nesnelerinde de aynı biçimde olduğunu anımsayınız. Ancak bool türden bir
    Series nesnesi loc indeklemesinde kullanılacaksa Series nesnesinin satır indeksleriyle DataFrame nesnesinin satır indeksleri 
    aynı olmalıdır. Örneğin:

    >>> a = np.arange(25).reshape(5, 5)
    >>> df = pd.DataFrame(a, columns=list('ABCDE'), index=list('xyzkn'))
    >>> df
        A   B   C   D   E
    x   0   1   2   3   4
    y   5   6   7   8   9
    z  10  11  12  13  14
    k  15  16  17  18  19
    n  20  21  22  23  24
    >>> s = pd.Series([False, True, True, False, True])
    >>> s
    0    False
    1     True
    2     True
    3    False
    4     True
    dtype: bool
    >>> df.loc[s, :]

    Bu indeksleme exception'a yol açacaktır. Ancak örneğin:

    >>> s = df['C'] % 2 == 0
    >>> s
    x     True
    y    False
    z     True
    k    False
    n     True
    Name: C, dtype: bool
    >>> df.loc[s, :]
        A   B   C   D   E
    x   0   1   2   3   4
    z  10  11  12  13  14
    n  20  21  22  23  24

    Burada artık elde edilen Series nesnesinin indeksleriyle DataFrame nesnesinin indeksleri aynıdır. 
#------------------------------------------------------------------------------------------------------------------------------------
  
#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame nesnesi dolaşılabilir bir nesnedir. DataFrame nesnesi dolaşıldığında sütun isimleri (sütunların kendisi değil) elde 
    edilmektedir. Örneğin:

    df = pd.DataFrame({
        'Adı Soyadı': ['Ali Serçe', 'Ayşe Er', 'Hakan Demir', 'Fehmi Uzun', 'Esra Elli'],
        'Boy': [175, 167, 183, 175, 169],
        'Kilo': [74.5, 62.4, 82.4, 92, 71],
        'Cinsiyet': ['Erkek', 'Kadın', 'Erkek', 'Erkek', 'Kadın']
        }, index=['a', 'b', 'c', 'd', 'e'])

    for col in df:
        print(col)

    DataFrame nesnesinin belli bir sütunu doğrudan indeksleme ile dolaşılırsa o sütunun elemanları elde edilir. Zaten bu biçimdeki 
    doğrudan indekslemeden Series nesnesinin elde edildiğini biliyorsunuz. 

    for val in df['Kilo']:
        print(val)

    Doğrudan indesklemede tek bir sütunun belirtidiği durumda elde edilen nesnenin Series nesnesi olduğuna dikkat ediniz. Yani 
    biz burada aslında Series nesnesini dolaşmaktayız.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame nesnesinin satır satır dolaşılmasına sıkça gereksinim duyulmaktadır. Bunu yapmanın birkaç yolu olabilir. Örneğin dolaşımı
    iloc indekslemesi ile aşağıdaki gibi yapabiliriz:

    df = pd.DataFrame({
        'Adı Soyadı': ['Ali Serçe', 'Ayşe Er', 'Hakan Demir', 'Fehmi Uzun', 'Esra Elli'],
        'Boy': [175, 167, 183, 175, 169],
        'Kilo': [74.5, 62.4, 82.4, 92, 71],
        'Cinsiyet': ['Erkek', 'Kadın', 'Erkek', 'Erkek', 'Kadın']
        }, index=['a', 'b', 'c', 'd', 'e'])

    for i in range(len(df)):
        row = df.iloc[i]
        print(row)

    Burada satır numarası ile döngü içerisinde satırları Series nesneleri olarak elde ettik.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında bir DataFrame nesneleri genellikle elle oluşturulmamaktadır. Bir dosyadan hareketle oluşturulmaktadır. Daha önceden de 
    belirttiğimiz gibi CSV dosyaları veri biliminde en fazla kullanılan dosya formatıdır. Pandas'ta read_csv fonksiyonu ile CSV 
    dosyaları bir DataFrame nesnesi biçiminde okunabilmektedir. read_csv fonksiyonu NumPy'ın loadtxt fonksiyonuna göre oldukça 
    yeteneklidir. Fonksiyon pek çok CSV diyaleğini otomatik anlayabilmektedir. read_csv fonksiyonu CSV dosyasındaki başlık kısmını 
    DataFrame nesnesindeki sütun isimleri haline getirmektedir. Fonksiyon otomatik olarak sütunların türlerini CSV dosyasının içeriğinden 
    hreketle belirleyebilmektedir. 

    read_csv fonksiyonun çok fazla sayıda parametresi vardır. Ancak bu parametrelerin dosyanın yol ifadesi dışındaki parametreleri 
    default değerlerle geçilebilir. Çoğu kez programcının yalnızca CSV dosyasının yol ifadesini vermesi yeterli olmaktadır. 
    Fonksiyonun parametik yapısı şöyledir:

    pandas.read_csv(filepath_or_buffer, *, sep=<no_default>, delimiter=None, header='infer', names=<no_default>, 
            index_col=None, usecols=None, dtype=None, engine=None, converters=None, true_values=None, false_values=None, 
            skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, 
            na_filter=True, verbose=<no_default>, skip_blank_lines=True, parse_dates=None, infer_datetime_format=<no_default>, 
            keep_date_col=<no_default>, date_parser=<no_default>, date_format=None, dayfirst=False, cache_dates=True, 
            iterator=False, chunksize=None, compression='infer', thousands=None, decimal='.', lineterminator=None, 
            quotechar='"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, encoding_errors='strict', 
            dialect=None, on_bad_lines='error', delim_whitespace=<no_default>, low_memory=True, memory_map=False, 
            float_precision=None, storage_options=None, dtype_backend=<no_default>)

    Örneğin:

    df = pd.read_csv('data.csv')
    
#------------------------------------------------------------------------------------------------------------------------------------
   
import pandas as pd

df = pd.read_csv('covid-19.csv')

print(df.columns)
print(df.dtypes)

#------------------------------------------------------------------------------------------------------------------------------------
    read_csv fonksiyonun usecols parametresi yine loadtxt fonksiyonunda olduğu gibi okunacak sütunların numaralarını ya da isimlerini 
    bir liste olarak bizden alır. 
#------------------------------------------------------------------------------------------------------------------------------------
import pandas as pd

df = pd.read_csv('covid-19.csv', usecols=[1, 2, 3])
print(df)

df = pd.read_csv('covid-19.csv', usecols=['Confirmed', 'Deaths', 'Recovered'])
print(df)

#------------------------------------------------------------------------------------------------------------------------------------    
    read_csv fonksiyonu tırnakları da sütun ayıracı olarak akıllı bir biçimde anlayabilmektedir. Örneğin aşağıdaki gibi bir 
    "student.csv" isminde bir dosya olsun:

    "Adı, Soyadı", No,Doğum Yeri
    "Ali, Serçe",123,Tarsus
    "Kaan, Aslan",345,Eskişehir
    "Necati, Ergin",764,Giresun
    "Hasan, Kılışçaslan",523,Van
    "Barış, Gök",692,Çorum
    "Gürbüz, Aslan",823,Eskişehir

    Bu dosyada iki tırnak içerisindeki virgüllerin dikkate alınmamasını, iki tırnaklı sütunların tek bir sütun olarak ele alınmasını 
    istemiş olalım. Fonksiyon default durumda bunu akıllı biçimde yapabilmektedir.  Ancak tırnaklama konusunda bazı ayrıntıları 
    belirleyebilmek için "quoting" isimli parametreden de faydalanılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd

df = pd.read_csv('student.csv')
print(df)

#------------------------------------------------------------------------------------------------------------------------------------
                                        51. Ders 20/09/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Dataframe nesnesi istenirse DataFrame sınıfının to_csv metodu ile CSV dosyası olarak da save edilebilir. Yani bu fonksiyon 
    işlevsel olarak read_csv fonksiyonun tersini yapmaktadır. metot default durumda DataFrame'deki satır etiketlerini de dosyaya 
    yazmaktadır. Eğer bu istenmiyorsa index parametresi False olarak geçilmelidir. 
------------------------------------------------------------------------------------------------------------------------------
   
import pandas as pd

df = pd.read_csv('student.csv')

print(df)
print(df.dtypes)

df.to_csv('x.csv', index=False)

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında DataFrame sınıfının to_csv metodunun dışında başka to_xxx metotları da vardır. Örneğin to_dict isimli metot DataFrame 
    nesbesinden Python sözlüğü oluşturmaktadır:

    import pandas as pd

    df = pd.DataFrame({
        'Adı Soyadı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'],
        'No': [32, 167, 35, 87, 46],
        'Cinsiyet': ['Erkek', 'Erkek', 'Erkek', 'Kadın', 'Kadın']
        })

    print(df)

    d = df.to_dict()
    print(d)
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame sınıfının to_sql isimli metodu bizde sırasıyla bir tablo ismi ve bir bağlantı nesnesi alır. DataFrame içerisindeki 
    bilgileri ilgili tabloya yazar. Tablo varsa default durumda metot exception oluşturmaktadır. Ancak metodun if_exists parametresi 
    "replace" ya da "append" de girilebilmektedir. Böylece biz tek hamlede br CSV dosyasını SQL tablosu haline yazabilmeketyiz. 
    Örneğin:

    df = pd.read_csv('student.csv')

    conn = None
    try:
        conn = sqlite3.connect('student.sqlite')
        df.to_sql('Person', conn)
    except sqlite3.Error as e:
        print(e)
    finally:
        if conn:
            conn.close()                 
    conn.close()      

    Burada "student.csv" isimli CSV dosyası önce DataFrame olarak okunmuş sonra tek hamlede DataFrame sınıfının to_sql metodu ile 
    SQLite3 VTYS tablosu biçiminde save edilmiştir. Tabii siz farklı bağlanı nesnelerini vererek istediğiniz VTYS için bu işlemi 
    yapabilirsiniz.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame sınıfının to_json metodu DataFrame içeriğini bir JSON dosyası biçiminde oluşturmaktadır. Örneğin:
    
    df.to_json('student_json')

    DataFrame sınıfının to_excel metodu DataFrame nesnesinden Excel dosyası oluşturmaktadır. Örneğin:

    df.to_excel('student.xlsx')

    Sınıfın to_numpy metodu ise DataFrame nesnesinden NumPy dizisi oluşturmaktadır. Ancak sütunlar farklı türlerdense to_numpy metodu 
    ile oluşturulan DataFrame nesnesinin dtype türü "object" olur. Örneğin:

    df = pd.DataFrame({
        'Adı Soyadı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'],
        'No': [32, 167, 35, 87, 46],
        'Cinsiyet': ['Erkek', 'Erkek', 'Erkek', 'Kadın', 'Kadın']
        })

    a = df.to_numpy()
    print(a, a.dtype)

    Aslında to_numpy metodunda dtype türü belirtilebilmektedir. Ancak sütunlar bu dtype türü ile ifade edilemezse exception oluşacaktır.

    DataFrame sınıfının to_xmkl metodu da DataFRame nesnesinden XML dosyası oluşturmaktadır. XML konusu kursumuzda ayrı bir başlık 
    altında ele alınacaktır. Örneğin:

    df.to_xml('student.xml')

    Burada dikkat edilmesi gereken bir nokta DataFrame nesnesindeki sütun isimlerinin XML'deki tag isimleri haline getirilmesidir. 
    Dolayısıyla örneğin sütun isimlerin boşluklar olursa bundan geçerli bir XML oluşturulamayacaktır. 

    DataFrame sınıfının to_html metodu da benzerdir. DafaFrame nesnesini HTML tablosu haline getirmektedir. Örneğin:

    df.to_html('student.html')

    Ancak metot bir geçerli bir HTML dosyası oluşturmamakta yalnızca bir HTML dosyasına iliştirilebilecek bir tablo oluşturmaktadır. 

    DataFrame sınıının to_string metodu DataFrame nesnesini bir yazı haline getirmektedir. Metot bu yazıyı geri dönüş değeri olarak 
    vermektedir. Örneğin:

    s = df.to_string()

    print(s)

    DataFrame sınıfının diğer to_xxx metotlarını dokmanlardan inceleyebilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
   DataFrame nesneleri üzerinde de Series nesneleri üzerinde yapılan işlemlerin benzerleri yapılabilmektedir. Tabii DataFrame üzerinde 
   işlem yaparken işlemden tüm sütunlar etkilenmektedir. Buradaki metotların bazılarının yine global fonksiyon karşılıkları da vardır. 
   Bu metotlar ve fonksiyonlar axis parametresi alabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------02d

#------------------------------------------------------------------------------------------------------------------------------------
   Örneğin Series sınıfın mean metodu ya da mean fonksiyonu bir Series nesnesindeki değerlerin ortalamasını bize verir. Ancak DataFrame 
   sınıfının mean metodu ya da global mean fonksiyonu axis temelinde bize satır ya da sütun ortalamalarını vermektedir. Tabii bu 
   tür metotlar ve foksiyonlar DataFrame nesnesinin tüm sütunları üzerinde etkili olduğu için sütunların türlerinin ilgili işlemlere 
   uygun olması gerekir. Örneğin biz kişilerin ad ve soyaflarının bulunduğu sütunun ortalamasını alamayız. Bu metot ve fonksiyonlarda 
   eksen belirtilmezse default olarak axis=0 alınmaktadır. Yani sutunsal işlemler yapılmaktadır. Örneğin:

   df = pd.DataFrame({
        'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
        'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
        'Boy': [172, 156, 182, 153, 171]
        })
        

    means = df[['Kilo', 'Boy']].mean()
    stds = df[['Kilo', 'Boy']].std()

    print(means)    
    print('-' * 20)
    print(stds)

    Burada DataFrame nesnesindeki "Adı" sütunu sayısal bilgi içermemektedir. Bu nedenle biz de yalnızca "Kilo" ve "Boy" sütunlarından
    yeni bir DataFrame nesnesi oluşturarak o sütunların ortalamasını ve standart sapmasını elde ettik.
#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd

df = pd.DataFrame({
    'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
    'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
    'Boy': [172, 156, 182, 153, 171]
    })
    
means = df[['Kilo', 'Boy']].mean()
stds = df[['Kilo', 'Boy']].std()

print(means)    
print('-' * 20)
print(stds)

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame sınıfının yine Series sınıfında olduğu gibi min gibi, max, gibi, sum gibi metotları vardır. Bunlar da axis temelinde 
    işlem yapabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd

df = pd.DataFrame({
    'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
    'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
    'Boy': [172, 156, 182, 153, 171]
    })
    
mins = df[['Kilo', 'Boy']].min()
maxs = df[['Kilo', 'Boy']].max()

print(mins)    
print('-' * 20)
print(maxs)

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame nesnesine doğrudan indeksleme yoluyla atama yapılırsa bu işlem "sütun eklemek" anlamına gelir. Örneğin:

    df = pd.DataFrame({
        'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
        'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
        'Boy': [172, 156, 182, 153, 171]
        })

    Burada DataFrame nesnesinde kişilerin boy ve kiloları vardır. Biz de bu iki bilgiden hareketle kişilerin "vücut kitle endeksini 
    (body mass index)" elde edip bunu bir sütun olarak eklemek isteyelim. Bunu basit bir biçimde şöyle yapabiliriz:

    df['VKE'] = df['Kilo'] / (df['Boy']  / 100) ** 2

    Burada VKE isminde yeni bir sütun oluşturulacaktır. Veri biliminde olan bilgilerden yukarıdaki gibi olmayan sütunların oluşturulması 
    sürecine "özellik mühendisliği (feature engineering)" denilmektedir. Bu yöntemle sütun eklediğimizde her zaman ekleme sona yapılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    İstatistikte veri kümesindeki sayısal değil sınıf belirten yazısal sütunlara "kategorik sütunlar" ya da "nominal sütunlar" denilmektedir. 
    Pek çok veri bilimi ve makine öğrenmesi algoritması yalnızca yalnızca sayısal veriler üzerinde uygulanmaktadır. Bu nedenle uygulamacı
    tarafından kategorik sütunlar önce sayısal biçime dönüştürülmektedir. Eğer sütunda yalnızca iki kategori varsa bunlardan biri 0 
    ile diğeri 1 ile temsil edilebilir. Ancak sütunda ikiden fazla kategori varsa bunlara birer sayı karşı düşürmek çoğu kez iyi 
    bir yöntem değildir. Çünkü sayılar algoritmalar tarafından "büyük", "küçük" ilişkisiyle değerlendirilme eğilimindedir. Bu nedenle
    "büyük" "küçük" ilişkisini kırmak için iki kategoriden daha fazla kategoriye sahip olan sütunlar üzerinde ismine "one-hot-encoder"
    denilen teknik kullanılmaktadır. Bu teknikte veri kümesine kategori sayısı kadar sütun eklenir. Her bir değer yalnızca bir sütunu 
    1 olan diğer sütunları 0 olan sayılar haline getirilir. Örneğin kişilere üç renk arasında renk tercihi sorulmuş olsun. Renkler 
    Kırmızı, Yeşil ve Mavi olsun. Kişilerin verdiği yanıtların şunlar olduğunu düşünelim:

    Kırmızı
    Mavi
    Kırmızı
    Yeşil
    Mavi
    Kırmızı
    Yeşil

    Bu renk tercihleri one-hot-encoding biçiminde aşağıdaki sayısallaştırılır:

    Renk_Kırmızı       Renk_Yeşil       Renk_Mavi
    1                   0               0
    O                   0               1
    1                   0               0
    0                   1               0
    0                   0               1
    1                   0               0
    0                   1               0

    Bu otomatik olarak yapan Pandas kodu şöyle olabilir:

    df = pd.DataFrame({
        'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
        'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
        'Boy': [172, 156, 182, 153, 171],
        'Renk': ['Kırmızı', 'Yeşil', 'Mavi', 'Yeşil', 'Kırmızı']
        })
       

    for color in df['Renk'].unique():
        df['Renk_' + color] = (df['Renk'] == color).astype('int32')
    df.drop(['Renk'], axis=1)
#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd

df = pd.DataFrame({
    'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
    'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
    'Boy': [172, 156, 182, 153, 171],
    'Renk': ['Kırmızı', 'Yeşil', 'Mavi', 'Yeşil', 'Kırmızı']
    })
    

for color in df['Renk'].unique():
    df['Renk_' + color] = (df['Renk'] == color).astype('int32')
df.drop(['Renk'], axis=1)
    
print(df)

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame üzerinde bir sütun insert etmek için DataFrame sınıfının insert metodu metodu kullanılabilmektedir. insert metodunun 
    birinci parametresi her zaman insert edilecek sütunun indeks numarasını alır. İkinci parametre insert edilecek sütunun ismini 
    (yani etiketini), üçüncü parametre ise sütun bilgilerini almaktadır. insert metodu "in-place" insert işlemi yapmaktadır. Yani 
    DataFrame nesnesinin kendi üzerinde ekleme yapılmaktadır. Örneğin:

    import pandas as pd

    df = pd.DataFrame({
        'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
        'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
        'Boy': [172, 156, 182, 153, 171],
        'Renk': ['Kırmızı', 'Yeşil', 'Mavi', 'Yeşil', 'Kırmızı']
        })
        
    vke = df['Kilo'] / (df['Boy'] / 100) ** 2
    df.insert(3, 'VKE', vke)

    print(df)

    Buradan şöyle bir çıktı elde edilmiştir:

          Adı  Kilo  Boy        VKE     Renk
    0     Ali  48.3  172  16.326393  Kırmızı
    1    Veli  56.7  156  23.298817    Yeşil
    2  Selami  92.3  182  27.864992     Mavi
    3    Ayşe  65.3  153  27.895254    Yeşil
    4   Fatma  72.3  171  24.725557  Kırmızı

    Insert işleminin şöyle yapıldığına dikkat ediniz:

    df.insert(3, 'VKE', vke)

    Burada yeni eklenecek sütun üçüncü indeksli sütun olacaktır. Eklemecek sütunun ismi 'VKE' biçimindedir. 

    Biz bu insert metoduyla bir Python listesi ya da demetini ya da NumPy nesnesini de kullanabiliriz. Yani metodun üçüncü parametresinin 
    Series belirtmesi zorunlu değildir. Ancak eğer insert edilecek bilgi bir Series nesnesi ise bu durumda Series nesnesinin elemanlarının 
    indeksleri ile DataFrame satırlarının indekslerinin aynı olması gerekmektedir. 

    Biz insert metodu ile bir DataFrame nesnesine başka bir DataFrame nesnesini insert edemeyiz. insert metodu tek bir sütunu insert 
    etmek için kullanılmaktadır. Global bir insert fonksiyonu da bulunmamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd

df = pd.DataFrame({
    'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
    'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
    'Boy': [172, 156, 182, 153, 171],
    'Renk': ['Kırmızı', 'Yeşil', 'Mavi', 'Yeşil', 'Kırmızı']
    })
    
vke = df['Kilo'] / (df['Boy'] / 100) ** 2
df.insert(3, 'VKE', vke)

print(df)

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame nesnesine satır eklemenin birkaç yolu vardır. Örneğin loc indekslemesiyle olmayan bir indekse satır bilgisi atanırsa
    bu ekleme anlamına gelmektedir:

   import pandas as pd

    df = pd.DataFrame({
        'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
        'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
        'Boy': [172, 156, 182, 153, 171],
        'Renk': ['Kırmızı', 'Yeşil', 'Mavi', 'Yeşil', 'Kırmızı']
        })
        
    df.loc[5] = ['Kazım', 83, 182, 'Yeşil']
    print(df)

    Burada satır indeksleri zaten sayısaldır. Dolayısıyla biz de nesnenin sonuna bir satır eklemiş olduk. Ekrana şunlar basılacaktır:

          Adı  Kilo  Boy     Renk
    0     Ali  48.3  172  Kırmızı
    1    Veli  56.7  156    Yeşil
    2  Selami  92.3  182     Mavi
    3    Ayşe  65.3  153    Yeşil
    4   Fatma  72.3  171  Kırmızı
    5   Kazım  83.0  182    Yeşil

    Bu biçimde satır ekleme yalnızca loc indekslemesi ile yapılmaktadır. iloc indekslemesi ile satır eklenememektedir. DataFrame 
    nesnesinde iki satırın arasına yeni bir satır insert etmek için pratik bir metot bulunmamaktadır. Bu işlemler concat fonksiyonuyla 
    yapılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                            52. Ders 21/09/2025 – Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame ve Series nesneleri concat isimli fonksiyonla birleştirilip yeni bir DataFrame nesnesi elde edilebilmektedir. concat 
    fonksiyonun birinci parametresine biz DataFrame ya da Series nesnelerinden oluşan bir liste ya da demet girebiliriz. Fonksiyon 
    bunları bizim belirttiğimiz sırada uç uca ekleyip yeni bir DataFrame nesnesi oluşturmaktadır. concat fonksiyonu sütun birleştirmesi 
    ya da satır birleştirmesi için kullanılabilir. Fonksiyonun axis parametresi vardır. Eğer axis=0 ise satırsal birleştirme, axis=1 
    ise sütunsal birleştirme yapılmaktadır. concat fonksiyonu ile sütunsal birleştirme yapılırken DataFrame ya da Series nesnelerinin 
    satır indekslerinin (yani etiketlerinin) aynı olması gerekir. Eğer satır indeksleri aynı olmazsa bu durumda her uyuşmayan indeks 
    için ayrı ekleme yapılır. Ancak uyuşmayan elemanlar NaN ile doldurulur. Örneğin:

    df = pd.DataFrame({
        'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
        'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
        'Boy': [172, 156, 182, 153, 171],
        'Renk': ['Kırmızı', 'Yeşil', 'Mavi', 'Yeşil', 'Kırmızı']
        })
        
    vke = df['Kilo'] / (df['Boy'] / 100) ** 2
    vke.name = 'VKE'

    df = pd.concat([df['Adı'], vke, df['Renk']], axis=1)
    print(df)

    Bu örnekte biz DataFrame içersindeki "Kilo" ve "Boy" sütunları yerine "VKE (Vücut Kitle Endeksi)" sütununu yerleştirmek isteyelim. concat işleminin nasıl yapıldığına dikkat ediniz:

    df = pd.concat([df['Adı'], vke, df['Renk']], axis=1)

    Burada df['Adı'], vke ve df['Renk'] birer Series nesnesidir. Bu üç Series nesnesi birleştirilerek br DataFrame oluşturulmuştur. 
    Oluşturulan DataFrame nesnesi şöyledir:

          Adı        VKE     Renk
    0     Ali  16.326393  Kırmızı
    1    Veli  23.298817    Yeşil
    2  Selami  27.864992     Mavi
    3    Ayşe  27.895254    Yeşil
    4   Fatma  24.725557  Kırmızı

    Burada concat fonksiyonun inplace işlem yapmadığına dikkat ediniz. inplace işlemler genel olarak fonksiyonlar yoluyla değil metotlar 
    yoluyla  yapılmaktadır. inplace işlem yapan bir concat metodu yoktur. concat her zaman bize yeni bir DataFrame nesnesi vermektedir. 
    Örneğin:

    s1 = pd.Series([10, 20, 30, 40, 50], name='A')
    df1 = pd.DataFrame({'B': [4, 7, 2, 1, 8], 'C': [52, 12, 54, 23, 32]})
    s2 = pd.Series([10, 20, 30, 40, 50], name='D')

    df_result = pd.concat([s1, df1, s2], axis=1)
    print(df_result)

    Buradan şöyle DataFrame nesnesi elde edilmektedir:

        A  B   C   D
    0  10  4  52  10
    1  20  7  12  20
    2  30  2  54  30
    3  40  1  23  40
    4  50  8  32  50

    Sütunsal ekleme yapılırken eklenecek Series ya da DataFrame nesnelerinin satır indeksleri (yani etiketleri) aynı olmalıdır. Eğer 
    etiketler farklı olursa farklı etiketler de sütun haline getirilir ancak uyuşmayan etiketler NaN olur. Örneğin:

    s = pd.Series([10, 20, 30, 40, 50], index=['a', 'b', 'c', 'd', 'e'], name='A')
    df = pd.DataFrame({'B': [4, 7, 2, 1, 8], 'C': [52, 12, 54, 23, 32]})

    df_result = pd.concat([s, df], axis=1)
    print(df_result)

    Burada s nesnesi ile df nesnesinin satır etiketleri aynı değildir. Elde edilen df_result isimli DataFrame şöyle olacaktır:

          A    B     C
    a  10.0  NaN   NaN
    b  20.0  NaN   NaN
    c  30.0  NaN   NaN
    d  40.0  NaN   NaN
    e  50.0  NaN   NaN
    0   NaN  4.0  52.0
    1   NaN  7.0  12.0
    2   NaN  2.0  54.0
    3   NaN  1.0  23.0
    4   NaN  8.0  32.0

    Görüldüğü gibi birleştirme yine yapılmıştır. Ancak her satır satır etiketi oluşturulan DataFrame nesnesine yerleştirilmiştir. 
    Eğer etiketin diğer birleştirilen nesnelerde karşılığı yoksa ilgili hücrelerde NaN değeri bulunmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    concat ile biz bir DataFrame'e bir satır da ekleyebiliriz. Bu durumda eklemeyi axis=0 (default durum) parametresi ile yapmamız 
    gerekir. Örneğin:
    
    df1 = pd.DataFrame({
        'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
        'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
        'Boy': [172, 156, 182, 153, 171],
        'Renk': ['Kırmızı', 'Yeşil', 'Mavi', 'Yeşil', 'Kırmızı']
        })
    print(df1)  

    df2 = pd.DataFrame({
        'Adı': ['Hüseyin', 'Can'], 
        'Kilo': [82, 75], 
        'Boy': [183, 176], 
        'Renk': ['Kırmızı', 'Yeşil']
        })
    print(df2)

    df_result = pd.concat([df1, df2], axis=0)
    print(df_result)

    Burada df1 ile df2 satırsal biçimde concat işlemine sokulmuştur. Elde edilen DataFrame nesnesine dikkat ediniz:

           Adı  Kilo  Boy     Renk
    0      Ali  48.3  172  Kırmızı
    1     Veli  56.7  156    Yeşil
    2   Selami  92.3  182     Mavi
    3     Ayşe  65.3  153    Yeşil
    4    Fatma  72.3  171  Kırmızı
    0  Hüseyin  82.0  183  Kırmızı
    1      Can  75.0  176    Yeşil

    Burada eklenen satırın indekslerinin yine 0  ve 1 olduğunu görüyorsunuz. Bu durum bazı işlemlerde sorunlara yol açabilmektedir. 
    Bu durumda birleştirmeden sonra concat fonksiyonun satırlara yeniden indeks vermesi için ignore_index parametresi True 
    geçilmelidir. Örneğin:

    df_result = pd.concat([df1, df2], axis=0, ignore_index=True)

    Elde edilen DataFrame nesnesisinin satırları artık sıfırdan numaralandırılacaktır:

            Adı  Kilo  Boy     Renk
    0      Ali  48.3  172  Kırmızı
    1     Veli  56.7  156    Yeşil
    2   Selami  92.3  182     Mavi
    3     Ayşe  65.3  153    Yeşil
    4    Fatma  72.3  171  Kırmızı
    5  Hüseyin  82.0  183  Kırmızı
    6      Can  75.0  176    Yeşil

    DataFrame nesnesine satırsal olarak bir Series nesnesi ekleyebilir miyiz? İşte durum biraz sorunludur. axis=0 yapılsa ve Series 
    nesnesinin index'leri DataFrame sütunlarıyla aynı olsa bile satırsal concat işlemi istenildiği gibi yapılamamaktadır. Elimizde
    bir Series nesnesi varsa onu DataFrame haline dönüştürüp satırsal ekleme yapmak gerekir. Bir Series nesnesi Series sınıfının 
    to_frame metodu ile DataFrame nesnesi haline getirilebilmektedir. Örneğin:

    >>> s = pd.Series(['Hüseyin', 67.5, 165, 'Yeşil'], index=['Adı', 'Kilo', 'Boy', 'Renk'])
    >>> s
    Adı     Hüseyin
    Kilo       67.5
    Boy         165
    Renk      Yeşil
    dtype: object
    >>> df = s.to_frame()
    >>> df
                0
    Adı   Hüseyin
    Kilo     67.5
    Boy       165
    Renk    Yeşil

    Burada Series nesnesi to_frame metodu ile tek sütundan oluşan DataFrame nesnesi haline getirilmiştir. Ancak yine bu bir satır 
    formunda olmadığı için axis=0 yapılsa bile Series nesnesi düzgün bir biçimde satırsal olarak eklenemeyecektir. Bu DataFrame 
    nesnesini transpoze etmek gerekir. Örneğin:

    >>> df = s.to_frame().T
    >>> df
        Adı  Kilo  Boy   Renk
    0  Hüseyin  67.5  165  Yeşil

    Şimdi artık concat işlemi yapılabilir. Örneğin:

    df_result = pd.concat([df, s.to_frame().T], axis=0, ignore_index=True)


#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd

df = pd.DataFrame({
    'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
    'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
    'Boy': [172, 156, 182, 153, 171],
    'Renk': ['Kırmızı', 'Yeşil', 'Mavi', 'Yeşil', 'Kırmızı']
    })
print(df)  

s = pd.Series(['Hüseyin', 67.5, 165, 'Yeşil'], index=['Adı', 'Kilo', 'Boy', 'Renk'])

df_result = pd.concat([df, s.to_frame().T], axis=0, ignore_index=True)
print(df_result)

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame nesnesinden sütun ya da satır silmek için Series sınıfında olduğu gibi drop metodu kullanılmaktadır. Bu metot bir ya da 
    birden fazla sütun ya da satır silebilmektedir. Silinecek sütun ya da satırın indeksleri (yani etiketleri) metodun ilk parametresinde 
    bir liste biçiminde belirtilir. Yani sütunsal silme yapılacaksa birinci parametre silinecek sütunların isimlerini satırsal silme 
    yapılacaksa birinci parametres silinecek satırların indekslerini belirtmelidir. Bu metot her zaman sütun isimleri ya da satır 
    indeksleri ile çalışmaktadır. Yani bu metoda sütun ya da satırların sıra numaraları verilmemektedir. Sütunsal silmelerde axis=1, 
    satırsal silmelerde axis=0 parametresi girilmelidir. Örneğin:

    df = pd.DataFrame({
        'Adı': ['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma'], 
        'Kilo': [48.3, 56.7, 92.3, 65.3, 72.3], 
        'Boy': [172, 156, 182, 153, 171],
        'Renk': ['Kırmızı', 'Yeşil', 'Mavi', 'Yeşil', 'Kırmızı']
        })
    print(df)  
    
    Buradaki DataFrame nesnesi şöyledir:

          Adı  Kilo  Boy     Renk
    0     Ali  48.3  172  Kırmızı
    1    Veli  56.7  156    Yeşil
    2  Selami  92.3  182     Mavi
    3    Ayşe  65.3  153    Yeşil
    4   Fatma  72.3  171  Kırmızı    
    
    Biz bu DataFrame nesnesinden "Adı" ve "Renk" sütunlarını atmak isteyelim. Bu işlemi şöyle yapabiliriz:

    df_result = df.drop(['Adı', 'Renk'], axis=1)

    Elde edilen df_result nesnesi şöyle olacaktır:

       Kilo  Boy
    0  48.3  172
    1  56.7  156
    2  92.3  182
    3  65.3  153
    4  72.3  171

    drop metodu default durumda in-place işlem yapmamaktadır. Yani silmeyi nesnenin üzerinde yapmamakta bize silinmiş yeni bir 
    DataFrame nesnesi vermektedir. Eğer in-place işlem yapılmak isteniyorsa inplace parametresine True girilmelidir. Örneğin:

    df.drop(['Adı', 'Renk'], axis=1, inplace=True)

    Tabii bu durumda metot None değeriyle geri dönmektedir. 

    Satırsal silme için axis=0 parametresiyle satır etiketleri verilmelidir. Örneğin:

    df.drop([0, 3], axis=0, inplace=True)

    Burada 0 ile 3 indeksine sahip satırlar silinmektedir. 

    Tabii biz aslında dilimleme yaparak belli elemanları seçerek de yeni bir DataFrame nesnesi oluşturabiliriz. Bu işlem de drop
    işlemine oldukça benzemektedir Örneğin DataFrame nesnemiz aşağıdaki gibi olsun:

          Adı  Kilo  Boy     Renk
    0     Ali  48.3  172  Kırmızı
    1    Veli  56.7  156    Yeşil
    2  Selami  92.3  182     Mavi
    3    Ayşe  65.3  153    Yeşil
    4   Fatma  72.3  171  Kırmızı

    df = df.iloc[:, [1, 2]]

    Biz burada tüm satırları ancak 1 ve 2 numaralı sütunları aldık. Bu bir çeşit silme gibi oldu. Örneğin:

    df = df[df['Boy'] > 170]

    Burada biz boyu 170'ten büyük satırları alarak adeta diğer satırları silmiş olduk. 

    drop metodunda tıpkı Series sınıfında olduğu gibi tek bir sütun ya da satır silinecekse onun bir liste biçiminde belirtilmesine 
    gerek yoktur. Örneğin:
    
    df.drop('Adı', axis=1, inplace=True)

    Burada yalnızca "Adı" sütunu silinmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Veri bilimi ve makine öğrenmesi uygulamalarında kullanılan klasik veri kümelerinden biri de "Titanik" veri kümesidir. Titanik 
    veri kümesinde Titanik yolcularına ilişkin çeşitli bilgiler bulunmaktadır. Bu bilgiler girildiğinde ilgili kişi "Titanik'te olsaydı
    hayatta kalma olasılığı ne olurdu?" sorusuna yanıt aranmaktadır. Titanik veri kümesi CSV dosyası olarak aşağıdaki bağlantıdan 
    indirilebilir:

    https://www.kaggle.com/datasets/yasserh/titanic-dataset

    Ancak "Kaggle" sitesinden veri kümesi indirebilmek için siteye üyelik gerekmektedir.  Veri kümesindeki sütunların anlamları 
    şöyledir:

    PassengerId:    Yolcuya verilen benzersiz kimlik numarası.
    Survived:	    Yolcunun kurtulup kurtulmadığı: 0 = Hayır, 1 = Evet.
    Pclass:	        Yolcu sınıfı (mevkii): 1 = 1. Mevkii, 2 = 2. Mevkii, 3 = 3. Mevkii. Sosyo-ekonomik durumu da yansıtıyor.
    Name:	        Yolcunun tam adı (çoğu zaman unvan da içeriyor: Mr., Mrs., Miss, Master vb.).
    Sex:	        Cinsiyet (male veya female).
    Age:	        Yolcunun yaşı (bazı kayıtlar eksik).
    SibSp:	        Yolcunun Titanic'teki kardeş ya da eşi sayısı. (Sibling/Spouse)
    Parch:	        Yolcunun Titanic'teki ebeveyn ya da çocuk sayısı. (Parent/Children)
    Ticket:	        Yolcunun bilet numarası.
    Fare:	        Ödenen bilet ücreti (Sterlin cinsinden).
    Cabin:	        Yolcunun kamarası (birçok kayıt eksik).
    Embarked:	    Yolcunun bindiği liman. C = Cherbourg (Fransa), Q = Queenstown (şimdiki Cobh, İrlanda), S = Southampton (İngiltere)

    Veri kümesi eksik veriler de barındırmaktadır. Yani bazı kişilerin bazı sütun verileri yoktur. Bu CSV dosyası aşağıdaki gibi 
    Pandas'ın read_csv fonksiyonuyla DataFrame olarak okunabilir:

    >>> df = pd.read_csv('Titanic-Dataset.csv')
    >>> df
        PassengerId  Survived  Pclass  ...     Fare Cabin  Embarked
    0              1         0       3  ...   7.2500   NaN         S
    1              2         1       1  ...  71.2833   C85         C
    2              3         1       3  ...   7.9250   NaN         S
    3              4         1       1  ...  53.1000  C123         S
    4              5         0       3  ...   8.0500   NaN         S
    ..           ...       ...     ...  ...      ...   ...       ...
    886          887         0       2  ...  13.0000   NaN         S
    887          888         1       1  ...  30.0000   B42         S
    888          889         0       3  ...  23.4500   NaN         S
    889          890         1       1  ...  30.0000  C148         C
    890          891         0       3  ...   7.7500   NaN         Q

    Görüldüğü gibi eksik veriler NaN biçiminde gözükmektedir. İzleyen paragraflarda bazı konularda bu veri kümesini kullanacağız.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame sınıfının dropna metodu da çok sık kullanılmaktadır. Daha önceden de belirttiğimiz gibi Pandas'ın read_csv fonksiyonu 
    eksik verileri default durumda NaN biçiminde okumaktadır. İşte biz eksik verilerin bulunduğu satırı ya da sütunu tümden atmak 
    isteyebiliriz. dropna metodunun  axis parametresi de vardır. Bu parametre 0 geçilirse eksik verilen bulunduğu satırlar,  1 geçilirse 
    sütunlar atılır. Metodun inplace parametresi default durumda False biçimdedir. Bu durumda metot eksik verilerin bulunmadığı 
    yeni bir DataFrame nesnesi verir. Bu parametre True geçilirse silme işlemi nesnenin üzerinde yapılmaktadır. Örneğin "Titanic" veri 
    kümesini okumuş olalım:

    >>> df = pd.read_csv('Titanic-Dataset.csv')

    Veri kümesindeki satır sayısını len fonksiyonuyla ya da DataFrame sınıfının shape örnek özniteliği öğrenebiliriz:

    >>> len(df)
    891
    >>> df.shape
    (891, 12)

    Şimdi eksik verilerin bulunduğu satırları atmak isteyelim:

    >>> df_result = df.dropna(axis=0)
    >>> df_result
        PassengerId  Survived  Pclass  ...     Fare        Cabin  Embarked
    1              2         1       1  ...  71.2833          C85         C
    3              4         1       1  ...  53.1000         C123         S
    6              7         0       1  ...  51.8625          E46         S
    10            11         1       3  ...  16.7000           G6         S
    11            12         1       1  ...  26.5500         C103         S
    ..           ...       ...     ...  ...      ...          ...       ...
    871          872         1       1  ...  52.5542          D35         S
    872          873         0       1  ...   5.0000  B51 B53 B55         S
    879          880         1       1  ...  83.1583          C50         C
    887          888         1       1  ...  30.0000          B42         S
    889          890         1       1  ...  30.0000         C148         C

    [183 rows x 12 columns]
    >>> df_result.shape
    (183, 12)

    891 satırlık veri kümesi 183 satıra düştü. O halde bu veri kümesinde çok fazla eksik veri vardır. Daha önceden de belirttiğimiz 
    gibi bu tür durumlarda satırları atmak yerine onlar yerine makul değerler yerleştirmek de (imputation) söz konusu olabilir. 
    Peki eksik verilerin bulunduğu satırları değil de sütunları atsaydık ne olurdu? Deneyelim:

    >>> df_result.shape
    (183, 12)
    >>> df_result = df.dropna(axis=1)
    >>> df_result
        PassengerId  Survived  Pclass  ... Parch            Ticket     Fare
    0              1         0       3  ...     0         A/5 21171   7.2500
    1              2         1       1  ...     0          PC 17599  71.2833
    2              3         1       3  ...     0  STON/O2. 3101282   7.9250
    3              4         1       1  ...     0            113803  53.1000
    4              5         0       3  ...     0            373450   8.0500
    ..           ...       ...     ...  ...   ...               ...      ...
    886          887         0       2  ...     0            211536  13.0000
    887          888         1       1  ...     0            112053  30.0000
    888          889         0       3  ...     2        W./C. 6607  23.4500
    889          890         1       1  ...     0            111369  30.0000
    890          891         0       3  ...     0            370376   7.7500

    [891 rows x 9 columns]
    >>> df_result.shape
    (891, 9)

    Görüldüğü gibi 13 sütunluk veri kümesi 9 sütuna inmiştir. O halde yalnızca 4 sütunda eksik veriler bulunmaktadır. Hangi 
    sütunların atıldığını birkaç biçimde öğrenebiliriz. Series sınıfının difference metodu birinde olan diğerinde olmayan elemanları
    bir Series nesnesi biçiminde vermektedir. Örneğin:

    >>> df.columns.difference(df_result.columns)
    Index(['Age', 'Cabin', 'Embarked'], dtype='object')

    Örneğin biz "Age" sütunundaki eksik verileri Series sınıfının fillna metoduyla ortalama değerle doldurabiliriz:

    >>> df_result = df['Age'].fillna(df['Age'].mean)
    >>> df_result
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Eksik veriler üzerinde işlem yapmadan önce sütunlarda kaçar tane eksik verinin bulunduğuna bakılmalıdır. Eksik veriler çok fazlaysa 
    doldurma (imputation) iyi bir seçenek olmaktan çıkmaktadır. Veri bilimcisi bunun için bir eşik değer seçebilir. Series ve DataFrame
    sınıflarının isna metotları bool bir Series ya da DataFrame nesnesine geri dönmektedir. Bu nesnedeki True elemanlar eksik verileri 
    False elemanlar eksik olmayan verileri belirtir. Örneğin:

    >>> df.isna().sum(axis=0)
    PassengerId      0
    Survived         0
    Pclass           0
    Name             0
    Sex              0
    Age            177
    SibSp            0
    Parch            0
    Ticket           0
    Fare             0
    Cabin          687
    Embarked         2

    Burada df.isna metodu ile bool değerlerden oluşan bir DataFrame elde edilmiştir. Daha sonra sütunsal toplama yapılarak True
    olanların sayısına bakılmıştır. Elde edilen sonucu dikkat ediniz. Titanic veri kümesinde 177 kişinin "Age" bilgisi, 687 kişinin 
    "Cabin" bilgisi ve 2 kişinin de "Embarked" bilgisi yoktur. "Cabin" sütunundaki eksiklik çok fazladır. Bu kadar fazla eksikliği 
    olan sütunlarda eksik verilerin doldurulması yerine sütunun tümden atılması tercih edilebilmektedir. Bu konuda pratik olarak 
    şunlar söylenebilir:

    - %0–5	Sütun tutulabilir, eksikler ortalama/medyan/mod ile doldurulabilir.
    - %5–20	Sütunun önemi yüksekse doldurulabilir, değilse atılabilir.
    - %20–50 Çoğu zaman atılma yoluna gidilir.
    - %50+	Sütun tamamen atılır.

    Burada Age sütununu ortalama ile doldurabiliriz ya da tamamen atabiliriz. Doldurma şöyle yapılabilir:

    df['Age'] = df['Age'].fillna(df['Age'].mean())

    Burada df['Age'] ifadesi ile DataFrame nesnesinin "Age" sütununa ilişkin Series elde edilmiş ve Series sınıfının fillna 
    metodu kullanılmıştır. Tabii elde edilen Series nesnesi yeniden "Age" sütununa atanmıştır.
    
    Aslında DataFrame sınıfının da bir fillna metodu vardır. Bu metodun birinci parametresi bir değer olarak girilirse tüm eksik 
    veriler bu değerle doldurulur. Fakat değişik sütunlar değişik değerlerle de doldurulmak istenebilir. Bunun için fillna metodunun 
    birinci parametresi bir sözlük olarak girilebilir. Bu sözlüğün anahtarları sütun isimlerinden değerleri de o sütuna doldurulacak 
    değerlerden oluşur. Örneğin:

    >>> df_result = df.fillna({'Age': df['Age'].mean(), 'Embarked': df['Embarked'].mode()})

    Burada biz "Age" sütunundaki eksik verileri o sütunun ortalaması ile, "Embarked" sütunundaki eksik verileri ise o sütundaki
    mod değeri ile doldurduk. fillna metodunun da inplace parametresi bulunmaktadır. "Cabin sütununda çok fazla eksik veri olduğu 
    için bu sütunu tamamen atabiliriz:

    >>> df_result = df_result.drop('Cabin', axis=1)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    DataFrame nesnesi üzerinde belirli koşulları sağlayan değerleri elde etmek için Series sınıfında anlattığımız bool indeksleme 
    kullanılabilir. Örneğin Titanic veri kümesinde yaşı 10'dan küçük olan yolculara ilişkin satırları şöyle elde edebiliriz:

    >>> df[df['Age'] < 10]
     PassengerId  Survived  Pclass                                      Name  ...           Ticket     Fare  Cabin  Embarked
    7              8         0       3            Palsson, Master. Gosta Leonard  ...           349909  21.0750    NaN         S
    10            11         1       3           Sandstrom, Miss. Marguerite Rut  ...          PP 9549  16.7000     G6         S
    16            17         0       3                      Rice, Master. Eugene  ...           382652  29.1250    NaN         Q
    24            25         0       3             Palsson, Miss. Torborg Danira  ...           349909  21.0750    NaN         S
    43            44         1       2  Laroche, Miss. Simonne Marie Anne Andree  ...    SC/Paris 2123  41.5792    NaN         C
    ..           ...       ...     ...                                       ...  ...              ...      ...    ...       ...
    827          828         1       2                     Mallet, Master. Andre  ...  S.C./PARIS 2079  37.0042    NaN         C
    831          832         1       2           Richards, Master. George Sibley  ...            29106  18.7500    NaN         S
    850          851         0       3   Andersson, Master. Sigvard Harald Elias  ...           347082  31.2750    NaN         S
    852          853         0       3                   Boulos, Miss. Nourelain  ...             2678  15.2458    NaN         C
    869          870         1       3           Johnson, Master. Harold Theodor  ...           347742  11.1333    NaN         S

    Yaşı 10'dan küçük olan yolcuların yaşlarını ve sağkalım durumlarını şöyle elde edebiliriz:

    >>> df[df['Age'] < 10][['Survived', 'Age']]

         Survived   Age
    7           0  2.00
    10          1  4.00
    16          0  2.00
    24          0  8.00
    43          1  3.00
    ..        ...   ...
    827         1  1.00
    831         1  0.83
    850         0  4.00
    852         0  9.00
    869         1  4.00

    Peki "yaşı 10'dan küçük olan ve hayatını kaybeden yolcuların listesini" nasıl alabiliriz? Bu işlem şöyle yapılabilir:

    >>> df_result = df[(df['Age'] < 10) & (df['Survived'] == 0)]

    Bu tür filtrelemeler için Pandas'ta DataFrame sınıfında query isimli güçlü bir metot bulundurulmuştur. Bu metot adeta SQL'deki
    SELECT komutu gibi çalışmaktadır. Bu metoda SQL SELECT cümlesi gibi bir yazı girilirse koşulu sağlayan satırlar bir DataFrame 
    biçiminde elde edilebilecektir. Örneğin:

    df_result = df.query('Age < 10 and Survived == 0')

    Burada "yaşı 10'dan küçük ve hayatını kaybetmiş olan" kişiler DataFrame nesnesi biçiminde elde edilmektedir. Eğer bu 
    koşulları sağlayan satırların belli sütunları seçilecekse ayrıca indeksleme yapılmalıdır. Örneğin:

    >>> df_result = df.query('Age < 10 and Survived == 0')[['Age', 'Name']]
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Series ve DataFrame sınıflarının apply isimli metotları da vardır. Bu metotların birinci parametresine bir fonksiyon girilir. 
    Metotlar sütunlardaki değerleri girilen bu fonksiyona parametre yapıp onun geri dönüş değerini bize vermektedir. Örneğin:

    df['Age'] = df['Age'].apply(lambda x: x - 10)

    Burada yolcuların "Age" sütunlarındaki değerler yerine onların 2 eksiği oraya yerleştirilmiştir. DataFrame sınıfının apply metodu 
    axis parametresi de almaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                            53. Ders 27/09/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Series nesnesinde yazı varsa (dtype='object' ya da dtype='string' de olabilir) o Series nesnesinin str isimli özniteliği yazısal 
    bize sütunlar üzerinde işlemler yapabilmemiz için bir nesne vermektedir. Bu nesne Python'daki str nesnesi gibidir. Biz de yazılsa 
    sütunlar üzerinde tipik string işlemlerini yapabiliriz. Örneğin:

    >>> df = pd.read_csv('us-counties.csv')
    >>> df
                date      geoid      county  ... deaths  deaths_avg  deaths_avg_per_100k
    0        2020-01-21  USA-53061   Snohomish  ...      0        0.00                 0.00
    1        2020-01-22  USA-53061   Snohomish  ...      0        0.00                 0.00
    2        2020-01-23  USA-53061   Snohomish  ...      0        0.00                 0.00
    3        2020-01-24  USA-53061   Snohomish  ...      0        0.00                 0.00
    4        2020-01-24  USA-17031        Cook  ...      0        0.00                 0.00
    ...             ...        ...         ...  ...    ...         ...                  ...
    1774199  2021-09-29  USA-69120      Tinian  ...      0        0.00                 0.00
    1774200  2021-09-29  USA-69110      Saipan  ...      0        0.00                 0.00
    1774201  2021-09-29  USA-78030  St. Thomas  ...      1        0.14                 0.28
    1774202  2021-09-29  USA-78020    St. John  ...      0        0.00                 0.00
    1774203  2021-09-29  USA-78010   St. Croix  ...      0        0.14                 0.28

    [1774204 rows x 10 columns]

    >>> df['state']
    0                        Washington
    1                        Washington
    2                        Washington
    3                        Washington
    4                          Illinois
                        ...
    1774199    Northern Mariana Islands
    1774200    Northern Mariana Islands
    1774201              Virgin Islands
    1774202              Virgin Islands
    1774203              Virgin Islands
    Name: state, Length: 1774204, dtype: object

    >>> df['state'].str.len()
    0          10
    1          10
    2          10
    3          10
    4           8
            ..
    1774199    24
    1774200    24
    1774201    14
    1774202    14
    1774203    14
    Name: state, Length: 1774204, dtype: int64

    Burada DataFrame nesnesi ile nesnenin 'state' sütununa ilişkin Series nesnesi elde edilmiştir. Sonra da str özniteliğinden 
    hareketle sütunlardaki eyalet belirten yazıların uzunlukları bulunmuştur. str ile kullanılabilecek bazı metotlar şunlardır:

    ⮞ Dönüştürme / Biçimlendirme

    str.capitalize()
    str.casefold()
    str.lower()
    str.upper()
    str.swapcase()
    str.title()
    str.normalize(form)
    str.strip([chars])
    str.lstrip([chars])
    str.rstrip([chars])
    str.pad(width, side='left', fillchar=' ')
    str.center(width, fillchar=' ')
    str.zfill(width)
    str.wrap(width, ...)

    ⮞ Arama / Koşul

    str.contains(pat, case=True, regex=True)
    str.startswith(pat)
    str.endswith(pat)
    str.match(pat)
    str.fullmatch(pat)
    str.isalnum()
    str.isalpha()
    str.isdigit()
    str.isspace()
    str.islower()
    str.isupper()
    str.istitle()
    str.isnumeric()
    str.isdecimal()
    str.isidentifier()
    str.isascii()

    ⮞ Arama / Konum bulma

    str.find(sub)
    str.rfind(sub)
    str.index(sub)
    str.rindex(sub)
    str.len()
    str.count(pat)

    ⮞ Regex tabanlı işlemler

    str.extract(pat, expand=True)
    str.extractall(pat)
    str.replace(pat, repl, case=True, regex=True)
    str.findall(pat)
    str.get_dummies(sep='|')

    ⮞ Bölme / Parçalama

    str.split(pat=None, n=-1, expand=False)
    str.rsplit(pat=None, n=-1, expand=False)
    str.partition(sep)
    str.rpartition(sep)
    str.slice(start=None, stop=None, step=None)
    str.slice_replace(start=None, stop=None, repl=None)
    str.get(i)

    ⮞ Dizge Manipülasyonu

    str.cat(others=None, sep=None, na_rep=None, join=None)
    str.repeat(repeats)
    str.replace(...)
    str.wrap(width)
    str.translate(table)

    ⮞ Bilgi / Yardımcı

    str.encode(encoding, errors='strict')
    str.decode(encoding, errors='strict')
    str.contains(...)
    str.count(...)

    Örneğin:

    >>> df.query('state.str.len() < 10 & cases_avg > 10')
                date      geoid         county     state  ...  cases_avg_per_100k  deaths  deaths_avg  deaths_avg_per_100k
    788      2020-03-08  USA-36119    Westchester  New York  ...                1.20       0        0.00                 0.00
    906      2020-03-09  USA-36119    Westchester  New York  ...                1.43       0        0.00                 0.00
    1052     2020-03-10  USA-36119    Westchester  New York  ...                1.58       0        0.00                 0.00
    1234     2020-03-11  USA-36119    Westchester  New York  ...                1.64       0        0.00                 0.00
    1455     2020-03-12  USA-36998  New York City  New York  ...                0.16       0        0.00                 0.00
    ...             ...        ...            ...       ...  ...                 ...     ...         ...                  ...
    1774190  2021-09-29  USA-01015        Calhoun   Alabama  ...               91.04       0        3.14                 2.77
    1774193  2021-09-29  USA-01009         Blount   Alabama  ...               59.79       0        1.14                 1.98
    1774194  2021-09-29  USA-01007           Bibb   Alabama  ...               70.17       0        0.43                 1.91
    1774196  2021-09-29  USA-01003        Baldwin   Alabama  ...               29.63       4        3.71                 1.66
    1774197  2021-09-29  USA-01001        Autauga   Alabama  ...               37.59       1        1.00                 1.79

    [399595 rows x 10 columns]
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Python'da istatistiksel grafikler çizmek için en çok kullanılan üç kütüphane "Matplotlib", "Seaborn" ve "Plotly" isimli 
    kütüphaneleridir. Başka alternatifler olsa da bu alternatifler henüz bunlarla rekabet edecek düzeye gelmemiştir. Biz burada 
    Matplotlib üzerinde duracağız. Çünkü en yaygın kullanılan grafik çizme kütüphanesi Matplotlib isimli kütüphanedir. Bu kütüphane 
    temel istatistiksel grafikler çizmek için kullanılmaktadır. Borsalarda kullanılan "mum grafiği (candle stick graphics)" gibi özel 
    amaçla kullanılan grafikler bu kütüphane ile çizilememektedir. 

    Matplotlib Anaconda dağıtımının doğal bir parçası durumundadır. Bu nedenle bu dağıtım install edildiğinde Matplotlib de zaten 
    kurulmuş durumdadır. Ancak diğer dağıtımlarda ve IDE'lerde bu kütüphanenin aşağıdaki gibi ayrıca kurulması gerekir:

    pip install matplotlib

    Kütüphanenin doğrudan çizim için kullanılan alt paketi "pyplot" isimli pakettir. Dolayısıyla genellikle programcılar doğrudan bu 
    paketi kullanırlar. Biz de çizimlerimizde bu paketi aşağıdaki gibi import edeceğiz:

    import matplotlib.pyplot as plt

    matplotlib.pyplot paketi kütüphanein yüksek seviyeli ve kullanıların doğrudan kullandığı en önemli paketidir. 

    Bu kütüphane "klasik prosedürel teknikle" yani fonksiyonlar yoluyla ya da "nesne yönelimli teknikle" yani sınıfların metotlarını 
    çağırarak da kullanılabilmektedir. Biz önce prosedürel kullanım üzerinde duracağız. Sonra sınıfsal kullanımı ele alacağız. 

    Kütüphanenin dokümantasyonuna aşağıdaki bağlantıdan erişilebilir:

    https://matplotlib.org/stable/index.html
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Matplotlib kütüphanesinde önemli iki kavram vardır: Figür (figure) ve Eksen (axis). Figür eksenleri tutan bir kap gibi (ya da 
    "canvas" da diyebiliriz) düşünülmüştür. Biz çizimleri eksenlere yaparız. En sık karşılaşılan durum bir figüde bir eksen bulunması 
    durumudur. Ancak bir figürde birden fazla eksen de bulunabilir. 

    Çizim işlemleri prosedürel teknikle yapılacaksa zaten bu teknikte işin başında default bir figür ve eksen yaratılmış durumdadır. 
    Dolayısıyla çizimler zaten var olan figür ve eksen üzerine yapılır. Bizim yaratmadığımız zaten işin başında yaratılmış olan bu 
    figür ve eksene "default figür" ve "default eksen" denilmektedir. Çizim fonksiyonları prosedürel teknikte her zaman çizimleri 
    default figürdeki default eksene yapmaktadır. 

    Matplotlib'te değişik grafikler için değişik fonksiyonlar kullanılmaktadır. Çizim işlemlerinden sonra show fonksiyonu çağrılmalıdır. 
    show fonksiyonu görüntülemeyi yapmaktadır. show fonksiyonu çağrıldıktan sonra artık figür ve eksen sıfırlanmış olur. Yani sıfırdan 
    eksene yeni bir çizim yapılabilir. 

    Anaconda'nın Spyder IDE'sinde yapılan çizimlerin doğrudan IPython ekranında görüntülenmesi için yukarıda "Plots" sekmesi seçilip 
    sağ üstteki çizgili menüden Mute inline plotting" unchecked yapılmalıdır. Aksi takdirde çizimler "Plots" sekmesinde görüntülenecektir. 
    Text ekranda komut satırında çizim yapılırken çizimler show fonksiyonu çağrıldığında bir popup pencere üzerinde görüntülenmektedir. 
    Spyder'da "Mute inline plotting" unchecked yapıldığında show fonksiyonu çağrılmadan görüntüleme yapılabilmektedir. Ancak siz 
    her zaman show fonksiyonunu çağırmalısınız. Çünkü show fonksiyonunun başla işlevleri de vardır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    En çok kullanılan çizim fonksiyonu şüphesiz plot isimli fonksiyondur. plot çizgi grafiği çizmektedir. Tipik olarak bu fonksiyon 
    x ve y değerlerini birer liste ya da NumPy dizisi olarak alır. Bu x ve y listelerinin karşılıklı elemanlarını nokta olarak kabul 
    edip onları çizgilerle birleştirir. Tabii bu noktaların sayısı çoksa çizgiler küçük olacak ve çizgiler kırıklı gözükmeyecektir. 
    Örneğin aşağıda bir sinüs eğrisi örneği verilmiştir. Bu örneği NPOINTS değerini gittikçe artırarak deneyiniz. Nokta sayısı arttıkça 
    kırıklı görünüm ortadan kalkacaktır. 

    NPOINTS = 20

    x = np.linspace(-6.28, 6.28, NPOINTS)
    y = np.sin(x)

    plt.plot(x, y)
    plt.show()
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt
import numpy as np

NPOINTS = 20

x = np.linspace(-6.28, 6.28, NPOINTS)
y = np.sin(x)

plt.plot(x, y)
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    show yapana kadar çizdiğimiz tüm grafikler aynı eksende görüntülenir. Matplotlib otomatik olarak her grafiği farklı renkle 
    çizdirmektedir. Yukarıda da belirttiğimiz gibi her show işleminden sonra sıfırdan yeni bir eksen başlatılır. Biz de yeni bir 
    çizime başlamış oluruz. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt
import numpy as np

NPOINTS = 1000

x = np.linspace(-6.28, 6.28, NPOINTS)
y = np.sin(x)

plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
        Aşağıda yine birden fazla çizim aynı eksen üzerine yapılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-6, 6, 100)

y = x ** 2 - 4
plt.plot(x, y)

y = 3 * x - 2
plt.plot(x, y)

y = 0.01 * x ** 3
plt.plot(x, y)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda 2^x üstel fonksiyonunun grafiği çizilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(0, 10, 10000)
y = 2 ** x

plt.plot(x, y)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda sigmoid fonksiyonunun grafiği çizdirilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(-10, 10, 1000)
y = 1 / (1 + np.e ** -x)

plt.plot(x, y)
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir grafik çizdiğimiz zaman grafikte 0 noktası ve eksanlardaki değerler otomatik olarak uygun bir biçimde belirlenmektedir. Yani
    çizdirdiğiniz grafikte beklediğiniz kartezyen koordinat sistemini göremeyebilirsiniz. Default durumda eksenin dört tarafında 
    çizgilerle bir kutu gibi kapatılmaktadır Tabii çizimin kartezyen koordinat sistemi gibi birbirini dik kesen iki doğru üzerinde 
    görünmesini de sağlayabilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Grafiğe çeşitli öğeler ekleyerek grafin daha dolgun gözükmesi sağlanabilmektedir. Örneğin grafiğe bir başlık yazısı eklemek için 
    title isimli fonksiyon kullanılmaktadır. Örneğin:

    plt.title('Sigmoid Fonksiyonu')
    x = np.linspace(-10, 10, 1000)
    y = 1 / (1 + np.e ** -x)

    plt.plot(x, y)
    plt.show()

    Burada eksenin üzerinde "Sigmoid Fonksiyonu" yazısı çıkacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Sigmoid function')
x = np.linspace(-10, 10, 1000)
y = 1 / (1 + np.e ** -x)

plt.plot(x, y)
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    title fonksiyonunda loc parametresi başlığın hizalamasında kullanılır. Default durum "center" biçimindedir. Ancak biz bu parametreye 
    "left" ya da "right" girebiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-6, 6, 100)

plt.title("Sinus-Kosinüs Grafiği", loc='left')

y = np.sin(x)
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    title fonksiyonunun pad (padding) parametresi başlık yazısının grafiğin ne kadar yukarısında görüntüleneceğini belirtmektedir. 
    Default durum 6 pixeldir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-6, 6, 100)

plt.title("Sinus-Kosinüs Grafiği", pad=20)

y = np.sin(x)
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    title fonksiyonundaki **kwargs parametresine için sayıda isimli parametre girilebilmektedir. Bu parametreler plt.text fonksiyonunda 
    dokümante edilmiştir. Önemli olanları şunlardır:
    
    color: Yazının rengini belirtir. Renk isim olarak girilebilir. Ya da '#rrggbb' biçiminde hex digitler biçiminde de girilebilir. 
    fontsize: Yazının puntosunu belirler. 
    fontfamily: Yazının font ismini belirtir. 
    fontstyle: 'bold', 'italic' ya da 'normal' olabilir. 
    fontweight: Font'un bold'luk durumu ile ilgilidir. Bu parametreye 'bold', 'semibold', 'heavy', 'extrabold' gibi değerler 
    girilebilmektedir.
    x ve y: Yazının ortasının bulunduğu x ve y pozisyonlarını belirtmektedir. Buradaki grafikteki x ve y koordinatlarıdır. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-6.28, 6.28, 100)

plt.title("Sinus-Kosinüs Grafiği", pad=40, color='red', fontsize=20, fontfamily='arial', fontstyle='italic', fontweight='bold', x=0.5)

y = np.sin(x)
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Hangi grafiğin hangi amaçla kullanıldığını belirten simgelere grafik terminolojisinde "legend" denilmektedir. Legend oluşturmak 
    için legend isimli fonksiyon kullanılmaktadır. Fonksiyona yazılardan oluşan dolaşılabilir bir nesne verilir. Fonksiyon da bu 
    yazılardan hareketle legend'ları oluşturur. legend fonksiyonu grafikler çizildikten sonra (örneğin plot çağrılarından sonra)  
    çağrılmalıdır. Örneğin:

    plt.title('Kosinüs - Hiperbolik Tanjant Fonksiyonları', color='blue')

    x = np.linspace(-10, 10, 1000)
    y = (np.e ** x - np.e ** -x) / (np.e ** x + np.e ** -x) 
    plt.plot(x, y)

    y = np.cos(x)
    plt.plot(x, y)
    plt.legend(['tanh', 'cos'])

    plt.show()
    
    legend bilgisi otomatik olarak grafiğin uygun bir yerine yerleştirilmektedir. Ancak legend fonksiyonunun loc parametresi ile bu 
    yerleşim yerini biz de belirleyebiliriz. loc parametresi 'upper left', 'upper right', 'lower left', 'lower right' , 'upper center' 
    gibi değerler alabilmektedir. Bu parametrenin alabileceği değerlerin listesi şunlardır:

    best
    upper right
    upper left
    lower left
    lower right
    right
    center left
    center right
    lower center
    upper center
    center

    legend fonksiyonunda legend yazıları çeşitli isimli parametrelerle özelleştirilebilmektedir. Bu isimli parametreleri matplotlib'teki 
    legend fonksiyonun dokümantasyonundan öğrenebilirsiniz. Örneğin yine fontsize parametresi legend yazılarının büyüklüğünü, labelcolor 
    parametresi yazıların renklerini, edgecolor legend kutucuğunun rengini, facecolor kutucuğun zemin rengini belirlemekte kullanılabilir. 
    Örneğin:

    plt.legend(['tanh', 'cos'], facecolor='gray', edgecolor='red')
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Kosinüs - Hiperbolik Tanjant Fonksiyonları', color='blue')

x = np.linspace(-10, 10, 1000)
y = (np.e ** x - np.e ** -x) / (np.e ** x + np.e ** -x) 
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)
plt.legend(['tanh', 'cos'], facecolor='gray', edgecolor='red')

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Grafiğin içerisine ızgara çizgileri grid isimli fonksiyonla yerleştirilebilir. Böylece sanki grafik bir çeşit grafik kağıdına 
    çizilmiş gibi gözükür. grid fonksiyonun ızgara çizgilerinin biçimini belirleyen çeşitli isimli parametreleri vardır. Bu parametreler
    dokümanlardan incelenebilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Kosinüs - Hiperbolik Tanjant Fonksiyonları', color='blue')
plt.grid()

x = np.linspace(-10, 10, 1000)
y = (np.e ** x - np.e ** -x) / (np.e ** x + np.e ** -x) 
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)
plt.legend(['tanh', 'cos'], facecolor='gray', edgecolor='red')

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Çizimdeki x ve y eksenlerine isim vermek için xlabel ve ylabel fonksiyonları kullanılmaktadır. Bu fonksiyonlar da  gösterilecek 
    yazının  biçimleriyle ilgili isimli parametreler almaktadır. Bu parametrelerin tam listesi için title fonksiyonunda belirttiğimiz
    gibi text fonksiyonunun dokümanlarına başvurabilirsiniz. En çok kullanılan parametreler şunlardır:

    color
    fontsize
    fontfamily
    fontstyle
    fontweight

    Örneğin:

    plt.xlabel('X', fontweight='bold', color='red')
    plt.ylabel('Y', fontweight='bold', color='red')

    Yine fonksiyonların loc parametreleri yazının yerini belirlemekte kullanılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Kosinüs - Hiperbolik Tanjant Fonksiyonları', color='blue')

plt.xlabel('X', fontweight='bold', color='red', loc='center')
plt.ylabel('Y', fontweight='bold', color='red')

plt.grid()
x = np.linspace(-10, 10, 1000)
y = (np.e ** x - np.e ** -x) / (np.e ** x + np.e ** -x) 
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)
plt.legend(['tanh', 'cos'], facecolor='gray', edgecolor='red')

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    x ve y eksenleri için aralık xlim ve ylim fonksiyonlarıyla belirlenebilir. Böyle bir belirleme yapılmadıysa matplotlib bu 
    belirlemeleri kendisi yapmaktadır. Örneğin:

    plt.ylim(-2, 2)
    plt.xlim(-12, 12)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Kosinüs - Hiperbolik Tanjant Fonksiyonları', color='blue')

plt.xlabel('X', fontweight='bold', color='red', loc='center')
plt.ylabel('Y', fontweight='bold', color='red')

plt.ylim(-2, 2)
plt.xlim(-12, 12)

plt.grid()
x = np.linspace(-10, 10, 1000)
y = (np.e ** x - np.e ** -x) / (np.e ** x + np.e ** -x) 
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)
plt.legend(['tanh', 'cos'], facecolor='gray', edgecolor='red')

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Eksenlerdeki tick'lerin yerlerini belirlemek için xticks ve yticks fonksiyonları kullanılmaktadır. Yine xticks ve yticks fonksiyonlarında
    tick'lerin biçimini belirleyen text fonksiyonunda dokümante edilmiş olan isimli parametreler kullanılabilmektedir. Örneğin:

    plt.xticks(range(-12, 13, 2), color='blue', fontsize=9)
    plt.yticks(np.arange(-2, 2, 0.25), color='blue', fontsize=9)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Kosinüs - Hiperbolik Tanjant Fonksiyonları', color='blue')

plt.xlabel('X', fontweight='bold', color='red', loc='center')
plt.ylabel('Y', fontweight='bold', color='red')

plt.ylim(-2, 2)
plt.xlim(-12, 12)

plt.xticks(range(-12, 13, 2), color='blue', fontsize=9)
plt.yticks(np.arange(-2, 2, 0.25), color='blue', fontsize=9)

plt.grid()
x = np.linspace(-10, 10, 1000)
y = (np.e ** x - np.e ** -x) / (np.e ** x + np.e ** -x) 
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)
plt.legend(['tanh', 'cos'], facecolor='gray', edgecolor='red')

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Grafiğin içerisine text isimli fonksiyonla bir yazı yerleştirebiliriz. Bu yazının konumu grafikteki eksen bilgilerine göre ve 
    yazının sol alt köşesi o konumda olacak biçimde belirlenmektedir. Anımsayacağınız gibi biz daha önce title gibi, xlabels, ylabels
    gibi fonksiyonlarda aslında text fonksiyonundaki parametrelerin geçerli olduğunu belirtmiştik. Aşağıdaki dokümantasyonda text 
    fonksiyonunda kullanabileceğiniz tüm parametreler hakkında bilgiler bulunmaktadır:

    https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.text.html

    Tabii en çok kullanılan text parametreleri şunlardır:

    color
    fontsize
    fontfamily
    fontstyle
    fontweight
    rotation
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Kosinüs - Hiperbolik Tanjant Fonksiyonları', color='blue')

plt.xlabel('X', fontweight='bold', color='red', loc='center')
plt.ylabel('Y', fontweight='bold', color='red')

plt.ylim(-2, 2)
plt.xlim(-12, 12)

plt.xticks(range(-12, 13, 2), color='blue', fontsize=9)
plt.yticks(np.arange(-2, 2, 0.25), color='blue', fontsize=9)

plt.grid()
x = np.linspace(-10, 10, 1000)
y = (np.e ** x - np.e ** -x) / (np.e ** x + np.e ** -x) 
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)
plt.legend(['tanh', 'cos'], facecolor='gray', edgecolor='red')

plt.text(-8.5, 0.25, 'This is a test', fontsize=8, fontweight='bold', rotation=65)
plt.text(-7.6, -0.5, 'Inside Parabol', fontsize=5, fontweight='bold')

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Çizim alanının içerisine ok çizdirebiliriz. Bunun arrow fonksiyonu kullanılır. Bu fonksiyon okun başlangıç ve bitiş koordinatlarını 
    eksen değerleriyle almaktadır.  Örneğin:

    plt.arrow(2, 1.5, -1.7, -0.4, style='round', head_length=0.3, head_width=0.1, color='red', linestyle=':')

    Ok çizerken ilk iki parametre okun başlangıç koordinatlarını belirtmektedir. Diğer iki parametre ise bitiş koordinatlarının deltax
    değerlerini belirtir. (Yani bu koordinatlar ok işaretinin delta değerlerini belirtmektedir.) Buradaki delta değerler başlangıçtan 
    itibaren x ekseninde ve y ekseninde ne kadar ilerleneceği anlamına gelmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Kosinüs - Hiperbolik Tanjant Fonksiyonları', color='blue')

plt.xlabel('X', fontweight='bold', color='red', loc='center')
plt.ylabel('Y', fontweight='bold', color='red')

plt.ylim(-2, 2)
plt.xlim(-12, 12)

plt.xticks(range(-12, 13, 2), color='blue', fontsize=9)
plt.yticks(np.arange(-2, 2, 0.25), color='blue', fontsize=9)

plt.grid()
x = np.linspace(-10, 10, 1000)
y = (np.e ** x - np.e ** -x) / (np.e ** x + np.e ** -x) 
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)
plt.legend(['tanh', 'cos'], facecolor='gray', edgecolor='red')

plt.text(-8.5, 0.25, 'This is a test', fontsize=8, fontweight='bold', rotation=65)
plt.text(-7.6, -0.5, 'Inside Parabol', fontsize=5, fontweight='bold')
plt.arrow(2, 1.5, -1.7, -0.4, style='round', head_length=0.3, head_width=0.1, color='red', linestyle=':')
plt.text(2, 1.5, 'Tepe noktası', fontsize=8)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Grafiği büyütmek ya da küçültmek için figürün büyütülmesi ya da küçültülmesi gerekir. Bunun için figure isimli fonksiyon ile yeni 
    bir figür yaratılıp o figürün aktif figür olması sağlanabilir. Yeni figür yaratılırken figure fonksiyonun figsize parametresi 
    inch cinsinden iki elemanlı bir demet biçiminde figürün genişlik ve yüksek değerlerini almaktadır. Örneğin:

    plt.figure(figsize=(6, 4))

    facecolor isimli parametresi ile figürün arka plan rengini de değiştirilebilir. Örneğin:

    plt.figure(figsize=(6, 4), facecolor='#FFFFDD')
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.figure(figsize=(6, 4), facecolor='#FFFFDD')
plt.title('Kosinüs - Hiperbolik Tanjant Fonksiyonları', color='blue')

plt.xlabel('X', fontweight='bold', color='red', loc='center')
plt.ylabel('Y', fontweight='bold', color='red')

plt.ylim(-2, 2)
plt.xlim(-12, 12)

plt.xticks(range(-12, 13, 2), color='blue', fontsize=9)
plt.yticks(np.arange(-2, 2, 0.25), color='blue', fontsize=9)

plt.grid()
x = np.linspace(-10, 10, 1000)
y = (np.e ** x - np.e ** -x) / (np.e ** x + np.e ** -x) 
plt.plot(x, y)

y = np.cos(x)
plt.plot(x, y)
plt.legend(['tanh', 'cos'], facecolor='gray', edgecolor='red')

plt.text(-8.5, 0.25, 'This is a test', fontsize=8, fontweight='bold', rotation=65)
plt.text(-7.6, -0.5, 'Inside Parabol', fontsize=5, fontweight='bold')
plt.arrow(2, 1.5, -1.7, -0.4, style='round', head_length=0.3, head_width=0.1, color='red', linestyle=':')
plt.text(2, 1.5, 'Tepe noktası', fontsize=8)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında bir figürde tek bir eksen bulunmak zorunda değildir. Birden fazla eksen bulundurulabilir. Böylece farklı grafikler yan 
    yana görüntülenebilir. Bu işlem çeşitli biçimlerde yapılabilmektedir. En basit biçim subplot fonksiyonunu kullanmaktır. Bir figürde 
    birden fazla eksen varsa bunların bir tanesi aktif eksendir. Dolayısıyla çizimler aktif eksene yapılırlar. subplot fonksiyonu yeni 
    bir eksen yaratıp onu aktif hale getirmektedir. sublot fonksiyonunundaki ilk iki parametre eksenlerin oluşturacağı matrisin boyutlarını,  
    üçüncü parametre ise bu matristeki hangi eksenin aktif hale getirileceğini belirtmektedir. Burada eksenlerin numaraları 1'den 
    başlatılır ve eksenler satır tabanlı olarak (row-wise) numaralandırılmaktadır. Bir eksen aktif hale getirildiğinde artık yukarıda 
    gördüğümüz çizim ile ilgili fonksiyonların hepsi o eksen üzerinde yapılır. Örneğin plt.title fonksiyonu eksen için bir başlık 
    oluşturmaktadır. Dolayısıyla biz istersek her eksene ayrı bir başlık atayabiliriz. Örneğin:

    plt.subplot(2, 2, 1)

    Burada 2x2'lik bir eksen matrisi oluşturulmuştur. Biz buy matrisin sol üst elemanını aktif hale getirmiş olmaktayız. Buradaki 
    numaralandırma satırsaldır. Örneğin:

    plt.subplot(2, 2, 2)

    Şimdi biz matrisin sağ üst elemanını aktif hale getirmiş olmaktayız. Bunu şekilsel olarak şöyle de gösterebiliriz:

    plt.subplot(2, 2, 1)            plt.subplot(2, 2, 2)
    plt.subplot(2, 2, 3)            plt.subplot(2, 2, 4)

    Bu tür çizimler yaparken subplot fonksiyonunun ilk parametresini baştan belirlemlisiniz. Bu iki parametreyi aynı tutup üçüncü 
    parametreyi değiştierek çizimleri yapabilirsiniz. Örneğin:

    plt.subplot(2, 2, 1)
    plt.title('Sinüs')
    x = np.linspace(-6.5, 6.5, 1000)
    y = np.sin(x)
    plt.plot(x, y)

    plt.subplot(2, 2, 2)
    plt.title('Cosinüs')
    x = np.linspace(-6.5, 6.5, 1000)
    y = np.cos(x)
    plt.plot(x, y)

    plt.subplot(2, 2, 3)
    plt.title('Parabol')
    x = x = np.linspace(-10, 10, 1000)
    y = x ** 2 - 2 * x + 1
    plt.plot(x, y)

    plt.subplot(2, 2, 4)
    plt.title('Logaritma')
    x = x = np.linspace(-10, 10, 1000)
    y = np.log(x)
    plt.plot(x, y)

#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.figure(figsize=(8, 8))

plt.subplot(2, 2, 1)
plt.title('Sinüs')
x = np.linspace(-6.5, 6.5, 1000)
y = np.sin(x)
plt.plot(x, y)

plt.subplot(2, 2, 2)
plt.title('Cosinüs')
x = np.linspace(-6.5, 6.5, 1000)
y = np.cos(x)
plt.plot(x, y)

plt.subplot(2, 2, 3)
plt.title('Parabol')
x = x = np.linspace(-10, 10, 1000)
y = x ** 2 - 2 * x + 1
plt.plot(x, y)

plt.subplot(2, 2, 4)
plt.title('Logaritma')
x = x = np.linspace(-10, 10, 1000)
y = np.log(x)
plt.plot(x, y)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii biz eksenleri bir döngü içerisinde aktif hale getirip çizimleri yapabiliriz. Örneğin:

    for i in range(1, 10):
        plt.subplot(3, 3, i)
        plt.title(f'X^{i}', fontsize=9, color='red')
        x = np.linspace(-100, 10)
        y = -x ** i
        plt.yticks(fontsize=6)
        plt.xticks(fontsize=6)
        plt.plot(x, y)
    plt.show()
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.figure(figsize=(9, 9))

for i in range(1, 10):
    plt.subplot(3, 3, i)
    plt.title(f'X^{i}', fontsize=9, color='red')
    x = np.linspace(-100, 10)
    y = -x ** i
    plt.yticks(fontsize=6)
    plt.xticks(fontsize=6)
    plt.plot(x, y)
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında subplot fonksiyonun üç parametresi tek parametreli bir int sayı biçiminde de oluşturulabilmektedir. Örneğin:

    plt.subplot(331)        # eşdeğeri plt.subplot(3, 3, 1)
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.figure(figsize=(8, 8))

plt.subplot(221)
plt.title('Sinüs')
x = np.linspace(-6.5, 6.5, 1000)
y = np.sin(x)
plt.plot(x, y)

plt.subplot(222)
plt.title('Cosinüs')
x = np.linspace(-6.5, 6.5, 1000)
y = np.cos(x)
plt.plot(x, y)

plt.subplot(223)
plt.title('Parabol')
x = x = np.linspace(-10, 10, 1000)
y = x ** 2 - 2 * x + 1
plt.plot(x, y)

plt.subplot(224)
plt.title('Logaritma')
x = x = np.linspace(-10, 10, 1000)
y = np.log(x)
plt.plot(x, y)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Çizgi grafiği (plot) için kullanılan plot fonksiyonun pek çok parametresi vardır. Çizginin rengi color parametresiyle ayarlanabilir. 
    Eğer renk belirtilmezse plot her çizim için bir paletten farklı bir rengi otomatik biçimde seçmektedir. linewidth parametresi ile
    çizgi kalınlığı değiştirilebilmektedir. marker parametresi noktaların nasıl görüntüleneceğini belirtmektedir. Burada 'o' parametresi 
    küçük bir dairesel simge ile noktaların gösterileceği anlamına gelmektedir. Diğer önemli marker sembolleri şunlardır: 'v', 's', '*', 
    'x'. linestyle parametresi çizginin kesikliliği üzerinde belirleme yapılmasını sağlar. Burada önemli değerler şunlardır: '-', '--', 
    ':', '-.', none. marker'ların büyüklükleri pixel cinsinden markersize parametresiyle ayarlanabilmektedir. Marker'ların zemin 
    renkleri markerfacecolor parametresi çizgi renkleri markeredgecolor parametresiyle ayarlanabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Sinüs')
x = np.linspace(-6.5, 6.5, 10)
y = np.sin(x)
plt.plot(x, y, linewidth=5, marker='o', markerfacecolor='red', markeredgecolor='yellow', markersize=10)
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Çeşitli olguların çubuklarla temsil edildiği grafiklere "çubuk grafikleri (bar charts)" denilmektedir. Tabii çubuk grafikleri 
    aslında matematiksel grafikler değildir. Çubuk grafikleri daha çok betimsel istatistikte kullanılmaktadır. Çubuk grafiklerinde 
    çubukların yüksekliği önemlidir. Çubukların genişliklerinin ve alanlarının genel olarak bir önemi yoktur. Çubukların yükseklikleri 
    olgular arasındaki niceliksel farklılıkları gözle karşılaştırmalı bir biçimde anlamamıza yardımcı olmaktadır. Çubukların genişliklerinin 
    bir önemi yoksa da görüntünün daha güzel gözükmesinde genişlikler katkı sağlayabilmektedir. Çubuk grafikleri bar isimli fonksiyonla 
    oluşturulmaktadır. 

    bar fonksiyonun ilk iki parametresi zorunlu parametrelerdir. Birinci parametre çubukların x eksenindeki orta noktalarını belirten 
    sayılara ilişkin ya da çubukları betimleyen yazılara ilişkin bir liste biçiminde girilebilir. Eğer bu liste string listesi 
    biçimindeyse çubukların orta noktaları 0'dan başlatılır ve birer artırımlı olarak devam ettirilmektedir. Örneğin:

    plt.title('Çubuk Grafiği')
    plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9])
    plt.show()

    Burada x değerleri kişilerin isimlerinden oluşmaktadır. Çubuk grafiklerinde tipik olarak x değerleri sayıdan ziyade yazı 
    biçiminde girilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.title('Çubuk Grafiği')
plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9])
plt.show()


#------------------------------------------------------------------------------------------------------------------------------------
    Çubukların genişlikleri default olarak 0.8'dir. Ancak biz genişlikleri bar fonksiyonunun width parametresiyle değiştirebiliriz. 
    Tabii genişlikleri küçülttükçe çubuk aralarındaki boşluklar artar, genişlikleri büyüttükçe bu boşluklar azalır. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.figure(figsize=(5, 4))
plt.title('Çubuk Grafiği')
plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9], width=0.9)
plt.yticks(range(0, 11))
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    bar fonksiyonun color parametresine bir renk girilirse tüm çubuklar o renkte görüntülenir. Bu parametreye bir renk dizisi de 
    girilebilir. Böylelikle biz her çubuğun rengini ayrı ayrı ayarlayabiliriz. Örneğin:

    plt.figure(figsize=(5, 4))
    plt.title('Çubuk Grafiği')
    plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9], width=0.9, 
            color=['yellow', 'blue', 'brown', 'black', 'magenta', 'red'])
    plt.yticks(range(0, 11))
    plt.show()
#------------------------------------------------------------------------------------------------------------------------------------

plt.figure(figsize=(5, 4))
plt.title('Çubuk Grafiği')
plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9], width=0.9, 
        color=['yellow', 'blue', 'brown', 'black', 'magenta', 'red'])
plt.yticks(range(0, 11))
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    bar fonksiyonun edgecolor parametresi çubukların çizgi renklerini, linewidth parametresi çubukların çizgi kalınlıklarını ayarlamakta 
    kullanılmaktadır. fill parametresi False geçilirse çubukların içleri hiç boyanmamaktadır. hatch çubukların içlerindeki dolgu biçimlerini
    belirlemekte kullanılmaktadır. Bazı dolgu biçimleri şunlardır: '\\' '/', '|', '+', 'o', 'O', .', '*'. Örneğin:

    plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9], width=0.7, 
            color=['yellow', 'blue', 'brown', 'black', 'magenta', 'red'], edgecolor='black', linewidth=4, hatch='/')
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.figure(figsize=(5, 4))
plt.title('Çubuk Grafiği')
plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9], 
    width=0.7, color=['yellow', 'blue', 'brown', 'green', 'magenta', 'red'], edgecolor='black', linewidth=4, hatch='/')
plt.yticks(range(0, 11))
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    bar fonksiyonunun bottom parametresi çubukların tabanlarının y eksenine göre konumunu belirlemekte kullanılır. 0 değeri tabanların 
    x eksenine oturduğu anlamına gelmektedir ve default durumdur. Buradaki değer y eksenindeki skalaya göre belirlenmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.figure(figsize=(5, 4))
plt.title('Çubuk Grafiği')
plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9], 
        width=0.7, color=['yellow', 'blue', 'brown', 'green', 'magenta', 'red'], edgecolor='black', linewidth=4, hatch='/', bottom=1)
plt.yticks(range(0, 11))
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    bottom değeri vererek çizgilerin üst üste gözükmesi sağlanabilmektedir. Bunun bottom değeri tek bir değer olarak değil her 
    çubuk bir liste biçiminde girilmelidir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.figure(figsize=(5, 4))
x = ['A', 'B', 'C']
y1 = [3, 5, 2]
y2 = [2, 3, 4]

plt.bar(x, y1, label='Seri 1')
plt.bar(x, y2, bottom=y1, label='Seri 2')  # y1'in üstüne yerleştir
plt.legend()
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    bar fonksiyonunun align parametresi 'center' ya da 'edge' biçiminde olabilmektedir. Default durum 'center' biçimindedir. Bu parametre
    x değerlerinin çubukların ortasında mı yoksa solunda mı görüntüleneceğini belirtmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.figure(figsize=(5, 4))
plt.title('Çubuk Grafiği')
plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9], 
        width=0.7, color=['yellow', 'blue', 'brown', 'green', 'magenta', 'red'], edgecolor='black', linewidth=4, hatch='/', align='edge')
plt.yticks(range(0, 11))
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Çubukları sola ve sağa yaslamak için yine xlim fonksiyonu ile x eksenindeki limitleri belirlemek gerekebilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.figure(figsize=(5, 4))
plt.title('Çubuk Grafiği')
plt.xlim(0, 6)
plt.bar(['ali', 'veli', 'selami', 'ayşe', 'fatma', 'hüseyin'], height=[10, 6, 7, 6, 2, 9], width=0.7, 
        color=['yellow', 'blue', 'brown', 'green', 'magenta', 'red'], edgecolor='black', linewidth=4, hatch='/', align='edge')
plt.yticks(range(0, 11))
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    bar fonksiyonuyla ilgili başka ayrıntı özellikler vardır. Bunlar için Matplotlib dokümanlarına başvurabilirsiniz.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Diğer çok kullanılan grafik türünden biri de "saçılma (scatter)" grafiğidir. Bu grafikte yalnızca noktalar gösterilir. Noktaların 
    dışında başka bir öğe grafikte bulunmaz. Tabii noktalar bir pixel ile değil küçük dairelerle gösterilemektedir. Bu dairelerin 
    büyüklüğü ayarlanabilmektedir. Saçılma grafiği istatistik ve veri biliminde çok sık kullanılmaktadır. Saçılma grafiği bir dağılıma 
    ilişkin noktaların gözle kontrol edilebilmesi sıkça kullanılmaktadır. Saçılma grafikleri scatter isimli fonksiyonla çizilmektedir.

    scatter fonksiyonun ilk iki parametresi zorunlu parametrelerdir. Bunlar noktaların x ve y bileşenlerini belirtir. Örneğin:

    x = [4, 34, 21, 17, 8, 42, 19, 62, 23, 30, 55, 20, 15, 20, 55, 10, 32, 13, 50, 40]
    y = [12, 34, 2, 43, 23, 11, 41, 32, 42, 21, 25, 15, 20, 30, 8, 4, 12, 12, 40, 20] 

    plt.title('Saçılma Grafiği')
    plt.scatter(x, y)
    plt.show()

#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

x = [4, 34, 21, 17, 8, 42, 19, 62, 23, 30, 55, 20, 15, 20, 55, 10, 32, 13, 50, 40]
y = [12, 34, 2, 43, 23, 11, 41, 32, 42, 21, 25, 15, 20, 30, 8, 4, 12, 12, 40, 20] 

plt.title('Saçılma Grafiği')
plt.scatter(x, y)
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Saçılma grafiğindeki noktaların renkleri yine color isimli parametresiyle değiştirilebilir. Örneğin:

    plt.scatter(x, y, color='magenta')
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

x = [4, 34, 21, 17, 8, 42, 19, 62, 23, 30, 55, 20, 15, 20, 55, 10, 32, 13, 50, 40]
y = [12, 34, 2, 43, 23, 11, 41, 32, 42, 21, 25, 15, 20, 30, 8, 4, 12, 12, 40, 20] 

plt.title('Saçılma Grafiği')
plt.scatter(x, y, color='magenta')
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında her noktanın rengini istediğimiz gibi de ayarlayabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Scatter Graphics')

x = np.array([1, 5, 7, 3, 9, 12, 5, 25, 7, 19])
y = np.array([10, 21, 17, 7, 24, 21, 9, 14, 11, 1])
plt.scatter(x, y, color=['red', 'green', 'blue', 'blue', 'red', 'green', 'black', 'blue', 'green', 'black'])

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Aynı eksenin üzerine show işlemi yapmadan birden fazla saçılma grafiği çizdirilebilir. Bu durumda plot fonksiyonunda olduğu gibi 
    renkler özellikle belirtilmemişse her scatter için otomatik atanmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

x1 = np.array([1, 5, 7, 3, 9])
y1 = np.array([10, 21, 17, 7, 24])
x2 = np.array([12, 5, 25, 7, 19])
y2 = np.array([21, 9, 14, 11, 1])

plt.title('Scatter Graphics')
plt.scatter(x1, y1)
plt.scatter(x2, y2)
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Bazen farklı kategorik değerlerin farklı renklerle saçılma grafiğinin çizilmesi gerekebilmektedir. Örneğin aşağıdaki gibi 
    bir 'scatter.csv' dosyası olsun:

    kilo,boy,cinsiyet
    72,155,erkek
    87.3,172,erkek
    56.5,167,kadın
    47.3,171,kadın
    67.4,178,kadın
    56.7,174,erkek
    72.3,169,erkek
    78.5,181,kadın
    57.4,164,kadın
    91.6,185,erkek

    Burada yatay eksende "kilo", düşey eksende "boy" özellikleri temsil edilsin. Biz de erkeklerle kadınların noktalarını farklı renklerle
    göstermek isteyelim. Burada bizim cinsiyete göre filtrelemeler yapmamız gerekmektedir:

    df = pd.read_csv('scatter.csv')

    plt.title('Scatter Graphics')
    plt.scatter(df['kilo'][df['cinsiyet'] == 'erkek'],df['boy'][df['cinsiyet'] == 'erkek'])
    plt.scatter(df['kilo'][df['cinsiyet'] == 'kadın'],df['boy'][df['cinsiyet'] == 'kadın'])
    plt.legend(['Erkek', 'Kadın'])

#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd
import matplotlib.pyplot as plt


df = pd.read_csv('scatter.csv')

plt.title('Scatter Graphics')
plt.scatter(df['kilo'][df['cinsiyet'] == 'erkek'],df['boy'][df['cinsiyet'] == 'erkek'])
plt.scatter(df['kilo'][df['cinsiyet'] == 'kadın'],df['boy'][df['cinsiyet'] == 'kadın'])
plt.legend(['Erkek', 'Kadın'])
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    scatter fonksiyonun s isimli parametresi noktalar için çizilen dairenin büyüklüğünü ayarlamak için kullanılmaktadır. Bu değer 
    büyütülürse daireler de büyüyecektir. Yine aslında noktalar için daire yerine marker parametresiyle başka sembollerin de 
    kullanılması sağlanabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('scatter.csv')

plt.title('Scatter Graphics')
plt.scatter(df['kilo'][df['cinsiyet'] == 'erkek'],df['boy'][df['cinsiyet'] == 'erkek'], s=10, marker='v')
plt.scatter(df['kilo'][df['cinsiyet'] == 'kadın'],df['boy'][df['cinsiyet'] == 'kadın'], s = 10, marker='o')
plt.legend(['Erkek', 'Kadın'])

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Grafikteki marker'ın iç rengi facecolor parametresiyle çizgi rengi edgecolor parametresiyle ve çizgi kalınlığı linewidth 
    parametresiyle belirlenebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('scatter.csv')

plt.title('Scatter Graphics')
plt.scatter(df['kilo'][df['cinsiyet'] == 'erkek'],df['boy'][df['cinsiyet'] == 'erkek'], s=10, marker='v')
plt.scatter(df['kilo'][df['cinsiyet'] == 'kadın'],df['boy'][df['cinsiyet'] == 'kadın'], s = 10, marker='o')
plt.legend(['Erkek', 'Kadın'])

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Bazen scatter grafiğinde bazı noktalar da bireysel biçimde belirtilmek istenebilir. Tek bir noktayı çizmek için scatter yerine 
    plot fonksiyonunu da kullanabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

plt.title('Scatter Graphics')

x = np.array([1, 5, 7, 3, 9, 12, 5, 25, 7, 19])
y = np.array([10, 21, 17, 7, 24, 21, 9, 14, 11, 1])
plt.scatter(x, y, s=150, color='blue', linewidth=3, facecolor='yellow')
plt.plot(10, 10, marker='x', markersize=14, color='red')
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    scikit-learn isimli makine öğrenmesi kütüphanesinde sklearn.datasets modülü bazı amaçlar için kullanılan çeşitli rastgele nokta 
    üretme fonksiyonları bulunmaktadır. Örneğin make_blobs isimli fonksiyon bize birbirinden kopuk k tane kümeden oluşan rastgele 
    noktalar vermektedir. Bu fonksiyon bir demete geri döner. Demetin ilk elemanı tüm noktaları barındıran bir NumPy dizisidir. 
    Demetin ikinci elemanı ise bu noktaların hangi sınıfa ait olduğunu belirten 0, 1, 2, ... biçiminde sınıf belirten sayılardab 
    oluşmaktadır. Örneğin:

    >>> from sklearn.datasets import make_blobs
    >>> dataset, labels = make_blobs(50, 2, centers=5)
    >>> dataset
    array([[-8.38325205,  3.60580764],
        [ 4.51867341,  7.4311921 ],
        [ 4.04116666, -3.35058303],
        [ 1.25720406,  6.82407607],
        [-8.25852123,  4.36493465],
        [-7.65490343,  4.29157456],
        [ 8.07471198,  5.79537231],
        [ 8.17025353,  6.93829721],
        [-5.03625673,  5.14028253],
        [-7.10139767,  5.1758152 ],
        [ 0.22094753,  6.75557295],
        [ 0.3818745 ,  6.33642333],
        [ 8.98190368,  7.69854562],
        [-6.79701411,  3.29686245],
        [ 4.9771809 ,  8.35464889],
        [-0.30454456,  2.73473828],
        [ 5.55765397,  9.95039466],
        [ 5.04037074, -4.2944478 ],
        [ 3.25879292,  7.15198822],
        [ 8.42091931,  5.92384327],
        [ 2.1723554 ,  7.36045773],
        [ 4.99566081, -3.56003277],
        [-0.26602114,  6.21918411],
        [ 4.63261427, -5.55274097],
        [-6.66265881,  2.58638149],
        [ 3.07062992, -2.94879771],
        [ 6.49231757,  6.60228816],
        [ 2.17643182,  5.62330393],
        [ 3.03590421, -2.48234133],
        [-7.33916759,  5.41487708],
        [ 6.77615268,  5.18684805],
        [ 4.36859224,  8.46921282],
        [ 4.94523652, -3.9158847 ],
        [ 2.89696602, -2.23439456],
        [ 3.23882866,  7.63115974],
        [ 4.95940036, -3.70769496],
        [ 6.48099217,  8.04609029],
        [ 2.40780885,  7.36819578],
        [ 6.63498939,  7.56139856],
        [ 1.17986973,  6.46382486],
        [ 5.57257106, -0.37931753],
        [-6.77561324,  5.36882706],
        [ 2.00467577,  6.59830384],
        [ 7.71979717,  6.97505674],
        [ 7.48557809,  5.54013869],
        [ 2.94926231,  8.79654149],
        [ 7.17755093,  6.09389411],
        [-6.88144637,  4.83986513],
        [ 7.37322699,  7.96918345],
        [ 8.47948876,  5.10220244]])
    >>> labels
    array([0, 2, 1, 4, 0, 0, 3, 3, 0, 0, 4, 4, 3, 0, 2, 4, 2, 1, 4, 3, 2, 1,
        4, 1, 0, 1, 2, 4, 1, 0, 3, 2, 1, 1, 2, 1, 3, 4, 2, 4, 1, 0, 4, 3,
        3, 2, 3, 0, 2, 3])

    Burada toplam 50 tane noktadan oluşan iki sütunlu rastgele bir veri kümesi oluşturulmuştur. Veri kümesindeki her nokta rastgele
    0, 1, 2, 3, 4 sınıflarından birine atanmıştır. Biz de örneğin her sınıf için ayrı bir renkle saçılma grafiğini şöyle çizdirebiliriz:

    plt.title('Scatter Graphics')
    for i in labels:
        plt.scatter(dataset[labels == i, 0], dataset[labels == i, 1])
    plt.show()
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt
from sklearn.datasets import make_blobs

dataset, labels = make_blobs(50, 2, centers=5)

plt.title('Scatter Graphics')

for i in labels:
    plt.scatter(dataset[labels == i, 0], dataset[labels == i, 1])

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    sklearn.datasets modülü içerisindeki rastgele kümesel veri üreten diğer bir fonksiyon da make_circles isimli fonksiyondur. Bu 
    fonksiyon belli sayıda rastgele değerlerden oluşan iki kümeye ayrılmış rastgele dairesel noktalar üretmektedir. Fonksiyon yine
    ikili bir demete geri dönmektedir. Demetin ilk elemanı veri kümesini, ikinci elemanı veri kümesindeki noktaların 0 ya da 1 
    biçiminde sınıflarını belirtmektedir. Fonksiyonun factor parametresi kümeler arasındaki dairesel noktaları birbirinden uzaklaştırıp
    yakınlaştırmak için, noise parametresi ise bu daireselliği belli oranlarda bozmak için kullanılmaktadır. Örneğin:

    >>> from sklearn.datasets import make_circles
    >>> dataset, labels = make_circles(50)
    >>> dataset
    array([[-0.74382119,  0.29449964],
        [ 0.5831749 ,  0.54763768],
        [-0.6472136 ,  0.4702282 ],
        [ 0.2472136 , -0.76084521],
        [ 0.87630668,  0.48175367],
        [-0.18738131, -0.98228725],
        [-0.92977649,  0.36812455],
        [ 1.        ,  0.        ],
        [-0.74382119, -0.29449964],
        [-0.9921147 ,  0.12533323],
        [ 0.96858316, -0.24868989],
        [ 0.05023242,  0.79842138],
        [ 0.53582679, -0.84432793],
        [ 0.70104534,  0.38540294],
        [-0.42577929,  0.90482705],
        [-0.34062343,  0.72386164],
        [ 0.96858316,  0.24868989],
        [ 0.77486653,  0.19895191],
        [ 0.72896863,  0.68454711],
        [-0.79369176, -0.10026659],
        [ 0.05023242, -0.79842138],
        [-0.80901699, -0.58778525],
        [ 0.87630668, -0.48175367],
        [-0.34062343, -0.72386164],
        [-0.79369176,  0.10026659],
        [ 0.06279052, -0.99802673],
        [ 0.42866144, -0.67546234],
        [-0.42577929, -0.90482705],
        [ 0.30901699,  0.95105652],
        [ 0.5831749 , -0.54763768],
        [-0.63742399,  0.77051324],
        [ 0.2472136 ,  0.76084521],
        [-0.14990505, -0.7858298 ],
        [ 0.70104534, -0.38540294],
        [-0.92977649, -0.36812455],
        [ 0.30901699, -0.95105652],
        [-0.80901699,  0.58778525],
        [ 0.53582679,  0.84432793],
        [ 0.8       ,  0.        ],
        [ 0.72896863, -0.68454711],
        [-0.14990505,  0.7858298 ],
        [-0.50993919,  0.61641059],
        [-0.18738131,  0.98228725],
        [ 0.42866144,  0.67546234],
        [-0.6472136 , -0.4702282 ],
        [-0.63742399, -0.77051324],
        [ 0.06279052,  0.99802673],
        [-0.9921147 , -0.12533323],
        [ 0.77486653, -0.19895191],
        [-0.50993919, -0.61641059]])
    >>> labels
    array([1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0,
        0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1,
        1, 0, 0, 0, 1, 1], dtype=int64)

    Biz bu rastgele kümesel noktaları saçılma grafiği ile farklı renklerde gösterebiliriz:

    dataset, labels = make_circles(50, factor=0.5, noise=0.04)

    plt.title('Scatter Graphics')
    plt.scatter(dataset[labels == 0, 0], dataset[labels == 0, 1])
    plt.scatter(dataset[labels == 1, 0], dataset[labels == 1, 1])
    plt.show()
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt
from sklearn.datasets import make_circles

dataset, labels = make_circles(50, factor=0.5, noise=0.04)

plt.title('Scatter Graphics')
plt.scatter(dataset[labels == 0, 0], dataset[labels == 0, 1])
plt.scatter(dataset[labels == 1, 0], dataset[labels == 1, 1])
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    scatter fonksiyonunun başka ayrıntı parametreleri de vardır. Bunun için Matplotlib dokümanlarına başvurabiliriniz.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Pasta dilimi grafiği çeşitli olguların bütün içerisindeki oranlarını görsel bir biçimde ifade etmek için kullanılmaktadır. Pasta 
    dilimi grafiği (pie chart) Matplotlib kütüphanesinde pie isimli fonksiyonla çizdirilmektedir. pie fonksiyonun zorunlu birinci 
    parametresi pasta dilimi olarak gösterilecek değerleri belirtmektedir. Fonksiyon kendisi bu değerlerden hareketle orantı kullanarak 
    pasta dilimlerinin büyüklerini belirlemektedir. Programcı isterse fonksiyonun labels parametresi yoluyla her bir pasta diliminin 
    anlamı için bir yazının gösterilmesini sağlayabilir. Örneğin:

    plt.title('Pie Charts')
    plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'])
    plt.show()

#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.title('Pie Charts')
plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'])
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Default durumda pasta dilimlerinin renkleri fonksiyonun kendisi tarafından belirlenmektedir. Ancak fonksiyonun colors parametresiyle 
    her pasta diliminin rengini biz ayrı ayrı belirleyebiliriz. Örneğin:

    plt.title('Pie Charts')
    plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], 
            colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'])
    plt.show()
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.title('Pie Charts')
plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], 
        colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'])
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Belli bir pasta diliminin ana pastadan kopuk biçimde gösterilmesi sık karşılaşılan bir durumdur. Bunun için fonksiyonun explode 
    parametresi kullanılmaktadır. Bu parametreye pasta dilimi sayısı kadar değer içeren dolaşılabilir bir nesne girilir. İlgili pasta 
    diliminin explode değeri 0 ise bu pasta dilimi kopuk değildir. explode değeri yükseldikte pastanın yarıçapı ile oranlı bir biçimde
    pasta dilimi kopuk gösterilmektedir. Genellikle kopukluk için 0.1 gibi 0.2 gibi değerler dilimi güzel gösteren değerlerdir. 
    Örneğin:

    plt.title('Pie Charts')
    plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], 
            colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'], explode=[0, 0, 0, 0.1, 0, 0]) 
    plt.show()
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.title('Pie Charts')
plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], 
        colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'], explode=[0, 0, 0, 0.1, 0, 0]) 
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    pie fonksiyonun autopct parametresi C'nin printf fonksiyonundaki gibi yer tutucu yazısını alır. Yer tutucular % karakteri ile 
    başlatılırlar. (Gerçekten % karakteri %% ile belirtilir). Örneğin %.2f gibi bir yazı pasta dilimlerinin yüzdesini noktadan sonra 
    iki basamak olarak göstermek için kullanılmaktadır. Örneğin:

    plt.title('Pie Charts')
    plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], 
            colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'], explode=[0, 0, 0, 0.1, 0, 0], autopct='%%%.2f') 
    plt.show()

    Burada noktadan sonra iki basamak olarak değerler pasta dilimlerinin yüzdelik biçimde görüntülenecektir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.title('Pie Charts')
plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], 
        colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'], explode=[0, 0, 0, 0.1, 0, 0], autopct='%%%.2f') 
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Default durumda pasta dilimleri ilk belirtilen dilim 0 derecede olacak biçimde saat yönünün ters yönünde konumlandırılır. Ancak 
    ilk dilimin başlangıç açısı startangle parametresi ile değiştirilebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.title('Pie Charts')
plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], 
        colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'], autopct='%%%.2f', startangle=90) 
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Pasta dilimlerindeki yazıların birtakım özellikleri textprops isimli parametreyle değiştirilebilmektedir. Bu parametre bir sözlük
    biçiminde girilir. Sözlüğün anahtarları text fonksiyonundaki yazı özelliklerini belirten parametre isimlerinin yazılarından, 
    değerleri ise onların değerlerinden oluşmaktadır. Örneğin:

    plt.title('Pie Charts')
    plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], 
            colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'], autopct='%%%.2f', 
            startangle=90, textprops={'fontsize': 8, 'fontweight': 'bold'}) 
    plt.show()
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.title('Pie Charts')
plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], 
        colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'], 
        autopct='%%%.2f', startangle=90, textprops={'fontsize': 8, 'fontweight': 'bold'}) 
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
                                            55.Ders 04/10/2025 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    shadow parametresi dilimleri hafif gölgeli göstermektedir. Özellikle explode edilmiş dilimlerde gölgeli gösterim önemli olabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

plt.title('Pie Charts')
plt.pie([3, 7, 6, 4, 9, 1], labels=['Ali', 'Veli', 'Selami', 'Ayşe', 'Fatma', 'Sacit'], 
        colors=['red', 'green', 'blue', 'magenta', 'yellow', 'brown'], autopct='%%%.2f', 
        startangle=90, textprops={'fontsize': 8, 'fontweight': 'bold'}, shadow=True) 
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    En çok kullanılan grafiklerden biri de "histogram" denilen grafiktir. İstatistikte, veri biliminde ve makine öğrenmesinde histogram 
    oldukça sık kullanılmaktadır. Histogram bir sıklık grafiğidir. Genellikle kişiler tarafından "çubuk grafiği (bar chart)" ile 
    karıştırılmaktadır. Çubuk grafiğinde çubuklar bir aralık belirtmezler. Bir olgu belirtirler. Ancak histogramda çubuklar bir aralıktaki 
    değerlerin kaç tane olduğunu yani o aralıktaki değerlerin sıklığını göstermek için kullanılmaktadır. Histogramda çubukların yükseklikleri 
    sıklık değerini, genişlikleri de aralığı belirtmektedir. Genellikle çubuklar aralarında boşluk olmadan yan yana gösterilirler. 
    Histogramın çubuk sayısı ayarlanabilmektedir. Örneğin 0 ile 100 arasında 1000 tane değer olsun. Biz bu 1000 değerin histogramını 
    çizerken çubuk sayısını 10'da tutarsak aralıklar da 10 genişlikte olur Ancak çubuk sayısını 20 yaparsak aralık genişlikleri 5 olur. 
    Histogramdaki çubuklara İngilizce "bin" de denilmektedir. 

    Histogram çizmek için hist isimli fonksiyon kullanılmaktadır. Fonksiyonun tek bir zorunlu parametresi vardır. O da x değerlerini 
    almaktadır. Fonksiyonda default çubuk sayısı 10'dur. Ancak biz bins parametresiyle bu çubuk sayısını değiştirebiliriz. Fonksiyon 
    bizim x parametresi olarak girdiğimiz değerlerdeki en büyük ve en küçük değeri tespit eder. O iki değer arasını çubuk sayısına 
    bölerek aralıkları oluşturur. Sonra o aralıklarda kaç değer varsa çubukların yüksekliğini ona göre ayarlar. Örneğin:

    x = [47.3, 59.1, 34.8, 52.6, 63.9, 44.7, 49.8, 70.4, 39.2, 54.0,
        61.7, 56.8, 42.5, 66.9, 50.4, 33.7, 46.1, 77.2, 58.6, 48.3,
        41.9, 65.1, 53.2, 60.8, 72.5, 46.8, 43.4, 50.9, 55.6, 68.0,
        57.9, 47.1, 64.3, 35.6, 52.0, 48.8, 40.2, 73.1, 44.3, 66.0,
        59.7, 54.8, 62.5, 30.9, 71.4, 45.6, 58.1, 49.2, 67.7, 36.4,
        51.3, 63.4, 42.1, 69.8, 56.2, 38.5, 53.9, 75.6, 41.2, 47.9,
        60.1, 64.7, 50.7, 43.8, 70.9, 55.3, 46.5, 39.8, 68.6, 61.0,
        32.7, 49.5, 72.0, 44.9, 58.9, 51.6, 66.5, 37.8, 47.5, 63.0,
        53.5, 48.0, 56.9, 41.7, 71.2, 45.1, 59.4, 50.1, 62.9, 43.2,
        57.6, 34.3, 54.6, 40.8, 69.3, 64.1, 49.0, 60.4, 67.1, 52.9]

    plt.title('Histogram')
    plt.hist(x)
    plt.show()

#------------------------------------------------------------------------------------------------------------------------------------

x = [47.3, 59.1, 34.8, 52.6, 63.9, 44.7, 49.8, 70.4, 39.2, 54.0,
    61.7, 56.8, 42.5, 66.9, 50.4, 33.7, 46.1, 77.2, 58.6, 48.3,
    41.9, 65.1, 53.2, 60.8, 72.5, 46.8, 43.4, 50.9, 55.6, 68.0,
    57.9, 47.1, 64.3, 35.6, 52.0, 48.8, 40.2, 73.1, 44.3, 66.0,
    59.7, 54.8, 62.5, 30.9, 71.4, 45.6, 58.1, 49.2, 67.7, 36.4,
    51.3, 63.4, 42.1, 69.8, 56.2, 38.5, 53.9, 75.6, 41.2, 47.9,
    60.1, 64.7, 50.7, 43.8, 70.9, 55.3, 46.5, 39.8, 68.6, 61.0,
    32.7, 49.5, 72.0, 44.9, 58.9, 51.6, 66.5, 37.8, 47.5, 63.0,
    53.5, 48.0, 56.9, 41.7, 71.2, 45.1, 59.4, 50.1, 62.9, 43.2,
    57.6, 34.3, 54.6, 40.8, 69.3, 64.1, 49.0, 60.4, 67.1, 52.9]

plt.title('Histogram')
plt.hist(x)
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Örneğin biz numpy.random.normal fonksiyonuyla oratalasmı ve standart sapması verilen normal dağılıma uygun n tane rastgele sayı 
    üretebiliriz. Sonra bunların histogramını çizdiğimizde çan eğrisine benzer bir görüntüyle karşılaşırız. Gerçekten de doğada gördüğümüz 
    pek olgu aslında sıklık bakımından "normal dağılım" denilen çan eğrisine benzemektedir. Çan eğrisi ortalama etrafında çok fazla 
    değerin toplandığı ortalamadan iki yönlü uzaklaşıldığında değerlerin azaldığı bir görünümdedir. Örneğin boy, zeka, kilo gibi pek 
    çok özellik normal dağılma eğilimindedir. Yani kişilerin bu özellikleri ortalama etrafında çan eğrisinde olduğu gibi yayılmış 
    durumdadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

x = np.random.normal(0, 1, 10000)

plt.title('Histogram', fontsize=14, fontweight='bold')
plt.hist(x, bins=20)
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    hist fonksiyonun range parametresi anormal değerlerin (outliers) atılması için kullanılmaktadır. Bu parametre ikili bir demet 
    olarak girilir. Fonksiyon bu ikili demetin içinde kalan değerleri dikkate almaktadır. Örneğin:

    plt.hist(x, range=(0, 100))
    
    Yine color parametresi çubukların renklerini ayarlamak için kullanılabilmektedir. orientation parametresi default 'vertical' 
    biçimdedir. Bu parametre 'horizontal' girilirse grafik yana yatmış şekilde görüntülenir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

x = [47.3, 59.1, 34.8, 52.6, 63.9, 44.7, 49.8, 70.4, 39.2, 54.0,
 61.7, 56.8, 42.5, 66.9, 50.4, 33.7, 46.1, 77.2, 58.6, 48.3,
 41.9, 65.1, 53.2, 60.8, 72.5, 46.8, 43.4, 50.9, 55.6, 68.0,
 57.9, 47.1, 64.3, 35.6, 52.0, 48.8, 40.2, 73.1, 44.3, 66.0,
 59.7, 54.8, 62.5, 30.9, 71.4, 45.6, 58.1, 49.2, 67.7, 36.4,
 51.3, 63.4, 42.1, 69.8, 56.2, 38.5, 53.9, 75.6, 41.2, 47.9,
 60.1, 64.7, 50.7, 43.8, 70.9, 55.3, 46.5, 39.8, 68.6, 61.0,
 32.7, 49.5, 72.0, 44.9, 58.9, 51.6, 66.5, 37.8, 47.5, 63.0,
 53.5, 48.0, 56.9, 41.7, 71.2, 45.1, 59.4, 50.1, 62.9, 43.2,
 57.6, 34.3, 54.6, 40.8, 69.3, 64.1, 49.0, 60.4, 67.1, 52.9]

plt.title('Histogram')
plt.hist(x, color='red', orientation='horizontal')
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    hist fonksiyonun burada ele aldığımız özelliklerden daha fazla özellikleri vardır. Bu ayrıntılar için Matplotlib kütüphanesinin
    dokümantasyonuna başvurabilirsiniz.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar Matplotlib kütüphanesini prosedürel biçimde kullandık. Yani bağımsız fonksiyonları çağırarak grafikleri çizdik.
    Aslında bu kütüphane "nesne yönelimli" bir biçimde de yani sınıflar ve onların metotları yoluyla da kullanılabilmektedir. Matplotlib
    kütüphanesinde figür gibi eksen gibi öğeler birer sınıfla temsil edilmiştir. Biz bu sınıflar türünden nesnelerle bu sınıfların 
    metotlarını çağırarak da çizimler yapabiliriz. Genel olarak global fonksiyonlardaki xxx isminin metot karşılığı set_xxx olarak 
    verilmiştir. Tabii prosedürel teknikle nesne yönelimli teknik birlikte de kullanılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Nesne yönelimli kullanımda ilk yapılacak şey figür ve eksen nesnelerinin elde edilmesidir. Prosedürel kullanımda zaten bizim için 
    default birFigure ve  Axes nesnesi yaratılmış durumdadır. Ancak istersek biz subplots fonksiyonu ile ayrı bir figüre nesnesi ve 
    Axes nesnesi oluşturabiliriz. subplots fonksiyonu default argümanlarla çağrılırsa bize ikili bir demet biçiminde bir tane figüre 
    ve onun içerisinde de bir tane eksen nesnesi verilir. Örneğin:

    fig, ax = plt.subplots()

    Burada subplots fonksiyonu bir tane Fıgure nesnesi ve o nesnes içerisinde çizimin yapılacağı bir de Axis nesnesini bir demet
    biçiminde vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

fig, ax = plt.subplots()

#------------------------------------------------------------------------------------------------------------------------------------
    Ancak subplots fonksiyonu belli bir sayıda eksen oluşturacak biçimde de çağrılabilir. Bu durumda eksen nesneleri bir NumPy 
    dizisi olarak verilecektir. Örneğin:

    fig, ax = plt.subplots(3, 3)

    Burada artık ax 3x3'lik her elemanı Axes olan bir NumPy dizisi beelirtmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

fig, ax = plt.subplots(3, 3)

#------------------------------------------------------------------------------------------------------------------------------------
    subplots fonksiyonundan elde ettiğimiz Figure ve Axis nesneleri ile biz artık bu sınıfın metotlarını çağırarak işlemler yapabiliriz. 
    Örneğin Figure nesnesini boyutlandırmak için set_size_inches metodu kullanılmaktadır. 

    fig, ax = plt.subplots(3, 3)
    fig.set_size_inches(6, 4)

    Ya da örneğin figürün zemin rengini değiştirmek için Figure sıfının set_facecolor metodu kullanılabilir. 

    Figure sınıfının pek çok metodu vardır. Bunların listesini aşağıdaki bağlantıdan inceleyebilirsiniz:

    https://matplotlib.org/stable/api/figure_api.html
#------------------------------------------------------------------------------------------------------------------------------------

import matplotlib.pyplot as plt

fig, ax = plt.subplots(3, 3)
fig.set_size_inches(6. 4)
fig.set_facecolor('yellow')
plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Grafiğe ilişkin önemli unsurların hepsi Axes sınıfının metotları ile oluşturulmaktadır. Örneğin plot, scatter, hist, bar gibi 
    fonksiyonlar nesne yönelimli kullanımda Axes sınıfının metotları durumundadır. Örneğin legend da aslında Axes sınıfının bir 
    metoduyla çıkartılabilmektedir. Çizim sonrasında ayine show işlemi fonksiyon yoluyla yapılmalıdır. Birden falz axis nesnesiyle 
    ile çalışırken çizimde hangi hangi axis nesnesini kullanırsak çizi oraya yapmış oluruz. Örneğin:

    fig.set_size_inches(6, 6)
    fig.set_facecolor('yellow')

    ax[0, 0].set_title('Histogram', fontsize=8, fontweight='bold')
    ax[0, 0].set_xticks(np.arange(-5, 5), labels=[str(label) for label in np.arange(-5, 5)], fontsize=8)
    ax[0, 0].hist(np.random.randn(100))

    ax[0, 1].set_title('Histogram', fontsize=8, fontweight='bold')
    ax[0, 1].set_xticks(np.arange(-5, 5), labels=[str(label) for label in np.arange(-5, 5)], fontsize=8)
    ax[0, 1].hist(np.random.randn(100))

    ax[1, 0].set_title('Sinüs', fontsize=8, fontweight='bold')
    ax[1, 0].set_xticks(np.arange(-5, 5), labels=[str(label) for label in np.arange(-5, 5)], fontsize=8)
    ax[1, 0].plot(np.linspace(-6.28, 6.28, 1000), np.sin(np.linspace(-6.28, 6.28, 1000)))

    ax[1, 1].set_title('Cosinüs', fontsize=8, fontweight='bold')
    ax[1, 1].set_xticks(np.arange(-5, 5), labels=[str(label) for label in np.arange(-5, 5)], fontsize=8)
    ax[1, 1].plot(np.linspace(-6.28, 6.28, 1000), np.cos(np.linspace(-6.28, 6.28, 1000)))
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

fig, ax = plt.subplots(2, 2)

fig.set_size_inches(6, 6)
fig.set_facecolor('yellow')

ax[0, 0].set_title('Histogram', fontsize=8, fontweight='bold')
ax[0, 0].set_xticks(np.arange(-5, 5), labels=[str(label) for label in np.arange(-5, 5)], fontsize=8)
ax[0, 0].hist(np.random.randn(100))

ax[0, 1].set_title('Histogram', fontsize=8, fontweight='bold')
ax[0, 1].set_xticks(np.arange(-5, 5), labels=[str(label) for label in np.arange(-5, 5)], fontsize=8)
ax[0, 1].hist(np.random.randn(100))

ax[1, 0].set_title('Sinüs', fontsize=8, fontweight='bold')
ax[1, 0].set_xticks(np.arange(-5, 5), labels=[str(label) for label in np.arange(-5, 5)], fontsize=8)
ax[1, 0].plot(np.linspace(-6.28, 6.28, 1000), np.sin(np.linspace(-6.28, 6.28, 1000)))

ax[1, 1].set_title('Cosinüs', fontsize=8, fontweight='bold')
ax[1, 1].set_xticks(np.arange(-5, 5), labels=[str(label) for label in np.arange(-5, 5)], fontsize=8)
ax[1, 1].plot(np.linspace(-6.28, 6.28, 1000), np.cos(np.linspace(-6.28, 6.28, 1000)))

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında biz hiç subplots fonksiyonunu kullanmasak da işin başında default bir Figure nesnesi ve Axes nesnesi zaten yaratılmış 
    durumdadır. Default olarak yaratılmış olan bu Figure nesnesini elde etmek için gcf (get current figure) ve default yaratılmış 
    olan Axes nesnesini elde etmek için de gca (get current axis) fonksiyonları kullanılabilmektedir. Örneğin:

    fig = plt.gcf()
    ax = plt.gca()

    fig.set_size_inches((6, 4))
    ax.set_title('Histogram')
    ax.hist(np.random.randn(1000))
    plt.show()

#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-6, 6, 1000)
y = np.sin(x)

fig = plt.gcf()
ax = plt.gca()

fig.set_size_inches((6, 4))
ax.set_title('Sinüs')
ax.plot(x, y)
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.grid(True)

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Normal olarak Matplotlib kartezyen koordinat sistemindeki gibi birbirini kesen x ve y ekselerini oluşturmaz. Ancak çizimin koordinat 
    eksenleriyle görüntülenmesini isteyebilirsiniz. Bunun bazı işlemler yapmanız gerekir. Normal olarak bir eksenin kenarlarında dört 
    tane kenar vardır. Bu dört çizgi adeta ekseni bir kuru gibi göstermektedir. İşte bu biz yatay ve düşüy taraftaki kenarlardan ikisini 
    ortaya taşırsak ve kalan ikisini de görünmez hale getirirsek sanki kartezyen koordinat ekseni gibi bir görünrü  elde edebiliriz. 
    Bu kenarlara "spines" debilmektedir. Belli bir kenarı ortaya almak için ilgili kenarı eksen nesnesinin spines metodu ile elde edip 
    ona set_position metodunu uygulamak gerekir. Örneğin:

    ax.spines['left'].set_position('center')

    Burada biz soldaki kenarı ortaya almış olduk. Aşağı kenarı da benzer biçimade aşağıdaki gibi ortaya alabiliriz:

    ax.spines['bottom'].set_position('center')

    Maalesef bu kenarları silmenin pratik bir metodu yoktur. Silme işlemi set_color metodunun None ile çağrılmasıyşa yapılmaktadır. 
    Örneğin:

    ax.spines['right'].set_color(None)
    ax.spines['top'].set_color(None)

    Bu durumda yapılacak işlemler şunlardır:

    fig, ax = plt.subplots(1)

    ax.spines['left'].set_position('center')
    ax.spines['bottom'].set_position('center')
    ax.spines['right'].set_color(None)
    ax.spines['top'].set_color(None)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Örneğin kartezyen koordinat eksenleriyle Gauss eğrisini aşağıdaki gibi
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-6, 6, 1000)
y = np.sin(x)

fig, ax = plt.subplots(1)

ax.spines['left'].set_position('center')
ax.spines['bottom'].set_position('center')
ax.spines['right'].set_color(None)
ax.spines['top'].set_color(None)

fig.set_size_inches((6, 4))
ax.set_title('Sinüs')
ax.plot(x, y)
ax.set_xlabel('X')
ax.set_ylabel('Y')

plt.show()

import numpy as np
import matplotlib.pyplot as plt

def normal_pdf(x, mu=0, sigma=1):
    return (1/(sigma * np.sqrt(2 * np.pi))) * np.exp(-(x-mu) ** 2 / (2 * sigma ** 2))

x = np.linspace(-6, 6, 1000)
y = normal_pdf(x)

fig, ax = plt.subplots(1)

ax.spines['left'].set_position('center')
ax.spines['bottom'].set_position('center')
ax.spines['right'].set_color(None)
ax.spines['top'].set_color(None)

fig.set_size_inches((6, 4))

ax.set_title('Sinüs')
ax.set_xlim(-6, 6)
ax.set_ylim(-0.5, 0.5)

ax.plot(x, y)

ax.set_xlabel('X')
ax.set_ylabel('Y')

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Eğri altını boyamak için Axes sınıfının fill_between isimli metodu kullanılmaktadır. Bu metot aslında bize x ve y nokta çiftlerini 
    alır. Onları çizgilerle birleştirir. Örneğin:

    x = np.linspace(1, 2, 100)
    y = normal_pdf(x)
    ax.fill_between(x, y, color='gray')

    Burada x ve y noktaları arasında dikey çizgiler çizildiğii için sankio alan boyanmış gibi bir etki oluşacaktır. 
#------------------------------------------------------------------------------------------------------------------------------------

import numpy as np
import matplotlib.pyplot as plt

def normal_pdf(x, mu=0, sigma=1):
    return (1/(sigma * np.sqrt(2 * np.pi))) * np.exp(-(x-mu) ** 2 / (2 * sigma ** 2))

x = np.linspace(-6, 6, 1000)
y = normal_pdf(x)

fig, ax = plt.subplots(1)

ax.spines['left'].set_position('center')
ax.spines['bottom'].set_position('center')
ax.spines['right'].set_color(None)
ax.spines['top'].set_color(None)

fig.set_size_inches((6, 4))

ax.set_title('Sinüs')
ax.set_xlim(-6, 6)
ax.set_xticks(np.arange(-6, 6))
ax.set_ylim(-0.5, 0.5)
ax.set_yticks(np.arange(-0.5, 0.6, 0.1))
ax.plot(x, y)
x = np.linspace(1, 2, 100)
y = normal_pdf(x)
ax.fill_between(x, y, color='gray')
ax.arrow(3, 0.3, -1.5, -0.20, head_width=0.05, head_length=0.05)

ax.set_xlabel('X')
ax.set_ylabel('Y')

plt.show()

#------------------------------------------------------------------------------------------------------------------------------------
    Matplotlib aslında ayrıntıları olan bir kütüphanedir. Yapmak istediğiniz şey her neyse muhtemelen Matplotlib  içerisinde bunu 
    yapan bir fonksiyon ya da metot bulunuyor olacaktır. Bu konuda LLM'lerden faydalanarak istediğiniz işlemin nasıl yapılacağını 
    öğrenebilirsiniz. Örneğin bulduğunuz bir grafiği ChatGPT gibi bir LLM'e verip "bana bunu çizen Matplotlinb kodunu yazar mısın?" 
    gibi bir prompt girebilirsiniz. Tabii sonra onun yazdığı kod üzerinde değişikler de yapmanız gerekebilir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Thread'ler bir programın (prosesin) ayrı bir biçimde çizelgelenen farklı akışlarıdır. Bir program (proses) çalışmaya tek bir 
    thread'le başlar. Buna prograın (prosesin) ana thread'i (main thread) denilmektedir. Diğer thread'ler daha sonra programcı 
    tarafından yaratılmaktadır. Thread'ler aynı program üzerinde ilerleyen farklı akışlara denilmektedir. Thread'ler işletim sistemlerine
    90'lı yıllarda sokulmuştur. Thread kullanımının mümkün olduğu işletim sistemlerine "çok thread'li (multi-threaded)" işletim sistemleri
    denilmektedir. Windows, Linux, macOS thread kullanımının mümkün olduğu "çok thread'li (multi-threaded)" işletim sistemleridir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Modern çok prosesli ve çok thread'li işletim sistemlerinde programlar "zaman paylaşımlı (time sharing)" bir biçimde çalıştırılmaktadır. 
    İşletim sistemi thread'leri bir kuyrukta tutar. Bu kuyruğua genellikle "çalışma kuyruğu (run queue)" denilmektedir. Sonra kuyruktan 
    bir thread'i alır. Onu CPU'ya atar. O thread'in belli bir süre çalışmasını sağlar. Sonra o süre dolduğunda thread'in çalışmasına ara 
    verir. Sıraki thread'i CPU'ya atar ve çalışma "biraz onu biraz bunu" biçiminde devam ettirilir. Kullanıcılar programların aynı anda 
    çalıştığını sanırlar. Ancak aslında programlar bu biçimde kesikli kesikli çalışmaktadır. Bir thread'in CPU'ya atanıp parçalı bir biçimde 
    çalıştırılması süresine "quanta süresi (time quantum)" denilmektedir. Quanta süresini bitiren (ya da bloke olan) bir thread'in 
    CPU'dan koparılarak sıradaki thread'in CPU'ya atanması sürecine "theradler arası geçiş (context switch)" ya da "görev geçişi (task switch)" 
    denilmektedir. Quanta süreleri işletim sistemi taarafından uygun biçimde belirlenmektedir. 

    Birden fazla CPU'nun ya da çekirdeğin bulunduğu durumda zaman paylaşımlı çalışma benzer biçimde yürütülmektedir. Genellikle işletim 
    sistemleri her CPU ya da çekirdek için ayrı bir çalışma kuyruğu oluştururlar. Böylece toplamda birim zamanda yapılan iş 
    miktarı da artırılmış olur. Bu durumu süpermarketlerdeki birden fazla kasanın bulunmasına benzetebiliriz. Bazı işletim sistemleri 
    tek bir çalışma kuyruğu oluşturup bir CPU ya da çekirdekte thread'ler arası geçiş olacağı zaman o tek kuyruktan çizelgeleme yapmaktadır. 
    Bu tarzda kuyruklar yine gündelik hayatta karşımıza çıkabilmektedir. 

    İşletim sistemlerinde thread'leri CPU kuyruklarına yerleştirilmesi, CPU'ya atanması, thread'ler arası geçiş (context switch) işlemlerini
    yapan alt sisteme "çizelgeleyici (scheduler)" denilmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Python'da thread'ler konusunu ele alacağız. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir işin birden fazla akışa yaptırılması ile ilgili çeşitli terimler kullanılmaktadır. Bazen bu terimler yanlış da anlaşılabilmektedir
    Aşağıda bu terimlerin açıklamalarını yapmak istiyoruz:

    1) Concurrent Computing / Concurrency: Bir işin birden fazla akışa yaptırılmasına yönelik en genel terimdir. Bu bir şemsiye
    terim olarak düşünülebilir. 

    2) Distributed Computing: Bir işin ağ içerisindeki birden fazla bilgisayar tarafından yapılmasına denilmektedir. Burada vurgulanan
    şey işin bilgisayarlara dağıtılıp eşzamanlı biçimde yaptırılmasıdır. 

    3) Parallel Programming (Paralel Programlama): Bir işin aynı makinedeki birden fazla CPU ya da çekirdeklere dağıtılarak eş zamanlı 
    bir biçimde yaptırılma çabasına denilmektedir. Burada vurgulanan şey işin aynı makinede farklı CPU ya da çekirdeklere eş zamanlı 
    yaptırılmasıdır. 

    4) Multi-Threading Programming (Çok Thread'li Programlama): Bit işin thread'ler yoluyla aynı makinede birden fazla akışa yaptırılmasına
    ilişkin çabalara çok thread'li programlama denilmektedir. Thread'ler paralel programlama yapabilmek için de gereken unsurlardır. 
    Çok thread'li programlamada thread'lerin aynı anda birden fazla CPU ya da çekirdekte çalışması zorunlu değildir. Tek işlemcili 
    sistemlerde de çok thread'li programlama yapılabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Modern işletim sistemlerinin çoğu çok prosesli ve çok thread'li çalışmayı mümkün kılmaktadır. Windows, Linux, macOS gibi işletim 
    sistemlerinde hem birden fazla program hem de her programda birden fazla akış bulunabilmektedir. İşletim sistemlerinde çalışmakta 
    olan programlara "proses (process)" denilmektedir. Program terimi "çalıştırılabilen dosyalar için" ya da "programın kaynak kodu" 
    için kullanılan bir terimdir. Bir program çalışmaya başladığında artık ona "proses" denilmektedir. Thread ise bir prosesin 
    akışları için kullanıan bir kavramdır. Proses denildiğinde yalnızca bir akış anlaşılmaz. Proses çalışmakta olan programın 
    bütün bilgilerini temsil etmektedir. Örneğin:

    - Bellekte nerede  bulunduğu
    - Yetki derecesi
    - Açılmış dosyalar
    - Çalışma dizini
    - Kimlik bilgileri
    - Diğer pek çok bilgiler
    
    Gibi bilgiler prosese özgü bilgilerdir. Thread ise yalnızca bir akış belirtmektedir. 

    Bir proses (yani program) tek bir thread ile yaratılmaktadır. Buna porsesin "ana thread'i (main thread)" denilmektedir. Python'da
    biz bir program yukarıdna aşağıya doğru çalışır. İşte bu akış prosesin ana thread'idir. Ana thread'i programcı yaratmaz. Ana 
    thread proses yaratıldığonda otomatik yaratılmaktadır. Prosesin diğer thread'lerini programcı izleyen paragraflarda açıklayacağımız 
    gibi çeşitli fonksiyonlarla yaratıp idare etmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                                56. Ders 05/10/2025 – Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bugün yaygın biçimde kullandığımız Windows, Linux ve macOS gibi işletim sistemleri "zaman paylaşımlı (time sharing)" çalıtırm 
    yöntemini kullanmaktadır. Bu sistemlerde tek bir CPU ya da çekirdek olsa bile bu sistemler aynı anda pek çok thread'i zaman 
    paylaşımlı bir biçimde yani "biraz onu biraz bunu" biçiminde çalıştırmaktadır. Zaman paylaşımlı çalışmada işletim sisteminin 
    çalıştırma birimleri thread'lerdir. İşletim sistemi proseslerin thread'lerini ismine "çalıştırma kuyruğu (run queue)" denilen 
    bir kuyruk sisteminde tutar. Kuyruktan bir thread'i alarak CPU'ya atar. O thread belli bir süre CPU'da çalıştırılır. Bu süre 
    dolduğunda işletim sistemi thread'i CPU'dan alarak kalınan yeri kaydeder, sıradki thread'i CPU'ya atar. Yeniden çalışma sırası 
    ilgili thread'e geldiğinde o thread kaldığı yerden çalışmaya devam ettirilir. Dışarıdan bakıldığında sanki tüm programlar yani 
    thread'leri aynı anda çalışıyormuş gibi bir illüzyon oluşturulmaktadır. Aslında CPU'lar aynı tek bir thread'i çalıştırabilmektedir. 
    Ancak bu zaman paylaşımlı çalışma çok hızlı yapıldığı için "sanki dışarıdan bakıldığında bunlar aynı anda çalışıyormuş" sanılabilmektedir. 

    CPU'ya çalışan thread'in çalışmasına ara verilerek sıradaki thread'in CPU'ya atanarak çalıştırılması sürecine "bağlamsal geçiş
    (context switch)" ya da "threadler arası geçiş (task switch)" denilmektedir. Bağlamsal geçiş belli bir zaman kaybı oluşturmaktadır. 

    Bir thread'in CPU'ya atandaıktan sonra parçalı çalışma süresine "quanta süresi" ya da İngilizce "time quantum" denilmektedir. 
    Quanta süresi çok yükske tutulursa "programların aynı anda çalışıyormuş illüzyonu" bozulabilir. Kullanıcı ile etkileşim konusunda 
    sorunlar ortaya çıkabilir. Quanta süresi çok kısa tutulursa bu durumda da çok fazla thread'ler arası geçiş oluşur. Birim zamanda 
    yapılan iş miktarı (througput) azalır. Bugünkü donanımlarda çalışan Linux sistemleri oralama 60 ms., Windows sistemlerinde ise 
    ortalama 20 ms. quanta süresi kullanmaktadır. Ancak thread'lerin kullandığı quanta süreleri çeşitli koşullara bağlı olarak 
    değişebilmektedir. 

    Bu durumda programımızın iki noktası arasında geçen mutlak zaman çalışma kuyruğundaki therad'lerin sayısına bağlı değişebilmektedir. 
    Bu sistemlerde tüm thread'lerin CPU'yu paylaştığına dikkat ediniz. 

    Peki ya sistemimizde birden fazla CPU ya da çekirdek (core) varsa? Bugün kullandığımız mikroişlemcilerde aynı devre içerisine 
    "çekirdek (core)" adı altında birden fazla CPU yerleştirilmektedir. Biren fazla CPU ya da çekirdek söz konusu olduğunda zaman
    paylaşımlı çalışmada aslında değişen önemli bir nokta yoktur. Bu durumu bir yemekhanede birden fazla koladan yemek verilmesine
    benzetebiliriz. Yine kişiler kurukta bekleyecektir ancak toplamda daha az bekleyecektit. Birdne fazla CPU ya da çekirdeğin 
    bulunduğu durumda işletim sistemleri genellikle her CPU ya da çekirdek için ayrı bir çalıştırma kuyruğu oluşturmaktadır. 
    Ancak yime çalışma zaman paylaşımlı yapılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Peki bir programda birden fazla akışın yani thread'in bulunmasının nasıl bir faydası vardır? Başka bir deyişle thread'lere 
    neden gereksinim duyulmaktadır? Thread'lerin kullanılma nedenlerini maddeler halinde şöyle açıklayabiliriz:

    1) Thread'ler arka plan periyodik işlemlerin yapılabilmesi için iyi bir araç oluşturmaktadır. Örneğin bir program çalışırken aynı 
    zamanda saati ekranın bir yerine basacak olsun. Tek bir akışla bu işlemi yapmak çok zordur. Çünkü ana akış input gibi bir fonksiyona 
    girdiğinde artık saati basma imkanı kalmaz. Ana akışın input gibi bir fonksiyona girmese bile hem bir işi yaparken periyok başka 
    bir işlemi yapılması çok zordur. Halbuki çok thread'li programlamada bir thread yaratılır ve arka plan periyodik işlemler bu thread'e 
    havale edilir. Böylece programın ana akışı ilerlemeye devam eder. Ondan bağımsız bir biçimde yaratılan thread periyodik işlemleri 
    yapar. Thread'ler biribinden bağımız olarak sanki ayrı programlarmış gibi çalışmaktadır. Bir thread'in bir noktada beklemesi (teknik 
    olarak "bloke olması") diğer thread'lerin çalışmasını engellemektedir. 

    2) Thread'ler bir işi hızlandırmak için de kullanılmaktadır. Bir işi tek bir akışa yaptırmak yerine biren fazla akışa yaptırabilirsek
    o işin daha hızlı bitirilmesini saplayabiliriz. 

    3) Thread'ler "paralel programlama (parallel programming)" ortamı oluşturmak için de kullanılmaktadır. 

    4) GUI programlama modelinde bir mesaj oluştuğunda bir işlem yapmak istediğimizde o işlemi uzatmamalıyız. Aksi takdirde
    mesaj döngüsü işletilmemiş olur ve program donmuş gibi bir etki oluşur. Bu tür durumlarda bir mesaj oluştuğunda uzun süren bir 
    işlem yapılacaksa bir thread yaratılır, uzun sürecek işlem thread'e havale edilir. Eğer işlem iptal edilecekse o thread öldürülür. 
    Yani GUI programlama modelinde therad'ler bazen mecburen kullanılmaktadır. 

#------------------------------------------------------------------------------------------------------------------------------------
    Python'da thread işlemleri için standart kütüphanedeki threading modülü kullanılmaktadır. Thread yaratmak için threading modülü 
    içerisindeki Thread sınıfı kullanılmaktadır. Thread türünden bir nesne yaratılır. Bu nesne yaratılırken "target" parametresine 
    thread akışının başlatılacağı fonksiyon girlir. Ancak thread akışı thead nesnesi ile start metodunun çağrılmasıyla başlatılır. 
    (time modülünde sleep fonksiyonu hangi thread akışı tarafından çağrılmışsa yalnızca o thread'i bekletmektedir. )

    Thread sınıfının __init__ metodunun target parametresi birinci parametre değildir. Bu nedenle bu parametreyi isimli kullanmalısınız. 
    Örneğin:

    thread = threading.Thread(target=thread_proc)
    thread.start()

    Programın akışı start metodundan hemen çıkarak devam eder. Ancak yeni bir thread yaratılıp sanki bağımsız bir programmış gibi 
    o thread de zaman paylaşımlı biçimde çalıştırılır. Thread'ler belli bir fonksiyondan çalışmaya başlamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

def thread_proc():
    for i in range(10):
        print('other thread')
        time.sleep(1)

thread = threading.Thread(target=thread_proc)
thread.start()

for i in range(10):
    print('main thread')
    time.sleep(1)

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte biz thread akışının başlatılacağı fonksiyonu yukarıda yazmak zorunda kaldık. Böyle bir zorunluluğu ortadan 
    kaldırmak için thread'i yaratan kodu da başka bir fonksiyon içerisine alabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

def main():
    thread = threading.Thread(target=thread_proc)
    thread.start()
    
    for i in range(10):
        print('main thread')
        time.sleep(1)

def thread_proc(): 
    for i in range(10):
        print('other thread')
        time.sleep(1)

main()

#------------------------------------------------------------------------------------------------------------------------------------
    İşletim sistemlerinde genel olarak thread'ler arasında altlık-üstlük ilişkisi yoktur. Bir thread herhangi bir thread akışı 
    içerisinde yaratılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Thread çalışmaya başladığında thread fonksiyonuna parametre de aktarılabilmektedir. Bunun için Thread nesnesi yaratılırken
    Thread sınıfının __init__ metodunda args parametresi kullanılır. args her zaman bir demet olarak girilmektedir. Bu demetteki 
    değerler sırasıyla thread fonksiyonunun parametresine argüman olarak geçirilmektedir.Örneğin:

    thread = threading.Thread(target=thread_proc, args=(10, 20))
    thread.start()
    
    Burada thread_proc fonksiyonun iki parametresi olmalıdır. 10 değeri ilk parametreye 20 değeri de diğer parametreye aktarılarak 
    thread akışı başlatılır.
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

def main():
    thread = threading.Thread(target=thread_proc, args=('Other thread', 10))
    thread.start()
    
    for i in range(10):
        print('Main thread')
        time.sleep(1)

def thread_proc(name, count):
    for i in range(10):
        print(f'{name}: {i}')
        time.sleep(1)
        
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Thread fonksiyonuna parametre ismi belirtilerek de argüman geçilebilir. Bunun için Thread sınıfının kwargs parametresi kullanılmaktadır. 
    Bu parametreye bir sözlük nesnesi girilmelidir. Sözlüğün anahtarları parametre değişkenlerinin isimlerinden değerleri de ona 
    aktarılacak değerlerden oluşmalıdır. Tabii bu durumda thread fonksiyonunun sözlükte belirtilen isimli parametrelere sahip olması 
    gerekir. Yani args parametresi argümanları sırasıyla, kwargs parametresi ise isimli olarak aktarmaktadır. Örneğin:

    thread = threading.Thread(target=thread_proc, kwargs={'name': 'Other thread', 'count': 10})
    thread.start()

    Burada thread_proc fonksiyonun iki parametresi olmalıdır. Birinci parametre name, ikinci parametre count biçiminde isimlendirilmelidir. 

    args parametresi ile kwargs parametresi beraber de kullanılabilir. Bu duurmda önce args parametresi ile pozisyonel bir biçimde
    eşleştirme yapılır. Sonra kwargs parametresi ile isimsel eşleştirme yapılır. Ancak default değer almayan her parametre değişkeni 
    ile bir tane ve yalnızca bir tane argüman eşleştirmesi yapılmak zorundadır. Örneğin:

    thread = threading.Thread(target=thread_proc, args=('Other thread', ), kwargs={'name': 4, 'step': 1, 'stop': 20})
    thread.start()

    Burada 'Other thread' yazısı thread fonksiyonun brinci parametresine aktarılmaktadır. Diğer diğer argümanlar da isimli parametrelere 
    aktarılmaktadır. Yani siz bu durumda thread fonksiyonun aşağıdaki gibi çağrıldığını düşünebilirsiniz:

    thread_proc(*args, **kwargs)
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

def main():
    thread = threading.Thread(target=thread_proc, args=('Other thread', ), kwargs={'start': 4, 'step': 1, 'stop': 20})
    thread.start()
    
    for i in range(10):
        print(f'Main thread: {i}')
        time.sleep(1)

def thread_proc(name, start, stop, step):
    for i in range(start, stop, step):
        print(f'{name}: {i}')
        time.sleep(1)

main()

#------------------------------------------------------------------------------------------------------------------------------------
    Peki bir thread ne zaman sonlanmaktadır? Bir thread en doğal olarak thread fonksiyonunun sona ermesiyle sonlanmaktadır. Bu durum 
    zaten en fazla tavsiye edilen sonlanma biçimidir. Bir thread'in sonlanıp sonlanmadığını anlayabilmek için Thread sınıfının is_alive 
    metodu kullanılmaktadır. Aşağıdaki programda önce bu metot çağrıldığında thread sonlanmamış olacaktır. Ancak daha sonra çağrıldığında 
    thread sonlanmış olacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

def main():
    thread = threading.Thread(target=thread_proc, args=('Other thread', ))
    thread.start()
    
    print('still running' if thread.is_alive() else 'finished')
    time.sleep(10)
    print('still running' if thread.is_alive() else 'finished')
    
def thread_proc(name):
    for i in range(5):
        print(f'{name}: {i}')
        time.sleep(1)

main()

#------------------------------------------------------------------------------------------------------------------------------------
    Maalesef Python'da thread kendi akışı tarafından sonlandırılamamaktadır. (Örneğin diğer dillerdeki kütüphanelerde thread'in kendini 
    sonlandırması için exit benzeri fonksiyonlar bulunmaktadır.) Ancak bir thread'te exception oluşursa ve ele alınmazsa tüm program 
    değil yalnızca o thread yok edilmektedir. O halde kendi thread akışımızı exception yoluyla sonlandırabiliriz. Biz sonlandırmak 
    istediğimiz yerde bir exception oluştururuz. Bunu thread fonksiyonunda yakalayıp thread fonksiyonun bitmesini sağlarız. Örneğin:

    def main():
        thread = threading.Thread(target=thread_proc, args=('Other thread', ))
        thread.start()
        
        for i in range(10):
            print(f'Main thread: {i}')
            time.sleep(1)   

    def thread_proc(name):
        try:
            foo(name)
        except Exception:
            pass

    def foo(name):
        for i in range(100):
            print(f'{name}: {i}')
            if i == 5:
                raise Exception()
            time.sleep(1)

    Burada foo fonksiyonu içerisinde thread'in sonlanması için bir exception raise edilmiştir. Bu exception thread fonksiyonun içerisiden
    ele alınıp thread fonksiyonun bitmesi sağlanmıştır. Yukarıda da belirttiğimiz gibi bir thread akışında exception oluştuğunda tüm 
    program değil yalnızca o thread akışı sonlandırılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

def main():
    thread = threading.Thread(target=thread_proc, args=('Other thread', ))
    thread.start()
    
    for i in range(10):
        print(f'Main thread: {i}')
        time.sleep(1)
    
def thread_proc(name):
    try:
        foo(name)
    except Exception:
        pass

def foo(name):
    for i in range(100):
        print(f'{name}: {i}')
        if i == 5:
            raise Exception()
        time.sleep(1)
        
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir thread'i sonlandırmanın diğer bir yolu da flag değişkeni kullanmaktır. Thread bir flag değişkenine arada bir bakarak işlemini 
    yürütebilir. Thread'i sonlandırmak için bu flag değişkeni uygun biçimde set edilebilir. Tabii bu modeli uygulamak her zaman mümkün 
    değildir.  Örneğin:

    def thread_proc(name):
        i = 0
        while g_flag: 
            print(f'{name}: {i}')
            time.sleep(1)
            i += 1

    Burada g_flag global değişkeni True olduğu sürece döngü yinelenmektedir. Başka bir threda akışı bu global dğeişkeni False değerine
    çekerse döngüden çıkılır fonksiyon dolayısıyla da thread sonlanır. 
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

g_flag = True

def main():
    global g_flag 
    
    thread = threading.Thread(target=thread_proc, args=('Other thread', ))
    thread.start()
    
    for i in range(10):
        print(f'Main thread: {i}')
        if i == 5:
            g_flag = False
        time.sleep(1)
    
def thread_proc(name):
    i = 0
    while g_flag: 
        print(f'{name}: {i}')
        time.sleep(1)
        i += 1
        
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi fonksiyonların yerel değişkenleri fonksiyonun akışı o yerel değişkenin yaratıldığı noktaya geldiğinde yaratılmakta 
    akış fonksiyondan çıktığında da yok edilmektedir. Bu mekanizma "stack" denilen bir kavramla sağlanmaktadır. Yerel değişkenler 
    stack denilen alanda yaratılır. Çok thread'li sistemlerde thread'lerin stack'leri birbirinden ayrılmıştır. Her thread'in ayrı bir 
    stack alanı vardır. Birden fazla thread aynı fonksiyon üzerinde ilerliyor olsa bile her thread o fonksiyondaki yerel değişkenlerin 
    kendine özgü farklı bir kopyasını kullanıyor durumda olmaktadır. Böylece farklı thread'ler aynı fonksiyon üzerinde ilerlese bile 
    yerel değişkenleri bozmazlar. Yerel değişkenlerin her thread için adeta ayrı bir kopyası bulunmaktadır. Örneğin:

    def foo(name):
        i = 0
        while i < 10:
            print(f'{name}: {i}')
            i += 1
            time.sleep(1)

    Bradaki foo fonksiyonunu iki farklı thread çağırmış olsun. Fonksiyondaki i yerel bir değişkendir. Bu nedenle iki farklı thread'in
    i değişkeni aslında farklıdır. Thread'lerden biri bu i değişkeninde değişiklik yaptığında kendi i değişkenini değiştirmiş olur. 
    Diğer thread'teki i değişkeni bu işlemden etkilenmez. 

    Aşağıdaki programda hem ana thread hem de yeni yaratılan thread foo fonksiyonu üzerinde ilerlemektedir. Ancak bu thread'ler foo 
    içerisindeki i değişkenin farklı kopyalarını kullanıyor durumdadırlar.
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

def main():   
    thread = threading.Thread(target=thread_proc, args=('Other thread', ))
    thread.start()
    
    foo('Main thread')
       
def thread_proc(name):
       foo(name)     
       
def foo(name):
    i = 0
    while i < 10:
        print(f'{name}: {i}')
        i += 1
        time.sleep(1)
       
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Fonksiyonların yerel değişkenlerinin stack alanında yaratıldığını, her thread'in de stack alanının farklı olduğunu belirtmiştik.
    Ancak global değişkenler thread'ler tarafından ortak kullanılmaktadır. Yani iki thread aynı global değişkeni kullandığında 
    gerçekten aynı değişkeni kullanmış olurlar. Başka bir deyişle bir thread bir global değişkeni değiştirdiğinde diğer thread onu 
    değişmiş olarak görür. Yukarıda yapmış olduğumuz örnekte i değişkenini global yaparsak iki thread'in de aynı değişkeni kullandığını 
    hemen anlayabiliriz:

    i = 0

    def foo(name):
        global i
        
        while i < 10:
            print(f'{name}: {i}')
            i += 1
            time.sleep(1)
        
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

def main():   
    thread = threading.Thread(target=thread_proc, args=('Other thread', ))
    thread.start()
    
    foo('Main thread')
       
def thread_proc(name):
       foo(name)     
    
i = 0

def foo(name):
    global i
    
    while i < 10:
        print(f'{name}: {i}')
        i += 1
        time.sleep(1)
       
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda Qt'de bir mesaj oluştuğunda uzun bir işlemin thread'e devredilmesine bir örnek verilmiştir. BuradBu örnektea "Ok" düğmesine 
    basıldığında thread yaratılıp uzun süren işlem başlatılmakta "Cancel" düğmesine basıldığında ise yaratılan thread sonlandırılmaktadır. 
    Yani uzun süren işlem bir thread'e devredilip mesaj döngüsünün işletilmesi sağlanmıştır. Bu tür durumlarda thread olmadan işin 
    içindne çıkmak oldukça güçtür. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import threading
from PyQt6.QtWidgets import *

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Signal/SLot Mechanism')
                            
        self.pushButtonOk = QPushButton('Ok', self)
        self.pushButtonOk.setGeometry(10, 10, 100, 100)
        self.pushButtonOk.clicked.connect(self.pushButtonOkHandler)
        
        self.pushButtonCancel = QPushButton('Cancel', self)
        self.pushButtonCancel.setGeometry(120, 10, 100, 100)
        self.pushButtonCancel.clicked.connect(self.pushButtonCancelHandler)
        
    def pushButtonOkHandler(self):
        self.flag = False
        self.thread = threading.Thread(target=self.thread_proc)
        self.thread.start()
        
    def pushButtonCancelHandler(self):
        self.flag = True
        
    def thread_proc(self):
        print('Operation begins...')
        for i in range(1000000000):
            if self.flag:
                break
        print('Operation ends...')
       
app = QApplication(sys.argv)

mainWindow = MainWindow()
mainWindow.show()
app.exec()

#------------------------------------------------------------------------------------------------------------------------------------
    Thread oluşturmanın diğer bir yolu da Thread sınıfından türetme yapmaktır. Aslında Thread sınıfındaki start metodu run isimli metodu 
    çağırmaktadır. Bizim target parametresinde belirttiğimiz fonksiyonu aslında Thread sınıfının run metodu çağırmaktadır. O halde biz 
    Thread sınıfından bir sınıf türetip run metodunu yazarsak start metodunu çağırdığımızda bu rum metodu çalışır. Yani artık adeta 
    thread'imizin çalışmaya başladığı fonksiyon run metodu olur. Örneğin:

    class MyThread(threading.Thread):
        def __init__(self, name, count):
            super().__init__()
            self.name = name
            self.count = count
            
        def run(self):
            for i in range(self.count):
                print(f'{self.name}: {i}')
                time.sleep(1)

    Burada thread sınıfından MyThrad isimli bir sınıf türetilip o sınıfta __init__ ve run metotları yazılmıştır. Artık bu sınıf 
    türünden bir nesne yaratıp onunla start metodu çağrılırsa bu start metodu Thread sınıfındaki run metodunu değil MyThread 
    sınıfındaki run metodunu çağırır. (Taban sınıf ve türemiş sınıfta aynı isimli metotlar varsa ve çağırma türemiş sınıf türünden 
    bir nesneyle yapılıyorsa türemiş sınıftaki metodun çağrılacağını anımsayınız.) Biz artık örneğimizde MyThread türünden bir nesne      
    yaratıp onunla start metodunu çağırabiliriz:

    thread = MyThread('Other thread', 10)
    thread.start()
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

def main():   
    thread = MyThread('Other thread', 10)
    thread.start()
    
    for i in range(10):
        print(f'Main thread: {i}', i)
        time.sleep(1)
    
class MyThread(threading.Thread):
    def __init__(self, name, count):
        super().__init__()
        self.name = name
        self.count = count
        
    def run(self):
        for i in range(self.count):
            print(f'{self.name}: {i}')
            time.sleep(1)
    
main()

#------------------------------------------------------------------------------------------------------------------------------------
                                                57. Ders 12/10/2025 – Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte Thread sınıfından türetmiş olduğumuz MyThread sınıfı target parametresini Thread sınıfının __init__ metoduna geçirmektedir. 
    Ancak artık target parametresi ile belirtilen fonksiyon çağrılmayacaktır. Çünkü target parametresiyle belirtilen fonksiyonu aslında
    Thread sınıfının run metodu çağırmaktadır. Halbuki aşağıdaki örnekte Thread sınıfının run metodu değil MyThread sınıfının run metodu 
    çalıştırılmaktadır
#------------------------------------------------------------------------------------------------------------------------------------

import threading
import time

class MyThread(threading.Thread):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
    def run(self):
        for i in range(10):
            print(f'Mythread.run: {i}')
            time.sleep(1)

def main():
    mt = MyThread(target=thread_proc)
    mt.start()
   
    for i in range(10):
        print(f'Main Thread: {i}')
        time.sleep(1)
    
def thread_proc():
    for i in range(10):
        print(f'thread_proc: {i}')
        time.sleep(1)
    
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii türetme yapıp yine target parametresi yoluyla belirlediğimiz bir fonksiyonun thread fonksiyonu olmasını sağlayabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import threading
import time

class MyThread(threading.Thread):
    def __init__(self, text, **kwargs):
        super().__init__(**kwargs)
        self.text = text
             
def thread_proc():
    for i in range(10):
        print('Other thread')
        time.sleep(1)
    
mt = MyThread('Other thread', target=thread_proc)
mt.start()
for i in range(10):
    print('Main thread')
    time.sleep(1)

#------------------------------------------------------------------------------------------------------------------------------------
    Biz kendi sınıfımızdaki run metodunda da super fonksiyonu ile taban sınıfın run metodunu çağırabiliriz. Bu durumda
    target parametresi ile belirtilen fonksiyonu Thread sınıfının run metodu çağırdığına göre yine target parametresi ile belirtilen
    fonksiyon çağrılmış olacaktır. 
#------------------------------------------------------------------------------------------------------------------------------------

import threading

class MyThread(threading.Thread):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
    def run(self):
        print('thread started')
        super().run()
        
def main():
    mt = MyThread(target=foo)
    mt.start()
    
def foo():
    print('foo')
    
main()
    
#------------------------------------------------------------------------------------------------------------------------------------
    Thread sınıfının start metodunun nasıl run metodunu çağırdığı ve bunun nasıl override edildiği aşağıdaki örnekle anlaşılabilir.
#------------------------------------------------------------------------------------------------------------------------------------

class Thread:
    def __init__(self, target=None):
        self.target = target
    
    def start(self):
        self.run()
        
    def run(self):
        print('Thread.run running...')
        # new thread calls target
        if self.target:
            self.target()
    
class MyThread(Thread):
    def __init__(self, **kwargs):
        super().__init__()
            
def thread_proc():
    print('thread_proc')
    
mt = MyThread(target=thread_proc)       
mt.start()

class YourThread(Thread):
    def __init__(self):
        super().__init__()
        
    def run(self):
        print('YourThread.run running...')
        
yt = YourThread()
yt.start()

#------------------------------------------------------------------------------------------------------------------------------------
    Bazen bir thread diğer bir thread sonlanana kadar onu beklemek isteyebilir. Örneğin bir thread bir şeyler yapmaktadır. O şeyleri 
    bitirince thread de sona ermektedir. O halde diğer thread o şeyler yapılana kadar beklemek isteyebilir. İşte Thread sınıfının 
    join isimli metodu ilgili thread akışı bitene kadar join metodunu çağıran thread'i blokede bekletir. (Bloke kavramı izleyen 
    paragraflarda ele alınmaktadır.) join metoduna istenirse saniye cinsinden bir "zaman aşımı (timeout)" argümanı geçirilebilmektedir. 
    Bu durumda eğer sonlanması beklenen thread bu zaman aşımına kadar sonlanmazsa join metodu beklemeyi bırakır ve akış devam eder. 
    Örneğin:

    def main():   
        thread = threading.Thread(target=thread_proc)
        thread.start()
        thread.join()
        print('main thread continues...')
        
    def thread_proc():
        for i in range(10):
            print(f'Other thread: {i}')
            time.sleep(1)
            
    main()

    Burada thread yaratılmış ve join metodu ile thread'i sonlanması beklenmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

def main():   
   thread = threading.Thread(target=thread_proc)
   thread.start()
   thread.join()
   print('main thread continues...')
    
def thread_proc():
    for i in range(10):
        print(f'Other thread: {i}')
        time.sleep(1)
        
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Peki programın ana thread'i diğer thread'lerden önce sonlanırsa ne olur? Bazı dillerde (örneğin C'de) ana thread bittiğinde 
    tüm program sonlandırıldığı için otomatik olarak diğer thread'ler de sonlandırılmaktadır. Halbuki Python'da durum böyle değildir. 
    Python'da programın ana thread'i sonlansa bile program son thread sonlanana kadar devam etmektedir. Yani Python'da program ana 
    thread sonlandığında değil son thread sonlandığında sonlanmaktadır. 

    Aşağıdaki örnekte ana thread yaratılan thread'ten daha sonlanmaktadır. Burada program bu thread'le çalışmaya devam edecek bu 
    thread sonlandığında sonlanacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

import threading
import time

def main():
    thread = threading.Thread(target=thread_proc)       
    thread.start()
    
    for i in range(5):
        print(f'Main thread: {i}')
        time.sleep(1)
    
def thread_proc():   
    for i in range(10):
        print('Other thread')
        time.sleep(1)
    
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Python'un ana gerçekleştirimi olan CPython yorumlayıcısında GIL (Global Interpreter Lock) denilen problemli bir durum vardır. 
    CPython gerçekleştirimi referans sayacı (reference counting) temelli bir çöp toplayıcı (garbage collection) mekanizması kullandığı 
    için maalesef birden fazla thread aynı anda sistem genelinde çalışamamktadır. Tek CPU'lu ya da tek çekirdekli sistemlerde zaten 
    böyle bir durum söz konusu olmaz. Ancak günümüzde bilgisayarlarımızda kullandığımız işlemcilerde artık çok sayıda çekirdek bulunmaktadır. 
    Python programımızdaki thread'ler işletim sistemi tarafından farklı çekirdeklerin kuyruklarına atanmış olsalar bile maalesef bu GIL 
    mekanizması nedeniyle gerçek anlamda aynı anda çalışma mümkün olamamaktadır. Bu da CPython gerçekleştiriminde paralel programlama 
    yapılamayacağı anlamına gelmektedir. Gerçi üçüncü parti bazı kütüphaneler bazı hilelerle bu GIL mekanizmasını bypass edebilmektedir. 
    Ancak bunun resmi bir yolu bulunmamaktadır. CPython gerçekleştiriminde çalışan programcılar bu problemi çözmeye çalışıyor olsalar 
    da henüz bir sonuca varamamışlardır. Bu GIL problemi Jython, Iron Python PyPy gibi gerçekleştirimlerde yoktur. (Örneğin siz 
    Microsoft'un Visual Studio IDE'sinde Python ile çalışıyoranız aslında IronPython kullanıyor durumda olursunuz. Bu nedenle 
    burada sözünü ettiğimiz GIL problemi sizin çaılışmanızda söz konusu olmayacaktır.)

    GIL yüzünden CPython'da çok thread'li programlama maalesef önemli bir yara almıştır. Biz CPython gerçekleştiriminde programımızda 
    ne kadar çok thread kullanırsak kullanalım. Bu thread'ler işletim sistemi tarafından farklı CPU ya da çekirdeklerin kuyruklarına 
    atanmış olsalar bile aynı anda çalışamamaktadır. GIL problemi yüzünden çok sayıda thread farklı çekirdekler tarafından aynı anda 
    çalıştırılamadığından çok tread'li programların performansları umulduğu kadar yüksek olmamaktadır.

    Özetle CPython yorumlayıcısı adeta sanki makinemizde tek bir işlemci varmış gibi çalışmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki program CPython gerçekleştirimi ile çalıştırıldığında tek thread'li kod yaklaşık 22 saniye, çok thread'li kod yaklaşık 
    21 saniye zaman almıştır. Ancak IronPython gerçekleştirimi ile çalıştırıldığında tek thread'li kod yaklaşık 8 saniye çok thread'li 
    kod ise yaklaşık 3 saniye zaman almıştır. Yukarıda da belirttiğimiz gibi IronPython gibi bazı Python gerçekleştirimlerinde "GIL" 
    problemi bulunmamaktadır.  
#------------------------------------------------------------------------------------------------------------------------------------

import threading
import time

def test1(): 
    t1 = time.time()
    for i in range(1000000000):
        pass
    t2 = time.time()
    print(t2 - t1)
        
test1()

def test2():
    t1 = time.time()
    
    thread1 = threading.Thread(target=thread_proc1)
    thread2 = threading.Thread(target=thread_proc2)
    thread3 = threading.Thread(target=thread_proc3)
    thread4 = threading.Thread(target=thread_proc4)
    
    thread1.start()
    thread2.start()
    thread3.start()
    thread4.start()
    
    thread1.join()
    thread2.join()
    thread3.join()
    thread4.join()
    
    t2 = time.time()

    print(t2 - t1)
    
def thread_proc1():
    for i in range(250000000):
        pass

def thread_proc2():
    for i in range(250000000):
        pass
    
def thread_proc3():
    for i in range(250000000):
        pass

def thread_proc4():
    for i in range(250000000):
        pass

test2()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir thread çalışırken uzun süre beklemeyi gerektiren dışsal olayı başlatmışsa işletim sistemleri böyle thread'leri geçici olarak 
    çizelgeden (run kuyruğundan) çıkartarak bekleme kuyrukları (wait queues) denilen kuyruklarda bekletmektedir. Örneğin klavyeden 
    okuma yapmak, bir dosyadan okuma yapmak, bir soketten okuma yapmak, time.sleep gibi bir fonksiyonu çağırmak bu biçimde thread'in 
    run kuyruğundan çıkartılmasına yol açarak uykuya dalmasına neden olmaktadır. Bu olayları başlatan thread'ler CPU zamanı harcamasın 
    diye çizelge run kuyruğundan çıkartılmaktadır. İşletim sistemleri uzun süre beklemeye yol açabilecek bu tür olayları arka planda 
    kendisi izlemektedir. Bu bekleme sona erdiğinde (örneğin klavyeden bir giriş yapıldığında, diskten ilgili bölüm okunduğunda, 
    network kartına bir bildi geldiğinde, time.sleep fonksiyonunda beklenen süre dolduğunda vs.) işletim sistemleri yeniden thread'leri 
    run kuyruğuna alırlar. Burada bekleme işlemini yapan thread'ler için bir sorun yoktur. Onlar zaten ilgili olay gerçekleşene kadar 
    bekleyeceklerdir. Ancak onların çizelge dışına çıkartılması boşuna CPU zamanının harcanmasını engeller. Dolayısıyla çalışma 
    performansını artırır. Örneğin sistemimizde yüzlerece thread bulunuyor olabilir. Aslında bunların büyük çoğunluğu o anda blokede 
    beklemektedir. Bu nedenle sistem sanıldığı kadar yavaşlamayacaktır. İşte dışsal olay başlatan thread'lerin geçici süre run 
    kuyruğundan çıkartılarak bekleme kuyruklartına alınmasına ilgili thread'in "bloke olması (blocking)" denilmektedir. 

    Thread'leri "CPU yoğun (CPU bound)" ve "IO yoğun (IO bound)" olmak üzere ikiye ayırabiliriz. CPU yoğun thread'ler kendisine 
    verilen quanta süresinin büyük bölümünü bloke olmadan kullanırlar. Ancak IO yoğun thread'ler kendilerine verilen quanta süresinin 
    çok azını kullanırlar. Genellikle IO yoğun thread'lerle karşılaşılmaktadır. Sistemde çok sayıda IO yoğun thread'in bulunmasının 
    bir zararı yoktur. Ancak çok sayıda CPU yoğun thread sistemde bulunursa bunlar hissedilebilir bir yavaşlık oluşturabilirler.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir therad'in yaşam döngüsü tipik olarak şöyledir: Thread yaratılır, quanta kullanmak için CPU'ya atanır. Sonra CPU'dan kopartılıp 
    sonraki quanta için çalışma kuyruğunda bekletilir. Dışsal bir olayı başlattığında ise bloke olarak çalışma kuyruğundan çıkartılır
    ve bekleme kuyruklarında bekletilir. Sonra olay gerçekleşince bekleme kuyruklarından yeniden çalışma kuyruğuna yerleştirilir. 
    Bu yaşam döngüsünü şekilsel biçimde aşağıdaki gibi ifade edebiliriz:

    Thread Yaratıldı
         
          │
          ▼
    ┌─────────┐             ┌─────────┐
    │ RUNNING │──────────>  │  READY  │
    │         │<──────────  │         │
    └────┬─┬──┘             └────▲────┘
         │ │                     │
         │ │                     │
         │ │  ┌─────────┐        │
         │ └─>│ WAITING │────────┘
         │    └─────────┘
         │
         └────▶ Thread Sonlanıyor

    Buradaki "Running" thread'in CPU'ya atandığını ve çalışmakta olduğu belirtmektedir. "Ready" ise thread'in run kuyruğunda olduğunu 
    ve çalışma sırasının kendisine gelmesini bekldiğini belirtmektedir. "Waiting" thread'in artık çalışma kuyruğunda da olmasığını 
    dışsal olayı beklemek için oradan çıkartıldığını anlatmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Thread'ler konusunun en önemli kısmını "thread senkronizasyonu" oluşturmaktadır. Thread senkronizasyonu birlikte birtakım işleri 
    yapan thread'lerin birbirlerini kimi zaman bekleyerek sorunsuz bir biçimde bir arada çalışması anlamına gelmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Thread senkronizasyonundaki en önemli kavramlardan biri "krtik kod (critical section)" denilen kavramdır. Belli bir kod parçasının 
    başından sonuna kadar tek bir thread akışı tarafından çalıştırılması gereken kod parçalarına "kritik kod" denilmektedir. 

    Kritik kodlarda kritik koda giren thread bu kod içerisinde quanta süresini doldurup kesilebilir. Ancak başka bir thread bu thread 
    çıkmadan kritik koda girmemelidir. Kritik kod başından sonuna kadar kesilmeden çalışma anlamına gelmez. Başından sonuna kadar 
    hiç thread'ler arası geçiş olmadan çalışmaya "atomik çalışma" denilmektedir. Kritik kodlara giren thread'ler quanta sürelerini 
    bitirip ya da bloke olup kesilebilirler. Ancak başka thread'ler onlar krtik koddan çıkmadan kritik koda girmemelidirler. 

    Aşağıdaki örnekte iki farklı thread aynı global değişkeni birer milyon kez artırmıştır. Ancak sonuç 2 milyon çıkmayabilecektir.
    Peki neden? İşte her ne kadar program içerisinde global değişken tek bir satırda artırılmış olsa da aslında bu işlem birkaç
    makine komutuyla yapılabilmektedir. Yani count += 1 işlemi tek bir makine komutuyla değil birkaç makine komutuyla yapılıyor olabilir. 
    İşte bu makine komutalrı arasında thread'ler arası geçiş oluşursa count sayacının değeri bozulabilir. Örneğin bu artırma işlemi
    32 bit Intel işlemcilerinde tipik olarak şöyle yapılmaktadır:

    MOV reg, count
    INC reg
    MOV count, reg

    Şimdi thread'ler arası geçişin tam aşağıdaki noktada oluştuğunu varsayalım:

    MOV reg, count
    INC reg
    ----> thread'ler arası geçiş oluşmuş olsun
    MOV count, reg

    Bu threda CPU'ya yenidne atandığında yazmaç içerisindeki değer count değerine set edilecektir. Ancak başka bir thread bu arada 
    bu count değerini artırmış olabilir. Bu durumda onun yaptığı artırımlar etki göstermeyecektir. 
#------------------------------------------------------------------------------------------------------------------------------------

import threading

count = 0

def main():
    thread1 = threading.Thread(target=thread_proc1)
    thread2 = threading.Thread(target=thread_proc2)
    
    thread1.start()
    thread2.start()
    
    thread1.join()
    thread2.join()
    
    print(count)
    
def thread_proc1():
    global count
    
    for i in range(1000000):
        count += 1

def thread_proc2():
    global count
    
    for i in range(1000000):
        count += 1
    
main()

#------------------------------------------------------------------------------------------------------------------------------------
    İki thread'in bir makineyi sırasıyla 1'den 5'e kadar konumlara soktuğunu varsayalım. Örneğin thread'lerden biri makineyi 2 numaralı  
    konuma soktuktan asonra thread'ler arası geçiş oluşup diğer thread çalıştırılırsa ve diğer thread'te bu makineyi kullanırsa makinenin 
    konumu bozulacaktır. Birinci thread yeniden kaldığı yerden çalışmaya devam ettiğinde makineyi 2 numaralı konumda sanacaktır. Ancak 
    makine artık 2 numaralı konumda değildir. Aşağıda bu örnek simüle edilmiştir. Bu örnekte aslında olması gereken şey thread'lerden 
    biri makineyi kullanmaya başladığı zaman diğerlerinin bu thread kullanımı bitirene kadar bekletilmesidir. 
#------------------------------------------------------------------------------------------------------------------------------------

import time
import random
import threading

def main():
    thread1 = threading.Thread(target=thread_proc1)
    thread2 = threading.Thread(target=thread_proc2)
    
    thread1.start()
    thread2.start()
    
    thread1.join()
    thread2.join()
        
def thread_proc1():
    for _ in range(10):
        run_machine('thread1')
        
def thread_proc2():
    for _ in range(10):
        run_machine('thread2')

def run_machine(name):
    print(f'{name}: 1. Step')
    time.sleep(random.random())
    print(f'{name}: 2. Step')
    time.sleep(random.random())
    print(f'{name}: 3. Step')
    time.sleep(random.random())
    print(f'{name}: 4. Step')
    time.sleep(random.random())
    print(f'{name}: 5. Step')
    time.sleep(random.random())
    print('-------------------------------')
    
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Kritik kodlar flag kullanılarak manuel bir biçimde oluşturulamazlar. Örneğin aşağıdaki gibi bir kritik kod oluşturulamamaktadır:

    g_flag = False
    ...

    while g_flag:
        pass
    g_flag = True
    ...
    ...             <KRİTİK KOD>
    ...
    g_flag = False
    
    Bu kodda iki önemli kusur vardır:

    1) Thread'ler arası geçiş aşağıda belirtilen noktada olursa birden fazla thread kritik koda girebilir. Yani mekanizma çalışmaz:

     g_flag = False
    ...

    while g_flag:
        pass
    ----->      DİKKAT! Bu noktada thread'ler arası geçiş oluşursa mekanizma çalışmaz!
    g_flag = True
    ...
    ...             <KRİTİK KOD>
    ...
    g_flag = False

    2) Bu kodda bekleme döngü içerisinde CPU zamanı harcanarak yapılmaktadır. Halbuki beklemenin "thread'in çalışma kuyruğundan (run queue)" 
    çıkartılarak bekleme kuyruklarına alınması biçiminde uykuya yatırılarak yapılması gerekir. 

    İşte kritik kodlar ancak işletim sisteminin sağladığı özel mekanizmalarıyla sağlanabilmektedir. Bu özel mekanizmaları kullanan 
    standart Python sınıfları vardır. 
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    Kritik kod oluşturmanın en pratik yolu threading modülündeki Lock isimli sınıfı kullanmaktır. Bu sınıf yoluyla kritik kod şöyle 
    oluşturulur:

    1) Thread'ler yaratılmadan önce global bir Lock nenesi yaratılmalıdır. (Ya da yerel düzeyde yaratılıp thread'lere parametre olarak 
    da geçirilebilir.) Örneğin:

    g_lock = threading.Lock()

    2) Kritik kod aşağıdaki gibi oluşturulur:

    g_lock.acquire()
    ...
    ...     <KRİTİK KOD>
    ...
    g_lock.release()

    Burada thread'lerin aynı lock nesnesini kullanması gerekmektedir. Bunun basit bir yolu Lock nesnesinin global düzeyde oluşturulması 
    olabilir. Diğer bir yolu da thread'lere parametre yoluyla aktarılmasıdır. 

    Thread'lerden biri lock.acquire() metodunu eğer  kilit açıksa geçer ve kilidi otomatik olarak kilitler. Başka thread'ler aynı 
    nesneyle acquire yapmak istediklerinde bloke olup kilidi almış thread'in kilidi bırakmasını beklerler. Kilidi almış olan thread 
    lock.release() ile  kilidi bırakır. Bu durumda bekleyen thread'lerden biri kilidi alır. Bekleyenlerden hangisinin kilidi alacağı 
    konusunda bir garanti verilmemektedir. (Yani ilk bekleyenin kilidi alması gibi bir granti söz konusu değildir.)

    Bir thread Lock nesnesini lock acquire metodu ile kilitlemişse başka thread release uygulasa bile kilit açılmaz. Bu durumda 
    exception (RuntimeError) Kilidin açılması kilidi alan thread'in release uygulamasıyla mümkün olmaktadır. Yani kilidin thread 
    temelinde sahipliği vardır. Hangi thread aquire yapmış ise o thread release yapabilir. 

    Aşağıdaki daha önce yapmış olduğumuz makine konumlandırma örneği Lock nesnesi ile düzeltilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import time
import random
import threading

g_lock = threading.Lock()

def main():
    thread1 = threading.Thread(target=thread_proc1)
    thread2 = threading.Thread(target=thread_proc2)
    
    thread1.start()
    thread2.start()

    thread1.join()
    thread2.join()
    
def thread_proc1():
    for _ in range(10):
        run_machine('thread1')
        
def thread_proc2():
    for _ in range(10):
        run_machine('thread2')

def run_machine(name):
    g_lock.acquire();
    print(f'{name}: 1. Step')
    time.sleep(random.random())
    print(f'{name}: 2. Step')
    time.sleep(random.random())
    print(f'{name}: 3. Step')
    time.sleep(random.random())
    print(f'{name}: 4. Step')
    time.sleep(random.random())
    print(f'{name}: 5. Step')
    time.sleep(random.random())
    print('-------------------------------')
    g_lock.release()
    
main()

#------------------------------------------------------------------------------------------------------------------------------------
    İki thread'in aynı gloıbal değişken üzerinde işlem yapması yukarıda belirtildiği gibi bir senkronizasyon sorununa yol açabilmektedir. 
    Aşağıda bu sorun Lock nesnesiyle giderilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import threading

g_lock = threading.Lock()
g_count = 0

def main():
    thread1 = threading.Thread(target=thread_proc1)       
    thread2 = threading.Thread(target=thread_proc2)       
    
    thread1.start()
    thread2.start()
    
    thread1.join()
    thread2.join()
    
    print(g_count)

def thread_proc1():
    global g_count
    
    for _ in range(1000000):
        g_lock.acquire()
        g_count += 1
        g_lock.release()

def thread_proc2():
    global g_count
    
    for _ in range(1000000):
        g_lock.acquire()
        g_count += 1
        g_lock.release()

main()

#------------------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyonun ya da metodun "thread güvenli (thread safe)" olması bu fonksiyonun ya da metodun aynı anda birden fazla thread 
    tarafından çağrılması durumunda bir sorunun oluşmaması anlamına gelmektedir. Global değişkenleri kullanmayan ve ortak kaynakları 
    kullanmayan fonksiyonlar ve meotlar genel olarak thread güvenlidir. Ancak Python programcısı olarak çok thread'li uygulamalar 
    yaparken kullandığınız kütüphanelerdeki fonksiyonların ve metotların thread güvenli olup olmadığı konusunda bilgi sahibi 
    olmalısınız. Peki foo gibi fonksiyon thread güvenli değilse ancak biz birden fazla thread'ten bu fonksiyonu çağırmak istiyorsak 
    ne olacaktır? Bu durumda programcının kendisinin her thread'te bu fonksiyonu çağırırken lock işlemi yapması gerekir. Örneğin:

    lock.acquire()
    foo()
    lock.release()
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                        58. Ders 18/10/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Python'un list gibi, dict gibi, set gibi mutable sınıfları CPython gerçekleştiriminde ve diğer gerçekleştirimlerin çoğunda (örneğin 
    IRon Python'da da) thread güvenli bir biçimde oluşturulmuştur. Yani bu gerçekleştirimlerde örneğin iki thread aynı listeye append 
    yaptığında herhangi bir bozulma söz konusu olmayacaktır. Zaten bu sınıflar yazılırken bu durum dikkate alınıp lock senkronizasyonları 
    bunların içerisinde de uygulanmıştır. Ancak Python'un resmi dokümanlarında bu built-in sınıfların bu metotlarının thread güvenliliği 
    konusunda bir garanti verilmemektedir. Bu nedenle programcının bu tür durumlarda metotları dışarıdan kilitlemesini tavsiye ederiz. 
        
    Aşağıdaki programda iki thread aynı global listeye append ile ekleme yapmaktadır. Eğer CPython gerçekleitiriminde list sınıfı 
    thread güvenli olmasaydı program çökerdi. Ancak thread güvenli olduğu için program sorunsuz çalışacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

import threading

g_a = []

def main():

    thread1 = threading.Thread(target=thread_proc1, args=(lock,))
    thread2 = threading.Thread(target=thread_proc2, args=(lock,))
    
    thread1.start()
    thread2.start()
    
    thread1.join()
    thread2.join()
    
    print(len(g_a))
     
def thread_proc1(lock):
    for i in range(1000000):
        g_a.append(i)
    
def thread_proc2(lock):
    for i in range(1000000):
        g_a.append(i)
        
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi madekmi resmi dokümantasyonlarda bu built-in sınıfların thread güvenliliği konusunda açık şeyler
    söylenmemiştir o halde aynı sınıf nesnelerinin yukarıdaki gibi kullanıldığı durumlarda aşağıdaki gibi kilitlemenin yapılması 
    tavsiye edilir.
#------------------------------------------------------------------------------------------------------------------------------------

import threading

a = []
lock = threading.Lock()

def main():
    thread1 = threading.Thread(target=thread_proc1)
    thread2 = threading.Thread(target=thread_proc2)
    
    thread1.start()
    thread2.start()
    
    thread1.join()
    thread2.join()
    print(len(a))
        
def thread_proc1():
    for i in range(100000):
        lock.acquire()
        a.insert(0, i)
        lock.release()
        
def thread_proc2():
    for i in range(100000):
        lock.acquire()
        a.insert(0, i)
        lock.release()

print('Ok')
   
main()

#------------------------------------------------------------------------------------------------------------------------------------
   Diğer bir senkronizasyon nesnesine de Event nesneleri denilmektedir. Event nesneleri belli bir olay gerçekleşene kadar bir thread'i 
   blokede bekletmek için kullanılmaktadır. Nesnenin kullanım şöyledir:

    1) Global düzeyde bir Event nesnesi yaratılır. (Ya da yerel düzeyde yaratılıp thread'lere parametre olarak da geçirilebilir.)
    2) Bekleyecek thread event nesnesinin wait metoduyla beklemeyi yapar. Bu metoda zaman aşımı parametresi (saniye cinsinde) verilebilir. 
    3) Bekleyen thread'i bekleme durumundan çıkartmak için diğer thread event nesnesi ile sınıfın set metodunu çağırır. 

    Kilit set metodu ile açıldıktan sonra artık wait işlemleri blokeye yol açmaz. Kilidi yeniden kapamak için clear metodu kullanılmalıdır. 
    Tabii diğer thread set işlemini daha önce yapmışsa wait işlemini yapan thread artık beklememektedir. 

    Event senkronizasyon nesneleri tipik olarak iki thread birlikte bir şeyi yaparken birisinin diğerinin bir işlemi bitirmesini 
    beklmesi için kullanılmaktadır. Aşağıda böyle bir örnek verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

event = threading.Event()

def main():
    thread1 = threading.Thread(target=thread_proc1)
    thread2 = threading.Thread(target=thread_proc2)
    
    thread1.start()
    thread2.start()
    
    thread1.join()
    thread2.join()
      
def thread_proc1():
   print('thread1 is waiting...')
   
   event.wait()
   
   print('Ok, thread1 resumes....')     
   for i in range(10):
       print(f'thread1: {i}')
       time.sleep(1)
       
def thread_proc2():
    for i in range(10):
        print(f'thread2: {i}')
        time.sleep(1)
        
    event.set()
    
    for i in range(10):
        print(f'thread2: {i}')
        time.sleep(1)
   
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Semaphore'lar pek çok işletim sisteminde ve framework'te bulundurulan temel senkronizasyon nesnelerinden biridir. Semaphore'lar 
    sayaçlı senkronizasyon nesneleridir. Bir kritik koda en fazla n tane thread akışının girmesini sağlamak kullanılmaktadır. (Biz 
    kritik kod tanımını "başından sonuna kadar tek bir thread akışı tarafından çalıştırılması gereken kodlar" biçiminde yapmıştık. 
    Ancak bu bağlamda da kritik kod terimi kullanılabilmektedir.)
    
    Semaphore'lar tipik olarak şöyle kullanılmaktadır:

    1) Global düzeyde bir Semaphore nesnesi yaratılır. (Ya da yerel düzeyde yaratılıp thread'lere parametre olarak da geçirilebilir.)
    Bu noktada semaphore sayacı belirtilmektedir. Burada belirtilen semaphore sayacı kritik koda en fazla kaç akışın girebileceğini 
    belirtmektedir. 
    
    Örneğin:

    g_sem = threading.Semaphore(3) 

    2) Kritik kodlar Semaphore sınıfının acquire ve release metotları arasında oluşturulmaktadır:

    sem = threading.Semaphore(3)
    ...

    sem.acquire()
    ...
    ...     <KRİTİK KOD>
    ...
    sem.release()

    3) Bir thread akışı acquire netoduna geldiğinde eğer semaphore sayacı sıfırdan büyükse geçiş yapılır ama semaphore sayacı 
    1 eksiltilir. Eğer semaphore sayacı 0 ise acquire metodu thread'i blokede bekletir. Ta ki semaphore sayacı 0'dan büyük olana 
    kadar. relese metodu ise semaphore sayacını 1 artırmaktadır. Böylece kritik koda en fazla başlangıçta belirlenen sayıda thread 
    girebilmektedir. Örneğin:

    sem.acquire()
    ...
    ...     <KRİTİK KOD>
    ...
    sem.release()

    Burada başlangıçtaki semaphore sayacının 3 olduğunu varsayalım. Bir thread acquire metoduna gelmiş olsun. Semaphore sayacı 
    0'dan büyük olduğu için thread bloke olmadan kritik koda girecektir. Ancak semaphore sayacı 1 eksiltilecektir. Başka bir 
    thread de yine acquire metodundan geçecektir. Böylece semaphore sayacı 1'e düşecektir. Başka bir thread daha acquire metodundan 
    geçtiğinde artık kritik kodda 3 thread vardır ve semaphore sayacı 0'a düşmüştür. Bundan sonra başka bir thread acquire metoduna 
    geldiğinde blokede bekleyecektir. Ta ki semaphore sayacı 0'dan büyük olana kadar. Eğer kritik koddaki thread'lerden biri release 
    metodunu çağırırsa semaphore sayacı 1 artırılır. Artık semaphore sayacı 0'dan büyük olduğu için bekleyen thread kritik koda 
    girebilir. Tabii yine semaphore sayacı 0'a düşecektir. 

    Başlangıçtaki semaphore sayacı 1 olan semaphore'lara "binary semaphore'lar" denilmektedir. Binary semaphore'lar kullanım 
    bakımından Lock nesnelerine oldukça benzemektedir. Ancak Lock nesneleri ile binary Semaphore nesneleri arasında yine de 
    bir fark vardır: Lock nesnelerinde kilit ancak kilidi alan thread tarafından açılabilir. Halbuki Semaphore'larda kilit başka 
    bir thread tarafından release metodu uygulandığında açılabilmektedir. Bu özellik de "üretici tüketici problemi" benzeri problemlerin 
    çözümünde kullanılmaktadır. 

    Peki semaphore nesnelerine neden gereksinim duyulmaktadır? İşte semaphore nesneleri tipik olarak "kaynak paylaştırmak" 
    amacıyla kullanılmaktadır. Örneğin elimizde üç tane yazıcı olsun. Biz bu üç yazıcıyı 10 tane thread'in kullanımına sunalım. Bir 
    thread yazıcıyı talep ettiğinde ona bu üç yazıcıdan birini tahsis edebiliriz. Diğer bir thread de yazıcıyı talep ettiğinde ona 
    da bir yazıcı tahsis edebiliriz. Başka bir thread yazıcıyı talep ederse ona da kalan son yazıcıyı tahsis ederiz. Artık elimizde 
    yazıcı kalmamıştır. Bu durumda yazıcı talep eden thread'lerin CPU zamanı harcamadan yazıcılardan biri boşalana kadar uykuda 
    bekletilmesi gerekir. O halde semaphore nesneleri tipik oladak "belli sayıda kaynağı çok sayıda thread'in kullanımına sunmak 
    için" kullanılmaktadır. Kaynağı talep edene boşta kaynak varsa verilir. Ancak boşta kaynak yoksa kaynağı talep eden thread 
    CPU zamanı harcamadan bekletilir. 

    Birden fazla thread semaphore sayacı 0'a düştüğünden dolayı acquire metodunda uykuya dalmış olsun. Kritik kodda bir thread 
    çıktığında ve semaphore sayacı artırıldığında hangi thread kritik koda girecektir? İşte bu tür durumlarda hangi thread'in 
    ikritik koda gireceğine yönelik bir garanti işletim sistemi tarafından verilmemektedir. İlk gelen thread'in kritik koda 
    girmesi adil bir durum olsa da bunun bir garantisi yoktur. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Daha önce yapmış olduğumuz makine simülasyonunu bu kez binary semaphore ile yapalım.
#------------------------------------------------------------------------------------------------------------------------------------

import time
import random
import threading

g_sem = threading.Semaphore(1)

def main():
    thread1 = threading.Thread(target=thread_proc1)
    thread2 = threading.Thread(target=thread_proc2)
    
    thread1.start()
    thread2.start()
    
    thread1.join()
    thread2.join()
        
def thread_proc1():
    for _ in range(10):
        run_machine('thread1')
        
def thread_proc2():
    for _ in range(10):
        run_machine('thread2')

def run_machine(name):
    g_sem.acquire();
    print(f'{name}: 1. Step')
    time.sleep(random.random())
    print(f'{name}: 2. Step')
    time.sleep(random.random())
    print(f'{name}: 3. Step')
    time.sleep(random.random())
    print(f'{name}: 4. Step')
    time.sleep(random.random())
    print(f'{name}: 5. Step')
    time.sleep(random.random())
    print('-------------------------------')
    g_sem.release()
    
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de Semaphore kullanarak kaynak paylaştırma örneği verelim. Elimizde 3 tane (NPRINTERS kadar) yazıcı olsun. Ancak 20 (NTHREADS) 
    kadar thread bu yazıcıları kullanmak için rekabet etsin. Biz bu yazıcıları bir liste içerisinde (g_printers) toplayalım. Thread'ler 
    istedikçe bu listeden pop ile onları alıp thread'lere verelim. Therad'ler yazıcıyı kullandıktan sonra anları yeniden bu listeye 
    append ile ekleyelim. Böylece bu liste boşta olan yazıcıları tutuyor olsun. Toplam 3 (NPRONTERS kadar) yazıcı olduğuna göre ve 
    bizden 20 thread yazıcı talep edeceğine göre elimizde yazıcı kalmayınca diğer thread'leri uykuda bekletmeliyiz. 
#------------------------------------------------------------------------------------------------------------------------------------

import time
import random
import threading

NTHREADS = 20
NPRINTERS = 3

class Printer:
    def __init__(self, number):
        self.number = number
        
    def use(self, name):
        print(f'{name} using printer {self.number}')
        
    def release(self, name):
        print(f'{name} releasing printer {self.number}')
        
    def __repr__(self):
        return f'Printer-{self.number}'

g_sem = threading.Semaphore(NPRINTERS)
g_printers = [Printer(i) for i in range(1, NPRINTERS + 1)]

def main():
    threads = []
    for i in range(NTHREADS):
        thread = threading.Thread(target=thread_proc, args=(f'thread-{i + 1}', ))
        threads.append(thread)
        thread.start()
        
    for thread in threads:
        thread.join()
        
def thread_proc(name):
    for _ in range(3):
        time.sleep(1/random.randint(3, 10))        
        
        print(f'{name} is waiting to get the printer')
        g_sem.acquire()
        printer = g_printers.pop(0)
        printer.use(name)
        time.sleep(1/random.randint(3, 10))        
        printer.release(name)
        g_printers.append(printer)
        g_sem.release()
        
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Üretici tüketici problemi (producer-consumer problem) gerçek hayatta en çok karşılaşılan senkronizasyon problemlerinden biridir. 
    Bu problemde bir thread döngü içeisinde bir değer elde eder. Diğer thread bir döngü içerisinde bunu alarak işler. Eğer üretici 
    thred tüketici thread'ten hızlı davranırsa tüketici thread eski bilgiyi almadan üretici thread paylaşılan alana yeni bir bilgi 
    yerleştirerek eski bilgiyi ezebilir. Benzer biçimde tüketici thread de üretici thread'ten hızlı davranırsa üretici thread yeni 
    bir bilgiyi paylaşılan alana koymadan eski bilgiyi yeniden paylaşılan alandan alabilir. Problemde bu durumun engellenmesi gerekir. 
    Yani üretici thread tüketici thread eski bilgiyi almadan paylaşılan alana yeni bilgiyi yerleştirmemeli, tüketi thread de üretici 
    thread yeni bilgiyi almdan eski bilgiyi yeniden almamalıdırç 

    Aşağıdaki örnekte üretici thread 0'dan 100'e kadar (100 dahil değil) değerleri rastgele beklemelerle paylaşılan alana (global değişkene)
    yerleştirmiş, türketici bunları oradan alarak rastgele beklemelerle işlemiş gibi yapmıştır. Bu yukarıda açıkladığımız üretici-tüketici
    problemi için bir simülasyondur. Programın bir çalışmasında tüketicinin aldığı değerler şöyledir:

    None None None 1 1 2 3 3 3 3 4 4 6 7 8 10 10 10 14 15 15 15 17 17 19 19 20 21 23 24 25 27 29 31 32 32 33 34 35 36 37 38 40 40 42 
    43 43 45 45 46 47 49 49 49 50 50 52 53 54 56 60 60 60 62 63 67 68 69 69 71 74 75 75 76 76 76 77 81 81 83 83 84 84 85 88 90 92 92 
    93 95 96 96 97 99 

    Buradan görüldüğü gibi tüketici hem bazı değerleri kaçırmış hem de bazı değerleri birden fazla kez almıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

import random
import time
import threading

g_shared = None

def main():
    producer = threading.Thread(target=producer_thread_proc)
    consumer = threading.Thread(target=consumer_thread_proc)
    
    producer.start()
    consumer.start()
    
    producer.join()
    consumer.join()
            
def producer_thread_proc():
    global g_shared
    
    i = 0
    while True:
        time.sleep(random.random() / 2)
        g_shared = i
        if i == 99:
            break
        i += 1
    
def consumer_thread_proc():
    while True:
        val = g_shared
        time.sleep(random.random() / 2)
        print(val, end = ' ')
        if val == 99:
            break
    print()
              
main()
   
#------------------------------------------------------------------------------------------------------------------------------------
    Üretici-Tüketici problemi tipik olarak semaphore nesneleriyle çözülmektedir. Çözümde üretici ve tüketici için iki ayrı semaphore 
    nesnesi yaratılır. Başlangıçta üretici semaphore'unun değeri 1 olarak, tüketici semaphore'unun değeri ise 0 olarak ayarlanır. 
    Üretici paylaşılan alana bilgi yerleştirince tüketici semaphore'unu tüketici de bilgiyi paylaşılan alandan alınca  üretici 
    semaphore'unu artırır. Problemin çözümünün "sembolik kodu (pseudo code)" şöyledir:

    g_sem_producer = threading.Semaphore(1)
    g_sem_consumer = threading.Semaphore(0)

    ÜRETİCİ

    while True:
        <bilgiyi elde et>
        g_sem_producer.acquire()
        <bilgiyi paylaşılan alana yerleştir>
        g_sem_consumer.release()

    TÜKETİCİ

    while True:
        g_sem_consumer.acquire()
        <bilgiyi paylaşılan alandan al>
        g_sem_producer.release()
        <bilgiyi kullan>
    
    Burada üreticinin tüketiciyi tüketicinin de üreticiyi blokeden kurtardığına dikkat ediniz. Adeta bir tahteravalli gibi işlemler 
    yürütülmektedir. 

    Yuukarıdaki problem aşağıdaki gibi çözülebilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import time
import random
import threading

g_sem_producer = threading.Semaphore(1)
g_sem_consumer = threading.Semaphore(0)
g_val = None

def main():
    thread_producer = threading.Thread(target=producer_thread_proc)
    thread_consumer = threading.Thread(target=consumer_thread_proc)
    
    thread_producer.start()
    thread_consumer.start()
    
    thread_producer.join()
    thread_consumer.join()
        
def producer_thread_proc():
    global g_val
    
    val = 0
    while True:
        time.sleep(random.random() % 3)
        g_sem_producer.acquire()
        g_val = val
        g_sem_consumer.release()
        if val == 99:
            break
        val += 1
        
def consumer_thread_proc():
    while True:
        g_sem_consumer.acquire()
        val = g_val
        g_sem_producer.release()
        time.sleep(random.random() % 3)
        print(val, end=' ', flush=True)
        if val == 99:
            break
    print()
        
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Peki üretici-tüketici problemi ile uğraşmaya ne gerek vardır? Neden tek bir thread değeri elde ettikten sonra kendisi işlemeyip 
    başka bir thread'in işlemesi için paylaşılan alana yazmaktadır? Bu işlemin temel amacı hız kazancı sağlamaktır. Bu sayede bir 
    thread yeni bir değeri elde ederken diğeri eş zamanlı biçimde onu işleyebilir ve böylece işlemler çok daha hızlı gerçekleştirilebilir. 
    Tabii CPyton dağıtımında GIL yüzünden birden fazla CPU ya da çekirdek aynı programın farklı thread'lerini eş zamanlı biçimde 
    çalıştıramamaktadır. Bu durumda hız kazancı umulduğu kadar olmayacaktır. Ancak diğer bazı Python gerçekleştirimlerinde GIL 
    biçiminde bir problem yoktur.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Üretici-tüketici probleminde paylaşılan alan tek elemanlık değil birden fazla elamanı içerecek bir kuyruk sistemi olursa toplam 
    bekleme miktarı azaltılır. Çünkü bu durumda üretici thread yalnızca kuyruk doluyken, tüketici thread ise yalnızca kuyruk boşken 
    bekleyecektir.

    Aşağıdaki örnekte liste kullanılarak bir kuyruk sistemi oluşturulmuştur. Bu örnekte üretici semaphore sayacının başlangıçta 1 
    değerine değil kuyruk uzunluğu değerine kurulduğuna dikkat ediniz. Aslında izleyen paragraflarda da göreceğimiz gibi zaten 
    Python'da üretici-tüketici problemi Queue isimli bir sınıfla gerçekleştirilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import time
import random
import threading

QUEUE_SIZE = 10

g_sem_producer = threading.Semaphore(QUEUE_SIZE)
g_sem_consumer = threading.Semaphore(0)
g_queue = [None] * QUEUE_SIZE
g_head = 0
g_tail = 0

def main():
    thread_producer = threading.Thread(target=producer_thread_proc)
    thread_consumer = threading.Thread(target=consumer_thread_proc)
    
    thread_producer.start()
    thread_consumer.start()
    
    thread_producer.join()
    thread_consumer.join()
        
def producer_thread_proc():
    global g_val
    global g_tail
    
    val = 0
    while True:
        time.sleep(random.random() % 3)
        g_sem_producer.acquire()
        g_queue[g_tail] = val
        g_tail += 1
        g_tail %= QUEUE_SIZE
        g_sem_consumer.release()
        if val == 99:
            break
        val += 1
        
def consumer_thread_proc():
    global g_head
    
    while True:
        g_sem_consumer.acquire()
        val = g_queue[g_head];
        g_sem_producer.release()
        g_head += 1
        g_head %= QUEUE_SIZE
        time.sleep(random.random() % 3)
        print(val, end=' ')
        if val == 99:
            break
    print()
        
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında kuyruklu üretici-tüketici problemi zaten Python Standart Kütüphanesinde hazır bir biçimde bulunmaktadır. queue modulündeki 
    Queue sınıfı bu iş için kullanılmaktadır. Sınıfın kullanımı şöyledir:

    1) queue.Queue sınıfı türünden global bir nesne yaratılır. Nesne yaratılırken kuyruk uzunluğu verilebilir. Eğer kuyruk uzunluğu 
    verilmezse kuyruk bellek yettiği müddetçe otomatik büyütülmektedir. 

    2) Üretici thread Queue sınıfının put metoduyla kuyruğa eleman ekler. Kuyruk doluysa bu metot blokeye yol açmaktadır. Yani sınıf 
    kendi içerisinde zaten semaphore nesnelerini yaratıp onları kullanarak işlemlerini yapmaktadır.

    3) Tüketici thread kuyruktan queue sınıfının get metoduyla eleman alır. Kuyruk boşsa bu metot blokeye yol açmaktadır.

    Queue sınıfı birden çok üretici ve birden tüketici olması durumunda da çalışmaktadır. Örneğin 10 farklı thread aynı kuyruğa 
    yazarken 5 farklı thread aynı kuyruktan okuma yapabilir. 

    Yukarıdaki örneğin hazır queue.Queue sınıfı ile gerçekleştirimi aşağıdaki verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import time
import random
import threading
import queue

g_queue = queue.Queue(10)

def main():
    thread_producer = threading.Thread(target=producer_thread_proc)
    thread_consumer = threading.Thread(target=consumer_thread_proc)
    
    thread_producer.start()
    thread_consumer.start()
    
    thread_producer.join()
    thread_consumer.join()
        
def producer_thread_proc():
    val = 0
    while True:
        time.sleep(random.random() / 3)
        g_queue.put(val)
        if val == 99:
            break
        val += 1
                  
def consumer_thread_proc():
    while True:
        val = g_queue.get()
        time.sleep(random.random() / 3)
        print(val, end=' ', flush=True)
        if val == 99:
            break
    print()
        
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında queue modülünde yine semaphore nesneleriyle çalışan yani senkronize edilmiş LifoQueue ve PriorityQueue isimli iki sınıf 
    da bulunmaktadır. LIFO kuyruk sistemine "stack" de denilmektedir. Bu kuyruk sisteminde kuyruğa son yerleştirilen eleman ilk 
    alınmaktadır. LIFO kuyruk sistemiyle gerçek hayatta seyrek de olsa karşılaşılmaktadır. Örneğin asansöre binme ve inme sırası 
    LIFO sistemini çağrıştırmaktadır. Undo mekanizması LIFO kuyruk sistemiyle yapılmaktadır. LifoQueue sınıfının da yine put ve 
    get metotları vardır. Kuyruğun boş mu dolu mu olduğu bilgisi sınıfın empty metoduyla elde edilmektedir. Eğer boşsa bu metot True
    değerine, kuyruk dolaysa False değerine geri döner. 
    
    PriorityQueue denilen öncelik temelli kuyruk sistemleriyle de gerçek yaşamda karşılaşılmaktadır. Bu kuyruk sistemlerinde kuyruğa 
    yerleştirilen elemanlara birer öncelik derecesi verilir. Kuyruktan eleman alınırken alım sırası bu önceliğe göre yapılır. 
    PriorityQueue sınıfında put metoduna tipik olarak ikili bir demet biçiminde argüman girilir. Demetin ilk elemanı öncelik derecesini, 
    ikinci elemanı kuyruğa yerleştirilecek değeri belirtir. get metodu da yine ikili demet vermektedir. Python'daki PriprityQueue 
    sınıfında düşük değer yüksek öncelik belirtmektedir. put metoduna demet girmek zorunlu değildir. Fonksiyon aslında get metodunda 
    kuyruktaki elemanları min fonksiyona sokarak elde ettiği elemanı vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda LifoQueue sınıfının kullanımına bir örnek verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import queue

lifoq = queue.LifoQueue()

lifoq.put('ali')
lifoq.put('veli')
lifoq.put('selami')
lifoq.put('ayşe')
lifoq.put('fatma')

while not lifoq.empty():
    val = lifoq.get()
    print(val)

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıda PriorityQueue sınıfının kullanımına bir örnek verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import queue

pq = queue.PriorityQueue()

pq.put((7, 'Ali'))
pq.put((2, 'Veli'))
pq.put((3, 'Selami'))
pq.put((5, 'Ayşe'))
pq.put((6, 'Fatma'))
pq.put((2, 'Sacit'))

while not pq.empty():
    val = pq.get()
    print(val)

#------------------------------------------------------------------------------------------------------------------------------------
   Program terimi halk arasında "kaynak kod" anlamında ya da "çalıştırılabilen dosyalar" anlamında kullanılmaktadır. işletim sistemleri 
   dünyasında çalışmakta olan programalara "proses" denilmektedir. Bir program çalıştırıldığında işletim sistemi bir proses oluşturur 
   ve programın çalışmasını sürekli izler. Yani programlar işletim sistemlerinin kontrolü altında çalışmaktadır. 
   
   Bir program başka bir programı çalıştırabilir. Bir programın başka bir programı çalıştırması aslında yeni bir prosesin yaratılması 
   eylemidir. 

   CPython dağıtımında GIL problemi olduğu için çok thread'li uygulamalarda thread'ler birden fazla CPU ya da çekirdekte eş zamanlı 
   olarak çalıştırılamamaktadır. Bu da maalesef daha önceden de belirttiğimiz gibi Python'da thread kullanımını önemli ölçüde olumsuz 
   biçimde etkilemektedir. Normalde thread'ler yokken bir iş hızlandırma amacıyla birden fazla prosese yaptırılıyordu. Ancak thread'ler 
   bunun için çok daha iyi bir mekanizma sunmuşlardır. Fakat CPyton'daki GIL yüzünden neredeyse çok prosesli uygulamalar çok thread'li 
   uygulamalardan daha yavaş çalışır durumdadır. Özetle aslında diğer dillerde bir işin farklı prosrslere bölünerek yaptırılması farklı 
   thread'lere bölünerek yaptırılmasından çok daha yavaş sonuç vermektedir. Ancak CPython gerçekleştiriminde GIL yüzünden neredeyse 
   tersi durum daha hızlı bir çalışmaya yol açmaktadır. 
   
   Diğer dillerde bir işin proseslere yaptırılması ile thread'lere yaptırılması arasındaki performans farklılığının gerekçeleri şunlardır:

   1) Thread'ler proseslere göre daha az sistem kaynağı kullanırlar.
   2) Thread'lerin yaratılması ve yok edilmesi proseslere göre çok daha hızlı yapılmaktadır.
   3) Prosesler birbirinden izole edilmiştir. Onların haberleşmeleri thread'lerin haberleşmelerinden çok daha zordur. 
    
   Ancak yukarıda da belirttiğimiz gibi CPython gerçekletiriminde adeta ters bir durum vardır. Yani çoğu kez bir işin proseslere 
   yaptırılması GIL yüzünden thread'lere yaptırılmasından daha hızlı sonuç vermektedir. Tabii IronPython gibi gerçekleştirimlerde 
   durum böyle değildir. O gerçekleştirimlerde bir işin daha hızlı yapılması için thread'leri tercih edebilirsiniz.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir proses yaratmak için (yani bir programı çalıştırmak için) en çok başvurulan yöntem Python Stabdart Kütüphanesindeki subprocess 
    modülünde bulunan run fonksiyonunu kullanmaktır. run fonksiyonunun temel kullanımı çok basittir. Fonksiyon birinci parametresiyle 
    bizden çalıştırılacak programı ve onun komut satırı argümanlarını dolaşılabilir bir nesne biçiminde alır ve programı çalıştırır. 
    Eğer komut satırı argümanları kullanılmayacaksa birinci parametreye doğrudan çalıştırılacak programın yol ifadesi de girilebilir. 
    Örneğin:

    subprocess.run([r'c:\windows\notepad.exe', 'sample.py'])

    Burada "c:\windows\notepad.exe" programı çalıştırılmak istenir ve "sample.py" yazısı da ona komut satırı argümanı olarak 
    verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

subprocess.run(r'c:\windows\notepad.exe')

#------------------------------------------------------------------------------------------------------------------------------------
    Windows sistemlerinde çalıştırılabilen programın yol ifadesinde '\' UNIX/Linux ve macOS sistemlerinde '/' kullanılmazsa dosya 
    PATH çevre değişkeni ile belirtilen dizilerde aranır. PATH çevre değişkeni dizinlerden oluşmaktadır. Dolayısıyla biz run fonksiyonunda 
    dosyanın yol ifadesinde Windows sistemlerinde '\' karakterini UNIX/Linux sistemlerinde '/' karakterini hiç kullanmamışsak bu dosya 
    PATH çevre değişkenindeki dizinlerde sırasıyla aranacaktır. Örneğin Windows'ta kurulum sırasında zaten Windows dizini PATH çevre 
    değişkeninde bulunmaktadır. Bu durumda biz "notepad.exe" programını aşağıdaki gibi de çalıştırabilirdik:

    subprocess.run('notepad.exe')

    Yani başka bir deyişle run fonksiyonu ile bir programı çalıştırmak istediğimizde eğer program PATH dizinlerinin birinin içerisindeyse 
    onun yalnızca ismini belirtebilriz. Ancak program PATH dizinlerinin herhangi birinin içerisinde değilse onun tüm yol ifadesini 
    belirtmeliyiz. Windows sistemlerinde çalıştırılabilen dosyanın uzantısı belirtilmezse zaten otomatik olarak o isimli ".exe" 
    dosyalar aranmaktadır. Örneğin:

    subprocess.run('notepad')

    Örneğin Chrome tarayıcısını programımızın içerisinde şöyle çalıştırabiliriz:

    subprocess.run([r'C:\Program Files\Google\Chrome\Application\chrome.exe', 'csystem.org'])

    Chrome tarayıcısı komut satırı argümanıyla aldığı URL'i çalışmaya başladığında göstermeye çalışmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

subprocess.run('notepad.exe')

#------------------------------------------------------------------------------------------------------------------------------------
    Örneğin bulunduğumuz sistemde Microsoft'un Visual Studio IDE'sini aşağıdaki gibi çalıştırabiliriz:

    subprocess.run(r'C:\Program Files\Microsoft Visual Studio\2022\Community\Common7\IDE\devenv.exe')
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

subprocess.run(r'C:\Program Files\Microsoft Visual Studio\2022\Community\Common7\IDE\devenv.exe')

#------------------------------------------------------------------------------------------------------------------------------------
    Eğer çalıştırılacak programa komut satırı argümanları da verilecekse bu durumda run fonksiyonunda program ismi ve argümanları 
    dolaşılabilir bir nesne biçiminde verilmelidir. Örneğin:

    subprocess.run(['notepad.exe', 'sample.py'])                                                     
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

subprocess.run(['notepad.exe', 'sample.py'])

#------------------------------------------------------------------------------------------------------------------------------------
                                            59. Ders 19/10/2025 – Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Python programını çalıştırmak için import işlemi yapılabilir ya da built-in exec fonksiyonundan faydalanılabilir. Ancak bu 
    yöntemlerde çalıştırılan kod farklı proses tarafından çalıştırılmamaktadır. Aynı proses ve hatta aynı thread tarafından çalıştırılmaktadır. 
    Biz bir python programını subprocess.run fonksiyonu ile tıpkı komut satırında çalıştırdığımız gibi başka bir proses yaratarak 
    çalıştırabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

subprocess.run(['python', 'testprog.py'])

#------------------------------------------------------------------------------------------------------------------------------------
    Proses subprocess.run fonksiyonuyla yaratıldığında akış yaratılan alt proses sonlanmadan run fonksiyonundan çıkmaz. run fonksiyonu 
    CompletedProcess isimli bir sınıf türünden nesneyle geri dönmektedir. 

    Aşağıdaki programda Windows'ta "notepad.exe" programı çalıştırılmıştır. Bu "notepad.exe" programı bitmeden kodun aşağıya
    geçmediğine dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

print('begins...')
cp = subprocess.run(['notepad.exe'])
print('ends...')

#------------------------------------------------------------------------------------------------------------------------------------
    ComplededProcess sınıfının args örnek özniteliği bizim run fonksiyonuna geçtiğimiz birinci parametreyi (yani program ismini 
    ve komut satırı argümanlarını)  bir liste biçiminde vermektedir. Sınıfın returncode isimli örnek özniteliği ise çalıştırılan 
    prosesin "exit kodunu" bize verir. Proseslerin bir tamsayı olan exit kodları vardır. Bu exit kodları proses bittiğinde işletim 
    sistemine iletilir. İşletim sistemi de bu exit kodunu prosesi çalıştıran prosese verir. Exit kodları geleneksel olarak başarılı 
    sonlanmalar için 0,  başarısız sonlanmalar için sıfır dışı değerler olarak seçilmektedir.

    Aşağıdaki örnekte notepad.exe progrfamı çalıştırılmış, programın çalışması bitince onun exit kodu yazdırılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

cp = subprocess.run(['notepad.exe', 'sample.py'])
print(cp.args)
print(cp.returncode)

#------------------------------------------------------------------------------------------------------------------------------------
    Bildiğiniz gibi Python programlarında akış dosyanın sonuna geldiğinde program sonlanmaktadır. İşte bu durumda default olarak 
    python programımız 0 exit koduyla sonlanmaktadır. Biz bir Python programını herhangi bir fonksiyon içerisinde o noktada da 
    sonlandırabiliriz. Bunun için sys modülündeki exit fonksiyonu kullanılmaktadır. exit fonksiyonun int türden bir parametresi vardır. 
    Bu parametre sonlandırılan prosesin exit kodunu oluşturur. Python programımız ele alınmayan bir exception ile sonlanmışsa
    bu bir başarısızlık durumu olduğu için 1 exit koduyla proses sonladırılmaktadır.

    Aşağıdaki programda proses foo fonksiyonu içerisinde sonlandırılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

import sys

def foo():
    print('foo')
    sys.exit(0)

print('begins...')
foo()
print('ends...')

#------------------------------------------------------------------------------------------------------------------------------------
    Komut satırında bir program çalıştırıldıktan sonra son çalıştırılmış olan prgramın exit kodu alınabilir. Windows sistemlerinde 
    bu exit kodunu aşağıdaki kabuk komutuyle elde edebilirsiniz:

    echo %errorlevel%

    UNIX/Linux sistemlerinde ve macOS sistemlerinde aynı işlem şöyle yapılmaktadır:

    echo $?
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Spyder IDE'sinde sağ taraftaki komut satırı programına "IPython" denilmektedir. Aslında IPython bağımsız bir projedir. Spyder 
    IDE'sine de entegre edilmiştir. IPython'u Spyder olmadan da yükleyip komut satırından çalıştırabilirsiniz. Yükleme işlemi pip 
    programı ile aşağıdaki gibi yapılabilir:

    pip install ipython

    Son Debian dağıtımlarında "sana ortam (virtaul environment)" oluşturmadan ana Python yorumlayıcısına paket install edilmesi 
    engellenmiştir. Ancak install işlemi yine de komut satırından --break-system-packages argümanı girilerek yapılabilmektedir. 
    Örneğin:

    sudo pip install --break-system-packages ipython
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Örneğin biz Linux ve macOS sistemlerinde bir C programını derleyip çalıştıran bir Python programı yaabiliriz. Linux ve macOS 
    sistemlerinde bir C programı "gcc" isimli derleyici ile şöyle derlenmektedir:

    gcc -o <çalıştırılabilen_dosyanın_ismi> <kaynak_dosya_ismi>

    Örneğin "sample.c" programı şöyle derlenebilir:

    $ gcc -o sample sample.c

    Biz de aşağıdaki programda komut satırından girilen ".c" dosyasını derlemek için "gcc" programını çalıştırdık. Eğer derleme 
    başarılı olursa "gcc" derleyicisi 0 exit kodunu üretmektedir. Bu durumda biz de derleme sonucunda oluşmuş olan programı 
    çalıştırdık.
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess
import sys
from os.path import splitext

if len(sys.argv) != 2:
    print('wrong numnber of arguments!..')
    sys.exit(1)
path = sys.argv[1]
name, ext = splitext(path)

if ext != '.c':
    print('invalid extension')
    sys.exit(1)

cp = subprocess.run(['gcc', '-o', name, path])
if cp.returncode == 0:
    subprocess.run('./' + name)

#------------------------------------------------------------------------------------------------------------------------------------
    IPython komut satırı progranmının pek çok özelliği vardır. Örneğin hiç dışarı çıkmadan ! öneki getirerek kabuk komutlarını IPython
    içerisinden çalıştırabiliriz:

    In [8]: !dir
    Volume in drive C is Windows
    Volume Serial Number is E01C-756E

    Directory of c:\Dropbox\Shared\Kurslar\Python-App\Src\Threads

    19.10.2025  17:37    <DIR>          .
    12.10.2025  18:36    <DIR>          ..
    19.10.2025  17:29               147 sample.py
    19.10.2025  17:37                67 test.py
                2 File(s)            214 bytes
                2 Dir(s)  133,111,422,976 bytes free

    In [8]: !notepad
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Modern işletim sistemlerinde ekran, klavye gibi donanım birimleri "aygıt sürücü (device driver)" denilen modller tarafından 
    yönetilmektedir. Aygıt sürücüler birer dosya gibi kullanılırlar. Yani biz aygıt sürücüleri dosya gibi açarız. Aygıt sürücü 
    dosyasına bir şeyler yazdığımızda yazılanlar aslında aygıt sürücüye gönderilir. Aygıt sürücü gereğini yapar. Benzer biçimde 
    biz bir aygıt sürücü dosyasından okuma yaptığımızda aslında aygıt sürücü kendi yönettiği aygıttan okumayı yaparak bize vermektedir. 
    
    Programalamada ekran ve klavye sözcükleri pek kullanılmaz. Ekran yerine "stdout dosyası", klavye yerine ise "stdin dosyası" terimleri 
    kullanılmaktadır. Yukarıda da belirttiğimiz gibi ekran ve klavye birer aygıt sürücü tarafından kontrol edilmektedir. Yani stdout 
    ve stdin aslında aygıt sürücü belirtmektedir. Biz Python'da print fonksiyonu ile ekrana bir şeyler yazdırmak istediğimizde print 
    fonksiyonu yazdırılmak istenen şeyleri stdout dosyasına yani stdout aygıt sürücüsüne gönderir. Onun ekrana çıkartılması bu aygıt 
    sürücünün görevidir. Aynı şey okuma yaparken kullandığomız input fonksiyonunda da benzerdir. Biz Python'da input fonksiyonu ile 
    bir okuma yapmak istediğimizde aslında input fonksiyonu doğrudan klavyeden değil klavyeyi kontrol eden aygıt sürücüden okumayı 
    yapmaktadır. 

    İşletim sistemlerinde "IO yönlendirmesi (IO Redirection)" denilen bir olgu vardır. IO yönlendirmesi bir dosyaya yazdığını sanan
    kişilerin ya da bir dosyadan okuma yaptığını sanan kişilerin aslında başka dosyalara yazma ve başka dosyalardan okuma yapması 
    durumudur. Örneğin print fonksiyonu stdout dosyasına yazma yapar. Default durumda bu stdout dosyası terminal aygıt sürücüsüne 
    yönlendirilmiştir. Ancak biz stdout dosyasını başka bir dosyaya yönlendirirsek ekrana yazdığımız şeyler aslında yönlendirdiğimiz 
    dosyaya yazılacaktır. Örneğin:

    for i in range(100):
        print(i)

    Buradaki Python programı 0'dan 100'e kadar sayıları ekrana yazmamaktadır, stdout dosyasına yazmaktadır. stdout dosyası default 
    durumda ekran işlemlerini yapan aygıt sürücüye yönlendirilmiş durumdadır. Bu nedenle bu sayılar ekranda gözükecektir. Ancak biz 
    stdout dosyasını başka bir aygıta ya da diskteki başka bir dosyaya yönlendirebiliriz. Bu durmda bu sayılar ekrana değil o kaynağa 
    yazılacaktır. O halde "print fonksiyonu ekrana yazar" cümlesi yanlıştır. Bunun doğrusu "print fonksiyonu stdout dosyasına yazar" 
    biçimindedir. stdout dosyası ise yönlendirilebilmektedir. Aynı durum stdin dosyası için de benzerdir. 

    Windows ve UNIX/Linux sistemlerinde komut satırında stdout dosyasını bir disk dosyasına yönlendirmek için ">" sembolü kullanılır. 
    Örneğin:

    python sample.py > x.txt

    Burada artık sample.py dosyasının stdout dosyasına yazdıkları ekrana değil "x.txt" dosyasına yazılacaktır. Windows ve UNIX/Linux 
    sistemlerinde stdin dosyasını yönlendirmek için ise "<" sembolü kullanılır. Örneğin:

    python sample.py < numbers.txt

    Burada aslında "sample.py" programında input fonksiyonu stdin dosyasından okuma yapar. stdin dosyası default durumda klavyeyi 
    kontrol eden aygıt sürücüsüne yönlendirilmiş durumdadır. Ancak biz "<" sembolü ile stdin dosyasını "numbers.txt" dosyasına 
    yönlendirmiş olduk. Artık bu dosyadaki şeyleri sanki biz klavyeden girmişiz gibi bir etki oluşacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    subprocess.run fonksiyonunun stdout ve stdin parametreleri bir dosya nesnesi olarak girilirse (yani açılmış bir dosya olarak 
    girilirse) çalıştırılan programın stdout ve stdin dosyaları ilgili dosyaya yönlendirilmiş olur. Örneğin:

    with open('test.txt', 'w') as f:
        subprocess.run('./sample', stdout=f)

    Burada UNIX/Linux ve macOS sistemlerinde "sample" program çalıştırılmıştır. Ancak bu programın stdout dosyasına yazdıkları artık
    "test.txt" dosyasına yazdırılacaktır. 
    
    Aşağıdaki programda "sample.exe" programının ekrana (stdout dosyasına) yazdığı şeyler aslında "test.txt" dosyasına yazılacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

with open('test.txt', 'w') as f:
    cp = subprocess.run(['sample.exe'], stdout=f)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Tabii yukarıdaki işlem aslında bir Python programı üzerinde de uygulanabilirdi. Yani biz subprocess ile bir python programını 
    çalıştırabiliriz ve o Python programının ekrana (yani stdout dosyasına) yazdırdıklarının dosyaya yazılmasını sağlayabilirz:

    with open('test.txt', 'w') as f:
        subprocess.run(['python', 'test.py'], stdout=f)
   
#------------------------------------------------------------------------------------------------------------------------------------

# sample.py

import subprocess

with open('test.txt', 'w') as f:
    subprocess.run(['python', 'test.py'], stdout=f)
    
# test.py

print('begins...')

for i in range(100):
    print(i)
    
print('ends...')

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi stdin dosyası klavye (terminal) aygıt sürücüsü yerine başka bir dosyaya yönlendirilmişse stdin 
    dosyasından okuma yapan programlar o dosyadakileri klavyeden girilmiş gibi okurlar. Python'daki input fonksiyonu stdin dosyasından 
    okuma yapmaktadır. Örneğin:

    with open('test.txt') as f:
        subprocess.run(['python', 'test.py'], stdin=f)

    Burada "test.txt" dosyası açılmış ve stdin argümanına dosya nesnesi verilmiştir. Artık "test.py" programımın stdion dosyasından 
    (klavyeden) okudukları gerçekte "test.txt" dosyasından okunavaktır.

    Aşağıdaki örnekte biz çalıştırdığımız python programının stdin dosyasını test.txt dosyasına yönlendirdik.
#------------------------------------------------------------------------------------------------------------------------------------

# sample.py

import subprocess

import subprocess

with open('test.txt') as f:
    subprocess.run(['python', 'test.py'], stdin=f)

# test.py

a = int(input())
b = int(input())

c = a + b
print(c)

# test.txt

10
20

#------------------------------------------------------------------------------------------------------------------------------------
    Spyder IDE'sinde biz subprocess.run ile bir programı çalıştırdığımızda maalesef o programın stdout dosyasına yazdığı şeyler 
    IPython konsolunda gözükmemektedir. Ancak PyCharm IDE'sinde böyle bir sorun yoktur. Bu nedenle bu tür denemelerin bazılarını 
    IPython'da ! karakteri ile sanki kabuk üzerindeymişsiniz gibi çalıştırabilirsiniz. Ya da denemelerinizi gerçekten kabuk üzerinden 
    yapabilirsiniz.  Örneğin:

    !python sample.py
    0
    1
    2
    3
    4
    5
    6
    7
    8
    9 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Artık bir bir programı çalıştıran Python programı yazabildiğimize göre IDE benzeri bir program da yazabiliriz. Örneğin bir C 
    IDE'si yazacak olalım. Bu durumda aslında menüden "Compile" seçildiğinde biz C derleyicisini çalıştırarak kodu derleyebiliriz. 
    Sonra IDE'den "Run" seçildiğinde yine biz derlenmiş programı çalıştırabiliriz. Siz de kendiniz için PyQt kullanarak basit bir 
    IDE yazmaya çalışabilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Biz daha önce os modlündeki system fonksiyonunu görmüştük. Bu fonksiyonla komut satırından yapabileceğimiz her şeyi yapıyorduk. 
    Peki bir programı çalıştırmak için os.system ile subprocess.run arasında ne farklılık vardır? Örneğin biz "gcc isimli C derleyicisini" 
    çalıştırarak ilgili C programını iki biçimde de derleyebiliriz:

     1) subprocess.run fonksiyonunu kullanarak
     
     import subprocess

    subprocess.run(['gcc.exe', '-o', 'sample.exe', 'sample.c'])

    2) os.system fonksiyonunu kullanarak:

    import os

    os.system('gcc.exe -o sample.exe sample.c')

    Bu iki fonksiyon arasındaki farklılıklar şunlardır:

    - os.system aslında kabuk programını çalıştırıp kabuk programının komutu çalıştırmasını sağlamaktadır. Halbuki subprocess.run
    doğrudan belli bir programı çalıştırmaktadır. Dolayısıyla os.system aslında toplamda program çalıştırmak için daha yavaş bir
    yöntemdir. 
      
    - os.system fonksiyonu ile komut satırında yapabilecğeimiz her şeyi yapabiliriz. Örneğin:

    os.system('ls -l | wc')

    Burada UNIX/Linux sistemlerinde komut satırından uyguladığımız boru işlemini os.system fonksiyonuna yaptırmış olduk.

    - Tabii asıl olan subprocess.run fonksiyonudur. Biz aslında os.system fonksiyonunun yaptığı şeyin aynısını kabuk programını
    çalıştırarak da yapabiliriz. Örneğin UNIX/Linux sistemlerinde os.system fonksiyonu aşağıdakine benzer yazılmıştır:

    import subprocess

    def system(cmd):
        cp = subprocess.run(['/bin/bash', '-c', cmd])
        return cp.returncode

    system('ls -l')

    UNIX/Linux ve macOS sistemlerinde kabul programları "-c" komut satırı argümanıyla çalıştırıldığında komut satırına düşülmez. 
    Kabuk programı komutu çalıştırıp hemen sonlanır. Windows'ta komut satırı programı olan "cmd.exe" de benzer biçimde "/c" komut 
    satırı argümanıyla aynı işlemi yapmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Kabuk programlarında iki komut türü vardır: İçsel (internal) komutlar ve dışsal (external) komutlar. Eğer bir komut doğurdan kabuğun 
    kendisi tarafından çalıştırılıyorsa bu tür komutlara "içsel komutlar" denilmektedir. Eğer komut kabuğun kendisi tarafından değil 
    de kabuğun çalıştırdığı bir program tarafından çalıştırılıyorsa bu tür komutlara da "dışsal (external)" komutlar denilmektedir. 
    Windows'un "cmd.exe" kabuk programında komutların çok büyük kısmı içsel komutlardır. Örneğin Windows'taki "dir" komutu bir program 
    değildir. "dir komutu "cmd.exe" programının kendisi tarafından yorumlanıp işletilmektedir. UNIX/Linux sistemlerinde ve macOS 
    sistemlerinde ise tam ters olarak kabuk komutlarının çok büyük çoğunluğu dışsal komutlardır. Örneğin bash kabuğundaki "ls" komutu 
    aslında bir programdır. Bu komut bu programın çalıştırılmasıyla yürütülmektedir. 

    Aşağıda içsel ve dışsal komutların ne olduğunu anlamaya yönelik basit bir komut yorumlayıcı örneği verilmiştir. Bu programı 
    UNIX/Linux ve Windows sistemlerinde çalıştırarak deneyiniz.
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

while True:
    cmd = input('CSD>')
    match cmd.split():
        case ['dir', *args]:
            print(f'internal command with args "{args}"')
        case ['exit', *args]:
            if len(args) != 0:
                print('too many arguments!...')
            break
        case [cmd, *args]:
            try:
                subprocess.run([cmd, *args])
            except:
                print(f'bad command: {cmd}')
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                            60. Ders 25/10/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    subprocess.run fonksiyonunda stdout parametresi özel bir değer olan subprocess.PIPE biçiminde geçilirse bu durumda çalıştırdığımız 
    programın stdout dosyasına yazdıklarını biz CompletedeProcess nesnesinin stdout örnek özniteliğinden elde edebiliriz. Buradaki 
    CompletedProcess sınıfının stdout örnek özniteliği bize bytes nesnesi vermektedir. Biz o bytes nesnesini decode metoduyla ya da 
    string sınıfının encoding parametreli __init__ metoduyla string nesnesine dönüştürebiliriz. Örneğin:
    
    cp = subprocess.run('ls', stdout = subprocess.PIPE)
    s = cp.stdout.decode()
    print(s)

    Benzer biçimde çalıştırdığımız programın stderr dosyasına yazdıklarını biz CompletedProcess sınıfının stderr örnek özniteliğinden
    elde edebiliriz. Genellikle porgramlar hata mesajlarını stderr dosyasına yazdırırlar. Örneğin biz "gcc" isimli C derleyicisini 
    çalıştırıp eğer bir hata varsa hata yazısını bu yöntemle elde edebiliriz. Bir IDE yazarken derleyici ya da yorumlayıcının 
    hata mesajlarının alınıp pencere içerisine basılması bu biçimde sağlanmaktadır. Örneğin:

    import subprocess

    cp = subprocess.run(['gcc', '-o', 'sample', 'sample.c'], stdout = subprocess.PIPE, stderr=subprocess.PIPE)
    stderr_result = cp.stderr.decode()

    print(stderr_result)

    Aağıdaki programda "sample.py" programı "mample.py" programını çalıştırmıştır. Ancak o programın ekrana yazdıklarını alıp kendi 
    ekranına yazdırmıştır. Örneğin IDE'ler aslında buradaki işlemin bir benzerini yapmaktadır. Biz bir Python IDE'sinde "programı 
    çalıştır" dediğimizde IDE python yorumlayıcısını çalıştırır, ancak onun stdout dosyasına yazdıklarını alarak kendi penceresinde 
    gösterir.
#------------------------------------------------------------------------------------------------------------------------------------

# sample.py

import subprocess

cp = subprocess.run(['python', 'mample.py'], stdout=subprocess.PIPE)
s = cp.stdout.decode()
print(s)

# mample.py

for i in range(10):
    print(i)

#------------------------------------------------------------------------------------------------------------------------------------
    Açağıda basit bir C IDE'si örneği verilmiştir. Bu IDE Windows'taki Microsoft'un C derleyicisini kullanmaktadır. Menüden "Compile"
    ve "Run" seçenekleri seçildiğinde dosya derlenip çalıştırılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import sys
import shelve
import os.path
import subprocess
from PyQt6.QtCore import *
from PyQt6.QtWidgets import *
from PyQt6.QtGui import *

CL_PATH = r'C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\bin\Hostx86\x86\cl.exe'

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.resize(800, 600)
        
        try:
            self.app_settings = shelve.open('settings', 'c')
        except:
            QMessageBox.critical(None, 'Error', 'Application settings file cannot open')
            raise
        
        pos = self.app_settings.get('pos', QPoint(100, 100))
        size = self.app_settings.get('size', QSize(800, 600))
        fullScreen = self.app_settings.get('fullScreen', False)
        wordWrap = self.app_settings.get('wordwrap', False)
        self.textColor = self.app_settings.get('textcolor', QColor(0, 0, 0))
        self.backColor = self.app_settings.get('backcolor', QColor(255, 255, 255))
                
        self.move(pos)            
        self.resize(size)
           
        self.splitter =  QSplitter(Qt.Orientation.Vertical)
        self.splitter.setHandleWidth(6)
                       
        self.textEdit = QTextEdit(self)
        self.splitter.addWidget(self.textEdit)
        
        self.textEditOutput = QTextEdit(self)
        self.textEditOutput.setFont(QFont('Segoe UI', 12))
        self.splitter.addWidget(self.textEditOutput)
        
        self.setCentralWidget(self.splitter)
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if wordWrap else QTextEdit.LineWrapMode.NoWrap)
        
        self.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()}; background-color: {self.backColor.name()}; }}')
                
        font = self.textEdit.font()
        font.setPointSize(14)
        self.textEdit.setFont(font)
                
        menuBar = self.menuBar()
        self.filePopup = QMenu('&File')
        self.editPopup = QMenu('&Edit')
        self.buildPopup = QMenu('&Build')
        self.viewPopup = QMenu('&View')
        self.optionsPopup = QMenu('&Options')
        self.helpPopup = QMenu('&Help')
        
        self.openAction = QAction('&Open...')
        self.openAction.setIcon(QIcon('MenuIcons/open.png'))
        self.openAction.setShortcut('Ctrl+O')
        self.openAction.setToolTip('Opens a file...')
        
        self.saveAction = QAction('&Save')
        self.saveAction.setIcon(QIcon('MenuIcons/save.png'))
        self.saveAction.setShortcut('Ctrl+S')
        self.saveAction.setToolTip('Saves the file...')
        
        self.saveAsAction = QAction('&Save As...')
        self.saveAsAction.setIcon(QIcon('MenuIcons/saveas.png'))
        self.saveAsAction.setShortcut('Ctrl+Shift+S')
        self.saveAsAction.setToolTip('Saves file as...')
        
        self.closeAction = QAction('&Close')
        self.closeAction.setIcon(QIcon('MenuIcons/close.png'))
        self.closeAction.setEnabled(False)
        self.closeAction.setToolTip('Closes a file...')
    
        self.openRecentPopup = QMenu('Open Recent')
        self.openRecentPopup.setToolTipsVisible(True)
        self.openRecentPopup.setToolTip('Last recently used files...')
        
        self.file1Action = QAction('A.dat')
        self.file1Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.file2Action = QAction('B.dat')
        self.file2Action.setIcon(QIcon('MenuIcons/file.png'))
        self.file3Action = QAction('C.dat')
        self.file3Action .setIcon(QIcon('MenuIcons/file.png'))
        
        self.openRecentPopup.addAction(self.file1Action)
        self.openRecentPopup.addAction(self.file2Action)
        self.openRecentPopup.addAction(self.file3Action)
        
        self.separatorAction = QAction()
        self.separatorAction.setSeparator(True)
                
        self.filePopup.setToolTipsVisible(True)
        self.exitAction = QAction('E&xit')  
        self.exitAction.setIcon(QIcon('MenuIcons/exit.png'))
        self.exitAction.setShortcut('Alt+X')
        self.exitAction.setToolTip('Exits the application...')
        
        self.filePopup.addAction(self.openAction)
        self.filePopup.addAction(self.saveAction)
        self.filePopup.addAction(self.saveAsAction)
        self.filePopup.addAction(self.closeAction)
        self.filePopup.addMenu(self.openRecentPopup)
        self.filePopup.addAction(self.separatorAction)
        self.filePopup.addAction(self.exitAction)
                
        self.cutAction = QAction('C&ut')
        self.cutAction.setIcon(QIcon('MenuIcons/cut.png'))
        self.cutAction.setShortcut('Ctrl+X')
        
        self.copyAction = QAction('&Copy')
        self.copyAction.setIcon(QIcon('MenuIcons/copy.png'))
        self.copyAction.setShortcut('Ctrl+C')
        
        self.pasteAction = QAction('&Paste')
        self.pasteAction.setIcon(QIcon('MenuIcons/paste.png'))
        self.pasteAction.setShortcut('Ctrl+V')
        
        self.editPopup.addAction(self.cutAction)
        self.editPopup.addAction(self.copyAction)
        self.editPopup.addAction(self.pasteAction)
        
        self.compileAction = QAction('&Compile')
        self.compileAction.setIcon(QIcon('MenuIcons/compile.png'))
        self.compileAction.setShortcut('Ctrl+F5')
        
        self.runAction = QAction('&Run')
        self.runAction.setIcon(QIcon('MenuIcons/run.png'))
        self.runAction.setShortcut('Ctrl+F9')
        
        self.buildPopup.addAction(self.compileAction)
        self.buildPopup.addAction(self.runAction)
                 
        self.textColorAction = QAction('&Text Color...')
        self.textColorAction.setIcon(QIcon('MenuIcons/color.png'))
        self.textColorAction.setShortcut('Ctrl+T')
        self.textColorAction.triggered.connect(self.textColorActionTriggeredHandler)
        
        self.optionsPopup.addAction(self.textColorAction)
        
        self.backColorAction = QAction('&Background Color...')
        self.backColorAction.setIcon(QIcon('MenuIcons/backcolor.png'))
        self.backColorAction.setShortcut('Ctrl+T')
        self.backColorAction.triggered.connect(self.backColorActionTriggeredHandler)
        
        self.optionsPopup.addAction(self.backColorAction)
        
        self.fontAction = QAction('&Font...')
        self.fontAction.setIcon(QIcon('MenuIcons/font.png'))
        self.fontAction.setShortcut('Ctrl+Alt+F')
        self.fontAction.triggered.connect(self.fontActionTriggeredHandler)
        
        self.optionsPopup.addAction(self.fontAction)
                
        self.themePopup = QMenu('Theme')
        self.themePopup.setIcon(QIcon('MenuIcons/Theme.png'))
                
        self.classicThemeAction = QAction('Classic')
        self.classicThemeAction.setIcon(QIcon('MenuIcons/Classic.png'))
        
        self.darkThemeAction = QAction('Dark')
        self.darkThemeAction.setIcon(QIcon('MenuIcons/Dark.png'))
        
        self.lightThemeAction = QAction('Light')
        self.lightThemeAction.setIcon(QIcon('MenuIcons/Light.png'))
        
        self.themePopup.addAction(self.classicThemeAction)
        self.themePopup.addAction(self.darkThemeAction)
        self.themePopup.addAction(self.lightThemeAction)
        
        self.viewPopup.addMenu(self.themePopup)
        
        self.viewPopup.addAction(self.separatorAction)
        self.fullScreenAction = QAction('&Full Screen')
        self.fullScreenAction.setCheckable(True)
        self.fullScreenAction.setChecked(fullScreen)
        self.fullScreenAction.setShortcut('Ctrl+Shift+F')
        self.viewPopup.addAction(self.fullScreenAction)
        
        self.viewPopup.addAction(self.separatorAction)
        self.wordWrapAction = QAction('&Word Wrap')
        self.wordWrapAction.setCheckable(True)
        self.wordWrapAction.setChecked(wordWrap)
        self.wordWrapAction.triggered.connect(self.wordWrapActionTriggeredHandler)
        self.viewPopup.addAction(self.wordWrapAction)
        
        self.aboutAction = QAction('&About')
        self.aboutAction.setIcon(QIcon('MenuIcons/about.png'))
        
        self.helpPopup.addAction(self.aboutAction)
                    
        self.openAction.triggered.connect(self.openActionTriggeredHandler)
        self.saveAction.triggered.connect(self.saveActionTriggeredHandler)
        self.saveAsAction.triggered.connect(self.saveAsActionTriggeredHandler)
        
        self.closeAction.triggered.connect(self.closeActionTriggeredHandler)
        self.exitAction.triggered.connect(self.exitActionTriggeredHandler)
        
        self.cutAction.triggered.connect(self.cutActionTriggeredHandler)
        self.copyAction.triggered.connect(self.copyActionTriggeredHandler)
        self.pasteAction.triggered.connect(self.pasteActionTriggeredHandler)
        
        self.compileAction.triggered.connect(self.compileActionTriggeredHandler)
        self.runAction.triggered.connect(self.runActionTriggeredHandler)
        
        self.fullScreenAction.triggered.connect(self.fullScreenActionTriggeredHandler)
        
        self.aboutAction.triggered.connect(self.aboutActionTriggeredHandler)
                
        menuBar.addMenu(self.filePopup)
        menuBar.addMenu(self.editPopup)
        menuBar.addMenu(self.buildPopup)
        menuBar.addMenu(self.optionsPopup)
        menuBar.addMenu(self.viewPopup)
        menuBar.addMenu(self.helpPopup)
        
        self.toolBar = QToolBar()
        self.addToolBar(self.toolBar)
        self.toolBar.setIconSize(QSize(32, 32))
        
        self.toolBar.addAction(self.openAction)
        self.toolBar.addAction(self.saveAction)
        self.toolBar.addAction(self.closeAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.copyAction)
        self.toolBar.addAction(self.cutAction)
        self.toolBar.addAction(self.pasteAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.compileAction)
        self.toolBar.addAction(self.runAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.textColorAction)
        self.toolBar.addAction(self.backColorAction)
        self.toolBar.addAction(self.fontAction)
        self.toolBar.addSeparator()
        self.toolBar.addAction(self.wordWrapAction)
                
        self.comboBoxFonts = QComboBox(self.toolBar)
        font = self.textEdit.font()
        fonts = ["Arial", "Times New Roman", "Helvetica", "Courier New", "Verdana", "Georgia", "Trebuchet MS", 
                 "Comic Sans MS", "Lucida Console", "Tahoma"]
        fonts.insert(0, font.family())
        
        self.comboBoxFonts.addItems(fonts)
        self.comboBoxFonts.setFont(QFont('Arial', 12))
        self.comboBoxFonts.currentIndexChanged.connect(self.comBoxFontsCurrentIndexChangedHandler)
        self.toolBar.addWidget(self.comboBoxFonts)
        
        self.comboBoxFontSizes = QComboBox()
        self.comboBoxFontSizes.addItems([str(size) for size in range(8, 42)])
        self.comboBoxFontSizes.setCurrentText(str(font.pointSize()))
        self.comboBoxFontSizes.currentIndexChanged.connect(self.comBoxFontSizesCurrentIndexChangedHandler)
        self.toolBar.addWidget(self.comboBoxFontSizes)
        
        self.pushButtonColorReset = QPushButton('Color Reset', self.toolBar)
        self.toolBar.addWidget(self.pushButtonColorReset)
        self.pushButtonColorReset.clicked.connect(self.pushButtonColorResetClickedHandler)
        
        self.fullScreenActionTriggeredHandler()
        self._setWindowTitle('Noname')
        
        self.setCompilerDirectories()
      
    def _setWindowTitle(self, path):
        baseName = os.path.basename(path)
        titleText = f'MyIDE - {baseName}'
        self.setWindowTitle(titleText)
        self.path = path
        
    def _saveFile(self, path):
        try:
            with open(path, 'w') as f:
                text = self.textEdit.document().toPlainText()
                f.write(text)
                self._setWindowTitle(path)
                self.textEdit.document().setModified(False)
        except Exception as e:
            QMessageBox.warning(self, 'Save Error', str(e))
           
    def openActionTriggeredHandler(self):
        if self.textEdit.document().isModified():
            result = QMessageBox.information(self, 'Warning', 'Save changes?', 
                    QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)   
            if result == QMessageBox.StandardButton.Cancel:
               return
            if result == QMessageBox.StandardButton.Yes:
                self.saveActionTriggeredHandler()
            
        fd = QFileDialog(self)
        fd.setWindowTitle('Choos a a file')
        fd.setDirectory('.')
        fd.setFileMode(QFileDialog.FileMode.ExistingFile)
        fd.setNameFilter('Text files (*.c;*.py);;All files (*.*)')

        if fd.exec() == QFileDialog.DialogCode.Accepted:
            path = fd.selectedFiles()[0]
            with open(path) as f:
                text = f.read()
                self.textEdit.setText(text)
                self._setWindowTitle(path)
                
    def saveActionTriggeredHandler(self):
        if self.path != 'Noname':
            self._saveFile(self.path)
        else:
            self.saveAsActionTriggeredHandler()
        
    def saveAsActionTriggeredHandler(self):
        path, _ = QFileDialog.getSaveFileName(self, 'Save As', '.', 'Text files (*.c;*.py);;All files (*.*)')
        if path:
            self._saveFile(path)
                                
    def closeActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Close selected')
        
    def exitActionTriggeredHandler(self):
        self.close()
        
    def cutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Cut selected')
        
    def copyActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Copy selected')
        
    def pasteActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Paste selected')
        
    def compileActionTriggeredHandler(self):
        try:
            self.saveActionTriggeredHandler()
            cp = subprocess.run([CL_PATH, self.path], env=env, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            s = cp.stderr.decode()
            s += cp.stdout.decode()
            
            self.textEditOutput.setPlainText(s)
        except Exception as e:
            QMessageBox.information(self, 'Error', str(e))
        
    def runActionTriggeredHandler(self):
        self.saveActionTriggeredHandler()
        
        exePath = os.path.splitext(self.path)[0] + '.exe'
        dt1 = os.path.getmtime(self.path)
        dt2 = os.path.getmtime(exePath)
        
        if dt1 > dt2:
            self.compileActionTriggeredHandler()  
        try:
            cp = subprocess.run(exePath, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            s = cp.stderr.decode()
            s += cp.stdout.decode()
                        
            self.textEditOutput.append(s)
            self.textEditOutput.moveCursor(QTextCursor.MoveOperation.End)
            self.textEditOutput.ensureCursorVisible()

        except Exception as e:
            QMessageBox.information(self, 'Error', str(e))
        
    def textColorActionTriggeredHandler(self):
        colorDialog = QColorDialog(self)
        colorDialog.setCurrentColor(self.textColor)
        if colorDialog.exec() == QFileDialog.DialogCode.Accepted:
            self.textColor = colorDialog.currentColor()
            self.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()}; background-color: {self.backColor.name()}; }}')
                       
    def backColorActionTriggeredHandler(self):
        colorDialog = QColorDialog(self)
        colorDialog.setCurrentColor(self.backColor)
        if colorDialog.exec() == QFileDialog.DialogCode.Accepted:
            self.backColor = colorDialog.currentColor()
            self.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()} }}; background-color: {self.backColor.name()}; }}')
            
    def fontActionTriggeredHandler(self):
        fontDialog = QFontDialog(self.textEdit.font(), self)
        if fontDialog.exec() == QDialog.DialogCode.Accepted:
            font = fontDialog.currentFont()
            self.textEdit.setFont(font)
                       
    def fullScreenActionTriggeredHandler(self):
        if  self.fullScreenAction.isChecked():
            self.normal_pos = self.pos()
            self.normal_size = self.size()    
            self.showFullScreen()
        else:
            self.showNormal()
    
    def wordWrapActionTriggeredHandler(self):
        checked = self.wordWrapAction.isChecked()
        self.textEdit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth if checked else QTextEdit.LineWrapMode.NoWrap)
        
    def aboutActionTriggeredHandler(self):
        QMessageBox.information(self, 'Message', 'Menu App\nVersion 0.16')
        
    def comBoxFontsCurrentIndexChangedHandler(self):
        font = self.textEdit.font()
        font.setFamily(self.comboBoxFonts.currentText())
        self.textEdit.setFont(font)
        
    def comBoxFontSizesCurrentIndexChangedHandler(self):
        font = self.textEdit.font()
        font.setPointSize(int(self.comboBoxFontSizes.currentText()))
        self.textEdit.setFont(font)
        
    def pushButtonColorResetClickedHandler(self):
        if QMessageBox.information(self, 'Warning', 'Colors will be set with default values, are you sure?', 
                QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No) == QMessageBox.StandardButton.Yes:
            self.textColor = QColor(0, 0, 0)
            self.backColor = QColor(255, 255, 255)
            self.setStyleSheet(f'QTextEdit {{color: {self.textColor.name()}; background-color: {self.backColor.name()}; }}')
        
    def closeEvent(self, ce):
        if self.textEdit.document().isModified():
            result = QMessageBox.information(self, 'Warning', 'Save changes?', 
                    QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No|QMessageBox.StandardButton.Cancel)   
            if result == QMessageBox.StandardButton.Cancel:
                ce.ignore()
                return
            if result == QMessageBox.StandardButton.Yes:
                self.saveActionTriggeredHandler()
        self.app_settings['pos'] = self.normal_pos if self.fullScreenAction.isChecked() else self.pos()
        self.app_settings['size'] = self.normal_size if self.fullScreenAction.isChecked() else self.size()
        self.app_settings['fullScreen'] = self.fullScreenAction.isChecked()
        self.app_settings['wordwrap'] = self.wordWrapAction.isChecked()     
        self.app_settings['textcolor'] = self.textColor
        self.app_settings['backcolor'] = self.backColor     
        self.app_settings.close()     

    def resizeEvent(self, event):
        total = self.width()
        self.splitter.setSizes([int(total * 0.8), int(total * 0.2)])
        super().resizeEvent(event)      
        
    def setCompilerDirectories(self):
        global env 
        
        VC_ROOT = r'C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207'
        SDK_INCLUDE = r'C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0'
        SDK_LIB = r'C:\Program Files (x86)\Windows Kits\10\Lib\10.0.22621.0'

        # Ortam değişkenlerini kopyala ve güncelle
        env = os.environ.copy()
        env['INCLUDE'] = (
            rf'{VC_ROOT}\include;'
            rf'{SDK_INCLUDE}\ucrt;'
            rf'{SDK_INCLUDE}\shared;'
            rf'{SDK_INCLUDE}\um;'
            rf'{SDK_INCLUDE}\winrt'
        )
        env['LIB'] = (
            rf'{VC_ROOT}\lib\x86;'
            rf'{SDK_LIB}\ucrt\x86;'
            rf'{SDK_LIB}\um\x86'
        )

        # PATH'e derleyici araçlarını ekle (link.exe, nmake, vs.)
        env['PATH'] = rf'{VC_ROOT}\bin\Hostx86\x86;' + env['PATH']      
        
try:
    app = QApplication(sys.argv)
    mainWindow = MainWindow()
    mainWindow.show()
    app.exec()
except Exception as e:
    QMessageBox.critical(None, 'Error', str(e))
    
#------------------------------------------------------------------------------------------------------------------------------------
                                                61. Ders 26/10/2025 – Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki gibi IDE projelerinde editörün de programlama diline özgü birtakım özewlliklerinin olması beklenir. Örneğin pek çok
    programlama editöründe "syntax highligting" gi,bi özellikler bulunmaktadır. Bu türt durumlarda açık kaynak kodlu başka projelerden 
    faydalanabilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında subprocess.run fonksiyonu subprocess.Popen isimli bir sınıf nesnesini kullanmaktadır. Yani prosesi çalıştıran asıl
    işlevsellik bu Popen sınıfındadır. Başka bir deyişle aslında subprocess.run bir "sarma (wrapper)" fonksiyondur. subprocess.Popen 
    sınıfının işlevselliği daha fazla olduğu için ayrıntılı işlemlerde subprocess.run yerine bu sınıfın kullanılması tercih edilebilir. 
    Sınıfın temel kullanımı zaten benzedir. Örneğin:

    popen = subprocess.Popen(['Notepad.exe'])  

    Aşağıdaki örnekte subprocess.Popen sınıfı kullanılmıştır. Sınıf nesnesi yaratılır yaratılmaz hemen proses çalıştırılır. 
    Ancak Popen sınıfı bu anlamda blokeye yol açmaz. Aşağıdaki örnekte hem programın çalıştırıldığına hem de akışın devam ettiğine 
    dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------------------

import subprocess

# sample.py 

import subprocess

p = subprocess.Popen(['python', 'test.py'])
print('Ok')

#------------------------------------------------------------------------------------------------------------------------------------
    Çalıştırılan proses bitene kadar blokede bekleme yapılmak isteniyorsa Popen sınıfının wait metodu kullanılabilir. Örneğin:

    p = subprocess.Popen(['python', 'test.py'])
    p.wait()
    print('Ok')

    Burada artık çalıştırılan "test.py" Python programı bitene kadar programın akışı wait metodunda bekleyecektir. 
#------------------------------------------------------------------------------------------------------------------------------------

# sample.py 

import subprocess

p = subprocess.Popen(['python', 'test.py'])
p.wait()
print('Ok')

# test.py

import time 

for i in range(10):
    print(i)
    time.sleep(1)

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında IO yönlendirmeleri subprocess.run fonksiyonu yerine doğrudan subprocess.Popen sınıfı kullanılarak daha yeterli düzeyde 
    yapılabilir. Örneğin bu sınıfta __init__ metodunun stdout parametresi subprocess.PIPE geçilirse Popen sınıfının stdout örnek 
    özniteliği bir dosya nesnesi olur. Biz bu dosyadan okuma yaptığımızda aslında çalıştırdığımız prosesin ekrana yazdırdıklarını 
    okumuş oluruz. Burada bir noktaya dikkat ediniz. subprocess.run fonksiyonu çalıştırılan program bitene kadar beklemekte ve 
    çalıştırılan programın stdout dosyasına yazdıklarını nesnenin byte türünden stdout özniteliğinden almaktadır. Halbuki Popen 
    sınıfında stdout özniteliği byte türünden değildir, bir dosya nesnesidir. Yani stdout dosyasından okuma sanki bir dosyadan 
    yapılıypormuş gibi read fonksiyonuyla yapılmalıdır. Örneğin:

    po = subprocess.Popen(['python', 'test.py'], stdout=subprocess.PIPE)

    s = po.stdout.read().decode()
    print(s)

    Burada bir nıoktaya dikkat ediniz. read metodu parametresiz kullanıldığında dosya sonuna kadar olan her şeyi okur. Burada dosya
    adeta çalıştırılan programın stdout dosyasına yazdıklarından (gerçekte yaratılmış olan borudan) oluşmaktadır. O halde bu kodda 
    çalıştırılan program bitmeden onun stdout dosyasına yazdıklarını biz print edemeyeceğiz. 

#------------------------------------------------------------------------------------------------------------------------------------

# sample.py 

import subprocess

p = subprocess.Popen(['python.exe', 'mample.py'], stdout=subprocess.PIPE)

s = p.stdout.read().decode()
print(s)

# mample.py 

import time

for i in range(10):
    time.sleep(0.5)
    print(i)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Biz Popen nesnesinin stdout örnek özniteliği ile dosyadan okuma yapmak istediğimizde eğer çalıştırılan proses stdout dosyasına 
    bizim okumak istediğimiz kadar bilgiyi henüz yazmamışsa biz blokede bekleriz. Çünkü boru işlemleri default olarak blokeli 
    işlemlerdir.  

    Aşağıdaki örnekte "sample.py" programı yine "test.py" programını çalıştırmıştır. "test.py" programı birer saniye bekleyerek stdout 
    dosyasına sayıları yazdırmaktadır. "sample.py" programı eğer p.stdout.read() ile okuma yapsaydı dosya sonuna gelene kadar bloke 
    oluşacaktı. Çünkü borularda dosya sonuna gelinmesi boruya yazan prosesin sonlanmasıyla mümkün olmaktadır. İşte bu tür durumlarda 
    boruya yeni bilgi geldikçe okuma yapmak gerekir. Bunun için Popen  sınıfının poll metodu kullanılmaktadır. Konun bazı ayrıntılarına 
    burada girmeyeceğiz. 
#------------------------------------------------------------------------------------------------------------------------------------

# sample.py

import subprocess

po = subprocess.Popen(['python', 'test.py'], stdout=subprocess.PIPE)

while not po.poll():
    s = po.stdout.readline().decode()
    print(s, end='')

# test.py

import time 

for i in range(10):
    print(i, flush=True)
    time.sleep(1

#------------------------------------------------------------------------------------------------------------------------------------
    Normal olarak bir işin birden fazla thread tarafından yapılması hız kazancı sağlar. Ancak CPython gerçekleştirimindeki GIL 
    yüzünden çok thread'li çalışma umulduğu kadar hız kazancı sağlamamaktadır. (Anımsanacağı gibi IronPython yorumlayısında GIL problemi 
    yokur.) İşte çok thread'li uygulamalarda CPyton'daki GIL problemi yüzünden bir işin farklı thread'ler yaratılarak değil farklı 
    prosesler yaratılarak yapılması alternatif bir yöntemdir. C, C++, Java, C# gibi programlama dillerinde multithreading çözümler 
    multiprocess çözümlere göre çok daha etkindir. Ancak GIL yüzünden CPython gerçekleştiriminde multiprocess çalışma çoğu zaman 
    multithreading çalışmadan daha hızlı olmaktadır. 

    Python'da multiprocess çalışma demekle birden fazla birbirinden bağımsız Python yorumlayıcısının ayrı programlar olarak 
    çalıştırılması kastedilmektedir. Daha önceden değindiğimiz gibi normal olarak multiporocess çalışmanın muştithreading çalışmaya
    göre şu dezavantajları vardır:

    - Prosesler thread'lere göre sistem genelinde daha fazla kaynağın kullanılmasına yol açmaktadır.
    - Proseslerin yaratılması ve yok edilmesi thread'lerin yaratılması ve yok edilmesine göre daha yavaştır. 
    - Thread'ler aynı adres alanı içerisinde çalıştığından dolayı thread'lerin haberleşmesi çok daha kolaydır. Halbuki prosesler 
    pek çok sistemde biribirinden izole edilmiştir. Dolayısıyla proseslerarası haberleşme thread'lerarası haberleşmeden çok daha yavaştır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Standart kütüphanedeki multiprocessing modülünde bulunan Process sınıfı genel kullanım itibari ile threading modülündeki Thread 
    sınıfına benzemektedir. Programcı Process sınıfı türünden bir nesne yaratır. Nesneyi yaratırken yine yeni proses akışının başlatılacağı 
    fonksiyonu target parametresiyle belirtir. Yine args parametresi ile parametre aktarımı yapılır. Proses nesnesine yine bir name 
    parametresi ile isim verilebilir. Prosesi çalıştırmak için yine start metodu, sonlanmasını beklemek için yine join metodu kullanılmaktadır. 
    join metodu alt processin kaynaklarını da boşaltmaktadır. Yani join metodu çağrıldığında üst proses alt proses eğer sonlanmamışsa sonlana 
    kadar bekler ve onun kaynaklarını boşaltır. Bir alt proses yaratılıp join ile beklenmezse bu tür durumlara UNIX/Linux dünyasında 
    "hortlak proses (zombie process)" denilmektedir. Ancak bazen bir alt proses yaratılıp  onun sonlanmasını beklemek istemeyebiliriz. 
    Bu tür durumlarda proses yaratılırken beklemenin yapılmayacağı belirtilmelidir. Bunu Python'da sağlamanın iki yolu vardır. Birincisi 
    Process sınıfında proses yaratılırken daemon parametresini True geçmektir. İkincisi proses yaratıldıktan sonra daemon örnek özniteliğine 
    False yerleştirmektir. 
        
    Görüldüğü gibi genel çalışma biçimi daha önce görmüş olduğumuz thread'lere benzemektedir. Örneğin:

    def foo(s):
        for i in range(10):
            print(f'{s}: {i}')
            time.sleep(1)
            
    if __name__ == '__main__':
        proc = multiprocessing.Process(target=foo, args=('Other process', ), daemon=True)
        proc.start()
        
        for i in range(10):
            print(f'Main process: {i}')
            time.sleep(1)
    
    Ancak burada target parametresi ile belirtilen fonksiyonun başka bir Python yorumlayıcısı tarafından tamamen başka bir proses 
    gibi çalıştırıldığına dikkat ediniz. Process sınıfı ile işlemler yapılırken kritik bir nokta vardır. Yeni bir prosesin yaratılması 
    __name__ == '__main__' koşulu altında yapılmalıdır. Bu kontrolün neden gerektiği "işletim sistemlerinin alt proses yaratma 
    biçimiyle ve Python'un özel bazı durumuyla ilgilidir. Tabii biz programındiğer kısımlarını fonksiyonlara yaptırıp yalnızca ana
    akışın başlatılacağı yerde bu kontrolü yapabiliriz. Örneğin:

    def foo(s):
        for i in range(10):
            print(f'{s}: {i}')
            time.sleep(1)

    def main():
        proc = multiprocessing.Process(target=foo, args=('Other process', ), daemon=True)
        proc.start()
        
        for i in range(10):
            print(f'Main process: {i}')
            time.sleep(1)

    if __name__ == '__main__':
        main()
#------------------------------------------------------------------------------------------------------------------------------------

import time
import multiprocessing

def foo(n):
    for i in range(n):
        print(f'Other process: {i}')
        time.sleep(1)

if __name__ == '__main__':
    process = multiprocessing.Process(target=foo, args=(10, ))
    process.start()
    
    for i in range(10):
        print(f'Parent process: {i}')
        time.sleep(1)

#------------------------------------------------------------------------------------------------------------------------------------
    Daha önce CPython'da 1 milyarlık bir döngüyü tek bir thread'le ve 250 milyonluk dört ayrı thread'le dönen bir test programı yazmıştık. 
    O programda her iki test de birbirine yakın sonuç vermişti. Aşağıdaki örnekte 1 milyarlık döngü hem tek bir thread'le, hem dört 
    prosesle hem de dört thread'le döndürülmüş ve sonuçlar ekrana (stdout dosyasına) yazdırılmıştır. Şu sonuçlar elde edilmiştir:

    Singlethreading: 14.27587628364563
    Multiprocessing: 4.058649778366089
    Multithreading: 15.125516176223755
#------------------------------------------------------------------------------------------------------------------------------------

import threading
import multiprocessing as mp
import time

def proc1():
    for i in range(250_000_000):
        pass

def proc2():
    for i in range(250_000_000):
        pass
    
def proc3():
    for i in range(250_000_000):
        pass

def proc4():
    for i in range(250_000_000):
        pass

def test1(): 
    t1 = time.time()
    for i in range(1_000_000_000):
        pass
    t2 = time.time()
    print(f'Singlethreading: {t2 - t1}')
           
def test2():
    t1 = time.time()
    
    process1 = mp.Process(target=proc1)
    process2 = mp.Process(target=proc2)
    process3 = mp.Process(target=proc3)
    process4 = mp.Process(target=proc4)
    
    process1.start()
    process2.start()
    process3.start()
    process4.start()
    
    process1.join()
    process2.join()
    process3.join()
    process4.join()
    
    t2 = time.time()

    print(f'Multiprocessing: {t2 - t1}')
    
def test3():
    t1 = time.time()
    
    thread1 = threading.Thread(target=proc1)
    thread2 = threading.Thread(target=proc2)
    thread3 = threading.Thread(target=proc3)
    thread4 = threading.Thread(target=proc4)
    
    thread1.start()
    thread2.start()
    thread3.start()
    thread4.start()
    
    thread1.join()
    thread2.join()
    thread3.join()
    thread4.join()
    
    t2 = time.time()

    print(f'Multithreading: {t2 - t1}')
    
if __name__ == '__main__':
    test1()
    test2()
    test3()
    
#------------------------------------------------------------------------------------------------------------------------------------
    Thread'lerin haberleşmesi global nesneler yoluyla yapılabilmektedir. Yani bir thread bir global değişkene bir değer yazdığında 
    diğeri onu görebilir. Gerçi bu tür uygulamalarda senkronizasyon da bir problemdir. Ancak haberleşme kısmı thread'lerde global 
    nesneler yoluyla yapılabilmektedir. 

    Aşağıdaki örnekte ana thread bir thread yaratıp bir global değişkeni set etmiştir. Yaratılan thread de aynı global değişkeni 
    görebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import time
import threading

val = 0

def foo(s):
    global val
    
    val = 100

def main():
    proc = threading.Thread(target=foo, args=('Other process', ))
    proc.start()
    time.sleep(1)       
    print(val)      # 100

if __name__ == '__main__':
    main()
    
#------------------------------------------------------------------------------------------------------------------------------------
    Prosesler ayrı bellek alanlarına sahiptir. Biz multiprocessing.Process sınıfında target parametresiyle proses akışının hangi 
    fonksiyondan başlatılacağını vermekteyiz. Ancak bu fonksiyon başka bir proses tarafından çalıştırılmaktadır. Dolayısıyla aslında 
    global nesneler farklı proseslerin farklı global nesneleri olur. Yukarıdaki örnek proseslerle yapıldığında üst proses val değişkenini 
    set ettiğinde alt proses bunu görmeyecektir. Çünkü aslında bu iki prosesin val değişkenleri kendilerine özgü ayrı değişkenlerdir. 
    Bu nedenle prosesleri haberleştirmek için "Queue" gibi "Pipe" gibi "Shared Memory" gibi özel yöntemler kullanılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import time
import multiprocessing

val = 0

def foo(s):
    global val
    
    val = 100

def main():
    proc = multiprocessing.Process(target=foo, args=('Other process', ), daemon=True)
    proc.start()
    time.sleep(1)
    print(val)          # 0

if __name__ == '__main__':
    main()

#------------------------------------------------------------------------------------------------------------------------------------
    Proseslerarası haberleşme threadlerarası haberleşmeden daha maliyetlidir. Proseslerarası haberleşme için multiprocessing modülünde 
    çeşitli sınıflar bulundurulmuştur. multiprocessing.Queue sınıfının kullanımı daha önce thread'ler konusunda üretici-tüketici 
    problemi için kullandığımız queue modülündeki Queue sınıfına çok benzemektedir. queue modülündeki Queue sınıfı aynı prosesin thread'leri 
    arasında haberleşme için kullanılırken multiprocessing modülündeki Queue sınıfı proseslerarası haberleşme için kullanılmaktadır.
    Örneğin biz üretici-tüketici problemini muştptocessing.Queue sınıfı yoluyla prosesler arasında uygulayabiliriz. Bunun için 
    multiprocessing.Queue nesnesi ana thread'te oluşturulur. Bu nesne alt prosese argüman olarak aktarılır. Artık iki fonksiyon 
    farklı proseslerde olsa da aslında aynı kuyruğu kullanıyor durumda olacaktır. Örneğin:

    def consumer(queue):
        while True:
            val = queue.get()
            if val == 99:
                break
            print(val, end=' ', flush=True)
        print()

    def producer(queue):
        val = 0
        while True:
            time.sleep(random.random() / 3)
            queue.put(val)
            val += 1
        
    if __name__ == '__main__':
        queue = multiprocessing.Queue(maxsize=10)
        proc = multiprocessing.Process(target=consumer, args=(queue, ))
        proc.start()
        producer(queue)
        proc.join()
        
    Burada multiprocessing.Queue sınıfı türünden nesne henüz alt proses yaratılmadan yaratılmış ve alt prosese parametre olarak 
    geçilmiştir. Buradaki producer ve consumer fonksiyonları aslında farklı ik proses tarafından çalıştırılmaktadır. Ancak 
    multprocessing.Queue sınıfı sayesinde kuyruktaki değerler prosesler arasında kullanılabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

def consumer(queue):
    while True:
        val = queue.get()
        if val == 99:
            break
        print(val, end=' ', flush=True)
    print()

def producer(queue):
    val = 0
    while True:
        time.sleep(random.random() / 3)
        queue.put(val)
        val += 1
    
if __name__ == '__main__':
    queue = multiprocessing.Queue(maxsize=10)
    proc = multiprocessing.Process(target=consumer, args=(queue, ))
    proc.start()
    producer(queue)
    proc.join()

#------------------------------------------------------------------------------------------------------------------------------------     
                                            62. Ders 01/11/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Gerek thread'lerde kullandığımız queue.Queue sınıfı gerekse prosesler için kullandığımız multiprocessing.Queue sınıfı birden fazla 
    tüketici ile çalışabilmektedir. 

    Aşağıdaki örnekte üretici-tüketici problemi iki tane tüketici ile çözülmüştür. Tüketici birden fazla olduğu zaman işlemin ne zaman 
    bitecğini belirlemek ve tüketicileri döngüden çıkartmak ayrı bir sorun olabilir. Çünkü kuyruktaki değere göre prosesler döngüyü 
    sonlandıracaksa bu değer iki tüketici tarafından da alınamamaktadır. Yani tüketicilerden yalnızca biri bu değeir alabilecek ve 
    döngüen çıkabilecektir. Bu tür problemlerin çözümleri için ilave senkronizasyon nesnelerinin (koşul değişkenleri gibi) kullanılması 
    gerekebilmektedir. Aşağıdaki örnekte bu problem ana prosesin işlem bittikten sonra diğer prosesleri kill metoduyla yok etmesiyle 
    sağlanmıştır. Process sınıfının kill metodu bir prosesi koşulsuz sonlandırmak için kullanılmaktadır. Ancak proseslerin bu biçimde 
    kill metoduyla sonlandırılması aslında sağlam bir çözüm yöntemi değildir. 
#------------------------------------------------------------------------------------------------------------------------------------

import multiprocessing as mp
import time
import random

def consumer_proc1(q):
    while True:
        val = q.get()
        time.sleep(random.random() / 2)
        print(f'consumer1 ---> {val}', flush=True)
        if val == 99:
            break

def consumer_proc2(q):
    while True:
        val = q.get()
        time.sleep(random.random() / 2)
        print(f'consumer2 ---> {val}', flush=True)
        if val == 99:
            break

if __name__ == '__main__':
    q = mp.Queue()            
    cp1 = mp.Process(target=consumer_proc1, args=(q, ))
    cp2 = mp.Process(target=consumer_proc2, args=(q, ))
    
    cp1.start()
    cp2.start()
    
    i = 0
    while True:
        time.sleep(random.random() / 2)
        q.put(i)
        if i == 99:
            break
        i += 1
        
    time.sleep(1)
    cp1.kill()
    cp1.kill()

#------------------------------------------------------------------------------------------------------------------------------------
    Prosesler arasında haberleşme için diğer bir yöntem de "boru (pipe) haberleşmesi" denilen yöntemdir. Boru haberleşmesi yöntemi 
    multiprocessing modülündeki Pipe isimli sınıf yoluyla uygulanmaktadır. Aslında Pipe kullanımı ile Queue kullanımı ana hatlarıyla 
    birbirine benzemektedir. Ancak Queue birden fazla üretici-tüketici prosesler arasında kullanılabilirken Pipe nesneleri iki proses 
    arasında kullanılmaktadır. Genel olarak Pipe kullanımı iki proses arasında haberleşme yapılıyorsa Queue kullanımından daha hızlıdır. 
    Pipe kullanımı şöyledir:

    1) Pipe sınıfı türünden bir nesne yaratılır. Bu nesne bir demet biçiminde iki Connectşon nesnesi verir. Borular tek yönlü 
    (unidirectional) ya da çift yönlü (bidiectional) olabilmektedir. Default durumda yaratılan borular çift yönlüdür. Eğer Pipe nesnesi 
    yaratılırken duplex parametresi False geçilirse bu durumda boru tek yönlü olur. Pipe fonksiyonun bize verdiği demetin ilk elemanı 
    okuma yapmak için, ikinci elemanı yazma yapmak için kullanılmaktadır. Çift yönlü borularda her iki taraf da hem okuma hem yazma 
    yapabilmektedir. Programcı bu connection nesnelerinin birini yarattığı prosese geçirir diğerini kendisi kullanır. 

    2) Connection sınıfının send metodu ile boruya bilgi yazılabilir, recv metodu ile borudan bilgi okunabilir. Genel olarak send 
    metodu herhangi bir türden bilginin boruya yazılmasını, recv metodu da gönderilmiş olan herhangi türden bir bilginin okunmasını 
    sağlamaktadır. 

    Aşağıdaki örnekte iki yönlü bir boru oluşturulmuştur. Üst proses boruya klavyeden girilen yazıları yazmış alt proses (yaratılan 
    proses) ise borudan bu yazaıyı okuyp onun tersini boruya yazmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import multiprocessing

def proc(conn):
    while True:
        s = conn.recv()
        if s == 'exit':
            break
        conn.send(s[::-1])
           
if __name__ == '__main__':
    conn1, conn2 = multiprocessing.Pipe()
    process = multiprocessing.Process(target=proc, args=(conn2, ))
    process.start()
    
    while True:
        s = input('Enter text:')
        conn1.send(s)
        if s == 'exit':
            break
        s = conn1.recv()
        print(s, flush=True)
        
    process.join()
    
#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte üst proses boruya send metoduyla 0'dan 100'e kadar sayıları yazmakta ve alt proses de bu sayıları recv metoduyla
    okuyup ekrana (stdout dosyasına) yazdırmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------------------
    Prosesler arasında bellek izolasyonu olduğu için biz Pipe gibi Queue gibi özel yöntemlerle iki proses arasında veri aktarımı 
    yapabilmekteyiz. İki proses arasında veri aktarımının bir diğer yolu da "paylaşılan bellek alanı (shared memory)" denilen tekniktir. 
    Python'da "paylaşılan bellek alanları" Value ve Array sınıflarıyla gerçekleştirilmiştir. Value sınıfı tipik olarak şöyle kullanılmaktadır:
    şöyleidr:

    1) Value sınıfı türünden bir nesne yaratılır. Nesne yaratırken ona bir "type code" ve nesnenin içereceği ilkdeğer verilir. 
    2) Bu Value nesnesi diğer prosese parametre yoluyla aktarılır. 
    3) Value sınıfının value isimli örnek özniteliği paylaşılan nesneyi temsil eder. Bir proses ona atama yaptığında diğeri onu 
    atanmış görmektedir. Yani bu value özniteliği aslında "paylaşılan bellek alanı (shared memory)" içerisindeki nesneyi belirtmektedir. 

    Value nesnesi yaratılırken birinci parametrede belirtilen "type code" özel bazı türleri temsil eden yazılardan oluşmaktadır. 
    Örneğin 'i' int türünü 'f' float türünü, 'd' double türünü temsil eder. Value sınıfı temelde C ile yazıldığı için buradaki type 
    code C dilindeki türlere ilişkindir. Örneğin Python'un str türüne ilişkin bir type code yoktur. Buradaki 'i', 'f' ve 'd' kodları 
    C'deki türlerdir. C'deki int türü Python'daki gibi sınırsız uzunluğa sahip değildir. Genellikle 4 byte uzunluktadır. C'de double 
    türü Python'daki float türüne karşı gelmektedir. C'deki float türünün Python'da bir karşılığı yoktur. Ancak tabii bir Value 
    sınıfının value örnek özniteliği ile değeri aldığımızda bu C'deki değer Python türüne dönüştürülerek bize verilmektedir. Örneğin:

    def proc(val):
        print(val.value)
        val.value = 200
            
    if __name__ == '__main__':
        val = multiprocessing.Value('i')
        val.value = 100      
        process = multiprocessing.Process(target=proc, args=(val, ))
        process.start()    
        process.join()
        print(val.value)
        
    Burada önce type kodu 'i' olan (yani int türünden olan) bir Value nesnesi yaratılmıiş ve bu nesne yeni yaraatılan prosese
    gönderilmiştir. Nesnenib value özniteliği paylaşılan alanı temsil etmektedir. Proseslerden biri bu özniteliğie bir şsey 
    yazdığında diğeri bunu görmektedir. 
    
    Paylaşılan bellek alanları bir senkronizasyon içermemektedir. Dolayısıyla bir senkronizasyon nesnesi olmadan üretici-tüketici 
    problemleri gibi problemlerde bu nesneler doğrudan kullanılamamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import multiprocessing

def proc(val):
     print(val.value)
     val.value = 200

if __name__ == '__main__' :
    val = multiprocessing.Value('i', 100)
    process= multiprocessing.Process(target=proc, args=(val, ))
    process.start()
    process.join()
    print(val.value)

#------------------------------------------------------------------------------------------------------------------------------------
    multiprocessing modülündeki Array isimli sınıf aslında Value sınıfının dizisel biçimidir. Bir Array nesnesi yaratıldığında bu 
    nesne yaratılan prosese parametre olarak geçilirse proses hem bu değerleri kullanabilir. Hem de bu dizinin elemanlarını değiştirirse 
    diğer proses onları değişmiş görür. Yani paylaşılan bellek alanında bir dizi yaratılmış olur. Array nesnesi yaratılıken de yine bir 
    "type code" belirtilmektedir. Yine buradaki type code C Programlama Dilindeki türlere ilişkindir. Array nesnesi yaratılırken ya 
    dizinin elemanları Python listesi ya da demeti biçiminde verilir, ya da yalnızca uzunluk belirtilir. Örneğin:

    array = multiprocessing.Array('i', 10)
        
    Örneğin:
    
    def proc(array):
        for x in array:
            print(x, end=' ', flush=True)
        print(flush=True)
        
        for i in range(len(array)):
            array[i] = array[i] + 1
        
    if __name__ == '__main__':
        array = multiprocessing.Array('i', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
        process = multiprocessing.Process(target=proc, args=(array, ))
        process.start()    
        process.join()
        for x in array:
            print(x, end=' ', flush=True)

    Burada Array nesnesi ilkdeğer verilerek yaratılmıştır.  Sonra bu array nesnesi yaratılan prosese gönderilmiştir. Orada önce 
    değerleri ekrana yazdırılmış sonra da dizi elemanları üzerinde değişiklikler yaoılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

import multiprocessing

def proc(array):
    for x in array:
        print(x, end=' ', flush=True)
    print(flush=True)
    
    for i in range(len(array)):
        array[i] = array[i] + 1
       
if __name__ == '__main__':
    array = multiprocessing.Array('i', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
    process = multiprocessing.Process(target=proc, args=(array, ))
    process.start()    
    process.join()
    for x in array:
        print(x, end=' ', flush=True)
  
#------------------------------------------------------------------------------------------------------------------------------------
    Shared memory tekniği işletim sistemleri dünyasında en hızlı proseslerarası haberleşme yöntemidir. Ancak bu yöntem yukarıda da 
    belirttiğimiz gibi kendi içerisinde bir senkronizasyon içermemektedir. Yani proseslerden biri bu paylaşılan bellek alanına bir 
    şeyler yazdığında diğerinin bunu uygun zamanda okuması gerekir. Bu biçimde pek çok veri aktarılacaksa "üretici-tüketici" problemi 
    uygulanmalıdır. Ancak zaten modüldeki Queue ve Pipe sınıfları bu tarz bir senkronizasyonu kendiliğinde içermektedir. Python'daki 
    Value ve Array sınıfları genellikle birtakım bilgilerin tek seferlik hızlı ve basit bir biçimde aktarılması için kullanılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Proseslerarasında da senkronizasyonlar gerekebilmektedir. Bunun için threading modülündeki senkronizasyon nesnelerinin tamamen 
    benzerleri multiprocessing modülünde de bulundurulmuştur. Yani biz thread'ler arasında kullandığımız senkronizasyon nesnelernin 
    benzerlerini prosesler arasında da kullanabilmekteyiz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    threading modülündeki Lock sınıfının tamamen benzeri multiprocessing modülünde de prosesleri senkronize etmek için bulunmaktadır.
    Tabii proseslerarasında kullanım için Lock nesnesinin alt prosese args parametresiyle geçirilmesi gerekmektedir. Proseslerin 
    bellek alanlarının tamamen izole edildiğini anımsayınız.

    Aşağıdaki örnekte üst proses alt prosesin kilidi ele geçirmesine izin vermiştir. Alt proses kilidi alarak 5 saniye bekledikten 
    sonra kilidi bırakmıştır. Üst proses alt proses kilidi bıraktıktan sonra kilidi alabilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import multiprocessing as mp
import time

def proc(lock):
   lock.acquire()
   print('child process locked', flush=True)
   time.sleep(5)
   lock.release() 
   print('child rekeased', flush=True)
            
if __name__ == '__main__':
    lock = mp.Lock()
    process= mp.Process(target=proc, args=(lock, ))
    process.start()
    time.sleep(1)
    
    print('parent process is wating for lock...', flush=True)
    lock.acquire()
    print('parent process locked', flush=True)
    lock.release()
    print('parent process released', flush=True)
    
    process.join()
   
#------------------------------------------------------------------------------------------------------------------------------------
    Tabii farklı proseslerde senkronizasyonun anlamlı olabilmesi için farklı proseslerin ortak bir kaynağı kullanıyor olması gerekir. 
    Bu ortak kaynak bellekte bir nesne ise bu nesnenin de prosesler arasında paylaşılıyor olması gerekir. 

    Aşağıdaki örnekte multiprocessing.Lock nesnesi kullanılarak kritik kod oluşturulmuştur. Bu koddaki do_something fonksiyonu iki proseste de
    bulunan ancak iki farklı programın çalıştırdığı bir fonksiyondur.
#------------------------------------------------------------------------------------------------------------------------------------

import multiprocessing as mp
import time
import random

def do_something(s, lock):
    lock.acquire()
    print(f'{s}: 1.Step', flush=True)
    time.sleep(random.random() / 2)
    print(f'{s}: 2.Step', flush=True)
    time.sleep(random.random() / 2)
    print(f'{s}: 3.Step', flush=True)
    time.sleep(random.random() / 2)
    print(f'{s}: 4.Step', flush=True)
    time.sleep(random.random() / 2)
    print(f'{s}: 5.Step', flush=True)
    time.sleep(random.random() / 2)
    print('---------------------------', flush=True)
    lock.release()

def proc(lock):
   for i in range(10):
       do_something('Child Process', lock)
         
if __name__ == '__main__':
    lock = mp.Lock()
    process= mp.Process(target=proc, args=(lock, ))
    process.start()
    
    for i in range(10):
        do_something('Parent Process', lock)
    
    process.join()
   
#------------------------------------------------------------------------------------------------------------------------------------
    threading modülündeki event nesnelerinin de multiprocessing modülünde bir benzeri bulunmaktadır. Tabii yine Event nesnesinin alt 
    proseseargs parametresiyle aktarılması gerekmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import multiprocessing as mp
import time

def proc(event):
    print('Child process runs...')
    time.sleep(5)
    print('Child reached important point', flush=True)
    event.set()
    
if __name__ == '__main__':
    event = mp.Event()
    process= mp.Process(target=proc, args=(event, ))
    process.start()
    
    print('Parent waits for child...', flush=True)
    event.wait()
    print('Ok, parent continues...', flush=True)
    
    process.join()
    
#------------------------------------------------------------------------------------------------------------------------------------
    Yine threading modülündeki Semaphore sınıfının bir benzeri multiprocessing modülünde de bulundurulmuştur. Aşağıdaki örnekte 
    binary semaphore ile proseslerarasında kritik kod oluşturulmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import multiprocessing as mp
import time
import random

def do_something(s, sem):
    sem.acquire()
    print(f'{s}: 1.Step')
    time.sleep(random.random() / 2)
    print(f'{s}: 2.Step')
    time.sleep(random.random() / 2)
    print(f'{s}: 3.Step')
    time.sleep(random.random() / 2)
    print(f'{s}: 4.Step')
    time.sleep(random.random() / 2)
    print(f'{s}: 5.Step')
    time.sleep(random.random() / 2)
    print('---------------------------')
    sem.release()

def proc(lock):
   for i in range(10):
       do_something('Child Process', lock)
         
if __name__ == '__main__':
    sem = mp.Semaphore(1)
    process= mp.Process(target=proc, args=(sem, ))
    process.start()
    
    for i in range(10):
        do_something('Parent Process', sem)
    
    process.join()
   
#------------------------------------------------------------------------------------------------------------------------------------
    Proseslerarası haberleşme (interprocess communication ya da kısaca IPC) kabaca ikiye ayrılmaktadır: 

    1) Aynı makinenin prosesleri arasında haberleşme
    2) Farklı makinelerin prosesleri arasında haberleşme

    Aynı makinenin prosesleri arasında haberleşmede işletim sistemleri tarafından sunulan "mesaj kuyrukları (message queue)", "borular 
    (pipes)", "paylaşılam bellek alanları (shared memory)" gibi yöntemler kullanılmaktadır. (Biz de multiprocessing modülü sayesinde 
    Python'da yüksek seviyeli bir biçimde bu mekanizmaları kullababilmekteyiz.) 
    
    Farklı makinelerin prosesleri arasında haberleşme için önceden belirlenmiş birtakım kurallara uyulması gerekmektedir. Haberleşmede 
    uyulması gereken kurallara "protokol (protocol)" denilmektedir. Çeşitli protokol aileleri vardır. Bugün için en yaygın kullanılan 
    protokol ailesi "IP Protokol Ailesi (IP Protocol Family)" denilen ailedir. IP prototokol ailesi aynı zamanda Internet'tin de 
    kullandığı protokol ailesidir. Dolayısıyla IP protokol ailesini kullanarak yazılmış olan programlar Internet ortamında da 
    kullanılabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Farklı makinelerin prosesleri arasında uzak mesafe haberleşme ilk kez 1969 yılında denenmiştir. Soğuk savaş yıllarında ABD Savunma 
    Bakanlığına bağlı DARPA (Defense Advanced Research Projects Agency) denilen kurumun ARPA (Advanced Research Project Agency) denilen 
    bölümü ismine ARPANET(Advanced Research Projects Agency Network) denilen bir proje başlatmıştır. ARPANET ABD savunmasında kullanılan 
    bilgisayarların dağıtık hale getirilmesini hedeflemekteydi. Proje ABD Savunma Bakanlığının yanı sıra "University of California Los 
    Angeles (UCLA)", "Stanford Research Institute (SRI)", "University of California, Santa Barbara (UCSB)", ve "University of Utah" 
    üniversiteleri tarafından yürüyülüyordu. Sonraları bu ARPANET genişlemeye başladı. ABD'dedeki diğer hükümet kurumları ve üniversiteler 
    bu ağa bağlandılar. O zamanlar bu ağda NCP (Netword Control Protocol) denilen bir protokol kullanıyordu. ARPANET sonraları Avrupa'ya 
    sıçradı ve 80'li yılların ortalarına doğru da Türkiye'ye de geldi. 1983 yılında ARPANET NCP protokolünü bırakarak IP protokol ailesine 
    geçmiştir. ARPANET 1983 yılında IP protokol ailesini kullanmaya başlayınca zamanla ismi de "Internet" haline gelmiştir. Internet 
    ismi "internetworking" sözcüğünden uydurulmuştur. Internetworking ağların birbirlerine bağlanması anlamına gelmektedir. Bugünkü 
    Internet'te aslında çeşitli küçük ağlar birbirleriyle bağlanarak büyük bir ağı oluşturmaktadır. Ağları biribirine bağlamak için 
    "Router" denilen aygıtlar kullanılmaktadır. Bugün evlerimizde kullandığımız modemler aynı zamanda router özelliğine de sahiptir. 
    Bizim evimizdeki bilgisayarlar bir "yerel ağ (local area netork)" oluşturmaktadır. Bu yerel ağ router ile dış dünyadaki başka bir 
    ağa (tipik olarak Internet apına) bağlanmaktadır. Aslında kişiler bir araya gelip kendi ağlarını oluşturabilirler. Ancak herkesin 
    katıldığı Internet denilen ağ büyük sinerji oluşturmuştur. Belli bir kurum içerisinde oluşturulmuş bu tür ağlara "intranet" de 
    denilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Protokol aileleri üst üste yığılmış olan protokollere sahip olabilmektedir. Her üste yığılmış protokole "katman (layer)" denilmektedir. 
    Her katmandaki protokol "aşağıdaki katmanların zaten var olduğu fikriyle daha yüksek seviyeli" kuralları tanımlamaktadır. Protokol 
    ailelerini oluşturmak  için ISO ve bazı kurumlar tarafından ismine "OSI Reference Model" denilen  dokğmanlar oluşturulmuştur. OSI 
    model bir protokol değildir. Protokol ailelerini oluşturacaklar için bir kılavuz niteliğindedir. OSI modelde toplam 7 katman üst üste ,
    yığılmıştır. OSI'nin 7 katmanışöyledir:

    ╔═══════════════════════════════════════════════════════════╗
    ║                    7. UYGULAMA KATMANI                    ║
    ║                   (Application Layer)                     ║
    ║        HTTP, FTP, SMTP, DNS, Telnet, SSH, SNMP            ║
    ╠═══════════════════════════════════════════════════════════╣
    ║                    6. SUNUM KATMANI                       ║
    ║                  (Presentation Layer)                     ║
    ║         SSL/TLS, JPEG, GIF, MPEG, ASCII, EBCDIC           ║
    ╠═══════════════════════════════════════════════════════════╣
    ║                    5. OTURUM KATMANI                      ║
    ║                    (Session Layer)                        ║
    ║          NetBIOS, RPC, PPTP, SIP, SQL, NFS                ║
    ╠═══════════════════════════════════════════════════════════╣
    ║                   4. AKTARIM KATMANI                      ║
    ║                   (Transport Layer)                       ║
    ║                      TCP, UDP, SCTP                       ║
    ╠═══════════════════════════════════════════════════════════╣
    ║                     3. AĞ KATMANI                         ║
    ║                    (Network Layer)                        ║
    ║              IP, ICMP, ARP, RARP, IGMP, IPsec             ║
    ╠═══════════════════════════════════════════════════════════╣
    ║                2. VERİ BAĞLANTI   KATMANI                 ║
    ║                  (Data Link Layer)                        ║
    ║           Ethernet, PPP, Switch, Bridge, MAC              ║
    ╠═══════════════════════════════════════════════════════════╣
    ║                    1. FİZİKSEL KATMAN                     ║
    ║                   (Physical Layer)                        ║
    ║        Kablolar, Hub, Repeater, Modem, Wi-Fi              ║
    ╚═══════════════════════════════════════════════════════════╝
    
    - Fiziksel katman (physical lLayer) iletişimde kullanılacak tüm donanımsal öğelerin spesifikasyonlarını belirtmektedir. Örneğin 
    kabloların taşıma kapasitesi, konnektörler, telsiz (wireless) aktarım söz konusuysa kullanılacak frekeans gibi tüm unsurlar 
    fiziksel katmana ilişkindir. Bu katmak gerçekleştirildiğinde artık veri transferi için donanımsal ortam sağlanmış durumdadır. 
    
    - Veri bağlantı katmanı (data link layer) ağa bağlı birimlerin (bilgisayarların) birbirlerini tanımaları için gereken kuralları 
    barındırmaktadır. Veri bağlantı katmanında ağa bağlı her birimin bir fiziksel adresi olmalıdır. Bugün bilgisayarlarımızda kullandığımız 
    "Ethernet kartı" diye bilinen network kartlarının protokolü olan Ethernet protokolü OSI'nin veri bağlantı katmanına ilişkindir.
    Bu katman gerçekleştirildiğinde artık ağa bağlı olan her birimin donanımsal bir adresi vardır. bir birimden diğerine paket 
    paket bilgiler gönderilip alınabilmektedir. 
    
    - Ağ Katmanı (network layer) "internetworking" için gereken ana protokollerin bulunduğu katmandır. IP Protokol ailesindeki IP 
    (Internet Protocol) protokolü OSI'nin "ağ katmanına" ilişkin bir protokoldür. Bu katmandaki protokoller artık ağa bağlı birimlere 
    fiziksel değil mantıksal bir adres vermektedir. Bu katmandaki protokoller bilgilerin nasıl paketlere ayrılıp nasıl iletileceği 
    konusundaki ayrıntıları tanımlamaktadır. Bu katman gerçekleştirildiğinde artık bir paket veri belli bir mantıksal adrese sahip 
    birime iletilebilir hale gelmiştir. 
    
    - Aktarım katmanı (transport layer) aynı birime giden paketlerin o birim içerisinde ayrıştırılması ve bir araya getirilmesine 
    ilişkin kuralları tanımlayan protokolleri içermektedir. Örneğin IP protokol ailesindeki TCP ve UDP protokolleri tipik olarak 
    aktarım katmanı protokolleridir. Aynı zamanda bu katman paketli bilgilerin bir stream haline dönüştürülmesi işlevini de yerine
    getirmektedir. 
        
    - İletişimde bir "oturum (session)" oluşturmak gerekebilir. Oturum katmanı bunu sağlamaktadır. IP protokol ailesinde bu işlevde 
    bir oturum katmanı bulunmamaktadır. 
    
    - Bilgilerin şifrelenemsi, sıkıştırılması, sunuma hazır hale getirilmesi gibi faaaliyetler açıklama Katmanı protokolleri tarafından 
    yapılmaktadır. IP protokol ailesinde bazı protokollerde bu tür faaliyetler vardır. Ancak OSI referans modelinede belirtilen 
    biçimde bir sunum katmanı yoktur.
    
    - Nihayet uygulama katmanı (application layer) protokolleri kullanıcı programlarının doğrudan kullandığı protokollerdir. Örneğin 
    IP ailesindeki HTTP, Telnet, SSH, POP3, IMAP gibi protokoller OSI'nin uygulama katmanına ilişkindir. Yani uygulama katmanı artık 
    kullanıcı ile etileşimde bukunan kullanıcı için belli bir işi yerine getiren en yüksek düzeyli protokolleri barındırmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Her ne kadar OSI 7 katmanlı bir protokol ailesi tanımlamışsa da IP Protokol ailesi OSI'nin 7 katmanını kullanmamaktadır. IP protokol ailesi 
    4 katmanlı bir protokol ailesidir. IP Protokol ailesinin temel protokolleri şöyle oluşturulmuştur:

    ╔═══════════════════════════════════════════════════════════╗
    ║                    4. UYGULAMA KATMANI                    ║
    ║                   (Application Layer)                     ║
    ║        HTTP, FTP, SMTP, DNS, Telnet, SSH, DHCP            ║
    ║              (OSI: Uygulama + Sunum + Oturum)             ║
    ╠═══════════════════════════╦═══════════════════════════════╣
    ║     3. AKTARIM KATMANI    ║     3. AKTARIM KATMANI        ║
    ║    (Transport Layer)      ║    (Transport Layer)          ║
    ║                           ║                               ║
    ║           TCP             ║           UDP                 ║
    ║                           ║                               ║
    ╠═══════════════════════════╩═══════════════════════════════╣
    ║                   2. AĞ KATMANI                           ║
    ║                    (Internet Layer)                       ║
    ║              IP (IPv4, IPv6), ICMP, ARP, IGMP             ║
    ║                      (OSI: Ağ Katmanı)                    ║
    ╠═══════════════════════════════════════════════════════════╣
    ║                1. AĞ ERİŞİM KATMANI                       ║
    ║                (Network Access Layer)                     ║
    ║              Ethernet, Wi-Fi, PPP, MAC                    ║
    ║              (OSI: Fiziksel ve Veri Aktarım)              ║
    ╚═══════════════════════════════════════════════════════════╝

    Aslında uygulama katmanındaki popüler protokollerin çoğu TCP üzerine oturtulmuştur. Yukarıdaki katmanlı yapı şöyle de ifade 
    edilebilir. 

    ╔═══════════════════════════╦═══════════════════════════════╗
    ║   4. UYGULAMA KATMANI     ║   4. UYGULAMA KATMANI         ║
    ║  (Application Layer)      ║  (Application Layer)          ║
    ║                           ║                               ║
    ║  HTTP, HTTPS, FTP, SMTP   ║  DNS, DHCP, TFTP, SNMP        ║
    ║  Telnet, SSH, POP3, IMAP  ║  NTP, RIP, VoIP (SIP/RTP)     ║
    ║                           ║                               ║
    ╠═══════════════════════════╬═══════════════════════════════╣
    ║     3. AKTARIM KATMANI    ║     3. AKTARIM KATMANI        ║
    ║    (Transport Layer)      ║    (Transport Layer)          ║
    ║                           ║                               ║
    ║          TCP              ║           UDP                 ║
    ║   (Bağlantı Odaklı)       ║      (Bağlantısız)            ║
    ║   Güvenilir İletim        ║       Hızlı İletim            ║
    ║                           ║                               ║
    ╠═══════════════════════════╩═══════════════════════════════╣
    ║                   2. AĞ KATMANI                           ║
    ║                    (Internet Layer)                       ║
    ║              IP (IPv4, IPv6), ICMP, ARP, IGMP             ║
    ║                      (OSI: Ağ Katmanı)                    ║
    ╠═══════════════════════════════════════════════════════════╣
    ║                1. AĞ ERİŞİM KATMANI                       ║
    ║                (Network Access Layer)                     ║
    ║              Ethernet, Wi-Fi, PPP, MAC                    ║
    ║              (OSI: Veri Bağlantısı + Fiziksel)            ║
    ╚═══════════════════════════════════════════════════════════╝

#------------------------------------------------------------------------------------------------------------------------------------
                                                63.Ders 02/11/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii IP Protokol ailesinde daha pek çok yardımcı protokoller de vardır. Biz yukarıda yalnızca temel protokolleri belirttik. "IP 
    Protokolü (Internet Protocol)" aileye ismini veren en önemli protokoldür. Bu protokol bilgilerin paketlere ayrılması, rotalanması 
    gibi tanımlamaları barındırmaktadır. IP protokolünde ağa bağlı olan her birime "host" denilmektedir. Her host'un ismine IP numarası 
    denilen mantıksal bir adresi vardır. IP protokolünün iki önemli versiyonu vardır: IPV4 ve IPV6. IPV4'te IP numaraları 4 byte 
    uzunluktadır. Ancak bu 4 byte'lık IP numaraları zamanla yetersiz kalmaya başlamıştır. IPV6'da IP numaraları 16 byte uzunluğundadır. 
    Bugün hem IPV4 hem de IPV6 aynı anda kullanılmaktadır. Yine ağırlıklı kullanım halen IPV4'tür. Ancak IPV6 kullanım oranı son 
    yıllarda oldukça yüskelmiştir. Yakın bir gelecekte başa baş noktaya geleceği söylenebilir. 

    TCP (Transmission Control Protocol) IP ailesindeki ağırlıklı kullanılan aktarım (transport) protokolüdür. IP ailesinin HTTP, SSH, 
    Telnet, POP3, FTP gibi protokollerinin hepsi TCP üzerine oturtulmuştur. IP protokol ailesinde doğrudan IP protokolü ile işlemler 
    çok seyrek yapılmaktadır. Genellikle uygulamacılar TCP protokolünü kullanmaktadır. TCP kullanımına halk arasında TCP/IP de 
    denilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    IP protokolünün üzerine TCP (Transmission Control Protocol) ve UDP (User Datagram Protocol) protokolleri oturtulmuşur. Yukarıda 
    da belirttiğimiz gibi ağırlıklı olarak TCP protokolü kullanılmaktadır. TCP "stream tabanlı (stream based)"i UDP ise "paket tabanlı 
    (datagram)" bir haberleşme sunmaktadır. Stream tabanlı haberleşme demekle "byte'ların bir kuyruk sistemi hedefte  peşi sıra dizildiği 
    ve istenilen miktarda byte'ın peşi sıra okunabildiği" hanerleşme modeli anlaşılmaktadır. TCP aslında IP protokolünü kullanır yani 
    TCP ile bilgi gönderilirken aslında bilgi IP paketlerine bölünür bu IP paketleri gönderilir. Ancak IP paketleri peşi sıra gönderilse 
    bile aynı sırada alınmak zorunda değildir. İşte TCP protokolünde bu IP paketleri içerisindeki TCP verileri hedefte yeniden birleştirlerek 
    sanki peşi sıra dizikmiş bir grup byte'mış gibi okunamaktadır. Dolayısıyla biz TCP'de çalışırken "sanki bir byte yığını varmış da 
    oradan sırasıyla istediğimiz kadar byte'ı okuyormuşuz gibi" bir durum oluşturulmaktadır. UDP ise "paket tabanlı (ya da datagram 
    tabanlı)" bir haberleşme sunmaktadır. UDP aslında IP protokolüne benzemektedir. UDP'de gönderen taraf bir grup bilgiyi bir paket 
    olarak gönderir. Alan taraf da bu paketi alır. Alan taraf "önce 5 byte sonra 10 byte gibi okumalar" yapamaz. Alan taraf gelen 
    paketi bütünsel olarak almaktadır. 

    TCP "bağlantılı (connection oriented)" bir protokoldür. TCP ile haberleşmeden önce bir taraf dğerine bağlanır. Burada bağlanmak 
    demekle "iki tarafın birbirlerinin farkında olması ve hangi durumda olduğunu bilmesi" kastedilmektedir. TCP haberleşmesinin başlaması 
    için bir tarafın karşı tarafa bağlanmayı istemesi ve karşı tarafın da bunu kabul etmesi gerekir. TCP'deki bağlantılı çalışma "
    client-server" tarzı bir haberleşme modelini akla getirmektedir. Client-server çalışma modelinde client önce server'a bağlanır.
    Sonra server'dan birtakım isteklerde bulunur. Server da bu istekleri yerine getirir. Sonuçları da client'a yollar. Bu durumda 
    TCP/IP uygulaması oluştururken "client" ve "server" olmak üzere iki ayrı programın yazılması gerekmektedir. UDP ise "bağlantısız 
    (connectionless)" bir protokoldür. Bağlantısız protokollerde gönderen ve alan arasında özel bir ilişki yoktur. Gönderen bilgiyi 
    paket biçiminde gönderir. Alanın da paketi alıp almadığını bilmez. TCP haberleşmesini telefon konuşmasına, UDP haberleşmesini ise
    eski tip mektup haberleşmesine benzetebiliriz. 

    TCP "güvenilir (reliable)" bir protokoldür. Bir protokolün güvenilir olması demek haberleşme sırasında bazı paketlerin yolda 
    kaybolması durumunda bile bunların yeniden istenerek telafi edilebilmesi demektir. Gönderen taraf alan tarafın bilgiyi aldığını 
    bilmektedir. Eğer alan taraf bilgiyi almamışsa (örneğin bilgi yolda kaybolmuşsa) gönderen taraf onu yeniden göndererek telafi 
    edebilmektedir. Güvenilirliğin sağlanması için gönderen ve alan tarafın karşılıklı bir "akış kontrolü (flow control)" uygulaması 
    gerekir. Bir taraf sürekli bilgi gönderdiğinde karşı tarafın tamponu dolarsa gönderen taraf artık blgi göndermeyip onun tamponun
    boşalmasını beklemektedir. UDP ise "güvenilir olmayan (unreliable)" bir protokdür. UDP'de gönderen paketi gönderir ancak alanın 
    bunu alıp almadığını bilmez. Dolayısıyla paket yolda kaybolursa bunun da bir telafisi yapılamamaktadır. 

    TCP protokolü UDP protokolüne göre daha güvenilir ancak daha yavaştır. UDP'de bir akış kontrolü olmadığından paketlerin karşı 
    tarafta birleştirilmesi gibi işlemler de olmadığı için UDP hızlı bir haberleşme sunmaktadır. Ancak UDP'nin güvenilebilir olmaması 
    ve stream tabanlı olmaması onun seyrek kullanılmasına yol açmaktadır. IP protokol ailesinin HTTP gibi, POP3 gibi, IMAP gibi, FTP 
    gibi uygulama katmanı protokolleri hep TCP kullanmaktadır. 
    
    Yukarıda da belirttiğimiz gibi IP protok ailesinde ağa bağlı olan birimlere "host" denilmektedir. Bir host bir bilgisayar 
    olabileceği gibi yazıcı, kamera, sensör vs. de olabilir. Her host'un bir IP numarası vardır. IP paketleri kaynak host'tan hedef 
    host'a gönderilmektedir. Ancak hedef host'a gelen bir IP paketi orada hangi programa iletilecektir? IP protokolü bununla ilgilenmemiştir. 
    İşte bu durum TCP ve UDP protokolerrinde "protocol port numarası" denilen yöntemle ele alınmıştır. TCP ve UDP protokollerinde 
    bir host'a giden bilgilere bir port numarası da iliştirilir. Hedef host'a gelen bilgiler o port'la hangi program ilgileniyorsa 
    o programa iletilmektedir. Yani "port numarası" adeta bir şirketin "içsel hat numaralarına" benzemektedir. Biz TCP ve UDP'de 
    yalnızca hedef host'un IP numarası ile bilgiyi göndermeyiz. Bilgiyi belli bir host'un belli port'una göndeririz. IP protokol 
    ailesinde IP numarasıyla port numarasının oluşturduğu ikiliye "end point" de denilmektedir .

    Port numaraları [0, 65535] arasındadır. İlk 1024 port numarası IP protokol ailesinin uygulama katmanındaki protokoller için 
    ayrılmıştır. Dolayısıyla programcıların server programları yazarken ilk 1024 port nmarasını kullanmaması gerekir. Bu ilk 
    1024 port numarasına İngilizce "well known ports" da denilmektedir. Örneğin sizin de duyduğunuz bazı uygulama katmanı protokollerinin 
    port numaraları şöyledir:

    HTTP: 80
    FTP: 20, 21
    TFTP: 69
    SSH: 22
    TELNET: 23
    SMTP: 25
    POP3: 110

    Port kavramı TCP ve UDP protokollerine ilişkin kavramlardır. Dolayısıyla IPV4 ve IPV6 versiyonlarında da port numaraları 65536 
    tanedir. (TCP ve UDP protokollerinin V4 ve V6 biçiminde versiyonları yoktur. IP protokolünün IPV4 ve IPV6 biçiminde versiyonları
    vardır.)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
   TCP/IP çalışma "client-server" tarzı bir haberleşme modelini dikte ettirmektedir. Burada client-server haberleşme modeli hakında 
   bilgiler vereceğiz. 

   Clint-server haberleşme modelinde çalışan iki program bulunmaktadır. Bunlardan birine "client" diğerine "server" denilmektedir. 
   Bu modelde asıl işi yapan program "server" programdır. Client program server programdan kendisi için bir şey yapmasını ister 
   "server" bunu client için yapar ve işlemin sonuçlarını client programa gönderir. Client-server çalışma modelinin neden yaygın 
   bir biçimde kullanıldığını birkaç maddede açıklayabiliriz:

   1) Client-server model kaynakların paylaştırılması için sıkça kullanılmaktadır. Kaynaklar server tarafından erişilebilir durumdadır. 
   client programlar kaynaklara doğrudan erişemediği için server programdan istekte bulunur. Server kayanaklara erişir client'ın 
   isteğini yerine getirir ve sonucu client programa yollar. Örneğin bir yazıcının bir bilgisayara bağlı olduğunu düşünelim. Bu yazıcı 
   deiğer bilgisayarlara bağlı değildir. Ancak bu yazıcının bağlı olduğu bilgisayarda bir server program bulunabilir. Client programlar 
   print edilecek sayfaları bu server'a iletirler server program da printer'dan bunların çıktılarını alır. Ya da örneğin biz ATM 
   cihanlarına banka kartını taktığımızda ATM cihazı içerisinde client program çalışmaktadır. Bu client program bizim bilgilerimizi 
   server programa yollar server program veritabanına erişir para çekme isteğini onaylar, bunu ATM'deki client programa bildirir. 
   ATM'de client program da parayı haznesinden çıkartarak öüşteriye verir. Burada client'ların veritabanına erişemediğine yalnızca
   server programın eriştiğine dikkat ediniz. 

   2) Server program güçlü bir makinede çalışıyor olabilir. Client programlar makineler güçsüz mobil aygıtlardna oluşuyor olabilir. 
   Bu durumda server programın gücünden faydalanılabilir. Örneğin quantum bilgisayarlar şu anda çok pahalı olduğu için ancak büyük 
   kurumlar tarafından sahiplenilmektedir. Bu kurumlar bulut sistemleriyle client-server çalışma mimarisi ile bizim quantum bilgisayarlara
   iş yaptırabilmemizi sağlayabilmektedir. 

   3) Server program bir koordinasyon yapıyor olabilir. Örneğin sosyal ağlar tamamne client-server tarzda bir uygulama içermektedir. 
   Biz kontaktlistemizdeki kişilerin o anda online olup olmadığını bilmeyiz. Kullanıcılar client programlardır. Server onların sisteme
   girdiğini anlar bize "falanca balantın şu anda online oldu" biçiminde bildirim gönderebilir. Biz ona mesaj göndermek istediğimizde
   mesajı server'a gönseririz. Server da mesajı diğer kişiye gönderir. Burada tüm bilgilere server'ın sahip olduğuna ve iletişimi 
   tamamen server'ın koordine ettiğine dikkat ediniz. Oyun programları da benzerdir. Oyun oynarken aslında kişiler arasındaki 
   koordinasyon server program tarafından sağlanmaktadır. 

    Client-server çalışma modelinde bağlanmak isteyen taraf clint rolündedir. Örneğin Windows'un uzak masaüstü uygulamalarını 
    düşünelim. Bu uygulamada biz bir Windows makineye uzaktan bağlanıp onu yönebilmekteyiz. Burada iki ayrı program söz konusudur. 
    Bizim bağlantıda kullandığımız uzak masaüstü programı client programdır. Karşı tarafta uzak masaüstü programın server programının 
    bulunuyoe olması gerekir. Bağlantı gerçekelştiğinde server program client programa ekran görüntüsünü yollar, client program da 
    bunu ekranda gösterir. Client makinedeki fare ve klavye hareketlerini client program server programa gönderir. Server program 
    da onları o makinede uygular. 

    Birisine e-posta göndermek isteyelim. Biz aslında e-postayı hizmet aldığımız yerin server programına iletiriz. Bu server program 
    e-postayı karşı tarafından server programına iletir. Karşı tarafın server programı e-postaları saklar. Karşı tarafın clinet programı
    istediğinde onu client programa yani kullanıcıya verir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Protokol ailelerini işleten kodlar işletim sistemlerinin içerisinde çekirdeğin parçası biçiminde bulunmaktadır. Ancak onların 
    programcılar tarafından kullanılabilmesi için kütüphanelere gereksinim vardır. İşte ağ haberleşmesi için kullanılan ve ilk kez 
    BSD UNIX sistemlerinde gerçekleştirilen kütüphaneye "soket kütüphanesi (socket library)" denilmektedir. Windows bu BSD soket 
    kütüphanesinin kendine özgü değişik bir biçimini de oluşturmuştur. Microsoft'un BSD soket kütüphanesi temel alınarak oluşturduğu 
    bu soket kütüphanesine de "Winsock Kütüphanesi" denilmektedir. macOS sistemleri BSD soket kütüphanesini aynı biçimde desteklemektedir. 

    Soket kütüphanesi Python'da "nesne yönelimli biçimde" bir modül olarak oluşturulmuştur. Python'un bu soket kütüphanesi aslında 
    arka planda UNIX/Linux ve macOS sistemlerinde BSD soket kütüphanesini, Windows sistemlerinde ise Winsock kütüphanesini 
    kullanmaktadır. Başka bir deyişle Python'daki soket kütüphanesi işletim sistemindeki C'de yazılmış olan soket kütüphanesini 
    sarmalamaktadır. 

    Yukarıda da belirttiğimiz gibi soket kütüphanesi özellikle IP protokol ailesi için oluşurulmuş bir kütüphane değildir. Soket 
    kütüphanesi protokol aileleri için ortak bir arayüz oluşturmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi TCP/IP soket uygulamalarında "server" ve "client" programların ayrı ayrı yazılması gerekmektedir. 
    Biz burada önce TCP server programının sonra da TCP client programının nasıl yazılacağını göreceğiz. Python'da tüm socket işlemleri 
    socket isimli standart Python modülü ile yapılmaktadır. 

    TCP/IP ve UDP/IP protokollerinde server ve client programlar aynı host'ta da çalıştırılabilir. Genellikle programcılar server 
    ve client programları aynı makinede test edip sonra bunları hedef makinelere taşırlar. Yani TCP/IP ve UDP/IP aynı makinedeki 
    proseslerin haberleşmesi için de kullanılabilmektedir. Tabii bu protokollerle aynı makinedeki proseslerin haberleşmesi daha 
    yüksek maliyetle sağlanmaktadır. Bu tür durumlarda multiprcessing modülünde görmüş olduğumuz aynı makinenin prosesleri arasında 
    haberleşme yöntemleri tercih edilmelidir. Soket haberleşmesi "UNIX Domain Socket" denilen yöntemle aynı makinenin prosesleri 
    arasında daha etkin bir biçimde de sağlanabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    TCP server program tipik olarak aşağıdaki adımlardan geçilerek yazılmaktadır:

    1) Soket nesnesi yaratılır
    2) Soket bağlanır (bind edilir)
    3) Soket dinleme konumuna sokulur 
    4) Bağlantı istekleri kabul edilir
    5) Gönderme ve alma işlemleri yapılır
    6) Soket shutdown edilir
    7) Soket kapatılır

    Soket işlemleri için socket isimli sınıf kullanılmaktadır. socket sınıfı türünden bir nesne yaratılıp işlemler bu sınıfın 
    metotlarıyla yürütülmektedir. soket sınıfının __init__ metodunun parametrik yapısı şöyledir:

    socket(family=socket.AF_INET, type=socket.SOCK_STREAM, proto=0, fileno=None)
    
    Fonksiyonun birinci parametresi hangi protokol ailesi ile çalışılacağını belirtmektedir. Bu parametre socket.AF_INET geçilirse 
    "IPV4" ailesi, socket.AF_INET6 geçilirse "IPV6" ailesi anlaşılmaktadır. Diğer protokol aileleri için bu parametreye başka değerler 
    geçilmelidir. Bu parametrenin default değerinin socket.AF_INET olduğuna dikkat ediniz. Fonksiyonun ikinci parametresi soket türünü 
    belirtmektedir. Bu parametre TCP için socket.SOCK_STREAM, UDP için socket.SOCK_DGRAM girilmelidir. Bu parametrenin de default 
    değerinin socket.SOCK_STREAM biçiminde olduğuna dikkat ediniz. Fonksiyonun üçüncü parametresi kullanılacak "aktarım katmanı 
    (transport layer)" protokolünü belirtmektedir. Bu parametre TCP için socket.IPPROTO_TCP, UDP için ise socket.IPPROTO_UDP biçiminde 
    girilebilir. Aslında fonksiyonun ikinci parametresi IP protokol ailesi söz konusu olduğunda ikinci parametresinden anlaşılabilmektedr. 
    Dolayısıyla IP protokol ailesi için bu üçüncü parametrenin girilmesine gerek yoktur. Fonksiyonun son parametresi UNIX/Linux 
    sistemlerindeki dosya betimleyicisini alabilmektedir. Bu parametrenin bizim için şu aşamada önemi yoktur. 
    
    Eğer biz TCP/Ip kullanacaksak aslında socket fonksiyonunun iki parametresi uygun değerleri almaktadır. Yani örneğin:

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    ile aslında aşağıdaki çağrı eşdeğerdir:

    sock = socket.socket()

    Biz öneklerimizde okunabilirliği artırmak için açıkça protokol ailesini ve soket türünü belirteceğiz. 

    Soket işlemlerinde hata oluştuğunda built-in OSError isimli sınıfla exception fırlatılmaktadır. Programcı kodunu try-except bloğu 
    içerisine yerleştirebilir. Örneğin:

    try:
        server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # ...
    except OSError as e:
        print(e)

    socket sınıfı "bağlam yönetim protokolünü (context management protocol)" desteklemektedir. Dolayısıyla socket sınıfı with deyimi 
    ile kullanılabilir. Bu durumda with deyiminden çıkışdığında socket nesnesi otomatik olarak kapatılacaktır. Örneğin:

    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
        # ...
    except OSError as e:
        print(e)
#------------------------------------------------------------------------------------------------------------------------------------

import socket

try:
    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP)
    print('Ok')
except OSError as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    Soket yaratıldıktan sonra bind edilmelidir. Soketin bind edilmesi demek "hangi network kartından gelen bağlantı isteklerinin 
    işleme sokulacağını ve hangi port hedeflenerek gelen bağlantı istekleriyle ilgilenileceğini" belirlemek demektir. bind işlemi
    socket sınıfının bind metoduyla yapılmaktadır. bind metodu iki elemanlı bir demeti parametre olarak alır. Demetin birinci elemanı 
    bağlantı istekleri için kullanılacak network kartının IP adresini, ikinci elemanı ise ilgilenilecek port numarasını belirtir. 
    Birinci parametrede boş string "tüm network kartlarından gelen bağlantı isteklerinin kabul edileceğini" belirtir. Örneğin:

    sock.bind(('', 55555))

    Burada server program 55555 port numarası ile kendi bilgisayarındaki tüm network kartından (network interface) gelen bağlantı 
    isteklerini değerlendiecektir. 
#------------------------------------------------------------------------------------------------------------------------------------

import socket
import socket

PORT_NO = 55555

try:
    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_sock.bind(('', PORT_NO))
    print('Ok')
except OSError as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Soket bind edildikten sonra artık aktif dinleme konumuna sokulmalıdır. Soketin dinlenmesi "gelen bağlantı isteklerinin işletim 
    sistemi tarafından bizim için kuyruklanması" anlamına gelmektedir. Soket dinleme konumuna sokulduğunda artık bizi ilgilendiren 
    bağlantı isteklerini işletim sistemi bize iletecektir. listen işlemi blokeye yol açmaz (yani listen işleminde bi bekleme olmaz). 
    Çünkü burada gelen bağlantı isteklerinin belirlenmesini bizim programımız değil işletim sisteminin kendisi yapmaktadır. 
    
    Soketi dinleme konumuna sokmak için socket sınıfının listen metodu kullanılmaktadır. listen metodunun bir parametresi vardır.
    Bu parametre bağlantı isteklerinin yerleştirileceği kuyruğun uzunluğunu belirtir. Server program yavaş kalırsa yeni bağlantı 
    istekleri bu kuyruğa eklenir. Eğer kuyruk dolarsa bağlantı istekleri kuyruğa yerleştirilemediği için bağlanmak isteyen taraf 
    başarız olur. Bu parametre için değer girilmezse uygun bir kuyruk uzunluğu metot tarafından belirlenmeketdir. Yoğun server'larda 
    bu değerin yüksek tutulması, yoğun olmayan server'larda düşük tutulması uygundur. Ya da bu uzunluğun listen metodu tarafından 
    default alınması yoluna da gidilebilir.  Örneğin:

    PORT_NO = 55555

    try:
        server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_sock.bind(('', PORT_NO))
        server_sock.listen()
        print('Ok')
    except OSError as e:
        print(e)
        
    Soket dinleme konumuna sokulurken işletim sistemlerinin "firewall" denilen güvenlik mekanizması devreye girebilmektedir. Örneğin 
    Windows sistemlerinde "listen" işlemi yapıldığında işletim sistemi bir popup pencere çıkartmaktadır. Bu popup pencerede kullanıcı 
    durum hakkında bilgilendirilmektedir. Bazı sistemlerde (örneğin centos gibi) port default olarak firewall tarafından engellenmiş 
    olabilmektedir. Bu durumda server programı çalıştırmadan önce programcının firewall'dan ilgili portu açması gerekebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import socket

PORT_NO = 50500

try:
    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP)
    server_sock.bind(('', PORT_NO))
    server_sock.listen(8)
    print('Ok')
except OSError as oserr:
    print(oserr)

#------------------------------------------------------------------------------------------------------------------------------------
    Artık sıra bağlantıların kabul edilmesine gelmiştir. Bu işlem socket sınıfının accept isimli metoduyla yapılır. accept metodu 
    kuyrukta bağlantı için bekleyen bir bağlantı isteği varsa hemen o bağlantıyı sağlar. Böylece bloke oluşmaz. Ancak kuyrukta bir 
    bağlantı isteği  yoksa bir bağlantı isteği oluşana kadar accept metodu thread'i blokede bekletmektedir. Yani accept blokeye 
    (beklemeye) yol açabilen bir metottur. accept metodu bağlantıyı sağladıktan sonra bağlanılan client ile konuşmakta kullanılacak 
    bir soketi ve bağlanılan client'a ilişkin bilgileri geri döndürür. Yani accept bize yeni bir soket yaratıp vermektedir. Biz 
    her accept metodunu çağırdığımızda o anda bağlandığımız client ile konuşmakta  kullanacağımız yeni bir soket nesnesi elde 
    ederiz. Her client ile farklı bir soket kullanılarak konuşulmaktadır. İşin başında server programın yarattığı sokete halk 
    arasında "pasif soket (passive socket)" ya da "dinleme soketi (listenining socket)" denilmektedir. Bu soket client ile 
    konuşmakta kullanılmaz yalnızca bağlantı yapmak için kullanılır. accept metodunun verdiği konuşmakta kullanılacak olan sokete 
    ise halk arasında "aktif soket (active socket)" denilmektedir. 
    
    accept metodu iki elemanlı bir demet geri döndürmektedir. Demetin ilk elemanı client ile konuşmakta kullanılacak soket, ikinci
    elemanı ise client'ın IP numarası port numarasını belirten iki elemanlı bir demettir. IP adresi ve port numarasında oluşan 
    bilgiye "end point" de denildiğini anımsayınız. O halde accept metodu tipik olarak şöyle kullanılmaktadır:

    client_sock, (client_addr, client_port) = sock.accept()

    accept metodunun geri döndürdüğü "end point"teki IP adresi bir string olarak verilmektedir. Bir IPV4 adresinin bir string olarak
    noktalı biçimde ifade edilmesine İngilizce "dotted decimal format" denilmektedir. Örneğin:

    "192.168.1.1"
    "188.3.183.172"

    IPV4 adresleri protokol tarafından 4 byte'lık bir sayı gibi gönderilip alınmaktadır. Ancak noktalı desimal format okunması 
    ve ifade edilemsi kolay olduğu için halk arasında çokça kullanılmaktadır. 

    Client taraf server'a ip adresi port numarasını belirterek bağlanmaktadır. Ancak client programın da kendi host'ndan bir 
    port numarası vardır. Client'ın port numarasının server programını yazan tarafından bilinmesine çoğu kez gerek yoktur. Soket 
    kütüphanesi zaten bu bilgiyi iletişmde arka planda kullanmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import socket

PORT_NO = 55555

try:
    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_sock.bind(('', PORT_NO))
    server_sock.listen()
    print('waiting for connection...')
    client_sock, (client_addr, client_port) = server_sock.accept()
    print(f'connected with client {client_addr}:{client_port}')
except OSError as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
                                                64. Ders 08/11/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Soketten bilgi gönderip soketten bilgi okuma işlemleri ileride ele alınacaktır. Soket işlemleri bittiğinde soketin kapatılması 
    gerekir. Soketi kapatmak için socket sınıfının close metodu kullanılmaktadır. Pasif soketler (dinleme soketleri) doğrudan close 
    ile kapatılabilir. Ancak aktif soketlerin close işleminden önce shutdown metodu ile "shutdown" yapılması tavsiye edilmektedir. 
    Shutdown işlemi sırasında TCP/IP için gereken "el sıkışma (hand shaking)" işlemi yapılır ve iletişim kontrollü bir biçimde 
    sonlandırılır. Bir soketin önce shutdown yapılıp sonra close ile kapatılmasına TCP/IP dünyasında "zarif kapatma (graceful close)" 
    denilmektedir. 

    shudown metodunun bir parametresi vardır. Bu parametre shutword işleminin nasıl yapılacağını belirtir. Aşağıdaki değerlerden 
    biri biçiminde girilmelidir:
   
    socket.SHUT_RD
    socket.SHUT_WR
    socket.SHUT_RDWR

    Biz bir sokete bilgi gönderdiğimizde (bunun nasıl yapıldığı izleyen paragraflarda ele alınmaktadır) bu bilgi hemen IP paketine
    dönüştülerek yollanmamaktadır. Programcının göndermek istediği bilgiler önce "network tamponu (network buffer)" denilen sokete 
    özgü bir tampona çekilir. Sonra işletim sistemi bunu kendi döngüsü içerisinde gönderir. İşte biz soket ile karşı tarafa bir 
    bilgi gönderip hemen arkasından soketi close ettiğimizde close işlemi network tamponuyla birlikte tüm soketin kapatılmasına yol 
    açmaktadır. Yani bu durumda network tamponunda gönderilmeyi bekleyen bilgiler de gönderilemeyebilecektir. İşte shutdown işlemi 
    socket.SHUT_WR ya da socket.SHUT_RDWR ile yapılırsa bu durumda shutdown metodu network tamponundaki bilgiler karşı tarafa gönderilene 
    kadar küçük bir bloke oluşturacaktır. Bu sayede biz close işlemi yapmadan önce yerel makinemizdeki tüm bilgilerin karşı tarafa 
    gönderildiğinden emin oluruz. socket.SHUT_RD değeri "ben bir daha bu soketten okuma yapmayacağım fakat yazma yapabilirim" anlamına 
    socket.SHUT_WR değeri ise "ben bir daha bu sokete yazma yapmayacağım ancak soketten okuma yapabilirim" anlamına gelmektedir. 
    Bu tür shutdown işlemlerine TCP dünyasında "half close" da denilmektedir. shutdown metodunda eğer socket.SHUT_RDWR değeri 
    kullanılırsa bu durumda "artık bir daha soketten okuma ya da sokete yazma" yapılamamaktadır. Tipik olarak shutdown parametresi 
    için socket.SHUT_RDWR kullanılmaktadır. 

    Anımsanacağı gibi "exception güvenli" bir kodlama için genellikle nesneler üzerindeki sonlandırma ve kapatma işlemleri try bloğunun 
    finally kısmında yapılıyordu. Ancak henüz açılmamış bir soketin kapatılması da bir exception oluşmasına yol açmaktadır. Bu nedenle
    socket değişkenlerine başlangıçta None değeri yerleştirip duruma göre bunların shutdown ve close edilmesi uygun olur. Örneğin:
    
    PORT_NO = 55555

    server_sock = None
    client_sock = None

    try:
        server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        ....
        client_sock, (client_addr, client_port) = server_sock.accept()
        ...
    except OSError as e:
        print(e)
    finally:
        if client_sock:
            client_sock.shudown(...)
            client_sock.close()
        if server_sock:
            server_sock.close()
#------------------------------------------------------------------------------------------------------------------------------------

import socket

PORT_NO = 55555

server_sock = None
client_sock = None

try:
    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_sock.bind(('', PORT_NO))
    server_sock.listen(8)
    
    print('waiting for client...')
    client_sock, (client_addr, client_port) = server_sock.accept()
    print(f'connected with client {client_addr}:{client_port}')
 
except OSError as e:
    print(e)
finally:
    if client_sock:
        client_sock.shutdown(...)
        client_sock.close()
    if server_sock:
        server_sock.close()
#------------------------------------------------------------------------------------------------------------------------------------
    socket sınıfı "bağlam yönetim protokolünü (context management protocol)" desteklemektedir. Dolayısıyla with deyimi ile kullanılabilir. 
    Bu durumda with deyimi sonlanırken close işlemi otomatik yapılacaktır. Bu tür kodlarda with deyimi daha sade bir yazıma olanak 
    sağlamaktadır. Örneğin:

    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
            ....
            client_sock, (client_addr, client_port) = server_sock.accept()
            with client_sock:
                ...
                client_sock.shutdown(...)
    except OSError as e:
        print(e)
#------------------------------------------------------------------------------------------------------------------------------------

import socket

PORT_NO = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
        server_sock.bind(('', PORT_NO))
        server_sock.listen(8)
        
        print('waiting for client...')
        client_sock, (client_addr, client_port) = server_sock.accept()
        with client_sock:
            print(f'connected with client {client_addr}:{client_port}')
            client_sock.shutdown(socket.SHUT_RDWR)
except OSError as e:
    print(e)
  
#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de TCP clinet programın nasıl yazılacağı üzerinde duracağız. TCP client programın yazımı tipik olarak şu aşamalardan geçilerek 
    gerçekleştirilmektedir:

    1) Client soket nesnesini yaratır.
    2) Client soket için isteğe olarak bind işlemi yapabilir.
    3) Client server'a bağlanır.
    4) Bağlantı sağlandıktan sonra gönderme ve alma işlemleri yapılır
    5) Soket shutdown edilir (graceful close)
    6) Soket kapatılır.

    İzleyen paragraflarda bu aşamalar üzerinde duracağız.     
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    TCP ve UDP protokollerinde her soket bir portla ilişkilendirilir. İlişkilendirme işlemi bind metoduyla yapılmaktadır. Client 
    program bind işlemini yapmak zorunda değildir. Bu durumda client programın yarattığı soket connect işlemi sırasında işletim sistemi 
    tarafından boş bir portla ilişkilendirilir. İşletim sisteminin client soket için bağlantı sırasında otomatik atadığı porta İngilizce 
    "ephemeral port" denilmektedir. Genel olarak client'ın bağlanmada kullanacağı soketin port numarasının bir önemi yoktur. Ancak 
    bazı server'lar ya da router'lar kaynak port numarası konusunda bazı koşullar oluşturabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bağlanma işlemi socket sınıfının connect metoduyla yapılmaktadır. connect metodu iki elemanlı bir demeti parametre olarak alır. 
    Demetin birinci elemanı server'ın IP adresini, ikinci elemanı port numarasını içermelidir. IPV4'te IP adresleri 4 byte'tır. Bu 
    4 byte "dotted decimal format" denilen noktalarla ayrılmış bir yazı biçiminde verilebilir. Örneğin '5.25.161.169' gibi. IP protokol 
    ailesinde anımsanması kolay olsun diye host'lara aynı zamanda isimler de (host name) karşılık düşürülmüştür. Ancak protokol her 
    zaman IP numaralarıyla işletilmektedir. Internet içerisinde host'lara karşı gelen IP numaraları DNS (Domain Name Server) denilen 
    server'ların veritabanlarında tutulmaktadır. Dolayısıyla eğer biz bir host ismini biliyorsak DNS serverler'ına başvurarak onun 
    IP adreslerini elde edebiliriz.  DNS işlemleri için IP protokol ailesinde DNS isimli bir protokol kullanılmaktadır. Tabii 
    programcıların bu DNS protokolünü bilmesine gerek yoktur. Soket sınıfının gethostbyname, gethostbyaddress, getaadrinfo gibi 
    metotları DNS işlemlerini kendi içerisinde yapmaktadır. Aslında connect metoduna parametre olarak geçtiğimiz demetin birinci 
    elemanına IP adresi yerine doğrudan host ismi de verebiliriz. Bu durumda connect önce DNS işlemini yapar, host ismini IP adresine 
    dönüştürür ondan sonra bağlantı kurmaya çalışır. DNS veritabanlarında host ismiyle IP numaraları birebir bir ilişki içerisinde 
    değildir. Bir host ismi birden fazla IP numarasıyla ilişkilendirilebileceği gibi bir IP numarası birden fazla host ismiyle  
    ilişkilendirilebilmektedir.   

    IPV4'te 127.0.0.1 adresi özel bir IP adresidir. Bu adrese "loopback address" de denilmektedir. Bu IP adresi biz hangi host'ta 
    çalışıyorsak o host'un IP adresi anlamına gelir. Windows, UNIX/Linux ve macOS sistemlerinde bulunduğumuz makinenin host 
    ismi "localhost" ile de temsil edilmektedir. 

    Biz connect metodunu çağırdığımızda o anda bizim bağlantımızı kabul edecek bir server programın çalışıyor olması gerekir. Aksi 
    takdirde belli bir zaman aşımından (timeout) sonra exception oluşacaktır. Benzer biçimde server program çalıştığı halde listen 
    metodunda belirtilen accept kuyruğu o anda dolmuş da olabilir. Bu durumda connect metodu belli bir süre bekler. Zaman aşımından 
    dolayı olur ve exception oluşur. 
#------------------------------------------------------------------------------------------------------------------------------------

#server.py 

import socket

PORT_NO = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
        server_sock.bind(('', PORT_NO))
        server_sock.listen(8)
        
        print('waiting for client...')
        client_sock, (client_addr, client_port) = server_sock.accept()
        with client_sock:
            print(f'connected with client {client_addr}:{client_port}')

            # send/recv işlemleri

            client_sock.shutdown(socket.SHUT_RDWR)
except OSError as e:
    print(e)

# client.py 

import socket

SERVER_NAME = 'localhost'
SERVER_PORT = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
        client_sock.connect((SERVER_NAME, SERVER_PORT))
        print('connected...')

        # send/recv işlemleri

        client_sock.shutdown(socket.SHUT_RDWR)
except OSError as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Aslında istenirse client programda da bind işlemi yapılabilir. Bu durumda biz belli bir kaynak porttan hedef makineye bağlanabiliriz.
    Ancak genel olarak zorunlu olmadıkça client program bind yapmamalıdır. Bu durumda işletim sistemi client sokete connect işlemi 
    sırasında boş bir port numarası (buna "ephemeral port" dendiğini anımsayınız) atayacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

import socket

PORT_NO = 50500

try:
    client_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP)
    client_sock.bind(('', 3006))
    client_sock.connect(('localhost', PORT_NO))
    print('connected...')

    # send/recv işlemleri
    client_sock.shutdown(SHUT_RDWR)
    client_sock.close()
    
except OSError as oserr:
    print(oserr)
 
#------------------------------------------------------------------------------------------------------------------------------------
    Soketler "full duplex" bir haberleşme sunarlar. Yani client ile server eş zamanlı olarak birbirlerine bilgi gönderip alabilirler. 
    Bilgi göndermek için socket sınıfının send metodu bilgi almak için ise recv metodu kullanılmaktadır. Her iki metot da "byte" 
    temelinde çalışmaktadır. 
    
    send metoduna biz bir bytes nesnesi veririz. (Anımsanacağı gibi bytes nesneleri bir grup byte'ı temsil etmektedir.) recv metodu 
    da bize okunan byte'ları bytes nesnesi olarak vermektedir. send metodu network tamponuna yazılan byte sayısı ile geri döner. recv 
    metodu da okuyabildiği byte'lardan bytes nesnesi yaparak bize o nesneyi geri verir. Biz send metodu ile n byte göndermek istediğimizde 
    send metodu eğer network tamponunda (yani yerel makinedeki gönderme tamponunda) en az 1 byte yer varsa tampona yazabildiği kadar 
    byte'ı yazar ve yazabildiği byte sayısına geri döner. Yani biz send metodu ile n byte göndermek istediğimizde aslında daha az 
    byte göndermiş olabiliriz. Bunu send metodunun geri dönüş değeri ile anlayabiliriz. send metodu eğer network tamponunda hiç boş 
    yer yoksa en az 1 byte newtwork tamponuna yazana kadar blokede bekler. send metodu geri döndüğünde gönderilmek istenen bilgilerin
    en az 1 byte'ı network tamponuna yazılmıştır. Ancak bu durum network tamponuna yazılan bilgilerin karşı tarafa gönderildiği anlamına 
    gelmez. send metodu gönderilecekleri network tamponuna yazar ve hemen geri döner. Network tamponundaki bilgilerin TCP/IP paketi 
    olarak gönderilmesi belli bir süre sonra (tabii çok uzun bir süre değil) işletim sistemi tarafından yapılmaktadır. Örneğin:

    buf = b'\x01\x02\x\03'
    result = sock.send(buf)

    Burada send ile 3 byte gönderilmek istanmiştir. send metodu eğer network tamponunda hiç boş yer yoksa en az 1 byte yer açılana kadar 
    blokede bekler. Örneğin network tamponunda 2 byte boş yer olsun. Bu durumda send metodu 3 byte'ı değil iki byte'ı yazarak 2 değeri 
    ile geri dönecektir. 

    recv metodu eğer network tamponunda hazırda bulunan hiçbir byte yoksa en az 1 byte okuyana kadar blokede beklemeye yol açar. Eğer 
    network tamponunda okunmak için bekleyen en az bir byte bilgi varsa recv parametresiyle belirtilen miktarda byte'ın hepsini okuyana 
    kadar bloke oluşturmaz. Okuyabildiği kadar byte'ı okur hemen geri döner. Eğer karşı taraf soketi shutdown ya da close ile kapatmışsa 
    recv boş bir bytes nesnesine geri dönmektedir. Yani recv metodunun boş bir bytes nesnesi ile geri dönmesi başarısızlıktan dolayı 
    değil karşı tarafın soketi kapattığından dolayıdır. Nihayet recv metodu bağlantının kopması gibi anormal olaylar karşısında exception 
    fırtlatmaktadır. Örneğin:
      
    buf = sock.recv(100)

    Burada biz 100 byte okumak istiyoruz. Eğer okunacak hiçbir byte yoksa recv en az bir byte okuyana blokede bekler. O sırada örneğin 
    porta 5 byte gelmiş olsun. Bu durumda recv bu 5 byte'ı okur. 5 byte'tan oluşan bir bytes nesnesi ile geri döner. Yani recv metodunun 
    parametresinde belirttiğimiz byte sayısı en fazla okunacak byte'ı belirtmektedir. 

    TCP/IP'de önemli bir noktayı vurgulamak istiyoruz: Bir tarafın tek bir send ile gönderdiği bilgiyi karşı taraf tek bir recv ile 
    okumak zorunda değildir. Biz tek bir send ile 1000 byte bilgi göndermiş olabiliriz. Bu bilgi network tamponundan iki ayrı IP paketi 
    olarak paketlenerek gönderilmiş olabilir. Bu paketlerden biri hedefe geldiğinde recv hemen bunu okuyup 1000 byte'ın bir kısmını 
    elde etmiş olabilir. Böylece tek hamlede send ile gönderilen bilgi tek recv ile değil birden fala recv ile okunabilir. 
    
    Aşağıdaki örnekte client program server'a bağlanıp ve ona çeşitli yazılar göndermektedir. (Tabii soketten bir yazı gönderilmek 
    istenirse yazının önce bytes nesnesine dönüştürülmesi gerekir. Benzer biçimde elde edilen bytes nesnesi de yeniden yazıya 
    dönüştürülebilir. Bir string'in bytes nesnesine dönüştürülmesi için str sınıfının encode metodu, bytes nesnesinin string'e 
    dönüştürülmesi için ise bytes sınıfının decode metodu kullanılabilir.) Server bu yazıları ters çevirip client'a geri yollamaktadır.
    Bu tür test amacıyla oluşturulmuş server programlara "echo server" da denilmektedir.  
#------------------------------------------------------------------------------------------------------------------------------------

# server.py

import socket

PORT_NO = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
        server_sock.bind(('', PORT_NO))
        server_sock.listen(8)
        
        print('waiting for client...')
        client_sock, (client_addr, client_port) = server_sock.accept()
        with client_sock:
            print(f'connected with client {client_addr}:{client_port}')
            while True:
                b = client_sock.recv(1000)
                if b == b'':
                    break
                s = b.decode(encoding='utf-8')
                print(s)
                if s == 'quit':
                    break
                client_sock.send(s[::-1].encode(encoding='utf-8'))
          
            client_sock.shutdown(socket.SHUT_RDWR)
except OSError as e:

# client.py 

import socket

SERVER_NAME = '127.0.0.1'
SERVER_PORT = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
        client_sock.connect((SERVER_NAME, SERVER_PORT))
        print('connected...')
        
        while True:
            s = input('Bir yazı giriniz:')
            n = client_sock.send(s.encode(encoding='utf-8'))
            print(f'{n} bytes sent')
            if s == 'quit':
                break
            b = client_sock.recv(1000)
            if b == b'':
                break
            print(b.decode('utf-8'))
         
        client_sock.shutdown(socket.SHUT_RDWR)
except OSError as e:
    print(e)
 
#------------------------------------------------------------------------------------------------------------------------------------
                                                    65. Ders 09/11/2025 – Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii client ile server programların aynı dilde yazılması gerekmez. Çünkü dil ne olursa olsun aslında arka planda aynı protokol 
    aynı kurallara göre işletilmektedir. 

    Aşağıdaki örnekte client program C#'ta server program Python'da yazılmıştır. 
#------------------------------------------------------------------------------------------------------------------------------------

# server.py 

import socket

PORT_NO = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
        server_sock.bind(('', PORT_NO))
        server_sock.listen(8)
        
        print('waiting for client...')
        client_sock, (client_addr, client_port) = server_sock.accept()
        with client_sock:
            print(f'connected with client {client_addr}:{client_port}')
            while True:
                b = client_sock.recv(1000)
                if b == b'':
                    break
                s = b.decode(encoding='utf-8')
                print(s)
                if s == 'quit':
                    break
                client_sock.send(s[::-1].encode(encoding='utf-8'))
          
            client_sock.shutdown(socket.SHUT_RDWR)
except OSError as e:
    print(e)
    
// Client.cs 

using System;
using System.Net;
using System.Net.Sockets;
using System.Text;

namespace CSD
{
    class App
    {
        static readonly string SERVER_NAME = "127.0.0.1";

        static void Main()
        {
           
            string text, response;
            byte[] b, buf = new byte[1024];
            int n;

            try
            {
                Socket clientSock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                clientSock.Connect(new IPEndPoint(IPAddress.Parse(SERVER_NAME), 55555));
                Console.WriteLine("Connected...");

                for (; ; )
                {
                    Console.Write("Bir yazı giriniz:");
                    text = Console.ReadLine();
                    b = Encoding.UTF8.GetBytes(text);
                    clientSock.Send(b);
                    if (text == "quit")
                        break;
                    n = clientSock.Receive(buf);
                    response = Encoding.UTF8.GetString(buf, 0, n);
                    Console.WriteLine(response);
                }
                clientSock.Shutdown(SocketShutdown.Both);
                clientSock.Close();
            }
            
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }

        }
    }
}

#------------------------------------------------------------------------------------------------------------------------------------
    Yerel makinede deneyerek çalıştırdığımız client ve server programları Internet ağında da aynı biçimde çalıştırabiliriz. Eğer 
    evinizde bir server program bulundurmak istiyorsanız bazı bilgilere sahip olmasınız:

    - Biz evimizde bir yerel ağa (Local Area Network (LAN)) saihbiz. Evimiz içindeki yerel ağı ayrı bir network olarak düşünebilirsiniz.
    Evimizdeki bilgisayarların IP numaraları "yerel IP (local IP)" numarasına sahiptir. Biz evimizdeki yerel ağı Internet'e tek bir
    router ile bağlamaktayız. Bizim evimizin Internet'teki adresi bu router'ımızın IP adresidir. Yani evimizde birkaç bilgisayarımız 
    olsa da biz Internet ortamında sanki tek bir host gibi görünmekteyiz. Router'ımızın Internet'teki IP adresi çeşitli biçimlerde 
    elde edilebilir. Bunun basit bir yolu tarayıcıdan "whatismyip.com" sitesine girip bakmaktır. Ancak maalesef servis sağlayıcılar  
    bize hep aynı IP adresini atamamaktadır. Dolayısıyla "whatismyip.com" sitesinden elde edeceğiniz IP adresleri zamanla değişebilecektir. 
    Bu tür IP adreslerine "dinamik IP adresleri" denilmektedir. Servis sağlayıcının bize hep aynı IP adresine vermesini istiyorsanız 
    servis sağlayıcınızla statik IP için görüşmelisiniz. Ancak servis sağlayıcılar bu işlemi aylık ücret karşılığında yapmaktadır. 
    Statik IP'nin en önemli faydası client programların hep IP adresi ile server'larınıza erişebilmesidir. Internet hizmeti veren 
    hosting firmaları zaten hep statik IP vermektedir. 

    - Evimizde bir server oluştururken dikkat edeceğimiz bir nokta da "port yönlendirmesi (port forwarding)" yapmaktır. Dış dünyadan 
    bizim evimizdeki server'a bağlanmak isteyen kişiler bizim rouer IP adresini kullanacaklardır. Oysa server'ımız yerel ağdadır ve onun
    yerel IP'si vardır. İşte bu durumda router'a gelen bağlantı isteklerinin router tarafından yerel ağdaki bilgisayarımıza yönlendirilmesi
    gerekir. Buna port yönlendirmesi denilmektedir. Poer yönlendirmesi yapabilmek için tarayıcıdan router'a erişmek gerekir. Genellikle 
    router adresi yerel ağda "192.168.1.1" biçimindedir. Ancak artık servis sağlayıcılar port yönlendirmesi için statik IP'yi zorunlu
    tutmaktadır. Tabii bir hosting şirketinden VPS ya da "dedicated server" kiralamışsanız böyle port yönlendirmesini yapmanıza gerek 
    kalmayacaktır. Zaten bu tür hosting hizmeti veren şirketler VPS ve "dedicated server'lar" için statik IP adresleri vermektedir.                                          
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de çok client'lı server uygulamaları üzerinde duralım. 
    
    Çok client'lı server uygulamalarında server her client için döngü içerisinde accept uygulamalıdır. Ancak çok client'lı server 
    uygulamalarında önemli problem şudur: Server bir client ile bağlandığı zaman onunla nasıl konuşacaktır? Tek bir akış söz konusu 
    olduğunda server yeniden accept metodunda beklerken bloke oluşacağından dolayı daha önce bağlanmış olduğu client'lar ile konuşamaz. 
    Benzer biçimde tek bir akışlı bir çalışmada bir client için recv yapıldığında eğer o client bir bilgi göndermemişse akış bu sefer 
    de recv metodunda bloke olur. Sonuç olarak tek bir akışla birden fazla client ile konuşmak mümkün olmaz. O zaman ilk akla gelecek 
    yöntem her client için bağlantı yapıldıktan sonra yeni bir thread yaratmak ve o client ile o thread'in konuşmasını sağlamaktır. 
    Böylece bir thread bloke olsa bile diğer thread'ler bundan etkilenmezler. Çok client'lı server uygulamalarında çeşitli modeller 
    kullanılabilmektedir. Thread modeli basitliği nedeniyle bazı uygulamalarda tercih edilir. Ancak thread modelinin de bazı önemli 
    dezavantajları vardır. 

    Burada CPython yorumlayıcısındaki accept metodunun gerçekleştirimi hakkında bir noktaya değinmek istiyoruz. CPython gerçekleştiriminde
    accept metodu çeşitli sinyalleri bloke etmektedir. Dolayısıyla akış accet metodunda beklerken Ctrl+C tuşlarıyla program sonlandırılmak 
    istenirse bu sonlandırma gerçekleşmektedir. Bunu sağlamanın bir yolu sokete bir "zaman aşımı (timeout)" değeri vermektir. Sokete 
    zaman aşımı verilirse accept en fazla bu zaman aşımı kadar bekler, zaman aşımı oluşursa socket.timeout türü ile raise işlemi yapılır. 
    Bu sırada sinyal blokesi çözüleceği için accpet Ctrl+C gibi tuşlarla kesilebilmektedir. Sokete zaman aşımı socket sınıfının settimeout 
    metodu ile verilebilmektedir. Örneğin:

    server_sock.settimeout(1.0)   

    Aşağıdaki programda server için thread modeli uygulanmıştır. Her bağlantı sağlandığında yeni bir thread yaratılmış ve soket 
    bilgileri bu yeni thread'e parametre yoluyla aktarılmıştır. Programdaki accept döngüsü şöyledir:

    def main():
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
                server_sock.bind(('', PORT_NO))
                server_sock.listen(8)
                server_sock.settimeout(1.0)             
                print('waiting for clients...')
                while True:
                    try:
                        client_sock, (client_addr, client_port) = server_sock.accept()
                        print(f'connected with client {client_addr}:{client_port}')
                        thread = threading.Thread(target=client_proc, args=(client_sock, client_addr, client_port))
                        thread.start()              
                    except socket.timeout:
                        continue                
        except OSError as e:
            print(e)

    Burada her bağlantıdan sonra yeni bir thread yaratıldığına ve bağlanılan client ile o thread kullanılarak konuşulduğuna dikkat 
    ediniz. Thread fonksiyonu şöyle yazılmıştır

    def client_proc(sock, addr, port):
        try:
            with sock:
                while True:
                    b = sock.recv(1000)
                    if b == b'':
                        break
                    msg = b.decode(encoding='utf-8')
                    print(f'Message from {addr}:{port} =>  {msg}')
                    if msg == 'quit':
                        break
                    sock.send(msg[::-1].encode(encoding='utf-8'))    
                sock.shutdown(socket.SHUT_RDWR)
        except OSError as e:
            print(e)
#------------------------------------------------------------------------------------------------------------------------------------

# server.py 

import socket
import threading

PORT_NO = 55555

def main():
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
            server_sock.bind(('', PORT_NO))
            server_sock.listen(8)
            server_sock.settimeout(1.0)             
            print('waiting for clients...')
            while True:
                try:
                    client_sock, (client_addr, client_port) = server_sock.accept()
                    print(f'connected with client {client_addr}:{client_port}')
                    thread = threading.Thread(target=client_proc, args=(client_sock, client_addr, client_port))
                    thread.start()              
                except socket.timeout:
                    continue                
    except OSError as e:
        print(e)

def client_proc(sock, addr, port):
    try:
        with sock:
            while True:
                b = sock.recv(1000)
                if b == b'':
                    break
                msg = b.decode(encoding='utf-8')
                print(f'Message from {addr}:{port} =>  {msg}')
                if msg == 'quit':
                    break
                sock.send(msg[::-1].encode(encoding='utf-8'))    
            sock.shutdown(socket.SHUT_RDWR)
    except OSError as e:
        print(e)

main()


# client.py

import socket

SERVER_NAME = '127.0.0.1'
SERVER_PORT = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
        client_sock.connect((SERVER_NAME, SERVER_PORT))
        print('connected...')
        
        while True:
            s = input('Bir yazı giriniz:')
            n = client_sock.send(s.encode(encoding='utf-8'))
            print(f'{n} bytes sent')
            if s == 'quit':
                break
            b = client_sock.recv(1000)
            if b == b'':
                break
            print(b.decode('utf-8'))
         
        client_sock.shutdown(socket.SHUT_RDWR)
except OSError as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------------------
    Client'larla konuşmak için thread'ler yerine proseslerden de faydalanabiliriz. Daha önceki konularda da bahsettiğimiz gibi genel 
    olarak prosesler GIL yüzünden thread'lere göre daha iyi performans gösterebilmektedir. Aşağıda çok client'lı uygulama için proses
    modeline bir örnek verilmiştir. Anımsanacağı gibi zaten multiprocessing modülünün kullanımı threading modülüne oldukça benzemektedir. 
    Dolayısıyla biz thread örneğinde küçük değişikliklerle aşağıdaki proses örneğini oluşturduk. 
#------------------------------------------------------------------------------------------------------------------------------------

# server.py

import socket
import multiprocessing

PORT_NO = 55555

def main():
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
            server_sock.bind(('', PORT_NO))
            server_sock.listen(8)
            server_sock.settimeout(1.0)             
            print('waiting for clients...')
            while True:
                try:
                    client_sock, (client_addr, client_port) = server_sock.accept()
                    print(f'connected with client {client_addr}:{client_port}')
                    thread = multiprocessing.Process(target=client_proc, args=(client_sock, client_addr, client_port))
                    thread.start()              
                except socket.timeout:
                    continue                
    except OSError as e:
        print(e)

def client_proc(sock, addr, port):
    try:
        with sock:
            while True:
                b = sock.recv(1000)
                if b == b'':
                    break
                msg = b.decode(encoding='utf-8')
                print(f'Message from {addr}:{port} =>  {msg}')
                if msg == 'quit':
                    break
                sock.send(msg[::-1].encode(encoding='utf-8'))    
            sock.shutdown(socket.SHUT_RDWR)
    except OSError as e:
        print(e)

main()
 
# client.py

import socket

SERVER_NAME = '127.0.0.1'
SERVER_PORT = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
        client_sock.connect((SERVER_NAME, SERVER_PORT))
        print('connected...')
        
        while True:
            s = input('Bir yazı giriniz:')
            n = client_sock.send(s.encode(encoding='utf-8'))
            print(f'{n} bytes sent', flush=True)
            if s == 'quit':
                break
            b = client_sock.recv(1000)
            if b == b'':
                break
            print(b.decode('utf-8'), flush=True)
         
        client_sock.shutdown(socket.SHUT_RDWR)
except OSError as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Bir soket nesnesinden o soketi gören bir dosya nesnesi elde edilebilir. Burada "o soketi gören" demekle o dosya nesnesi ile işlem 
    yapıldığında aslında ilgili soketle işlem yapıldığını" anlatmak istiyoruz. Soketten dosya nesnesi elde etmek için socket sınıfının 
    makefile isimli metodu kullanılmaktadır. makefile metodunun ilgili parametreleri built-in open fonksiyonun parametreleri gibidir. 
    makefile metodu tek parametreyle çağrılabilir. Bu durumda bu parametre dosyanın açış modunu belirtir. Ancak buradaki açış modu
    yalnızca 'r', 'w', 'rb', 'wb' modlarından biri olmak zorundadır. Buradan elde edien dosya nesnesi yine close edilmelidir. Ancak 
    bu nesnenin close edilmesi socket nesnesinin close edilmesi anlamına gelmez. socket nesnesi ayrıca close edilmelidir. Benzer 
    biçimde socket nesnesinin close edilmesi de bu dosya nesnesinin close edileceği anlamına da gelmemektedir. 

    Peki soket için makefile ile dosya nesnesi oluşturmanın ne faydası vardır? İşte normal soket ile ancak send ve recv metotlarını 
    kullanabiliriz. Bu metotlar da byte nesneleriyle çalışmaktadır. Halbuki dosya nesnelerinin kullanımı daha esnektir. Ancak Python'da 
    text dosyalar (yani 'b' belirtilmeden oluşturulan dosyaların) tamponlu çalışmaktadır. Bunun için dosya nesnesinin üzerinde 
    flush uygulanması gerekebilmektedir. 

    Aslında dosyalarda biz dosyaya birşeyler yazdığımızda bu yazılanlar önce bir tamponda biriktirilip tampon dolduğunda asıl hedefe 
    aktarılmaktadır. Bunun nedeni gerçek disk işlemlerinin azaltılmak istenmesidir. İşte makefile ile sokete ilişkin bir dosya nesnesi
     elde ettiğimizde bu dosya nesnesi ile write yapıldığında yazılmak istenenler arka planda hemen send işlemi ile soketten gönderilmemektedir. 
     Bunlar önce bir tamponda biriktirilip tampon dolduğunda gönderilmektedir. Biz yazılanların hemen gönderilmesini istiyorsak write 
     işleminden sonra flush metodunu çağırmalıyız. flush işlemi tamponda birikenleri o anda hedefe aktarmaktadır. Tabii dosya nesnesi 
     kapatıldığında kapatma sırasında da flush işlemi yapılmaktadır. 

    Aşağıdaki örnekte makefile metodu ile sanki soket bir dosyaymış gibi işlemler yaoılmıştır. Bir dosyadan readline okuma yapıldığında 
    '\n' karakteri görülene kadar okuma yapıldığını anımsayınız. readline netodu '\n' karakterini de yazının eklemektedir. Örneğimizdeki
    slient program şöyle yazılmıştır:

    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
            client_sock.connect((SERVER_NAME, SERVER_PORT))
            print('connected...')
            
            with client_sock.makefile('r') as fr, client_sock.makefile('w') as fw:
                while True:
                    s = input('Bir yazı giriniz:')
                    fw.write(s + '\n')
                    fw.flush()
                    if s == 'quit':
                        break
                    s = fr.readline()
                    if s == '':
                        break
                    print(s, end='')
                
            client_sock.shutdown(socket.SHUT_RDWR)
    except OSError as e:
        print(e)
    
    Burada socket sınıfının makefile metodu ile soketi gören fr ve fw isimli iki dosya nesnesi oluşturulmuştur. with deyimi 
    bittiğinde bu dosya nesneleri de otomatik close edilecektir. Sokete yazma işleminin artık send ile değil write ile yapıldığına 
    dikkat ediniz:

    s = input('Bir yazı giriniz:')
    fw.write(s + '\n')
    fw.flush()

    Karşı taraf okumayı readline metodu ile yapacağından yazılacak bilgiye '\n' karakteri de eklenmiştir. Yazımdan sonra flush 
    işlemi yapıdığına dikkat ediniz. Okuma ilemi de readline metodu ile şöyle yapılmıştır:

    s = fr.readline()
    if s == '':
        break
    print(s, end='')
    
    Server programdaki mesajlaşma işlemi yine client_proc fonksiyonu tarafından şöyle yapılmaktadır:

    def client_proc(sock, addr, port):
        try:
            with sock, sock.makefile('r') as fr, sock.makefile('w') as fw:
                while True:
                    msg = fr.readline()
                    if msg == '':
                        break
                    msg = msg[:-1]
                    print(f'Message from {addr}:{port} =>  {msg}', end='', flush=True)
                    if msg == 'quit':
                        break
                    fw.write(msg[::-1] + '\n')    
                    fw.flush()
                sock.shutdown(socket.SHUT_RDWR)
        except OSError as e:
            print(e)

    Burada da yine soketi gören fr ve fw nesneleri yaratılmıştır. Yine okuma readline metodu ile yazma da write fonksiyonu ile
    yapılmıştır. Okumadan elde edilen yazının sonundaki '\n' karakterinin atıldığına dikkat ediniz:

    msg = msg[:-1]
#------------------------------------------------------------------------------------------------------------------------------------

# server.py 

import socket
import multiprocessing

PORT_NO = 55555

def main():
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
            server_sock.bind(('', PORT_NO))
            server_sock.listen(8)
            server_sock.settimeout(1.0)             
            print('waiting for clients...')
            while True:
                try:
                    client_sock, (client_addr, client_port) = server_sock.accept()
                    print(f'connected with client {client_addr}:{client_port}')
                    thread = multiprocessing.Process(target=client_proc, args=(client_sock, client_addr, client_port))
                    thread.start()              
                except socket.timeout:
                    continue                
    except OSError as e:
        print(e)

def client_proc(sock, addr, port):
    try:
        with sock, sock.makefile('r') as fr, sock.makefile('w') as fw:
            while True:
                msg = fr.readline()
                if msg == '':
                    break
                msg = msg[:-1]
                print(f'Message from {addr}:{port} =>  {msg}', end='', flush=True)
                if msg == 'quit':
                    break
                
                fw.write(msg[::-1] + '\n')    
                fw.flush()
            sock.shutdown(socket.SHUT_RDWR)
    except OSError as e:
        print(e)

main()

# client.py

import socket

SERVER_NAME = '127.0.0.1'
SERVER_PORT = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
        client_sock.connect((SERVER_NAME, SERVER_PORT))
        print('connected...')
        
        with client_sock.makefile('r') as fr, client_sock.makefile('w') as fw:
            while True:
                s = input('Bir yazı giriniz:')
                fw.write(s + '\n')
                fw.flush()
                if s == 'quit':
                    break
                s = fr.readline()
                if s == '':
                    break
                print(s, end='')
             
        client_sock.shutdown(socket.SHUT_RDWR)
except OSError as e:
    print(e)
    r as e:
    print(e)   
        
#------------------------------------------------------------------------------------------------------------------------------------
    Bir soketten bir satır (yani '\n' görene kadar) bilgi okumak sanıldığı kadar kolay değildir. Çünkü TCP protokolünde bir tarafın 
    send ile gönderdiği bilgileri diğer tarafın tek bir recv ile okuması garanti değildir. Bunlar karşı tarafa farklı TCP paketleri 
    ile iletilebilir. Dolayısıyla okuyan taraf bir satırlık bilgiyi birden fazla recv ile okumak zorunda kalabilir. Aynı zamanda 
    gönderen taraf da birden fazla satırı peş peşe gönderdiğinde alan taraf da bunu tek bir recv ile alabilir. Yani TCP'de birden 
    fazla send işlemi tek bir recv ile de alınabilmektedir. İşte bu nedenlerden dolayı bir satırlık bilginin etkin bir biçimde 
    okunması o kadar kolay bir işlem değildir. Tabii recv metodu ile her defasında birer karakter soketten okunarak bir satır bilgi 
    okunabilir. Ancak bu da yavaş bir yöntemdir dolayısıyla etkin değildir. 
    
    İşte makefile metodu sayesinde soketten bir satır okumak oldukça kolaydır. Çünkü makefile bize bir dosya nesnesi verir. O dosya 
    nesnesi üzerinde readline metodunu uyguladığımızda zaten bu okuma işlemi readline tarafından etkin bir biçimde yapılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Client/Server uygulama geliştirirken client'ın isteklerini server'a iletmesi, server'ın istenilenleri yapması ve sonucu client'a 
    iletmesi gerekir. İşte client ile server arasındaki bu mesajlaşmalar temelde iki biçimde yapılmaktadır:

    1) Yazısal (text) biçiminde
    2) Binary biçimde (yani byte düzeyinde)

    Byte düzeyinde (binary) mesajlaşma daha hızlıdır. Ancak daha zordur ve manuel işlemler için (örneğin telnet gibi bir ortam) uygun 
    olmayabilir. Bu nedenle yazısal mesajlaşmalar daha çok tercih edilmektedir. Gerçekten de IP protokol ailesinin uygulama katmanındaki 
    POP3, SMTP, FTP, TELNET, HTTP gibi protokolleri hep metinsel biçimde mesajlaşma uygulamaktadır. Biz de kursumuzda metinsel 
    mesajlaşmalara ilişkin örnekler vereceğiz. Metinsel mesajlaşmalarda client ve server birbirlerine "bir satırlık" yazılar göndererek 
    mesajlaşmayı sağlarlar. Gerçekten de IP protokol ailesinin uygulama katmanındaki protokoller böyle birer satırlık bilgilerin 
    gönderilip alınması biçiminde mesajlaşma uygulamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                        66.Ders 15/11/2025 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Dört işlem yapan çok client'lı bir client/server uygulama yazmak isteyelim. Bu tür uygulamalar yazılırken önce bir "uygulama 
    katmanı protokolünün tasarlanması" gerekir. Yani client server'a nasıl istekte bulunacak, server bunu nasıl yanıtlayacak? Burada 
    mesajlaşmalar nasıl olacak? Bunların belirlenmesi gerekir. Server'lardan herkesin hizmet alamaması için bir user name/password 
    mekanizmasının oluşturulması ve login işleminin yapılması gerekebilir. TCP/IP'de connect ve accept işlemleriyle fiziksel bağlantı 
    sağlanmaktadır. Client'ın server'a fiziksel biçimde bağlanması ondan hizmet alabileceği anlamına gelmez. Server'ın hizmet vermesi 
    için bir "login" mekanizmasının mantıksal biçimde oluşturulması gerekir. Bu login mekanizmasına "mantıksal bağlanma" da diyebiliriz. 
    Böyle bir uygulamanın protokolü aşağıdaki gibi olabilir:

    Client'tan Server'a Gönderilen Mesajlar:

    "LOGIN <user name> <password>\n"
    "LOGOUT\n"
    "ADD <op1> <op2>\n"
    "SUB <op1> <op2>\n"
    "MUL <op1> <op2>\n"
    "DIV <op1> <op2>\n"
    
    Server'dan Client'a Gönderilen Mesajlar:

    "LOGIN_ACCEPTED\n"
    "ERROR <text>\n
    "RESULT <value>\n"
    "LOGOUT_ACCEPTED\n"

    Genel olarak bu tür protokollerde client'ın her mesajına karşılık server da client'a bir mesaj yollamaktadır. Eğer client geçersiz 
    bir mesaj yollarsa ya da client'ın isteği yerine getirilemezse bizim bu örneğimizde server client'a "ERROR hata_mesajı\n" biçiminde 
    yazı gönderecektir. Bu tür protokollerde mesajlaşmalar yazısal düzeyde yapılıyor olsa da gönderilen bu yazılar parse edilerek 
    istenen bilgi yazıların içerisinden alınmaktadır. 

    Aşağıda böyle bir program örneği verilmiştir. Örneğimizde client'lara ilişkin "user name" ve" password" bilgileri "credentials.csv"
    dosyası içerisinde tutulmaktadır. Bu dosyanın içeriği "credentials.csv" şöyle olabilir:

    user_name,password
    kaan,maviay
    ali,ankara
    ahmet,istanbul

    Bu CSV dosyasında her satırda ilgili kullanıcının kullanıcı adı ve parolası bulunmaktadır. Tabii uygulamada aslında kullanıcıların 
    parolalarının kendisi doğrudan dosyalarda bu biçimde saklanmamalıdır. Kullanıcıların parolaları şifrelendikten sonra onların 
    şifrelenmiş halleri dosyalarda saklanmalıdır. Böyle bir sistemde kullanıcı login olurken kullanıcının parolası yeniden şifrelenir 
    ve iki şifrelenmiş parolanın eşitliğine bakılır. Yani normal olarak aslında server'larda bizim parolalarımızın tutulmaması gerekir. 
    Örneğimizdeki client program çalıştırıldığında önce klavyeden kullanıcı adı ve parola istenmektedir. Sonra server bunu doğrularsa 
    client server'a mantıksal olarak bağlanmış olur. Ondan sonra client program "Calc>" biçiminde bir prompt'a düşer. Bu prompt'ta 
    protokolde belirtilen biçimde komutlar yazı olarak gönderilmiştir. Server gelen yazı da ekrana yazdırılmıştır. Örneğin:

    user name:ali
    password:ankara
    connected to calc server...
    Calc>ADD 3 2
    RESULT 5.0
    Calc>XXX
    ERR invalid command syntax
    Calc>quit

    Client programda "quit" yazıldığında client ptogram server'a "LOGOUT\n" mesajını göndererek programı sonlandırmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

# calc-server.py

import socket
import multiprocessing
import csv

CREDENTIALS_CSV='credentials.csv'
PORT_NO = 55555

credentials  = {}

def main():
    global credentials
    
    try:
        credentials = read_credentials(CREDENTIALS_CSV)
        
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
            server_sock.bind(('', PORT_NO))
            server_sock.listen(8)
            server_sock.settimeout(1.0)             
            print('waiting for clients...')
            while True:
                try:
                    client_sock, (client_addr, client_port) = server_sock.accept()
                    print(f'connected TCP with client {client_addr}:{client_port}')
                    thread = multiprocessing.Process(target=client_proc, args=(client_sock, client_addr, client_port))
                    thread.start()              
                except socket.timeout:
                    continue                
    except OSError as e:
        print(e)
    except Exception as e:
        print(e)

def read_credentials(path):
    with open(path) as f:
        f.readline()
        return {key: value for key, value in csv.reader(f)}
        
def client_proc(sock, addr, port):
    try:
        with sock, sock.makefile('r') as fr, sock.makefile('w') as fw:
            if not login_client(fr, fw):
                fw.write('ERR invalid user name or password\n')
                fw.flush()
                sock.shutdown(socket.SHUT_RDWR)
                return
                
            while True:
                msg = fr.readline()
                if msg == '':
                    break
                msg = msg[:-1]
                print(f'Message from {addr}:{port} =>  {msg}', end='', flush=True)
                proc_msg(fr, fw, msg)
                
                fw.flush()
            sock.shutdown(socket.SHUT_RDWR)
    except OSError as e:
        print(e)

def login_client(fr, fw):
    msg = fr.readline()
    if msg == '':
        return False
    msg = msg[:-1]
    args = msg.split()
    
    if len(args) != 3:
        return False
    if args[0] != 'LOGIN':
        return False
    user_name, password = args[1:]
    if msg == '':
        return False
    if credentials.get(user_name) != password:
        print(f'client {user_name} login rejected...', flush=True)
        return False
    fw.write('LOGIN_ACCEPTED\n')
    fw.flush()
    print(f'client {user_name} loggin in...', flush=True)
    return True
        
def proc_msg(fr, fw, msg):
    try:
        args = msg.split()
        if len(args) != 3:
            fw.write('ERR invalid command syntax\n')
            fw.flush()
            return 
        val1 = float(args[1])
        val2 = float(args[2])
        
        match args[0]:
            case 'ADD':
                result = val1 + val2
            case 'MUL':
                result = val1 * val2
            case 'SUB':
                result = val1 - val2
            case 'DIV':
                result = val1  / val2
            case 'LOGOUT':
                fw.write('LOGOUT_ACCEPTED"\n')
                fw.flush()
            case _:
                fw.write(f'ERR invalid command "{args[0]}"\n')
                fw.flush()
                
        fw.write(f'RESULT {result}\n')
        fw.flush()
                        
    except ValueError as e:
        fw.write(f'ERR {e}\n')
        fw.flush()
        
main()

# calc-client.py

import socket

SERVER_NAME = '127.0.0.1'
SERVER_PORT = 55555

def main():
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
            client_sock.connect((SERVER_NAME, SERVER_PORT))       
            
            with client_sock.makefile('r') as fr, client_sock.makefile('w') as fw:
                if not login_server(fr, fw):
                   print('invalid user name or password')
                   return
               
                print('connected to calc server...')
                while True:
                    cmd = input('Calc>')
                    if cmd == 'quit':
                        logout_server(fr, fw)
                        break
                    fw.write(cmd + '\n')
                    fw.flush()
                    s = fr.readline()
                    if s == '':
                        break
                    print(s, end='')
                 
            client_sock.shutdown(socket.SHUT_RDWR)
    except OSError as e:
        print(e)
     
def login_server(fr, fw):
    user_name = input('user name:')
    password = input('password:')
    fw.write(f'LOGIN {user_name} {password}\n')
    fw.flush()
    s = fr.readline()[:-1]
    if s != 'LOGIN_ACCEPTED':
        return False
    return True

def logout_server(fr, fw):
    fw.write('LOGOUT\n')
    fw.flush()
    s = fr.readline()[:-1]
    if s != 'LOGOUT_ACCEPTED':
        return False
    return True
     
main()

# credentials.cvs

user_name, password
kaan,maviay
ali,ankara

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte client program protokoldeki komut yazısını değil doğrudan matematik işlemin kendisini almaktadır. Örneğin:

    User name:kaan
    Password:maviay
    Logged in...
    Calc>3 + 2
    5.0
    Calc>5 * 3
    15.0
    Calc>logout
    Logged out

    Bu program yukarıdakinden biraz daha değişik yazılmıştır. Programda server programda mesajları işlemek için proses yernine thread'ler
    kullanılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

# server.py 

import socket
import threading
import csv

PORT_NO = 50500

users = {}

def main():
    try:
        with open('credentials.csv') as f, socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP) as server_sock:
            for t in csv.reader(f):
                if len(t) != 2:
                    continue
                user_name, password = t
                users[user_name] = password
                
            server_sock.bind(('', PORT_NO))
            server_sock.listen(8)
        
            print('waiting for connection...')
            while True:
                (client_sock, (client_addr, client_port)) = server_sock.accept()
                print(f'connected with client {client_addr}:{client_port}...')
                
                client_thread = threading.Thread(target=client_thread_proc,  args=(client_sock, client_addr, client_port))
                client_thread.start()
                
    except OSError as oserr:
        print(oserr)
            
def client_thread_proc(client_sock, client_addr, client_port):
    try:
        with client_sock, client_sock.makefile('r') as fr, client_sock.makefile('w') as fw:
            if not login_proc(fr, fw):
                client_sock.shutdown(socket.SHUT_RDWR)
                return
     
            while True:
                cmd = fr.readline()
                if cmd == '':
                    break
                cmd = cmd[:-1]
                print(f'Command from {client_addr}({client_port}): {repr(cmd)}')
                
                if not process_cmd(fw, cmd):
                    break
        client_sock.shutdown(socket.SHUT_RDWR)
            
    except OSError:
        pass
    finally:
        print(f'{client_addr}:{client_port} disconnected...')

def process_cmd(fw, cmd):
    cmd_dict = {'ADD': add_proc, 'SUB': sub_proc, 'MUL': mul_proc, 'DIV': div_proc, 'LOGOUT': logout_proc}
    
    params = cmd.split()
    
    if params and (proc := cmd_dict.get(params[0])):
        return proc(fw, cmd, params)
    
    fwrite(fw, f'ERROR Invalid command "{cmd}"\n')    
        
    return True
  
def login_proc(fr, fw):
    cmd = fr.readline()[:-1]
    params = cmd.split()
    if len(params) != 3 or params[0] != 'LOGIN':
        fwrite(fw, f'ERROR Invalid command "{cmd}"\n')
        return False
    
    password = users.get(params[1])
    if  password and password == params[2]:
        fwrite(fw, 'LOGIN_ACCEPTED\n')
        print(f'{params[0]} logged in...')
        return True
    else:
        fwrite(fw, 'ERROR Invalid user name or password\n')
        return False
                 
def add_proc(fw, cmd, params):
    if len(params) != 3:
        fwrite(fw, f'ERROR Invalid command: "{cmd}"\n')
        return True
    
    try:
        val1 = float(params[1])
        val2 = float(params[2])
        result = val1 + val2
        fwrite(fw, f'RESULT {result}\n')
    except ValueError:
        fwrite(fw, f'ERROR incorrect argument: "{cmd}"\n')
        
    return True

def sub_proc(fw, cmd, params):
    if len(params) != 3:
        fwrite(fw, f'ERROR Invalid command: "{cmd}"\n')
        return True
    
    try:
        val1 = float(params[1])
        val2 = float(params[2])
        result = val1 - val2
        fwrite(fw, f'RESULT {result}\n')
    except ValueError:
        fwrite(fw, f'ERROR incorrect argument: "{cmd}"\n')
        
    return True

def mul_proc(fw, cmd, params):
    if len(params) != 3:
        fwrite(fw, f'ERROR Invalid command: "{cmd}"\n')
        return True
    
    try:
        val1 = float(params[1])
        val2 = float(params[2])
        result = val1 * val2
        fwrite(fw, f'RESULT {result}\n')
    except ValueError:
        fwrite(fw, f'ERROR incorrect argument: "{cmd}"\n')
        
    return True
        
def div_proc(fw, cmd, params):
    if len(params) != 3:
        fwrite(fw, f'ERROR Invalid command: "{cmd}"\n')
        return True
    
    try:
        val1 = float(params[1])
        val2 = float(params[2])
        
        if val2 == 0:
            fwrite(fw, f'ERROR Divider shall not be zero: "{cmd}"\n')
            return True
        result = val1 / val2
        fwrite(fw, f'RESULT {result}\n')
    except:
        fwrite(fw, f'ERROR incorrect argument: "{cmd}"\n')
        
    return True
        
def logout_proc(fw, cmd, params):
    if len(params) != 1:
        fwrite(fw, f'ERROR Invalid command: "{cmd}"\n')
        return True
    
    fwrite(fw, 'LOGOUT_ACCEPTED\n')
    print('{params[0]} logged out...')
    
    return False
    
def fwrite(fw, text):
    fw.write(text)
    fw.flush()

main()

# client.py

import socket
import re

PORT_NO = 50500
SERVER = 'localhost'

def main():
    cmd_dict = {'ERROR': error_proc, 'RESULT': result_proc, 'LOGOUT_ACCEPTED': logout_accepted_proc}
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM, socket.IPPROTO_TCP) as client_sock:
            client_sock.connect((SERVER, PORT_NO))
            with client_sock.makefile('r') as fr, client_sock.makefile('w') as fw:
                if not login_proc(fr, fw):
                    return
                
                while True:
                    cmd_text = input('Calc>').strip()
                    if cmd_text != 'logout':    
                        result, operand1, operand2, operator = parse_input(cmd_text)
                        if not result:
                            print('Invalid input!')
                            continue
                        optext = {'+': 'ADD', '-': 'SUB', '*': 'MUL', '/': 'DIV'}[operator]
                        msg = f'{optext} {operand1} {operand2}\n'
                    else:
                        msg = 'LOGOUT\n'
                        param = None
                    
                    fwrite(fw, msg)
                    
                    response = fr.readline()
                    if not response:
                        break
                    cmd, param = parse_cmd(response)
                    proc = cmd_dict.get(cmd)
                    if not proc:
                        print('Invalid server command: {cmd}')
                        continue
                    if not proc(param):
                        break
                        
            client_sock.shutdown(socket.SHUT_RDWR)
    
    except OSError as oserr:
        print(oserr)
    
def login_proc(fr, fw):
    user_name = input('User name:')
    password = input('Password:')
    
    fwrite(fw, f'LOGIN {user_name} {password}\n')
    response = fr.readline()
    cmd, param = parse_cmd(response)
    
    if cmd != 'LOGIN_ACCEPTED':
        print(f'Error message form server: {param}')
        return False
    
    print('Logged in...')
    
    return True

def error_proc(param):
    match = re.search(':\s*(".*")', param)
    
    msg_text = param[: match.start()]
    msg_cmd = match[1]
    
    print(f'Error message from server: {msg_text} ({msg_cmd})')
    return True
    
def result_proc(param):
    print(param)
    return True
    
def logout_accepted_proc(param):
    print('Logged out')
    return False

def fwrite(fw, text):
    fw.write(text)
    fw.flush()

def get_input(cmd):
    pass

def parse_cmd(s):    
    k = 0
    while k < len(s) and s[k].isspace():
        k += 1
        
    if k == len(s):
        return '', ''
        
    i = k
    while i < len(s) and not s[i].isspace():
        i += 1
    
    cmd = s[k:i]
    if i == len(s):
        return cmd, ''
    
    while i < len(s) and s[i].isspace():
        i += 1
    
    param = s[i:]
    
    return cmd, param.strip()

def parse_input(cmd):
    i = 0
    while i < len(cmd) and '+-*/'.find(cmd[i]) == -1:
        i += 1
        
    if i == len(cmd):
        return False, None, None, None
    
    op1 = cmd[:i].strip()
    op2 = cmd[i + 1:].strip()
    op = cmd[i]
    
    try:
        float(op1)
        float(op2)
    except:
        return False, None, None, None
    
    return True, op1, op2, op
        
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Çok client'lı server uygulamalarında aynı anda birden fazla client ile konuşabilmek için thread ya da process modelinin dışında 
    çeşitli başka modeller de  kullanılabilmektedir. Biz yukarıdaki çok client'lı server örneklerimizin birincisinde process modelini 
    ikincisinde thread modelini kullandık. Ancak thread ya da proses modelleri basit olmasına karşın bazı handikapları olan modellerdir. 
    Çok sayıda client söz konusu olduğunda çok fazla sayıda threda ya da prosesin yaratılması ciddi bir sistem kaynağının harcanmasına 
    yol açmaktadır. Bu nedenle client sayısının fazla olduğu durumlarda thread ve proses modelleri uygun model olmaktan çıkmaktadır.  
    
    Thread ve proses modellerinin dışındaki modeller de yine işletim sisteminin desteği ile sağlanmaktadır. Genel olarak işletim sistemlerinde 
    buna benzer IO modellerine "asenkron IO (asynchronous IO) ve multiplexed IO modelleri" denilmektedir. Asenkron IO modelleri işletim 
    sisteminden işletim sistemine değişebilmektedir. Çünkü bu konu işletim sisteminin çekirdek gerçekleştirimi ile ilgilidir. Bazı modeller 
    birden fazla işletim sisteminde onların çekirdekleri tarafından gerçekleştirilmiş durumdadır.

    - Windows sistemlerinde asenkron IO işlemleri için "Overlapped IO", "IO Completion Port" ve "select" modelleri kullanılabilmektedir. 
    Bunlar arasında Windows için en uygun ve en etkin model "IO Completion Port" denilen modeldir. 

    - Linux sistemlerinde "select" modeli, "poll" modeli, "epoll"  modeli ve "asyncio" modeli kullanılabilmektedir. Ancak en yüksek 
    performans "epoll" modelinden elde edilmektedir. 

    - FreeBSD sistemlerinde "select", "poll" ve "asyncio" modellerinin yanı sıra "kqueue" modeli de kullanılmaktadır. 

    - macOS sistemlerinde de "select" modeli, "poll" modeli ve "kqueue" modelleri kullanılabilmektedir. 

    Python standart kütüphanesinde "select" isimli modülde yukarıdaki asenkron IO modellerinin hepsi bulunmaktadır. Ancak bu modeller
    işletim sisteminin çekirdeğine bağlı olduğu için her işletim sisteminde kullanılamamaktadır. Örneğin epoll modeli Linux için 
    uygun bir model olduğu için  bu model Windows sistemlerinde ya da macOS sistemlerinde bulunmamaktadır. Bu bakımdan nispeten en 
    taşınabilir olan model "select" modelidir. Ancak Python standart kütüphanesinde bu aşağı seviyeli asenkron IO modellerini kullanan 
    daha yüksek seviyeli "selectors" denilen bir modül de vardır. Biz kursumuzda önce aşağı seviyeli "select" modeli hakkında bilgiler 
    vereceğiz. Sonra da yüksek seviyeli "selectors" modelini tanıtacağız. En sonunda da aynı işlemlerin Python diline eklenen "coroutine" 
    mekanizmasıyla gerçekleştirilmesini göreceğiz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    select modelinde işletim sisteminin "select" isimli bir sistem fonksiyonu bulunur. Programcı bu select fonksiyonuna birden fazla
    soketi verir. (Tabii aslında select fonksiyonu yalnızca soketlerle değil pek çok aygıtla çalışabilmektedir.) select fonksiyonu 
    bu soketleri izler. Eğer soketlerde hiçbir IO olayı yoksa select fonksiyonu thread'i blokede bekletir. Ancak soketlerden en az 
    birinde bir olay olmuşsa (buradaki olay tipik olarak sokete okunacak bilgi gelmesidir) select blokeyi çözer. Böylece select 
    fonksiyonu geri döner. Programcı da hangi soketlerde hangi olayların olduğunu sorgular ve artık bloke oluşmadan işlemlerini yapar. 
    Sonra yeniden select fonksiyonunu çağırır. Yani select fonksiyonu bir döngü içerisinde çağrılmaktadır. Buradaki olay "okuma", 
    "yazma" ya da "exception" işlemleri olabilir. 

    Python'da select modeli şöyle kullanılır:

    1) Bir döngü içerisinde select modülündeki select fonksiyonu çağrılır. Bu fonksiyon tipik olarak üç parametre almaktadır. 
    Fonksiyonun birinci parametresi okuma olayı için izlenecek soket listesini, ikinci parametresi yazma olayı için izlenecek soket 
    listesini, üçüncü parametre ise exception oluşturan eylemler için izlenecek soket listesini belirtir. Genellikle programcılar 
    yalnızca okuma işlemiyle ilgilenirler. Dolayısıyla yalnızca fonksiyonun birinci parametresi için liste oluştururlar. İkinci 
    ve üçüncü parametreye boş liste girerler. (Biz burada liste demekle herhangi dolaşılabilir bir nesneyi kastediyoruz. Fonksiyonun 
    bu üç parametresine askında herhangi bir dolaşılabilir nesne girilebilmektedir.) Fonksiyona isteğe bağlı olarak bir zaman aşımı 
    değeri de son parametrede girilebilmektedir. Bu durumda fonksiyon soketlerin hiçbirinde bir olay gerçekleşmemişse en kötü olasılıkla 
    burada belirtilen saniye kadar sonra blokeyi çözer. Bu parametrenin girilmemesi zaman aşımı uygulanmayacağı anlamına gelmektedir. 
    Fonksiyonun birinci parametresindeki listeye dinleme soketi (pasif soket) de eklenebilir. Bu durumda bu sokete bir bağlantı isteği 
    geldiğinde bu istek sanki bir okuma olayı gibi değerlendirilmektedir. Programcılar genellikle işin başında bu okuma listesine dinleme 
    soketini yerleştirmektedir. select fonksiyonu üçlü bir demete geri döner. Bu demetin birinci elemanı okuma olayı gerçekleşen soketlerin 
    listesini bize verir. Örneğin biz select fonksiyonun birinci parametresine 50 tane soket vermiş olalım. Bunların iki tanesine bilgi 
    gemiş olsun. Şimdi select fonksiyonunun geri döndürdüğü demetin ilk elemanında bu iki soket bulunacaktır. Yani biz bunlardan okuma 
    yapmak istersek artık bloke oluşmayacaktır. Demetin ikinci elemanı yazma olayı gerçekleşen soketleri, üçüncü elemanı ise exception 
    olayı gerçekleşen soketleri belirten listelerdir. Tabii programcı yazma ve exception için zaten boş liste vermişse demetin bu 
    elemanları da boş liste olacaktır. Çrneğin:

    read_sockets, _, _ = select.select(client_sockets, [], [])

    2) select fonksiyonu geri döndüğünde programcı olaya yol açan soketleri gözden geçirerek uygun işlemleri yapmalıdır. Örneğin tipik 
    olarak biz soketleri okuma amaçlı izliyorsak bilgi gelen soketler üzerinde recv fonksiyonunu uygulamalıyız. Burada önemli bir nokta 
    dinleme soketi üzerinde okuma olayının gerçekleşip gerçekleşmediğinin sorgulanmasıdır. Eğer dinleme soketi üzerinde okuma olayı 
    gerçekleşmişse bu durum yeni bir client'ın bağlanma isteğini belirtmektedir. Bu durumda bizim dinleme soketi ile accept işlemini 
    yapmamız ve bağlantıdan elde ettiğimiz soketi yeniden okuma olay listesine dahil etmemiz gerekir. 

    3) Bir client soketi kapattığında bu olay da select fonksiyonunda sanki okuma olayı gibi ele alınmaktadır. Tabii bu soketten 
    okuma yapıldığında artık 0 byte okunacak yani recv metodu boş bytes nesnesi ile geri dönecektir. Programcının da bu durumda 
    artık o soketi okuma listesinden çıkarması gerekir.  

    Windows'ta select fonksiyonu sinyalleri bloke etmektedir. Dolayısıyla Windows'ta akış select fonksiyonuna geldiğinde klavyeden 
    Ctrl+C tuşlarına basıldığında server program sonlandırılamamaktadır. Ancak Linux sistemlerinde böyle bir sorun yoktur. Windows
    sistemlerinde bu durumu savuşturmal için select fonksiyonuna küçük bir zaman aşımı verebilirsiniz. Böylece select belli süre 
    bekleyip sonlanır. Sinyal blokesi çözülüp klavyeden basılan Ctrl+C tuşları etki gösterir. 

    Aşağıdaki örnekte aşağı seviyeli select modelinin örnek uygulaması görülmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

# server.py

import socket
import select

PORT_NO = 55555

def main():
    client_sockets = []
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
            server_sock.bind(('', PORT_NO))
            server_sock.listen(8)
            print('waiting for clients...')
            client_sockets.append(server_sock)
            while True:
                read_sockets, _, _ = select.select(client_sockets, [], [])
                for sock in read_sockets:
                    if sock == server_sock:
                        client_sock, (ipaddr, port) = sock.accept()
                        print(f'connected with client {ipaddr}:{port}')
                        client_sockets.append(client_sock)
                        continue
                    b = sock.recv(1024)
                    if b == b'':
                        sock.close()
                        client_sockets.remove(sock)
                        continue
                    s = b.decode(encoding='utf-8')
                    s = s[::-1]
                    sock.send(s.encode(encoding='utf-8'))
                                    
    except OSError as e:
        print(e)

main()

# client.py 

import socket

SERVER_NAME = '127.0.0.1'
SERVER_PORT = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
        client_sock.connect((SERVER_NAME, SERVER_PORT))
        
        print('connected...')
        while True:
            s = input('Bir yazı giriniz:')
            if s == 'quit':
                break
            client_sock.send(s.encode(encoding='utf-8'))
            b = client_sock.recv(1024)
            if b == b'':
                break
            s = b.decode(encoding='utf-8')
            print(s)
             
        client_sock.shutdown(socket.SHUT_RDWR)
        
except OSError as e:
    print(e)
        
#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda verdiğimiz örnekte recv işlemi uyguladığımızda okunan byte'ların mantıksal olarak hangi client'a ilişkin olduğunu 
    bilmemekteyiz. Bu tür durumlarda bağlanan her client için bir veri yapısı oluşturulup onun bilgileri o veri yapısında saklanabilir. 
    Burada bilgilerin bir sözlük içerisinde bulundurulması uygun olacaktır. Sözlüğün anahtarı soket nesnesinden oluşturulur. (Soket 
    nesneleri hashable nesnelerdir.) Bunların değerleri de client bilgilerinden oluşturulabilir. 

    Aşağıdaki örnekte bir client bağlantısı sağlandığında client'ın bilgileri sözlüğe soket anahtar yapılarak ikili demet biçiminde 
    yerleştirilmiş ve sonra soket bilgisi anahtar yapılarak client bilgileri elde edilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

# server

import socket
import select

PORT_NO = 55555

def main():
    client_sockets = []
    client_info = {}
        
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
            server_sock.bind(('', PORT_NO))
            server_sock.listen(8)
            print('waiting for clients...')
            client_sockets.append(server_sock)
            while True:
                read_sockets, _, _ = select.select(client_sockets, [], [])
                for sock in read_sockets:
                    if sock == server_sock:
                        client_sock, (ipaddr, port) = sock.accept()
                        print(f'connected with client {ipaddr}:{port}')
                        client_sockets.append(client_sock)
                        client_info[client_sock] = (ipaddr, port)
                        continue
                    b = sock.recv(1024)
                    if b == b'':
                        sock.close()
                        client_sockets.remove(sock)
                        continue
                    s = b.decode(encoding='utf-8')
                    print(f'Message received from {ipaddr}:{port} => "{s}"')
                    s = s[::-1]
                    ipaddr, port = client_info[sock]
                    sock.send(s.encode(encoding='utf-8'))                 
                                    
    except OSError as e:
        print(e)

main()

# client.py

import socket

SERVER_NAME = '127.0.0.1'
SERVER_PORT = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
        client_sock.connect((SERVER_NAME, SERVER_PORT))
        
        print('connected...')
        while True:
            s = input('Bir yazı giriniz:')
            if s == 'quit':
                break
            client_sock.send(s.encode(encoding='utf-8'))
         
            b = client_sock.recv(1024)
            if b == b'':
                break
            s = b.decode(encoding='utf-8')
            print(s)
             
        client_sock.shutdown(socket.SHUT_RDWR)
        
except OSError as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Python'da asenkron soket işlemlerini kolaylaştırmak için kendi içlerinde "select", "poll", "epoll", "kqueue" gibi asenkron IO 
    modellerini kullanan ancak ilgili olay gerçekleştiğinde programcının belirlediği fonksiyonu çağıran daha yüksek seviyeli ismine 
    "selectors" denilen bir modül de bulundurulmuştur. Bu modüldeki SelectSelector arka planda "select" modelini, EPollSelector arka 
    planda "epoll" modelini, PollSelector arka planda "poll" modelini ve KqueueSelector ise arka planda "kqueue" modelini kullanmaktadır. 
    Ayrıca bir de modülde DefaultSelector isimli bir sınıf da vardır. Bu sınıf ilgili sistemdeki en uygun selektör nesnesini seçip 
    kullanmaktadır. Bütün Selector sınıflarının kullanım biçimleri aynıdır. Biz burada en uygun seçenek olan DefaultSelctor nesnesini 
    kullanacağız. Selector nesnelerinin kullanımı şöyledir:

    1) Programcı önce selector nesnesini yaratır. Yukarıda da belirttiğimiz gibi bu nesne tipik olarak DefaultSelector sınıfıyla 
    yaratılmalıdır. Örneğin:

    selector = selectors.DefaultSelector()
    
    2) Programcı bir soket üzerinde olay gerçekleştiğinde çağrılmasını istediği fonksiyonu selector sınıflarının register metotları 
    ile register ettirir. Selector sınıflarının register metotları üç parametreden oluşmaktadır. Birinci parametre izlenecek soketi belirtir. 
    İkinci parametre izlenecek olayı belirtmektedir. Bu olay selectors.EVENT_READ, selectors.EVENT_WRITE ya da selectors.EVENT_READ|
    selectors.EVENT_WRITE biçiminde girilebilir. Yine dinleme soketi üzerinde okuma olayının takip edilmesi aslında yeni bağlantı 
    isteklerinin takip edilmesi anlamına gelmektedir. register  metodunun üçüncü parametresi sonraki maddede açıklanacak olan Selector 
    nesnesiyle çağrılan select metodunun geri döndürdüğü SelectorKey isimli sınıf nesnesinin data örnek özniteliğinden elde edeilecek 
    olan bilgiyi belirtir. Bu üçüncü parametre bir fonksiyon olarak da girilebilir. Bu parametre default olarak None değerini almaktadır. 
    Örneğin:

    selector.register(server_sock, selectors.EVENT_READ)

    Burada dinleme soketş okuma amaçlı (yani bağlanı amaçlı) izlenmektedir. 
    
    3) Programcının bir döngü içerisinde selector nesnesinin select metodunu çağırması gerekir. Bu metot yine eğer register ettirilen 
    soketlerin hiçbirinde bir olay gerçekleşmemişse blokede thread'i bekletir. Ancak bu soketlerden en az birinde bir olay gerçekleşmişse 
    geri dönmektedir. select metodunun geri dönüş değeri iki elemanlı demetlerden oluşan bir listedir. Bu listede gerçekleşen olaylara 
    ilişkin bilgiler bulunmaktadır. Listeyi oluşturan demetlerin birinci elemanı SelectorKey isimli bir sınıf türünden bir nesnesidir. 
    Bu demetin ikinci elemanı ise mask elemanıdır. Bu mask elemanı bize olayın türünü vermektedir. Bu olay selectors.EVENT_READ, 
    selectors.EVENT_WRITE ya da bunların her ikisi olabilir. Programcı bu listeyi dolaşıp SelectorKey nesnelerinin içerisinden şu 
    bilgileri alabilir:

    fileobj: Bu örnek özniteliği register fonksiyonuna girilen izlenecek soketi belirtmektedir.
    events: register fonksiyonuna girilen ikinci parametreyi belirtir. 
    data: register metoduna girilen üçüncü parametreyi belirtmektedir. 

    Programcı accept işleminden elde ettiği soketi de yine register ettirerek izlemeye dahil etmelidir. Örneğin:

    client_info = {}

    while True:
        select_list = selector.select()
        for key, mask in select_list:
            if mask & selectors.EVENT_READ:      # bu programda gerek yok
                if key.fileobj == server_sock:
                    client_sock, (ipaddr, port) = server_sock.accept()
                    print(f'connected with client {ipaddr}:{port}')
                    selector.register(client_sock, selectors.EVENT_READ)
                    client_info[client_sock] = (ipaddr, port)
                    continue
                # ....   

    4) Bir client soketin kapatılması yine bir okuma işlemi gibi değerlendirilmektedir. Bu durumda programcının client soketi kapatıp
    onu izlemeden çıkartması gerekir. İzlemeden çıkartma işlemi için Selector sınıflarının unregister metotları kullanılmaktadır. 
    Bu metodun parametresi izlemeden çıkartılacak soketi belirtir. 

    5) İşlem bitince selector nesnesi sınıfın close metoduyla kapatılır. Selector sınıfları da bağlam yönetim protokolünü desteklemektedir.

    Aşağıdaki Selector sınıflarının kullanımına bir örnek verilmiştir. Burada register fonksiyonun üçüncü parametresini hiç kullanmadık.
    İzleyen paragrafta bu üçüncü parametrenin naısl kullanılacağına yönelik bir örnek de verilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

# server.py 

import socket
import selectors

PORT_NO = 55555

def main():
    client_info = {}
        
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
            server_sock.bind(('', PORT_NO))
            server_sock.listen(8)
            print('waiting for clients...')
            
            with selectors.DefaultSelector() as selector:
                selector.register(server_sock, selectors.EVENT_READ)
                while True:
                    select_list = selector.select(timeout=0.5)
                    for key, mask in select_list:
                        if mask & selectors.EVENT_READ:      # bu programda gerek yok
                            if key.fileobj == server_sock:
                                client_sock, (ipaddr, port) = server_sock.accept()
                                print(f'connected with client {ipaddr}:{port}')
                                selector.register(client_sock, selectors.EVENT_READ)
                                client_info[client_sock] = (ipaddr, port)
                                continue
                            b = key.fileobj.recv(1024)
                            if b == b'':
                                print(f'{ipaddr}:{port} is closing...')
                                key.fileobj.close()
                                selector.unregister(key.fileobj)
                                continue
                            s = b.decode(encoding='utf-8')
                            ipaddr, port = client_info[key.fileobj]
                            print(f'Message received from {ipaddr}:{port} => "{s}"')
                            s = s[::-1]
                            key.fileobj.send(s.encode(encoding='utf-8'))           
    except OSError as e:
        print(e)

main()

# client.py 

import socket

SERVER_NAME = '127.0.0.1'
SERVER_PORT = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
        client_sock.connect((SERVER_NAME, SERVER_PORT))
        
        print('connected...')
        while True:
            s = input('Bir yazı giriniz:')
            if s == 'quit':
                break
            client_sock.send(s.encode(encoding='utf-8'))
         
            b = client_sock.recv(1024)
            if b == b'':
                break
            s = b.decode(encoding='utf-8')
            print(s)
             
        client_sock.shutdown(socket.SHUT_RDWR)
        
except OSError as e
    
#------------------------------------------------------------------------------------------------------------------------------------
    Selector sınıflarının register metotlarının üçüncü parametresine çağrılabilen (callable) girilebilir. Bu durumda ilgili olay 
    gerçekleştiğinde biz bu fonksiyonu SelectorKey nesnesinin data özniteliğinden alabiliriz. Böylece hemen o fonksiyonu çağırabiliriz. 
    Kodumuzu biraz daha kompakt hale getirebiliriz. Örneğin:

    with selectors.DefaultSelector() as selector:
        selector.register(server_sock, selectors.EVENT_READ, accept_proc)
        while True:
            select_list = selector.select()
            for key, mask in select_list:
                if mask & selectors.EVENT_READ:      # bu programda gerek yok
                    key.data(selector, key.fileobj) 
    
    Burada SelectorKey nesnesinin data özniteliği için accept_proc fonksiyonu girilmiştir. Bir bağlantı gerçekleştğinde bu fonksiyonun 
    çağrılması sağlanmıştır. Bu fonksiyon içerisinde de bağlanılan soket izlemeye alınmış ve onun için de başka bir fonksiyon 
    girilmiştir:

    def accept_proc(selector, sock):
        client_sock, (ipaddr, port) = sock.accept()
        print(f'connected with client {ipaddr}:{port}')
        selector.register(client_sock, selectors.EVENT_READ, receive_proc)
        client_info[client_sock] = (ipaddr, port)

    Buradaki receive_proc fonksiyonu da şöyledir:

    def receive_proc(selector, sock):
        b = sock.recv(1024)
        ipaddr, port = client_info[sock]
        if b == b'':
            print(f'{ipaddr}:{port} is closing...')
            sock.close()
            selector.unregister(sock)
            return
        s = b.decode(encoding='utf-8')
        ipaddr, port = client_info[sock]
        print(f'Message received from {ipaddr}:{port} => "{s}"')
        s = s[::-1]
        sock.send(s.encode(encoding='utf-8'))  

    Kodu bir bütün olarak aşağıda veriyoruz.    
#------------------------------------------------------------------------------------------------------------------------------------

# server.py 

import socket
import selectors

PORT_NO = 55555

client_info = {}
  
def main():   
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
            server_sock.bind(('', PORT_NO))
            server_sock.listen(8)
            print('waiting for clients...')
            
            with selectors.DefaultSelector() as selector:
                selector.register(server_sock, selectors.EVENT_READ, accept_proc)
                while True:
                    select_list = selector.select(timeout=0.5)
                    for key, mask in select_list:
                        if mask & selectors.EVENT_READ:      # bu programda gerek yok
                            key.data(selector, key.fileobj) 
    except OSError as e:
        print(e)
        
def accept_proc(selector, sock):
    client_sock, (ipaddr, port) = sock.accept()
    print(f'connected with client {ipaddr}:{port}')
    selector.register(client_sock, selectors.EVENT_READ, receive_proc)
    client_info[client_sock] = (ipaddr, port)
    
def receive_proc(selector, sock):
    b = sock.recv(1024)
    ipaddr, port = client_info[sock]
    if b == b'':
        print(f'{ipaddr}:{port} is closing...')
        sock.close()
        selector.unregister(sock)
        return
    s = b.decode(encoding='utf-8')
    ipaddr, port = client_info[sock]
    print(f'Message received from {ipaddr}:{port} => "{s}"')
    s = s[::-1]
    sock.send(s.encode(encoding='utf-8'))      

main()

# client.py

import socket

SERVER_NAME = '127.0.0.1'
SERVER_PORT = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
        client_sock.connect((SERVER_NAME, SERVER_PORT))
        
        print('connected...')
        while True:
            s = input('Bir yazı giriniz:')
            if s == 'quit':
                break
            client_sock.send(s.encode(encoding='utf-8'))
         
            b = client_sock.recv(1024)
            if b == b'':
                break
            s = b.decode(encoding='utf-8')
            print(s)
             
        client_sock.shutdown(socket.SHUT_RDWR)
        
except OSError as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    IP protokol ailesindeki ve genel olarak Inter dünyasındaki protokoller "RFC (Request for Comment)" denilen dokümanlarla tanımlanmaktadır. 
    Her protokolün tanımlandığı bir RFC numarası vardır. Tabii protoklerrin de versiyonları söz konusudr. Dolayısıyla aynı protokole 
    ilişkin birden çok RFC bulunabilmektedir. Örneğin POP3 ptotokolünün resmi dokümanaları RFC 1939 dıkğmanında açıklanmıştır. RFC'ler
    Internet'in idaresinde rol alan "IETF (Internet Engibeering Task Force)" isimli kurum tarafından işletilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de IP prtokol ailesinin bazı uygulama katmanı protolleri üzerinde duralım. E-postaları almak için POP3 (Post Office Protocol 
    Version 3) ve IMAP (Internet Message Access Protocol) denilen iki protokol kullanılmaktadır. E-posta okumak için kullanılan programlar
    genellikle her iki protokolü de desteklemektedir. POP3 daha basit bir protokoldür. E-posta göndermek içinb ise SMTP (Send Message 
    Transfer Protocol) denilen protokol kullanılmaktadır. Bir e-postanın gönderilip alınması aşağıdaki süreçlerle gerçekleşmektedir:

    1) Bunun için bir e-posta sunucu programının bulunuyor olması gerekir. Eğer tüm sistemi siz kuruyorsanız bu sunucuyu (server) 
    da sizin kurmanız gerekmektedir. Zaten Windows sistemlerinde, UNIX/Linux sistemlerinde bu sunucular hazır biçimde bulunmaktadır.
    Tabii eğer domain hizmetini aldığınız bir kurum varsa onlar da zaten e-posta hizmeti vermek için hazır e-posta sunucuları 
    bulundurmaktadır. E-posta gönderebilmek için ya da e-posta alabilmek için bizim e-posta sunucumuzun adresini biliyor olmamız 
    gerekir. Gönderme işleminde kullanılacak sunucu ile alma işleminde kullanılacak sunucu farklı olabilmektedir. Örneğin CSD'nin 
    e-posta sunucuna "mail.csystem.org" adresiyle erişilebilmektedir. Bu sunucu hem gönderme hem de alma işlemini yapmaktadır. 
    E-posta gönderebilmek için client ptogram ile server program "SMTP (Simple Mail Transfer Protocol)" denilen bir protokolle
    haberleşmektedir. O halde gönderim için bizim kendi e-posta sunucumuza bağlanarak SMTP protokolü ile göndereceğimiz e-postayı 
    ona iletmemiz gerekir.

    2) Biz göndereceğimiz e-postayı SMTP protokolü ile e-posta sunucumuza ilettikten sonra bu sunucu hedef e-posta sunucusuna bu 
    e-postayı yine SMTP protokolü ile iletmektedir. E-postayı alan sunucu bunu bir posta kutusu (mail box) içerisinde saklar. 

    3) Karşı taraftaki client program POP3 ya da IMAP protokolü ile kendi e-posta sunucuna bağlanarak posta kutusundaki e-postayı 
    yerel makineye indirir. 

    client ---SMTP---> e-posta sunucusu ---SMTP--> e-posta sunucusu ---POP3/IMAP---> client

    Görüldüğü gibi POP3 ve IMAP protokolleri e-posta sunucusunun posta kutusundaki zaten gelmiş ve saklanmış olan e-postaları yerel 
    makineye indirmek için kullanılmaktadır. Özetle biz göndermek istediğimiz e-postayı doğrudan karşı tarafa göndermeyiz. Önce onu
    kendi sunucumuza iletiriz. Bizim sunucumuz onu karşı tarafın sunucusuna iletir. Karşı taraftaki kullanıcı da e-postayı kendi 
    sunucusundan yerel makinesine indirir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    POP3 protokolü RFC 1939 dokümanlarında açıklanmıştır. RFC 1939 dokğmanlarına aşağıdaki bağlantıdan erişebilirsiniz:

    https://www.rfc-editor.org/rfc/rfc1939
        
    Protokol kabaca şöyle işlemektedir:

    1) Client program 110 numaralı (ya da 995 numaralı) porttan e-posta sunucusuna TCP ile fiziksel olarak bağlanır. 

    2) Protokoldeki mesajlaşma tamamen text tabanlı ve satırsal biçimde yapılmaktadır. Satırlar CR/LF karakterleriyle sonlandırılmaktadır. 
    Protokolde client'ın gönderdiği her komuta karşı server bir yanıt göndermektedir. (Fiziksel bağlantı sağlandığında da server 
    bir onay mesajı göndermektedir.) Eğer yanıt olumluysa mesaj "+OK" ile olumsuzsa mesaj "-ERR" ile başlatılmaktadır. Yani server'ın 
    client'a gönderdiği mesajın genel biçimi şöyledir:

    +OK [diğer bilgiler] CR/LF
    -ERR [diğer bilgiler] CR/LF

    POP3 protokol komutlarınde büyük harf küçük harf duyarlılığı yoktur. Ancak genellikle büyük harfler tercih edilmektedir. 

    3) Fiziksel bağlantı sağlandıktan sonra client program mantıksal olarak server'a login olmalıdır. Login olmak için önce "user name" 
    sonra da "password" gönderilmektedir. User name ve password gönderme işlemi aşağıdaki iki komutla yapılmaktadır:

    "USER <user name> CR/LF"
    "PASS <password> CR/LF"

    Kullanıcı adı e-posta adresiyle aynıdır. Örneğin biz "test@csystem.org" için e-posta sunucusuna bağlanıyporsak buradaki kullanıcı 
    ismi "test qcsystem.org" olacaktır. Parola e-postalarınızı okumak için kullandığınız paroladır. Sisteme başarılı bir biçimde login 
    olduğumuzu varsayıyoruz. Tipik olarak server bize şu mesajı iletecektir:

    +OK Logged in.

    password yanlış girilmişse yeniden öce user name ve sonra password gönderilmelidir. 
    
    4) Client program LIST komutunu göndererek e-posta kutusundaki mesaj bilgilerini elde eder. LIST komutuna karşılık server önce aşağıdaki
    gibi bir satır gönderir:

    +OK 6 messages:

    Burada server e-posta kutusunda kaç e-posta olduğunu belirtmektedir. Sonra her e-postaya bir numarara vererek onların byte uzunluklarını 
    satır satır iletir. Komut yalnızca '.' içeren bir satırla son bulmaktadır. Örneğin:

    +OK 6 messages:
    1 1565
    2 5912
    3 11890
    4 4920
    5 9714
    6 4932
    .

    5) Belli bir e-posta RETR komutuyla elde edilmektedr. Bu komuta elde edilecek e-postanın index numarası girilir. Örneğin:

    "RETR 2 CR/LF"

    RETR komutuna karşı server önce aşağıdaki gibi bir satır gönderir:

    +OK 5912 octets

    Burada programcı bu satırı parse ederek belirtilen miktarda byte kadar soketten okuma yapmalıdır. Anımsanacağı gibi porttan 
    tam olarak n byte okuma TCP'de tek bir recv ile yapılamamaktadır.   

    6) Mesajı silmek için DELE komutu kullanılır. Komuta parametre olarak silinecek mesajın indeks numarası girilmektedir. Örneğin:

    "DELE 3 CR/LF"

    Bu komut uygulandığında server henüz e-postayı posta kutusundan silmez. Yalnızca onu "silinecek" biçiminde işaretler. Silme 
    işlemi QUIT komutuyla oturum sonlandırıldığında yapılmaktadır. Eğer client silme eyleminden pişmanlık duyarsa RSET komutuyla 
    ilk duruma gelir. RSET komutu logout yapmaz. Yalnızca silinmiş olarak işaretlenenlerin işaretlerini kaldırır. 

    7) STAT komutu o anda e-posta kutusundaki e-posta sayısını bize vermektedir. Bu komut gönderildiğinde aşağıdaki gibi bir yanıt
    alınacaktır:

    +OK 5 27043

    Burada server e-posta kutusunda toplam 5 e-postanın bulunduğunu ve bunların byte uzunluklarının da 27043 olduğunu söylemektedir. 

    8) Protocol client programın QUIT komutunu göndermesiyle sonlandırılmaktadır. Örneğin:

    "QUIT CR/LF"

    9) POP3 protokolününde client belli bir süre server'a hiç mesaj göndermezse server client'ın soketini kapatıp bağlantıyı
    kopartmaktadır. Her ne kadar RFC 1939'da server'ın en azından 10 dakika beklemesi gerektiği söylenmişse de server'ların 
    çoğu çok daha az bir süre beklemektedir. 

    POP3 protokolünde client programın gönderdiği yazısal komutlar için server programın gönderdiği yanıtlar parse edilerek 
    tam gerektiği kadar okuma yapılabilmektedir. Ancak aşağıdaki programda biz basitlik sağlamak amacıyla server'dan gelen mesajları 
    başka bir thread ile ele aldık. 

    Aşağıdaki program POP3 komutlarının manuel bir biçimde uygulanabilmesini sağlamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import socket
import threading
import time

SERVER_NAME = 'mail.csystem.org'
SERVER_PORT = 110

def main():
    
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client_sock:
            client_sock.connect((SERVER_NAME, SERVER_PORT))
            print('connected...')
            
            thread = threading.Thread(target=thread_proc, args=(client_sock, )) 
            thread.start()
            
            while True:
                time.sleep(1)
                cmd = input('POP3>')
                cmd += '\r\n'
                if cmd == 'quit\r\n':
                    break
                client_sock.send(cmd.encode())
            
            client_sock.shutdown(socket.SHUT_RDWR)
        
    except Exception as e:
        print(e)

def thread_proc(sock):
    try:
        while True:
            b = sock.recv(4096)
            if len(b) == 0:
                break
            response = b.decode()
            print(response, end='')
    except Exception as e:
        print(e)
    
main()

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki programda biz server'a TCP ile bağlandıktan sonra ona CR/LF ile biten satırlar gönderip onun bize gönderdiği satırları 
    yazdırdık. Aslında bu işlemi yapan zaten "telnet" denilen bir protokol ve bir client program vardır. Telnet client programı TCP 
    ile karşı tarafa fiziksel biçimde bağlanıp sonu CR/LF ile biten yazıları karşı tarafa gönderebilmektedir. Telnet client program  
    aynı zamanda karşı taraftan gelen yazları da ekrana yazdırmaktadır. Programının kullanımı şöyledir:

    telnet <host> <port>

    Linux ve macOS sistemlerinde zaten telnet programı default biçimde bulunmaktadır. Ancak Windows sistemlerinde Telnet programını 
    yükleyebilmek için "Denetim Masası / Programlar ve Özellikler / Windows Özelliklerini Aç ya da Kapat" seçeneğinden Telnet'in 
    seçilmesi gerekir.   
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında Python'un standart kütüphanesinde POP3 protokolünü uygulayan "poplib" isimli hazır bir modül bulunmaktadır. Bu modülün 
    içerisindeki  POP3 isimli sınıf zaten yukarıda açıkladığımız komutları server'a gönderip onun yanıtlarını bize vermektedir. Sınıf 
    şöyle kullanılmaktadır:

    1) Programcı e-posta sunucusunun adresini ve port numarasını vererek POP3 sınıfı türünden nesne yaratır. Ancak __init__ metodu henüz 
    TCP bağlantısını kurmamaktadır. Örneğin:
    
    pop3 = POP3('mail.csystem.org', 110)

    2) Programcı POP3 sınıfının user ve pass_ (pass bir anahtar sözcüktür bu nedenle sonuna alt tire eklenmiştir) metotlarıyla server'a 
    login olur. TCP bağlantısı user metodu çarıldığında sağlanmaktadır. user ve pass_ metotları karşı taraftan gelen yanıta ilişkin 
    byte nesneleriyle geri döner. 

    3) LIST komutu için list metodu kullanılmaktadır. Bu metot bize üç elemanlı bir demet verir. Demetin ilk elemanı LIST komutunun 
    yanıtındaki ilk satırdır. İkinci elemanı bytes nesnelerinden oluşan bir listedir. Üçüncü elemanı ise server'ın bize verdiği e-posta 
    listesindeki byte sayısıdır (Bu sayıya ilk satırdaki byte'lar dahil değildir ancak sonraki satırlardaki CR/LF'ler de bu sayıya 
    dahildir.)

    4) Belli bir mesajı elde etmek için yine sınıfın retr metodu kullanılır. Bu metot da yine üçlü bir demete geri döner. Demetin ilk 
    elemanı yanıtın ilk satırını, diğer elemanı e-posta içeriğini ve son elemanı da ilk satırdan sonraki toplam byte sayısını vermektedir. 
    Burada mesaj içeriği satırlardan oluşan bir liste biçiminde verilmektedir. Satırlar ine byte nesneleri biçiminde verilmektedir. 

    5) Belli bir e-postayı silmek için dele metodu, silinenleri silinmemiş hale getirmek için rset metodu kullanılmaktadır. 

    6) İşlem bittiğinde quit metoduyla iletişim sonlandırılır. 

    Aşağıdaki örnekte bir e-posta sunucusuna POP3 protokolü ile bağlanılıp oradan e-postalar çekilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import poplib

try:
    pop3 = poplib.POP3('mail.csystem.org', 110)
    
    pop3.user('test@csystem.org')
    pop3.pass_('TheBeatles-1962')
    response, msg_list, total_bytes = pop3.list()
    
    for index, size in (b.decode().split() for b in msg_list):
        _, content, _ = pop3.retr(index)
        for line in content:
            print(line.decode())
        print('-----------------------------------------------------')
        
    pop3.quit()
except Exception as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    GMail çok kullanılan bir e-posta hizmetidir. gmail'in e-posta sunucusunun adresi "pop.gmail.com" biçimindedir. Ancak GMail SSL 
    kullandığından GMail'den e-posta okumak için POP3 sınıfı yerine POP3_SSL sınıfı kullanılmalıdır. GMail'in POP3 server'ı 995 numaralı 
    portu kullanmaktadır. Ancak GMail son zamanlarda POP3 erişimini isteğe bağlı hale getirmiştir. Bu nedenle E-Posta hesabına girilip 
    e-posta hesabının "POP3" erişimine açılması gerekmektedir. E-Posta hesabının POP3 protokolüne açılması için GMail'den Ayarlara girilir. 
    Oradan üst menüden "Yönlendirme ve POP/IMAP" seçilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import poplib

try:
    pop3 = poplib.POP3_SSL('pop.gmail.com', 995)
    
    pop3.user('csystem1903@gmail.com')
    pop3.pass_('TheLongAndWindingRoad-1969')
    response, msg_list, total_bytes = pop3.list()
    
    for index, size in (b.decode().split() for b in msg_list):
        _, content, _ = pop3.retr(index)
        print(content)
        print('-----------------------------------------------------') 
    pop3.quit()
except Exception as e:
    print(f'Error: {e}')

#------------------------------------------------------------------------------------------------------------------------------------
    POP3 ya da IMAP protokolü ile e-postaları elde etmek oldukça kolaydır. Ancak asıl zor olan kısım e-posta içerisindeki bilgilerin 
    parse edilmesi ve uygun biçimde gösterilmesidir.
    
    POP3 ve IMAP protokolleri e-postayı yazısal olarak gönderip almaktadır. Peki bir e-postanın içerisinde resim varsa, ses versa 
    yani başka türden bilgiler varsa bu iletim nasıl yapılmaktadır? İşte e-postadaki yazı olmayan olmayan öğeler aslında yazısal biçime 
    dönüştürülüp gönderilmektedir. Alınan e-posta yazısının içerisinde hangi parçanın hangi türden bilgiyi içerdiği bilgisi MIME denilen 
    bir formata göre kodlanmaktadır. MIME (Multipurpose Internet Mail Extensions) çeşitli öğelerin yazısal olarak kodlanması için 
    kullanılan bir tekniktir. O halde e-postanın yazısını alan programcı bunu MIME standardına göre parse etmelidir. Bu parse işlemi 
    şöyle yapılmaktadır:

    1) Programcı email.parser modülündeki Parser sınıfı türünden ya da BytesParser nesnesi türünden bir nesne yaratır. Örneğin:

    parser = BytesParser()
    
    2) Parser nesnesi ile sınıfın parserbytes metodunu çağırır. Bu metot e-posta mesajının içeriğini parametre olarak almaktadır. Metot
    bize e-posta mesajını temsil eden Message türünden bir nesne vermektedir. 

    3) Artık programcı bu Message türünden MIME kodlanmış mesajın birden fazla parçadan oluşup oluşmadığını kontrol etmelidir. MIME 
    mesajları "text/plain", "text/html", "image/jpeg", "image/gif" gibi parçalardan oluşmaktadır (Tüm MIME türlerini Internet'ten 
    bulabilirsiniz.)

    4) Eğer mesaj birden fazla parçadan oluşuyorsa bu parçalar Message sınıfının walk isimli metoduyla elde edilebilir. Mesajın 
    hem tamamı hem de Ancak onun parçaları da Message isimli sınıfla temsil edilmiştir. Programcının artık walk işlemiyle ilgili 
    parçaların türünü tespit etmesi gerekir. Bunun için Message sınıfının get_content_type isimli metodu kullanılmaktadır. 

    5) Mesajın türü tespit edildikten sonra o türün bilgileri Message sınıfının get_payload metodu ile elde edilir. 

    6) E-posta mesajındaki From, To, Subject gibi başlık alanlarını Message sınıfının [...] operatör metodu ile elde edebiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

import poplib
from email.parser import BytesParser
from PIL import Image

pop3 = poplib.POP3('mail.csystem.org')

pop3.user('test@csystem.org')
pop3.pass_('TheBeatles-1962')
response, msg_list, total_bytes = pop3.list()

parser = BytesParser()

for index, size in (b.decode().split() for b in msg_list):
    _, content, _ = pop3.retr(index)
    b = b'\n'.join(content)
    message = parser.parsebytes(b)
    
    from_text = message['From']
    subject_text = message['Subject']
    to_text = message['To']
    
    print(f'From: {from_text}')
    print(f'Subject: {subject_text}')
    print(f'To: {to_text}')
    for part in message.walk():
        part_type = part.get_content_type()
        if part_type == 'text/plain':
            text = part.get_payload()
            print(f'Plain Text: {text}')
        elif part_type == 'text/html':
            text = part.get_payload()
            pass
        elif part_type == 'image/jpeg':
            file_name = part.get_filename() 
            data = part.get_payload(decode=True)
            
            with open(file_name, 'wb') as f:
                f.write(data)
          
            """
            image = Image.open(file_name)
            image.show()
            """
    print('-------------------------------------------')            
        
pop3.quit()

#------------------------------------------------------------------------------------------------------------------------------------
    E-Posta göndermek için SMTP (Simple Mail Transport Protocol) isimli uygulama katmanı protokolü kullanılmaktadır. Bu protokol de
    yazısal tabanlıdır. Tipik olarak client program e-posta sunucusuna TCP ile fiziksel olarak bağlanır. Sonra mantıksal biçimde 
    login olur. Daha sonra da e-posta mesajını bir yazı olarak karşı tarafa gönderir. Bu e-posta yazısı bir başlık içermektedir. Başlık 
    ile posta içeriği arasında bir satır boşluk bırakılır. E-Posta içeriği karmaşık öğelere sahip olabilir. Bu durumda içerik MIME 
    olarak kodlanır. SMTP protokolünün güncel versiyonu RFC 5321'de dokümante edilmiştir:
    
    https://datatracker.ietf.org/doc/html/rfc5321

    SMTP'de de client'ın her bir komutuna karşılık server bir yanıt vermektedir. Verilen yanıtın birer sayısal kodu ve içeriği vardır. 

    Biz bir kullanıcı olarak bir başkasına e-posta gönderebilmek için e-postamızı kendi smtp sunucumuza göndeririz. Bu sunucu e-postayı 
    karşı atarafın sunucusuna göndermektedir. Yani biz e-postayı aslında kendimiz doğrudan karşı tarafa göndermemekteyiz. Bu işlemi 
    bizim hizmet aldığımız sunucu yapmaktadır. 

    Python'da e-posta göndermek için smtplib isimli standart bir modül bulundurulmuştur. E-posta gönderme işlemi tipik olarak aşağıdaki
    adımlardan geçilerek yapılmaktadır:

    1) Önce SMTP sınıfı türünden ya da SMTP_SSL sınıfı türünden bir nesne yaratılır. Bu sınıfların __init__ metotları bizden e-posta sunucusunun 
    adresini ve port numarasını almaktadır. SMTP protokolünün orijinal port numarası 25'tir. Ancak bugün e-posta sunucuları şifrelemeyi de 
    sağlayan e-postalar için genel olarak 587 portunu kullanmaktadır. E-Posta sunucunuzun hangi portu kullandığını öğrenmelisiniz. Örneğin:

    smtp = smtplib.SMTP('mail.csystem.org', 587)

    2) Bundan sonra programcının SMTP nesnesi yoluyla sınıfın login metodunu çağırarak e-posta sunucusuna mantıksal biçimde bağlanması 
    gerekir. login metodu kullanıcı adı ve parolayı parametre biçiminde almaktadır. Örneğin:

    smtp.login('test@csystem.org', 'TheBeatles-1962')

    3) Artık e-posta mesajının metni oluşturulur. SMTP protokolünde aslında e-posta tek bir yazıdan oluşmaktadır. Yazının başında bir başlık 
    kısmı bulunur. Başlık kısmının genel formatı şöyledir:

    From: <kimden>
    To: <kime>
    Subject: <konu>
    Date: <tarih>

    Bu başlık kısmından sonra bir satır boşluk bırakılmalıdır. Ondan sonra da mesaj metni bulundurulur. Buradaki FROM ve TO 
    alıcının gördüğü bilgilerdir. Yani bir kişi sanki e-postayı başka birisi göndermiş gibi bir etki oluşturabilir. Örneğin:

    mail_text = ""
    "From: ali@csystem.org
    To: csystem1903@gmail.com
    Subject: Test
    Date: 02/09/2023
                
    This is test
    """

    4) Bundan sonra e-posta SMTP sınıfının sendmail metoduyla yollanır. Bu metot üç parametre almaktadır. Metodun birinci parametresi 
    yollayan kişinin e-posta adresini, ikinci parametresi hedef e-posta adresini ve üçüncü parametresi de e-posta metnini almaktadır. 
    Eğer e-posta birden fazla kişiye yollanacaksa bu durumda metodun ikinci parametresi dolaşılabilir bir nesne (örneğin bir liste) 
    olmalıdır. Birinci parametrede belirtilen e-posta adresi aslında zarfın üzerinde yazılan adrestir. Yani eğer e-posta gönderilemezse 
    bu adrese bildirimde bulunulacaktır. Mesaj başlığında FROM ve TO kısmı tamamen alıcının göreceği bilgilerden oluşmaktadır. Yani 
    bu kısımdaki bu bilgiler doğrulanmamaktadır. Örneğin:

    smtp.sendmail('test@csystem.org',  ['csystem1903@gmail.com', 'aslank@csystem.org'], mail_text)

    5) Nihayetinde e-posta gönderimi bittikten sonra sınıfn quit metoduyla işlemler sonlandırılır. Örneğin:

    smtp.quit()

   Aşağıda e-posta göndermeye bir örnek verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import smtplib 

try:
    smtp = smtplib.SMTP('mail.csystem.org', 587)
    smtp.login('test@csystem.org', 'TheBeatles-1962')
    mail_text = """FROM: ali@csystem.org
To: csystem1903@gmail.com
Subject: Test
Date: 02/09/2023
CC: aslank@csystem.org;
               
This is test
""" 
    smtp.sendmail('test@csystem.org', ['csystem1903@gmail.com', 'aslank@csystem.org'], mail_text)
    smtp.quit()
    
except Exception as e:
    print(e)
 
#------------------------------------------------------------------------------------------------------------------------------------
    Zaman içerisinde e-posta sunucuları spam ve kötü niyetli e-postaları tespit etme konusunda karmaşık yöntemler uygulamaya başlamıştır.
    Bugün artık spam ve zararlı e-postalar maike öğrenmesi teknikleri de kullanılarak tespit edilmeye çalışılmaktadır. Bu nedenle 
    artık pek çok sunucu içerik bakımından çok farklı olmayan, kısa süreli aralıklarıyla gönderilen e-postaları yok hükmünde saymaktadır. 
    Bu nedenle yukarıdaki gibi bir programla artık muhtemelen aynı kişiye benzer e-postaları atmak konusunda sıkıntı yaşayacaksınız. 
    E-posta sunucuları spam ya da zararlı postaları genellikle üç biçimde ele almaktadır:

    1) Normal e-postalar,. Bunlar normal iletilmektedir. 
    2) Spam ve şüpheli ama belki önemli. Bunlar iletilmekte ancak spam'e düşmektedir.
    3) Silinen/Reddedilen e-postalar: Bunlar spam'e bile düşürülmeden yok hükmünde sayılmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Peki göndereceğimiz e-posta içerisinde yazının dışında başka şeyler de olmasını istiyorsak ne yapmamız gerekir? İşte bu durumda
    POP3 protokolünde de gördüğümüz gibi e-posta içeriğini yazısal biçimde MIME olarak ifade etmemiz gerekir. Bu amaçla email modülünde
    çeşitli sınıflar bulundurulmuştur. Bunun için şu işlemler yapılmalıdır:

    1) Önce email.mime.multipart modülündeki MIMEMultipart isimli sınıf türünden bir nesne yaratılır. Bu nesne parçalardan oluşan 
    e-postanın tamamını temsil etmektedir. Bu nesne üzerinde as_string metodu tüm MIME dokümanını yazısal olarak, as_bytes metodu 
    ise byte dizisi olarak bize vermektedir. E-postaya ilişkin FROM, To, Subject bilgileri bu MimeMultipart nesnesinin [...] operatörü 
    yolu ile belirtilmektedir. Örneğin:

    mime_multipart = MIMEMultipart()
    mime_multipart['From'] = 'test@csystem.org'
    mime_multipart['To'] = 'test@csystem.org;aslank@csystem.org'
    mime_multipart['Subject'] = 'MIME Test E-Postası'

    2) Daha sonra çeşitli modüllerde bulunan MIMEText, MIMEImage, MIMEAudio, MIMEApplication gibi sınıflar yoluyla e-postanın ilgili 
    kısımları MIME olarak ifade edilir. Bu kısımlar ana e-postaya MIMEMultipart nesnesinin attach metodu çağrılarak eklenmektedir. 
    Örneğin:

    text_msg1 = """
    Bugün hava çok güzeldi. Ben de parka gittim. Orada dinlendim.
    """

    mime_text1 = MIMEText(text_msg1)
    mime_multipart.attach(mime_text1)

    with open('AbbeyRoad.jpg', 'rb') as f:
        image_data = f.read()
    
        mime_image = MIMEImage(image_data)
        mime_image.add_header('Content-Disposition', 'attachment', filename='AbbeyRoad.jpg')

    3) En sonunda mime_multipart nesnesi ile sınıfın as_striing metodu çağrılarak tüm e-posta içeriği bir text biçiminde oluşturulur. 
    Örneğin:

    email_content = mime_multipart.as_string()

    4) Oluşturulan bu içerik smtp sınıfının sendmail metoduyla gönderilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.image import MIMEImage
from email.mime.text import MIMEText

smtp = smtplib.SMTP('mail.csystem.org', 587)

response_code, response_text = smtp.login('test@csystem.org', 'Csystem-1993')

mime_multipart = MIMEMultipart()
mime_multipart['From'] = 'test@csystem.org'
mime_multipart['To'] = 'test@csystem.org;aslank@csystem.org'
mime_multipart['Subject'] = 'MIME Test E-Postası'

text_msg1 = """
Bugün hava çok güzeldi. Ben de parka gittim. Orada dinlendim.
"""
mime_text1 = MIMEText(text_msg1)
mime_multipart.attach(mime_text1)

with open('AbbeyRoad.jpg', 'rb') as f:
    image_data = f.read()
   
mime_image = MIMEImage(image_data)
mime_image.add_header('Content-Disposition', 'attachment', filename='AbbeyRoad.jpg')

text_msg2 = """
Bu resmi de yolluyorum. Bu fotoğraf Londra'da Abbey Road denilen semtte çekilmiştir.'
"""

mime_text2 = MIMEText(text_msg2)
mime_multipart.attach(mime_text2)
mime_multipart.attach(mime_image)

result = smtp.sendmail('test@csystem.org', ['test@csystem.org', 'aslank@csystem.org'], mime_multipart.as_string())

smtp.quit()

#------------------------------------------------------------------------------------------------------------------------------------
    UDP (User Datagram Protocol) anımsanacağı gibi "bağlantısız (connectionless)", "datagram tabanlı (datagram)", "güvenilir olmayan 
    (unreliable)" ancak hızlı bir protokoldür. TCP'ye göre oldukça seyrek kullanılmaktadır. Özellikle periyodik uzun olmayan mesajların 
    hızlı iletilmesi gerektiğinde tercih edilmektedir. Bu protokolde bir bağlantı yapılmadığı için akış kontrolü uygulanmaz. Gönderici 
    taraf bilginin karşı tarafa gidip gitmediğini bilemez. Zaten protokolde bir akış kontrolünün uygulanmaması onu hızlı yapmaktadır. 
    UDP haberleşme paket tabanlıdır. Buradaki pakete "datagram" da denilmektedir. Paket tabanlı haberleşmede bir taraf diğer tarafa 
    bir grup bilgiyi bir paket olarak gönderir. Karşı taraf da bunu paket olarak alır. 

    Anımsanacağı gibi TCP client-server tarzı bir çalışma modelini bize uygulatmaktadır. TCP'de bağlantıyı kabul eden (accept yapan) 
    tarafa "server", bağlantı kurmak isteyen tarafa ise "client" denilmektedir. UDP ise bağlantısız bir protokol olduğu için burada 
    client ve server rolleri açık değildir. Ancak yine de genel olarak mesajları alıp iş yapan tarafa "server", mesaj gönderen tarafa 
    ise "client" denilmektedir. 

    UDP programlama da yine "server (yani alan taraf)" ve "client (yani gönderen taraf)" olmak üzere iki ayrı programın yazılması 
    gerekmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    UDP server programın organizasyonu şöyledir:

    1) Server program önce bir UDP soketi yaratır. UDP soket yaratılırken soket fonksiyonun ikinci parametresi socket.SOCK_DGRAM 
    geçilmelidir. Üçüncü parametre girilmeyebilir ya da socket.IPPROTO_UDP biçiminde girilebilir. Örneğin:

    server_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)

    Ya da örneğin:

    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) as server_sock:
        pass

    2) Server program soketi bind etmelidir. Her ne kadar bir bağlantı olmasa da client programlar datagram paketlerini gönderirken 
    bir IP adresi ve port belirtirler. Yani server program yine bir portla kendisini ilişkilendirmektedir. Örneğin:

    server_sock .bind(('', PORT_NO))

    3) Artık server program Socket sınıfının recvfrom isimli metoduyla gelen datagram peketlerini elde edebilir. recvfrom metodu 
    default durumda blokeye yol açmaktadır. Yani herhangi bir kişiden paket gelene kadar recvfrom akışı bekletmektedir. Metodun 
    birinci parametresi mesajın uzunluğunu belirtir. Eğer mesaj uzunluğu için girilen parametre gönderilen UDP paketinin uzunluğundan 
    kısa ise default durumda belirtilen sayıdaan fazla olan byte'lar kırpılarak okuma yapılmaktadır. İkinci parametre mesajın okunma 
    biçimine ilişkin bazı bayrak değerlerini belirtir. İkinci parametre hiç girilmeyebilir. recvfrom metodunun geri dönüş değeri 
    iki elemanlı bir demettir. Demetin birinci elemanı UDP paketindeki bilgileri içeren bytes nesnesdir. Demetin ikinci elemanı 
    da iki elemanlı bir demettir. Bu iki elemanlı demetin ilk elemanı paketi gönderen tarafın IP adresini, ikinci elemanı ise 
    kaynak port numarasını belirtmektedir. Bu durumda recvfrom metodu tipik olarak aşağıdaki gibi kullanılmalıdır:

    msg, (ipaddr, port) = server_sock.recvfrom(8192)
    
    4) Server işlemler bitirince açtığı soketi kapatmalıdır. UDOPsoketlerde shutdown işlemi yoktur. Eğer soket with deyiyle açılmışsa
    zaten akış with deyimini bitirdiğinde soket de otomatik olarak kapatılmaktadır. 

    Örneğin:

    PORT_NO = 55555

    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) as server_sock:
        server_sock .bind(('', PORT_NO))
        
        while True:
            print('waiting datagrams...')
            msg, (ipaddr, port) = server_sock.recvfrom(4096)
            print(f'message from {ipaddr}:{port} => "{msg.decode()}"')
        

    Aşağıda bir UDP server örneği verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import socket

PORT_NO = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) as server_sock:
        server_sock .bind(('', PORT_NO))
        while True:
            print('waiting datagrams...')
            msg, (ipaddr, port) = server_sock.recvfrom(4096)
            msg = msg.decode()
            if msg == 'quit':
                break
            print(f'message from {ipaddr}:{port} => "{msg}"')
except Exception as e:
    print(e)
        
#------------------------------------------------------------------------------------------------------------------------------------
    UDP client programın da organizasyonu şöyledir:

    1) UDP client program da önce bir UDP soket yaratır. Yine soket yaratılırken soket türü socket.SOCK_DGRAM girilmelidir. 

    2) Client program isteğe bağlı olarak bind işlemi yapabilir. Örneğin client belli bir yerel porttan bilgiyi göndermek isteyebilir. 
    Ancak genel olarak böyle bir durum sıklıkla arzu edilmemektedir. 

    3) Client server'a socket sınıfının sendto metoduyla UDP paketini gönderir. sendto metodunun iki parametresi vardır. (sendto üç 
    parametreli bir biçimde de kullanılabilmektedir. Bu durumda metot bir flags parametresi de alır.) Metodun birinci parametresi 
    gönderilecek UDP paketini oluşturan bytes nesnesidir. İkinci parametre server IP adresi ve port numarasını içeren iki elemanlı bir 
    demettir. Örneğin:

    sock.sendto(b, (SERVER_NAME, PORT_NO))

    4) Client işlem bitince close metodu ile soketi kapatmalıdır. Tabii eğer soket with deyimiyle açılmışsa deyim sonlandığında zaten 
    otomatik close işlemi yapılmaktadır.

    Aşağıda örnek client program verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import socket

SERVER_ADDR = '192.168.1.15'
PORT_NO = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) as client_sock:
        while True:
            text = input('Enter text:')
            client_sock.sendto(text.encode(), (SERVER_ADDR, PORT_NO))
            if text == 'quit':
                break
except Exception as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Tabii aslında recvform ve sendto metotları hem client hem de server program tarafından uygulanabilir. Örneğin server recvfrom 
    metodu ile client'tan bir bilgi alıp ona sento metoduyla yanıtı ona yollayabilir. Çünkü UDP mesajlarının hangi host ve port'tan
    geldiği bilinmektedir. Aşağıdaki örnekte UDP client programı client UDP server'a bir yazı göndermekte, server da yazıyı tersine 
    çevirip client'a yollamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

# server.py

import socket

PORT_NO = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) as server_sock:
        server_sock .bind(('', PORT_NO))
        while True:
            print('waiting datagrams...')
            msg, (ipaddr, port) = server_sock.recvfrom(4096)
            msg = msg.decode()
            if msg == 'quit':
                break
            print(f'message from {ipaddr}:{port} => "{msg}"')
            server_sock.sendto(msg[::-1].encode(), (ipaddr, port))
except Exception as e:
    print(e)
       
    
# client.py 

import socket

SERVER_ADDR = '192.168.1.15'
PORT_NO = 55555

try:
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) as client_sock:
        while True:
            text = input('Enter text:')
            client_sock.sendto(text.encode(), (SERVER_ADDR, PORT_NO))
            if text == 'quit':
                break
            msg, (ipaddr, port) = client_sock.recvfrom(8192)
            msg = msg.decode()
            print(f'message from {ipaddr}:{port} => "{msg}"')
except Exception as e:
    print(e)
        

#------------------------------------------------------------------------------------------------------------------------------------
    UDP server programlarında server'a pek çok client UDP paketi gönderiyor olabilir. Server bir UDP paketini aldığında onu kendisi 
    işlerse yeni gelen paketleri kaçırabilir. Kaçırmanın ötesinde de ayrıca paketi gönderen client yanıtı geç alabilir. Bu tür 
    durumlarda server UDP paketini aldıktan sonra onun işlemesini bir thread'e havale edebilir. Bu tür thread'lerin o anda yaratılması 
    yavaşlığa yol açmaktadır. Aynı durum TCP uygulamalarında da karşımıza çıklabilmektedir. TCP server bir client'tan bilgiyi aldığında 
    eğer thread modelini kullanmıyorsa bilgiyi işlerken gecikmeye yol açabilir. İşte bu tür durumlarda genel olarak "thread havuzu 
    (thread pool)" denilen mekanizma kullanılmaktadır. TCP ya da UDP server bilgiyi okuduğunda ona yanıt vermek için bir thread (ya da 
    process) yaratırsa bu thread'in yaratılma ve yok edilme işlemindeki zamansal maliyet faydayı ortadan kaldırabilmektedir. Thread 
    havuzları bu bu maliyeti elimine etmek için düşünülmüş bir organizasyondur. Thread havuzunda zaten yaratılmış olan belli miktarda 
    thread suspend durumda havuzda bekletilmektedir. Server bilgiyi işlemek için havuzdaki zaten yaratılmış ama suspend durumda olan 
    thread'leri kullanır. Böylece gelen mesajın işlenmesi hızlıca yapılabilmektedir. Java, .NET, Qt gibi framework'lerdeki thread havuzları 
    duruma göre suspend durumdaki thread sayısını otomatik artırıp  azaltabilmektedir. 

    Daha önceden de bahsettiğimiz gibi CPython yorumlayıcısında GIL yüzünden thread'ler bu bakımdan etkin biçimde kullanılamamaktadır. 
    Bu nedenle çoğu kez aslında yüksek maliyeti olan proses yaratmak CPython için daha iyi bir çözüm olabilmektedir. Pyton'a belli 
    bir süreden sonra proses temelinde çalışan bir thread havuzu mekanizması ilkel düzeyde de olsa eklenmiştir. Ancak programcı zaten 
    üretici-tüketici problemleri için hazır bulundurulmuş Queue sınıfından da bu bağlamda faydalanabilir. Yani örneğin belli miktarda 
    proses (ya da thread) yaratılıp ortak bir Queue nesnesini kullanabilir. Böylece server gelen isteği kuyruğa atar. Client'ların 
    herhangi biri kuyruktan mesajı alarak işleyebilir. Tabii proseslerle çalışma thread'lerle çalışmaya göre bazı sıkıntılara da 
    sahiptir. Python'da ayrıca ThreadPoolExecutor isimli thread havuz mekanizmasını kullanan bir sınıf da bulunmaktadır. Ancak bu 
    sınıf CPython yorumlayıcında CPU yoğun işlemlerde GIL yüzünden zayıf bir performans göstermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                                70. Ders 30/11/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Soket işlemlerini bitirdikten sonra şimdi de Python standart kütüphanesine yönelip standart kütüphanede henüz görmediğimiz önemli
    bileşenleri gözden geçireceğiz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    İlk olarak itertools modülünde bulunan bazı yardımcı fonksiyonları göreceğiz. Ancak ondan önce Python kursunda görmüş olduğumuz 
    birkaç fonksiyonu hatırlatmak istiyoruz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi map built-in fonksiyonu bir fonksiyon (genel olarak "çağrılabilir (callable) bir nesne" ve bir dolaşılabilir 
    nesneyi alıp bize bir dolaşım nesnesi veriyordu. Bu dolaşım nesnesini dolaştığımızda aslında biz map fonksiyonuna verdiğimiz 
    dolaşılabilir nesnenin yine  map fonksiyonuna verdiğimiz fonksiyona sokulmasından elde edilen geri dönüş değerlerini elde ederiz. 
    Tabii benzer işlem içlemlerle ya da üretici ifadelerle de yapılabilmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

def foo(x):
    return x * x

a = [1, 2, 3, 4, 5]

m = map(foo, a)

for x in m:
    print(x, end=' ')
    
print()

# eşdeğeri 

for x in (foo(y) for y in a):
    print(x, end=' ')

#------------------------------------------------------------------------------------------------------------------------------------
    Örneğin map fonksiyonuyla biz yazıların uzunluklarını kısa bir ifadeyle elde edebiliriz.
#------------------------------------------------------------------------------------------------------------------------------------

names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']    

for x in map(len, names):
    print(x, end= ' ')

#------------------------------------------------------------------------------------------------------------------------------------
    map fonksiyonu üretici bir fonksiyon olarak çok basit biçimde aşağıdaki gibi yazılabilir.
#------------------------------------------------------------------------------------------------------------------------------------

def mymap(f, iterable):
    for elem in iterable:
        yield f(elem)
    
names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

a = list(mymap(len, names))
print(a)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Bu tür fonksiyonları üretici fonksiyon olarak değil de dolaşılabilir bir sınıf olarak yazmak daha hızlı bir çalışmaya yol açmaktadır. 
    Gerçekten de standart kütüphanede map aslında bir sınıf olarak yazılmıştır. Aşağıda map fonksiyonunun bir sınıf olarak yazımına 
    örnek verilmiştir.
#------------------------------------------------------------------------------------------------------------------------------------

class mymap:
    def __init__(self, f, iterable):
        self.f = f
        self.iterator= iter(iterable)
   
    def __iter__(self) :
       return self
       
    def __next__(self):
        return self.f(next(self.iterator))
       
names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

iterator = mymap(len, names)
a = list(iterator)          
print(a)

a = list(iterator)          
print(a)
    
#------------------------------------------------------------------------------------------------------------------------------------
    filter isimli built-in fonksiyon benzer biçimde kullanılmaktadır. filter fonksiyonunun birinci parametresi bool bir değere geri 
    dönen fonksiyon (genel olarak "callable" nesne) alır. filter iterable nesnedeki tüm elemanları sırasıyla bu fonksiyona argüman
    yaparak bu fonksiyonu çağırır. Bize de geri dönüş değeri True olan elemanları verir. Tabii filter fonksiyonun eşdeğeri yine 
    iterable bir sınıf biçiminde ya da bir üretici fonksiyon ya da ifade biçiminde de oluşturulabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']    

for x in filter(lambda x: len(x) > 4, names):
    print(x, end= ' ')
    
print()

# eşdeğeri 

for x in (y for y in names if len(y) > 4):
    print(x, end= ' ')

#------------------------------------------------------------------------------------------------------------------------------------
    filer fonksiyonu da basit bir biçimde üretici fonksiyonla aşağıdaki gibi yazılabilir.
#------------------------------------------------------------------------------------------------------------------------------------

def myfilter(f, iterable):
    for elem in iterable:
        if f(elem):
            yield elem
       
names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

for name in filter(lambda s: s[0] == 'a', names)    :
    print(name)
    
#------------------------------------------------------------------------------------------------------------------------------------
    Tabii filter fonksiyonu da aslında bir sınıf biçiminde yazılmıştır. Aşağıda filter fonksiyonunun dolaşılabilir bir sınıf biçiminde 
    yazımına örnek verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

class myfilter:
    def __init__(self, f, iterable):
        self.f = f
        self.iterator = iter(iterable)
        
    def __iter__(self):
        return self
    
    def __next__(self):
        while True:
            val = next(self.iterator)
            if self.f(val):
                return val
            
names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

for name in myfilter(lambda s: s[0] == 'a', names)    :
    print(name)
 
#------------------------------------------------------------------------------------------------------------------------------------
    Built-in zip fonksiyonu ise dolaşılabilir nesneleri alarak onların karşılıklı elemanlarından oluşan demetleri veren bir dolaşım 
    nesnesi geri döndürmektedir. unzip işlemi de yine zip fonksiyonu ile yapılyapılabilmektedir.
#------------------------------------------------------------------------------------------------------------------------------------

a = [1, 2, 3, 4, 5]
b = ['ali', 'veli', 'selami', 'ayşe', 'fatma', 'süleyman']

z = zip(a, b)

for x, y in z:
    print(x, y)
    
c = list(zip(a, b))
print(c)

numbers, names = zip(*c)
print(numbers)
print(names)
    
#------------------------------------------------------------------------------------------------------------------------------------
    İşte itertools modülü içerisinde built-in map, filter, zip gibi fonksiyonlara benzer dolaşılabilir nesnelerle kullanılabilen 
    faydalı birtakım fonksiyonlar bulunmaktadır.

    itertools modülündeki accumulate fonksiyonu bir dolaşılabilir nesneyi alır bize başka bir dolaşım nesnesi verir. Biz accumulate 
    fonksiyonun verdiği dolaşım nesnesini dolaştığımızda elemanların kümülatif toplamlarını elde ederiz. Fonksiyonunun parametrik yapısı 
    şöyledir:

    itertools.accumulate(iterable, func= operator.add, *, initial=None)

    Fonksiyonun ikinci parametresi kümülatif işlemi belirtmektedir. Burada operator modülündeki add metodu default argüman olarak 
    kullanılmıştır. Bu fonksiyon iki değeri alarak onun toplamına geri dönmektedir. Dolayısıyşa fnksiyon tipik olarak tek argümanla 
    çağrılmaktadır. Örneğin:

    import itertools

    a = [1, 2, 3, 4, 5]

    for x in itertools.accumulate(a):
        print(x, end=' ')
        

    Buradaki accumulate fonksiyonu her dolaşıldığında kümülatif toplamlar olan 1 3 6 10 15 değerleri elde edilecektir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

a = [1, 2, 3, 4, 5]

result = itertools.accumulate(a)
for x in result:
    print(x, end=' ')       # 1 3 6 10 15

#------------------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte isimlerin karakter uzunluklarının kümülatif toplamları bir liste olarak elde edilmiştir:

    names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

    for x in itertools.accumulate(map(len, names)):
        print(x, end=' ')       # 3 7 13 17 22
        
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

for x in itertools.accumulate(map(len, names)):
    print(x, end=' ')       # 3 7 13 17 22

#------------------------------------------------------------------------------------------------------------------------------------
    accumulate fonksiyonun initial parametresi ilk toplam değerini belirtmektedir. Dolaşım sırasında önce initial parametresiyle 
    belirtilen değer elde edilir. Sonra dolaşıldıkça bu değerin üzerine eklenen değerler elde edilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

a = [1, 2, 3, 4, 5]

result = itertools.accumulate(a, initial=10)

for x in result:
    print(x, end=' ')       # 10 11 13 16 20 25

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında accumulate fonksiyonun ikinci parametresi iki parametreli bir fonksiyon olarak da girilebilir. Bu durumda bu fonksiyonun 
    ilk parametresi kümülatif değeri, ikinci parametresi ise dolaşılabilir nesnedeki sıradaki değeri belirtir. Böylece biz örneğin 
    kümülatif toplamları değil, kümülatif çarpımları da bulabiliriz:

    def foo(cumm, val):
        return cumm * val

    a = [1, 2, 3, 4, 5]

    for x in itertools.accumulate(a, foo):
        print(x, end=' ')

    Buradan sırasıyla 1, 2, 6, 24, 120 değerleri elde edilecektir.
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

a = [1, 2, 3, 4, 5]

result = itertools.accumulate(a, lambda cum, x: cum * x, initial=10)

for x in result:
    print(x, end=' ')   # 10 10 20 60 240 1200 
    
#------------------------------------------------------------------------------------------------------------------------------------
    Python'un "Standard Library" dokümanında accumulate fonksiyonun üretici fonksiyon biçiminindeki gerçekleştirimi aşağıdaki gibi 
    verilmiştir:

    def accumulate(iterable, func=lambda cum, val: cum + val, *, initial=None):
        it = iter(iterable)
        total = initial
        if initial is None:
            try:
                total = next(it)
            except StopIteration:
                return
        yield total
        for element in it:
            total = func(total, element)
            yield total

#------------------------------------------------------------------------------------------------------------------------------------

def accumulate(iterable, func=lambda cum, val: cum + val, *, initial=None):
    it = iter(iterable)
    total = initial
    if initial is None:
        try:
            total = next(it)
        except StopIteration:
            return
    yield total
    for element in it:
        total = func(total, element)
        yield total
        
result = accumulate(a, lambda cum, x: cum * x)

for x in result:
    print(x, end=' ')   # 10 10 20 60 240 1200 
    
#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki chain isimli fonksiyon bizden birden fazla dolaşılabilir nesneyi parametre olarak alır. Sonra bize yeni bir 
    dolaşım nesnesi verir. chain fonksiyonunun verdiği dolaşım nesnesi dolaşıldığında sanki bizim fonksiyona verdiğimiz dolaşılabilir 
    nesneler tek bir dolaşılabilir nesneymiş gibi sırasıyla dolaşılmaktadır. Örneğin:

    
    a = ['ali', 'veli', 'selami']
    b = 'ankara'
    c = {10, 20, 30}

    for x in itertools.chain(a, b, c):
        print(x, end=' ')               # ali veli selami a n k a r a 10 20 30 
    
    chain fonksiyonunun birden fazla dolaşılabilir nesneyi adeta uç uca eklenmiş tek bir dolaşılabilir nesne gibi dolaştığına dikkat
    ediniz.     
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

a = ['ali', 'veli', 'selami']
b = 'ankara'
c = {10, 20, 30}

for x in itertools.chain(a, b, c):
    print(x, end=' ')               # ali veli selami a n k a r a 10 20 30 
    
#------------------------------------------------------------------------------------------------------------------------------------
    Standart Kütüphanede chain aslında iterable bir sınıf olarka yazılmıştır. Ancak standart kütüphanenin dokümantasyonunda eşdeğer 
    generic gerçekleştirimi aşağıdaki gibi verilmiştir:

    def chain(*args):s
    for iterable in args:
        for x in iterable:
            yield x
#------------------------------------------------------------------------------------------------------------------------------------

def chain(*args):s
    for iterable in args:
        for x in iterable:
            yield x
            
result = chain(a, b, c)    
for x in result:
    print(x, end=' ')       # 1 2 3 4 5 ali veli selami a n k a r a 

#------------------------------------------------------------------------------------------------------------------------------------
    Her ne kadar dokümantasyonda chain fonksiyonun muhtemel gerçekleştirimi üretici fonksiyon biçiminde verilmişse de aslında CPython'da
    yukarıda da belirttiğimiz gibi gerçekleştirim chain isimli bir dolaşılabilir sınıf biçiminde yapılmıştır. Aşağıda chain işlemini 
    yapan dolaşılabilir bir sınıf örneği de verilmiştir:

    class mychain:
    def __init__(self, *args):
        self.args_iterator = iter(args)
        self.iterator = iter(next(self.args_iterator))
    
    def __iter__(self):
        return self
    
    def __next__(self):
        while True:
            try:
                return next(self.iterator)
            except StopIteration:
                self.iterator = iter(next(self.args_iterator))
#------------------------------------------------------------------------------------------------------------------------------------

class mychain:
    def __init__(self, *args):
        self.args_iterator = iter(args)
        self.iterator = iter(next(self.args_iterator))
    
    def __iter__(self):
        return self
    
    def __next__(self):
        while True:
            try:
                return next(self.iterator)
            except StopIteration:
                self.iterator = iter(next(self.args_iterator))
            
a = [1, 2, 3, 4, 5]
b = ('ali', 'veli', 'selami')
c = 'ankara'
d = [1.2, 3.4, 5.5]

result = chain(a, b, c, d)    
for x in result:
    print(x, end=' ')
       
#------------------------------------------------------------------------------------------------------------------------------------
    Ayrıca chain isimli sınıfın from_iterable isimli bir staticbir  metodu da vardır. Bu metodun farkı iterable nesneleri ayrı nesneler 
    olarak değil tek bir iterable nesne biçiminde almasıdır. Örneğin:

    chain = itertools.chain.from_iterable([['ali', 'veli', 'selami'], 'ankara', (10, 20, 30)])

    for x in chain:
        print(x, end=' ')               # ali veli selami a n k a r a 10 20 30   
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

a = [1, 2, 3, 4, 5]
b = ('ali', 'veli', 'selami')
c = 'ankara'
d = [1.2, 3.4, 5.5]

iterables = [a, b, c, d]
result = itertools.chain.from_iterable(iterables)  
  
for x in result:
    print(x, end=' ')

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii aslında biz aynı şeyi chain fonksiyonunu çağırırken *'lı argüman kullanarak da sağlayabiliriz.
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

a = [1, 2, 3, 4, 5]
b = ('ali', 'veli', 'selami')
c = 'ankara'
d = [1.2, 3.4, 5.5]

iterables = [a, b, c, d]
result = itertools.chain(*iterables)  
  
for x in result:
    print(x, end=' ')

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda yazdığımız sınıfa from _iterable metodunu aşağıdaki gibi ekleyebiliriz:

    class mychain:
        def __init__(self, *args):
            self.args_iterator = iter(args)
            self.iterator = iter(next(self.args_iterator))
        
        def __iter__(self):
            return self
        
        def __next__(self):
            while True:
                try:
                    return next(self.iterator)
                except StopIteration:
                    self.iterator = iter(next(self.args_iterator))
        
        @staticmethod
        def from_iterable(iterables):
            return mychain(*iterables)
   
#------------------------------------------------------------------------------------------------------------------------------------

class chain:
    def __init__(self, *args):
        self.args = args
        self.iterator = iter(self.args[0]) if args else iter(args)
        self.index = 0
        
    def __iter__(self):
        return self
    
    def __next__(self):
        try:
            result = next(self.iterator)
        except StopIteration:
            self.index += 1
            if self.index < len(self.args):
                self.iterator = iter(self.args[self.index])
                result = next(self.iterator)
            else:
                raise StopIteration
        
        return result
    
    @staticmethod
    def from_iterable(itreables):
        return chain(*iterables)

a = [1, 2, 3, 4, 5]
b = ('ali', 'veli', 'selami')
c = 'ankara'
d = [1.2, 3.4, 5.5]

result = chain.from_iterable(iterables)    
for x in result:
    print(x, end=' ')

#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki combinations isimli fonksiyonu biz aslında Python derslerinde görmüştük. Bu fonksiyon bir dolaşılabilir 
    nesnenin n'li kombinasyonlarını demet olarak veren bir dolaşım nesnesi vermektedir. Örneğin [1, 2, 3, 4, 5] gibi dolaşılabilir 
    bir nesnede 3'lü kombinasyonlar şöyle elde edilebilir:

    a = [1, 2, 3, 4, 5]
    result = itertools.combinations(a, 3)
    for x in result:
        print(x)

    n elemanlı kümenin k'lı kombinasyonlarının sayısınım C(n, k) olduğunu anımsayınız. Kümenin eleman sayısı 5 ise bu değer şöyle
    olacaktır:

    c(5, 3) = 5! / (3! * (5 - 3)!) = 10

    
    names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

    for index, t in enumerate(itertools.combinations(names, 3), 1):
        print(f'{index}: {t}') 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools 

s = 'ABCDEF'

iterator = itertools.combinations(s, 3)

for t in iterator:
    print(*t, sep='')
    
#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki permutations isimli fonksiyonu da Python kursumuzda görmüştük. Bu fonksiyon da combinations fonksiyonuyla 
    aynı parametrelere sahiptir. Ancak iterable nesnenin permütasyonlarını elde etmekte kullanılır. Permütasyonların bir dizilim 
    oluştduğunu anımsayız. Örneğin:
    
    for index, t in enumerate(itertools.permutations('ABCDE', 3), 1):
        print(f'{index}: {t}')

    n elemanlı bir kümenin k'lı permütasyonlarının sayısının P(n, k) = n! / (n - k)! olduğunu anımsayınız. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools 

s = 'ABCDEF'

iterator = itertools.permutations(s, 3)

for t in iterator:
    print(*t, sep='')
    
#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki combinations_with_replacement isimli fonksiyon yine dolaşılabilir nesnenin kombinasyonlarını verir ancak 
    kombinasyonlar aynı elemanlardan da oluşabilmektedir. Örneğin 'ABC' yazısının bu biçimdeki ikili kombinasyonları AA AB AC BB BC CC 
    biçimindedir. Örneğin:

    for index, t in enumerate(itertools.combinations_with_replacement('ABCDE', 2), 1):
        print(f'{index}:', *t)

    Buradan şöyle bir çıktı elde edilecektir:

    1: A A
    2: A B
    3: A C
    4: A D
    5: A E
    6: B B
    7: B C
    8: B D
    9: B E
    10: C C
    11: C D
    12: C E
    13: D D
    14: D E
    15: E E
    
    Ancak permutaions fonksiyonunun permeutaions_with_replacement biçiminde iadeli bir biçimi yokur. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

s = 'ABC'
result = itertools.combinations_with_replacement(s, 3)
for x in result:
    print(x)
     
#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki compress isimli fonksiyon bizden iki dolaşılabilir nesne alır. İkinci dolaşılabilir nesne bool değerler içerir. 
    (Eğer bu nesnedeki değerler bool türden değilse bool türe fonksiyon tarafından dönüştürülmektedir.) Fonksiyon bize bir dolaşım nesnesi  
    verir. Ancak bu dolaşım nesnesi dolaşıldığında ikinci dolaşılabilir nesnedeki True olan elemanlara karşı gelen birinci dolaşılabilir 
    nesnedeki elemanlar elde edilecektir. Fonksiyona girilen iki dolaşılabilir nesnenin aynı uzunlukta olması gerekmez. Kısa olan 
    bittiğinde işlem bitirilmektedir. Örneğin:
    
    a = ['ali', 'veli', 'selami', 'ayşe', 'fatma']
    b = [False, True, True, False, True]

    for x in itertools.compress(a, b):
        print(x, end=' ')                   # veli selami fatma
        
    Burada b dolaşılabilir nesnesindeki True olan elemanlara karşı gelen a'daki elemanlar elde edilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

s = ['ali', 'veli', 'selami', 'ayşe', 'fatma']
selector = [False, True, True, False, True]

result = itertools.compress(s, selector)            # ali selami ayşe 
for x in result:
    print(x, end=' ')
     
#------------------------------------------------------------------------------------------------------------------------------------
    Her ne kadar standart kütüphanedeki compress bir sınıf olarak yazılmışsa da standart kütüphane dokümantasyonunda muhtemel bir 
    gerçekleştirim aşağıdaki gibi verilmiştir:

    def compress(data, selectors):
        return (d for d, s in zip(data, selectors) if s)  

    Gördüğünüz gibi aslında bu işlem tek bir üretici ifadeyle yapılabilmektedir. Yukarıdaki işlemin işlevsel eşdeğeri şöyledir:

    def mycompress(data, selector):
        for d, s in zip(data, selector):
            if s:
                yield d
#-----------------------------------------------------------------------------------------------------------------------------------

def compress(data, selectors):
    return (d for d, s in zip(data, selectors) if s)       
        
s = ['ali', 'veli', 'selami', 'ayşe', 'fatma']
selector = [True, False, True, True, False]

result = compress(s, selector)    # ali selami ayşe 
for x in result:
    print(x, end=' ')
           
#------------------------------------------------------------------------------------------------------------------------------------
    compress fonksiyonunu biz de dolaşılabilir bir sınıf biçiminde aşağıdaki gibi yazabiliriz.
#------------------------------------------------------------------------------------------------------------------------------------

class mycompress:
    def __init__(self, data, selector):
        self.data_iter = iter(data)
        self.selector_iter = iter(selector)
        
    def __iter__(self):
        return self
    
    def __next__(self):
        while True:
            s = next(self.selector_iter)
            d = next(self.data_iter)
            if s:
                return d     
        
s = ['ali', 'veli', 'selami', 'ayşe', 'fatma']
selector = [True, False, True, True, False]

result = compress(s, selector)    # ali selami ayşe 
for x in result:
    print(x, end=' ')

#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki count fonksiyonu belli bir değerden başlayarak belli artımlarla sonsuz döngü içerisinde değer veren bir
    dolaşım nesnesi vermektedir. Artım değeri belirtilmezse default 1'dir. Başlangıç değeri verilmezse default 0'dır. Bu fonksiyonun 
    sonsuz döngü oluşturduğuna dikkat ediniz. Sizin bir biçimde bu döngüyü kırmanız gerekebilir. Örneğin:

    for x in itertools.count(10, 2):
        print(x, end=' ')
        if x == 50:
            break
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

for x in itertools.count(10, 2):
    print(x, end=' ')
    if x == 50:
        break

#------------------------------------------------------------------------------------------------------------------------------------
    count fonksiyonun muhtemel gerçekleştirimi standart kütüphane dokümanlarında aşağıdaki gibi verilmiştir:

    def mycount(start=0, step=1):
        while True:
            yield start 
            start += step

    Ancak standart kütüphanede aslında count dolaşılabilir bir sınıf biçiminde yazılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

def mycount(start=0, step=1):
    while True:
        yield start 
        start += step
        
for x in count():
    print(x, end=' ')        
    if x == 10:
        break

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii count fonksiyonu aslında standart kütüphanede üretici fonksiyon olarak değil bir sınıf olarak yazılmıştır. count fonksiyonunu
    sınıf biçiminde aşağıdaki gibi yazabiliriz:

    class mycount:
        def __init__(self, start=0, step=1):
            self.start = start
            self.step = step
            
        def __iter__(self):
            return self
        
        def __next__(self):
            self.start += self.step
            return self.start - self.step    
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

class mycount:
    def __init__(self, start=0, step=1):
        self.start = start
        self.step = step
        
    def __iter__(self):
        return self
    
    def __next__(self):
        self.start += self.step
        return self.start - self.step    
        
names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

for t in zip(names, mycount(0, 0.5)):
    print(t)
    
#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki cycle isimli fonksiyon parametresiyle aldığı dolaşılabilir nesneyi tekrar tekrar sonsuz döngü içerisinde 
    dolaşan bir dolaşım nesnesi verir. Yani dolaşılabilir nesne bitince hep yeniden dolaşılmaktadır. Örneğin:

    names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']
        
    for name in itertools.cycle(names):
        print(name)

    Burada bir sonsuz döngüde sürekli bu listenin elemanları dolaşılacaktır. Tabii programcı muhtemelen belli bir koşul sağlandığında
    break ile döngüyü kırmak isteyecektir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

s = 'ABC'

result = itertools.cycle(s)

for index, x in enumerate(result):
    print(x, end=' ')
    if index == 10:
        break

#------------------------------------------------------------------------------------------------------------------------------------
    cycle fonksiyonunu bir üretici fonksiyon olarak aşağıdaki gibi yazabiliri:

    def mycycle(iterable):
        while True:
            for item in iterable:
                yield item
        
    Ancak burada bir kusur vardır. Eğer bu fonksiyona bir kere dolaşıldığında biten bir iteratör verilirse bu durumda yield olmadan sonsuz
    döngü oluşur. Bu nedenle Python Standart Kütüphanesinin dokğmantasyonunda muhtemel gerçekleştirim aşağıdaki gibi verilmiştir:

    def cycle(iterable):
        saved = []
        for element in iterable:
            yield element
            saved.append(element)
        while saved:
            for element in saved:
                yield element

    Burada ilk kez dolaşım yapılırken elemanalr saklanmıştır. Sonra saklanan elemanlar dolaşılmıştır.
#------------------------------------------------------------------------------------------------------------------------------------
    
def cycle(iterable):
    saved = []
    for element in iterable:
        yield element
        saved.append(element)
    while saved:
        for element in saved:
              yield element
    
s = 'ABC'

for index, x in enumerate(cycle(s)):
    print(x, end=' ')
    if index == 10:
        break

#------------------------------------------------------------------------------------------------------------------------------------
                                            71. Ders 06/12/2025 - Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki filterfalse isimli fonksiyon iki parametre almaktadır. Birinci parametre bool değere geri dönen bir fonksiyondur.
    İkinci parametre dolaşılabilir bir nesnedir. Fonksiyon bize dolaşılabilir bir nesne verir. Bu nesne dolaşıldığında sırasıyla 
    ikinci parametresindeki dolaşılabilir nesnedeki elemanlar birinci parametresindeki fonksiyona sokulur, False olanlar bize verilir. 
    Aslında bu fonksiyon built-in filter fonksiyonunun tersini yapmaktadır. Örneğin:

    names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

    for name in itertools.filterfalse(lambda name: len(name) == 4, names):
        print(name)
    
    Burada biz eğer buil-in filter fonksiyonunu kullanıyor olsaydık 4 karakter olan isimleri elde ederdik. filterfalse ise bunun 
    tersini yapmaktadır. Tabii filterfalse yerine koşulu tersleyerek de filter uyhulanabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

for name in itertools.filterfalse(lambda name: len(name) == 4, names):
    print(name)
print('-' * 20)
for name in filter(lambda name: len(name) == 4, names):
    print(name)
    
#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki islice isimli fonksiyon bizden dolaşılabilir bir nesneyi ve start, stop, step değerlerini parametre olarak 
    alır. Bize yeni bir dolaşım nesnesi verir. Fonksiyonun verdiği dolaşım nesnesini dolaştığımızda fonksiyonda belirttiğimiz start 
    değerinden başlayarak, step artırımlarla stop değerine kadar ana dolaşılabilir nesnedeki elemanlar elde edilir. Bu fonksiyon özellikle 
    elimizdeki dolaşılabilir nesnenin belli bir kısmının dolaşılmasında kullanılmaktadır. islice fonksiyonun dolaşılabilir nesne 
    parametresi dışındaki parametrelerinin kullanımı tamamen range fonksiyonundaki gibidir. Yani fonksiyona yalnızca start değeri 
    girilirse bu değer stop değeri gibi kabul edilmektedir. Eğer start değeri girilip stop değeri de girilirse bu durumda start 
    değerinden stop değerine kadar elemanlar elde edilir. stop değeri None olarak girilirse "sonuna kadar" anlamına gelmektedir. 
    Örneğin:
    
    >>> s = 'abcdefghijklmn'
    >>> import itertools
    >>> for c in itertools.isclice(s, 5): print(c)
    ...
    a
    b
    c
    d
    e
    >>> for c in itertools.islice(s, 5, None): print(c)
    ...
    f
    g
    h
    i
    j
    k
    l
    m
    n
    >>> for c in itertools.islice(s, 5, 10, 2): print(c)
    ...
    f
    h
    j
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

s = {10, 20, 30, 40, 50, 60}
a = [3, 6, 8, 3, 8, 9]
m = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

result = itertools.islice(s, 3)
for x in result:
    print(x, end=' ')       # 50 20 40 sıra belli değil
    
print()

result = itertools.islice(a, 3)
for x in result:
    print(x, end=' ')       # 3 6 8 
    
print()
    
result = itertools.islice(m, 3)
for x in result:
    print(x, end=' ')       # ali veli selami 

#------------------------------------------------------------------------------------------------------------------------------------
    islice fonksiyonu özellikle dolaşılabilir bir nesnesnin belli bir yerinden itibaren dolaşıma başlanması için sıkça kullanılmaktadır. 
    Örneğin bir dosyanın bir ilk 5 satırını gereçerek geri kalan satırlarını bir döngü içerisinde işleme sokmak isteyelim. Bu işlemi 
    şöyle yapabiliriz:

    with open('test.txt') as f:        
        for line in itertools.islice(f, 5, None, 1):
            print(line, end='')
    
    Ya da örneğin daha önce görmüş olduğumuz sonsuz dönü oluşturan itertools fonksiyonlarında da islice fonksiyonun faydalanabiliriz. 
    Örneğin:

    for x in itertools.islice(itertools.count(), 0, 10):
        print(x)
            
    Örneğin bir dizilimin permütasyonlarının ilk 10 tanesini şöyle elde edebiliriz:

    s = 'ABCDEF'

    for t in itertools.islice(itertools.permutations(s), 10):
        print(t)
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Built-in min ve max fonksiyonlarının bir benzerini yazmaya çalışalım. Bu fonksiyonlara eğer tek argüman verilirse bunlar o 
    argümanı dolaşılabilir nesne kabul eder ve o dolaşılabilir nesnenin en küçük ya da enbüyük elemanlarına geri döner. (Özel durum 
    olarak eğer bu fonksiyonlara birden fazla argüman girilirse bunlar artık o argümanlara ilişkin en küçük ya da en büyük elemanlara 
    geri dönmektedir. Blindiği gibi en küçük ve en büyük sayıyı bulma algoritmasında ilk sayı en büyük ya da en küçük kabul edilir. 
    Sonra ondan daha büyük ya da daha küçük değer varsa o değer saklanır. Burada biz manuel olarak bunu sağlayabiliriz. Nesneyi bir 
    kez iterate ederiz ve ilk elemanı elde ederiz. Geri kalan elemanları for döngüsüyle dolaşabiliriz. Örneğin:

    def mymax(*iterables):
        if len(iterables) == 1:
            iterables = iterables[0]
            
        iterator = iter(iterables)
        max_val = next(iterator)
        
        for val in iterator:
            if val > max_val:
                max_val = val
        return max_val
#------------------------------------------------------------------------------------------------------------------------------------

def mymax(*iterables):
    if len(iterables) == 1:
        iterables = iterables[0]
        
    iterator = iter(iterables)
    max_val = next(iterator)
    
    for val in iterator:
        if val > max_val:
            max_val = val
    return max_val

a = [110, 4, 7, 2, 9, 10, 4, 3]

max_val = mymax(4, 7, 12, 21)
print(max_val)

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki programı deneme amacıyla itertools.islice ile yapmak isteyelim. Tabii aslında bu örnekte islice fonksiyonunu kullanmaya 
    hiç gerek yoktur.
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

def mymax(*iterables):
    if len(iterables) == 1:
        iterables = iterables[0]
        
    max_val = list(itertools.islice(iterables, 0, 1))[0]
    
    for val in itertools.islice(iterables, 1, None):
        if val > max_val:
            max_val = val
    return max_val

a = [110, 4, 7, 2, 9, 10, 4, 3]

max_val = mymax(4, 7, 12, 21)
print(max_val)

#------------------------------------------------------------------------------------------------------------------------------------
    Hiç itertools.islice kullanmadan herhangi bir dolaşılabilir nesnenin ilk n tane elemanını dolaşmak istersek bildiğimiz yöntemlerle
    bunu nasıl yapabiliriz? İlk akla gelen enumerate fonksşyonunu kullanmak olabilir:

    for index, val in enumerate(iterable):
        if index == 5:
            break
        print(val)

    zip fonksiyonu "kısa olan kadar" işleme izin verdiğine göre zip fonksiyonunu da kullanbiliriz. Örneğin:

    for _, val in zip(range(5), iterable):
        print(val)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Örneğin bir dolaşılabilir nesnenin başından ve sonundan n tane elemanı görüntülemek isteyelim. Dolaşılabilir nesnenin __len__ 
    metodunun bulunduğunu varsayalım. Böyle bir fonksiyonu aşağıdaki gibi yazabiliriz.    
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

def disp_head_tail(iterable, n = 5):
    for x in itertools.islice(iterable, n):
        print(x, end=' ')
    print('... ', end='')  
    for x in itertools.islice(iterable, len(iterable) - 5, None):
        print(x, end=' ')
    print()
    
s = {12, 45, 23, 11, 8, 67, 34, 23, 98, 46, 79, 34, 36, 90, 23, 78}

disp_head_tail(s)

a = [12, 45, 23, 11, 8, 67, 34, 23, 98, 46, 79, 34, 36, 90, 23, 78]

disp_head_tail(a)
        
#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki product isimli fonksiyon bizden bir grup dolaşılabilir nesneyi ayrı argümanlarla alır. Bunların kartezyen 
    çarpımlarını oluşturup demet biçiminde bize veren bir dolaşım bir nesne geri döndürür. Örneğin:

    a = ['x', 'y', 'z']
        b = [1, 2, 3]

    for t in itertools.product(a, b):
        print(t)
    
    Buradan şöyle bir çıktı elde edilecektir:

    ('x', 1)
    ('x', 2)
    ('x', 3)
    ('y', 1)
    ('y', 2)
    ('y', 3)
    ('z', 1)
    ('z', 2)
    ('z', 3)

    Burada product fonksiyonuna verdiğimiz argümanlar üç tane olsaydı bize verilen dolaşım nesnesi dolaşıldıkça üç elemanlı
    demetler elde edilecekti.
#------------------------------------------------------------------------------------------------------------------------------------

import itertools

a = ['x', 'y', 'z']
b = [1, 2, 3]

for t in itertools.product(a, b):
    print(t)
        
#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki repeat fonksiyonu bir nesneyi ve tekrar sayısını parametre olarak alır ve bize bir dolaşım nesnesi verir. 
    Fonksiyonun bize verdiği dolaşım nesnesini dolaştığımızda o tekrar sayısı kadar o nesneden elde ederiz. Eğer fonksiyonun ikinci 
    parametresi girilmezse (None girmeyiniz) fonksiyon hep aynı nesne nesneiyi vermeye devam eder. Örneğin:

    s = 'ankara'

    for x in itertools.repeat(s, 3):
        print(x)

    Burada üç kere "ankara" yazısı elde edilecektir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools
   
s = 'ankara'

for x in itertools.repeat(s, 3):
    print(x, end=' ')           # ankara ankara ankara 

#------------------------------------------------------------------------------------------------------------------------------------
    Standart kütüphane dokümanlarında repeat fonksiyonunun üretici fonksiyonlarla örnek gerçekleştirimi aşağıdaki gibi verilmiştir:

    def repeat(val, times=None):
    if times is None:
        while True:
            yield val
    else:
        for _ in range(times):
            yield val

    Her ne kadar standrat kütüphane fokğmanlarındaki gerçekleştirimde fonksiyonun ikinci parametresinin default değeri None biçiminde 
    belirtilmiş olsa da bu parametreye açıkça None verildiğinde gerçekte durumun böyle olmadığı anlaşılmaktadır. Dokmantasyonla davranış
    arasında bir çelişki vardır. 
#------------------------------------------------------------------------------------------------------------------------------------

def repeat(val, times=None):
    if times is None:
        while True:
            yield val
    else:
        for _ in range(times):
            yield val
        
s = 'ankara'

for x in repeat(s, 3):
    print(x, end=' ')           # ankara ankara ankara 
        
#------------------------------------------------------------------------------------------------------------------------------------
    Her ne kadar standart kütüphanedeki muhtemel gerçekleştirim üretici fonksiyon biçiminde verilmişse de CPython yorumlayıcısında 
    repeat bir sınıf biçiminde yazılmıştır. Aşağıda sınıfsal yazımı verilmiştir:

    class myrepeat:
        def __init__(self, obj, times=None):
            self.obj = obj
            self.times = times
            self.i = 0
            
        def __iter__(self):
            return self
        
        def __next__(self):
            if self.times is None:
                return self.obj
            
            if self.i >= self.times:
                raise StopIteration
            self.i += 1
            return self.obj
#------------------------------------------------------------------------------------------------------------------------------------

class myrepeat:
    def __init__(self, obj, times=None):
        self.obj = obj
        self.times = times
        self.i = 0
        
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.times is None:
            return self.obj
        
        if self.i >= self.times:
            raise StopIteration
        self.i += 1
        return self.obj
        
s = 'ankara'

for x in myrepeat(s, 3):
    print(x)S
    
#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki takewhile isimli fonksiyon bizden bir çağrılabilir nesne ve bir de dolaşılabilir nesne alır. Bize bir dolaşım 
    nesnesi verir. Onun verdiği dolaşım nesnesini dolaştığımızda orijinal dolaşılabilir nesnedeki elemanları elde ederiz. Ancak bu elemanlar 
    bizim birinci parametreyle verdiğimiz fonksiyona sokulup bu fonksiyon True geri döndürmüşse verilmektedir. Eleman fonksiyona sokulup
    ilk False elde edildiğinde tüm işlem sonlandırılır. Başka bir deyişle bu fonksiyon bizim verdğimiz fonksiyon False döndürene kadar 
    dolaşılabilir nesnenin elemanlarını bize vermektedir. Halbuki filter fonksiyonunun True olan değerlerin hepsini verdiğini anımsayınız.
    Örneğin:

    a = [12, 24, 46, 8, 9, 40, 21]

    for name in itertools.takewhile(lambda x: x % 2 == 0, a):
        print(name, end=' ')

    Burada ilk tek sayı görülene kadar işlemlere devam edilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import itertools
   
a = [12, 24, 46, 8, 9, 40, 21]

for x in itertools.takewhile(lambda x: x % 2 == 0, a):
    print(x, end=' ')       # 12 24 46 8 
    
#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki startmap fonksiyonu tamamen built-in map fonksiyonu gibidir. Ancak starmap fonksiyonunda dolaşılabilir nesne 
    dolaşılabilir nesnelerden oluşmalıdır. Bu durumda starmap fonksiyonundaki fonksiyona bu dolaşılabilir nesnenin elemanları olan 
    dolaşılabilir nesne *'lı argüman biçiminde aktarılmaktadır. Örneğin:

    def f(a, b, c):
        return (a + b ) % c

    a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

    for x in itertools.starmap(f, a):
        print(x)
        
    Burada starmap fonksiyonu a dolaşılabilir nesnesindeki elemanları birinci parametresinde belirtilen fonksiyona *'lı bir biçimde 
    geçrimektedir. Biz de onları farklı parametrelerle elde edebilmekteyiz. map ve starmap fonksiyonlarının üretici fonksiyon olarak 
    muhtemel gerçekleştirimi aşağıdaki gibi olabilir:

    def map(f, iterable):
        for x in iterable:
            yield f(x)

    def starmap(f, iterable):
        for x in iterable:
            yield f(*x)

#------------------------------------------------------------------------------------------------------------------------------------

import itertools
   
a = [12, 24, 46, 8, 9, 40, 21]

iterable = map(lambda x: x * x, a)
for x in iterable:
    print(x, end=' ')
    
a = [(1, 2), (3, 4), (5, 6)]

iterable = map(lambda t: t[0] + t[1], a)
for x in iterable:
    print(x, end=' ')

a = [(1, 2), (3, 4), (5, 6)]

iterable = itertools.starmap(lambda x, y: x + y, a)
for x in iterable:
    print(x, end=' ')

#------------------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki tee isimli fonksiyon bir dolaşılabilir nesneyi ve bir d değerini alıp bize bir demet biçiminde n tane dolaşım 
    nesnesi vermektedir. İlk bakışta kişilere fonksiyon anlamsız bir iş yapıyormuş gibi gelebilmektedir. Ancak iter fonksiyonuyla 
    bir iterator elde edilmişse bu iterator bir kez dolaşıldığında artık sona gelinir ve bir daha dolaşılamaz. İteratör nesnelerinin 
    de dolaşılabilir olduğunu anımsayınız. Örneğin:

    >>> a = [1, 2, 3]
    >>> iterator = iter(a)
    >>> list(iterator)
    [1, 2, 3]
    >>> list(iterator)
    []

    Burada bir iterator bir kez dolaşılmış ve tüketilmiştir. İkinci kez dolaşılmak istendiğinde artık dolaşacak bir şey kalmadığı 
    için bir değer elde edilememiştir. İşte biz bu işlemi itertools modülündeki tee fonksiyonu ile yaparsak başlangıçta bir tane
    iterator değil n tane iterator elde edebiliriz. Böylece birisi tükense bile diğerleri tükenmemiş olur. Örneğin:

    >>> import itertools
    >>> a = [1, 2, 3]
    >>> iterator = iter(a)
    >>> t = itertools.tee(a, 3)
    >>> list(t[0])
    [1, 2, 3]
    >>> list(t[1])
    [1, 2, 3]
    >>> list(t[2])
    [1, 2, 3]

    Özetle tee fonksiyonu bir kez dolaşıldığında biten bir iteratör varsa onu n kez dolaşabilmek için kullanılmaktadır. Fonksiyondaki 
    ikinci parametre olan n default 2 değerini almaktadır:


#------------------------------------------------------------------------------------------------------------------------------------


a = [1, 2, 3, 4]
iterator = iter(a)

iterators = itertools.tee(iterator)
for x in iterators[0]:
    print(x, end= ' ')
print()
for x in iterators[1]:
    print(x, end= ' ')

#------------------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda itertools modülünde bulunan pek fonksiyon gördük. Şimdi de Bu fonksiyonların bir özetini yapalım:

    - accumulate(iterable, func=operator.add)
    Birikimli şekilde toplama (veya verilen işleve göre biriktirme) yapar.
    Örn: [1,2,3] → [1,3,6]

    - chain(*iterables)
    Birden fazla iterable’ı tek bir iterable gibi ardışık birleştirir.

    - combinations(iterable, r)
    Sıra önemli olmadan elemanlardan r’li tüm kombinasyonları üretir.
    Tekrarsızdır.

    - permutations(iterable, r=None)
    Sırası önemli olacak şekilde r’li tüm permütasyonları üretir.

    - combinations_with_replacement(iterable, r)
    Elemanların tekrarına izin vererek r’li kombinasyonları üretir.

    - compress(data, selectors)
    selectors içindeki True değerlerine göre data’daki öğeleri filtreler.

    - count(start=0, step=1)
    Sonsuz bir sayı üreteci: start’tan başlar, step kadar artar.

    - cycle(iterable)
    Iterable’ı sonsuz döngüde tekrar eder.

    - filterfalse(predicate, iterable)
    predicate(item) False döndürdüğü öğeleri geçirir (normal filter’ın tersi).

    - islice(iterable, start, stop, step=1)
    Bir iterable’dan dilimleme yapar.

    - product(*iterables, repeat=1)
    Kartezyen çarpım oluşturur.

    - takewhile(predicate, iterable)
    Şart True olduğu sürece öğeleri üretir, False ile karşılaşınca durur.

    - tee(iterable, n=2)
    Bir iterable’ı bağımsız n adet kopyaya böler.

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi Python'da dilin içerisinde zaten var olan bazı veri yapıları bulunmaktadır. Programcılar pek çok işleminde
    bunları kullanırlar. Python kursunda gördüğümüz built-in veri yapıları şunlardır:
    
    list
    tuple
    set
    frozenser
    dict
    str 
    bytes
    
    Ancak bu veri yapıları bazı tür uygulamalar için yetersiz olabilmektedir. İşte standart kütüphanedeki "collections" isimli 
    modülde bazı ek veri yapıları da bulundurulmuştur.     
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    collections modülü içerisindeki built-in olmayan önemli bir veri yapısı deqeue isimli ver yapısıdır. Bu veri yapısı deque isimli 
    bir sınıfla temisle edilmiştir. "deque" sözcüğü "double-ended queue" sözcüklerinden kısaltılarak uydurulmuştur ve "dek" biçiminde 
    telaffuz edilmektedir. ("di kyu" biçiminde teleaffuz edilmemektedir.) deque sınıfı aslında list sınıfına oldukça benzemektedir. 
    list sınıfında sona eleman O(1) karmaşıklıkta çok hızlı bir biçimde eklenir. Ancak başa eleman ekleme eleman kaydırması gerekitği 
    için O(n) karmaşıklıkta yavaş bir işlemdir. Benzer biçimde list sınıfında sonda eleman da hızlı bir biçimde O(1) karmaşıklıkta 
    silinebilemktedir. Ancak baştaki elemanın silinmesi yine eleman kaydırması (shrink işlemi) gerektirdiği için ancak O(n) karmaşıklıkta
    yani yavaş bir biçimde yapılmaktadır. 
    
    Bazı uygulamalarda veri yapısının başına ve sonuna eleman ekleme, başından ve sonundan eleman silme çok karşılaşılan bir işlemdir. 
    İşte "deque" denilen veri yapısının başına ve sonuna O(1) karmaşlıklıkta çok hızlı eleman eklenebilmekte aynı zamanda başından 
    ve sonundan O(1) karmaşıklıkta çok hızlı eleman silinebilmektedir. Algoritmalar dünyasında bir döngü ile yapılan işlemlere O(N) 
    karmaşıklıkta işlemler denilmektedir. Döngü olmadan yapılan işlemlere ise O(1) karmaşıklıkta işlemler denilmektedir. İşte listelerde 
    sona eleman ekleme ve sondan eleman silme O(1) karmaşıklıkta yapılabildiği halde başa eleman ekleme ve baştan eleman silme ancak 
    ancak bir dönü ile O(N) karmaşıklıkta yapılabilmektedir. Halbuki deque veri yapısında hem sona hem de başa eleman O(1) karmaşıklıkta 
    eklenebilmekte ve hem baştan hem de sondan eleman O(1) karmaşıklıkta silinebilmektedir. O halde özel bazı uygulamalarda iki taraftan 
    da ekleme ve silme çokça yapılıyorsa list yerine deque veri yapısının kullanılması uygun olur. 

    Şüphesiz deque veri yapısı list veri yapısından dha yetenekli gibi gözüküyor olsa da aslında deque veri yapısının da list veri 
    yapısına göre bazı dezavantajları söz konusudur. Genel olarak yalnızca sona eklemenin yapıldığı durumlarda list veri yapısı hem 
    daha hızlı hem de daha az yer kaplamaktadır. Dolayısıyla ancak gerektiği durumlarda list yerine deque kullanılması gerekir. 

    Aslında yukarıda da belirttiğimiz gibi deque sınıfı kullanım bakımından list sınıfına çok benzemektedir. list sınıfının metotlarının 
    çoğu deque sınıfında da vardır. Ancak deque sınıfında sona ekleme yapan append metodunun yanı sıra başa ekleme yapan appendleft 
    metodu da bulunmaktadır. Benzer biçimde deque sınıfında da extend metodunun yanı sıra extendleft isimli metot da bulunmaktadır. 
    list sınıfının pop metodu herhangi bir indeksteki elemanı silmek için kullanılıyordu. Eğer pop metoduna argüman geçmezsek bu metot 
    son elemanı siliyordu. Ancak deque sınıfının pop metodu  zaten parametresizdir, her zaman son elemanı siler. deque sınıfında 
    baştaki elemanı silmek için parametresiz popleft isimli bir metot da bulunmaktadır. 
    
    Tabii deque sınıfında da istenilen indeksteki elemanlara listelerde olduğu gibi [] operatörü ile erişilebilir. Örneğin:

    import collections

    d = collections.deque([10, 20, 30, 40, 50])
    d.append(100)
    d.appendleft(200)
    print(d)

    for val in d:
        print(val, end=' ')
    print()
    for i in range(len(d)):
        print(d[i], end=' ')
        
    Görüldüğü gibi deque sınıfı list gibi kullanılmaktadır. Ancak başa eleman ekleme ve baştan eleman silmeye yönelik ekstra 
    metotlara sahiptir.
#------------------------------------------------------------------------------------------------------------------------------------

import collections

d = collections.deque()

d.append(1)
d.append(2)
d.appendleft(3)
d.appendleft(4)
   
d.extend([10, 20, 30])
d.extendleft([40, 50, 60])

for x in d:
    print(x, end=' ')           # 60 50 40 4 3 1 2 10 20 30   
print()
for i in range(len(d)):
    print(d[i], end=' ')        # 60 50 40 4 3 1 2 10 20 30 

print()

d.popleft()
d.pop()

print(d)                        # deque([50, 40, 4, 3, 1, 2, 10, 20])

#------------------------------------------------------------------------------------------------------------------------------------
    deque sınıfının list sınıfında olmayan "döndürme (rotate)" işlemi yapan rotate bir metodu vardır. rotate işlemi bir kez yapıldığında 
    en sağdaki eleman en sola alınır ve diğer elemanlar bir sağa kaydırılır. Örneğin deque içerisinde şu elemanlar olsun:

    10 20 30 40 50 

    Bir kez rotate işlemi yapalım. Aşağıaki durum oluşacaktır:

    50 10 20 30 40

    rotate işlemi birden fazla kez de yapılabilir. Şimdi yukarıdaki ilk değerleri 2 kez rotate yapalım:

    40 50 10 20 30

    rotate metodunun parametresi rotate miktarını almaktadır. Default rotate miktarı 1'dir. 

    Aslında bir kez rotate yapmak d.appendleft(d.pop()) ile aynı anlamdadır. Bu biçimdeki rotate işlemine sağa rotate işlemi denilmektedir. 
    (Çünkü kaydırma sağa doğru yapılmaktadır.) Örneğin:

    d = collections.deque([10, 20, 30, 40, 50])
    d.rotate(2)     # deque([40, 50, 10, 20, 30])
    print(d)
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
d = coll.deque([10, 20, 30, 40, 50])
print(d)        # deque([10, 20, 30, 40, 50])
d.rotate(1)     # sağa bir kez döndürme
print(d)        # deque([50, 10, 20, 30, 40])
d.rotate(3)
print(d)        # deque([20, 30, 40, 50, 10])

#------------------------------------------------------------------------------------------------------------------------------------
    rotate metodunun döndürme miktarını belirten parametresi negatif girilirse bir sayı bçiminde girilirse döndürme sola doğru 
    yapılmaktadır. Sola bir kez döndürme işlemi d.append(d.popleft()) ile eşdeğerdir. 
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
d = coll.deque([10, 20, 30, 40, 50])
print(d)            # deque([10, 20, 30, 40, 50])
d.rotate(-1)        # sola bir kez döndürme
print(d)            # deque([20, 30, 40, 50, 10])
d.rotate(-3)
print(d)            # deque([50, 10, 20, 30, 40])

#------------------------------------------------------------------------------------------------------------------------------------
    Döndürme gibi bir işleme nedne gereksinim duyulduğunu merak edebilirsiniz. Bazı algoritmalarda bu döndürme teması kullanılmaktadır. 
    Örneğin bir oyunda oyuncular her parti sonunda birer kayarak yer değiştirebilmektedir. Ya da örneğin zaman serilerinde başlangıç 
    noktasının kaydırılması gerekebilir:

    days = deque(["Paz", "Pzt", "Sal", "Çar", "Per", "Cum", "Cmt"])
    days.rotate(-1)  # Pzt başa gelsin

    Burada haftanın ilk günü Pazar'dır. Biz hatanın ilk gününü sola döndürme yaparak Pazartesi haline getirebiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    deque nesnesini yaratırken maxlen parametresi ile bir uzunluk da belirleyebiliriz. Eğer bu parametre verilirse deque nesnesi 
    maksimum belirtilen uzunlukta olabilir. Bu durumda uzunluk yetmezse sona ekleme durumunda baştaki eleman, başa ekleme durumunda 
    da sondaki eleman deque'ten atılmaktadır. örneğin:

    d = collections.deque(maxlen=5)

    d.append(10)
    d.append(20)
    d.append(30)
    d.append(40)
    d.append(50)

    print(d)            # deque([10, 20, 30, 40, 50], maxlen=5)
    d.append(100)
    print(d)            # deque([20, 30, 40, 50, 100], maxlen=5)
    d.append(200)      
    print(d)            # deque([30, 40, 50, 100, 200], maxlen=5)
    d.appendleft(300)
    print(d)            # deque([300, 30, 40, 50, 100], maxlen=5)
#------------------------------------------------------------------------------------------------------------------------------------

d = collections.deque(maxlen=5)

d.append(10)
d.append(20)
d.append(30)
d.append(40)
d.append(50)

print(d)            # deque([10, 20, 30, 40, 50], maxlen=5)
d.append(100)
print(d)            # deque([20, 30, 40, 50, 100], maxlen=5)
d.append(200)      
print(d)            # deque([30, 40, 50, 100, 200], maxlen=5)
d.appendleft(300)
print(d)            # deque([300, 30, 40, 50, 100], maxlen=5)

#------------------------------------------------------------------------------------------------------------------------------------
    maxlen parametresi dolaşılabilir bir nesnenin sondaki n değerin elde edilmesinde kullanılabilir. Örneğin dosyalar dolaşılabilir 
    nesnelerdir. Dosya nesnesi dolaşıldığında dosyanın satırları elde edilir. (Bu satırların sonlarında '\n' karakteri bulunmaktadır.)
    O halde deque nesnesi ile biz örneğin bir dosyanın sonundaki n tane satırı elde edebiliriz. Bu işlemin daha pratik bir yolu 
    varsa bile zahmetlidir. (Dosyanın sonuna konumlanıp geriye gidilebilir. Ancak text dosyalarda dosya göstericisi bu biçimde 
    konumlandırılamamaktadır.) Örneğin:

    import collections as coll

    d = collections.deque(maxlen=5)
    with open('test.txt') as f:
        for line in f:
            d.append(line)
            
    for line in d:
        print(line, end='')

    Burada biz aslında dosyanın tüm satırlarını sanki deque nesnesine ekliyormuşuz gibi yaptık. Ancak deque nesnesi her zaman
    son eklenen 5 satırı bize vermiştir.
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll

d = coll.deque(maxlen=5)
with open('test.txt') as f:
    for line in f:
        d.append(line)
        
for line in d:
    print(line, end='')
        
#------------------------------------------------------------------------------------------------------------------------------------
    Örneğin biz tek sayıları bir dizinin başına, çift sayıları sonuna eklemek isteyelim. Bu iş için deque oldukça verimlidir. Aşağıdaki
    örnekte 100 tane rastgele sayı üretilerek deque içerisine bu biçimde yerleştirilmiştir. 
#------------------------------------------------------------------------------------------------------------------------------------

import random
import collections as coll

d = coll.deque()

for _ in range(100):
    val = random.randint(0, 1000)
    if val % 2 != 0:
        d.appendleft(val)
    else:
        d.append(val)
        
a = list(d)
print(a)

#------------------------------------------------------------------------------------------------------------------------------------    
                                                72. Ders 07/12/2025 - Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    deque sınıf ile ile FIFO ya da LIFO kuyruk sistemleri de kolayla oluşturulabilir. Biz daha önce queue modülündeki ve multiprocessing 
    modülündeki Queue sınıflarını görmüştük. Ancak bu Queue sınıfları "üretici-tüketici" problemi için düşünülmüş olan "senkronize" 
    kuyruk sistemleri oluşturmaktadır. Dolayısıyla daha önce görmüş olduğumuz Queue sınıfları "multi-threaded" ve "multi-processing" 
    uygulamalar için düşünülmüştür. Tabii biz bu Queue sınıfını thread'siz (single-threaded) programlarda da kullanabiliriz. Ancak 
    bu durumda performans düşer. İşte collections modülündeki deque sınıfı sayesinde FIFO ve LIFO kuyruk sistemleri kolayca 
    oluşturulabilmektedir. Örneğin biz bir deque nesnesi yaratıp elemanları bu nesnenin sonuna ekleyip başında alırsak ya da başına 
    ekleyip sonundan alırsak bir FIFO kuyruk sistemi oluşturmuş oluruz. Benzer biçimde biz bir deque nesnesi yaratıp elemanları başa 
    ekleyip baştan alırsa, ya da sona ekleyip sondan alırsa bir LIFO kuyruk sistemi oluşturmuş oluruz. Dolayısıyla Python'un standart 
    kütüphanesinde ayrı bir kuyruk ya da stack veri yapısı yoktur. Zaten bu veri yapıları deque kullanılarak gerçekleştirilebilmektedir. 

    Bilindiği gibi FIFO kuyruk sistemleri bilgileri sırası bozulmadan geçici olarak saklamak amacıyla kullanılmaktadır. Aşağıdaki 
    örnekte 1'den 100' kadar sayılar bir kuyruk sistemine eklenip geri alınmıştır.
#------------------------------------------------------------------------------------------------------------------------------------

import random
import collections as coll

q = coll.deque()

q.append(10)
q.append(20)
q.append(30)
q.append(40)
q.append(50)

while len(q) != 0:
    val = q.popleft()
    print(val, end=' ')
print()
    
#------------------------------------------------------------------------------------------------------------------------------------
    LIFO kuyruk sistemlerine "stack" sistemleri de denilmektedir. Doğadaki bazı olaylarda stack yapısı gözlenmektedir. Örneğin üst üste 
    tabakları koyduğumuzda önce en son koyduğumuzu önce alırız. Bir asansöre binenler geri çekildiği için son binen önce iner. Programalamada 
    stack sistemi pek çok yerde kullanılmaktadır. Örneğin "undo" mekanizması bir stack sistemi gibi çalışır. Yani biz "undo" yaptığımızda 
    son yaptığımız değişikliği geri alırız. Ya da örneğin parsing algoritmalarında stack kullanılmaktadır. Stack bir şeyi ters yüz etmek 
    için de kullanılmaktadır. 
    
    Python'da bir LIFO kuyruk deque sınıfı kullanılarak gerçekleştirilebilir. Örneğin biz deque nsnesinin başına eleman ekleyip 
    elemanı baştan alırsak ya da sonuna eleman ekleyip elemanı sondan alırsak aslında bir LIFO kuyruk sistemi oluşturmuş oluruz. Tabii
    LIFO kuyruk sistemi aslında deque sınıfına da gerek yoktur. Pekala listeler de aynı amaçla kullanılabilir. Listelerde append işlemi 
    ve pop işlemi sona ekleyip sondan eleman almaktadır. Sona ekleme ve sondan eleman çekme listelerde yine O(1) karmaşıklıkta bir 
    işlemdir. 
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
q = coll.deque()

for x in range(100):
    q.appendleft(x)
    
while len(q):
    val = q.popleft()
    print(val, end=' ')
    
#------------------------------------------------------------------------------------------------------------------------------------
    collections modülü içerisindeki diğer bir nesne tutan sınıf da ChainMap isimli sınıftır. ("Chain" zincir anlamına, "Map" ise bu 
    bağlamda sözlük (dictionary) anlamına gelmektedir.) Biz ChainMap nesnesine birden fazla sözlük veriririz. Sonra bu ChainMap üzerinde 
    anahtara dayalı arama yaptığımızda (bunun için yine [] operatörü ya da get metodu kullanılabilir) nesne bizim verdiğimiz sözlüklere 
    sırasıyla bakar ve ilk bulduğu sözlükteki değeri bize verir. Böylece ChainMap nesnesi bir "scope" mantığını pratik bir biçimde 
    oluşturmak için kullanılabilmektedir. Bir ChainMap nesnesi sınıfın __init__ metodunda argümanlar halinde verilir. (Metodun parametresi
    *'lıdır.) Örneğin:

    d = {'ali': 10, 'veli': 20, 'selami': 30}
    k = {'ayşe': 40, 'ali': 50, 'fatma': 60}
    m = {'selami': 70, 'sacit': 80, 'hasan': 90}

    cm = collections.ChainMap(d, k, m)

    Sonra arama yapılır. Artık arama sırasıyla ilk verilen sözlükten son verilen sözlüğe doğru yapılmaktadır. Örneğin:

    val = cm.get('ali')
    print(val)                  # 10
    d.pop('ali')
    val = cm.get('ali')         # 50
    print(val)
#------------------------------------------------------------------------------------------------------------------------------------

import collections 

d = {'ali': 10, 'veli': 20, 'selami': 30}
k = {'ayşe': 40, 'ali': 50, 'fatma': 60}
m = {'selami': 70, 'sacit': 80, 'hasan': 90}


cm = collections.ChainMap(d, k, m)

val = cm.get('ali')
print(val)
d.pop('ali')
val = cm.get('ali')
print(val)

#------------------------------------------------------------------------------------------------------------------------------------
    ChainMap nesnesi dolaşıldığında ya da keys ve values metotlarıyla anahtar ve değerler elde edildiğinde her zaman son sözlükten ilk 
    sözlüğe doğru bir dolaşma yapılmaktadır. Örneğin ChamMap nesnesi ChanMap(d, k, m) biçiminde oluşturulmuş olsun. Biz bu nesneyi 
    dolaştığımızda önce m nesnesinin anahtarları, sonra k nesnesinin anahtarları sonra da d nesnesinin anahtarları elde edilecektir. 
    Ayrıca dolaşım sırasında sözlüklerde birden fazla aynı anahtar varsa yalnızca ilk karşılaşan sözlükteki anahtar verilmektedir. 
    Örneğin:

    d = {'ali': 10, 'veli': 20, 'selami': 30}
    k = {'ayşe': 40, 'ali': 50, 'fatma': 60}
    m = {'selami': 70, 'sacit': 80, 'hasan': 90}

    cm = collections.ChainMap(d, k, m)

    for key in cm:
        print(key)

    Burada dolaşım sonucunda sırasıyla şu değerler elde edilecektir:

    selami
    sacit
    hasan
    ayşe
    ali
    fatma
    veli

    ChainMap sınıfının values  metodu ile değerler elde edilirken önce anahtarlar yukarıda belirtilen kurala göre elde edilir. Sonra 
    o anahtarlara ilişkin değerler düz sırada elde edilir. Örneğin:

    d = {'ali': 10, 'veli': 20, 'selami': 30}
    k = {'ayşe': 40, 'ali': 50, 'fatma': 60}
    m = {'selami': 70, 'sacit': 80, 'hasan': 90}

    cm = collections.ChainMap(d, k, m)
    for value in cm.values():
        print(value)

    Buradan değerler şu sırada elde edilecektir:

    30
    80
    90
    40
    10
    60
    20
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
d = {'ali': 10, 'veli': 20, 'selami': 30}
k = {'ayşe': 40, 'ali': 50, 'fatma': 60}
m = {'selami': 70, 'sacit': 80, 'hasan': 90}

cm = coll.ChainMap(d, k, m)

for key in cm.keys():
    print(key, end = ' ')       # sondan başa selami sacit hasan ayşe ali fatma veli 

print()

for val in cm.values():
    print(val, end = ' ')       # 30 80 90 40 10 60 20 

print()
    
# yukarıdakinin eşdeğeri

for key in cm.keys():
    val = cm[key]
    print(val, end = ' ')        # 30 80 90 40 10 60 20  

#------------------------------------------------------------------------------------------------------------------------------------
    Bir ChainMap nesnesine ekleme yapıldığında ekleme her zaman ilk sözlük nesnesine yapılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
d = {'ali': 10, 'veli': 20, 'selami': 30}
k = {'ayşe': 40, 'ali': 50, 'fatma': 60}
m = {'selami': 70, 'sacit': 80, 'hasan': 90}

cm = coll.ChainMap(d, k, m)

cm['hüseyin'] = 100
cm['jale'] = 200

print(cm)
print(d)        # {'ali': 10, 'veli': 20, 'selami': 30, 'hüseyin': 100, 'jale': 200}

#------------------------------------------------------------------------------------------------------------------------------------
    Benzer biçimde ChainMap sınıfından pop metoduyla eleman silinmek istendiğinde silme her zaman sanki yalnızca birinci sözlük varmış 
    gibi yapılmaktadır. (Yani silinecek anahtar birinci sözlükte yoksa ancak diğer sözlüklerin birinde varsa pop exception fırlatmaktadır.
    Başka bir deyişle eleman ekleme ve silme işlemlerinde işlemler sanki yalnızca ilk sözlük varmış gibi yürütülmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
d = {'ali': 10, 'veli': 20, 'selami': 30}
k = {'ayşe': 40, 'ali': 50, 'fatma': 60}
m = {'selami': 70, 'sacit': 80, 'hasan': 90}

cm = coll.ChainMap(d, k, m)

print(cm)

cm.pop('selami')

print(cm)

val = cm.pop('sacit', 'Not Found')
print(val)          # Not Found

#------------------------------------------------------------------------------------------------------------------------------------
    ChainMap sınıfının maps örnek özniteliği bizim nesne yaratılırken verdiğimiz sözlükleri bize bir liste biçiminde verir. parents 
    örnek özniteliği ilk sözlük dışındaki tüm sözlükleri bize bir liste olarak vermektedir. Sınıfın new_child metodu bazı "scope" 
    uygulamalarında nesneye yeni bir sözlüğün eklenmesi amacıyla bulundurulmuştur. Metot yeni bir ChainMap nesnesi yaratır ve 
    bizim verdiğimiz sözlüğü bu yeni ChainMap nesnesinin başına ekler. Dolayısıyla cm bir ChainMap nesnesi ve d de bir sözlük 
    nesnesi belirtmek üzere aşağıdaki iki ifade eşdeğerdir:

    cm = cm.new_child(d) 
    cm = ChainMap(d, *d.maps)

    new_child metodu parametresiz de kullaılabilir. Bu durumda boş bir sözlük eklenir. 
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
d = {'ali': 10, 'veli': 20, 'selami': 30}
k = {'ayşe': 40, 'ali': 50, 'fatma': 60}
m = {'selami': 70, 'sacit': 80, 'hasan': 90}

cm = coll.ChainMap(d, k, m)

print(cm)

child = cm.new_child({'kazım': 100, 'levent': 110})     # eşdeğeri child = ChainMap({'kazım': 100, 'levent': 110}, *cm.maps)
print(child)
              
#------------------------------------------------------------------------------------------------------------------------------------
    Eskiden collections modülündeki OrderedDict sınıfı bir çeşit sözlük nesnesi oluşturuyordu. Ancak bu sözlük nesnesi dolaşıldığında 
    dolaşım eklenme sırasına göre yapılıyordu. Fakat zaten artık Python 3.7 ile birlikte built-in dict sınıfı da bu özelliğe sahip 
    olmuştur. Bu nedenle OrderedDict sınıfının birkaç önemsiz özelliğinin dışında bir kullanım gereği kalmamıştır. Fakat geçmişe 
    doğru uyumun korunması için bu sınıf muhafaza edilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    collections modülünde namedtuple isimli önemli bir fonksiyon vardır. Bu fonksiyon "isimli demet (named tuple)" oluşturmak için 
    kullanılmaktadır. İsimli demetler bir demetin bütün özelliklerini bünyesinden barındıran ancak demet elemanlarına köşeli parantez 
    operatörünün yanı sıra isimlerle de erişmeyi sağlayan ve bunu yaparken de nesne üzerinde ek bir maaliyet oluşturmayan sınıflardır. 
    Aslında isimli demetler built-in tuple sınıfından türetme yapılarak da manuel biçimde oluşturulabilmektedir. Buna ilişkin bir 
    örneği izleyen bölümlerde vereceğiz. Ancak manuel oluşturma zahmetlidir ve modüldeki namedtuple fonksiyonu bunu otomatize 
    etmektedir. İsimli bir demete benzer işlevsellik normal sınıflarla da verilebilir. Örneğin:

    class Point:
        def __init__(self, x, y):
            self.x = x
            self.y = y

    pt = Point(10, 20)

    print(pt.x, pt.y)

    Ancak normal sınıfların bazı ek maaliyetleri vardır ve aynı zamanda genellik de sağlanamamaktadır. Oysa isimli demetler maaliyetsiz 
    bir biçimde gerçekleştirilmektedir. Ayrıca normal sınıflarda "açım (unpacking)" işlemleri de yapılamamaktadır.

    Bir isimli demet namedtuple fonksiyonu ile oluşturulur. Bunun için fonksiyonun birinci parametresine oluşturulacak sınıfın metadata 
    ismi verilir. Bu isim bizim için önemli olmasa da bazı ileri uygulamalarda gerekebilmektedir. Bu isim istenirse ilgili sınıf türünden 
    nesne ile __class__ örnek özniteliği  kullanılarak elde edilebilir. namedtuple fonksiyonunun ikinci parametresi demet elemanlarının 
    isimlerini içeren dolaşılabilir bir nesne olmalıdır. Biz namedtuple fonksiyonunun geri dönüş değerini bir değişkene atarız. Artık o 
    değişken bir sınıf ismi gibi nesne yaratmakta kullanılabilir. Örneğin:

    Fruit = collections.namedtuple('Fruit', ['banana', 'orange', 'apricot'])
    
    Burada Fruit bir sınıf gibidir. Sınııfn metadata ismiyle onun atandığı değişken isminin aynı olması gerekmez. Burada biz artık
    Fruit sınıfı türünden bir nesne yaratabiliriz. Aslında bir demet yaratmış oluruz. Örneğin:

    f = Fruit(10, 20, 30)

    Burada f değişkeni Fruit türündendir. Fruit ise tuple sınıfından türetilmiştir. Biz buradaki demetin elemanlarına normal 
    köşeli parantezlerle de verdiğimiz isimlere ilişkin özniteliklerle de erişebiliriz. Örneğin:

    print(f[0], f[1], f[2])                         # 10 20 30
    print(f.banana, f.orange, f.apricot)            # 10 20 30

    namedtuple fonksiyonunun bize verdiği sınıf aslında built-in tuple sınıfından türetilmiş bir sınıftır. Dolaysıyla bu sınıf türünden 
    nesne yaratıldığında aslında demetin tüm işlevselliği kullanılabilöektedir. Ek olarak tabii elemanlara isimlerle de erişebiliriz. 
    Örneğin:

    Point = collections.namedtuple('Point', ['x', 'y'])
    pt = Point(10, 20)

    print(pt[0], pt[1])
    print(pt.x, pt.y)

    Görüldüğü gibi burada namedTuple fonksiyonunun geri döndürdüğü değer bir değişkene atanmış o değişken de sanki bir sınıfmış gibi 
    kullanılmıştır. Örneğimizdeki Point sınıfı aslında tuple sınıfından türetilmiş durumdadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll
   
Point = coll.namedtuple('Point', ['x', 'y'])

t = Point(10, 20)

print(t[0], t[1])           # 10 20
print(t.x, t.y)             # 10 20

print(Point.__bases__)      # (<class 'tuple'>,)

#------------------------------------------------------------------------------------------------------------------------------------
    namedtuple fonksiyonunun birinci parametresiyle verdiğimiz isim aslında yaratılan nesnenin türüne ilişkin sınıfın metadata 
    ismidir. Örneğin:

    import collections as coll

    Z = coll.namedtuple('Complex', ['real', 'imag'])

    z = Z(10, 2)

    Burada z değişkeni Complex isimli sınıf türündendir. Ancak bu sınıfın type nesne referansını gösteren değişken Z ismindedir. Complex 
    sınıfı tuple sınıfından türetilmiş durumdadır. Durumu şekilsel olarak şöyle gösterebiliriz:

    Z ----> type (nesnesi Complex sınıfı türünden tuple sınıfından türetilmiş)

    Yani yukarıdaki isimli demet oluşturma ifadesinde aslında tuple sınıfından türetilmiş olan Complex isimli bir sınıf oluşturulmuştur.
    Ancak bu sınıfın referansı Z değişkeninde tutulmaktadır. Bu durum izleyen paragraflarda ele alacağımız "meta sınıflar" konusundan 
    sonra daha iyi anlaşılacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll

Z = coll.namedtuple('Complex', ['real', 'imag'])

z = Z(10, 2)
print(z.real, z.imag)

print(type(z))              # Complex
print(type(Z))              # type
print(type(z).__bases__)    # (tuple,)

#------------------------------------------------------------------------------------------------------------------------------------
    İsimli demetler pek çok kütüphanede özellikle de fonksiyonların geri dönüş değerlerinde sıkça kullanılmaktadır. Örneğin ikinci 
    derece bir denklemin köklerini veren getroots isimli bir fonksiyon olsun. Biz bu fonksiyonu normal demet yerine sisimli bir demetle geri 
    döndürebiliriz:
    
    Roots = collections.namedtuple('Root', ['x1', 'x2'])

    def get_roots(a, b, c):
        delta = b ** 2 - 4 * a * c
        if delta < 0:
            return None
        x1 = (-b + math.sqrt(delta)) / (2 * a)
        x2 = (-b - math.sqrt(delta)) / (2 * a)
        return Roots(x1, x2)

    Fonksiyonunun kullanımı şöyle olabilir:

    result = get_roots(1, 0, -4)
    if result:
        print(result.x1, result.x2)

    Burada köklere x1 ve x2 isimleriyle erişildiğine dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------------------

import collections 
import math

Roots = collections.namedtuple('Root', ['x1', 'x2'])

def get_roots(a, b, c):
    delta = b ** 2 - 4 * a * c
    if delta < 0:
        return None
    x1 = (-b + math.sqrt(delta)) / (2 * a)
    x2 = (-b - math.sqrt(delta)) / (2 * a)
    return Roots(x1, x2)

result = get_roots(1, 0, -4)
if result:
    print(result.x1, result.x2)

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi aslında biz isimli bir demet etkisini oluşturacak bir sınıf da yazabiliriz. Aşağıda buna bir örnek 
    verilmiştir. Ancak böyle bir etki sınıfla oluşturulurken isimli demete göre arka planda daha fazla maliyet söz konusu olmaktadır:

    class Roots:
        def __init__(self, x1, x2):
            self.x1 = x1
            self.x2 = x2
            
        def __getitem__(self, index):
            if index == 0:
                return self.x1
            if index == 1:
                return self.x2
            raise IndexError('Index out of range')        
#------------------------------------------------------------------------------------------------------------------------------------

import collections 
import math

class Roots:
    def __init__(self, x1, x2):
        self.x1 = x1
        self.x2 = x2
        
    def __getitem__(self, index):
        if index == 0:
            return self.x1
        if index == 1:
            return self.x2
        raise IndexError('Index out of range')
                

def get_roots(a, b, c):
    delta = b ** 2 - 4 * a * c
    if delta < 0:
        return None
    x1 = (-b + math.sqrt(delta)) / (2 * a)
    x2 = (-b - math.sqrt(delta)) / (2 * a)
    return Roots(x1, x2)

result = get_roots(1, 0, -4)
if result:
    print(result.x1, result.x2)
    
x1, x2 = result
print(x1, x2)

#------------------------------------------------------------------------------------------------------------------------------------
    İsimli demetler yaratılırken demet elemanlarının isimleri tek bir string biçiminde de verilebilir. Bu durumda isimler boşluk veya 
    virgüllerle ayrılmalıdır. Örneğin:

    Roots = collections.namedtuple('Roots', 'x1 x2') 

    Burada isimli demetin elemanlarının isimleri x1 ve x2 biçimindedir. Yani bu işlem aşağıdkaiyle eşdeğerdir:

    Roots = collections.namedtuple('Roots', ['x1', 'x2']) 

    Aşağıdaki yaratım da geçerlidir:

    Fruit = collections.namedtuple('Fruit', 'banana,,,,   orange,,,, apricot')
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll

Roots = coll.namedtuple('Roots', 'x1 x2')

r = Roots(1, 2)
print(r.x1, r.x2)

#------------------------------------------------------------------------------------------------------------------------------------
    collections modülündeki Counter isimli sınıf bir çeşit sözlük sınıfıdır. Zaten bu sınıf dict sınıfından türetilmiştir. Sınıfın 
    amacı varlıkların sayısını tutmaktır. Counter türünden bir nesne tipik olarak dolaşılabilir bir nesne verilerek yaratılır. Böylece 
    nesne o dolaşılabilir nesnedeki elemanların sayılarını tutar hale gelir. Counter nesnesiyle elde edilen sözlüğün anahtarları 
    dolaşılabilir nesnedeki elemanlardan, değerleri ise onların sayılarından oluşmaktadır. Örneğin:

    import collections 

    c = collections.Counter('ankara')  
    print(c)                    # Counter({'a': 3, 'n': 1, 'k': 1, 'r': 1})

    for key in c:
        print(f'{key}: {c[key]}')

    Counter sınıfı dict sınıfından türetildiği için tamamen dict sınıfının bütün işlevselliklerini barındırmaktadır. Yani örneğimizdeki 
    c nesnesi bir çeşit sözlük nesnesidir. Sözlüklerdeki tüm metotları biz Counter nesnesi ile de kullanabiliriz.  
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll

c = coll.Counter('ankara')
print(c)        # Counter({'a': 3, 'n': 1, 'k': 1, 'r': 1})

c = coll.Counter([1, 2, 1, 2, 1, 2, 4, 5, 5, 2, 6, 3, 6])
print(c)        # Counter({1: 3, 2: 2})

for key, value in c.items():
    print(key, '=>', value)

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Counter nesnesi bir sözlükle de oluşturulabilmektedir. Bu durumda değerler ve onların sayıları sözlükle elde edilmiş olur. Örneğin:

    c = collections.Counter({'x': 5, 'y': 3, 'z': 2})
    peinr(c)                # Counter({'a': 10, 'c': 4, 'b': 3})
#------------------------------------------------------------------------------------------------------------------------------------

import collections 

c = collections.Counter({'x': 5, 'y': 3, 'z': 2})

print(c)

#------------------------------------------------------------------------------------------------------------------------------------
    Counter sınıfının elements isimli parametresiz metodu bize bir dolaşım nesnesi vernektedir. Bu nesne dolaşıldığında nesnenin 
    tuttuğu elemanlar belirtilen sayıda bize verilmektedir. Örneğin:

    c = collections.Counter({'x': 5, 'y': 3, 'z': 2})
    e = c.elements()
    a = list(e)
    print(a)        # ['x', 'x', 'x', 'x', 'x', 'y', 'y', 'y', 'z', 'z']
#------------------------------------------------------------------------------------------------------------------------------------

import collections 

c = collections.Counter({'x': 5, 'y': 3, 'z': 2})
e = c.elements()
a = list(e)
print(a)        # ['x', 'x', 'x', 'x', 'x', 'y', 'y', 'y', 'z', 'z']
    
#------------------------------------------------------------------------------------------------------------------------------------
    Counter sınıfının most_common metodu en çok yinelenen ilk n değeri demetlerden oluşan bir liste biçiminde vermektedir. Eğer metot
    argümansız çağırılırsa bütün değerler bu biçimde verilmektedir. Örneğin:
    
    c = collections.Counter('anastas mum satsana')    

    result = c.most_common(2)    
    print(result)       # [('a', 6), ('s', 4)]
#------------------------------------------------------------------------------------------------------------------------------------

import collections as coll

c = coll.Counter('abrakadabra')
mc = c.most_common(3)
print(mc)       # [('a', 5), ('b', 2), ('r', 2)]

mc = c.most_common()
print(mc)       # [('a', 5), ('b', 2), ('r', 2), ('k', 1), ('d', 1)]

#------------------------------------------------------------------------------------------------------------------------------------
    Counter sınıfının total metodu toplam eleman sayısını bize vermektedir. Ancak bu metot Python 3.10 ile eklenmiştir. (Spyder 
    kullanıyorsanız sol üst köşeden Spyder'ın kullandığı Python versiyonuna dikkat ediniz.)
#------------------------------------------------------------------------------------------------------------------------------------
    
import collections 

c = collections.Counter({'a': 5, 'b': 3, 'c': 2})

print(c)                # 3
print(c.total())        # 10    

#------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi dict sınıfının update metodu eklenecek elemanlar zaten sözlükte varsa yalnızca bunların değerlerini güncelliyordu. 
    Ancak Counter sınıfının update metodu dolaşılabilir bir nesne ya da sözlük alabilmektedir. Bu durumda metot üzerine ekleme yapmaktadır. 
    Yani sanki anahtarın sayaçları artmış gibi bir etki oluşmaktadır. Halbuki Counter sınıfının [] operatörü ile atama yapıldığında 
    davranış böyle değildir. Eski sayaç değeri kaybedilip yeni değer set edilmektedir. Örneğin:
    
    c = collections.Counter('istanbul')    
    print(c)        # Counter({'i': 1, 's': 1, 't': 1, 'a': 1, 'n': 1, 'b': 1, 'u': 1, 'l': 1})

    c.update('alanya')
    print(c)        # Counter({'a': 4, 'n': 2, 'l': 2, 'i': 1, 's': 1, 't': 1, 'b': 1, 'u': 1, 'y': 1})

    c['a'] = 1
    print(c)        # Counter({'n': 2, 'l': 2, 'i': 1, 's': 1, 't': 1, 'a': 1, 'b': 1, 'u': 1, 'y': 1})
#------------------------------------------------------------------------------------------------------------------------------------
    
import collections 

c = collections.Counter('istanbul')    
print(c)        # Counter({'i': 1, 's': 1, 't': 1, 'a': 1, 'n': 1, 'b': 1, 'u': 1, 'l': 1})

c.update('alanya')
print(c)        # Counter({'a': 4, 'n': 2, 'l': 2, 'i': 1, 's': 1, 't': 1, 'b': 1, 'u': 1, 'y': 1})

c['a'] = 1
print(c)        # Counter({'n': 2, 'l': 2, 'i': 1, 's': 1, 't': 1, 'a': 1, 'b': 1, 'u': 1, 'y': 1})

#------------------------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi bir Python listesi ya da demeti aslında değerlerin adreslerini tutmaktadır. Bu tutuş biçimi dinamik tür sistemine 
    uygun olsa da ve heterojen nesnelerin tutulmasına olanak sağlıyor olsa da fazla yer kaplaması ve elemanlara yavaş erişilmesi gibi 
    dezavantajları da beraberinde getirmektedir. array modülündeki array isimli sınıf aynı türden nesneleri etkin bir biçimde depolamak 
    ve onlara hızlı bir biçimde erişebilmek için bulundurulmuştur. array sınıfı "aynı türden bir grup değeri C Programlama Dilindeki 
    diziler gibi" tutmaktadır. Dolayısıyla array nesnesinin içerisindeki elemanlar list ve tuple sınıflarında olduğu gibi adres 
    tutmazlar doğrudan değerleri tutarlar. 

    array nesneleri NumPy kütüphanesindeki ndarray nesnelerine benzemektedir. Anımsanacağı gibi ndarray nesnelerinin de bir dtype türü 
    vardı. Bu nesneler de elemanların adreslerini değil doğrudan kendilerini tutuyordu. İşte array nesneleri aynı türden değerlerin 
    etkin bir biçimde tutulmasını ve onlara hızlı bir biçimde erişilmesini mümkün hale getirmektedir. Ancak array nesneleri ndarray 
    nesneleri gibi karşılıklı elemanlar üzerinde vektörel işlem yapma yeteneğine sahip değildir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    array nesnesi yaratılırken onun türü de belirtilir. Çünkü bir array nesnesi hep aynı türden değerleri tutmak zorundadır. array 
    nesnesinin tuttuğu değerlerin türleri C Programlama Dili temel alınarak belirlenmiştir. Türlerlere ilişkin isimler şöyledir:

    Tür Temsili         C'deki Tür

    'b'                 signed char
    'B'                 unsigned char
    'u'                 wchar_t
    'h'                 signed short int
    'H'                 unsigned short int
    'i'                 signed int
    'I'                 unsigned int
    'l'                 signed long int
    'L'                 unsigned long int
    'q'                 signed long long int
    'Q'                 unsigned long long int
    'f'                 float
    'd'                 double 

    C Programlama Dilindeki yukarıdaki türlerin uzunlukları aslında char dışında sistemden sisteme değişebilmektedir. Ancak tipik 
    durum şöyledir:

    char, unsigned char             ---> 1 byte'lık tamsayı türü
    short, unsigned short           ---> 2 byte'lık tamsayı türü
    int, unsigned int               ---> 4 byte'lık tamsayı türü
    long, unsigned long             ---> 4 ya da 8 byte'lık tamsayı türü
    long long, unsigned long long   ---> 8 byte'lık tamsayı türü
    float                           ---> 4 byte'lık gerçek sayı türü 
    double                          ---> 8 byte'lık gerçek sayı türü (Python'daki float)

    Bir array nesnesini yaratırken onun türünü ve isteğe bağlı olarak onun tutacağı değerleri verebiliriz. Örneğin:

    import array

    a = array.array('i', [1, 2, 3, 4, 5,])
    print(a)            # array('i', [1, 2, 3, 4, 5])

    Yukarıda da belirttiğimiz gibi array sınıfı bizzat değerlerin kendisini tutmaktadır. Yani list ve tuple sınıflarında olduğu gibi 
    onların adreslerini tutmamaktadır. array nesnesinin tuttuğu bütün değerlerin aynı türden olduğunu anımsayınız.

    Aslında NumPy kütüphanesindeki ndarray sınıfı da benzer biçimde bir temsil kullanmaktadır. Buradaki array sınıfının NumPy'daki 
    ndarray sınıfıyla bir rekabeti yoktur. NumPy kütüphanesi oldukça geniş ve vektörel işlem yapma yeteneğine sahiptir. NumPy'daki 
    dtype da aslında yukarıda türleri belirtmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import array 

a = array.array('i', [1, 2, 3, 4, 5])
print(a)            # array('i', [1, 2, 3, 4, 5])

#------------------------------------------------------------------------------------------------------------------------------------
    Bir array nesnesi oluşturulduktan sonra bu nesnenin kullanımı list nesnelerinin kullanımına çok benzemektedir. Yani array nesneleri 
    adeta elemanları aynı türden olan, daha az yer kaplayan ve hızlı işlem yapılabilen list nesneleri gibidir. Örneğin:

    - array nesnesi de "değiştirilebilir (mutable)" türlendendir. 
    - array nesnesinin elemanlarına yine [] operatörü ile erişilebilir. 
    - Dilimleme listelerde olduğu gibidir. Ancak dilimleme işleminden değerlerin kopyaları çıkartılmaktadır. (NumPy'da dilimleme 
    işleminden bir view nesnesi elde edildiğini anımsayınız.)
    - array sınıfı da dolaşılabilir bir sınıftır. 
    - array nesnesindeki elemanların sayısı len fonksiyonuna elde edilebilir. 
    - count metodu yine belli bir elemanın sayısını bize verir. 
    - append metodu dizinin sonuna ekleme yapar. 
    - extend metodu bir dolaşılabilir nesnenin içerisindekileri diziye ekler.
    - Yine pop metodu belli bir indeksteki elemanı silmek kullanılır.
    - Yine remove metodu elemanı arar ve bulursa ilk bulduğu elemanı siler. Eleman yoksa exception oluşur. 
    - in ve not in operatörleri yine "içinde var mı" kontrolünü yapar.
    - insert metodu yine belli bir elemanı belli bir indekse insert etmektedir. 
    - Yine reverse metodu "inplace" biçimde diziyi tersyüz etmektedir. 
    - indeks metodu yine bir elemanı arar, bulursa onun ilk bulunduğu yerin indeks numarası ile geri döner. Bulamazsa exception oluşur.
    - tolist metodu array içerisindeki elemanları bize Python listesi biçiminde verir. 
    - tobytes metodu dizinin içerisindeki değerleri bir bytes nesnesi olarak bize verir. 
    - array sınıfının typecode isimli örnek özniteliği dizinin türünü bize verir. 
    - itemsize örnek özniteliği dizinin tuttuğu bir elemanın byte uzunluğunu bize vermektedir. 
    - Elimizde bir byte dizisi varsa biz bu byte dizisini bir array nesnesi haline getirebiliriz. 
    - Elimizde bir bytes nesnesi varsa onun içeriğini frombytes metodu ile Array nesnesine ekleyebiliriz. 
    - fromlist metodu bir Python listesini alıp onun elemanlarını array nesnesine eklemektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import array 

a = array.array('i', [10, 20, 30, 40, 50])

print(a[2])     # 30

a[2] = 100
print(a)        # array('i', [10, 20, 100, 40, 50])

b = a[2:4]
print(b)        # array('i', [100, 40])

for x in a:
    print(x, end=' ')       # 10 20 100 40 50 
print()

a.append(60)
print(a)        # array('i', [10, 20, 100, 40, 50, 60])

a.extend([70, 80, 90])
print(a)        # array('i', [10, 20, 100, 40, 50, 60, 70, 80, 90])

a.pop(2)
print(a)        # array('i', [10, 20, 40, 50, 60, 70, 80, 90])

a.remove(60)
print(a)        # array('i', [10, 20, 40, 50, 70, 80, 90])

a.insert(1, 100)
print(a)        # array('i', [10, 100, 20, 40, 50, 70, 80, 90])

a.reverse()
print(a)        # array('i', [90, 80, 70, 50, 40, 20, 100, 10])

result = a.index(100)
print(result)   # 6

x = a.tolist()
print(x)        # array('i', [90, 80, 70, 50, 40, 20, 100, 10])

y = a.tobytes()
print(y)        # b'Z\x00\x00\x00P\x00\x00\x00F\x00\x00\x002\x00\x00\x00(\x00\x00\x00\x14\x00\x00\x00d\x00\x00\x00\n\x00\x00\x00'

print(a.typecode)       # i

print(a.itemsize)       # 4

b = b'\x10\x00\x00\x00'  # 16 sayısının byte karşılığı
a.frombytes(b)
print(a)                # array('i', [90, 80, 70, 50, 40, 20, 100, 10, 16])

a.fromlist([100, 200, 300])
print(a)                # array('i', [90, 80, 70, 50, 40, 20, 100, 10, 16, 100, 200, 300])

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii biz bir array nesnesin bir elemanına o tür ile temsil edilemeyen bir değeri atayamayız. Örneğin:

    a = array.array('i', [10, 20, 30, 40, 50])
    a[1] = 12.3     # exception oluşur

#------------------------------------------------------------------------------------------------------------------------------------

import array 

a = array.array('i', [10, 20, 30, 40, 50])
a[1] = 12.3     # exception oluşur

#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Peki array sınıfını hangi durumlarda list ya da tuple sınıflarına tercih edebiliriz? İşte eğer elemanlar aynı türdense ve çok 
    sayıdaysa list ya da tuple yerine array kullanmak hız ve bellek kazancı sağlayabilmektedir. array sınıfı C Programlama Dilindeki 
    türleri tutabildiği için küçük tamsyaılardan oluşan diziler list ve tuple sınıflarına göre çok daha az yer kaplayabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    C, C++, Java ve C# gibi pek çok dilde "enumeration (sayımlama)", kısaca "enum" denilen türler bulunmaktadır. Enum türleri aslında 
    bu dillerde birtakım sayıların isimsel olarak temsil edilmesini sağlamak amacıyla kullanılmaktadır. Bazen kısıtlı sayıda seçeneğe 
    sahip olan olgular söz konusu olabilir ve bunların tamsayılarla ifade edilmesi gerekebilir. Genel olarak yazılar pek çok durumda 
    kategori belirten değerlerin temsil edilmesinde hem zamansal bakımdan hem de hata kontrolü bakımından uygun olmayabilmektedir. 

    Python'da dilin sentaksı tarafından desteklenen bir enum türü yoktur. Ancak standart kütüphanede enum türünün temsili için enum 
    isimli modülün içerisinde Enum isimli bir sınıf bulundurulmuştur. 

    Python'da enumaration kullanımı şöyledir: Programcı önce enum.Enum sınıfından bir sınıf türetir. Türemiş sınıfta enum sabitlerini 
    isim = değer sentaksıyş sınıf değişkeni (sınıf özniteliği) biçiminde oluşturur. Sonra sınıf ismi ve nokta operatörü ile bu enum 
    sabitlerine erişir. Örneğin:

    class Direction(enum.Enum):
        Up = 0
        Right = 1
        Down = 2
        Left = 3

    Burada biz Direction isimli bir enum oluşturmuş olduk. Bu enum elemanlarına Direction.Up, Direction.Right, Direction.Down, 
    Direction.Left biçiminde erişebiliriz. Peki bunu sağlamak için neden enum.Enum sınıfından türetme yapılmaktadır? Aynı işlemleri 
    aşağıdaki gibi yapamaz mıydık?

    class Direction:
        Up = 0
        Right = 1
        Down = 2
        Left = 3

    İşte eğer bu biçimde enum oluşturmaya çalışsaydık burada sınıf değişkenleri bir sabit gibi ele alınmazdı. Dolayısıyla örneğin 
    biz bu değişkenlere atama yapılabilirdik. Halbuki bu sınıf enum.Enum sınıfından türetilirse artık bu değişkenlere atama 
    yapılamamaktadır. Ayrıca eğer enum oluşturmayı yukarıdaki gibi yapmış olsaydık bir int değer ile enum değerini karşılaştırıp 
    işleme sokabilirdik. Halbuki enum.Enum sınıfından türetme yaptığımızda ancak aynı türden iki enum değerini anlamlı olarak 
    == ve != operatörleriyle karşılaştırabiliriz. Örneğin:

    class Direction(enum.Enum):
        Up = 0
        Right = 1
        Down = 2
        Left = 3

    d = Direction.Left
    if Direction.Right > 1:         # error!
        pass
    val = Direction.Up + 1          # error!
    if d == Direction.Left:            #geçerli
        pass       

    enum.Enum sınıfından türettiğimiz sınıf içerisindeki isimlere "enum sabitleri" de denilmektedir. Enum sabitleri için İngilizce 
    "enumerator" terimi kullanılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

import enum

class Direction(enum.Enum):
    Up = 0
    Right = 1
    Down = 2
    Left = 3
    
def move(direction):
    if direction == Direction.Up:
        print('yukarıya gidiyor')
    elif direction == Direction.Right:
        print('sağa gidiyor')
    elif direction == Direction.Down:
        print('aşağıya gidiyor')
    elif direction == Direction.Left:
        print('sola gidiyor')
        
move(Direction.Left)
move(Direction.Right)
move(Direction.Up)
move(Direction.Down)

#------------------------------------------------------------------------------------------------------------------------------------
    Bir enum değişkeninin ya da sabitinin değeri Enum sınıfının value özniteliği ile elde edilebilmektedir. Örneğin:

    class Direction(enum.Enum):
        Up = 0
        Right = 1
        Down = 2
        Left = 3

    d = Direction.Right
    print(d.value)          # 1

    Enum değerinin ismi ise sınıfın name isimli özniteliği ile str nesnesi biçiminde elde edilebilmektedir. Örneğin:

    d = Direction.Right
    print(d.name)           # Right

    Enum sınıfından türetilmiş olan sınıf türünden nesne yaratırken enum değeri verilebilir. Örneğin:

    e = Direction(2)
    print(e.name)           # Down

    Ancak enum nesnesi yaratılırken argüman olarak geçirilen değer o enum türündeki bir enum sabitinin değeri değilse bu durumda 
    exception oluşmaktadır. 

    enum.Enum sınıfından türetilerek oluşturulmuş olan sınıf türleri "dolaşılabilir" nesnelerdir. Bu nesneler dolaşıldıkça enum 
    sabitleri elde edilmektedir. Örneğin:

    class Direction(enum.Enum):
        Up = 0
        Right = 1
        Down = 2
        Left = 3

    for d in Direction:
        print(d, end=' ')       # Direction.Up Direction.Right Direction.Down Direction.Left

    Burada Direction tür ismi adeta dolaşılabilir bir nesne gibi davranmaktadır. 

    enum sınıf ismi ile [] operatörü kullanılırsa köşeli parantez içerisine enum sabitlerinin ismi yazı olarak verildiğinde onun 
    değerin elde ederiz. Örneğin:
        
    x = Direction['Right']    
    print(x)            # Direction.Right

    Bütün bu olanaklar aslında taban Enum sınıfında sağlanmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

import enum

class Direction(enum.Enum):
    Up = 0
    Right = 1
    Down = 2
    Left = 3
    
d = Direction.Down
print(d.value)      # 2
print(d.name)       # Down

k = Direction(2)
print(k)            # Direction.Down

for x in Direction:
    print(x, end=' ')   # Direction.Up Direction.Right Direction.Down Direction.Left 
print()

result = Direction['Down']
print(result)       # Direction.Down

#------------------------------------------------------------------------------------------------------------------------------------
    Standart kütüphanedeki "fonksiyonel programlama (functional programming)" paradigmasını desteklemek amacıyla itertools modülünün 
    yanı sıra functools isimli bir modül de bulundurulmuştur. functools modülü genel olarak dekoratör biçiminde kullanılmaya uygun 
    olan fonksiyonlardan ve sınıflardan oluşmaktadır.  
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    functools modülü içerisindeki cache isimli dekoratör fonksiyonu bir fonksiyonun bir argümanla çağrılması durumunda bu argümanla 
    geri dönüş değerini bir önbellek (cache) oluşturup orada saklamaktadır. Böylece fonksiyon ikinci kez aynı argümanla çağrıldığında 
    boşuna fonksiyou çağırması yapmadan doğrudan bize geri dönüş değerini hızlıca vermektedir Örneğin:

    import functools

    @functools.cache
    def foo(a):
        print('foo called')
        return a * a

    for i in range(10):
        val = foo(i)
        print(val)

    Burada 0'dan10'a kadar sayıların kareleri functools modülü tarafından oluşturulan önbellekte saklanmıştır. Şimdi biz 0'dan 10'a 
    kadar bazı sayıların karelerini foo ile elde etmek istesek aslında foo fonksiyonu çalıştırılmadan hemen önbellekte saklanan değerler 
    bize verilecektir:

    result = foo(3)         # önbellekte var foo çalıştırılmayacak
    print(result)

    result = foo(5)         # önbellekte var foo çalıştırılmayacak
    print(result)

    result = foo(15)        # önbellekte yokfoo çalıştırılacak
    print(result)

    result = foo(15)        # aartık önbellekte var foo çalıştırılmayacak
    print(result)
#------------------------------------------------------------------------------------------------------------------------------------

import functools

@functools.cache
def foo(a):
    print('foo called')
    return a * a

for i in range(10):
    val = foo(i)
    print(val)

print('-' * 30)

result = foo(3)         # önbellekte var foo çalıştırılmayacak
print(result)

result = foo(5)         # önbellekte var foo çalıştırılmayacak
print(result)

result = foo(15)        # önbellekte yokfoo çalıştırılacak
print(result)

result = foo(15)        # aartık önbellekte var foo çalıştırılmayacak
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    functools.cache dekoratörü birden fazla parametre alan fonksiyonlarda da kullanılabilir. Bu durumda geri dönüş değerinin cache'ten 
    alınması için tüm argümanların aynı olması gerekir. Örneğin:

    @functools.cache
    def foo(a, b):
        print('foo called')
        return a + b

    val = foo(10, 2)
    print(val)              # önbellekte yok foo çalıştırılacak

    val = foo(2, 10)
    print(val)              # önbellekte yok foo çalıştırılacak

    val = foo(10, 2)
    print(val)              # önbellekte var foo çalıştırılmayacak

#------------------------------------------------------------------------------------------------------------------------------------

@functools.cache
def foo(a, b):
    print('foo called')
    return a + b

val = foo(10, 2)
print(val)              # önbellekte yok foo çalıştırılacak

val = foo(2, 10)
print(val)              # önbellekte yok foo çalıştırılacak

val = foo(10, 2)
print(val)              # önbellekte var foo çalıştırılmayacak

#------------------------------------------------------------------------------------------------------------------------------------
    functools.cache dekoratörü argüman değeri ile geri dönüş değeri arasında ilişki kurmaktadır. Yani önbellek sisteminin bir sözlükle 
    gerçekleştirildiğini varsayarsak burada anahtar argümanlardan, değer ise geri dönüş değerinden oluşmaktadır. Eğer fonksiyon argümana 
    bağlı bir geri dönüş değerine sahip değilse ya da fonksiyon içerisinde bir "yan etki" oluşturacak başka işlemler (burada fonksiyonun 
    başka bir şeyler yaptığını ve o işlemlerin de gerçekleştirilmek istendiğini kastediyoruz.) yapılıyorsa bu dekoratör kullanılmamalıdır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    functools modülü içerisindeki cache dekoratörünün bir benzeri basit bir biçimde aşağıdaki gibi yazılabilir:

    class mycache:
        def __init__(self, f):
            self.f = f
            self.cache = {}
        
        def __call__(self, *args):
            value = self.cache.get(args)
            if value is None:
                value = self.f(*args)
                self.cache[args] = value
            return value
#------------------------------------------------------------------------------------------------------------------------------------

class mycache:
    def __init__(self, f):
        self.f = f
        self.cache = {}
    
    def __call__(self, *args):
        value = self.cache.get(args)
        if value is None:
            value = self.f(*args)
            self.cache[args] = value
        return value
      
@mycache
def foo(a):
    print('foo called')
    return a * a

for i in range(10):
    val = foo(i)
    print(val)

print('-' * 30)

result = foo(3)         # önbellekte var foo çalıştırılmayacak
print(result)

result = foo(5)         # önbellekte var foo çalıştırılmayacak
print(result)

result = foo(15)        # önbellekte yokfoo çalıştırılacak
print(result)

result = foo(15)        # aartık önbellekte var foo çalıştırılmayacak
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    cache dekoratörü girdiye bağlı olarak tutarlı çıktıların elde edildiği ancak bu çıktıların elde edilme zamanının performans 
    üzerinde etkili olduğu durumlarda tercih edilmelidir. Örneğin bir grafta iki düğüm arasından en kısa yolu bulan bir fonksiyon 
    olsun:

    length = shortest_path('A', 'B')

    Burada 'A' ile 'B' düğümleri arasındaki en kısa yol hep aynıdır ancak bunun hesaplanması belli bir zaman almaktadır. İşte bunun 
    önbellekte saklanarak yeniden 'A' ve 'B' uzaklığı hesaplanmak istendiğinde doğrudan sonucun elde edilmesi için biz cache
    dekoratörünü kullanabiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    functools modülündeki lru_cache isimli dekoratör aslında tamamen cache dekoratörü gibidir. Bunun tek farkı maxsize tane değeri 
    önbellekte tutmasıdır. Bu maxsize değeri belirtilmezse default 128 alınmaktadır. Buradaki LRU öneki "Least Recently Used" anlamına 
    gelmektedir. Yani önbellek dolduğu zaman son zamanlarda en az kullanılanlar önbellekte atılmaktadır. Önbellekte olan eski bir 
    öğeyi kullanırsak bu öğre son zamanlarda kullanıldığı için öne çekilir ve önbellekteb atılmaz. Örneğin önbellek uzunluğu 3 olsun 
    biz de fonksiyonu sırasıyla şu argümanlarla çağırmış olalım:

    @functools.lru_cache(3)
    def foo(a):
        print('foo called')
        return a * a

    Burada 3, 5 ve 7 değerleti ile foo fonksiyonunu çağıralım. Bu fonksiyonlar önbellekte tutulacaktır. Ama artık önbellekte yer 
    kalmayacaktır. İşte budurumda LRU politikasına göre yer açılması için son zamanlarda en kullanılanlar önbellekten atılacaktır.

    val = foo(3)            # foo çağrılır, 3 önbelleğe alınır
    print(val)

    val = foo(5)            # foo çağrılır, 5 önbelleğe alınır
    print(val)

    val = foo(7)            # foo çağrılır 7 önbelleğe alınır
    print(val)

    val = foo(3)            # foo çağrılmaz değer önbellekten verilir
    print(val)

    val = foo(5)            # foo çağrılmaz değer önbellekten verilir
    print(val)

    Burada son zamanlarda en kullanılan değer artık 7'dir. Yeni bir değer önbelleğe girecekse bu 7 değeri çıkartılacaktır:

    val = foo(10)           # 10 önbellleğe giriyor, 7 çıkartılıyor
    print(val)

    val = foo(7)            # 7 önbellekten çıkartıldığı için foo çağrılacak ve 7 yeniden önbelleğe girecek
    print(val)
 #------------------------------------------------------------------------------------------------------------------------------------

import functools

@functools.lru_cache(3)
def foo(a):
    print('foo called')
    return a * a

val = foo(3)
print(val)

val = foo(5)
print(val)

val = foo(7)
print(val)

val = foo(3)
print(val)

val = foo(5)
print(val)

val = foo(10)           # 10 önbellleğe giriyor, 7 çıkartılıyor
print(val)

val = foo(7)            # 7 önbellekten çıkartıldığı için foo çağrılacak ve 7 yeniden önbelleğe girecek
print(val)

#------------------------------------------------------------------------------------------------------------------------------------
    functools modülündeki total_ordering dekoratörü bir sınıfa iliştirilebilir. Bu dekoratör < ve == operatör metotları bulunan sınıfta
    diğer operatör metotlarını (<=, >=, !=, >) bunları kullanarak yazmaktadır. Böylece biz bir sınıf için yalnızca bu iki operatör 
    metodunu yazabiliriz, diğerleri dekoratör tarafından oluşturulur. Örneğin:

    class A:
        def __init__(self, x):
            self.x = x
            
        def __lt__(self, b):
            return self.x < b.y
        
        def __eq__(self, number):
            return self.x == number.y
        
    class B:
        def __init__(self, y):
            self.y = y

    Burada A ve B türünden nesnelerin < ve == operatörleriyle karşılaştırılaqbildiğini görüyorsunuz. Ancak diğer operatörlerle 
    iki sınıf türünden nesnenin karşılaştırılması mümkün değildir. İşte functools.total_ordering dekoratörü bu işlemlerin de 
    < ve == operatörleri kullanılarak yapılabilmesini sağlamaktadır. 
        
    Aşağıdaki örnekte Number sınıfı < ve == operatör metotlarını bulundurmuştur. Diğer karşılaştırma operatör metotları dekoratör 
    tarafından bunlar oluşturulacaktır. 
#------------------------------------------------------------------------------------------------------------------------------------

import functools

@functools.total_ordering
class A:
    def __init__(self, x):
        self.x = x
        
    def __lt__(self, b):
        return self.x < b.y
    
    def __eq__(self, number):
        return self.x == number.y
    
class B:
    def __init__(self, y):
        self.y = y
            
x = A(50)
y = B(50)

if x > y:
    print("x > y")
elif x < y:
    print("x < y")
else:
    print("x == y")
  
#------------------------------------------------------------------------------------------------------------------------------------
    functools modülündeki partial isimli fonksiyon bir fonksiyonu ve ilk n tane argüman değerini parametre olarak alır ve bize 
    başka bir fonksiyon verir. Biz onun verdiği fonksiyonu çağırırken ilk n parametre için argüman girmeyiz. Yalnızca geri kalan k tane 
    parametre için argüman gireriz. İlk n tane parametre için argüman bizim partial fonksiyonuna verdiğimiz argüman olur. Örneğin:
    
    def foo(a, b, c, d):
        print(f'a = {a}, b = {b}, c = {c}, d  = {d}')
    
    foo = functools.partial(foo, 100, 200)

    Burada artık foo fonksiyonunu biz iki argümanla çağırırız. İlk iki argüman için sanki 100 ve 200 değerlerini girmiş gibi 
    olmaktayız:

    foo(3, 4)       # a = 100, b = 200, c = 3, d  = 4
    foo(5, 6)       # a = 100, b = 200, c = 5, d  = 6

    partial fonksiyonunu biz @ ie dekoratör sentaksı ile kullanamamaktayız. Çağrımın açıkça yapılması gerekmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import functools

def foo(a, b, c, d):
    print(f'a = {a}, b = {b}, c = {c}, d  = {d}')
    
foo = functools.partial(foo, 100, 200)

foo(3, 4)       # a = 100, b = 200, c = 3, d  = 4
foo(5, 6)       # a = 100, b = 200, c = 5, d  = 6

#------------------------------------------------------------------------------------------------------------------------------------
    functools modülündeki partialmethod isimli fonksiyon da partial fonksiyonu gibidir. Ancak sınıfın bir metodunu alarak onun ilk n 
    parametresi için yerleştirme yapar. Bu fonksiyon kullanılırken tipik olarak fonksiyonun geri döndürdüğü değer sınıtaki bir sınıf
    değişkenine (class attribute) atanmalıdır. Örneğin:

    class Sample:
        def foo(self, a, b, c):
            print(a, b, c)
            
        bar = functools.partialmethod(foo, 100, 200)
    
    Burada biz sınıfa bar isimli bir metot eklemiş gibi olduk. Artık bar metodunu çağırdığımızda aslında foo metodu 
    çağrıacaktır. Ancak foo metpdun ilk iki paramtressi için 100 ve 200 değerleri argüman olarak girilecektir. Bizim yalnızca
    son parametre için argüman girmemiz gerekir. Örneğin:

    s = Sample()
    s.bar(300)      # eşdeğeri: s.foo(100, 200, 300)

    Buradaki s.bar(300) çağrısı ile s.foo(100, 200, 3) çağrısı eşdeğerdir. 
#------------------------------------------------------------------------------------------------------------------------------------

import functools

class Sample:
    def foo(self, a, b, c):
        print(a, b, c)
        
    bar = functools.partialmethod(foo, 100, 200)
    
s = Sample()

s.foo(10, 20, 30)           # 10 20 30
s.bar(300)                  # 100 200 300

#------------------------------------------------------------------------------------------------------------------------------------
    functools modülündeki reduce fonksiyonu aslında itertools modülündeki accumulate fonksiyonuna çok benzemektedir. Ancak reduce 
    fonksiyonu accumulate gibi her değeri değil yalnızca sonuç değerini bize verir. reduce fonksiyonunun birinci parametresi bir 
    fonksiyon olmalıdır. Bu fonksiyon bir önceki değerle yeni sıradaki değeri argüman yapılıp çağrılmaktadır. 

    Aşağıdaki örnekte her iki fonksiyon da birlikte kullanılmıştır. itertools.accumulate bize bir itertor nesnesi verirken functools.reduce 
    bize tek bir değer vermektedir. Örneğin:
    
    def foo(a, b):
        return a + b

    a = [1, 2, 3, 4, 5]
    val = functools.reduce(foo, a)
    print(val)          # 15 

    Burada her defasında listenin sıradaki elemanı ile daha önce foo fonksiyonundan elde edilen değer argüman olarak verilip foo 
    fonksiyonu çağrılmaktadır. En son değer nihai değer olarak verilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

import functools

def foo(a, b):
    return a + b

a = [1, 2, 3, 4, 5]
val = functools.reduce(foo, a)
print(val)

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de Python'da kopyalama işlemleri üzerinde duracağız. Bilindiği Python'da tüm atamalar aslında adres atamasıdır. Örneğin:

    a = [1, 2, 3, 4, 5] 
    b = a

    Burada b = a atamasıyla yeni bir nesne yaratılmamaktadır. a ve b aynı nesnenin adreslerini tutmaktadır. Yani a is b True verir. 

    Biz bazen değiştirilebilir nesnelerin yeni kopyasını oluşturmak isteyebiliriz. Çünkü birinin bozulması durumunda diğerinin 
    değerini korunması gerekebilir. Tabii temel türlerde olduğu gibi değiştirilemez türlerin kopyasının oluşturulmasının bir anlamı 
    yoktur. Örneğin bir str nesnesi "değiştirilemez (immutable)" bir nesnedir. Bizim onun kopyasını oluşturmamızın bir anlamı yoktur. 
    
    Python'da değiştirilebilir olan list gibi, set gibi, dict gibi sınıflara ilişkin nesnelerin kopyalarını çıkartmak için zaten bu 
    sınıflarda copy isimli metotlar bulunmaktadır. Örneğin:

    >>> a = [1, 2, 3, 4, 5]
    >>> id(a)
    1954630234624
    >>> b = a.copy()
    >>> b
    [1, 2, 3, 4, 5]
    >>> id(b)
    1954630260032
    >>> a = {'ali': 10, 'veli': 20, 'selami': 30}
    >>> b = a.copy()
    >>> id(a)
    1815000300928
    >>> id(b)
    1815000319488
    >>> a = {1, 2, 3, 4, 5}
    >>> b = a.copy()
    >>> id(a)
    1814999063840
    >>> id(b)
    1814999060704

    Yine dilimleme, ve yineleme (repition) gibi işlemlerin aslında kopya yoluyla yapıldığını anımsayınız. 
    
    Ancak biz kendi sınıfımız türünden nesnelerin de kopyalarını oluşturmak isteyebiliriz. İşte bunun için copy modülünde copy ve 
    deepcopy isimli iki fonksiyon bulundurulmuştur. copy fonksiyonu "sığ kopyalama (shallow copy)", deepcopy fonksiyonu ise "derin 
    kopyalama (deep copy)" işlemi yapmaktadır. Sığ kopyalama yalnızca ana nesnenin kopyasının çıkartılması ancak elemanlar için 
    kopya çıkartılmaması anlamına gelir. Derin kopyalama ise "özyinelemeli (recursive)" biçimde tüm nesnenin kopyalarının 
    çıkartılmasını sağlamaktadır. 

    Örneğin biz Sample sınıfı türünden bir nesnenin elemanlarını değiştirmeden önce onun bir kopyasını çıkartarak eski halini saklamak 
    isteyebiliriz:

    class Sample:
        def __init__(self, a, b)    :
            self.a = a 
            self.b = b

        def __repr__(self):
            return f'a = {self.a}, b = {self.b}'

    s = Sample(10, 20)
    print(id(s))

    k = copy.copy(s)
    print(id(k))

    Burada k değişkeni artık s ile aynı nsneyi göstermemektedir. s değişkeninin gösterdiği nesnenin bir kopyası çıkartılmış k 
    değişkeni o kopyayı gösterir hale gelmiştir:

    s.a = 200
    s.b = 300

    print(s)        # a = 200, b = 300
    print(k)        # a = 10, b = 20
       
#------------------------------------------------------------------------------------------------------------------------------------

import copy

class Sample:
    def __init__(self, a, b)    :
        self.a = a 
        self.b = b

    def __repr__(self):
        return f'a = {self.a}, b = {self.b}'
    
s = Sample(10, 20)
print(id(s))

k = copy.copy(s)
print(id(k))

s.a = 200
s.b = 300

print(s)
print(k)
print(f'id(k): {id(k)}')

#------------------------------------------------------------------------------------------------------------------------------------
    Sığ kopyalamada yalnızca ana nesnenin kopyası çıkartılmaktadır. Dolayısıyla ana nesnenin bir örnek özniteliği "değiştirilebilir 
    (mutable)" bir nesne ise bu nesnenin kopyası çıkartılmaz. Derin kopyalama daha fazla zaman alan ve daha fazla bellek kullanan bir 
    kopyalama biçimidir. Bu nedenle programcı gerekmediği durumda derin kopyalama yapmamalıdır. Sığ kopyalamayı tercih etmelidir.  
    
    Şimdi yukarıdaki Sample sııfında a ve b örnek öznitelikleri bir liste olacak biçimde nesneyi yaratalım:

    class Sample:
        def __init__(self, a, b)    :
            self.a = a 
            self.b = b

        def __repr__(self):
            return f'a = {self.a}, b = {self.b}'
        
    s = Sample([1, 2, 3, 4, 5], [6, 7, 8, 9, 10])
    print(id(s.a), id(s.b))     # 1930436204608 1930436198976

    Burada Sample nesnesinin a ve b özniteliklerinin id değerleri yazdırılmıştır. Şimdi copy fonksiyonu ile sığı kopyalama (shallow 
    copy) uygulayalım:

    k = copy.copy(s)
    print(id(k.a), id(k.b))     # 1930436204608 1930436198976

    Burada k artık yeni bir Sample nesnesini göstermektedir. Ancak s.a ve s.b listelerinin kopyları çıkarılmamıştır. Dolayısıyla
    bu elemanların id'leri de aynı olacaktır. Şimdi de derin kopyalama yapalım:
    
    k = copy.deepcopy(s)
    print(id(k.a), id(k.b))     1930435991360 1930435986624

    Artık hem s ile k darklı nesneleri göstermektedir hem de bu nesnelerin a ve b örniteliklerinin gösterdiği listeler farklı 
    olacaktır.     
#------------------------------------------------------------------------------------------------------------------------------------

import copy

class Sample:
    def __init__(self, a, b)    :
        self.a = a 
        self.b = b

    def __repr__(self):
        return f'a = {self.a}, b = {self.b}'
      
s = Sample([1, 2, 3, 4, 5], [6, 7, 8, 9, 10])
print(id(s.a), id(s.b))

k = copy.copy(s)
print(id(k.a), id(k.b))

k = copy.deepcopy(s)
print(id(k.a), id(k.b))

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii derin kopyalama sırasında değiştirilemez (immutable) türlere ilişkin elemanların kopyaları çıkartılmamaktadır. Zaten 
    değiştirilemez türlerin kopyalarının çıkartılmasının bir anlamı da yoktur. Aşağıdaki örnekte nesnenin a ve b öznietlikleri 
    değiştirilemez olduğu için burada copy ile deepcopy arasında bir farklılık oluşmayacaktır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi Python'un float türü IEEE 754 formatını kullanmaktadır. Zaten bugün hemen her CPU gerçek sayıları bu formatta ele 
    alıp eletrik devreleriyle işlem yapmaktadır. Dolayısıyla float türü de bu bağlamda doğal ve hızlı bir türdür. Ancak maalesef 
    Python kurusumuzn ilk bölümlerinde de belirttiğimiz gibi IEEE 754 fotmatının (genel olarak floating point formatların) "yuvarlama 
    hatası (rounding error)" denilen bir problemi vardır. Yuvarlama hatası bazı noktalı sayıların tam olarak ifade edilemeyip onlara 
    yakın bir sayının ifade edilebilmesiyle oluşan hatalardır. Yuvarlama hataları pek çok uygulamada önemsiz olarak değerlendirilebilir. 
    Ancak muhasebe gibi, finans gibi, savunma sanayi gibi, uzay hesapları gibi kritik uygulamalarda yuvarlama hataları hiç istenmeyebilir. 
    İşte Python'un standart kütüphanesinde decimal isimli modüldeki Decimal sınıfı yuvarlama hatasına maruz kalmadan noktalı sayılarla 
    işlemlerin yapılabilmesini sağlamaktadır. Bu Decimal sınıfı aynı zamanda float türünün tutabileceğinden daha uzun noktalı sayıları 
    da tutabilmektedir. Örneğin:

    >>> a = 0.3
    >>> b = 0.1
    >>> c = a - b
    >>> c
    0.19999999999999998

    Burada yuvarlama hatası nedeniyle 0.2 yerine ona çok yakın bir değer elde edilmiştir. Halbuki biz aynı işlemi Decimal sınıfıyla 
    yapmış olsaydık tam olarak 0.2 elde edilecekti:

    >>> import decimal
    >>> a = decimal.Decimal('0.3')
    >>> b = decimal.Decimal('0.1')
    >>> c = a - b
    >>> c
    Decimal('0.2')
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Decimal nesnesi bir string ile, int bir değerle ya da float bir değerle oluşturulabilmektedir. Decimal sınıfının çeşitli 
    operatör metotları vardır. Bu operatör metotları sayesinde Decimal türden iki nesne sanki float türünden iki nesneymiş gibi 
    işlemlere sokulabilmektedir. Örneğin:

    >>> import decimal
    >>> a = decimal.Decimal('0.3')
    >>> b = decimal.Decimal('0.2')
    >>> c = a - b
    >>> print(c)
    0.1

    Her ne kadar bir Decimal nesne float bir değerle oluşturulabiliyorsa da bu durum aslında Decimal kullanımının amacına ters 
    düşmektedir. Çünkü float değerin kendisinde de daha sınıfa vermeden yuvarlama hataları oluşabilmektedir. 
    
    Bu örnekte Decimal nesnenin yuvarlama hatasına yol açmadığına ancak float türün yuvarlama hatasına yol açabildiğine dikkat ediniz.     
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                            74. Ders 14/12/2025 – Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi bir Decimal nesnenin float bir değerle oluşturulması kullanım amacı bakımından uygun olmayabilir. 
    Çünkü float değerin kendisi zaten sabit olarak belirtilirken bile yuvarlama hatası oluşturuabilmektedir. Örneğin:

    >>> a = Decimal(1.2)
    >>> a
    Decimal('1.1999999999999999555910790149937383830547332763671875')
    >>> b = Decimal('1.2')
    >>> b
    Decimal('1.2')

    Python'da komut satırında float değeri yazdırmak istediğimizde float türüün __repr__ metodu devreye girmektedir. Bu __repr__ 
    metodunda kullanılan algoritmaya bağlı olarak yuvarlama hatası oluşsa bile noktalı sayılar sanki yuvarlama hatası oluşmamış gibi 
    gösterilebilmektedir. Örneğin:

    >>> x = 1.2
    >>> x
    1.2

    Ancak örneğin:

    >>> f'{x:.30f}'
    '1.199999999999999955591079014994'

    Genel olarak biz iki Decimal nesneyi ya da bir Decimal nesneyle bir int nesneyi işleme sokabiliriz. Ancak bir Decimal nesneyle bir 
    float nesneyi ya da bir Decimal nesneyle bir string'i işleme sokamayız. Bir Decimal nesneyle bir int nesne işleme sokulduğunda sonuç 
    Decimal türden elde edilir. Bunu sembolik olarak şöyle belirtebiliriz:

    Decimal <op> Decimal    => Decimal
    Decimal <op> int        => Decimal
    int <op> Decimal        => Decimal
    Decimal <op> float      Geçersiz!  
    Decimal <op> str        Geçersiz!
    
    Örneğin:

    >>> a = decimal.Decimal('123.5')
    >>> b = 10
    >>> c = a + b
    >>> c
    Decimal('133.5')
    >>> a + 3.2
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: unsupported operand type(s) for +: 'decimal.Decimal' and 'float'
    >>> a + '1.2'
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: unsupported operand type(s) for +: 'decimal.Decimal' and 'str'
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Decimal nesne float türüne, int türüne ve bool türüne ve str türüne dönüştürülebilir. Çünkü Decimal sınıfı için bu dönüşümleri 
    yapabilecek __float__, __int__ ve __bool__ operatör metotları bulundurulmuştur. Örneğin:

    >>> d = decimal.Decimal('1234567890')
    >>> i = int(d)
    >>> i
    1234567890
    >>> f = float(d)
    >>> f
    1234567890.0
    >>> b = bool(d)
    >>> b
    True
    >>>c = Decimal('3.304863269228730284730287123')
    >>> str(c)
    '3.304863269228730284730287123'

    bool türüne dönüştürmede yine Decimal değer sıfır mı diye bakılmaktadır:

    >>> d = decimal.Decimal('0')
    >>> bool(d)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Normal olarak math modülündeki fonksiyonların Decimal türü ile kullanımı konusunda Standart Kütüphane dokümanlarında bir belirleme 
    yapılmamıştır. Eskiden bu fonksiyonların Decimal türü ile kullanımlarında sorun oluşuyordu. Ancak bu fonksiyonlar daha sonraları 
    kendi içlerinde Decimal argümanları float türüne dönüştürmeye başlamıştır. Bu nedenle Decimal türler de math modülündeki fonksiyonlar 
    tarafından kullanılabilir duruma gelmiştir. Ancak bu durum Standart Kütüphanede dokümante edilmemiştir. Bu nedenle Decimal türünü 
    math modülündeki fonksiyonlarla doürudan kullanmayınız. Tabii bir Decimal nesnesini float türüne dönüştürerek math modülündeki 
    fonksiyonlarla kullanabiliriz. Ancak Decimal sınıfında da math modülündeki işlemleri yapab sqrt, ln, log10 gibi metotlar bulundurulmuştur. 
    Tabii bu metotların geri dönüş deperleri Decimal türdendir. Örneğin:

    >>> d = Decimal('3.141592653589793238462643')
    >>> math.sqrt(d)
    1.7724538509055159
    >>> d.sqrt()
    Decimal('1.772453850905516027298167375')
    >>> math.log10(d)
    0.49714987269413385
    >>> d.log10()
    Decimal('0.4971498726941338543512682353')
#------------------------------------------------------------------------------------------------------------------------------------

from decimal import Decimal

d = Decimal(2)

result = d.sqrt()
print(result)

result = d.ln()
print(result)

result = d.log10()
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Decimal modülündeki Decimal sınıfı ile işlemler yapılırken bazı belirlemelere uyulmaktadır. Bu belirlemelere "context" denilmektedir. 
    Bu belirlemeler getcontext() fonksiyonu ile elde edilebilir. context nesnesi getcontext fonksiyonuyla elde edildikten sonra nesne 
    üzerinde değişikler yapılabilmektedir. getcontext ile alınan bağlam nesnesi "thread temelinde singleton" bir nesnedir. Yani bu 
    nesnenin toplamda her thread için tek bir kopyası vardır. Biz aynı thread'te birden fazla kez getcontext fonksiyonunu çağırsak bile 
    bu fonksiyon bize hep aynı nesneyi verir. Bağlam nesnesi getcontext fonksiyonuyla alınıp onun belli elemanları değiştirilebilir. 
    Ya da istenirse yeni context nesnesi oluşturulup setcontext fonksiyonuyla bu nesne set edilebilir. Bağlam nesnesinin en önemli 
    elemanlarından biri "prec" elemanıdır. Bu prec elemanı Decimal sayıların işlem duyarlılığını belirtmektedir. Bu elemanın default 
    değeri 28'dir. Bu değer işlem sonrasında elde edilecek Decimal sayının toplam mantisini (yani tam kısmı ve noktalı kısmının toplam 
    basamak sayısını) belirtmektedir. Buradaki default 28 duyarlılığın Decimal sayının duyarlılığı olmadığına işlem sonrasında elde 
    edilen Decimal sayının duyarlılığı olduğuna dikkat ediniz. Örneğin:

    >>> a = decimal.Decimal('1.65243163461436514236514356143614236514326142365142365412634162356123')
    >>> b = decimal.Decimal('1.65243163461436514236514356143614236514326142365142365412634162356123')
    
    Burada çok yüksek basamaklı iki Decimal sayı vardır. Şimdi bunları toplamaya çalışırsak elde edeceğimiz sayı 28 basamaklı olacaktır:

    >>> c = a + b
    >>> c
    Decimal('3.304863269228730284730287123')   

    Örneğin:

    >>> a = decimal.Decimal('1.65243163461436514236514356143614236514326142365142365412634162356123')
    >>> b = decimal.Decimal('1.65243163461436514236514356143614236514326142365142365412634162356123')
    >>> context = decimal.getcontext()
    >>> context.prec = 3
    >>> c = a + b
    >>> c
    Decimal('3.30')

    Buradaki yuvarlama da aslında birkaç seçenekten biri olarak seçilebilir. Yuvarlamanın biçimi bağlam nesnesinin rounding elemanı 
    ile belirlenmektedir. Bu eleman default olarak decimal.ROUND_HALF_EVEN biçimindedir. ROUND_HALF_EVEN durumunda sayı yuvarlanacağı 
    zaman yuvarlama yerinde 5 varsa ve başka bir digit yoksa bu durumda sayının noktadan sonraki kısmı (yani 5'in solundaki kısmı) 
    çift olacak biçimde yuvarlama yapılır. ROUND_HALF_UP durumunda ise klasik biçimde [0,4] aşağıya, [5, 9] yukarıya yuvarlanmaktadır. 
    Örneğin:

    >>> context = decimal.getcontext()
    >>> context.prec = 3
    >>> d = decimal.Decimal('1.335')
    >>> d + 0
    Decimal('1.34')
    >>> d = decimal.Decimal('1.345')

    Burada 4 basamaklı mantise sahip olan sayı 3 basamaklı mantise yuvarlanmaktadır. Ancak yuvarlama noktasında 5 vardır. İşte bu durumda
    sayı 1.33 biçiminde değil 1.34 biçiminde yuvarlanmaktadır. Çünkü 1.34'teki sayının noktadan sonrak kısmı öift sayıdır. Ancak örneğin:

    >>> d = decimal.Decimal('1.345')
    >>> d + 0
    Decimal('1.34')
    
    Burada yuvarlama sonrasında elde edilecek 1.34 sayısının noktadan sonraki kısmı zaten çift olduğu için yuvarlama sonucunda 1.34 
    elde edilmeiştir. decimal.ROUND_HALF_UP yuvarlaması bildiğimiz klasik yuvarlamadır. Yani sayının yuvarlanacak yerindeki basamak 
    [0, 4] arasındaysa yuvarlama aşağıya doğru, [5, 9] arasındaysa yukarıyaş doğru yapılmaktadır. Örneğin:

    >>> context = decimal.getcontext()
    >>> context.rounding = decimal.ROUND_HALF_UP
    >>> context.prec = 3
    >>> d = decimal.Decimal('1.345')
    >>> d + 0
    Decimal('1.35')

    Python'un built-in round fonksiyonu da buradaki ROUND_HALF_EVEN gibi çalışmaktadır. Örneğin:
    
    >>> x = 3.375
    >>> round(x, 2)
    3.38

    Ancak yuvarlama hataları nedeniyle sayının aslında niyet edilenden daha küçük olabileceğini de göz önümde bulundurunuz. Örneğin:

    >>> f = 1.335
    >>> round(f, 2)
    1.33

    Burada ROUND_HALF_EVEN yuvarlamasıyla 1.34 değerinin elde edilmesi gerekir. Ancak aslında 1.335 sayısının kendisi bu biçimde 
    değildir. Bu sayı zaten yuvarlama hatası nedeniyle bu değerdne küçüktür. Dolayısıyla yuvarlama ROUND_HALF_EVEN olsa bile yuvarlama
    noktası 5 olmadığı için bu değer elde edilmiştir:

    >>> print(f'{f:.20f}')
    1.33499999999999996447
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Şimdi de Python Standart Kütüphanesindeki rasyonel sayıları temsil eden Fraction sınıfı üzerinde duralım. 

    Rasyonel sayılar a ve b birer tamsayı ve b 0'a eşit olmamak üzere olmak üzere a / b biçiminde yazılabilen sayılara denilmektedir. 
    Matematikte rasyonel sayılar kümesi tamsayılar kümesini kapsamaktadır. Her rasyonel sayının noktadan sonraki belli kısmı devreder. 
    Yani her rasyonel sayının devirli ondalıklı açılımı vardır. Örneğin:

    22/7 = 3.142857142857142857...

    Burada devreden kısım 142857'dir. Örneğin:

    1/2 = 0.5000000...

    Burada devreden kısım 0'dır. Örneğin:

    2/1 = 2.000000...

    Burada da devreden kısım 0'dır. 

    Ancak bilindiği gibi noktalı fakat devretmeyen sayılar da vardır. Bu sayılar iki sayının bölümü biçiminde yazılamamaktadır.
    Bunlara irrasyonel sayılar denilmektedir. Örneğin pi sayısı, e sayısı, köklü sayıların önemli bir bölümü irrasyonel sayılardır.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Python'un standart kütüphanesindeki fractions isimli modülde Fraction isimli sınıf rasyonel sayıları temsil etmektedir. Bir 
    Fraction nesnesi pay ve payda belirtilerek yaratılabilir. Örneğin:

    from fractions import Fraction

    x = Fraction(3)       # 3/1 ile aynı anlamda
    y = Fraction(2, 3)    # 2/3 ile aynı anlamda

    Biz aşağıdaki örneklerimizde Fraction sınıfının fractions modülünden import edildiğini varsayacağız. 

    İngilizce "pay" sözcüğü "numerator" biçiminde "payda" sözcüğü ise "denominator" biçiminde ifade edilmektedir. Bir Fraction 
    nesnesi float bir nesneyle de yaratılabilmektedir. Örneğin:

    >>> x = Fraction(0.5)
    >>> print(x)
    1/2
    >>> x = Fraction(0.125)
    >>> print(x)
    1/8
    >>> x = Fraction(0.12345)
    >>> print(x)
    2223877495995551/18014398509481984

    Birs string'ten de Fraction nesnesi oluşturulabilmektedir. Örneğin:

    >>> x = Fraction('1/2')
    >>> x
    Fraction(1, 2)
    >>> print(x)
    1/2

    Fraction nesnesi yaratılıken pay ve payda değerleri sadeleştirilerek nesne içerisinde tutulmaktadır. Örneğin:

    >>> x = Fraction(5, 100)
    >>> print(x)
    1/20
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Fraction sınıfının rasyonel sayı işlemlerini yapan pek çok operatör metodu bulunmaktadır.  math modülündeki matematiksel 
    fonksiyonlar da Fraction nesneleri ile çalışmaktadır. Ancak bu durum açıkça Python dokümanlarında belirtilmemiştir. Örneğin:

    >>> x = Fraction('1/2')
    >>> y = Fraction('2/5')
    >>> z = x + y
    >>> print(z)
    9/10
    >>> z = x * y
    >>> print(z)
    1/5
    >>> z = x - y
    >>> print(z)
    1/10
    >>> z = x / y
    >>> print(z)
    5/4
#------------------------------------------------------------------------------------------------------------------------------------

from fractions import Fraction

x = Fraction(1, 2)
print(x)

y = Fraction(1, 3)
print(y)

result = x + y
print(result)       # 5/6

result = x + y * 2
print(result)       # 7/6

result = x ** 2
print(result)       # 1/4

import math

result = math.sqrt(x)
print(result)       # 0.7071067811865476

result = math.sin(x)
print(result)       # 0.479425538604203

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Fraction nesnesindeki pay ve payda değerleri numerator ve denominator öznitelikleri ile elde edebilir. Örneğin:
    
    >>> x = Fraction('1/2')
    >>> x.numerator
    1
    >>> x.denominator
    2
#------------------------------------------------------------------------------------------------------------------------------------
    
from fractions import Fraction

x = Fraction(1, 2)
print(x.numerator, x.denominator)

#------------------------------------------------------------------------------------------------------------------------------------
    Fraction sınıfının as_integer_ratio metodu bize rasyonel sayının pay ve paydasını iki tane int değerden oluşan bir demet olarak 
    verir. Örneğin:

    >>> x = Fraction('1/2')
    >>> x.as_integer_ratio()
    (1, 2)
    >>> a, b = x.as_integer_ratio()
    >>> a
    1
    >>> b
    2

    Fraction sınıfına bir float sayı verildiğinde sınıf bunu otomatik olarak rasyonel sayı biçimine dönüştürmektedir. Ancak biz 
    limit_denominator metodu ile bu sayıların basamaklarını sınırlandırabiliriz. Örneğin:

    >>> Fraction('3.1415926535897932')
    Fraction(7853981633974483, 2500000000000000)
    >>> Fraction('3.1415926535897932').limit_denominator(1000)
    Fraction(355, 113)
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Python'da "soyut sınıflar (abstract classes)" ve "soyut metotlar (abstract nethods)" konularını ele alacağız. 
    
    Nesne Yönelimli Programlama Tekniğinde (NYPT) "soyut sınıf (abstract class)" kendisinden nesne yaratılamayan içerisindeki soyut 
    metotları sınıftan türetme yapan kişilerin yazmak (override etmek) zorunda olduğu özel sınıflardır. Soyut sınıflar "bir kontrat 
    oluşturmak için", bir "arayüz oluşturmak için" ve birtakım minimal gereksinimlerin karşılanması için kullanılabilmektedir. 
    C++, Java ve C# gibi dillerde soyut sınıflar doğrudan dilin sentaksı tarafından desteklenmektedir. Java ve C# gibi dillerdeki 
    "arayüzler (interface)" benzer amaçla kullanılıyor olsa da soyut sınıflardan farklıdır. Bu dillerdeki arayüzler veri elemanlarına 
    (fields) sahip olamazlar ve soyut olmayan metotlar içeremezler. Halbuki soyut sınıflar veri elemanlarına (fields) sahip olabilmekte 
    ve soyut olmayan metotlar içerebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir soyut sınıfı Python'da oluşturabilmek için abc isimli modüldeki ABC sınıfından faydalanılmaktadır. (Buradaki abc ismi "abstract 
    base class" sözcükleriden kısaltılmıştır.) Programcı abc.ABC sınıfından türetme yaparsa türettiği sınıf soyut sınıf olur. Örneğin:

    import abc

    class Sample(abc.ABC):
        pass

    Bir soyut sınıf soyut metotları oluşturmak için kullanılmaktadır. Yani biz bir soyut sınıfa soyut metot yerleştirmezsek soyut sınıf 
    oluşturmamızın bir anlamı kalmaz. Bir soyut sınıfa soyut metot yerleştirmek için soyut metodun abc.abstractmethod dekoratörü ile 
    dekore edilmesi gerekmektedir. Örneğin:

    import abc

    class Sample(abc.ABC):
        def foo(self):
            print('foo')
        
        @abc.abstractmethod
        def bar(self):
            pass

    Soyut sınıftaki soyut metot normal bir metot gibi suit içerebilir. Örneğin:

    import abc

    class Sample(abc.ABC):
        def foo(self):
            print('Sample.foo')
        
        @abc.abstractmethod
        def bar(self):
            print('abstract bar')

    Soyut bir sınıfa en az bir soyut bir metot yerleştirilirse artık o soyut sınıf türünden nesneler yaratılamaz. Örneğin:

    s = Sample()            # exception oluşur

    Soyut bir sınıfın kendisi bir işe yaramaz. Ondan türetme yapılması ve taban sınıftaki soyut metotların türemiş sınıfta yazılması 
    (override edilmesi) gerekir. Örneğin:

    import abc

    class A(abc.ABC):
        def foo(self):
            print('foo')
        
        @abc.abstractmethod
        def bar(self):
            pass
        
    class B(A):
        pass

    Burada A soyut bir sınıftan Tretme yapılarak B sınıfı oluşturulmuştur. Ancak bu türetme sonrasında türemiş sınıf olan B sınıfında 
    taban A sınıfının soyut bar metodu tanımlanmamıştır. İşte bu durumda B sınıfı da soyut olur. B sınıfı türünden de nesne 
    yaratılamaz. Yukarıdaki örnekte biz ne A sınıfı türünden ne de B sınıfı türünden nesne yaratabiliriz. Bir soyut sınıfın (örneğimizde
    A) işe yarayabilmesi için ondan türetme yapılıp oradaki abstract metotların yazılması gerekir. Örneğin:

    class A(abc.ABC):
        def foo(self):
            print('foo')
        
        @abc.abstractmethod
        def bar(self):
            print('bar')
        
    class B(A):
    def bar(self):
        print('B.bar')

    b = B()     # geçerli

    Görüldüğü gibi artık türemiş B sınıfı türünden nesneler yaratabilmekteyiz. 

    Yukarıda da belirttiğimiz gibi bir soyut sınıftan türetme yapıldığında türemiş sınıfın soyutluktan kurtulup somut (concrete) 
    hale gelebilmesi için taban soyut sınıftaki bütün soyut metotları barındırması gerekir. Örneğin:

  import abc

    class A(abc.ABC):
        def foo(self):
            print('foo')
        
        @abc.abstractmethod
        def bar(self):
            pass
        
        @abc.abstractmethod
        def tar(self):
            pass
        
    class B(B):
        def bar(self):
            print('B.bar')
            
    Burada B sınıfı A sınıfından türetilmiştir. Ancak A sınıfındaki yalnızca bar soyut metodunu barındırmıştır. Bu durumda B sınıfı 
    da yine soyut durumda kalacaktır. Dolayısıyla biz B  türünden de nesneler yaratamayız. Örneğin:

    b = B()     # exception oluşur!

    Ancak buradaki B sınıfı A sınıfındaki bar ve tar soyut metotlarının  her ikisini de barındırırsa (override ederse) B sınıfı da
    somut hale getirilebilir. Örneğin:

    class A(abc.ABC):
        def foo(self):
            print('foo')
        
        @abc.abstractmethod
        def bar(self):
            print('bar')
            
        @abc.abstractmethod
        def tar(self):
            print('tar')
            
    class B(A):
    def bar(self):
        print('B bar')
        
    def tar(self):
        print('B.tar')

    b = B()     # geçerli
#------------------------------------------------------------------------------------------------------------------------------------

import abc

class A(abc.ABC):
    def foo(self):
        print('foo')
    
    @abc.abstractmethod
    def bar(self):
        print('bar')
        
    @abc.abstractmethod
    def tar(self):
        print('tar')
        
class B(A):
   def bar(self):
       print('B bar')
       
   def tar(self):
      print('B.tar')

b = B()     # geçerli

#------------------------------------------------------------------------------------------------------------------------------------
    Peki toplamda soyut sınıf ve soyut metotlar neyi sağlamaktadır? İşte yukarıda da belirttiğimiz gibi bu ekanizma bir "kontrat" 
    başka bir deyişle "taahhüt" oluşturmaktadır. Biz ya da kütüphaneleri yazanlar bir soyut sınıfı kullanan kişilerin o soyut 
    sınıftaki metotları barındırdıklarından emin olurlar. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Python'da "meta sınıflar (meta classes)" konusu genellikle programcıların doğrudan kullanmadığı ve kişilere oldukça soyut gelen 
    mantıksal bakımdan bir konudur. Ancak ayrıntılı birtakım modüllerin yazılması gerektiği durumlarda "meta sınıflardan" faydalanılması 
    gerekebilmektedir. Meta sözcüğü "bir olguyu betimleyen olgular için" kullanılmaktadır. Örneğin "metadata" data'yı betimleyen data 
    anlamındadır. Yani bir verinin neresinde ne olduğunu anlatan verilerdir. "Meta language" dilleri betimleyen dildir. "Meta programlama"
    program oluşturan program yazma etkinliğine denilmektedir. İşte Python'daki "meta sınıf" kavramı da benzerdir. Türkçe'de meta 
    sözcüğünün karşılığı olarak genellikle "üst" sözcüğü kullanılmaktadır. 

    Bu bölümde Python'un belki de en karmalık konularından biri olan "meta sınıflar" konusunu ele alacaız.
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Python yorumlayıcı bir sınıf tanımlamasıyla karşılaştığında önce type sınıfı türünden bir nesne yaratır. Sonra bu nesnenin içerisine
    sınıfın bilgilerini yerleştirir. Sonra da bu nesnenin adresini sınıf ismiyle belirtilen değişkene atar. Örneğin:

    class Sample:
        pass

    Burada Sample aslında type türünden bir sınıf nesnesini gösteren bir değişkendir. Sample değişkeninin diğer değişekenlerden hiçbir 
    farkı yoktur. Biz Python'da "bir değişkenin türü" denildiğinde o değişkenin gösterdiği nesnenin türü anlaşılmaktadır. Örneğin:

    a = 123

    Burada a değişkeni bir int nesneyi göstermektedir. Dolayısıyla a int türündendir. Örneğin:

    class Sample:
        pass

    Burada Sample değişkeni type sınıfı türünden bir nesneyi göstermektedir. O halde Sample değişkeni type türündendir. Örneğin:

    >>> class Sample:
    ...     pass
    ...
    >>> a = 100
    >>> type(a)
    <class 'int'>
    >>> type(Sample)
    <class 'type'>

    Sınıflar aynı zamanda tür de belirtmektedir. Biz bir sınıf türünden değişken yarattığımızda artık değişkenin türü o sınıf 
    türünden olur. Örneğin:

    >>> class Sample:
    ...     pass
    ...
    >>> type(Sample)
    <class 'type'>
    >>> s = Sample()
    >>> type(s)
    <class '__main__.Sample'>

    Görüldüğü gibi burada Sample değişkeni type türündedir, s değişkeni ise Sample türündendir. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Sınıf isimleri de sıradan birer değişken olduğuna göre başka değişkenlere atanabilirler. Örneğin:

    class Sample:
        pass

    Mample = Sample

    Burada hem Sample hem de Mample aynı type nesnesini dolayısıyla da aynı sınıf bilgilerini temsil etmektedir. Bizim artık Sample 
    ismini kullanmamızla Mample ismini kullanmamız arasında hiçbir farklılık yoktur. Örneğin:

    s = Sample()
    m = Mample()

    Burada her iki değişken de aslında aynı sınıf türündendir. Python yorumlayıcısı sınıfın ismini de type nesnesinin içerisine 
    yerleştirmektedir. Bu yerleştirme işlemini class tanımlamasını gördüğünde yapmaktadır. Dolayısıyla sınıfın type nesnei içerisindeki
    isim class anahtar sözcüğünün yanındak isimdir. Yukarıdaki örnekte biz type(m) yaptığımızda sınıfın ismini Mample görmeyiz, 
    Sample görürüz:

    >>> class Sample:
    ...     pass
    ...
    >>> Mample = Sample
    >>> s = Sample()
    >>> m = Mample()
    >>> type(s)
    <class '__main__.Sample'>
    >>> type(m)
    <class '__main__.Sample'>

    Python'da type sınıfında olduğu gibi bir sınıfın bilgilerini tutan sınıfa "meta sınıf (meta class)" denilmektedir. type bir meta 
    sınıftır. Bir sınıf tanımladığımızda yorumlayıcı default durumda meta sınıf olarak type sınıfını kullanmaktadır. Ancak biz 
    kullanılacak meta sınıfı değiştirebiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                            75. Ders 20/12/2025 – Cumartesi
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Öncelikle default meta sınıf olan type sınıfı hakkında bazı ayrıntılar üzerinde duralım. type fonksiyonunu biz bir değişkenin 
    türünü elde etmek için kullanmıştık. Örneğin:

    >>> a = 10
    >>> type(a)
    <class 'int'>

    type fonksiyonu aslında bize bir yazı değil ilgili değişkenin türüne ilişkin sınıf bilgilerinin yerleştirilmiş olduğu type 
    nesne referansını vermektedir. Yukarıdaki örnekte type(a) ile int aynı anlamdadır. Çünkü int değişkeni aslında int isimli 
    sınıfın bilgilerinin tutulduğu type nesnesinin adresini tutan bir değişkendir. type(a) ifadesi de bize aynı nesnenin adresini 
    vermektedir. O halde type(a) ile verilen adres ile int değişkeninin içerisindeki adres aynı type nesnesini göstermektedir. 
    Yorumlayıcı her sınıf için yalnızca bir tane type nesnesi oluşturmaktadır. Örneğin:

    >>> a = 10
    >>> t = type(a)
    >>> t is int
    True
    >>> id(t)
    140704769070640
    >>> id(int)
    140704769070640

    Aynı durum bizim oluşturduğumuz sınıflar için de geçerlidir. Örneğin:

    >>> class Sample:
    ...     pass
    ...
    >>> s = Sample()
    >>> t = type(s)
    >>> t is Sample
    True

    type sınıfının __str__ ve __repr__ metotları o type nesnesi içerisinde hangi sınııfn bilgileri varsa bize o sınııfn ismini bir 
    string olarak vermektedir. Örneğin:

    >>> class Sample:
    ...     pass
    ...
    >>> print(Sample)
    <class '__main__.Sample'>
    >>> print(repr(Sample))
    <class '__main__.Sample'>

    Bu nedenle biz bir sınıf türünden değişkeni type fonksiyonuna sokup onu yazdırdığımızda o değişkenin türü ekrana çıkmaktadır. 
    Örneğin:

    >>> s = Sample()
    >>> print(type(s))
    <class '__main__.Sample'>
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Mademki yorumlayıcı bir sınıf tanımlaması gördüğünde aslında type sınıfı türünden bir nesne yaratmaktadır, o halde biz de hiç 
    sınıf tanımlaması yapmadan type sınıfı türünden bir nesne yaratırsak aslında bir sınıf oluşturmuş oluruz. İşte type fonksiyonu 
    iki biçimde çağrılmaktadır: Tek argümanla ve üç argümanla. type fonksiyonu (aslında type sınıfının __init__ metodu) eğer tek 
    argümanla çağrılırsa argümanda belirtilen nesneye ilişkin sınıfın type nesne referansını döndürmektedir. Eğer type fonksiyonu üç 
    argümanla çağrılırsa (yani type sınıfının __init__ metodu üç argümanla çağrılırsa) type fonksiyonu bize yeni bir type nesnesi 
    yaratır ve o type nesnesinin nesne  adresini verir. Yeni bir type nesnesinin yaratılması yeni bir sınıfın yaratılması anlamına 
    gelmektedir. O halde bir sınıf yaratmak için sınıf tanımlamak yerine biz doğrudan bu işi type fonksiyonuyla da yapabiliriz. Zaten 
    yorumlayıcı bir sınıf tanımlamasını gördüğünde aslında kendisi type fonksiyonunu çağırıp sınıfı oluşturmaktadır. 

    type fonksiyonun bir argümanla çağrılmasıyla üç argümanla çağrılması arasındaki önemli farka dikkat ediniz. type fonksiyonu bir 
    argümanla çağrıldığında bize o argümanın ilişkin olduğu sınıfın type nesnesinin adresini vermektedir. Ancak üç argümanla çağrıldığında 
    bu bir "sınıf yaratma" anlamına gelmektedir. type fonksiyonunun üç argümanı şunları belirtmelidir:

    type(sınıf_isim, taban_sınıflarını_belirten_demet, sınıfın_elemanlarını_belirten_sözlük)

    Taban sınıflar bir demet biçiminde verilmelidir. Burada boş demet geçilse bile yine sınıf object sınıfından türetilmiş olacaktır. 
    Yani eğer sınıf herhangi bir sınıftan türetilmeyecekse argümana () girmekle (object, ) girmek arasında bir fark oluşmaz. Sınıfın 
    öznitelikleri ise bir sözlük biçiminde verilmelidir. Aslında Python yorumlayıcısı da bir sınıfla karşılaştığında zaten o sınıfı type 
    fonksiyonuyla yaratmaktadır. Sınıfın elemanları type nesnesinin içerisindeki bir sözlükte tutulmaktadır. Örneğin:

    class Sample:
        x = 10
        def foo(self, a):
            return a * a

    Böyle bir sınıf bildirimini gören yorumlayıcı aslında type fonksiyonu ile şöyle bir nesne yaratmaktadır:

    Sample = type('Sample', (object, ), {'x': 10, 'foo': foo})

    Mademki yorumlayıcı bir sınıf tanımlamasını gördüğünde type sınıfı türünden bir nesne yaratmaktadır. O halde aslında aynı şeyi biz 
    de yapabiliriz:

    def init(self, a):
        self.a = a
        
    def disp(self):
        print(self.a)
        
    Sample = type('Sample', (object, ), {'__init__': init, 'disp': disp})

    s = Sample(10)
    s.disp() 
#------------------------------------------------------------------------------------------------------------------------------------

def foo(self, a):
    return a * a

Sample = type('Sample', (object, ), {'x': 100, 'foo': foo})

s = Sample()

print(s.x)
result = s.foo(4)
print(result)

#------------------------------------------------------------------------------------------------------------------------------------
    Peki biz bir sınıfı class anahtar sözcüğü ile yarattığımızda sınıf için yaratılan type nesnesinin içerisinde hangi elemanlar 
    vardır? Aslında type sınıfının kendisi de object sınıfından türetilmiştir. Bu nedenle type nesnesinin içerisinde object sınıfının 
    elemanları da olacaktır. Örneğin:

    >>> type.__bases__
    (<class 'object'>,)
    >>> dir(type)
    ['__abstractmethods__', '__annotations__', '__base__', '__bases__', '__basicsize__', '__call__', '__class__', '__delattr__', 
    '__dict__ ', '__dictoffset__', '__dir__', '__doc__', '__eq__', '__flags__', '__format__', '__ge__', '__getattribute__', '__gt__', 
    '__hash__', '__init__', '__init_subclass__', '__instancecheck__', '__itemsize__', '__le__', '__lt__', '__module__', '__mro__', 
    '__name__', '__ne__', '__new__', '__or__', '__prepare__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__ror__', 
    '__setattr__', '__sizeof__', '__str__', '__subclasscheck__', '__subclasses__', '__subclasshook__', '__text_signature__', 
    '__weakrefoffset__', 'mro']
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında yorumlayıcı bir sınıf nesnesinin içerisine __dict__ isimli bir sözlük elemanı yerleştirmektedir. Yani type fonksiyonuyla 
    verilen sözlük istenirse sınfın __dict__ elemanı ile de elde edilebilir. __dict__ bir sınıf değişkenidir. Bu nedenle sınıf ismiyle 
    ya da o sınıf türünden bir değişkenle kullanılablir.  Örneğin:

    class Sample:
        def foo(self):
            pass
    
        def bar(self):
            pass
               
    d = Sample.__dict__
    print(d)

    Buradan şöyle çıktı elde edilmiştir:

    {'__module__': '__main__', 'foo': <function Sample.foo at 0x00000214C935E280>, 'bar': <function Sample.bar at 0x00000214C935E040>, 
    'x': 10, '__dict__': <attribute '__dict__' of 'Sample' objects>, '__weakref__': <attribute '__weakref__' of 'Sample' objects>, 
    '__doc__': None}

    Burada __doc__ ve __weakref__ gibi bizim bulundurmadığımız iki elemanı da görüyorsunuz. __doc__ sınıfın doküman yazısını belirtir. 

    Tabii aslında bir sınıf türünden nesnenin içerisine de bir __dict__ elemanı yerleştirilmektedir. Örneğin:

    def foo(self):
        pass

    d = {'x': 10, 'foo': foo}
    Sample = type('Sample', (object, ), d)

    s = Sample()
    print(s.__dict__)

    Burada ekrana şunlar basılmıştır:

    {'x': 10, 'foo': <function foo at 0x0000014FA81C3640>, '__module__': '__main__', '__dict__': <attribute '__dict__' of 'Sample' objects>,
     '__weakref__': <attribute '__weakref__' of 'Sample' objects>, '__doc__': None}
    {}
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi a bir sınıf türünden değişken olmak üzere a(...) biçimindeki bir ifade  aslında a.__call__(...) anlamına 
    gelmekteydi. Yani bir sınıf türünden değişkeni (...) operatörü ile kullandığımızda aslında o değişkenin ilişkin olduğu sınıfın 
    __call__ metodu çağrılmaktadır. O halde bir sınıf türünden nesne yaratma işlemi de aslında type sınıfının __call__ metodu ile
    yapılmaktadır. Örneğin:

    class Sample:
        pass

    s = Sample()        # Sample type türünden olduğuna göre nesne type sınıfının __call__ metodu tarafından yaratılır. 

    Burada Sample aslında type türünden bir nesneyi göstermektedir. O halde Sample(...) işleminde aslında type sınıfının __call__ 
    metodu çağrılacaktır. Başka bir deyişle aslında nesneyi yaratmaktan sorumlu olan ana mekanizma type sınıfının __call__ metodudur.
    
    Peki type sınıfının __call__ metodu nesneyi nasıl yaratmaktadır? İşte type sınıfının __call__ metodu önce sınıf nesnesini bellekte 
    yaratmak için söz konusu sınıfın ile __new__ isimli statik metodu çağırmaktadır. Eğer bu __new__ metodu ilgili sınıf türünden bir 
    type nesnesi verirse bu durumda o nesneyle bu kez __init__ metodunu çağırmaktadır. Yani tasarımda nesnenin bellekte tahsis edilmesi 
    ile tahsis edilmiş nesneye ilkdeğerlerin verilmesi biribirinden ayrılmıştır. __new__ metodu nesneyi tahsis etmek için kullanılırken 
    __init__ metodu tahsis edilmiş nesne üzerinde birtakım ilkdeğerlerin verilmesi için kullanılmaktadır. Bu durumda type sınıfının 
    nesne yaratımını yapan __call__ metodu nesneyi şöyle yaratmaktadır:

    1) Önce söz konusu sınıf türüyle __new__ static metodunu çağırır. Tahsisat bu metot tarafından yapılmalıdır. Bu noktada yaratılmak 
    istenen sınıfın __new__ metodu çağrılmaktadır. Tabii eğer ilgili sınıfta __new__ mwtodu yazılmamışsa taban sınıfın (örneğin object 
    sınıfının) __new__ metodu çağrılacaktır.

    2) __new__ metodunun geri döndürdüğü nesne eğer __call__ metodunun çağrıldığı nesne türündense (yani yaratımak istenen nesnenin 
    türüne ilişkin sınıf türündense) bu kez type sınıfının __call__ metodu __new__ ile elde edilen nesne ile sınıfın __init__ 
    metodunu çağırmaktadır. 
    
    Yani type sınıfının __call__ metodu temsili olarak şöyle yazılmıştır:

    class type:
        def __call__(self, *args, **kwargs):
            if self.__new__ is not object.__new__:
                obj = self.__new__(self, *args, **kwargs)
            else:
                obj = object.__new__(self)

            if obj is self:
                oobj.__init__(*args, **kwargs)

            return obj

    Buradan görüldüğü gibi bir nesne yaratılırken aslında önce o sınıfın static __new__ isimli static metodu çağrılmaktadır. O metodun 
    geri döndürdüğü nesne eğer tahsis edilmek istenen sınıf türündense o nesne ile __init__ metodu çağrılmaktadır. Peki programcı 
    kendi sınıfı için __new__ metodunu yazmazsa ne olur? Bu tür durumda bildiğiniz gibi o sınıfın __new__ metodu olan ilk taban sınıfın 
    __new__ metodu çağrılacaktır. Aslında tüm tahsisatlar eninde sonunda object sınıfının __new__ metoduyla yapılmaktadır. Programcı 
    kendi sınıfında __new__ metodunu yalnızca "araya girmek için" yazar (override eder). Programcı da aslında kendi yazdığı __new__ 
    metodunda super().__new__(cls) çağrısıyla tahsisatın object sınıfının __new__ metodu tarafından yapılmasını sağlar. Örneğin:

    class Sample:
        @staticmethod
        def __new__(cls, *args, **kwargs):
            print(f'__new__ called: {args},  {kwargs}')
            obj = super().__new__(cls)
            return obj
        
        def __init__(self, a, b):
            print('__init__ called')
        
    s = Sample(10, 20)
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Peki __new__ metodu nasıl ve neden yazılır? __new__ metodu static bir metot olmalıdır. __new__ metodunun birinci parametresi tahsis 
    edilecek sınıf türünden type nesnesini belirtir. type sınıfının __call__ metodu __new__ metoduna nesne yaratılırken kullanılan 
    bütün argümanları geçirdiği için __new__ metodunun parametrik yapısının da bu argümanları alacak biçimde *args ve **kwargs 
    parametrelerine sahip olması gerekir. Bu durumda __new__ metodunun tipik parametrik yapısı şöyle oluşturulmalıdır:

    def __new__(self, *args, **kwargs):
        pass

    Yukarıda da belirttiğimiz gibi programcı yalnızca araya girme işlemi yapmalıdır. Gerçek nesne her zaman eninde sonunde object.__new__ 
    metoduyla yaratılmak zorundadır. Ancak bu noktada bir ayrıntıya dikkatinizi çekmek istiyoruz. object sınıfının __new__ metodunun 
    tek parametresi vardır. Yani *args ve **kwargs parametrleri yoktur. Dolayısıyla __new__ metodunu yazdığımız sınıf başka bir sınıftan 
    türetilmişse taban sınıfın __new__ metodunu çağırırken dikkat ediniz. Eğer taban sınıfta __new-_ metodu yazılmamışsa object sınıfının
     __new__ metodu çağrılacaktır.

    Bazı ileri uygulamalarda __new__ metodunun programcı tarafından yazılması gerekebilmektedir. Örneğin singleton kalıbı Python'da __new__ 
    metodu yoluyla sağlanabilir. NYPT'de bir tasarım kalıbı olarak "singleton" bir sınıf türünden toplamda tek bir nesnenin var olmasını 
    sağlayan  kalıptır. Bu kalıpta programcı birden fazla nesne yarattığını sansa bile aslında toplamda tek bir nesne yaratılmaktadır. 
    İşte biz de singleton kalıbını aşağıdaki gibi oluşturabiliriz:

    class Mample:
        pass

    class Sample:
        _obj = None
        @staticmethod
        def __new__(cls, *args, **kwargs):
            if Sample._obj is None:
                Sample._obj = super().__new__(cls)
            return Sample._obj
        
        def __init__(self):
            print('__init__ called')
        
    s = Sample()
    k = Sample()
    m = Sample()
            
    print(id(s), id(k), id(m))   

    Göürldüğü gibi __new__ içerisinde nesne daha önce yaratılmışsa yaratılmış olan nesne verilmektedir. Eğer nesne daha önce yaratılmamışsa 
    gerçekten yaratılmaktadır. 

    Singleton nesnenin dekoratör yoluyla da yazılmasını da sağlayabiliriz. Bunun klasik yolu dekoratör sınıfında __call__ metodunda nesne 
    yaratımını yapmaktadır. Örneğin:
    
    class singleton:
        def __init__(self, cls):
            self.cls = cls
            self._obj = None
            
        def __call__(self, *args, **kwargs):
            if self._obj is None:
                self._obj = self.cls(*args, **kwargs)
            return self._obj
    
    @singleton
    class Sample:
        pass

    s = Sample()
    k = Sample()
    m = Sample()

    print(id(s), id(k), id(m))

    Sınıf dekoratörleri yokken aynı işlem türtetme yoluyla da yapılabiliyordu:

    class Singleton:
        _obj = None
        
        @staticmethod
        def __new__(cls, *args, **kwargs):
            if Singleton._obj is None:
                Singleton._obj = super().__new__(cls)
            return Singleton._obj
        
        def __init__(self):
            print('__init__')

    class Sample(Singleton):
        pass
   
    s = Sample()
    print(id(s))

    k = Sample()
    print(id(k))

    m = Sample()
    print(id(m))
 #------------------------------------------------------------------------------------------------------------------------------------

 #------------------------------------------------------------------------------------------------------------------------------------   
    Bazen __new__ metodunda programcı başka bir sınıf türünden nesneyi tahsis edip verebilir. Tabii bu durumda asıl sınıfın __init__
    metodu hiç çağrılmayacaktır. NYPT'de bu başka sınıf türünden nesnelerin yaratılmasında kullanılan bu tür kalıplara "fabrika kalıbı 
    (factory pattern)" denilmektedir. Örneğin:

    class A:
        def __init__(self):
            print('A created')
            
    class B: 
        def __init__(self):
            print('B created')
            
    class Factory:
        @staticmethod
        def __new__(cls, name, **kwargs):
            if name == 'A':
                obj = A()
            elif name == 'B':
                obj = B()
            else:
                obj = object()
            return obj
        
    a = Factory('A')            # aslında Factory değilk A nesnesi yaratılaca
    b = Factory('B')            # aslında Factory değil B nesnesi yaratılacak
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi yorumlayıcı bir sınıf tanımlamasıyla karşılaştığında önce type sınıfı türünden bir nesne yaratıyordu ve sınıfın 
    bilgilerini bu nesnenin içerisine yerleştiriyordu. Sonra da bu nesnenin adresini sınıf ismi olan değişkene atıyordu. İşte bir 
    sınıf yaratıldığında onun bilgilerini tutan type sınıfına meta sınıf denilmektedir. Buradaki "meta" sözcüğü sınıf bilgilerini 
    tutan sınıf anlamındadır. 
    
    İşte eğer isterse programcı yorumlayıcının sınıf tanımlamasını gördüğünde yaratacağı nesnenin türünü değiştirebilir. Yani meta 
    sınıf type sınıfı yerine başka bir sınıf da olabilmektedir. Meta sınıfı değiştirmek için sınıfı oluştururken  parantezler içerisinde 
    "metaclass = <sınıf_ismi>" yazılmalıdır. Örneğin:
    
    class Sample(metaclas=MyMetaClass):
        pass

    Buradaki metaclass normal olarak type sınıfından türetilmelidir. Örneğin:

    class MyMetaClass(type):
        pass

    Daha önceden de belirttiğimiz gibi bir sınıf nesnesi yaratıldığında aslında yorumlayıcı metaclass sınıfına ilişkin bir nesne 
    yaratmaktadır. Eğer metaclass belirtilmezse type sınıfına ilişkin nesne yaratılır. Eğer metaclass belirtilirse metaclass türünden 
    nesne yaratılır. (Başka bir deyişle default meta sınıf type sınıfıdır.) Yukarıda da belirttiğimiz gibi bu yaratım sırasında 
    yorumlayıcı sınıf ismini bir string olarak, sınıfın taban sınıflarını bir demet olarak ve sınıfın içerisindeki elemanları da 
    bir sözlük nesnesi olarak parametre yapıp metaclass sınıf nesnesini yaratmaktadır. Yani yaratım adeta şöyle yapılmaktadır:

    MyMetaClass(sınıf_isim, taban_sınıflar, sınıfın_elemanları)

    Dolayısıyla eğer biz meta sınıfımız için __init__ metodu yazacaksak bu __init__ metodunun self dışında üç parametresi olmalıdır. 
    Ancak aslında yaratımda type sınıfı kullanılacağı için bu parametrelerin super fonksiyonuyla type sınıfına aktarılması gerekir. 
    Örneğin:

    class MyMetaClass(type):
        def __init__(self, name, bases, namespace):
            super().__init__(name, bases, namespace)
            print('MyMetaClass instance created...')

    class Sample(metaclass=MyMetaClass):
        pass

    Bu program çalıştırıldığında ekranda "MyMetaclass instance created..." yazısı çıkmalıdır. Tabii biz meta sınıfımız için 
    __init__ metodunu yazmazsak type sınıfının __init__ metodu çağrılacaktır. Bu metot da normal yaratımı yapacaktır. Örneğin:

    class MyMetaClass(type):
        pass

    class Sample(metaclass=MyMetaClass):
        pass
        
    s = Sample()

    print(type(Sample))     # __main__.MyMetaClass
    print(type(s))          # <class '__main__.Sample'>

    Meta sınıfların type sınıfından türetilmek zorunda olduğuna dikkat ediniz. Çünkü nesnelerin yaratılması gibi işlevsellikler type
    sınıfında bulunmaktadır. Bizim yukarıdaki örneğimizde MyMetaClass isimli sınıfımız type sınıfından türetildiği için zaten type 
    sınıfının bütün işlevselliğini barındırmaktadır. Ancak ondan fazlalıkları vardır.
#------------------------------------------------------------------------------------------------------------------------------------
    
class MyMetaClass(type):
    def __init__(self, name, bases, namespace):
        super().__init__(name, bases, namespace)
        print('MyMetaClass instance created')

class Sample(metaclass=MyMetaClass):
    pass

#------------------------------------------------------------------------------------------------------------------------------------
    Tabii meta sınıfını değiştirdiğimiz sınıfımız başka bir sınıftan türetilmiş olablilir. Bu durumda metaclass belirlemesinin parantez
    içerisinde sonda yapılması gerekir. Örneğin:

    class MyMetaClass(type):
        def __init__(self, name, bases, namespace):
            super().__init__(name, bases, namespace)
            print('MyMetaClass instance created')

    class Sample:
        pass

    class Mample(Sample, metaclass=MyMetaClass):
        pass
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Peki meta sınıfların isimleri hangi sınıf türünden nesne belirtmektedir? Örneğin:

    class MyMetaClass(type):
        pass

    class Sample(metaclass=MyMetaClass):
        pass

    s = Sample()

    Burada s Sample sınıfı türündendir. Sample ise MyMetaClass türündendir. Peki MyMetaClass değişkeni hangi türdendir? MyMetaClass 
    default olarak type türündendir. Tabii aslında o da başka meta sınıf türünden olabilirdi. Tabii zincir bu biçimde devam ettirilirse
    en sonunda yine type nesnesi oluşturulacaktır. 
    
    Burada yorumlayıcı MyMetaClass tanımlamasını gördüğünde type sınıfı türünden bir nesne yaratmaktadır. Bu yaratım sırasında da yine 
    sınıfın __new__ ve __init__ metotları devreye girecektir. Sonra yorumlayıcı Sample sınıfını gördüğinde bu kez MyMetaClass türünden 
    nesne yaratacaktıraratmaktadır. Yorumlayıcı s = Sample() biçiminde Sample sınıfı türünden bir nesne yaratılmak istendiğindeise bu 
    kez MyMetaClass sınıfının __call__ metodunu çağıracaktır. MyMetaClass sınıfı type sınıfından türetildiği için nesnenin yaratılması 
    sırasında yine Sample sınıfının __new__ ve __init__ metotları çağrılacaktır. Özetle türler şöyledir:

    MyMetaClass -----> type
    Sample -----> MyMetaClass
    s ----> Sample
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Peki meta sınıflar neden kullanılmaktadır? Yani biz neden bir sınıfın type sınıfından değil de kendi sınıfımızdan oluşturulmasını 
    isteriz? İşte aslında meta sınıflar Python'da nadiren programcılar tarafından kullanılmaktadır. Bunlar genellikle bazı framework'leri 
    geliştirenler" tarafından ileri amaçlarla kullanılırlar. Örneğin yorumlayıcı bir sınıfı yaratırken meta sınıflar sayesinde biz  
    araya girip o sınıfa bazı elemanlar ekleyebiliriz. Tabii yorumlayıcı da meta sınıf nesnesini aslında type sınıfı türünden yaratmaktadır. 
    Yani bizim meta sınıfımızın ismine değişken de yukarıda belirttiğimiz gibi aslında type türündendir. O halde meta sınıf nesnesi 
    yaratılırken meta sınıf olarak belirttiğimiz sınıfın __new__ ve __init__ metotları çağrılacaktır. Biz de bu metotlarda sınıfa 
    birtakım elemanlar yerleştirebiliriz. Aşağıdaki örnekte meta sınıfın __init__ metodunda yeni yaratılan sınıf nesnesi için x ve foo 
    isimli iki öznitelik yerleştirilmiştir. Burada foo fonksiyonu bir metot gibi işlev görecektir. 
#------------------------------------------------------------------------------------------------------------------------------------

class MyMetaClass(type):
    def __init__(self, name, bases, namespace):
        super().__init__(name, bases, namespace)
        self.foo = foo
        self.x = 123

def foo(self):
    print('foo')
    
class Sample(metaclass=MyMetaClass):
    pass

s = Sample()
s.foo()

#------------------------------------------------------------------------------------------------------------------------------------
    Aslında yukarıdaki gibi araya girerek sınıfa eleman ekleme biçimindeki uygulamalar sınıf dekoratörleriyle de belli ölçüde 
    yapılabilmektedir. Ancak sınıf dekoratörlerinin çeşitli kısıtları vardır. Aşağıdaki örnekte bir sınıf dekoratörü yoluyla yukarıdaki 
    gibi sınıfa yine foo ve x elemanları eklenmiştir. foo bir metot gibi kullanılabilir. 
#------------------------------------------------------------------------------------------------------------------------------------

def foo(self):
    print('Ok')

def SampleDecorator(cls):
    cls.x = 10
    cls.foo = foo
    return cls
        
@SampleDecorator  
class Sample:
    pass

s = Sample()
print(Sample.x)
s.foo()

#------------------------------------------------------------------------------------------------------------------------------------
    Sınıf yaratımında araya girmek için meta sınıflar ve dekoratörler benzer amaçlarla kullanılabiliyor olsa da meta sınıflar 
    daha kapsamlı olanaklara sahiptir. Örneğin biz yazdığımız sınıfı print ettiğimizde istediğimiz bir yazının çıkmasını isteyelim. 
    Bu işlemi aşağıdaki gibi yapamayız:

    def foo(self):
        print('Ok')

    def SampleDecorator(cls):
        cls.__str__ = lambda self: 'this is a test'
        return cls
        
    @SampleDecorator  
    class Sample:
        pass

    print(Sample)

    s = Sample()                # <class '__main__.Sample'>
    print(s)                    # this is a test

    Burada biz sınıfa yerleştirmiş olduğumuz __str__ metodu sınıfın kendisini yazdırılırken devreye girmemektedir. O sınıf türünden 
    bir değişken yazdırılırken devreye girmektedir. Çünkü burada biz yarattığımız sınıfın içerisine bu metodu yerleştirmiş olduk. 
    Halbuki bizim bunu yapabilmemiz için bizzat meta sınıfın içerisine bunu yerleştirmemiz gerekirdi. Bunun için bizim __str__ 
    metodunu meta sınıfın içerisine yerleştirmememiz gerekir. Bunu da yalnızca kendi meta sınıfımızı oluşturarak yaparız. Örneğin:

    class MyMetaClass(type):
        def __str__(self):
            return 'this is a test'
            
    class Sample(metaclass=MyMetaClass):
        pass
    
    print(Sample)       # this is atest

    Burada Sample değişkeni artık type türünden değil MyMetaClass türündendir. Dolayısıyla artık Sample değişkeni print 
    edildiğinde MyMetaClass içerisindeki __str__ metodu çağrılacaktır.
#------------------------------------------------------------------------------------------------------------------------------------

class MyMetaClass(type):
    def __str__(self):
        return 'this is a test'

class Sample(metaclass=MyMetaClass):
    pass

print(Sample)

#------------------------------------------------------------------------------------------------------------------------------------
    Bu bölümde Python'da test işlemleri için kullanılam mekanizmalar üzerinde duracağız. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Yazılımda test süreçleri ürün geliştirmenin önemli bir aşamasını oluşturmaktadır. Programcılar kodlama yaparken böcekler oluşturabilir. 
    Bu böcekler de nihai ürünün kimi zaman yanlış çalışmasına yol açabilir. Bozuk yazılımların kullanıcılara dağıtılmasının önemli 
    zararları vardır. Aslında bu süreç imalat sektöründeki sürece benzemektedir. Bozuk bir ürün kullanıcıya satıldıktan sonra mağduriyetin 
    giderilmesi uzun bir zaman alabilmektedir. Bunun için servis oluşturulmakta, bozuk ürünler maaşlı çalışan kişiler tarafından test 
    edilmekte, duruma göre ürün tamir edilmekte ya da yenisi ile değiştirilmektedir. Bu tür durumlardaki en önemli sorunlardan biri 
    müşteri memnuniyetinin önemli ölçüde zarar görmesidir. Bazı yazılımlarda yazılımın doğru çalışması çok daha önemlidir. Yani bazı 
    yazılımlarda "hata toleransı" çok düşük olabilir. Araştırmalar programcının yaptığı hataların en az %5-%7'sinin tüm test süreçlerini 
    geçerek nihai ürüne yansıdığını göstermektedir. Yine araştırmalar bozuk bir yazılımın müşterinin eline geçtikten sonra düzeltilmesinin 
    çok maliyetli olduğunu göstermektedir. Genel olarak en iyi durum bozuk ürünün üretilmemesidir. Bu başarılamadığında bozuk ürün 
    daha müşterinin eline ulaşmadan tespit edilip düzeltilmelidir. En kötü yani üretici açısından en maliyetli durum bozuk ürünün 
    müşteriye teslim edilmesidir. 

    Eskiden yazılımda test süreçleri bir "lüks olarak" değerlendiriliyordu. Bu nedenle yalnızca büyük firmalar test departmanları 
    bulunduruyordu. Ancak günümüzde artık yazılımda kalite bilinci çok daha fazla artmış ve test süreçleri çok daha bilinir hale 
    gelmiştir. 

    Yazılımda test süreçleri için çeşitli stratejiler kullanılabilmektedir. Ancak test işlemi en alt düzeyde programcının kendi yazdığı 
    kodları test etmesi ile başlar. Bu sürece "birim testleri (unit testing)" denilmektedir. Yani örneğin programcı bir fonksiyon yazmış 
    olsun. Bu fonksiyon doğru çalışmakta mıdır? İşte buna yönelik yapılan testlere "birim testleri (unit testing)" denilmektedir. 
    Yazılımı oluşturan modiller bir araya getirilir. Bu bir araya getirilme işleminden sonragenellikle birleştirilmiş kodlar yeniden test 
    edilmektedir. Buna da "entegrasyon testi (integration testing)" denilmektedir. Yazılımın önemli parçalarına modül de denilmektedir. 
    Modüller de ayrı ayrı test edilebilmektedir. Buna da "modül testleri" denilmektedir. Nihayet tüm ürün oluşturulur ve ürün bir 
    bütün olarak test edilir. Buna da genellikle "kabul testleri (acceptance testing)" denir. Ürün bütün olarak önce kurumun test 
    epartmanı tarafından test edilir. Genellikle test departmanı tarafından yapılan bu testlere "alfa testi (alpha testing)" denilmektedir. 
    Sonra ürün seçilmiş bazı son kullanıcılara dağıtılır ve gerçek hayat testine sokulur. Buna da "beta testi (betta testing)" 
    denilmektedir. 

    birim testleri ---> modül testleri ---> entegrasyon testleri ---> kabul testleri ---> alfa testleri ---> beta testleri
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
                                                76. Ders 28/12/2025 – Pazar
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Peki yazılımlar nasıl test edilmektedir? Manuel yöntemler uygulanabilir. (Örneğin programı çalıştırıp çeşitli değerler için gözle 
    test yapılabilir.) Ancak manuel yöntem çoğu kez yetersiz bir yöntemdir. Yazılımda manuel test yöntemleri de kullanılabiliyor olsa 
    da asıl testler "test işlemini yapan kodlarla" yapılmaktadır. Yani yazılımlar çeşitli aşamalarda oluşturulan ortamlarda özel 
    yazılmış kodlarla test edilmektedir. Bazı yazılımlar normal koşullarda sorunsuz çalışırken özel koşullarda ya da uç noktalarda 
    bozukluklar ortaya çıkartabilmektedir. Yazılımın zor koşullar oluşturularak test edilmesine "stres testleri (stress testing)"
     denilmektedir. 

    Bir programcı için en önemli test aşaması "birim testleridir". Çünkü programcının kendi yazdığı kodların programcı tarafından 
    daha birinci elden test edilmesi en önemli aşamalardan bir tanesidir. Yukarıda da belirttiğimiz gibi aslında nihai ürünün bozuk 
    olmasının en önemli sebeplerinden biri programcının hatalı kodlama yapmasıdır. 

    Biz kursumuzda "birim test süreci için" assert deyimi ve unittest modülünün kullanımları üzerinde duracağız. Diğer test süreçleri
    özel bir konudur ve kursumuzun kapsamı dışındadır. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    assert İngilizce test bağlamında "iddia etmek", "ileri sürmek" gibi bir anlama gelmektedir. assert deyiminin genel biçimi şöyledir:

    assert <ifade> [, <ifade (string)>]

    assert anahtar sözcüğünün yanında doğru ya da yanlış olabilen bir ifade bulunması gerekir. Bu ifade bir iddia belirtmektedir. 
    Eğer iddia doğruysa akış normal olarak devam eder. Ancak iddia yanlışsa "AssertionError" isimli bir exception oluşur. Örneğin:

    def foo(a):
        assert a > 0
        print(a)

    Burada foo fonksiyonunun içerisinde "parametrenin sıfırdan büyük olduğu iddiası" vardır. Eğer bu iddia doğru ise bir sorun oluşmaz, 
    akış devam eder. Eğer iddia yanlış ise AssertionError isimli exception oluşacaktır. Örneğin:

    foo(10)         # iddia doğru, bir şey olmaz
    foo(-10)        # iddia geçersiz! exception oluşur

    Peki assert gibi bir deyime gerçekten gereksinim var mıdır? Biz aynı etkiyi kendimiz if deyimiyle oluşturamaz mıydık?

    def foo(a):
        if not a > 0:
            raise AssertionError
        print(a)

    İşte buradaki kod yukarıdaki ile eş anlamlı gibi gözükse de aslında başka önemli bir nokta daha vardır. Bir Python programı
    çalıştırılırken eğer "-O seçeneği" kullanılırsa program içerisindeki tüm assert deyimleri yorumlayıcı tarafından sanki yokmuş 
    gibi koddan kaldırılmaktadır. Başka bir deyişle -O ile Python programını çalıştırdığımızda assert deyimleri görmezden gelinmektedir. 
    Böylece biz performans gerekçesiyle tüm assert işlemlerinden basit bir biçimde kurtulabiliriz. Eğer aynı kontrolleri if ile yapsaydık 
    -O komut saırı argümanı ile bu if'lerden kurtulamazdık. Örneğin:

    # sample.py 

    def foo(a):
        assert a > 0
        print(a)

    foo(-10)

    Burada normal bir çalışmada AssertionError oluşacaktır. Ancak komut satırından programı aşağıdaki gibi çalıştırdığımızda exception 
    oluşmayacaktır:

    python -O sample.py

    Çünkü bu durumda Python yorumlayıcıları assert deyimleri sanki kodda yokmuş gibi kodu çalıştırmaktadır.    
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Bir program için iki versiyonun bulunduğunu varsayabiliriz: Debug ve Release (Production) versiyonları. Programın debug versiyonu
    programı geliştirirken nihai üründe gerekmeyen birtakım test kontrolleri içeren versiyonlarıdır. Programcı geliştirmesini debug
    versiyonunda yapmaktadır. Release versiyonu ise hatasız olduğuna inanılan programın gereksiz test kontrollerinden arındırılmış 
    biçimidir. Son kullanıcılar kullanıcılar programın release versiyonunu kullanacaklardır. 

    İşte Python'da assert kontrollerinin koda dahil edildiği versiyon programın debug versiyonu -O komut satırı argümanı ile ile 
    assert kontrollerinin koddan çıkartıldığı versiyon ise release versiyonudur. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Peki assert deyiminin faydası nedir? Programcı kodunu geliştirirken pek çok yere assert deyimi sayesinde sanki gereksiz gerekebilecek
    iddialar yerleştirir. Eğer bu iddialar doğrulanmazsa programcı birtakım şeylerin ters gittiğini düşünüp yapmış olduğu bug hakkında 
    bir ipucu elde eder. Eğer geliştirme sırasında hiç AssertionError oluşmazsa bu durumda kodun sağlam olduğunu düşünür ancak bu
    gereksiz kontrollerden kodunu arındırmak için programını -O seçeneği ile çalıştırır. Yani başka bir deyişle aslında kodu 
    geliştirirken assert deyimlerini kullanır ancak çalıştırırken bu assert deyimlerini -O seneği ile koddan kaldırır. 

    Programcı kodunu geliştirirken saçma gibi gözükse bile pek çok yere assert deyimlerini yereştirir. Böylece eğer testler sırasında 
    AssertionError oluşursa bir "bug" olduğunu anlar ve bir ipucu elde ederek bug'ı düzeltir. Ancak assert deyimlerini koddan hiç 
    çıkartmaz. Çünkü buna gerek yoktur. Zaten programı çalıştırırken -O seçeneği ile tek hamlede bu gereksiz assert deyimlerinden 
    kullanıcı kurtulmaktadır. Örneğin çerçeve çizen bir fonksiyonu yazıp kodun çeşitli yerlerinden çağıran programcı parametreler 
    üzerinde iddialarda bulunabilir. Böylece kodunun başka yerlerinde bu fonksiyonu yanlış parametrelerle çağırdığını geliştirme 
    aşamasında anlayabilir:

    def draw_rect(x1, y1, x2, y2):
        assert x1 < x2
        assert y1 < y2
        assert x1 >= 0 and x2 >= 0 and y1 >= 0 and y2 >= 0
        
        print('çerçeve çiziliyor')
   
    Bu fonksiyonda x1, y1 çerçevenin sol üst köşe koordinatlarını x2, y2 ise sağ alt köşe koordinatlarını belirtmektedir. Eğer biz 
    kodumuzda bu fonksiyonu kullanırken ona yanlışlıkla hatalı argümanlar geçmişsek kodu geliştirirken bunu assert deyimleri sayesinde 
    anlayabiliriz. Ancak bu kontroller sağlam çalışan bir program için gereksizdir. İşte program -O komut satırı argümanıyla çalıştırıldığında
    artık bu gereksiz kontroller koddan atılmış olacaktır. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki genel biçimden de görüldüğü gibi assert deyiminde iddianın yanına virgül atomu ile başka bir ifade de yerleştirilebilir. 
    Bu ifade genellikle bir string olur. Bu string AssertionError sınıf nesnesine argüman olarak geçirilmektedir. Yani buradaki yazı 
    kod assert işlemine takıldığında ekranda görüntülenecek olan mesajı belirtmektedir. Örneğin:

    def foo(a):
        assert a > 0, 'paramter must be positive'
        print(a)

    foo(-10)

    Bu kod çalıştırıldığında aşağıdaki gibi bir exception mesajı verilecektir:
    
    AssertionError: paramter must be positive
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi assert deyimi programın debug versiyonunda devreye giren ancak release versiyonunda devreye girmeyen 
    kontrollerin oluşturulması için kullanılmaktadır. Eğer programcı her zaman kontrolün çalıştırılmasını istiyorsa bunu assert deyimi 
    ile değil manuel biçimde if deyimleriyle yapmalıdır. 

    Ayrıca Python'da assert deyimlerinden kurtulmak için -O seçeneğinin yanı sıra PYTHONOPTIMIZE isimli bir çevre değişkeni de kullanılabilmektedir. 
    Bu çevre değişkenine herhangi bir yazı kaşı getirilirse artık Python yorumlayıcıları sanki kod -O seçeneği ile çalıştırılıyormuş 
    gibi davranmaktadır. Örneğin Windows sistemlerinde komut atırında bu işlemi şöyle yapabilirsiniz:

    C:\Python>set PYTHONOPTIMIZE=optimize
    C:\Python>python sample.py

    UNIX/Linux ve macOS sistemlerinde de aynı işlem şöyle yapılabilir:

    $ export PYTHONOPTIMIZE=optimize
    $ python sample.py

    Burada PYTHONOPTIMIZE çevre değişkenine hangi yazının atanacağının bir önemi yoktur. Önemli olan bu anahtara ilişkin bir çevre 
    değişkeninin bulunyor olmasıdır. 

    Bu çevre değişkeni açılan terminale ilişkindir. Dolayısıyla terminal kapatıldığında bu etki de ortadan kaldırılacaktır. Ancak 
    terminal kapatılmadan etkinin ortadan kaldırılması için bu çevre değişkenine atanan değerin yok edilmesi gerekir. Bu işlem Windows'ta
    şöyle yapılmaktadır:

    set PYTHONOPTIMIZE=

    Aynı işlem UNIX/Linux ve macOS sistemlerinde de şöyle yapılmaktadır:

    PYTHONOPTIMIZE=

    Çevre değişkenlerinin nasıl kalıcı hale getirilebileceğine Python kurslarında değinmiştik. Anımsayacağınız gibi Windows'ta bu 
    işlem "Gelişmiş Sistem ayarları / Ortam Değişkenleri" menüsüyle, Linux ve macOS sistemlerinde ise kullanılan 
    kabul programına göre onların start-up script dosyaları yoluyla yapılıyordu. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Python'da "tür açıklamaları (type annotation)" ve assert deyiminin dışında test süreci için en kapsamlı araçlar "unittest" modülü
    içerisindeki birim testine (unittesting) yönelik hazırlanmış mekanizmalardır. Burada birim testlerinin Python'da nasıl yapıldığını 
    açıklayacağız.

    Birim testleri son 20 yıldır yaygın kullanılan test mekanizmalarındandır. Buradaki "birim (unit)" kodu oluşturan küçük parçaları 
    anlatmaktadır. Bu küçük parçalar da genellikle fonksiyonlar ve metotlar biçiminde karşımıza çıkmaktadır. Birim testlerinde programcı
    çeşitli "test durumları (test cases)" oluşturarak kendi yazdığı kodu kendisi kodla test etmektedir. Ancak bu test işlemi geliştirme 
    işlemini sekteye uğratmayacak biçimde özel birim testi mekanizmalarıyla yapılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Birim testleri için Python'un standart kütüphanesinde "unittest" isimli bir modül bulundurulmuştur. Programcı test işlemleri için 
    "test durumları (test cases)" oluşturur. Test durumları unittest.TestCase isimli bir sınıftan türetilen sınıflar biçiminde 
    oluşturulmaktadır. Örneğin:

    class MyTestCase(unittest.TestCase):
        pass

    Yapılacak testler bu sınıfın metotları biçiminde oluşturulmaktadır. Ancak sınıfın tüm metotları test metodu olmak zorunda değildir. 
    Test metotları "test" önekiyle başlatılarak (tipik olarak test_xxxx biçiminde) isimlendirilmelidir. Örneğin:

    class MyTestCase(unittest.TestCase):
        def test_max(self):
            pass
        
        def test_sort(self):
            pass

        def foo(self):
            pass
        
    Nu örnekte başı "test" öneki ile başlayan test_max ve test_sort test fonksiyonları programcı tarafından belirlenen testi yapmak üzere
    yazılmalıdır. Eğer tets kodları uzun sürerse programcı sınıfa başı "test" ile başlamayan (örneğimizdeki foo gibi) yardımcı metotlar 
    da yerleştirilebilir. Bu tardımcı metotları test metotlarından çağırabilir. Bizim unittest.TestCase sınıfından türeterek oluşturduğumuz 
    sınıftaki başı "test" ile başlayan metotlara "test" ya da "test metotları" denilmektedir. Bir TestCase içerisinde istenildiği kadar 
    test bulundurulabilir. 

    unittest modülü içerisindeki fonksiyon ve metot isimlerinde "deve notasyonu (camel casting)" kullanılmıştır. Bir testin doğruluğu 
    için aşağıdaki assert metotları bulundurulmuştur. Bu metotlar TestCase sınıfının metotlarıdır. Dolayısıyla test metotları içerisinde 
    self ile çağrılmalıdır:

    assertEqual(a, b)
    assertNotEqual(a, b)
    assertTrue(x)
    assertFalse(x)
    assertIs(a, b)
    assertIsNot(a, b)
    assertIsNone(x)
    assertIsNotNone(x)
    assertIn(a, b)
    assertNotIn(a, b)
    assertIsInstance(a, b)
    assertNotIsInstance(a, b)
    assertAlmostEqual(a, b)
    assertNotAlmostEqual(a, b)
    assertGreater(a, b)
    assertGreaterEqual(a, b)
    assertLess(a, b)
    assertLessEqual(a, b)
    assertRegex(s, r)
    assertNotRegex(s, r)
    assertCountEqual(a, b)
    assertMultiLineEqual(a, b)
    assertSequenceEqual(a, b)
    assertListEqual(a, b)
    assertTupleEqual(a, b)
    assertSetEqual(a, b)
    assertDictEqual(a, b)
    assertRaises(exception, callable, *args, **kwds)
    ...

    assert metotlarının tam listesini "Python Standard Library" dokümanlarından elde edebilirisiniz. 

    Programcı test fonksiyonlarının içerisinde testlerini yukarıdaki assert metotlarını kullanarak yapar. En sonunda test durumlarını
    (test cases) çalıştırmak için unittest modülündeki main fonksiyonunu çalıştırır. Bu main fonksiyonu unitest.TestCase sınıflarından 
    türetilmiş tüm test durum sınıflarını belirler ve onların "test" ismi ile başlayan metotlarını çağırır. Test metotlardaki assert 
    çağrılarında belirtilen iddia yanlış ise bu durumda ilgili test "hatalı (fail)" ilan edilir. 
    
    unittest.main main fonksiyonu bütün testlerin sonuçlarına ilişkin bir rapor çıkarmaktadır. Programcı da bu raporu inceleyerek 
    testlerin neden başarısız olduğunu araştırır ve kodundaki hataları düzeltir.

    Bir test fonksiyonu içerisinde birden fazla assert metodu kullanılabilir. Bunlardan biri başarısız olursa test orada sonlandırılmaktadır. 
    Yani test raporu tüm assert'lere bakılarak verilmez. İlk başarısız olan assert işleminde test fonksiyonu başarısız ilan edilmektedir. 
    Örneğin bir dolaşılabir nesnedeki en büyük elemanı bulan bir getmax fonksiyonunu aşağıdaki gibi yazmış olalım:

    def getmax(a):
        iterator = iter(a)
        maxval = next(iterator)
        
        for x in iterator:
            if x > maxval:
                maxval = x
        return maxval

    Bu fonksiyonu nasıl test edebiliriz? Önce bazı tuhaf durumlar için sınama yapabiliriz. Sonra built-in max fonksiyonunu referans alarak 
    rastegele listelerle fonksiyonumuzu test edebiliriz. Örneğin:

    class MyTestCase(unittest.TestCase):
        def test_max(self):
            a = [4, 5, 2, 8, 4]
            self.assertEqual(getmax(a), 8)
            
            a = [10, 9, 8, 7, 6, 1 ]
            self.assertEqual(getmax(a), 10)
            
            a = [1, 1, 1, 1, 1]
            self.assertEqual(getmax(a), 1)
            
            a = [10]
            self.assertEqual(getmax(a), 10)
            
            for _ in range(1000):
                a = [random.randint(9, 1000) for _ in range(100)]
                self.assertEqual(max(a), getmax(a))
                
    Testler çalıştırmak için unittest.main fonksiyonunu çağırabiliriz:

    unittest.main()

    Birim testi yaparken test senaryolarını düzgün bir biçimde oluşturmalısınız. Tüm test senaryolarını baştan bir dokümana yazıp 
    sonra koda dökebilirsiniz. Bir kodu test ederken sağlam çalıştığına güvendiğiniz başka fonksiyınlardan ve sınıflardan faydalanabilirsiniz. 

    Biz yukarıda hep TestCase sınıfının assertEqual metodunu kullandık. Gerçekten de en çok kullanılan metot assertEqual metodudur. 
    Ancak örneğin bir test durumunda normal davranışın bir exception  oluşturacağı biliyor olabiliriz. Biz de bu durumu assertRaises 
    metodu ile sınayabiliriz. Bu metodun birinci parametresi oluşması beklenen Exception sınıfının ismini (yani type nesnesini), ikinci
    parametresi ise çağrılabilir bir nesneyi (tipik olarak bir fonksiyon ya da metot) parametre olarak almaktadır. Diğer parametreler 
    bu çağrılabilir nesnenin çağrılmasında kullanılacak argümanları belirtmektedir. Bu fonksiyonun iddiası ikinci parametreyle 
    belirtilen çağrılabilir nesne çağrıldığında oluşan exception'ın birinci parametresiyle belirtilen sınıf türünden bir except bloğu 
    bloğu tarafından yakalanabileceğidir." Örneğin getmax fonksiyonunu biz boş bir listeyle çağırırsak fonksiyon exception oluşmalıdır. 
    Birim test fonksiyonunda bu durumu şöyle sınayabiliriz:

    a = []
    self.assertRaises(Exception, getmax, a)

    Python projelerinde projeyi oluşturan ana kodlarla test kodlarını birbirinden ayırmalısınız. Genellikle projenin birim test kodları 
    proje dizininde "test" isimli bir dizin içerisinde bulundurulmaktadır. 
    
    Aşağdıda getmax ve bsort fonksiyonları için birim testine yönelik bir örnek verilmiştir. Örneğimizde "sample.py" ve "test.py" 
    isimli iki dosya bulunmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------

# sample.py

def getmax(a):
    iterator = iter(a)
    maxval = next(iterator)
    
    for x in iterator:
        if x > maxval:
            maxval = x
    return maxval

def bsort(a):
    for i in range(len(a) - 1):
        for k in range(len(a) - 1 - i):
            if a[k] > a[k + 1]:
                a[k], a[k + 1] = a[k + 1], a[k]

# test.py

import unittest
import copy
import random
import sample

class MyTestCase(unittest.TestCase):
    def test_max(self):
        a = [4, 5, 2, 8, 4]
        self.assertEqual(sample.getmax(a), 8)
        
        a = [10, 9, 8, 7, 6, 1 ]
        self.assertEqual(sample.getmax(a), 10)
        
        a = [-3, -6, -8, -2, -9]
        self.assertEqual(sample.getmax(a), -2)
        
        a = [1, 1, 1, 1, 1]
        self.assertEqual(sample.getmax(a), 1)
        
        a = [10]
        self.assertEqual(sample.getmax(a), 10)
        
        a = []
        self.assertRaises(Exception, sample.getmax)
                
        for _ in range(1000):
            a = [random.randint(9, 1000) for _ in range(100)]
            self.assertEqual(max(a), sample.getmax(a))
            
        self.assertEqual(sample.getmax((x for x in range(100))), 99)
        
    def test_bsort(self):
        a = [5, 4, 3, 2, 1]
        sample.bsort(a)
        self.assertEqual(a, [1, 2, 3, 4, 5])
        
        a = [-1, -2, -3, -4, -5]
        sample.bsort(a)
        self.assertEqual(a, [-5, -4, -3, -2, -1])
        
        a = []
        sample.bsort(a)
        self.assertEqual(a, [])
        
        a = [-5]
        sample.bsort(a)
        self.assertEqual(a, [-5])
                
        for _ in range(10000):
            a = random.sample(range(100000), 100)
            b = copy.copy(a)
            sample.bsort(a)
            b.sort()
            self.assertEqual(a, b)
                                 
unittest.main()

#------------------------------------------------------------------------------------------------------------------------------------
    unittest modülündeki main fonksiyonunu argümansız çağırırsak tüm test durum sınıflarındaki ismi "test" ile başlayan metotlar
    çalıştırılmaktadır. Ancak bazen biz belli test sınıflarının metotların çalıştırılmasını isteyebiliriz. Bunun için main fonksiyonunun 
    defaultTest parametresine ilgili TestCase sınıfının ismi girilebilir. Örneğin:

    unittest.main(defaultTest='MyTestCase')

    Birden fazla test durumlarını çalıştırabilmek için ise defaultTest parametresi test durum sınıflarının isimlerini içeren dolaşılabilir 
    bir nesne biçiminde girilmelidir. Örneğin:

    unittest.main(defaultTest=['SortTestCase', 'MaxTestCase'])

    Benzer biçimde main fonksiyonu türettiğimiz TestCase sınıfının belli bir  sınıfının belli bir test fonksiyonunu da çalıştırabilir. Bunun 
    için yazısal biçimde test sınıfı ve nokta ile test metodu belirtilmelidir. Örneğin:

    unittest.main(defaultTest='MyTestCase.test_max')

    Benzer biçimde yine birden fazla metot da dolaşılabilir bir nesne ile belirtilebilmektedir. Örneğin:

    unittest.main(defaultTest=['MaxTestCase.test_getmax', 'SortTestCase.test_sort'])

    unittest modülündeki main fonksiyonu her test metodu için ilgili TestCase sınıfınından ayrı bir nesne yaratmaktadır.
#------------------------------------------------------------------------------------------------------------------------------------
    
import unittest
import copy
import random
import sample

class MaxTestCase(unittest.TestCase):
    def test_max(self):
        a = [4, 5, 2, 8, 4]
        self.assertEqual(sample.getmax(a), 8)
        
        a = [10, 9, 8, 7, 6, 1 ]
        self.assertEqual(sample.getmax(a), 10)
        
        a = [-3, -6, -8, -2, -9]
        self.assertEqual(sample.getmax(a), -2)
        
        a = [1, 1, 1, 1, 1]
        self.assertEqual(sample.getmax(a), 1)
        
        a = [10]
        self.assertEqual(sample.getmax(a), 10)
        
        a = []
        self.assertRaises(Exception, sample.getmax)
                
        for _ in range(1000):
            a = [random.randint(9, 1000) for _ in range(100)]
            self.assertEqual(max(a), sample.getmax(a))
            
        self.assertEqual(sample.getmax((x for x in range(100))), 99)

class SortTestCase(unittest.TestCase):
    def test_bsort(self):
        a = [5, 4, 3, 2, 1]
        sample.bsort(a)
        self.assertEqual(a, [1, 2, 3, 4, 5])
        
        a = [-1, -2, -3, -4, -5]
        sample.bsort(a)
        self.assertEqual(a, [-5, -4, -3, -2, -1])
        
        a = []
        sample.bsort(a)
        self.assertEqual(a, [])
        
        a = [-5]
        sample.bsort(a)
        self.assertEqual(a, [-5])
                
        for _ in range(10000):
            a = random.sample(range(100000), 100)
            b = copy.copy(a)
            sample.bsort(a)
            b.sort()
            self.assertEqual(a, b)
                                 
unittest.main(defaultTest=['MaxTestCase', 'SortTestCase'])

#------------------------------------------------------------------------------------------------------------------------------------
    Bazen test metotlarından önce birtakım hazırlık işlemlerinin yapılması gerekebilmektedir. Bunun için her test metodu çağrılmadan 
    önce otomatik olarak TestCase sınıfının setUp isimli metodu çağrılmaktadır. Programcı da bu setUp metodunu override ederek test 
    öncesinde yapılması gereken bazı hazırlık işlemlerini yapabilir. Programcı her test fonksiyonundan önce değil de toplamda bir 
    kez hazırlık işlemi yapacaksa bu durumda setUpClass metodunu kullanmalıdır. setUpClas metodu bir sınıf metodudur. Örneğin:

    class MyTestCase(unittest.TestCase):
        def test_max(self):
            a = [4, 5, 2, 8, 4]
            self.assertEqual(sample.getmax(a), 8)
            
            a = [10, 9, 8, 7, 6, 1 ]
            self.assertEqual(sample.getmax(a), 10)
            
            a = [-3, -6, -8, -2, -9]
            self.assertEqual(sample.getmax(a), -2)
            
            a = [1, 1, 1, 1, 1]
            self.assertEqual(sample.getmax(a), 1)
            
            a = [10]
            self.assertEqual(sample.getmax(a), 10)
            
            a = []
            self.assertRaises(Exception, sample.getmax)
                    
            for _ in range(1000):
                a = [random.randint(9, 1000) for _ in range(100)]
                self.assertEqual(max(a), sample.getmax(a))
                
            self.assertEqual(sample.getmax((x for x in range(100))), 99)
            
        def test_bsort(self):
            a = [5, 4, 3, 2, 1]
            sample.bsort(a)
            self.assertEqual(a, [1, 2, 3, 4, 5])
            
            a = [-1, -2, -3, -4, -5]
            sample.bsort(a)
            self.assertEqual(a, [-5, -4, -3, -2, -1])
            
            a = []
            sample.bsort(a)
            self.assertEqual(a, [])
            
            a = [-5]
            sample.bsort(a)
            self.assertEqual(a, [-5])
                    
            for _ in range(10000):
                a = random.sample(range(100000), 100)
                b = copy.copy(a)
                sample.bsort(a)
                b.sort()
                self.assertEqual(a, b)
        
        def setUp(self):
            random.seed(12345)
            
        @classmethod
        def setUpClass(cls):
            print('setUpClass called...')
        
    Burada setUpClass metodu test işlemlerinden önce toplamda bir kez, setUp metodu ise her test metodu için test metodu çalıştırılmadan 
    önce bir kez çağrılmaktadır. 

    Eğer programcı sınıfın __init__ metodu iiçerisinde birtakım hazırlık işlemlerini yapmak istiyorsa bu durumda __init__ metodu için 
    *args ve **kwargs parametrelerini girmeli ve taban sınıfın __init__ metodunu bu parametrelerle *'lı bir biçimde çağırmalıdır. 
    Örneğin: 
    
    class MaxTestCase(unittest.TestCase):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            # ....

    Python Python birim testlerinde test durum sınıflarına __init__ metodu yoluyla parametre geçilememektedir. Bunun için yine 
    setUp metodu kullanılmaktadır. Tabii setUp metodunda da biz parametre bulundurmayız. Bu işlemler ancak setUp ve setUpClass 
    metotlarında bu işlemler biraz dolaylı olarak yapılabilmektedir. 
    
    Aşağıdaki örnekte __init__ metodu içerisinde bir count değeri belirlenmiş ve bu değer test metotları tarafından kullanılmıştır. 
    setUp metodunda da rassal sayı üreticisine her defasında aynı tohum değer verilmiştir. 
 #------------------------------------------------------------------------------------------------------------------------------------
    
# sample.py 

def getmax(a):
    iterator = iter(a)
    maxval = next(iterator)
    
    for x in iterator:
        if x > maxval:
            maxval = x
    return maxval

def bsort(a):
    for i in range(len(a) - 1):
        for k in range(len(a) - 1 - i):
            if a[k] > a[k + 1]:
                a[k], a[k + 1] = a[k + 1], a[k]

# test.py

import unittest
import copy
import random
import sample

class MyTestCase(unittest.TestCase):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.count = 1000
        
    def test_max(self):
        a = [4, 5, 2, 8, 4]
        self.assertEqual(sample.getmax(a), 8)
        
        a = [10, 9, 8, 7, 6, 1 ]
        self.assertEqual(sample.getmax(a), 10)
        
        a = [-3, -6, -8, -2, -9]
        self.assertEqual(sample.getmax(a), -2)
        
        a = [1, 1, 1, 1, 1]
        self.assertEqual(sample.getmax(a), 1)
        
        a = [10]
        self.assertEqual(sample.getmax(a), 10)
        
        a = []
        self.assertRaises(Exception, sample.getmax)
                
        for _ in range(self.count):
            a = [random.randint(9, 1000) for _ in range(100)]
            self.assertEqual(max(a), sample.getmax(a))
            
        self.assertEqual(sample.getmax((x for x in range(100))), 99)
        
    def test_bsort(self):
         a = [5, 4, 3, 2, 1]
         sample.bsort(a)
         self.assertEqual(a, [1, 2, 3, 4, 5])
         
         a = [-1, -2, -3, -4, -5]
         sample.bsort(a)
         self.assertEqual(a, [-5, -4, -3, -2, -1])
         
         a = []
         sample.bsort(a)
         self.assertEqual(a, [])
         
         a = [-5]
         sample.bsort(a)
         self.assertEqual(a, [-5])
                 
         for _ in range(self.count):
             a = random.sample(range(100000), 100)
             b = copy.copy(a)
             sample.bsort(a)
             b.sort()
             self.assertEqual(a, b)
    
    def setUp(self):
        random.seed(12345)
        
    @classmethod
    def setUpClass(cls):
        print('setUpClass called...')
                                 
unittest.main()

#------------------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi projelerde test kodlarının gerçek kodlarla aynı dosyada bulundurulması iyi bir teknik değildir. 
    Genellikle programcı test kodlarını asıl kodlardan ayırmaktadır. Örneğin projemzin ismi "Project" olmak üzere biz projemizin tüm 
    kodlarını bir dizinde toplayabiliriz. Bu dizinde Src ve Test isimli iki dizin oluşturabiliriz. Asıl kodlarımızı "src" dizininin 
    içerisinde test kodlarınızı ise "Test" dizininin içerisinde bulundurabiliriz:

    Project 
        Src
        Test

    Tabii burada "Test" dizininin içerisindeki test modüllerinin src dizinindeki test edilecek modülleri import ederek kullanması 
    gerekir. 

    Aşağıdaki örnekte Test dizini içeriside test.py ve test.csv dosyaları bulundurulmuştur. Src dizinin içerisinde de mymax ve mysort 
    fonksiyonlarının bulunduğu bir util.py dosyası vardır:

      Project 
        Src
            util.py
        Test
            test.py
            test.csv

#------------------------------------------------------------------------------------------------------------------------------------

# Proejct/Src/util.py

def mymax(iterable):
    it = iter(iterable)  # iterable.__iter__()
    try:
        mval = next(it)
    except:
        raise ValueError('maxval() arg is an empty sequence')
    for x in it:
        if x > mval:
            mval = x
            
    return mval

def mysort(a):
    for i in range(len(a) - 1):
        for k in range(len(a) - i - 1):
            if a[k] > a[k + 1]:
                a[k], a[k + 1] = a[k + 1], a[k]
        
# Project/Test/test.py

import sys

sys.path.append('../src')
import util

import unittest
import random
import copy
import csv
                
class MyTestCase(unittest.TestCase):
    def __init__(self, *args):
        super().__init__(*args)
        self.count = 1000000
        
    def setUp(self):
        random.seed(12345)
        self.f = open('test.csv')
        
    def tearDown(self):
        self.f.close()
    
    def test_max(self):
        for _ in range(self.count):
            a = random.sample(range(1000), 10)
            self.assertEqual(max(a), util.mymax(a))
            
        a = [[int(c) for c in line] for line in csv.reader(self.f)]
        self.assertEqual(max(a), util.mymax(a))
            
    def test_sort(self):
        for _ in range(self.count):
            a = random.sample(range(1000), 10)
            b = copy.copy(a)
            a.sort()
            util.mysort(b) 
          
            self.assertEqual(a, b)
            
        a = [[int(c) for c in line] for line in csv.reader(self.f)]
        self.assertEqual(max(a), util.mymax(a))

    unittest.main()

    BURADA KALDIK
#------------------------------------------------------------------------------------------------------------------------------------
    Python'un standart kütüphanesindeki modüller (yani .py dosyaları) bilindiği gibi birtakım faydalı fonksiyonları ve sınıfları bulundurmaktadır. 
    Ancak bu modüllerin bazıları aynı zamanda bir program gibi de çalıştırılabilmektedir. Yani bu modüllerin bazıları hem bir kütüphane gibi 
    kullanılmakta hem de bir program gibi çalıştırılmaktadır. Tabii bu modüllerdeki programlar bu modülleri yazanlar tarafından aşağıdaki 
    gibi bir kontrolle çalıştırılmıştır:

    # söz konusu modül
    ...
    ...
    ...
    if __name__ == '__main__:
        ....

    Mademki bazı kütüphane modülleri aynı zamanda birer program gibi çalıştırılabilmektedir. Peki onları program gibi nasıl çalıştırabiliriz?
    Öncelikle çalıştırma için modüle ilişkin .py dosyalarının nerede olduğunu bilmemiz gerekir. Kurulum programı Python'ı kurarken bunları 
    bazı dizinlerin içerisine çekmektedir. Her ne kadar bunların yerlerini biz bulabilirsek de buradaki programları bu yöntemle çalıştırmak 
    zahmetlidir. Mademki Python yorumlayıcısı zaten bunların yerlerini bilmektedir. O halde bizim Python yorumlayıcısına bunu bildirmemiz 
    yeterli olacaktır. Bu işlem de Python yorumlayıcısının komut satırında -m seçeneği ile yapılmaktadır. Örneğin:
    
    python -m <modül_ismi> [argüman_listesi]

    Burada -m ve modül isminden sonraki komut satırı argümanları doğrudan bu modül programına komut satırı argümanı olarak aktarılır. 
    Özetle eğer biz Python'un standart kütüphanesindeki bir modülde bulunan programı -m seçeneği ile çalıştırırız.     
#------------------------------------------------------------------------------------------------------------------------------------
  
#------------------------------------------------------------------------------------------------------------------------------------
    unittest modülü de hem bir kütüphane hem de bir program gibi davranmaktadır. unitest modülüne yerleştirilmiş olan program aslında 
    unittest.main fonksiyonunu çağırmaktadır. Bu durumda biz istersek unit test işlemlerini komut satırından da yapabiliriz. 

    Aşağıdaki örnekte test.py içerisinden unittest.main çağrısı kaldırılmıştır. Artık test kodu aşağıdaki gibi komut satırından da 
    çalıştırılabilir:

    python -m unittest test

    Alında çalıştırma sırasında modüldeki belli bir test case ya da test case içerisindeki belli bir test metodu da belirtilebilir. Örneğin:

    python -m unittest test.MyTestCase
    python -m unittest test.MyTestCase.test_max

#------------------------------------------------------------------------------------------------------------------------------------

import sys

sys.path.append('../src')
import util

import unittest
import random
import copy
import csv
                
class MyTestCase(unittest.TestCase):
    def __init__(self, *args):
        super().__init__(*args)
        self.count = 1000000
        
    def setUp(self):
        random.seed(12345)
        self.f = open('test.csv')
        
    def tearDown(self):
        self.f.close()
     
    def test_max(self):
        for _ in range(self.count):
            a = random.sample(range(1000), 10)
            self.assertEqual(max(a), util.mymax(a))
            
        a = [[int(c) for c in line] for line in csv.reader(self.f)]
        self.assertEqual(max(a), util.mymax(a))
            
    def test_sort(self):
        for _ in range(self.count):
            a = random.sample(range(1000), 10)
            b = copy.copy(a)
            a.sort()
            util.mysort(b) 
          
            self.assertEqual(a, b)
            
        a = [[int(c) for c in line] for line in csv.reader(self.f)]
        self.assertEqual(max(a), util.mymax(a))

#------------------------------------------------------------------------------------------------------------------------------------
    Üçüncü parti kütüphaneler ve paketler ve programlar başka kütüphanelere ve paketlere bağımlı olabilirler. Çünkü programcılar başka 
    kütüphanelerden faydalanıp kendi kütüphanelerini ve programlarını yazmaktadır. Üstelik programcılar kendi kütüphanelerini ya da 
    programlarını yazarken başka kütüphanelerin belli versiyonlarını kullanmış olabilirler. Kütüphanelerin yeni versiyonları çıktıkça bunlar 
    eskiye doğru uyumu oratadan kaldırabilmektedir. Yani bazen bir kütüphanenin yeni versiyonu eski versiyonu gibi kullanılamamaktadır. 
    Bu durumda biz üçüncü parti bir kütüphaneyi ya da paketi yüklediğimizde o paket kendi kullandığı kütüphanelerin son versiyonunu yükleyecektir. 
    Bu da paketin çalışmasını olumsuz yönde etkileyebilecektir. Örneğin bir makine öğrenmesi programı Tensorflow isimli kütüphanenin 1'li 
    versiyonu kullanıalrak yazılmış olabilirken diğer bir program 2'li TensorFlow kütüphanesinin 2'li versiyonları kullanılarak yazılmış 
    olabilir. Biz aynı makineye bu iki versiyonu birlikte yükleyemeyiz. Değişik kütüphanelerin ve programların değişik kütüphane versiyonlarını 
    kullanması önemli bir sıkıntıdır. Peki bu sıkıntıyı giderebilmek için ne yapabiliriz? İşte bunun için Python dünyasında "sanal ortam 
    (virtual envirionment)" denilen bir kavram oluşturulmuştur. 

    Sanal ortam (virtual environment) adeta makinemizdeki ayrı bir python kurulumu gibi etki oluşturmaktadır. Her sanal ortam ayrı bir 
    Python kurulumu temsil ettiği için birinde pip programı ile yüklenen paket ona özgü olmaktadır. Her sanal ortam birbirlerinden 
    izole edilmiştir. Örneğin biz bir samal ortama Python yorumlayıcısının 3.5 sürümünü, TensorFlow kütüphanesinin 1.4 sürümünü yükleyebiliriz. 
    Diğer bir sanal ortama ise Python yorumlayıcısının 3.10 sürümünü, TensorFlow kütüphanesinin ise 2.1 sürümünü yükleyebiliriz. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir sanal ortam yaratmak için standart kütüphanedeki venv modülü kullanılmaktadır. Bu modül bir program gibi de çalıştırılabilmektedir. 
    Sanal ortam yaratmanın tipik biçimi şöyledir:

    python -m venv <sanal_ortamın_ismi>

    Sanal ortam oluşturulduğunda bizim vermiş olduğumuz isimle bir dizin yaratılır. Yaratılan dizinin içerisinde "include" ve "lib" dizinleri 
    bulunur. Ayrıca Windows sistemlerinde "Scripts" isimli bir dizin UNIX/Linux ve macOS sistemlerinde "bin" isimli bir dizin daha vardır. 
    "Scripts" ya da "bin" dizinlerinin içerisinde "activate" ve "deactivate" isimli iki shell script bulunmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Sanal ortamı Windows'ta aktive etmek "Scripts" dizinine geçilip  "activate" scriptinin çalıştırılması gerekmektedir. Bunun için cd 
    komutunu kullanabilirsiniz. Dizine geçtikten sonra doğrudan komut satırından "activate" yazıp ENTER tuşuna basabilirsiniz.  Örneğin:

    C:\Users\kaanaslan\Study\Python-App>python -m venv myenv

    C:\Users\kaanaslan\Study\Python-App>cd myenv

    C:\Users\kaanaslan\Study\Python-App\myenv>dir
    Volume in drive C has no label.
    Volume Serial Number is 8E44-2FDB

    Directory of C:\Users\kaanaslan\Study\Python-App\myenv

    09.09.2022  20:27    <DIR>          .
    09.09.2022  20:27    <DIR>          ..
    09.09.2022  20:27    <DIR>          Include
    09.09.2022  20:27    <DIR>          Lib
    09.09.2022  20:27                92 pyvenv.cfg
    09.09.2022  20:27    <DIR>          Scripts
                1 File(s)             92 bytes
                5 Dir(s)  165.163.900.928 bytes free

    C:\Users\kaanaslan\Study\Python-App\myenv>cd Scripts

    C:\Users\kaanaslan\Study\Python-App\myenv\Scripts>activate

    (myenv) C:\Users\kaanaslan\Study\Python-App\myenv\Scripts>

    Sanal ortamın aktive edildiği prompt'taki en soldaki parantezden belli olmaktadır. Bu parantezin içerisinde sanal ortamın isminin
    bulunduğuna dikkat ediniz. Aslında bu dizin ile isim farklı da olabilmektedir. Bunun için sanal ortam yaratılırken --prompt <isim> 
    argümanı kullanılmalıdır. Örneğin:

    python -m venv myenv --prompt csd
        
    Windows'ta sanal ortamı deactivate etmek için herhangi bir yerde "deactivate" yazılıp ENTER tuşuna basılır. Yani "deactivacate" 
    komutu için "Scripts" dizininde olmak gerekmemektedir. Örneğin:

    (myenv) C:\Users\kaanaslan\Study\Python-App\myenv\Scripts>deactivate

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux ve macOS sistemlerinde sanal ortamı aktive etmek için "bin" dizinine geçilip "activate" scripti aşağıdaki gibi 
    çalıştırılmalıdır:

    source activate

    Örneğin:

    $ python3 -m venv myenv
    $ cd myenv
    $ ls
    bin        include        lib        pyvenv.cfg
    $ cd bin
    $ source activate
    
    Bu sistemlerde de sanal ortamı deactivate etmek için herhangi bir yerde "deactive" yazıp ENTER tuşuna basabiliriz. Örneğin:

    $ deactivate
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Bir sanal ortam oluşturup onu aktive ettiğimizde biz artık bağımısız bir Python kurulumunun içinde gibi oluruz. Dolayısıyla sanal 
    ortamımız aktive edildiğinde artık pip programı o sanal ortama install işlemi yapar. Bundan diğer sanal ortamlar ve ana kurulum 
    etkilenmez. Sanal ortamı silmek için tek yapılacak şey o dizini silmektir. Örneğin:

    c:\Users\kaanaslan\Study\Python-App\myenv\Scripts>activate

    (myenv) c:\Users\kaanaslan\Study\Python-App\myenv\Scripts>pip install numpy
    Collecting numpy
    Downloading numpy-1.23.3-cp39-cp39-win_amd64.whl (14.7 MB)
        |████████████████████████████████| 14.7 MB 6.4 MB/s
    Installing collected packages: numpy
    Successfully installed numpy-1.23.3
    WARNING: You are using pip version 21.2.3; however, version 22.2.2 is available.
    You should consider upgrading via the 'C:\Users\kaanaslan\Study\Python-App\myenv\Scripts\python.exe -m pip install --upgrade pip' command.

    Bu örnekte gördüğünüz gibi biz NumPy'ı aslında ana kuruluma değil "myenv" isimli sanal ortama kurduk. pip programı indirdiği paketleri 
    lib dizini içerisindeki "site-packages" dizinine kopyalamaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Anaconda dağıtımında sanal ortamlar GUI arayüzü ile oluşturulabilmektedir. Anaconda Navigator'da "Environments" sekmesine gelindiğinde
    O anda yaratılmış olan sanal ortamlar görüntülenmektedir. Burada biz fare ile tıklayarak bir sanal ortamı aktive edebiliriz.
    Aşağıdaki kısımda yeni bir sanal ortamı yaratıp silmek için düğmeler bulunmaktadır. Anaconda dağıtımı yükdiğinde "base(root)" isimli
    default bir sanal ortam otomatik olarak oluşturulmaktadır. Her sanal ortama Spyder IDE'sinin yeniden kurulması gerekir. 

    PyCharm da benzer bir biçimde çalışmaktadır. Biz PyCharm'da daha önce oluşturmuş olduğumuz bir sanal ortamı proje olarak açabiliriz. 
    PyCharm'da bir proje yaratılırken her zmana bir sanal ortam da yaratılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    Bir Python kurulumunda (bu bir sanal ortam da olabilir) kurulmuş bütün paketlerin versiyon listesisini elde etmek için şu komut 
    uygulanmalıdır:

    pip freeze

    Burada install edilmiş olan paketler ekrana yazdırılır. Onun bir dosyaya yazdırılmasını istiyorsanız ">" karakteriyle "io yönlendirmesi" 
    uygulamalısınız:

    pip freeze > plist.txt

    Artık biz yukarıdaki komutla o andaki python kurulumunun (bu bir sanal ortam da olabilir) install etmiş olduğu tüm paketleri versiyon 
    numaralarıyla birlikte "plist.txt" isminde bir dosyaya yerleştirmiş olduk. Artık pip programı ile bu dosyadan hareketle tün bu paketleri 
    başka bir kuruluma (bu başka kurulum bir sanal ortam da olabilir) -r seçeneği ile install edebiliriz. -r seçeneğinin yanına 
    oluşturmuş olduğumuz dosyanın yol ifadesi getirilmelidir. Örneğin:

    pip install -r plist.txt 

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Bir programı bağımsız çalıştırılabilir (executable) bir program haline getirebilmek için çeşitli üçüncü parti araçlar kullanılabilmektedir. 
    Bunlardan biri "pyinstaller" denilen araçtır. Bunun indirilip kurulması şöyle yapılabilir:

    pip install PyInstaller

    Bu biçimde kurulum yapıldığında pyinstaller Python'un standard kütüphanelerinin bulunduğu dizine kurulmaktadır. Dolayısıyla pyinstaller 
    -m seçeneği ile çalıştırılmalıdır. 

    Aslında pyinstaller programına başka alternatifler de vardır. Örneğin:

    py2exe
    PyOxidizer
    autopy2exe
    cx_freeze

    Ancak biz burada en yaygın kullanılan araç olan pyinstaller üzerinde duracağız.
    
    Artık bir Python programından "çalıştırılabilir (executable)" bir dosya elde edilebilir. Tek yapılacak şey şudur:

    python -m PyInstaller sample.py --onefile

    Eğer burada bir sorun çıkarsa --noupx seöeneğini de ekleyebilirisniz:

    python -m PyInstaller sample.py --onefile --noupx

    Burada sample.py dosyası çalıştırılmak istenen programı belirtmektedir. Tabii bir program çok fazla dosyadan oluşabilir. 
    Yani bu dosyalar import edilerek kullanılmış olabilir. Biz pyinstaller programına akışın başlatılacağı ana dosyayı veririz. 
    pyinstaller bu dosyayı inceler. Bu dosyadakilerden hareketle python yorumlayıcısı dahil olmak üzere her şeyi tek bir çalıştırılabilir
    dosyanın içerisine yerleştirir. Artık yalnızca bu dosya taşınsa bile program çalıştırılabilir. Yukarıdaki işlemden sonra bir 
    "build" bir de "dist" dizinleri oluşturulacaktır. Çalıştırılabilen program "dist" dizinin içerisine çekilir. 

    Eğer pyinstaller çalıştırılırken --onefile seçeneği girilmezse bu durumda dist dizinin içerisinde tek bir dosya değil bir grup dosya 
    yaratılır. Tabii bu dizin kopyalanırsa program çalıştırılabilir. Ancak burada tek bir dosya söz konusu değildir. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
                                                81. Ders 10/11/2023 - Cuma
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    XML (Extensible Markup Language) dokümanları kodlamak, iletmek ve yeniden oluşturmak için kullanılan genel bir doküman formatıdır. 
    XML belli bir konuya yönelik değildir. Herhangi bir konudaki verilerin kodlanması için genel kuralları içerir. Böylece biz örneğin 
    biyomedikal verilerini, veritabanı kayıtlarını, bir IDE'nin ayarlarını vs. XML kullanarak kodlayabiliriz. XML genel bir kodlama 
    formatıdır. Dolayısıyla spesifik bir alana yönelik değildir. XML yalnızca kodlamaya ilişkin kurallara sahiptir. Kodlanan içeriğin 
    ne anlama geldiğine yönelik kurallara sahip değildir. Yani birtakım verileri XML kullanarak text formatında saklayabilirisniz. 
    Ancak bunların ne anlam ifade ettiğini siz bilirsiniz. Örneğin bir IDE proje ayarlarını XML olarak bir dosyaya kaydediyor olabilir. 
    Ancak neyi nasıl kaydettiğini biz XML dosyasına bakarak anlayamayız. Onun semantiğine ilişkin dokümanları incelememeiz gerekir. 

    XML WWW Konsorsiyumu tarafından geliştirilmiştir. ECMA tarafından da standardize edilmiştir. Orijinal dokümanlara aşağıdaki bağlantıdan
    erişebilirniz:

    https://www.w3.org/TR/REC-xml/

    XML dokümanı elemanlaran oluşur. Bir eleman "başlangıç tag'ı (starting tag)" ve "bitiş tag'i (ending tag)" ile belirtilir. Başlangıç 
    ve bitiş tag'larının arasında "içerik (content)" bulunabilmektedir. Örneğin:

    <student>Ali Serçe</student>

    İçerik kısmında boşluklar bırakılırsa bu boşluklar da içeriğe dahil olmaktadır. Örneğin:

    <atasözü> üzüm üzüme baka baka kararır </atasözü>

    Burada içerik " üzüm üzüme baka baka kararır " biçimindedir. 

    Tag'lar açısal parantezler içerisinde yazılır. Bitiş tag'ında / karakteri ve başlangıç tag'ı boşuksuz biçimde bulundurulur. İçerik 
    herhangi bir biçimde oluşturulabilir. Tag isimleri tamamen dokümanı oluşturanın istediği gibi belirleyebileceği isimlerdir. 
    
    Başlangıç tag'ında istenirse "öznitelikler (attributes)" de bulundurulabilir. Öznitelikler isim="değer" biçiminde belirtilir. 
    '=' karakterinin iki yanında boşluklar bırakılabilir. Değer ise her zaman iki tırnak içerisine alınmak zorundadır. Özellikler arasında 
    istenildiği kadar SPACE, TAB ve ENTER karakteri bırakılabilir. Ancak ',' kullanılamaz. Örneğin:

    <student name="Ali Serçe" no="123">Murat Atılgan İlkokulu</student>

    Eğer eleman içeriğe sahip değilse bitiş tag'ı yazılmadan başlangıç tag'ının sonunda "/>" karakterleri ile eleman yazımı bitirilebilir. 
    Örneğin:

    <student name="Ali Serçe" no="123" />

    Yukarıdaki eleman aşağıdaki ile eşdeğerdir:

    <student name="Ali Serçe" no="123"></student>

    Başlangıç tag'ında "<" ile tag ismi bitişik yazılmalıdır. Ancak bundan sonra başlangıç tag'ını bitiren ">" karakteri öncesinde boşluklar 
    olabilmektedir. Örneğin:

    <student     >

    Bu geçerli bir başlangıç tag'ıdır. Bitiş tag'ında "/" ve isim bitişik olmak zorundadır. Ancak bitiş tag'ını bitiren ">" karakterinden önce 
    yine boşluklar olabilir. Örneğin:

    </student    >

    Bu da geçerli bir bitiş tag'ıdır. Tabii normalde uygulamacı bu gereksiz boşlukları kullanmaz. Örneğin:

    <student>content</student>

    Özellik belirtirken '=' karakterinin iki yanında boşluk bırakılabilir. Örneğin:

    <student name   =    "Ali Serçe">

    Bu yazım geçerlidir. Tabii normalde böyle bir şeyi yapmanız için gerekçeniz yoktur. 

    XML formatı hem insanlar tarafından text editörlerle hem de programlar tarafından otomatik biçimde oluşturulabilmektedir. XML dosyaları 
    genellikle prgramlar tarafından okunup parse edilerek kullanılmaktadır.

    Bir XML dosyasının başında kesinlikle XML versiyonunu belirten aşağıdaki tag bulunmak zorudadır:

    <?xml version="1.0"?>

    Şu anda XML'in son versiyonu (hala) 1.0'dır. 

    Her ne kadar XML'in henüz başka bir versiyonu olmasa da bu satırın dokümanın başında bulunması ileriye doğru uyumu korumak için 
    gereklidir. XML dokümanlarınızı "doğrulamak (validate etmek)" için çeşitli araçlar vardır. Google'da "xml validation tools" yazdığınızda 
    pek çok online araçla karşılaşacaksınız.

    Bir XML dökümanında bir tane kök eleman eleman bulunur. Bir elemanın içerik kısmında başka elemanlar bulunabilmektedir. Böylece doküman
    hiyerarşik veriler için kullanılabilir. Örneğin:

    <?xml version="1.0"?>

    <students>
        <student>Ali Serçe</student>
        <student>Kaan Aslan</student>
        <student>NEcati Ergin</student>
    </students>

    Burada kök eleman <students> elemanıdır. Bu eleman <student> elemanlarını içermektedir. Burada <student> elemanları aslında <students>
    elemanının içerik kısmındadır.
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    XML dokümanlarını parse etmek için genel olarak üç mimari kullanılmaktadır:

    1) DOM Parser Mimarisi
    2) SAX Parser Mimarisi
    3) ElementTree Mimarisi

    Hepsinin belli avantajları ve dezavantajları olmakla birlikte en çok tercih edilen ElemenTree parser'larıdır. Biz de burada bu 
    parser'ı tanıtacağız. Python'un standart kütüphanesi bu üç parser mimarisini de desteklemektedir. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    ElementTree parser'ı default durumda tüm XML dosyasını başından sonuna okur ve ondan sonra işleme sokar. Ancak bu modül bloke olmadan 
    parça parça işlem yapabilme yeteneğine de sahiptir. Bu parser Python'un standart kütüphanesinde xml.etree modülünde bulunmaktadır. 

    ElemenTree praser'ını kullanmak için önce ElemenTree sınfını from import ile import edebiliriz:

    from xml.etree import ElementTree

    Parse işlemi bu sınıfın static parse isimli metoduyla yapılmaktadır. Bu parse metodu dosyan ın yol ifadesini alabilir ya da open fonksiyonuyla 
    açılmış olan dosya nesnesini paramatre olarak alabilmektedir. Örneğin:

    from xml.etree import ElementTree 

   tree = ElementTree.parse('sample.xml')

   Ya da örneğin:

    from xml.etree import ElementTree 

    with open('sample.xml') as f:
        tree = ElementTree.parse(f)

    static parse metodu bize ElemenTree sınıfı türünden bir nesne verir. Biz de artık bu sınıfın metotlarını kullanarak işlemlerimizi yaparız. 
    parse metodunun bize verdiği ElementTree nesnesi tüm ağacı temsil etmektedir. 

    XML dokümanlarında başlangıç tag'ı, içerik ve bitiş tag'ının oluşturduğu topluluğa "eleman (element)" denilmektedir. ElementTree 
    mimarisinde tüm ağaç ElementTree sınıfı ile temsil edilirken elemanlar Element sınıfıyla temsil edilmektedir. XML dokümanlarında bir 
    elemanın diğer elemanları içerebildiğine dikkat ediniz. Örneğin:

    <?xml version="1.0"?>
    <data>
        <country name="Liechtenstein">
            <rank>1</rank>
            <year>2008</year>
            <gdppc>141100</gdppc>
            <neighbor name="Austria" direction="E"/>
            <neighbor name="Switzerland" direction="W"/>
        </country>
        <country name="Singapore">
            <rank>4</rank>
            <year>2011</year>
            <gdppc>59900</gdppc>
            <neighbor name="Malaysia" direction="N"/>
        </country>
        <country name="Panama">
            <rank>68</rank>
            <year>2011</year>
            <gdppc>13600</gdppc>
            <neighbor name="Costa Rica" direction="W"/>
            <neighbor name="Colombia" direction="E"/>
        </country>
    </data>

    Burada "data" elemanı "country" elemanlarını "country" elemanları da "rank", "year", "gdppc", "neighbor" elemanlarını içermektedir. 
    Biz bu XML dosyasını "sample.xml" ismiyle kaydedip örneklerde kullanacağız. 

    parse işleminden sonra ilk yapılacak şey kök elemanı elde etmektir. Yukarıdaki örnekte kök eleman "data" isimli elemandır. Bunun için
    ElementTree nesnesi ile sınıfın getroot metodu çağrılır. Örneğin:

    from xml.etree import ElementTree

    tree = ElementTree.parse('sample.xml')
    root = tree.getroot()

    Burada root değişkeni artık Elemant türündendir. Element nesnesinin üç önemli özniteliği vardır: tag, attrib ve text. tag özniteliği 
    string olarak tag'ın ismini, text özniteliği içerik yazısını ve attrib özniteliği de tag'a ilişkin özellikleri bir sözlük biçiminde 
    vermektedir. Sözlüğün anahtarları özelliklerin isimlerinden değerleri de özelliklere '=' ile atanan yazılardan oluşmaktadır. Örneğin:

    <student name="Ali Serçe" no="1234">Ümraniye</student>

    Bu elemanın "tag" özniteliği bize "student" yazısını, text özniteliği "1234" yazısını ve attrib özniteliği ise {'name': 'Ali Serçe', 'no': '1234'}
    sözlük nesnesini vermektedir. 
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------
    Bir Element nesnesi aynı zamanda dolaşılabilir bir nesnedir. Biz Element nesnesini dolaşırsak yukarıdan aşağıya doğru onun bütün 
    doğrudan alt elemanlarını elde ederiz. Örneğin:

    from xml.etree import ElementTree

    tree = ElementTree.parse('sample.xml')
    root = tree.getroot()

    for element in root:
        print(element.tag, element.attrib)
   
    Buradan şu çıktı elde edilmiştir:

    country {'name': 'Liechtenstein'}
    country {'name': 'Singapore'}
    country {'name': 'Panama'}

    Element sınıfının iter isimli metodu bize dolaşılabilir bir nesne verir. Ancak iter metodunun verdiği nesneyi dolaştığımızda 
    biz yalnızca doğrudan alt elemanları değil yukarıdan aşağıya doğru kendisi de dahil tüm alt elemanları elde ederiz. Örneğin:

    from xml.etree import ElementTree 

    tree = ElementTree.parse('sample.xml')
    root = tree.getroot()
    
    for element in root.iter():
        print(element.tag, element.attrib)
        
    Buradan şöyle bir çıktı elde edilmiştir:

    data {}
    country {'name': 'Liechtenstein'}
    rank {}
    year {}
    gdppc {}
    neighbor {'name': 'Austria', 'direction': 'E'}
    neighbor {'name': 'Switzerland', 'direction': 'W'}
    country {'name': 'Singapore'}
    rank {}
    year {}
    gdppc {}
    neighbor {'name': 'Malaysia', 'direction': 'N'}
    country {'name': 'Panama'}
    rank {}
    year {}
    gdppc {}
    neighbor {'name': 'Costa Rica', 'direction': 'W'}
    neighbor {'name': 'Colombia', 'direction': 'E'}

    Peki ağaç üzerinde spesifik elemanları nasıl elde edebiliriz? İlk akla gelen yöntem her elemanı elde ederken aynı zamanda 
    tag özelliğine bakmak olabilir. Örneğin:

    from xml.etree import ElementTree

    tree = ElementTree.parse('sample.xml')
    root = tree.getroot()

    for element in root.iter():
        if element.tag == 'year':
            print(element.tag, '=>', element.text)

    Buradan şöyle bir sonuç elde edilmiştir:

    year => 2008
    year => 2011
    year => 2011

    Aslında bunu yapmak için Element sınıfında findall isimli bir metot da bulundurulmuştur. Ancak findall metodu doğrudan alt 
    elemanları aramaktadır. findall bize elemanları bir liste olarak verir. Örneğin:

    result = root.findall('year')

    Burada findall hiçbir eleman bulamayacaktır. Çünkü kök eleman olan "data" yalnızca "country" elemanlarına sahiptir. findall 
    XPATH özelliğini desteklemektedir. XPATH XML ağacını sanki dizin ağacı gibi ifade etmek için kullanılan bir gösterim biçimidir. 
    XPATH ifadesine "./" ile başlamak en yaygın durumdur. Buradaki "./" o andaki eleman anlamına gelir. Örneğin "./country/year" 
    XPATH ifadesi "country" elemanının altındaki "year" elemanlarını bulur. Örneğin:

    from xml.etree import ElementTree

    tree = ElementTree.parse('sample.xml')
    root = tree.getroot()

    for element in root.findall('./country/year'):
        print(element.tag, '=>', element.text)
        
    XPATH'te ".//" ifadesi altındaki tüm elemanlar anlamına gelmektedir. Örneğin ".//year" ilgili elemanın altındaki tüm elemanlar 
    içerisinde "year" tag'larını bize verir. 

    findall bize tüm elemanları bulur, onu bir listeye doldurur ve listeyi bize verir. Halbuki bu işlemin iteratör yoluyla yapılması 
    kimi zaman daha az maliyetli olabilmektedir. İşte findall metodunun iteratörlü versiyonu iterfind ismindedir. iterfind bize 
    dolaşılabilir bir nesne verir. Dolayısıyla biz elemanı döngü içerisinde tek tek elde ederiz. Örneğin:

    from xml.etree import ElementTree

    tree = ElementTree.parse('sample.xml')
    root = tree.getroot()

    for element in root.iterfind('./country/year'):
        print(element.tag, '=>', element.text)

    Element sınıfının find isimli metodu yalnızca koşula uygun ilk elemanı bize verir. Örneğin:

   from xml.etree import ElementTree

    tree = ElementTree.parse('sample.xml')
    root = tree.getroot()

    element = root.find('.//year')
    print(element.tag, '=>', element.text)
    
    Şöyle bir sonuç elde edilecektir:

    year => 2008
#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------------------








