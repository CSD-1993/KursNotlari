/*-----------------------------------------------------------------------------------------------------------------------------

                                            C ve Sistem Programcıları Derneği

                                   Gömülü Linux Sistemleri - Geliştirme ve Uygulama Kursu

                                        Sınıfta Yapılan Örnekler ve Özet Notlar

                                                  Eğitmen: Kaan ASLAN

          Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.

                    (Notları okurken editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz.)

                                                Son Güncelleme: 18/04/2024

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												1. Ders 05/03/2024 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kurs için gerekli olabilecek malzemeler şunlardır:

    - Raspberry Pi SBC (Single Board Computer): Version 3, 4 ya da 5 olabilir. Yeni satın alacakların Raspberry Pi 5 almalarını 
    tavsiye ediyoruz.

    - Raspberry Pi 5 alınacaksa soğutucu ya da soğutuculu kılıf da alınmalı. Raspberry Pi 3 ve 4 için soğutucu alınmayabilir.

    - Raspberry Pi için Micso SD Kart: 64GB Yüksek Hızlı (SanDisk Extreme serisi olabilir). Micro SD kart 32 GB de olabilir.
    Ancak 32GB'den düşüğü tavsiye etmiyoruz.

    - Raspberry Pi 4 ve Raspberry Pi 5 için "Mikro HDMI -> HDMI kablosu", Raspberry Pi 3 için "HDMI -> HDMI" Kablosu.

    - USB Kombo Klavye + Mouse

    - Raspberry Pi için GPIO Breadboard Aktarma Kablosu

    - Raspberry Pi için Güç Kaynağı Adaptörü: Raspberry Pi 3 ve 4 için 5V/3A, Raspberry Pi 5 için 5V/5A (27W). Raspberry Pi 4 
    ve 5 USB Type C kullanıyor. Raspberry Pi 3 Micro USB kablosu kullanıyor.

    - BeagleBone Black SBC (Single Board Computer): BeagleBone Black 4G ya da BeagleBone Black Industrial ya da BeagleBone 
    Black Wireless yeni satın alacak olanlar "BeagleBone Black 4G" ya da BeagleBone Black Wireless" alabilirler. Stokları 
    kontrol etmek gerekiyor.

    - BeagleBone Black için Güç Kaynağı: Mini USB ile 5V/500mA güç adaptörü ya da yuvarlak girişli (DC Jack) 5V/1A güç adaptörü.

    - BeagleBone Black için Micro SD Kart (16GB olabilir).

    - BeagleBone Black için "Micro HDMI -> HDMI" Dönüştürücü.

    - Standart Boy Breadboard ve İsteğe Bağlı Küçük Boy Breadboard'lar da olabilir.

    - Jumper Kablo seti

    - "USB -> UART" Dönüştürücü (CP2102 olabilir)

    - USB Uzatma Kablosu Gerekebilir.

    - Ethernet RJ45 Kablosu: Eğer SBC'nin wireless özelliği varsa buna gerek duymayabilirsiniz.

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												2. Ders 07/03/2024 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kursumuzun giriş bölümünde çeşitli kavramları ve terimleri açıklayacağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Asıl amacı bilgisayar olmayan fakat bilgisayar sistemi içeren sistemlere genel olarak gömülü sistemler (embedded systems) 
    denilmektedir. Yani gömülü sistemler başka amaçları gerçekleştirmek için tasarlanmış olan aygıtların içerisindeki bilgisayar
    sistemleridir. Örneğin elektronik tartılar, biyomedikal aygıtlar, GPS cihazları, turnike geçiş sistemleri (validatörler), 
    müzik kutuları, kapı güvenlik aygıtları, otomobiller içerisindeki kontrol panelleri, birer gömülü sistemdir. Gömülü 
    sistemlerde en çok kullanılan programlama dili C'dir. Ancak genel amaçlı işletim sistemlerinin yüklenebildiği SBC'lerde 
    (Single Board Computer) diğer programlama dilleri de kullanılabilmektedir.

    Gömülü sistemler gömüldüğü aygıtta belli işlevleri sağlamak için kullanılmaktadır. Örneğin buzdolaplarının, çamaşır 
    makinelerinin içerisine yerleştirilen bilgisayar devreleri ve yazılımlar onların önemli etkinlerini yönetmekte, kullanıcı 
    ile arayüz oluşturabilmektedir. Günümüzde bilgisayar sistemi içeren aygıtlar artık her yeri sarmıştır. Bu nedenle üzerinde 
    geliştirme faaliyetleri de önemli bir iş alanı haline gelmiştir.

    Gömülü sistemlerin tipik özellikleri şunlardır:

    - Gömülü sistemler "genel değil belirli (specific) amaca yönelik" işlemleri gerçekleştirmektedir. Yani genel amaçlı değil 
    özel amaçlı donanım ve yazılım hizmeti sunmaktadır. Bu sistemlerdeki yazılımlar da genel amaçlı değil belli bir amacı 
    gerçekleştirmeyi hedeflemektedir.

    - Gömülü sistemler genellikle daha düşük bir bilgiişlem kapasaitesine sahip bilgisayar devreleridir. Örneğin bu sistemlerde 
    kullanılan işlemciler genel amaçlı masaüstü işlemcilerden genellikle daha yavaş olma eğilimindedir. Bu sistemlerdeki bellek
    miktarları (birincil ve ikinci bellekler) genel amaçlı bilgiayar sistemlerine göre daha düşük olma eğilimindedir. Dolayısıyla 
    gömülü sistemlerin maliyetleri de genel amaçlı bilgisayar sistemlerine göre çok düşüktür.

    - Gömülü sistemler genellikle (fakat her zaman değil) daha düşük güç harcamaktadır. Bu durum onların bataryalarla beslenebilmesini 
    dolayısıyla fiziksel taşınabilirliğini de artırmaktadır. Tabii genel olarak gömülü sistemler düşük güç harcama eğiliminde olan 
    sistemler olsalar da bu durum her zaman böyle olmak zorunda değildir. Bazı gömülü sistemlerin gömüldüğü sistemlerde bir güç kullanma
    sorunu yoktur. (Örneğin araba kantarı zaten bu işlevi gerçekleştirmek için önemli bir güç harcamaktadır. Dolayısıyla bu sistemdeki
    gömülü sisteminharcadığı gücün önemi olmayabilir.)

    - Gömülü sistemlerin önemli bir bölümü "gerçek zamanlı (real time)" olaylarla ilişkilidir. Bu sistemlerin belli bir bölümü 
    dış dünyadaki değişimlere karşı bir yanıt oluşturmaya çalışmaktadır. Örneğin bir gömülü sistem otamdaki ısı belli bir kritik 
    düzeye geldiğinde bir işlemi başlatabilir. Ya da bir gömülü sistem kalp ritmi bozulduğunda kalbe uyarılar göndererek ritm bozukluğunu
    düzeltmeye çalışabilir. Hava araçlarındak gömülü sistemler o anki hava şartlarına göre bir otomatik kumanda sistemi işlevini 
    görüyor olabilir. Tabii gömülü istemlerin bu gerçek zamanlı işlem doğası bazı uygulamalarda "çok katı (hard realtime)" olurken bazı 
    uygulamalarda "daha gevşek (soft realtime)" olabilmektedir.

    - Gömülü sistemlerin bazılarında hiç girdi/çıktı birimi olmayabilir. Bazılarında ise girdi/çıktı birimi olarak "düğmeler", 
    basit tuş takımları, küçük LCD'ler olabilir. Oysa genel amaçlı bilgisayar sistemlerinde genellikle girdi/çıktı birimi olarak 
    klavye, fare ve gelişmiş monitörler kullanılmaktadır. Başka bir deyişle gömülü sistemler kullanıcı arayüzü bakımından minimal 
    olma eğilimindedir.

    - Gömülü sistemlerdeki donanım birimleri nispeten ucuz olma eğilimindedir. Genel amaçlı bilgisayarlara göre bunlar çok daha ucuz
    olarak temin edilebilmektedir.

    - Gömülü sistemler çeşitli kaynaklarda çeşitli ölçütlere göre de sınıflandırılabilmektedir.

    1) İşlevsel Gereksinime Göre Sınıflandırma:

        a) Gerçek zamanlı Olan ya da Gerçek Zamanlı Olmayan Gömülü Sistemler: Bunlar "hard" ya da "soft" real-time olabilmektedir.
        b) Bağımsız (Stand-Alone) olan Bağımısz Olmayan Sistemler: Bunlar belli bir amaca yönelik hazırlanmış gömülü sistemlerdir.
        Örneğin hesap makineleri, kapı güvenlik sistemleri, MP3 çalarlar gibi.
        c) Ağ (Network) Üzerinde İşlem Yapan Gömülü Sistemler: Bunlar ağ işlemleri yapmak için oluşturulmuş gömülü sisteemlerdir.
        ATM makineleri, ADSL Rouer cihazları gibi cihazları bunlara örnek verebiliriz.
        d) Mobil Aygıtlarda Kullanılan Gömülü Sistemler: Bunlar küçük, taşınabilir aygıtlarda kullanılan gönmülü sistemlerdir.
        Telefonlari GPS cihazları, dijital kameralar bunlara örnek verilebilir.

    2) Performans Gereksinimine Göre Sınıflandırma:

        a) Küçük Ölçekli (Small Scale) Gömülü Sistemler
        b) Orta Ölçekli (Medium Scale) Gömülü sisteemlerde
        c) Büyük Ölçekli (Large Scale) Gömülü Sistemler

    Biz burada "https://www.ultralibrarian.com/2022/06/28/types-of-embedded-systems-characteristics-classifications-ulc"
    bağlantısındaki sınıflandırmayı kullandık. Ancak başka kaynaklarda başka türlü sınıflandırmalar da yapılabilmektedir.

    Gömülü sistemlerde bilgisayar birimi olarak genellikle miktodenetleyiciler (microcontrollers) kullanılmaktadır. Ancak entegre
    devre teknolojisinin gelişmesiyle artık içlerine standart işletim sistemi yüklenebilen çok daha gelişmiş donanımlar da 
    gömülü sistemlerde kullanılabilmektedir.

    Gömülü sistem yazılımlarının önemli bir bölümü bir işletim sistemi olmadan çalışacak biçimde (bare-metal) olarak geliştirilmektedir. 
    Bunun önemli nedenlerinden biri bunların kapasitelerinin nispeten düşük olması diğeri de belirli bir amacı gerçekleştirecek
    biçimde tasarlanmış olmalarıdır. Gömülü sistemlerin bir bölümünde "gerçek zamanlı işletim sistemleri" bir bölümünde ise "genel 
    amaçlı işletim sistemleri" kullanılmaktadır.

    Gömülü sistemlerde genel olarak üç işlem birimi kullanılmaktadır:

    1) Mikrodenetleyiciler
    2) Mikroişlemcileri
    3) DSP'ler
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bir bilgisayar sisteminde aritmetik, mantıksal, bitsel işlemler ve karşılaştırma gibi bilgiişlem faaliyetleri işlemleri 
    "mikroişlemci (microprocessor)" denilen birim tarafından yapılmaktadır. Mikroişlemciler entegre devre biçiminde üretilmişlerdir. 
    Mikroişlemcilere kavramsal olarak CPU (Centeral Processing Unit) de denilmektedir. Yani CPU mikroişlemcilerin kavramsal ismidir. 
    Aslında genel amaçlı bir bilgisayar sisteminde komut çalıştıran pek çok işlemci bulunabilmektedir. CPU bu işlemcileri de 
    programlayan "merkezi (central)" işlemcidir. Bilgisayar sisteminde yerel bazı işlemlerden sorumlu yardımcı işlemciler de 
    vardır. Örneğin "kesme denetleyicisi (interrupt controller)", "disk denetleyicisi (disk controller)", "DMA denetleyicisi 
    (DMA controller)" gibi.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Mikrodenetleyiciler tek bir chip içerisine yerleştirilmiş bir bilgisayar sistemi gibi düşünülebilirler. Tipik olarak bir 
    mikrodenetleyicide bir "işlemci (processor)", kendi içerisinde "RAM ve Flash EPROM", dış dünya ile haberleşmek için kullanılan 
    "IO birimi" ve bazı "çevre birimleri (peripherals)" bulunmaktadır. Mikrodenetleycilere İngilizce "microcontroller" ya da 
    "microcontroller Unit (MCU)" da denilmektedir.

    Mikrodenetleyicilerin işlem kapasiteleri ve içerdikleri bellek miktarları düşük olma eğilimindedir. Ancak bunlar çok kolay 
    programlanıp uygulamaya sokulabilmektedir. Mikro denetleyicilere "tek çiplik bilgisayar (single chip computer)" da denilmektedir. 
    Mikrodenetleyiciler özellikle gömülü sistemlerde tercih edilmektedir. Bunların düşük güç harcaması ve ucuz olmaları en büyük 
    avantajlarındandır. Gömülü uygulamalarda kullanılan pek çok mikrodenetleyici ailesi vardır. Örneğin:

    - Microchip PIC Mikrodenetleyici Ailesi (Microchip)
    - Renesans Mikrodenetleyici Ailesi (Renesans)
    - ARM Mikrodenetleyici Ailesi (Tasarımcısı ARM Holding, ancak çok şeşitli firmalar tarafından üretiliyor)
    - AVR Mikrodenetleyici Ailesi (Atmel, ancak Atmel firması 2016'da Microchip tarafından satın alındı)
    - MSP Mikrodenetleyici Ailesi (Texas Instruments)
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bazı firmalar ayrı birimler olarak tasarlanmış mikroişlemcileri, RAM'leri, ROM’ları ve diğer bazı çevre birimlerini tek bir 
    entegre devrenin içerisine sıkıştırmaktadır. Bunlara genel olarak "SoC (System on Chip)" denilmektedir. SoC mikrodenetleyicilere 
    benzese de aslında onlardan farklıdır. SoC’lar içerisindeki işlemcilerin ve belleklerin kapasiteleri yüksektir. Bunlar özel 
    amaçlı üretilirler ve bunların devrelerde kullanılmaları mikrodenetleyiciler kadar kolay değildir. Bunların en önemli avantajları 
    "az yer kaplamasıdır". Örneğin Raspberry Pi kitlerinde Broadcom isimli firmanın 2835, 2836, 2837, 2711, 2712 numaralı SOC 
    çipleri kullanılmıştır. SoC'ların RAM ve ROM bellek içermesi zorunlu değildir. Bazı SoC'lar RAM içerirken bazıları içermeyebilmektedir. 
    Örneğin Raspberry Pi 1, 2, 3 modellerinde kullanılan SoC'lar RAM içerirken Raspberry Pi 4 ve 5 modellerinde kullanılan SOC'lar 
    RAM içermemektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    SoC kavramına benzer diğer bir kavram da "SoM (Ssystem on Module)" kavramıdır. SoM bir işlemci ve onunla ilişkili bazı birimlerin
    monte edildiği kartları belirtmek için kullanılmaktadır. SoM'lar SoC'ları içerebilir. Ancak başka birimleri de içerebilir. 
    Örneğin bir SoM bir işlemci, buna ilişkin RAM, IO denetleyicisi (IO controllers içeren bir kart olabilir. Örneğin "Raspberry Pi
    Pico" ve "Raspberry Pi Compute Module" birer SBC'den ziyade birer SoM olarak ele alınabilir. SoM kavramını zihninizde SoM ile 
    SBC arasında bir yerde konumlandırabilirsiniz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Küçük bir kit (baskılı devre) üzerine monte edilmiş bilgisayarlara SBC (Single Board Computer) denilmektedir. Genellikle 
    bu kitlerde SOC'lar, RAM'ler ve başka çevre birimleri ve IO işlemleri için soketler bulunmaktadır. Örneğin Raspberry Pi, 
    Beagleboard SBC'lere örnek verilebilir. SBC'ler klavye, fare ve monitör takılarak bir masaüstü bilgisayar gibi kullanılabilmektedir.
    SBC'ler masaüstü bilgisayarlar gibi de kullanılabildiğinden bunlara Linux başta olmak üzere, Android ve Windows gibi işletim 
    sistemleri yüklenebilmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Mikroişlemcileri tasarım mimarilerine göre iki CISC (Complex Instruction Set Computers) ve RISC (Reduced Instruction Set 
    Computers) olmak üzere iki kısma ayırabiliriz. CISC ailesi işlemcilere Intel firmasının x86 ailesi işlemcilerini örnek verebiliriz. 
    ARM, MIPS, PowerPC, Itanium gibi işlemciler ise tipik RISC işlemcileridir. Her ne kadar CISC ve RISC isimleri komut kümesi 
    ile ilgili biçimde uydurulmuşsa da CISC ve RISC tasarımları başka bakımlardan da farklılık göstermektedir. 
    
    İşlemciler (makro ve mikro) ortaya çıktığında çok fazla makine komutunun bulunmasının bir avantaj olduğu düşünülüyordu. 
    Ancak daha sonraları bunun avantajdan ziyade dezavantaj oluşturduğu görüldü. Belli bir süreden sonra artık RISC mimarisinin
    CISC mimarisinden toplamda daha iyi bir tasarım olduğu kabul görmüştür. Bu nedenle son dönem mikroişlemci tasarımlarında hep 
    RISC mimarisi kullanılmıştır. 

    CISC ve RISC mimarisi arasındaki temel farklılklar şunlardır:

    1) CISC işlemcilerinde fazla sayıda makine komutu bulunmaktadır. Bu işlemcilerde bazı komutlar temel işlemleri yaparken 
    bazıları karmaşık işlemler yapmaktadır. Halbuki RISC işlemcilerinde az sayıda temel nmakine komutları bulunmaktadır. Bu 
    makine komutları da daha fazla transistör kullanılarak daha hızlı çalışacak biçime getirilmiştir. Dolayısla CISC işlemcilerindeki 
    bazı komutlar RISC işlemcilerinde birkaç komutla karşılanabilmektedir. Ancak bu durum sanıldığının tersine daha hızlı bir 
    çalışma sağlama potansiyelindedir. 

    2) CISC işlemcilerinde az sayıda yazmaç (register), RISC işlemcilerinde ise fazla sayıda yazmaç bulunma eğilimindedir. Yazmaç 
    sayıları az olunca yazmaçların tekrar tekrar aynı değerlerle yüklenmesi gerekebilmektedir. Bu da derleyicinin nesneleri 
    daha kısa sürede yazmaçlarda tutmasına yol açmaktadır. Yine CISC işlemcilerindeki bazı komutlar ancak bazı özel yazmaçlarla 
    kullanılmaktadır. (Örneğin Intel X86 şlemcilerinde MUL ve DIV gibi komutların bir operandı EAX ya da RAX yazmacında bulunmak 
    zorundadır.) Oysa RISC işlemcilerinde her işlem her yazmaçla yapılabilmektedir. 

    3) CISC işlemcilerinde komutlar farklı uzunluklarda olabilmektedir. Örneğin Intel'in x86 ailesinde 1 byte olan makine komutları 
    da vardır, 5 byte olan makine komutları da vardır, 11 byte olan hatta 15 byte olan makine komutları da vardır. Halbuki RISC 
    işlemcilerinde genel olarak tüm makine komutları eşit uzunluktadır. Örneğin ARM işlemcilerinde her makine komutu 4 byte 
    uzunluktadır. Böylece işlemci komutları bellekten daha etkin bir biçimde çekip (fetch işlemi) onları daha çabuk anlamlandırmaktadır
    ve n sonraki ya da önceki makine komutlarının yerini belirleyebilmektedir. 

    4) RISC işlemcilerinde pipeline mekanizması CISC işlemcilerine göre daha iyi gerçekleştirilmektedir. Pipeline işlemcinin
    bir makine komutunu çalıştırırken sonraki komutlar üzerinde hazırlık işlemlerini yapması anlamına gelmektedir. RISC tasarımı
    olarak pipleline mekanizmasının daha iyi yürütülmesine olanak sağlamaktadır.

    5) RISC İşlemcileri Load/Store tarzı makine komutları kullanmaktadır. Bu işlemcilerde belleğe erişim yapan makine komutlarıyla
    artimetik, mantıksal ve bitsel işlem yapan makine komutları birbirinden ayrılmıştır. Örneğin RISC işlemcilerinde ADD, SUB gibi
    makine komutlarının her iki operandı da yazmaç olmak zorundadır. Halbuki CISC işlemcilerinde bu tür makine komutlarının bir 
    operandı yazmaç bir operandı bellek olabilmektedir. Örneğin:

    a = b + c;

    gibi bir işlem CISC işlemcis ile şu makine komutlarıyla yapılabilmektedr:

    - b'yi yazmaca çeken makine komutu
    - Yazmaçtaki b ile bellekteki c'yi toplayan makine komutu
    - Yazmaçtaki toplamı a'ya yerleştiren makine komutu
   
    Oysa aynı işlem RISC işlemcilerinde şöyle gerçekleştirilmektedir:

    - b'yi yazmaca çeken makine komutu
    - c'yi yazmaca çeken makine komutu 
    - Yazmaçlardaki b ile c'yi toplayan makine komutu
    - Yazmaçtaki sonucu a'ya yerleştiren makine komutu

    Belleğe erişim komutlarıyla diğer komutların birbirinden ayrıldığı işlemcilere "load/store" işlemcileri ya da "register-register
    işlemcileri de denilmektedir. 

    6) RISC işlemcileri genel olarak (ancak hepsi değil) üç operandlı makine komutlarını kullanmaktadır. Oysa CISC işlemcileri 
    genellikle iki operand'lı makine komutlarını kullanır. İki operand'lı makine komutlarında işlemin sonucu operand olan yazmaçlardan
    birine yerleştirildiği için o yazmaç bozulmaktadır. Böylece derleyici o yazmaçtaki değeri yeniden kullanmak istediğinde 
    onu yeniden yüklemek zorunda kalmaktadır. Örneğin a = b + c işlemi 32 bit Intel işlemcilerinde tipik olarak şöyle 
    gerçekleştirilmektedir:

    MOV EAX, <a'nın adresi>
    ADD EAX, <b'nin adrei>
    MOV <c'bin adresi>, EAX

    Burada EAX işlemcinin bir yazmacıdır. ADD makine komutu bu yazmaçtaki değer ile bellekteki b'yi toplamakta ve sonucu yine
    EAX yazmacına yerleştirmektedir. Dolayısıyla EAX yazmacındaki a değeri artık kaybolacaktır. Bu değer yeniden kullanılmak 
    istendiğinde ise yeniden yüklemenin yapılması gerekecektir. Şimdi aynı işlemi ARM işlemcilerinde yapacak olalım:

    LDR R0, <a'nın bellek adresi>
    LDR R1, <b'nin bellek adresi>
    ADD R2, R1, R0
    STR R2, <c'nin bellek adresi>

    Burada R0, R1 ve R2 işlemcinin yazmaçlarıdır. Görüldüğü gibi ARM işlemcilerinde Load/Store komutları dışındaki komutlar 
    üç operand'lıdır. Bu da yazmaçlardaki değerlerin gerektiğinde bozulmamasına yol açmaktadır. 

    7) RISC işlemcileri yukarıda belirttiğimiz tasarım prensiplerinden dolayı toplamda daha az güç harcama eğilimindedir. Bu da
    onların mobil aygıtlarda kullanılmasının önemli bir gerekçesini oluşturmaktadır.

    8) RISC işlemcilerinde makine komutlarının çalışma süreleri birbirine yakındır. Ancak CISC işlemcilerinde makine komutlarının 
    çalışma süreleri arasında önemli farklılıklar olabilmektedir. Örneğin ARM işlemcilerinde toplama, çıkartma, çarpma gibi 
    makine komutları 1 cycle'da yapılmaktadır. Ancak load/store komutlarının, jump komutlarının ve özel bazı komutların çalışma 
    süreleri 1 cycle'dan fazla olabilmektedir. Oysa örneğin Intel x86 işlemcilerinde komut süreleri değişik faktörlere bağlı olarak
    biribirinden çok farklılaşmaktadır.

    RISC ve CISC mimarilerini bir spektrum olarak düşünmek gerekir. Örneğin MIPS işlemcileri ARM işlemcilerine göre bu spektrumun 
    daha fazla RISC tarafındadır. Intel'in x86 işlemcilerini kategori olarak CISC grubu işlemciler olarak ele alsak da Pentium 
    işlemcileri ile birlikte bu işlemcilerde de RISC prensipleri gittikçe daha fazla kullanılır hale gelmiştir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                3. Ders 12/03/2024 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ARM işlemcilerinin tarihi "Acorn Computer" isimli İngiliz firmasına dayanmaktadır. Bu firma 80’li yılların başlarında 
    "BBC Micro" isimli 64K’lık ev bilgisayarlarını yapmıştı. Bu bilgisayarlarda Rockwell’in 8 bitlik 6502 işlemcileri kullanılıyordu. 
    Firma daha sonra "Berkeley RISC" projesinden etkilenerek kendi RISC işlemcilerini yapmaya odaklandı. Böylece ilk ARM modelleri 
    tasarlanmış oldu. Şirket 1990’da "Apple" ve "VLSI Technology" şirketleriyle ortaklıklar da kurarak ARM ismini aldı. (Eskiden 
    ARM "Acorn RISC Machine" isminden kısaltlıyordu. Fakat daha sonra bu firma kurulunca bu kısaltma "Advanced RISC Machine" haline 
    getirildi.) Apple firması bu yeni firmaya maddi destek sağlamıştır. "VLSI Technology" firması ise ekipman tedarik etmiştir.
    Acorn ise az sayıda tasarım mühendisini bu yeni firmaya aktarmıştır. 2016 yılında "SoftBank Group" ARM hisselerinin önemli bir 
    bölümünü aldı. 2018'de ARM'ın Çin şubesinin yarısından fazlasını "Chine Investment" şirketine sattı. 2020'de "NVidia" ARM'ı 
    SoftBank Group'tan satın almak istediyse de satış gerçekleşmedi. Bugün "SoftBank Group" ARM'ın %90 civarındaki hisselerine 
    sahiptir. Geri kalan hisseleri kurucu ortaklarda ve halka arzdadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ARM bir tasarım firmasıdır. Yani fabrikalara sahip değildir. ARM yaptığı tasarımları lisanslandırarak üretici firmalara 
    satmaktadır. ARM'ın uyguladığı dört tür lisans vardır:

    Entegre Devre Lisansı (Full Custom License): Bu lisans müşterinin mikrodenetleyici tasarımını kendi özel ihtiyaçlarına 
    göre özelleştirmesine ve optimize etmesine olanak tanır. Örneğin Apple gibi, Qualcomm gibi, Samsung gibi firmalar bu 
    lisansa sahiptir.

    Mimari Lisans (Architecture License): Bu lisans ARM'nin genel mikroişlemci mimarisine erişim sağlayan bu lisanstır. Ancak, 
    bu lisans müşterinin mikrodenetleyiciyi özelleştirmesine izin vermez. Yani bu lisansa sahip olanlar işlemci tasarımını
    kullanarak üretim yapabilirler ancak onu özelleştiremezler.

    Çekirdek Lisansı (Processor IP License): Bu lisans ile ancak müşteri belli bir ARM işlemcisini (core) üretebilmektedir.

    Geliştirici Lisansı (Development License): Bu lisans ARM'nin tasarım araçlarına erişim sağlayan bir lisanstır. Müşteri 
    bu araçları kullanarak kendi işlemcilerini tasarlayabilir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ARM dünyasında çalışmak için bazı terimler hakkında bilgi sahibi olmak gerekir. ARM firması kendine özgü terimler uydurmuştur.
    Bu dünyada en çok karşılaşılan terimler "core", "cortex" ve "version" terimleridir. 

    ARM dünyasında "core" terimi belli bir mikroişlemci tasarımını belirtmektedir. Bu tasarım üretici firmalar tarafından 
    fiziksel hale getirilmektedir. Bir grup "core" bir araya getirildiğinde ve işlemciyle ilişkili birtakım birimler de bunlara 
    eklendiğinde "Cortex'ler" oluşmaktadır. ARM firması ARM'ın klasik versiyonlarında "cortex" terimini kullanmamıştır. Cortex
    terimi ARM11'den sonra kullanılmaya başlanmıştır. Bir cortex belli sayıda "core" içerebilir. Bu "core"lar noktalı sayılara
    (floating point) ilişkin işlem yapan birimlere sahip olabilirler. Cortex içerisindeki core'ların belli hızları vardır. Core 
    ve cortex terimleri daha çok çip düzeyindeki mimariyi belirtmektedir. Ancak cortex'lerde kullanılan işlemcilerin (core'ların) 
    sistem programcısını ilgilendiren "komut kümeleri (instruction sets)" de vardır. Böylece bir grup grup cortex belli bir komut
    kümesi ile kullanılabilecek biçimde tasarlanmıştır. Komut kümesi mimarisine "ARM Versiyonları" ya da İngilizcesiyle "ARM ISA
    (Instruction Set Architecture) Mimarisi" denilmektedir. Biz sistem programcısı olarak elimizdeki cortex'in hangi komut kümesini 
    kullanan ARM versiyonuna ilişkin olduğunu bilmek durumundayız. Burada dikkat edilmesi gereken nokta "Cortex teriminin donanımsal 
    mimariyi, versiyonun ise yazılımsal mimariyi belirtiyor" olmasıdır. O halde gömülü sistem geliştiricisi olarak bizim ilgilendiğimiz 
    ARM içeren kart ile ilgili şu iki özelliği biliyor olamamız gerekir:

    1) Kartımızda ARM'ın hangi cortex'i kullanılmıştır?
    2) Bu cortex'in ilişkin olduğu versiyon numarası nedir?

    Yukarıda da belirtitğimiz gibi farklı cortex'ler aynı version numarasını kullanabilmektedir. 

    ARM dünyasında üç mimari profili (profile) bulunmaktadır:

    1) A (Apllication) Profili 
    2) R  (Realtime) Profili
    3) M (Microcontroller) Profili 

    Bu profiller ilgili cortex'lerin hangi tür uygulamalarda ideal olarak kullanılabileceğini belirtmektedir. Profil isimleri 
    cortex'lerde ve versiyon numaralarında '-' karakterinden sonra A, R, M harfleriyle belirtilmektedir. Örneğin "Cortex-A8" ve 
    "ARMV7-A" gibi.A profilleri masasüstü işletim sistemlerinin çalıştırılabileceği, tamamen kişilsel bilgisayar olarak kullanılabilecek 
    cortex'leri belirtmektedir. Biz kursumuzda "gömülü Linux programcısı" olarak bu "A" profilleriyle çalışacağız. R profilleri
    "gerçek zamanlı (realtime)" uygulamalar için daha uygun olabilecek cortex'leri belirtmektedir. R profilleri ile A profilleri 
    birbirlerine benzemektedir. R profilleri A profillerine göre çok daha seyrek kullanılmaktadır. M profilleri ARM'ın mikrodenetleyici
    olarak kullanılan cortex'lerini belirtmektedir. Bu cortex'ler genel olarak Linux işletim sisteminin yüklenmesine izin vermemektedir. 
    Bu cortex'ler genellikle "bare-metal" programlarla ya da gerçek zamanlı işletim sistemleriyle kullanılmaktadır.

    ARM'ın iki önemli versiyonu ARMV7-A ve ARMV8'A dır. ARMV7 32 bitlik bir arayüz sunmaktadır. Dolayısıyla bu komut mimarisini 
    kullanan cortex'ler 32 bitlik işlemciler içermektedir. ARMV8-A versiyonları ise 64 bitlik arayüz sunmaktadır. Dolayısıyla bu 
    versiyonları kullanan cortex'ler 64 bitlik işlemcilere ilişkindir. Ancak ARM cortex'lerinin bir grubu hem 32 bit hem de 64 bit 
    olarak kullanılabilmektedir. Bu cortex'lerdeki işlemcileri kullanan işletim sistemleri 32 bitlik ve 64 bitlik programları zaman 
    paylaşımlı olarak bir arada çalıştırabilmektedir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Mikroişlemciler ilk çıktığında 8 bit işlemleri yapabiliyordu (örneğin 8080, 6800 gibi işlemciler). Bunlara 8 bitlik mikroişlemci 
    deniyordu. Sonra 16 bitlik mikroişlemciler çıktı (örneğin Intel'in 8086, 8088 işlemcileri gibi). Bunu 32 bit işlemciler izledi. 
    Günümüzde artık ağırlıklı olarak 64 bit işlemciler kullanılmaktadır. Pekiyi bir işlemcinin N bitlik olmasının anlamı nedir? 
    Bu soruya yanıt verelim:

    - N bitlik bir işlemcide tek hamlede (yani tek bir makine komutuyla) N bit üzerinde işlem yapılabilmektedir. Örneğin 32 bitlik 
    bir mikroişlemcide tek bir makine komutu ile 32 bitlik iki sayısıyı toplayıp çarpabiliriz. 

    - N bitlik bir mikroişlemciler genellikle (ama her zaman değil) 2^N uzunlukta bir fiziksel RAM'i adresleyebilmektedir. Örneğin
    32 bitlik bir mikroişlemciye biz tipik olarak 2^32 = 4GB'lik bir RAM bağlaybiliriz. Elimizdeki RAM 64GB olsa bile 32 bit
    bir mikroişlemci bu RAM'in ancak ilk 4GB'sini kullanabilmektedir. Tabii bu durum her zmana böyle değildir. Örneğin 8086 
    işlemcisi 16 bit olduğu halde 2^16 değil 2^20 uzunlupunda (1MB) fiziksel belleği adresleyebiliyordu. Benzer biçimde bugünkü
    64 bitlik Intel ve AMD işlemcileri gereksiz olduğu gerekçesiyle 2^64 değil 2^48 uzuluğundaki RAM'leri adresleyebilmektedir. 

    - N bitlik bir mikroişlemcide genellikle işlemci ile RAM aarasında transfer N bit olarak yapılmaktadır. Örneğin 32 bitlik
    bir mikroişlemcide tek bir makine komutuyla RAM'den CPU'ya 32 bitlik bir veri transfer edilebilir.

    8 bitten 16 bite geçişte ve 16 bitten 32 bite geçişte çok farkedilir bir hızlanma yaşanmıştır. Ancak 32 bitten 64 bite geçişte 
    hızlanma öncekiler kadar olmamıştır. Bunun nedeni 64 bitlik işlemlerin aslında yoğun olarak yapılmadığındandır. Ancak 32 bitten
    64 bite geçişin en önemli etkisi işlemciye bağlanabilecek RAM miktarı üzerinde olmuştur. Örneğin elimizde 8 GB RAM'li 
    Raspberry Pi 5 olsun. Buradaki ARM cortex'i hem 32 bit hem de 64 bit işlemci gibi çalışabilmektedir. Dolayısıyla biz bu kartımıza
    32 bitlik de 64 bitlik de Linux yükleyebilriz. Ancak 32 bitlik Linux işletim sistemi işlemciyi 32 bit modda çalıştıracağı için 
    işletim sistemi 8GB RAM'in ancak 4GB'sini kullanabilecektir. Bu 8GB RAM'in tamamından istifade edebilmemiz için işlemcinin 
    64 bit modunda çalıştırılması dolayısıyla da işletim sisteminin 64 bit olması gerekecektir. 

    Pekiyi 128 bitlik işlemciler tasarlansa, bunlar daha hızlı bir çalışam sunmaz mı? Neden 128 bitlik işlemciler tasarlanmıyor? 
    İşte 128 bitlik tamsayı işlemlerine çok nadir gereksinim duyulmaktadır. 2^128 uzunlupunda RAM zaten şu an için erişilmesi 
    imkansız bir RAM miktarıdır. O halde işlemcilerin 64 bitten 128 bite çıkartılmasının şu an için önemli bir faydası olmayacaktır.
    Ancak tabii gelecekte böyle bir ihtiyaç ortaya çıkabilecektir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Popüler ürünlerde kullanılan ARM cortex'leri şunlardır:

    iPhone 14: Apple'ın A15 isimli SOC'unu kullanmaktadır. Bu SOC'un içerisinde Apple'ın ARMv8.6‑A versiyonunu kullanan Avalanche 
    Cortex'i vardır. Buradaki core'lar yalnızca 64 biti desteklemektedir. 
    
    iPhone 15: Apple'ın A16 isimli SOC'unu kullanmaktadır. Bu SOC'un içerisinde Apple'ın ARMv8.6‑A versiyonunu kullanan Evereset
    Cortex'i vardır. Buradaki core'lar yalnızca 64 biti desteklemektedir. 
    
    Apple M1 SOC: Apple'ın ARMv8.4‑A versiyonunu kullanan FireStorm isimli Cortex'i vardır. Buradaki core'lar yalnızca 64 biti 
    desteklemektedir. 
    
    Apple M2 SOC: Apple'ın ARMv8.6‑A versiyonunu kullanan Avalanche ve Blizzard isimli Cortex'leri vardır. Buradaki Core'lar
    yalnızca 64 biti desteklemektedir. 
    
    Apple M3 SOC: Apple'ın ARMv8.6‑A versiyonunu kullanan Avalanche ve Blizzard kullanan isimli Cortex'i vardır. Buradaki core'lar
    yalnızca 64 biti desteklemektedir. 
    
    Samsung Galaxy S24: Qualcomm firmasının Snapdragon-8 SOC'unu kullnamaktadır. Bu SOC içerisinde ARMv9-A versiyonunu kullanan 
    Cortex A715 bulunmaktadır.
    
    Redmi Note 11: Xiaomi firmasınn ürünüdür. Qualcomm Snapdragon-685 SOC'unu kullanmaktadır. Bu SOC'un içerisinde ARMV8.2-A 
    versiyonuna ilişkin Cortex A78 bulunmaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bu kursta kullanacğımız SBC'lerin üzerinde bulunan ARM cortex'leri ve bunların versiyon numaraları da şöyledir:
    
    Raspberry Pi 3: BCM2837 SOC'u kullanlmıştır. Bu SOC'un içerisinde ARMV8-A versiyonuna ilişkin Cortex-A53 bulunmaktadır. Bu 
    cortex'teki işlemciler hem 32 bit hem de 64 bit modda çalışabilmektedir. Dolayıyla bunlara 32 bit ve 64 bit Linux sistemleri 
    yüklenebilmektedir.
    
    Raspberry Pi 4: BCM2711 SOC kullanlmıştır. Bu SOC'un içerisinde ARMV8-A versiyonuna ilişkin Cortex-A72 bulunmaktadır.  Bu 
    cortex'teki işlemciler hem 32 bit hem de 64 bit modda çalışabilmektedir.  Dolayıyla bunlara 32 bit ve 64 bit Linux sistemleri 
    yüklenebilmektedir.
    
    Raspberry Pi 5: BCM2712 Bu SOC'un içerisinde ARMV8.2-A versiyonuna ilişkin Cortex-A76 bulunmaktadır. Bu cortex'teki 
    işelmciler hem 32 bit hem de 64 bit modda çalışabilmektedir. Dolayıyla bunlara 32 bit ve 64 bit Linux sistemleri 
    yüklenebilmektedir.
    
    BlackBone Black 4G ve BeagleBone Black Wireless: Texas Instruments firmasının Sitara-AM3358 SOC'unu kullanmaktadır. Bu SOC'un 
    içerisinde Cortex-A8 kullanılmıştır. Bu cortex 32 bit işlemcilerden oluşmaktadır. Bunların kullandığı komut mimarisi de 
    ARMV7-A'dır. BeagleBona Black'ler 32 bit ARM işlemcilerini kullandığı için bunlara yalnızca 32 bit Linux sistemleri
    yüklenebilmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                4. Ders 14/03/2024 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi de Raspberry Pi 5 donanımını inceleyelim. Kartın üzerinde BCM2712 SOC'u heme dikkati çekmektedir. Bu SOC'un hemen 
    yanında RAM chip'i bulunmaktadır. Raspberyy Pi 5'in 1GB, 2GB, 4GB ve 8GB RAM'li modelleri bulunmaktadır. Raspberry Pi 5 
    modelinde toplam 4 USB soketi bulunmaktadır. Bunlardan iki tanesi USB 2.0, diğer 2 tanesi de USB 3.0'dır. Klavye ve fare gibi 
    yavaş aygıtları USB 2.0 girişlerine bağlayabilrsiniz. Bunların hemen yanında Ethernet girişi bulunmaktadır. KEnarlarda toplam 
    40 tane (20'lik iki sıra) GPIO uçları bulunmaktadır. Bu GPIO uçları aygıtın dış dünya ile elektrisksel olarak haberleşmesin
    için kullanılmaktadır. Raspberry Pi 5'te iki Micro HDMI girişi bulunmaktadır. Bu uçlardan birine monitörümüzü bağlamalıyız.
    Raspberry Pi 5 modelinde arka tarafta SD kart girişine yakın bir bölgede çok küçük OO/OFF düğmesi bulunmaktadır. Bu düğme 
    bilgisayarlarımızdaki Power Off düğmesi gibidir. Ayrıca kamera ve LCD bağlamak için iki adet MIP DSI/CSI bulunmaktadır. 
    Kartın arka tarafında bir Micro SD kart girişi bulunmaktadır. Buraya disk görevini görecek olan micro SD kartımızı takacağız.
    Giriş kısmında da belirttiğimiz gibi şu an için 64GB'lik SD kartlar fiyat bakımından uygun bir büyüklüktür. Ancak denemeler 
    için birden fazla (bunlar daha küçük de olabilir) SD kart kullanabilirsiniz. Kart üzerindeki diğer bileşenlerin bazılarını 
    ilerleyen bölümlerde ayrıca ele alacağız.

    Kart üzerindeki bileşenleri inceleyebilmek için aşağıdaki bağlantıyı kullanabilirsiniz:

    https://grobotronics.com/raspberry-pi-5-4gb.html

    Raspberry Pi'ın resmi iki sitesi raspberrypi.com ve raspberrypi.org siteleridir. Raspberry Pi ile ilgili tüm dokümanlar 
    https://www.raspberrypi.com/documentation/ bağlantısından elde edilebilir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Raspberry Pi bir proje olarak özellikle az gelişmiş ülkelerde düşük fiyatlı bilgisayar oluşturmayı hedeflemiştir. Dolayısıyla
    biz Raspberry Pi'ı tamamen Linux tabanlı bir kişisel bilgisayar olarak kullanabiliriz. Kursumuzda önce Raspberry Pi'ın 
    kişisel bilgisayar olarak nasıl kullanıldığı üzerinde duracağız. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Raspberry Pi için birkaç işletim sistemi oluşturulmuştur. Ancak bunlardan en yaygın kullanılan ikisi Linux'un "Raspberry Pi 
    OS (eski ismiyle Raspbian)" ve "Ubuntu" dağıtımlarıdır. Raspberry Pi ile tam uyum içind eolan ana dağıtım "Raspberry Pi OS"
    dağıtımıdır. Biz en azından "Raspberry Pi OS" ve "Ubuntu" dağıtımlarını ayrı micro SD kartlara yüklemenizi tavsiye ediyoruz. 

    Bir bilgisayar sistemini reset ettiğimizde işletim sisteminin (ya da bu görevdeki yazılımın) yüklenmesini sağlayan mekanizmalara
    "boot loader" denilmektedir. Gömülü sistemlerde kullanılan "boot loader" mekanizmaları kursumuzun ayrı bir konusunu oluşturmaktadır. 
    Ancak kabaca boot işlemi şöyle gerçekleşmektedir: Biz mikroişlemciyi reset ettiğimizda çalışma belli bir adresten başlatılmaktadır. 
    Yani işlemci reset edildiğinde çalıştırılacak kodun önceden hazır bir biçimde kalıcı bir bellekte (bugün bunlar için flash 
    EPROM'lar kullanılmaktadır) bulunuyor olması gerekir. Buradaki kod çeşitli donanım birimlerini programlar ve onları kullanıma 
    hazır hale getirir. Sonra boot loader'ın işletim sisteminin yüklenmesinden sorumlu olan kısmı RAM'e yüklenir. Boot Loader'ın 
    bu kısmı işletim sistemini yükler. Zaten bu konular ileride ayrıntılarıyla ele alınacaktır. Bizim bu aşamada bilmemiz gereken 
    şey işletim sistemimizin micro SD karta nasıl yükleneceğidir. Çünkü bu işlem yapıldıktan sonra artık her şey otomatik 
    gerçekleşmektedir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Micro SD kartımıza işletim sisteminin yüklenmesi gelişi güzel yapılacak bir işlem değildir. Çünkü belli programların disk 
    üzerinde belli sektörlerde bulunuyor olması gerekmektedir. Bunu sağlamanın basit bir yolu önceden hazırlanmış bir imaj dosyasını 
    micro SD kartımıza aktarmaktır. Raspberry Pi için bu imaj dosyaları hazır bir biçimde zaten bulunmaktadır. O halde bizim 
    tek yapacağımız şey bu imaj dosyalarını indirip micro SD kartımızın içerisine aktarmaktır. Ancak son birkaç yıldır bu işlemin
    kolaylaştırılması için Raspberry Pi ekibi "Raspberry Pi Imager" denilen bir program geliştirmiştir. Bu program menüler
    eşliğinde kullanıcının istediği işletim sisteminin imaj dosyasını indirip micro SD karta bunları yazmaktadır. Dolayısıyla 
    bu program işimizi hepten kolaylaştırmaktadır. Raspberry Pi İmager programını aşağıdaki bağlantıdan indirebilirsiniz:

    https://www.raspberrypi.com/software/

    RaspberryImager programı indirilip kurulup çalıştırılınca program bize üç şey sormaktadır? 

    1) Hangi Rasperry Pi Modelini kullandığımızı
    2) Hangi işletim sistemini yükleyeceğimizi 
    3) Hangi micro SD karta yüklemeyi yapacağımızı

    Bu sorulara yanıt verdikten sonra yüklenecek Linux üzerinde bazı basit konfigürasyon işlemleri de "Edit Setting" seçeneği 
    yapılabilmektedir. Tabii bunları yüklemeden sonra da yapabiliriz. 

    Raspberry Pi Imager her şeyi kendisi yapmaktadır. Program önce ilgili imajı yerel makineye indirir, sonra da micro SD karta 
    yazma yapar. 

    Tabii biz Raspberry Pi Imager programını kullanmak zorunda değiliz. Zaten bu program eskiden yoktu. Eğer bu programı kullanmayacaksak
    işletim sistminin SD kart imajını indirip SD karta yazma yapan bir programla onu karta aktarmamız gerekir. SD karta aktarma 
    yapan pek çok bedava program vardır. Bunlşardan en popüler iki tanesi "Rufus" ve "Etcher" programlarıdır. Manuel kurulum 
    için işletim sistemi imajlarını aşağıdaki bağlantıdan indirebilirsiniz:

    https://www.raspberrypi.com/software/operating-systems/

    Artık her şey hazırdır. Bundan sonra şu bağlantıları yapmalısınız:

    1) SD kartınızı Raspberry Pi'ınıza yerleştiriniz.
    2) Monitörünüzü Raspberry Pi'ınızın micro HDMI soketine takınız.
    3) Klavye ve Farneinizi Raspberry Pi'ınızın USB soketlerine takınız.
    4) USB Type-C soketi ile Raspberry Pi'ınıza güç veriniz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                    5.Ders 19/03/2024 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Gömülü sistemimize Linux'u kurduktan sonra ona başka bir makineden erişmek isteyebiliriz. Bunun çeşitli yolları varsa da 
    en tipik üç yöntem kullanılmaktadır:

    1) ssh protokolü ile erişim 
    2) VNC protokolü ile erişim
    3) Microsoft Remote Desktop Protokolü (RDP) ile erişim

    VNC ve RDP ile gömülü aygıtımızdaki Linux'a erişebilmemiz için orada bir pencere yönetici programın (yani masaüstü sisteminin)
    kurulu olması gerekir. RSapberry Pi güçlü bir donanıma sahip olduğu için ve kişisel bir bilgisayar gibi kullanılabildiği için
    buraya yüklediğimiz Linux sistemlerinde pencere yöneticisi zaten bulunuyor olacaktır. Ancak server sistemlerinde ve pek çok 
    gömülü Linux sisteminde bir pencere yöneticisi bulunmamaktadır. Bu durumda ssh protokolü ile erişim sağlanmakaktadır. Eskiden 
    ssh protokolünden önce telnet isimli benzer bir protokol vardı. Ancak telnet protokolünün güvenilirliği zayıf olduğu için 
    ssh protokolü geliştirildi. Bugün konsol tabanlı bir ortamda bir Linux sistemine uzaktan bağlanmak için genellikle ssh protokolü 
    kullanılmaktadır. 
    
    Her türlü TCP/IP uygulamalarında haberleşmenin yapılabilmesi için bir "server" program ile bir de "client" programın bulunuyor 
    olması gerekir. Bize erişimi sağlayan uzak makinedenki program "server" programdır. Bizim erişmek için kullandığımız program 
    ise "client" programdır. ssh server ve client programlar zaten işletim sistemlerinin pek çoğunun içinde default bir biçimde 
    bulunmaktadır. Biz Raspberry Pi'ımıza Raspberry OS işletim sistemini kurduğumuzda zaten ssh client ve server programlar yüklü 
    durumdadır. Ancak eğer gömülü sisteminizde ssh server program bulunmuyorsa onu şöyle kurabilirsiniz:

    $ sudo apt-get install openssh-server

    Bu işlem sshserver programının kurulup çalışır hale getirilmesini sağlamaktadır. client program da benzer biçime kurulabilir:

    $ sudo apt-get install openssh-client

    ssh client ptogramıyla bağlantı aşağıdaki gibi sağlanabilir:

    ssh user_name@host_name

    Bizim bağlantı sağlayabilmek için uzak makinede bir kullanıcının ismini ve parolasını biliyor olmamız gerekir. ssh client programı 
    benzer komut satırı argümanlarıyla Windows sistemlerinde ve macOS sistemlerinde de hazır bir biçimde bulunmaktadır. Dolayısıyla
    Windows ve macOS sistemlerinden de gömülü aygıtınıza benzer biçimde bağlanabilirsiniz. ssh programı ile bağlantı yapılırken kullanıcı 
    ismini "-l" seçeneği ile de belirtebilirsiniz. Örneğin:

    ssh -l user_name host_name

    VNC ile bağlantıda yine bir VNC server programıyla bir de VNC client programının karşılıklı makinelerde yüklü olması gerekmektedir. 
    Bizim bağlanmak istediğimiz makinede server programının çalışıyor olması, bağlantıyı sağlamak istediğimiz tarafta da client progmın 
    yüklü olması gerekir. Raspberry Pi'daki eski Raspbian işletim sisteminde VNC server hazır bir biçimde bulunmuyordu. Ancak belli 
    süre sonra artık Raspberry Pi OS içerisinde zaten VNC server programı hazır bir biçimde bulunmaktadır. Ancak VNC server hazır 
    bir biçimde bulunuyor olsa da onun çalışır getirilmesi gerekmektedir. Bu işlem pratik olarak ana menüden Preferences/Raspberry Pi 
    Configurations/Interfaces sekmensinden yapılabilir. Yukarıda da belirttiğimiz gibi VNC server için Linux sistemimizde bir pencere 
    yöneticisinin çalışıyor olması gerekir. Yani içerisine grafik arayüz yüklenmemiş olan bir Linux sistemine VNC ile bağlanmanın da 
    bir anlamı yoktur. 

    VNC server ve client program olarak çeşitli programlar kullanılabilmektedir. Linux'ta en yaygın kullanılan VNC server program
    "tightvncserver" isimli programdır. Bunun kurulumu şöyle yapılabilir:

    $ sudo apt-get install tightvncserver

    Ancak server program kurulduktan sonra bazı ayarlamaların yapılması gerekmektedir. Bu konu ileride başka bir bölümde ele 
    alınacaktır. 

    Biz pencere yönetici sistemin bulunduğu bir Linux sistemine Microsoft'un "Remote Desktop Protocolünü (RDP)" kullanarak da 
    bağlanabiliriz. Tabii bunun için de bağlanacağımız makinede RDP server programının çalışıyor durumda olması gerekmektedir. 
    Bu protokol Microsoft'a ait olduğu için Linux sistemleri tarafından aktif bir biçimde kullanılmamaktadır. RDP server programı
    aşağıdaki gibi kurulabilir:

    $ sudo apt-get install xrdp

    RDP protokülü için client program olarak genellikle Windows'taki "Uzak Masaüstü Bağlantısı" kullanılmaktadır. Ancak bu 
    protokol için başka client programlar da bulunmaktadır.

    VNC ve RDP protokolleri hem Linux sistemlerinde hem de Windows ve macOS sistemlerinde kullanılabilmektedir. Windows dünyasında
    RDP programları hızlı bir biçimde çalışmaktadır. Ancak Linux'ta VNC programları RDP programlarına göre daha hızlıdır. Windows'ta 
    da RDP programları VNC programlarına göre daha hızlıdır. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    BeagleBoard'lar en yaygın kullanılan SBC'ler arasındadır. Biz de kursumuz Beaglebone Black (BBB) kullanacağımızı söylemiştik.
    BBB'nin dokümantasyonuna aşağıdaki bağlantıdan erişilebilir:

    https://docs.beagleboard.org/latest/https://docs.beagleboard.org/latest/

    BBB kendi içerisinde ismine "eMMC (Embedded Multi-MEdia Card)" denilen on-board flash belleğe sahiptir. Zaten ürün satın 
    alındığında vu flash belleğin çerisinde bir Debian Linux dağıtımı yüklü durumdadır. Bu nedenle biz board'umuzu güç kaynağına 
    taktığmızda zaten default olarak bu on-board flash içerisindeki Linux boot edilmektedir. BBB'yi kullanıma hazır hale getirmek 
    için şunlar yapılmaldır:

    1) BBB'ye güç kaynağını bağlamak için iki soket kullanılabilmektedir. Birincisi eski tip yuvarlak sokettir (DC barrel jack). 
    İkincisi ise mini USB soketidir. Kullanıcılar genellikle güç kaynağını mini USB soketine bağlamaktadır. (Tabii bu mini USB 
    girişi doğrudan masaüstü bilgisayarımızın USB girişine bağlanabilir. Bu durumda gücü buradan alacaktır.)

    2) BBB üzerinde bir tane standart USB soket vardır. Genellikle bu sokete combo klavye fare bağlanmaktadır. Ancak birden fazla
    bağlantı için USB hub kullanılabilir. 

    3) BBB'nin klasik modellerinde Internet için "wireless" bağlantı yoktur. Dolayısıyla Internet bağlantısı sağlamak için ethernet
    soketi kullanılmaktadır. Ancak on-board flash üzerine yükllenmiş olan Debian içerisinde "Internet over USB" için gerekli aygıt
    sürücüler (device drivers) bulunmaktadır. Bu sayede biz örneğin mini USB kablosu ile BBB'yi Windows ya da Linux makinemize 
    bağlayıp  BBB'nin oradaki Internet'i kullanmasını sağlayabiliriz. 

    4) BBB'de de Raspberry Pi'da olduğu gibi micro HDMI soketi vardır. Bu sokete doğrudan monitörümüzü bağlayabiliriz. 
    
    Tipik olarak BBB'yi ilk kez kullanırken mini USB soketini masaüstü bilgisayarımızın standart USB soketine takarız. Böylece
    masaüstü bilgisayarımız otomatik olarak BBB'nin on-board flash belleğindeki bir disk bölümünü bir sürücü biçiminde görür. 
    Bu sürücü içerisinde host sistem için gerekli olan aygıt sürücüler bulunmaktadır. Eğer host makine olarak Windows'ta çalışıyorsak 
    aygıt sürücüleri yüklerken "UEFI BIOS'tan imzasız aygıt sürücüleri için" izin vermemiz gerekir. Bunun için aşağıdaki bağlantıdaki 
    yönergeleri izleyebilirsiniz:

    https://www.terasic.com.tw/wiki/Disable_Driver_Signature_Enforcement_in_Windows10_x64
    
   Biz bu biçimde USB bağlantısı yaptığımızda artık IP ptotokol ailesini USB üzerinden kullanabilir duruma geliriz. Dolayısıyla
   ssh ile BBB'ye bağlanabiliriz. BBB'de yüklü olan Debian dağıtımının default kullanıcı ismi "debian" default parolası ise "temppwd"
   biçimindedir. Tabii hazır yüklü olan Linux dağıtımının klavye ayarları İngilizcedir. Türkçe klavye ile yazarken buna dikkat 
   ediniz. ssh bağlantısı için BBB'deki IPV4 adresi "192.168.7.2" biçimindedir. Yani bağlantı aşağıdaki gibi yapılabilir:

   $ ssh debian@192.168.7.2

   parola olarak da "temppwd" girilmelidir. On-board flash üzerine yüklenmiş olan Debian dağıtımında bir pencere yönetici program
   bulunmamaktadır. Zaten BBB'nin on-board flash belleği 4GB'dir. 

   Biz BBB'nin mini USB kablosunu host makinemize bağladığımızda artık host makinemizden BBB'ye ssh yoluyla erişebiliriz. Ancak
   BBB'deki Linux sisteminin masaüstü host makinemizdeki Internet'i kullanabilmesi için Windows ve Linux sistemlerinde bazı 
   ayarların da yapılması gerekmektedir. Tabii BBB'nin Internet'i kullanabilmesini sağlamanın en normal ve hızlı yolu doğrudan 
   ADSL Router'ımızdan gelen Ethernet RJ45 jakını BBB'ye takmaktır. Biz "Internet over USB" yerine bu yöntemi kullanmanızı 
   öneriririz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                6. Ders 21/03/2024 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    BBB'ni on-board flash belleğine işletim sisteminin yeni bir sürümümü yerleştirebiliriz. Aslında Beagleboard için hazır imajlar
    zaten bulundurulmaktadır. Aşağıdaki bağlantıdan size uygun olan hazır imajları indirebilirsiniz:

    https://www.beagleboard.org/distros

    On-board flash belleğe işletim sistemini yüklemek için sırasıyla şu adımlardan geçilmelidir:

    1) Yukarıda belirttiğimiz sayfadan BBB için uygun sürüm indirilir. Bu sayfadaki hazır imajların bir bölümünde "Flasher" 
    ibaresi vardır. Bu "flasher" ibareli imajlardan biri indirilmelidir. Örneğin sınıftaki denemede aşağıdaki imaj indirilmiştir:
    
    AM335x 11.7 2023-09-02 4GB eMMC IoT Flasher

    Buradaki "IOT" sözcüğü indirilecek Debian dağıtımının IOT amaçla oluşturulmuş minimalist bir dağıtım olduğunu belirtmektedir. 
    Örneğin alternatif bir imaj da şu olabilir:

    AM335x 11.7 2023-09-02 4GB eMMC Xfce Flasher

    Burada "IOT" ibaresi yerine "Xfce" ibaresi bulunmaktadır. Xfce küçük bir pencere yöneticisidir. Ancak maalesef bu pencere 
    yöneticisi bile BBB'nin pek çok verisyonunda sistem kısıtları nedeniyle çok yavaş çalışma eğilinindedir. 

    2) İndirilen imaj zip'li olduğu için açılmalıdır. Açılan imajın uzantısının ".img" olması gerekir. 

    3) İmaj SD karta Rufus ya da Etcher benzeri bir programla yazılmalıdır. 

    4) SD karta yazma işlemi bittikten sonra SD kart BBB'nin SD kart yuvasına takılır. Sonra "Boot switch" denilen küçük düğmeciğe
    basılarak board'a güç verilir. Güç verildikten sonra 7, 8 saniye boot switch'e basılmaya devam edilmelidir. Sonra el boot 
    switch'ten çekilir. BBB'nin dört LED'i önce tamamen yanar. Sonra sırasıyla yanıp sönmeye başlar. Bu durum yazmanın başladığı
    anlamına gelmektedir. Yazma takriben 5 dakika civarında sürmektedir. Yazma bittikten sonra LED'ler tamamen söner. Boot switch
    Micro SD kartın yanındaki switch'tir.

    5) SD kart çıkartılarak sistem yeniden boot edilir. Artık on-board flash üzerine çektiğimiz işletim sistemi ile boot işlemini
    yapmış olduk. Ancak bizim indirdiğimiz imaj İngilizce (US) olarak ayarlanmıştır. Dolayısıyla default klavye ayarları da 
    İngilizce klavye biçimindedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Debian türevi sistemlerde klavye ayarlarını değiştirmenin birkaç yolu vardır. Öncelikle locale ayarlarının Türkiye ve Türkçe 
    biçiminde yapılmasını tavsiye ederiz. Çünkü BBB için hazır bulundurulan Debian dağıtımında default locale ayarları Amerika 
    ve İngilizce biçimindedir. Bunu sağlamanın bir yolu aşağıdaki komutu kullanmaktadır:

    $ sudo dpkg-reconfigure locales 

    Karşımıza bir menü gelecektir. Bu menüden locale'i "tr_TR.UTF-8" biçiminde ayarlayabilirsiniz. Bu ayarlamadan sonra artık 
    /etc/default/locale dosyası aşağıdaki gibi olacaktır:

    #  File generated by update-locale
    LANG=tr_TR.UTF-8 

    Ancak locale'in ayarlanması klavye düzenini değiştirmemektedir. Locale'in ayarlanması birtakım mesajların Türkçe çıkmasını, 
    terminal aygıt sürücüsünün girdi ve çıktılarının encoding'ini belirlemektedir. Klavye düzeni manuel olarak "/etc/default/keyboard"
    dosyası üzerinde güncelleme  yapılarak ayarlanabilir. Bu dosyanın BBB'deki default içeriği şöyledir:

    # KEYBOARD CONFIGURATION FILE
    # Consult the keyboard(5) manual page.

    XKBMODEL="pc105"
    XKBLAYOUT="us"
    XKBVARIANT=""
    XKBOPTIONS=""
    BACKSPACE="guess"

    Bizim Türkçe klavye için buradaki XKBLAYOUT satırını aşağıdaki gibi değiştirmemiz gerekir:

    XKBLAYOUT="tr"

    Ancak bu dosyada değişiklik yapılması klavye düzeninin değişeceği anlamına gelmemektedir. Bu ve birkaç dosyaya bakarak klavye 
    düzenini ayarlayan bazı programlar vardır. Bunların çalıştırılması gerekir. Bunun için "setupcon" programı kullanılabilir:

    $ sudo setupcon

    Artık klavyemiz Türkçe olarak ayarlanmıştır. Ancak iki problem daha vardır. Birincisi BBB'deki Debian dağırtımındaki default 
    console fontu Türkçe'yi desteklememektedir. Yani klavyedeki tuşların yerleri doğru olarak ele alınmaktadır ama Türkçe 
    karakterler doğru görüntülenememektedir. İkinci sorun ise BBB'yi reboot ettiğimizde yaptığımız ayarların otomatik devreye 
    girmemesidir. 

    Console ekranının fontunu değiştirmek için "/etc/default/console-setup" dosyasının edit edilmesi gerekmektedir. Bu dosyasının 
    BBB'deki default durumu şöyledir:

    # CONFIGURATION FILE FOR SETUPCON
    # Consult the console-setup(5) manual page.

    ACTIVE_CONSOLES="/dev/tty[1-6]"
    CHARMAP="ISO_8859-15"
    CODESET="guess"
    FONTFACE="Fixed"
    FONTSIZE="8x16"
    VIDEOMODE=
    # The following is an example how to use a braille font
    # FONT='lat9w-08.psf.gz brl-8x8.psf'

    Bizim burada CHARMAP satırını aşağıdaki gibi UTF-8 olarak güncellememiz gerekir:

    CHARMAP="UTF-8"

    Şimdi artık sistemi reboot ettiğimizde login ekranındaki klavye düzeni İngilizce olsa da login olup "setupcon" programını 
    çalıştırdığımızda her şey Türkçe'ye göre ayarlanmış olacaktır. 

    Biz klavyeyi ve console fontlarını ayarlarken bazı dosyaları güncelledik. Aslında bu dosyaları manuel olarak edit etmek yerine 
    bunları güncelleyen küçük programlardan da faydalanılabilir. Örneğin aslında "sudo dpkg-reconfigure locales" komutu 
    "/etc/default/locale" dosyası üzerinde güncelleme yapmaktadır. Benzer biçimde "sudo dpkg-reconfigure console-data" komutu 
    da aslında "/etc/default/console-setup" dosyasını güncellemektedir. Bazen klavye ayaralarını çalışırken o anda başka bir dille 
    de değiştirmek isteyebiliriz. Bunun için "loadkeys" isimli program kullanılmaktadır. Bu program klavye düzenek dosyasını 
    argüman olarak alıp klavyeyi ona göre ayarlamaktadır. 

    Yukarıda da belirttiğimiz gibi biz Türkçe ayarlarını yapmış olsak da bu ayarları etkili hale getirmek için "setupcon" 
    programını çalıştırmamız gerekir. Bu nedenle BBB'mizi reboot ettiğimizde login ekranında yine klavye İngilizce'de kalacaktır. 
    Bunu kalıcı ayarlamanın bir yolu "sudo update-initramfs -u" işlemidir. Diğer yolu ise sistem boot edildiğinde otomatik olarak 
    bu "setupcon" programının çalıştırılmasını sağlamaktır. Bu konular ileride ele alınacaktır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki ayarlama işlemlerinden de görüldüğü gibi aslında birtakım ayarlar "/etc" dizinini altındaki çeşitli dosyalarda 
    saklanmaktadır. Çeşitli programlar da ayarları bu dosyalara bakarak set etmektedir. Microsoft eskiden Linux'takilere benzer
    ismine "ini dosyaları" denilen ayar dosyalarını kullanıyordu. Daha sonra "registry" denilen tüm ayarların saklandığı mini 
    bir hiyerarişik veritabanı sistemine geçti. Ancak UNIX/Linux sistemlerinde böyle bir merkezi ayar sistemi kullanılmamaktadır. 
    Her ayar "/etc" dizininin altında belli formattaki dosyaların içerisinde saklanmaktadır. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Sizin de gördüğünüz gibi Raspberry Pi donanımı BBB'ye göre oldukça güçlüdür. Raspberry Pi'ın SD kartına yüklediğimiz 
    işletim sistemleri oldukça dolu bir biçimdedir. Çünkü bu sistemler tam bir bilgisayar gibi kullanılsın istenmiştir. Halbuki
    BBB'nin kaynakları zayıf olduğu için hazır imajlar genellikle dolu bir biçimde değildir. Örneğin UNIX/Linux sistemlerinde 
    yardım almak için kullanılan "man" programı BBB'nin default imajında bulunmamaktadır. man programını ve onun kullandığı 
    önemli veri dosyalarını aşağıdaki gibi yükleyebiliriz:

    $ sudo apt install man-db manpages-posix
    $ sudo apt install manpages-dev manpages-posix-dev
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    BBB'yi on-board flash (eMMC) üzerine yüklü olan Linux sistemiyle açmak zorunda değiliz. SD kartımıza Linux kurup SD kart ile 
    de boot edebiliriz. SD karttan boot işlemi için yine "boot switch"e basılı olarak board'a güç verilir. Led'ler yandığında 
    basılı olan boot switch'ten el bırakılır. Böylece boot işlemi SD karttan harekeetle başlatılacaktır. BBB kartlarının ileri 
    sürümlerinde SD karttan boot işlemi için boot switch'e basmaya gerek kalmamıştır. Bu ileri modellerde SD kart takılıysa 
    zaten boot işlemi SD karttan başlatılmaktadır. SD karta yazacağınız Linux sistemine dikkat ediniz. Buraya "flasher" olmayan 
    bir imajı yerleştirmelisiniz. SD kartınıza yükleyceğiniz hazır Debian imajını aşağıdaki bağlantıdan indirebilirsiniz:

    https://www.beagleboard.org/distros

    Örneğin buradan SD kartınız için aşağıdaki imajı indirebilirsiniz:

    AM335x 11.7 2023-09-02 4GB microSD IoT

    Beagleboard Black kartınızın boot süreci kursumuzun ayrı bir bölümünde ayrıntılı bir biçimde ele alınacaktır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                        7. Ders 26/03/2024 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kursumuzun bu bölümünde gömülü Linux sistemlerinde C/C++ ile yazılım geliştirmek için kullanılan toolchain'ler üzerinde
    duracağız. Kursumuzda "toolchain" sözcüğünü bazen bu biçimde İngilizce olarak bazen de "araç zinciri" biçiminde Türkçe 
    olarak kullanacağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Aşağı seviyeli (C/C++, sembolik makine dilleri) biçimde yazılım geliştirmek için kullanılan araçlardan oluşan topluluğa 
    "araç zinciri (toolchain)" denilmektedir. Bir araç zincirinin tipik bileşenleri şunlardır:

    - C ve C++ Derleyicileri (C and C++ Compilers)
    - Sembolik Makine Dili Derleyicileri (Assemblers)
    - Bağlayıcılar (Linkers)
    - Binary Araçlar (Binary Utilities). Bu araçlar aşağı seviyeli işlemler için gerekebilen programlardan oluşmaktadır. 
    - Debugger'lar. Bunlar hataların tespit edilmesi ve çözümlenmesi amacıyla kullanılmaktadır.
    - C ve C++'tan kullanılabilecek temel kütüphaneler. (Örneğin standart C kütüphanesi, POSIX kütüphanesi gibi.)
    - Emülatörler ve Simülatörler (Emulators amd Simulators). Her türlü araç zincirinde bu bileşenler bulunmayabilir.
    - Build Otomasyon Araçları (Build Automation Tools). Örneğin make ve cmake gibi araçlar. 
    - Geliştirme İçin Gerekli Olan Diğer Dosyaların Bulunduğu "sysroot" Dizini. Programların derlenip bağlanabilmesi için
    bazı öğelerin bazı dizinler içerisinde bulunması gerekmektedir. 

    Her araç zincirinin bu öğelerin hepsini içermesi gerekmez. Bazı araç zincirleri de daha fazla öğe de içerebilir. Burada bir 
    noktaya dikkatinizi çekmek istiyoruz. Gömülü Linux sistemlerinde "araç zinciri (toolchain)" demekle "aşağı seviyeli araçlar"
    kastedilmektedir. Yani örneğin araç zincirleri içerisine Java, .NET, Python gibi platformlarda yazılım geliştirmek için 
    gerekli olan araçlar dahil değildir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kursumuzda kimi zaman çapraz derleme (cross compile) işlemleri yapacağız. Bu durumda host makine ile hedef makine arasında 
    dosya transfleri yapmamız gerekecek. İki makine arasında dosya transferi yapmak için genellikle IP prtokol ailesinin sunduğu 
    olanaklar kullanılmaktadır. Bunun için en çok kullanılan utility program "scp" isimli programdır. Bu program "Secure Copy 
    Protocol" denilen bir protokol yoluyla arka planda ssh kullanarak dosya transferini yapmaktadır. scp programının tipik 
    kullanımı şöyledir:

    $ scp dosya_yol_ifadesi kullanıcı_ismi@uzak_makine

    Burada uzak_makine ip adresi ya da host ismi biçiminde belirtilebilir. Örneğin:

    $ scp app debian@192.168.7.2:

    Burada app dosyası uzak makinenin debian kullanıcısının home dizinine kopyalanmaktadır. (host isminden sonra ':' 
    karakterinin bulundurulması zorunludur.) Örneğin:

    $ scp app debian@192.168.7.2:/Test

    Burada app dosyası uzak makinedeki debian kullanıcısının home dizini içerisindeki Test dizinine kopyalanacaktır. Tabii scp 
    ile hedef makineden host makineye ters yönde de kopyalama yapabiliriz. Örneğin:

    $ scp debian@192.168.7.2:app app

    Burada hedef makinedeki app dosyası app ismiyle host makineye kopyalanmaktadır. scp ile bir dizin bütünsel olarak da transfer 
    edilebilir. Bunun için "-r" seçeneğinin kullanılması gerekmektedir. Örneğin:

    $ scp -r Src debian@192.168.7.2:

    Burada yerel makinedeki Src dizininin tamamı uzak makineye kopyalanmaktadır. 

    scp programının ayrıntıları için ilgili man sayfalarına başvurabilirsiniz. 

    Uzak makineye dosya transfer etmek için diğer pratik bir yöntem de "sshfs" denilen dosya sistemini kullanmaktır. Bu dosya 
    sistemi uzak makinedeki bir dizini yerel makinede bir dizin gibi göstermektedir. Böylece biz o dizine dosya kopyaladığımızda 
    sshfs dosya sistemi onu otomatik olarak hedef makineye transfer etmektedir. Tabii sshfs Linux sistemlerini kurduğumuzda sistemin 
    bir parçası biçiminde yüklü durumda değildir. Onun aşağıdaki gibi indirip kurabiliriz:

    $ sudo apt-get install sshfs

    Kurulumu yaptıktan sonra yerel makinede mount edilecek dizini yaratmamız gerekir. Örneğin:

    $ mkdir BBB

    Artık mount işlemini şöyle yapabiliriz:

    $ sshfs BBB debian@192.168.7.2:

    Artık BBB dizinimiz uzak makinedeki kullanıcının home dizini gibi olmuştur. Yani biz bu BBB dizinine dosya kopyaladığmızda 
    aslında onu uzak makineye kopyalamış oluruz. Bezer biçimde uzak makinede home dizinine bir dosya kopyalandığında biz bu 
    dosyayı BBB dizininde otomatik olarak görürüz. 

    Mount ettiğimiz dizininin uzak bağlantı yaptığımız makineden kopartılması için "umount" işleminin uygulanması gerekir.
    umount komutunda dizin ismi argüman olarak verilmektedir. Örneğin:

    $ umount BBB

    Yerel makine ile uzak makine arasında dosya transfer etmenin diğer bir yolu da FTP (File Tranfer Protocol) protokülünü 
    kullanmaktır. Ancak bunun için uzak makinede bir FTP sunucusunun yüklü olması gerekir. Düşük kapasitei gömülü aygıtlarda 
    geliştirici bu server'ı uzak makineye yüklemek istemeyebiir. FTP server ve client programların Linux sistemlerine nasıl 
    kurulacağını ilgili dokğmanlardan öğrenebilirsiniz. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Araç zincirlerini iki bölüme ayırabiliriz:

    1) Doğal Araç Zincirleri (Native Toolchains)
    2) Çapraz Araç Zincirleri (Cross Toolchains)

    Doğal araç zincirleri genellikle dağıtımların içerisinde zaten hazır bir biçimde bulunmaktadır. Örneğin Raspberry Pi için 
    Raspberry Pi OS'yi yüklediğimizde, Beaglebone Black için Debian dağıtımını yüklediğimizde zaten onun içerisinde doğal araç 
    zincirleri bulunmaktadır. Doğal araç zincirleri doğrudan ilgili sistem üzerinde yazılım geliştirilirken kullanılmaktadır. 
    Örneğin biz Raspberry Pi için yazılımımızı doğrudan Raspberry Pi üzerinde geliştirebiliriz. Bu durumda orada yüklü olan doğal 
    araç zincirini kullanabiliriz. Raspberry Pi donanımları (özellikle 4 ve 5) çok güçlü olduğu için doğal araç zincirleri ile 
    geliştirme yapmak artık iyi bir seçenek durumundadır. Ancak Beaglebone Black gibi aygıtların sistem kaynakları daha kısıtlı 
    olduğu için doğrudan bunların üzerinde geliştirme yapmak zor hatta bazen olanaksız hale gelebilmektedir. 

    Çapraz araç zincirleri (cross toolchains) geliştirmenin güçlü bir makine üzerinde yapılmasını sağlayan, hedef aygıt için kod 
    üreten araç zincirleridir. Buradaki çapraz (cross) sözcüğü üretilen kodun geliştirmenin yapıldığı makineye değil başka bir 
    hedef (target) makineye ilişkin olduğunu belirtmektedir. Eğer hedef makine etkin bir geliştirme yapmaya olanak sağlamıyorsa 
    bu durumda çapraz araç zincirleri kullanılabilir. Örneğin Beaglebone Black için tipik olarak çapraz araç zincirleri kullanılmaktadır.

    Pekiyi doğal araç zincirleri mi yoksa çapraz araç zincirleri mi tercih edilmelidir? İşte eğer Raspberry Pi'da olduğu gibi 
    hedef donanım güçlüyse doğal araç zincirlerinin kullanılmasını tavsiye ederiz. Çünkü doğal ortamda geliştirme yapılırken denemeler
    o anda geliştirme yapılan makinede çok daha hızlı yapılabilmektedir. Ancak hedef makine yeteri kadar güçlü değilse güçlü bir
    host makşinede çapraz araç zincirleriyle geliştirmenin yapılmasını öneririz. Araç zinciri denildiğinde zaten default olarak
    çapraz araç zincirleri kastedilmektedir. 

    Araç zincirlerini başka bakımlardan da sınıflandırabiliriz.  Örneğin araç zincirini "tedarik eden (vendor)" kuruma göre, 
    kullanılan derleyici sistemlerine göre de sınıflandırılabiliriz. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Araç zincirlerinin isimlendirilmesi genellikle "hedef (target) sisteme" göre yapılmaktadır. İsimlendirmede '-' karakterleriyle
    ayrılmış üç alan ya da dört alan kullanılabilmektedir. Üçlü (triple) isimlendirmede ismin alanları şunlardır:

    CPU-Tedarikçi-İşletimSistemi

    Dörtlü isimlendirmede ayrıca bir de ABI alanı bulundurulmaktadır. Dörtlü isimlendirmenin de genel biçimi şeyledir:

    CPU-Tedarikçi-İşletimSistemi-ABI

    Buradaki bileşenlerin hepsi hedef makineye ilişkin bileşenlerdir. Ancak araç zincirlerindeki isimlendirme biçimi herkes tarafından 
    uyulan, resmi bir standardı olan kural niteliğindeki biçimler değildir. Gevşek kurallardır. Üçlü ya da dörtlü isimlendirmeye 
    uymayan ya da kısmen uyan araç zincirleri de bulunmaktadır.
    
    Şimdi bazı örnekler vermek istiyoruz. Örneğin:

    i686-apple-darwin10-gcc-4.2.1

    Bu araç zinciri Intel'in 32 bit işlemcilerine ilişkin (X86) kod üretilmektedir. Tedarikçi (vendor) Apple şirketidir. Yani araç 
    zinciri Apple firması tarafından hazırlanmıştır. Hedef işletim sistemi darwin10'dur. Yani oluşturulacak kod bu işletim sistemi 
    tarafından çalıştırılacaktır. (macOS işletim sisteminin kernel'ına "Darwin" denilmektedir. Dolayısıyla buadaki Darwin aslında macOS 
    anlamındadır.) Kullanılan ABI versiyonu gcc-4.2.1 tarafından kullanılan default ABI'yi belirtmektedir. Örneğin:

    arm-none-linux-gnueabi

    Burada ARM kodu üretilmektedir. Tedarikçinin olmaması bunun manuel üretildiği anlamına gelebilmektedir. Burada yine kodun Linux 
    işletim sistemi için üretileceği belirtilmektedir. ABI için kullanılan "gnueabi" tipik olarak GNU araç zincirini ve gömülü
    sistemler için kullanılan ABI'yi belirtmektedir. (Buradaki eabi "extended abi" anlamına gelmektedir.). Örneğin:

    arm-linux-gcc

    Burada ARM üzerinde çalışan Linux sistemleri için kod üretilecektir. gcc derleyicisinin o sistemdeki default ABI'si 
    kullanılacaktır. Örneğin:

    i686-unknown-linux-gnu
    
    Burada tipik olarak 32 bit Intel işlemcileri üzerinde çalışan Linux sistemleri için kod üretilecektir. ABI bu sistemlerde 
    kullanılan default ABI'dir. Buradaki "gnu" GNU araç zincirini belirtmektedir. Örneğin:

    x86_64-w64-mingw32

    Buradaki araç zinciri 64 bit Intel işlemcilerini kullanan 64 bit Windows sistemleri için kod üretmektedir. Araç zinciri 
    MinGW dağıtımını referans almaktadır. Dolayısıyla oradaki ABI'yi kullanmaktadır. Örneğin:

    arm-none-eabi

    Burada ARM kodu üretilmektedir. Ancak herhangi bir işletim sistemi hedef alınmamıştır. İşletim sisteminin belirtilmediği 
    durum genellikle "bare metal" araç zinciri anlamına gelmektedir.

    Örneğin Windows'ta sanal makineye kurduğumuz Intel işlemcisini kullanan Mint dağıtımındaki gcc derleyicisinin izini sürelim:

    $ whereis gcc
    gcc: /usr/bin/gcc /usr/lib/gcc /usr/share/gcc /usr/share/man/man1/gcc.1.gz
    $ ls -l /usr/bin/gcc
    lrwxrwxrwx 1 root root 6 Mar 19 21:29 /usr/bin/gcc -> gcc-11
    $ ls -l /usr/bin/gcc-11
    lrwxrwxrwx 1 root root 23 Mar 19 21:29 /usr/bin/gcc-11 -> x86_64-linux-gnu-gcc-11

    Buradaki araç zinciri isimlendirmesinden şu anlaşılmaktadır: Buradaki gcc derleyici 64 bit Intel işlemcilerine ilişkin kod 
    üretmektedir. Söz konusu kod Linux sisteminde çalıştırılmak için üretilmektedir. GNU'nun araçları ve ABI'si kullanılmıştır. 
    Şimdi de BBB'deki Debian dağıtımı için aynı izi sürelib:

    $ whereis gcc
    gcc: /usr/bin/gcc /usr/lib/gcc /usr/share/gcc
    $ ls -l /usr/bin/gcc
    lrwxrwxrwx 1 root root 6 Oca 11  2021 /usr/bin/gcc -> gcc-10
    $ ls -l /usr/bin/gcc-10
    lrwxrwxrwx 1 root root 26 Oca 10  2021 /usr/bin/gcc-10 -> arm-linux-gnueabihf-gcc-10

    Buradaki araç zincirinden de şunu anlıyoruz: Bu araç zinciri 32 bit ARM kodu üretmektedir. Yine üretilen kodun Liux sistemlerinde 
    çalıştırılması gerektiği belirtilmektedir. GNU'nu araçları ve GNU'nun "eabihf" ABI'si kullanılmıştır. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Pekiyi araç zincirleri sistemimizde hazır bir biçimde bulunmuyorsa bunları nasıl elde edebiliriz? İşte bunun tipik olarak 
    üç yolu vardır:

    1) Çeşitli kurumlar ve topluluklar tarafından oluşturulmuş ve hazır hale getirilmiş araç zincirlerini kullanmak: Bunlara 
    "pre-built toolchain" de denilmektedir. 

    2) Araç zinciri oluşturan yazılımları ve projeleri kullanmak: Örneğin "crosstool-NG" gibi "buildroot" gibi "yocto" gibi 
    projelerle araç zincirleri daha etkin ve optimize edilmiş bir biçimde oluşturulabilmektedir. 

    3) Araç zincirlerini manuel biçimde oluşturmak: Manuel oluşturma çok zorlu bir süreçtir. Çünkü bu yöntemde araç zincirindeki 
    öğelerin kaynak kodlardan hareketle derlenmesi gerekmektedir. Bu işlemleri manuel yapmak için iyi bir deneyime sahip olmak 
    gerekir.

    Biz kursumuzda önce ARM platfotrmu için hazır araç zincirlerini tanıtacağız. Sonra "crosstool-NG" yazılımı ile araç 
    zinciri oluşturmayı göreceğiz. Buildroot ve Yocto projeleri araç zinciri oluşturmaktan daha fazla işlevselliğe sahiptir.
    Biz kursumuzda bunları ileride ayrı bir bölümde ele alacağız. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ARM platformu için önceden hazırlanmış ve kullanıma hazır hale getirilmiş hazır doğal ve çapraz araç zincirleri bulunmaktadır. 
    Bu amaçla kullanılan tipik araç zincirleri şunlardır:

    1) ARM Firması Tarafından Oluşturulmuş Olan Araç Zincirleri: ARM firmasının kendisi ARM hedefi için doğrudan kullanılabilecek 
    doğal ve çapraz araç zincirlerini hazırlamıştır. Bu araç zincirleri GNU projesini kullanmaktadır. Bu nedenle bu tür araç 
    zincirlerine "GNU araç zincirleri (GNU toolchains)" de denilmektedir. ARM'ın GNU araç zincirlerine aşağıdaki bağlantıdan 
    erişilebilir:

    https://developer.arm.com/downloads/-/gnu-a

    Örneğin elinizdeki host makinede 64 bit Intel işlemcilerinde çalışan Linux sistemi varsa Beaglebone Black için aşağıdaki çapraz 
    araç zincirini indirip kurabilirsiniz:

    gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf.tar.xz

    Raspberry Pi'nızda 64 bit Raspberry Pi OS varsa 64 bit Intel işlemcilerinde çalışan Linux sistemi için aşağıdaki çapraz araç 
    zincirini kullanabilirsiniz:

    gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz

    Burada yapılacak şey bu dosyaları indirip aşağıdaki örnekte olduğu gibi açmaktır:

    tar -xf gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf.tar.xz

    Tabii açımı dosya yöneticileri ile de yapabilirsiniz. 
    
    ARM firmasının yukarıda belirttiğimiz sitedeki hazır araç zincirleri ARM tarafından "discontinued" yapılmıştır. Yani ARM 
    yeni araç zinciri sistemine geçmiştir. ARM'ın yeni en yeni araç zincirleri aşağıdaki bağlantıdan indirilebilir:
    
    https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads

    Ancak buradaki araç zincirleri maalesef bizim kullandığımız BeagleBone Black  ile uyumsuzdur. (Buradaki araç zincirlerinde
    glibc kütüphanesinin daha ileri bir versiyonu kullanılmıştır. Dolayısıyla bu kütüphane dinamik kütüphane olarak kullanılacaksa 
    sorun oluşacaktır. Ancak statik kütüphane biçiminde kullanılacaksa sorun oluşmayacaktır.) Biz burada test amacıyla BeagleBone 
    Black aygıtımızla uyumlu olan ilk verdiğimiz bağlantıdaki araç zincirlerini kullanacağız. 

/*-----------------------------------------------------------------------------------------------------------------------------
                                            8. Ders 28/03/2024 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

    Yukarıdaki araç zincirini yerel host makineye indirdiğimizde aşağıdaki bir dizin yapısıyla karşılaşırız:

    bin 
    lib  
    libexec 
    arm-none-linux-gnueabihf  
    include  
    lib64  
    share

    Genel olarak araç zincirlerinin çoğundaki dizin yapısı bu biçimdedir. Burada bizim için en önemli dizin "bin" dizinidir. 
    Çünkü bütün çapraz araçlar bu dizin içerisinde bulnmaktadır. Bu dizini görüntülediğimizde içeriği şöyle listelenmektedir:

    arm-none-linux-gnueabihf-addr2line
    2021 arm-none-linux-gnueabihf-ar
    2021 arm-none-linux-gnueabihf-as
    2021 arm-none-linux-gnueabihf-c++
    2021 arm-none-linux-gnueabihf-c++filt
    2021 arm-none-linux-gnueabihf-cpp
    2021 arm-none-linux-gnueabihf-dwp
    2021 arm-none-linux-gnueabihf-elfedit
    2021 arm-none-linux-gnueabihf-g++
    2021 arm-none-linux-gnueabihf-gcc
    2021 arm-none-linux-gnueabihf-gcc-10.3.1
    2021 arm-none-linux-gnueabihf-gcc-ar
    2021 arm-none-linux-gnueabihf-gcc-nm
    2021 arm-none-linux-gnueabihf-gcc-ranlib
    2021 arm-none-linux-gnueabihf-gcov
    2021 arm-none-linux-gnueabihf-gcov-dump
    2021 arm-none-linux-gnueabihf-gcov-tool
    2021 arm-none-linux-gnueabihf-gdb
    2021 arm-none-linux-gnueabihf-gdb-add-index
    2021 arm-none-linux-gnueabihf-gfortran
    2021 arm-none-linux-gnueabihf-gprof
    2021 arm-none-linux-gnueabihf-ld
    2021 arm-none-linux-gnueabihf-ld.bfd
    2021 arm-none-linux-gnueabihf-ld.gold
    2021 arm-none-linux-gnueabihf-lto-dump
    2021 arm-none-linux-gnueabihf-nm
    2021 arm-none-linux-gnueabihf-objcopy
    2021 arm-none-linux-gnueabihf-objdump
    2021 arm-none-linux-gnueabihf-ranlib
    2021 arm-none-linux-gnueabihf-readelf
    2021 arm-none-linux-gnueabihf-size
    2021 arm-none-linux-gnueabihf-strings
    2021 arm-none-linux-gnueabihf-strip

    Burada gcc derleyicimiz "arm-none-linux-gnueabihf-gcc" ismiyle bulunmaktadır. Ancak derleyicimizi kullanmak için oldukça 
    fazla tuşa basmamız gerekir. Bunu engellemek için PATH çevre değişkenine bu "bin" dizini eklenebilir. Ya da aşağıdaki gibi 
    bir sembolik bağlantı dosyası oluşturulabilir:

    $ ln -s gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin/arm-none-linux-gnueabihf-gcc gcc-arm

    Burada artık biz ./gcc-arm biçiminde programı çalıştırdığımızda çapraz derleyicimizi çalıştırmış oluruz. Aynı işlemi C++
    derleyicisi için de yapabilirsiniz. C++ derleyicisi de  "arm-none-linux-gnueabihf-g++" ismiyle bulunmaktadır. O halde 
    örneğin "sample.c" programını sembolik link oluşturduktan sonra aşağıdaki gibi derleyebiliriz:

    $ ./gcc-arm -o sample sample.c

    2) Linaro Kurumu Tarafından Oluşturulmuş Araç Zincirleri: Yaygın kullanılan hazır araç zincirlerindne biri de "Linaro" 
    tarafından olutşurulmuş araç zincirleridir. Linaro kar amacı gütmeyen bir organizasyondur. Linaro araç zincirlerini 
    aşağıdaki bağlantıdan indirebilirsiniz:

    https://releases.linaro.org/components/toolchain/binaries

    Ya da aşağıdaki bağlantıyı kullanabilirsiniz:

    https://snapshots.linaro.org/ 

    BBB için Linaro araç zincirinin "bin" dizini içerisindeki çapraz araçların listesi şöyledir:

    arm-linux-gnueabihf-addr2line
    arm-linux-gnueabihf-ar
    arm-linux-gnueabihf-as
    arm-linux-gnueabihf-c++
    arm-linux-gnueabihf-c++filt
    arm-linux-gnueabihf-cpp
    arm-linux-gnueabihf-dwp
    arm-linux-gnueabihf-elfedit
    arm-linux-gnueabihf-g++
    arm-linux-gnueabihf-gcc
    arm-linux-gnueabihf-gcc-14.0.0
    arm-linux-gnueabihf-gcc-ar
    arm-linux-gnueabihf-gcc-nm
    arm-linux-gnueabihf-gcc-ranlib
    arm-linux-gnueabihf-gcov
    arm-linux-gnueabihf-gcov-dump
    arm-linux-gnueabihf-gcov-tool
    arm-linux-gnueabihf-gdb
    arm-linux-gnueabihf-gdb-add-index
    arm-linux-gnueabihf-gfortran
    arm-linux-gnueabihf-gprof
    arm-linux-gnueabihf-ld
    arm-linux-gnueabihf-ld.bfd
    arm-linux-gnueabihf-ld.gold
    arm-linux-gnueabihf-lto-dump
    arm-linux-gnueabihf-nm
    arm-linux-gnueabihf-objcopy
    arm-linux-gnueabihf-objdump
    arm-linux-gnueabihf-ranlib
    arm-linux-gnueabihf-readelf
    arm-linux-gnueabihf-size
    arm-linux-gnueabihf-strings
    arm-linux-gnueabihf-strip

    Bu araç zincirindeki gcc derleyicisi için de aşağıdaki gibi sembolik bağlantı dosyası oluşturabiliriz:

    $ ln -s gcc-linaro-14.0.0-2023.06-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc gcc-linaro

    Derlemeyi de şöyle yapabiliriz:

    ./gcc-linaro -o sample sample.c

    3) Bootlin Kurumu Tarafından Oluşturulmuş Araç Zincirini İndirip Kurmak: Bootlin gömülü Linux sistemleri alanında faaliyet 
    gösteren bir kurumdur. Bootlin tarafından oluşturulmuş olan çapraz araç zincirleri sık kullanılmaktadır. İlgili araç zinciri
    aşağıdaki sayfadan indirilebilir:

    https://toolchains.bootlin.com/

    Bootlin araç zincirlerinin hepsi Intel işlemcilerinin kullanıldığı Linux sistemleri için hazırlanmıştır.
    
    4) Windows İçin "gnutoolchains.com" Sitesindeki Araç Zincirini İndirip Kurmak: Bu site yalnızca Windows için çok çeşitli 
    GNU araç zincirlerini barındırmaktadır. Dolayısıyla eğer host sistem olarak Windows'u kullanıyorsak bu site işimizi 
    kolaylaştırabilir. Siteye aşağıdaki bağlantıdan erişebilirsiniz:

    https://gnutoolchains.com/

    Örneğin BBB için bu siteden "Beaglenone" seçilerek "beaglebone-gcc8.3.0.exe" dosyası indirilip kurulabilir. Bu site Windows'ta 
    doğrudan install edilebilen çalıştırılabilir programlar barındırmaktadır. Kurulum yapılırken bize araçların bulunduğu "bin"
    dizininin PATH çevre değişkenine eklenip eklenmeyeceği de sorulmaktadır. Eğer bu eklemeyi yaparsanız komut satırından 
    daha rahat çalışabilirsiniz. 

    5) Bazı dağırımların sunduğu araç zincirleri de bulunmaktadır. Örneğin Debian dağıtımı için ARM çapraz araç zinciri şöyle 
    kurulabilir:

    sudo apt-get install crossbuild-essential-armhf

    Bu araç zincirinin de glibc kütüphanesi bakımından BBB ile uyumsuz olduğuna dikkatinizi çekmek istiyoruz. Eğer ARM işlemcisinin
    bulunduğu Debian türevi bir Linux sisteminde çalışıyorsanız Intel kodu üretmek için de aşağıdaki gibi araç zincirini kurabilirsiniz:

    sudo apt-get install crossbuild-essential-amd64
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                    9. Ders 02/04/2024 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Gömülü Linux sistemleri için host makine olarak Windows kullanılmasının çok uygun olmadığını belirtmiştik. Windows'ta geleneksel
    çalışma modeli GUI çalışma modelidir. Windows'ta komut satırından komutlar yoluyla çalışma yaygın bir kullanım biçimi değildir. 
    Halbuki daha önceden de söylediğimiz gibi UNIX/Linux sistemlerinin geleneksel çalışma biçimi console çalımasıdır. Pekiyi 
    macOS sistemlerini host makine olarak kullanmak uygun olur mu? 

    Aslında Apple firması GUI çalışma modelini ilk kullanan firmalardandır. Microsoft'un DOS işletim sistemi zamanlarında 
    Aplle firmasının Machintosh sistemleri grafik arayüz kullanıyordu. Sonra 90'lı yılların sonlarına doğru Mac OS X (10) 
    ile birlikte Apple işletim sistemlerinin çekirdeğini değiştirerek UNIX türevi bir çekirdek kullanmaya başladı. Bugünkü 
    macOS sistemleri UNIX türevi bir sistem gibi değerlendirilebilir. Ancak durum böyle olsa da macOS sistemlerinde ağırlıklı 
    çalışma yine grafik arayüz yoluyla yapılmaktadır. Maalesef macOS sistemleri için hazır Linux araç zincirleri bulunmamaktadır. 
    Örneğin ARM, Linaro ve Bootlin kurumlarının macOS host olarak hazır araç zincirleri bulunmamaktadır. Bunların araç zinciri 
    üreten programlar tarafından derlenerek oluşturulması gerekmektedir. Dolayısıyla macOS sistemlerini host sistem olarak 
    kullanmak Windows sistemlerini host sistem olarak kullanmaktan biraz daha zordur. Biz macOS sistemlerini kullanan 
    katılımcılarımıza sanal makinelerine Linux kurmalarını öneriyoruz. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Eclipse ilk kez bir Java IDE'si olarak tasarlanmıştır. Daha sonra plugin'ler yoluyla genel bir IDE haline getirilmiştir. 
    Eclips IDE'sinin C/C++ plugin'ine CDT denilmektedir. Elimizde Java için zaten kurmuş olduğumuz bir Eclipse varsa biz bu CDT
    plugin'ini IDE'ye ekleyerek C/C++ çalışması da yapabiliriz. Ancaj kolaylık olsun diye Eclipse'in çeşitli diller için plugin'leri
    yüklenmiş halleri kendi sitesinde bulunudurlmaktadır. Biz burada Eclipse IDE'si ile çağraz araç zincirlerinin nasıl kullanılacağını 
    göreceğiz. 
    
    Eclipse IDE'si ile çapraz araç znicirini kullanmak için sırasıyla şunlar yapılmalıdır:

    1) Eclipse IDE for C++ Developers (Eclipse - CDT) indirilerek kurulur. İndirmeyi aşağıdaki bağlantıdan yapabilirsiniz:
"
    https://www.eclipse.org/downloads/packages/

    2) File/New/C/C++ seçeneğinden "C++ Project" ya da "C Project" seçilir. ("C/C++ Project" seçeneğini seçmeyiniz.)

    3) Karşımıza çıkan diyalog penceresinde projeye bir isim verilir. Sağ taraftaki "Toolchains" panelinden de "Cross GCC" 
    seçilir. 

    4) Daha sonra Project/Properties menüsünden "Tool Setting" seçilir.  Çıkan diyalog penceresinden "Cross Settings" seçilir. 
    Yan taraftaki Prefix edit alanına alet zincirinin ön ekleri girilir. Öneklerin sonunda "-" karakterininde bulundurulması 
    gerekmektedir. Örneğin "arm-linux-gnueabihf-" gibi. Path edit alanına ise çapraz alet zincirindeki programların bulunduğu
    "bin" dizininin yol ifadesi girilmelidir. (Örneğin "C:\SysGCC\beaglebone\bin" gibi.)

    5) Daha sonra Proje üzerinde gelinerek bağlam menüsünden "Build Project" seçilip build işlemi yapılır. 

    Eclipse üzerinden uzak bağlantı kurmak için de şunları yapılabilir:

    1) Help/Install New Software seçilir. Buradan aşağıdaki iki plugin kurulur:

    - Remote System Explorer User Actions
    - Remote System Explorer End-User Runtime
    - Remote Cammand Shell Console

    2) Window/Show View/Remote Systems seçilir. Linux seçilerek yeni bir bağlantı olşturulur. Bağlantıya bir isim verilerek Next 
    düğmesine basılır. Configuration penceresinden ssh files seçilir. Next düğmesine basılır. Bu kez Configuration sekmesinden 
    "processes.shell.linux" seçilir ve Next seçilir. Oradan da "ssh.shells" seçilir ve Finish düğmesine basılır.  
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                            10. Ders 04/04/2024 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Microsoft'un ünlü IDE'sine "Visual Studio" denilmektedir. Visual Studi IDE'si Windows için tasarlanmış ve gerçekleştirilmiştir. 
    Linux sistemlerinde bulunmamaktadır. Microsoft bu IDE'nin macOS versiyonunu çıkartmışsa da artık o projeyi devam ettirmemektedir. 
    Diğer sistemler için IDE ile editör arasında olan "Visual Studio Code" denilen aracı önermektedir. Visual Studio IDE'si 
    paralı bir üründür. Ancak Microsoft bu IDE'nin temel bir versiyonunu "Visual Studio Community" ismi altında bedava bir biçimde
    de vermektedir. IDE aşağıda bağlantıdan indirilebilir:

    https://visualstudio.microsoft.com/tr/downloads/

    Visual Studio uzun süredir ARM tabanlı mobil aygıtlar için kod üreten çapraz derleyicileri bünyesinde barındırmaktadır. 
    
    Windows'ta Visual Studio IDe'sinde ARM tabanlı Linux sistemleri için proje (ve çözüm) şöyle yaratılmaktadır:

    1) Yeni bir proje oluşturulurken Paltform olarak "Linux" ve "Empty Console Application" ya da "Empty Project" seçilir. 
    2) Üretilecek kod türü ARM seçilir. Bu seçim IDE'nin ana ekranında yukarıdaki combobox'tan yapılabilmektedir. 
    3) Daha sonra uzak makineye bağlantı yapılır. Bağlantı sırasında bizden uzak makinenin IP adresi (ya da ismi), oradaki 
    kullanıcının ismi ve parolası istenecektir. Bağlantı "Tools/Options/Multi Platform/Connection Manager" menüsünden yapılabilmektedir.
    4) Projeye kaynak kod eklenip "build" işlemi yapıldığında hedef makine için kod üretilir. Derleme menüsünden "Çözümü Dağıt"
    seçeneği seçildiğinde otomatik olarak tüm proje uzak makineye aktarılmaktadır. Debug işlemleri için de aslında programcının 
    özel bir hazırlık yapmasına gerek kalmamaktadır. Debug işlemi yerel makinede olduğu gibi yapılmaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Microsoft değişik sistemlerde platform bağımsız geliştirme yapabilmek için "Visual Studio Code" isimli IDE ile Editör arası
    bir araç da gelişmiştir. Son yıllarda bu araç çok kullanılır olmuştur. Visual Stduio Code yüksek seviyeli bir çalışma biçimine 
    sahip değildir. Çalışma düşük seviyede çeşitli ayar dosyaların edit edilmesiyle yapılmaktadır. Ancak editör tasarım olarak 
    genişletilebilir bir biçimde oluşturulmuştur. Yüksek seviyeli çalışma çeşitli plugin'lerle sağlanabilmektedir. Microsoft 
    bu plugin'lere "uzantı (extension)" demektedir. C/C++ programcısı olarak en azından Microsoft'un "C/C++ Extension Pack" 
    isimli eklentisini yüklemenizi öneririz. Ayrıca tek tuşa basarak programı derleyip çalıştırmak için "Code Runner" isimli 
    eklentiden de faydalanabilirsiniz. Örneğin bu eklentiş sayesinde "Ctrl+Alt+N" tuşlarına basılarak editördeki program doğrudan 
    derlenip çalıştırılabilmektedir. 

    Biz kursumuzdaki kodlama örneklerinde ağırlıklı olarak Visual Studio Code editörünü  kullanacağız. Ancak bu aracı bir IDE gibi 
    değil bir text editör gibi kullanacağız. İşlemleri genellikle manuel bir biçimde komut satırından yapacağız. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Visual Studio Code ile çapraz derleme işlemi maalesef kolay değildir. Bunun için henüz hazır eklentiler bulunmamaktadır. 
    Programcı tek tuşa basarak Visual Studio'da olduğu gibi işlemlerini otomatize edebilir. Ancak bunu yapmak için Visual Studio 
    Code'un çalışma biçimi hakkında ayrıntılı bilgi sahibi olması gerekir. 

    Visual Studio Code aracında tek tuşa basarak çapraz derleme yapmak için sırasıyla şu adımlar izlenebilir:

    1) Önce bir dizin yaratılır. Dizin projeyi temsil edecektir. Sonra dizin içerisinde ".vscode" isimli bir dizin oluşturulur. 
    Bu dizinin içerisinde de "tasks.json" dosyası yaratılır. 

    2) tasks.json dosyası için bir şablon şöyle olabilir:

    {
        "version": "2.0.0",
        "tasks": [
            {
                "label": "Build for ARM",
                "type": "process",
                "command": "/home/Study/gcc-arm-10.3-2021.07-aarch64-arm-none-linux-gnueabihf/bin/arm-none-linux-gnueabihf-gcc",
                "args": [
                    "-g",
                    "${workspaceFolder}/sample.c",
                    "-o",
                    "${workspaceFolder}/sample.o",
                    "--static"
                ],
                "group": {
                    "kind": "build",
                    "isDefault": true
                },
                "problemMatcher": [
                    "$gcc"
                ],
                "detail": "Compiler task."
            }
        ]
    }

    Burada "type" programın nasıl çalıştırılacağını belirtmektedir. Eğer buraya "shell" girilirse çalıştırma kabuğa yaptırılır.
    Eğer burada "process" girilirse doğrudan çalıştırma uygulanmaktadır. "command" çalıştırılacak programı belirtmektedir. 
    Tabii bu program ya doğrudan derleyici olur ya da make gibi, bir shell script gibi bir program olabilir. "args" ise "command" 
    ile belirtilen programın komut satırı argümanlarını belirtmektedir. 

    Bu dosya oluşturultan sonra derlenecek dosya editörde aktif hale getirilir. Shift+Ctrl+P tuşlarına basılarak "Run Build Task" 
    seçilir. 

    Tabii aslında yukarıdaki "tasks.json" dosyasında birden fazla "label" olabilir. Burada doğrudan derleyici çalıştırmak yerine 
    "make" gibi "cmake" gibi build otomasyon araçlarını da çalıştırabiliriz. Örneğin "tasks.json" dosyasını şöyle de oluşturabiliriz:

    {
    "version": "2.0.0",
    "tasks": [
        {
            "label": "Build for ARM",
            "type": "shell",
            "command": "make",
            "args": [
                "-f",
                "${workspaceFolder}/Makefile"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "problemMatcher": [
                "$gcc"
            ],
            "detail": "Compiler task."
        }
    ]
    }

    Burada biz "Shift+Ctlr+P" yapıp "Run Build Task" seçeneğini seçtiğimizde "make" programı çalıştırılacak ve make işlemi 
    yapılacaktır. Make dosyalarının naısl oluşturulacağını ayrı bir bölümde ele alacağız. Ancak en basit bir make dosyası 
    şöyle oluşturulabilir:

    SDK_PATH=/home/kaan/Study/EmbeddedLinux/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin

    project: sample.o
        $(SDK_PATH)/arm-none-linux-gnueabihf-gcc -o project sample.o
    sample.o: sample.c
        $(SDK_PATH)/arm-none-linux-gnueabihf-gcc -c sample.c
        
    Bu make kodunu yaratmış olduğunuz proje dizinine "Makefile" ismiyle kaydedebilirsiniz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Visual Studio Code editöründe uzak bağlantı ile çalışmak için de sırasıyla şunlar yapılmalıdır:

    1) Aşağıdaki bağlantıdan CLI paketini uzak makineye indirip sıkıştırılmış dosyayı açınız:
    
    https://code.visualstudio.com/Download
    
    Bu dosyada "code" isimli bir program bulunmaktadır. Bu programı Linux sistemlerinde "/usr/bin" dizinine kopyalayabilirsiniz. 
    Bu işlem Linux sistemlerinde aşağıdaki gibi yapılabilir:

    tar xf <indirilen CLI dosyası>
    sudo cp code /user/bin

    2) Hedef makinede code programı aşağıdaki gibi çalıştırılır:

    $ code tunnel

    Bu program server'ın çalıştırılmasını sağlayacaktır. Bu çalıştırmayı ilk kez yaptığınızda github için bir onaylama istenmektedir.
    Bundan sonra size bir URL verilir bu URL yerel makinenizin tarayıcısında yazılırsa VSCode editörü grafik atayüzle açılacaktır.
    Tabii siz aslında uzak makinede VSCode editörü ile çalışıyor durumda olacaksanız.

    3) Bu işlemden sonra uzak makinedeki server program bir URL verir. Bu URL yerel makinede girilirse karşımıza tarayıcıda Visual 
    Studio Code editörü çıkacaktır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda çeşitli kurumlar tarafından hazır hale getirilmiş (prebuilt) araç zincirlerini kullandık. Ancak hazır araç 
    zincirlerini kullanmanın kimi zaman bazı dezavantajları söz konusu olabilmektedir. Örneğin:

    - Hazır araç zincirleri gömülü sistemimizdeki Linux ile uyumlu olmayabilir. Çünkü bir programın çapraz derlenerek hedef 
    makinede çalışabilmesi için çapraz derleme ortamıyla derlenmiş kodun çalışacağı ortamın tam bir uyum içerisinde olması 
    gerekmektedir. Örneğin ARM'ın hazır yeni araç zincirleri bizim kullandığımız BBB ile kütüphane bakımından uyumsuzdur. 

    - Hazır araç zincirleri pek çok sistemde çalışabilsin diye hazırlanmaktadır. Bu da belli bir sistem için performansı 
    düşürebilmektedir. Oysa araç zincirleri tam olarak hedef sistem için en uygun kodların üretilebileceği biçimde o sisteme
    özgü oluşturulabilmektedir.

    - Hazır araç zincirleri standart C ve POSIX fonksiyonları için belli bir kütüphaneyi kullanmaktadır. Genellikle de bu 
    kütüphane GNU glibc kütüphanesidir. C++ için de benzer biçimde stdc++ kütüphanesi kullanılmaktadır. Araç zincirlerini manuel 
    biçimde oluştururken bu kütüphaneleri de hedef sistem için daha uygun olacak biçimde belirleyebiliriz. 

    - Hazır araç zincirleri bazı klasik ABI'leri kullanmaktadır. Bazı aygıtlar için bazı nedenlerden dolayı farklı ABI'lerin 
    kullanılması gerekebilmektedir. 

    Biz daha önce araç zincirlerinin manuel bir biçimde oluşturulmasının zorluklarından bahsetmiştik. İşte araç zincirlerinin
    içinde çok çeşitli programlar vardır. Bunların tek tek konfigüre edilip derlenmesi hem zahmetlidir hem de özel bilgiler 
    gerektirmektedir. İşte bu nedenden dolayı araç zincirlerini otomatik olarak üreten yazılımlar oluşturulmuştur. Biz kursumuzda 
    "buildroot" ve "yocto" projelerini ayrı bölümlerde ele alacağız. Bu projelerle araç zincirileri de oluşturulabilmektedir.
    Araç zincirlerinin oluşturulmasında son zamanlarda "corsstool-NG" isimli yazılım yaygın biçimde kullanılır olmuştur Biz de 
    bu bölümde bu crosttol-NG yazılımının kullanılması üzerinde duracağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    crosstool-NG araç zinciri ouşturan bir yazılımdır. Zaman içerisinde çeşitli böcekler giderilmiş olsa da hala birtakım böcekler 
    bulunmaktadır. Ancak yazılım iş görür bir durumdadır.  

    crosstool-NG aracını kullanmak için önce onun kaynak kodlarını indirip host makinede derlemek gerekir. Maalesef projenin 
    derlenmiş "binary" biçimi kendi sitesinde bulunmamaktadır. crosstool-NG hangi sistemde derlenirse host sistem o olmaktadır. 
    Biz bu araçta hedef (target) sistemin özelliklerini belirleyip host sistemde çalışacak çapraz derleme araçlarını oluşururuz. 

    crosstool-NG aracının tipik host sistemi Linux olmalıdır. Windows'ta derleme yapmak oldukça zordur. macOS sistemlerinde 
    bu aracın kullanılması Windows sistemlerinden daha kolaydır. Ancak macOS için bazı programların "brew (home brew)" ile 
    indirilmesi gerekmektedir. Biz kursumuzda host sistem olarak Linux kullanacağız. 

    crosstool-NG'nin tipik kullanımı şöyledir:

    1) Öncelikle crosstool-NG'nin derlenmesi ve araç zincirinin oluşturulması sırasında gerekli olan başka paketler kurulmalıdır.
    Gerekli bütün paketler aşağıda listelenmiştir. Bunu copy-paste yaparak bunların kurulumlarını sağlayabilirsiniz:

    sudo apt-get install autoconf automake bison bzip2 cmake flex g++ gawk gcc gettext git gperf help2man libncurses5-dev \
    libstdc++6 libtool libtool-bin make patch python3-dev rsync texinfo unzip wget xz-utils

    2) Projenin kaynak kodları kendi sitesinden indirilip proje derlenmelidir. Projenin resmi sitesi şöyledir:

    https://crosstool-ng.github.io/

    İndirme işlemi doğrudan git'ten yapılabilir. Örneğin:
    
    git clone https://github.com/crosstool-ng/crosstool-ng
    
    Eğer siteden indirme yapılmışsa indirilen dosya sıkıştırılmış bir dosyadır. Bu dosyanın açılması gerekir. Dosya açılınca bir dizin 
    oluşacaktır. 

    3) Kabuktan dizine geçilir ve ilk iş olarak  "bootstrap" isimli program aşağıdaki gibi çalıştırılır:

    $ ./bootstarp

    4) Daha sonra "autoconf" projelerinin çoğunda olduğu gibi bir "configure" işlemi yapılmalıdır. Bunun için "configure" denilen 
    program çalıştırılır. Bu program çalıştırılırken kurulumun hangi dizine yapılacağı da "--prefix" komut satırı argümanı
    ile belirtilebilir. Bu argümana "mutlak yol ifadesinin" verilmesi gerekmektedir. Örneğin

    $ ./configure --prefix=/home/kaan/crosstool-NG

    5) Artık projenin derlenmesi "make" komutuyla gerçekleştirilebilir: 

    $ make

    6) Artık derleme yapılmıştır. Son aşama olarak derlenmiş programın install edilmesi kalmıştır. Bu işlem de "make install" 
    komutuyla yapılmaktadır:

    $ make install

    Bu komutla crosstool-NG configure işleminde --prefix ile belirtilen dizine kurulacaktır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                            11. Ders 16/04/2024 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Crosstool-NG'de çapraz araç zincirleri için üç makine söz konusudur:

    1) Build Makinesi (Build Machine): Çapraz derleme araçlarının oluşturulduğu makinedir. Örneğin biz Intel tabanlı masaüstü 
    bilgisayarımızda alet zinciri oluşturmak amacıyla build işlemi yapıyorsak build makinesi bu makinedir. 

    2) Host Makinesi (Host Machine): Oluşturulmuş olan araç zincirinin kullanıldığı makinedir. Örneğin biz Intel tabanlı masaüstü
    bilgisayarımızda ARM için çapraz derleme yapıyorsak bu durumda host makinesi bu çapraz derlemeyi yaptığımız makinedir. 

    3) Hedef Makine (Target Machine):  Derlenmiş olan kodun çalıştırılacağı makineyi belirtmektedir. Örneğin biz Intel işlemcilerinin
    kullanıldığı host makinede ARM için çapraz derleme yapmışsak burada hedef makine ARM işlemcisinin bulunduğu makinedir. 

    Genellikle "build makinesi" ile "host makinesi" aynı makine olmaktadır. Yani biz genellikle araç zincirini build ettiğimiz 
    makinede aynı zamanda çapraz derleme işlemlerini de yaparız. 

    Crosstool-NG'nin dokümantasyonunda build makinesi, host makinesi ve hedef makine kombinasyonları için dört terim kullanılmaktadır:

    1) Eğer "build makinesi == host makinesi == hedef makine" ise bu tür araç zincirlerine "doğal araç zincirleri (native toolchains) 
    denilmektedir.

    2) Eğer "build makinesi == host makinesi != hedef makine" ise bu tür araç zincirlerine "çapraz araç zincirleri (cross toolchains)" 
    denilmektedir. crosstool-NG için en çok kullanılan araç zincirleri bunlardır. 

    3) Eğer "build makinesi != host makinesi == hedef makine" ise bu tür araç zincirlerine "çapraz-doğal araç zincirleri 
    (cross-native toolchains)" denilmektedir.

    4) Eğer "build makinesi != host makinesi != hedef makine" ise böyle araç zincirlerine "kanadalı araç zincirleri (canadian 
    toolchains)" denilmektedir.

    Kanadalı araç zincirine dikkat ediniz. Örneğin biz ARM tabanlı bir Linux makinede araç zinciri oluşturmak isteyelim. 
    Ancak araç zincirimiz Intel tabanlı bir bilgisayarda çalışacak olsun. Ancak bu Intel tabanlı bilgisayarda bu araç zincirini 
    çalıştırdığımızda üretilecek kod MIPS tabanlı bir bilgisayara yönelik olsun. Burada crosstool-NG terminolojisine göre bir 
    Kanadalı araç zinciri söz konusudur. 

    Ancak crosstool-NG her zaman build işleminin yapıldığı makinede çalışacak araç zinciri kodu üretmektedir. Yani üretilen 
    araç zincirinde "build makinesi == host makine" olmaktadır. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    crosstool-NG'de işlemler "bin" klasörünün altında "ct-ng" isimli programla yapılmaktadır. Biz burada sizin crosstool-NG'nin 
    ana klasöründe olduğunuzu varsayacağız. 

    Maalesef crosstool-NG aracında halen bazı böcekler bulunmaktadır. Örneğin eğer Linux sisteminizdeki "sistem dili" Türkçe ise
    crosstool-NG derlenirken bu sistem dilini referans aldığı için ürettiği script'lerde Türkçe karakterleri kullanmaktadır.
    Bu da bu script'lerin çalıştırılmasdında sorunlara yol açmaktadır. Bu böceğin "arkasından dolaşmak (workaround)" için sistem 
    dili Türkçe yerine İngilizce yapılabilir.  (Mint dağıtımında bu işlem ana menüden "Tercihler/Diller" seçeneği kullanılarak 
    yapılabilir. Burada yalnızca arayüz dilini değiştirebilirsiniz.) Tabii bu değişiklik yapıldıktan sonra crosstool-NG'yi yeniden 
    drlenmelidir. (Aslında muhtemelen derleme sırasında kodlar "LANG" ve "LANGUAGE" gibi bazı çevre değişkenlerine bakmaktadır. 
    Sistem ayarlarını değiştirmeden yalnızca birkaç çevre değişkeni geçici olarak da değiştirilebilir. Ancak sistem dilinin 
    değiştirilmesi daha sorunsuz bir çözüm oluşturacaktır.) crosstool-NG derlendikten sonra sistem dilini eski haline getirebilirsiniz. 
    Sistem dilini değiştirdikten sonra makinenizi reboot etmelisiniz. 
        
    crosstool-NG'de araç zinciri derleme işlemi sırasıyla şu adımlardan geçilerek sağlanmaktadır:

    1) Önce araç zinciri "ct-ng" programı ile konfigüre edilir. Araç zincirinin konfigürasyonu için "menuconfig" argümanı 
    kullanılmaktadır:

    $ bin/ct-ng menuconfig

    Karşımıza bir konfigürasyon menüsü gelecektir. Bu menüde ilgili öğeler seçilip konfigürasyon save edilir. Save işlemi sonrasında
    default durumda ".config" isimli bir dosya oluşacaktır. (UNIX/Linux sistemlerinde başında "." olan dosya ve klasörlerin ls 
    komutunda default olarak görüntülenmediğine dikkat ediniz.)

    Konfigürasyon işleminde pek çok menü seçeneği bulunmaktadır. Bu seçeneklerin hepsi için belirlemeler yapmak yerine isteğinize en 
    yakın olan hazır bir konfigürasyonu yükleyip değişiklikleri onun üzerinde yapabilirsiniz. Hazır konfigürasyonların listesi 
    aşağıdaki gibi görüntülenebilir:

    $ bin/ct-ng list-samples
    Status  Sample name
    [G...]   aarch64-ol7u9-linux-gnu
    [G...]   aarch64-ol8u6-linux-gnu
    [G...]   aarch64-ol8u7-linux-gnu
    [G...]   aarch64-rpi3-linux-gnu
    [G...]   aarch64-rpi4-linux-gnu
    [G...]   aarch64-unknown-linux-gnu
    [G..X]   aarch64-unknown-linux-musl
    [G...]   aarch64-unknown-linux-uclibc
    [G...]   alphaev56-unknown-linux-gnu
    [G...]   alphaev67-unknown-linux-gnu
    [G...]   arc-arc700-linux-uclibc
    ...

    Hazır bir konfigürasyonu yüklemek için buradaki isimlerden uygun olanı seçilir ve aşağıdaki gibi yükleme yapılır:

    $ bin/ct-ng <hazır şablonun ismi>

    Örneğin:

    $ bin/ct-ng arm-cortex_a8-linux-gnueabi

   Bir konfigürasyonun belirlemeleri konfigürasyon isminin başına "show-" getirilerek görüntülenebilmektedir. Örneğin:

   $ bin/ct-ng show-arm-cortex_a8-linux-gnueabi
   [G...]   arm-cortex_a8-linux-gnueabi
        Languages       : C,C++
        OS              : linux-6.6.1
        Binutils        : binutils-2.42
        Compiler        : gcc-13.2.0
        C library       : glibc-2.39
        Debug tools     : duma-2_5_21 gdb-14.2 ltrace-0.7.3 strace-6.6
        Companion libs  : expat-2.5.0 gettext-0.21 gmp-6.2.1 isl-0.26 libelf-0.8.13 libiconv-1.16 mpc-1.3.1 mpfr-4.2.1 
                          ncurses-6.4 zlib-1.3 zstd-1.5.5
        Companion tools :

    BBB için araç zinciri oluşturmak isteniyorsa buna en yakın konfigürasyon "arm-cortex_a8-linux-gnueabi" isimli konfigürasyondur.
    Bu konfigürasyonu aşağıdaki gibi yükleyebilirsiniz:

    $ bin/ct-ng arm-cortex_a8-linux-gnueabi

    Sonra menuconfig yaparak konfigürasyon menüsüne girebilirsiniz:

    $ bin/ct-ng menuconfig

    Burada şu seçenekleri değiştirmeniz gerekir:

    - "Paths and misc options" menüsünden "Render the toolchain read-only" unchecked yapılır.
    - "Target/Floating Point" menüsünden "hardware (FPU)" seçilir. 
    - "Target/Use specific FPU" menüsünde "neon" girilir. 
    - "C-Library" menüsünden "Versions of glibc" alt menüsüne gelinip glibc kütüphanesinin versiyon numarası 2.31 yapılır. 
    (BBB'deki debian sürümü glibc 2.34'i kullanmaktadır.)

    2) Araç zinciri menuconfig ile konfigüre edildikten sonra artık "build" işlemi aşağıdaki gibi yapılabilir:

    $ bin/ct-ng build

    3) crosstool-NG ürettiği araç zincirini default olarak "home" dizininin altında "x-tools" isimli bir dizine yerleştirmektedir. 
    Örneğin yukarıda ürettiğimiz araç zinciri bu dizinde şöyle gözükmeltedir:

    $ ls -l x-tools
    total 4
    drwxrwxr-x 8 kaan kaan 4096 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf

    Buradaki dizin hazır araç zincirlerinde olduğu bir yapıya sahiptir. Derleyiciler ve diğer binary araçlar bin dizinin içerisinde
    bulunmaktadır. Örneğin:

    -rwxr-xr-x 1 kaan kaan  1123904 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-addr2line
    -rwxr-xr-x 2 kaan kaan  1156456 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-ar
    -rwxr-xr-x 2 kaan kaan  2193584 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-as
    -rwxr-xr-x 2 kaan kaan  1850512 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-c++
    lrwxrwxrwx 1 kaan kaan       33 Nis 16 22:41 arm-cortex_a8-linux-gnueabihf-cc -> arm-cortex_a8-linux-gnueabihf-gcc
    -rwxr-xr-x 1 kaan kaan  1123392 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-c++filt
    -rwxr-xr-x 1 kaan kaan  1850512 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-cpp
    -rwxr-xr-x 1 kaan kaan     5812 Nis 16 21:19 arm-cortex_a8-linux-gnueabihf-ct-ng.config
    -rwxr-xr-x 1 kaan kaan  2742848 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-dwp
    -rwxr-xr-x 1 kaan kaan    43704 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-elfedit
    -rwxr-xr-x 2 kaan kaan  1850512 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-g++
    -rwxr-xr-x 2 kaan kaan  1846416 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-gcc
    -rwxr-xr-x 2 kaan kaan  1846416 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-gcc-13.2.0
    ...

    crosstool-NG'de daha önce yapılan ve ".config" dosyasına save edilen konfigürasyon dosyası "oldconfig" argümanıyla 
    geri yüklenebilir. Örneğin:

    $ bin/ct-ng oldconfig

    Artık bundan sonra "menuconfig" yaparsak eski konfigürasyon dosyasını yüklemiş oluruz. 

    Daha önce yapılan build işleminde kalan birtakım dosyaların kaldırılması için ise "distclean" argğmanıyla yapılabilmektedir. 
    Örneğin:

    # bin/ct-ng distclean

    distclean işlemi oluşturulan araç zincirlerini silmemektedir. Araç zincirlerinin oluşturulması için yaratılmış olan dosyaları 
    silmektedir. 

    ct-ng programının diğer komut satırı argümanları için aşağıdaki bağlantıdan faydalanabilirsiniz:

    https://man.archlinux.org/man/extra/crosstool-ng/ct-ng.1.en
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Araç zincirlerinin nasıl oluşturulduğunu ve kullanıldığını gördükten sonra şimdi dikkatimizi araç zincirleri içerisindeki 
    araçlara yönelteceğiz. Araç zincirleri içerisindeki en önemli araçlar şüphesiz "C Derleyicileri", "C++ Derleyicileri" ve 
    "Bağlayıcı (linker)" programlardır.
    
    Bilindiği gibi derleyiciler aslında "amaç dosya (object file)" denilen bir dosya üretmektedir. Bu amaç dosyalara "bağlayıcı
    (linker)" denilen programlara sokularak çalıştırılabilir (executable) dosya oluşturulmaktadır. Sistem programcısının bu 
    kavramlar hakkında temel bilgilere sahip olması gerekmektedir. Amaç dosyaların UNIX/Linux sistemlerindeki uzantıları ".o" 
    biçimindedir. Çalıştırılabilen dosyalar için UNIX/Linux sistemlerinde özel bir uzantı kullanılmamaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Derleyicilerin ürettiği amaç dosyaların (object files) ve bağlaıcıların ürettiği çalıştırılabilir dosyaların (executable files)
    önceden belirlenmiş belli bir formatı vardır. Microsoft DOS zamanlarında amaç dosya formatı olarak "OMF (Object Module Format)" 
    denilen bir formatı, çalıştırılabilir dosya formatı olarak da "MZ (Mark Zibikovski) " denilen bir formatı kullanıyordu. Sonra 
    16 bit Windows sistemleriyle amaç dosya formatı olarak OMF formatını kullanmaya devam etti ancak çalıştırılabilir dosya formatı 
    olarak "NE (New Executable)" isimli bir formatı kullanmaya başladı. Sonra nihayet 32 bit ve 64 bit Windows sistemlerinde amaç 
    dosya formatı olarak COFF (Common Object File Format)", çalıştırılabilir dosya formatı olarak "PE (Portable Executable) " denilen 
    formatı kullanmaya başladı. Bugün Microsoft COFF ve PE formatlarını kullanmaktadır. COFF formatı ile PE formatı hemen hemen aynı 
    formatlardır. COFF formatı PE formatının anaç dosya için özelleştirilmiş biçimi gibidir.

    Apple firması macOS sistemlerinde amaç dosya ve çalıştırılabilir dosya formatı olarak "Mach-O" formatı denilen bir dosya formatını
    kullanmaktadır.

    UNIX/Linux sistemlerinde uzunca bir süredir en yaygın kullanılan amaç dosya formatı ve çalıştırılabilir dosya formatı "ELF
    (Executable and Linkable Format)" isimli formattır. ELF formatı hem bir amaç dosya formatı hem de çalıştırılabilir dosya
    formatıdır. ELF formatının 32 bit ve 64 bit biçimleri vardır. Linux geçmişe doğru uyum için eski geleneksel "a.out" denilen 
    çalıştırılabilir dosya formatını da desteklemektedir. Fakat Linux sistemlerindeki default amaç dosya ve çalıştırılabilir 
    dosya formatı ELF formatıdır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde ELF dosyasını belleğe yükleyip çalışmaya hazır hale getirme işlemi "exec fonksiyonları" tarafından
    yapılmaktadır. (Linux sistemlerinde yalnızca execve fonksiyonu sistem fonksiyonu olarak bulundurulmuştur. Diğer exec 
    fonksiyonları execve fonksiyonunu çağırmaktadır.) Kavramsal olarak işletim sistemlerinde çalıştırılabilir dosyayı belleğe 
    yükleyerek çalıştırma durumuna getiren alt sistemlere "yükleyici (loader)" denilmektedir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ELF dosyasının genel yapısı şöyledir:

    ELF Başlığı (ELF Header)
    Program Başlık Tablosu (Program Header Table) (İsteğe Bağlı)
    Bölümler (Sections)
    Bölüm Başlık Tablosu (Section Header Table)

    ELF dosyasının hemen başında bir başlık kısmı (ELF Header) bulunmaktadır. Bu başlık kısmında dosya hakkında en önemli bilgiler
    bulunmaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                    12. Ders 18/04/2024 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Sistem programcısı olarak bir dosyanın içeriğini byte-byte hex sistemde görmek isteyebiliriz. Windows sistemlerinde bunu 
    yapan pek çok GUI uygulaması vardır. HxD denilen program oldukça yeteneklidir ve ücretsiz olarak kullanılabilmektedir. 
    Linux ve macOS sistemlerinde "hex editör" olarak çok güzel GUI programlarla karşılaşmak zordur. GHex isimli GUI hex editör 
    oldukça basittir ve GNOME sistemlerinde kullanılmaktadır. ghex programı aşağıdaki gibi install edilebilir:

    $ sudo apt-get install ghex

    Yine GUI hex editörlerinden biri de "bless" isimli editördür. Şöyle kurulabilir:

    $ sudo apt-get install bless

    Linux ve macOS sistemlerinde yetenekli IDE'ler aynı zamanda bir hex editör işlevini de görebilmektedir. Örneğin Visual Studio
    Code editörünün "Hex Editor" isimli bir eklentisi (Microsoft tarafından yazılmıştır) dosya içeriklerini hex olarak gösterebilmektedir. 
        
    Ancak tabii Linux sistemleri ağırlıklı biçimde komut satırından  işletildiği için sistem programcısının bir dosyanın içeriğini 
    komut satırından hex sistemde görüntülemesi gerekebilmektedir. Linux için konsol ekranında çalışan bazı hex gösterim yapan
    programlar şunlardır:

    - od programı. Tipik kullanımı şöyledir:

    od -t x1 <yol ifadesi>

    od default olarak dağıtımlarda bulunmaktadır.

    - hexer isimli program eski DOS sistemine benzer bir biçimde görüntüleme yapmaktadır. Şöyle kurulabilir:

    $ sudo ept-get install hexer

    - hexcurse isimli program. Hexcurse şöyle kurulabilir:

    $ sudo apt-get install hexcurse
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ELF Başlığında dosyadaki meta-data alanları hakkında önemli bilgiler yer almaktadır. ELF başlığığının ilk 16 byte'tı 
    "kimlik bilgileri (identification)" denilen dosyanın en önemli kimlik bilgilerini tutan kısmıdır. ELF dosyasının ilk dört 
    byte'ında bir "sihirli sayı (magic number)" bulundurulmuştur. Bu ilk 4 byte'ın ilk byte'ı 0x7F sonraki üç byte'ı da 'E', 'L', 
    'F' karakterlerinin ASCII kodlarından oluşmaktadır. Yani ELF dosyasının ilk 4 byte'ı hex olarak şöyledir:

    7F 45 4C 46

    Kimlik bilgilerinin 4'üncü offset'teki byte'ı ELF dosyasının 32 bit mi 64 bit mi olduğunu belirtmektedir. Eğer ELF dosyası 
    32 bit ise (yani 32 bitlik bir işletim sistemi için oluşturulmuşsa) burada 1 değeri 64 bit ise (yani 64 bit bir işletim 
    sistemi için oluşturulmuşsa) burada 2 değeri olmalıdır. 

    Kimlik bilgilerininin 5'inci offset'teki byte'ı ELF dosyasının "little endian" olarak mı yoksa "big endian" olarak mı 
    oluşturulduğunu belirtmektedir. Buradaki değer 1 ise dosya "little endian", 2 ise "big endian" biçiminde oluşturulmuştur. 
    Intel işlemcilerinin yalnızca "little endian" kullandığını, ARM işlemcilerinin hem "little endian" hem de "big endian" 
    olarak kullanılabildiğini ancak default kullanımın "little endian" olduğunu anımsayınız. O halde burada tipik olarak 1 
    değeri bulunacaktır. 

    Kimlik bilgilerinin 6'ıncı offset'indeki byte'ı ELF dosyasının versiyon numarasını belirtmektedir. Şu anda ELF dosyasının 
    majör olarak 1'li versiyonları kullanıdlığı için burada 1 değeri bulunacaktır. 

    Kimlik bilgilerinin 7'inci offset'teki byte'ı kullanılan ABI türünü belirtmektedir. Buradaki 0 değeri klasik "System 5 ABI"
    anlamına gelmektedir. Burada genellikle 0 değeri bulunmaktadır.

    Kimlik bilgilerinin 8'inci offset'teki byte'ı ABI versiyon numarasını belirtmektedir. Genel olarak burada 0 değeri bulunur. 

    Kimlik bilgilerinin 9'uncu offset'inden itibaren artık 16 byte'tan geri kalan byte'lar 0'larla doldurulmuştur. Bu 0 byte'larına
    "padding" denilmektedir. 

    Aşağıda 64 bit Intel makinesinde oluşturulmuş bir ELF formatının ilk 16 byte'ı görülmektedir:

    7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  .ELF............

    Aşağıda da 32 bit ARM işlemcileri için oluşturulmuş bir ELF formatının ilk 16 byte'ı görülmektedir:

    7f 45 4c 46 01 01 01 00  00 00 00 00 00 00 00 00  .ELF............

    ELF Başlığında kimlik bilgilerinden sonra (ilk 16 byte) yine dosya hakkında önemli bilgiler yer almaktadır. ELF başlığının 
    16'ıncı offset'indeki 2 byte'lık işaretsiz tamsayı dosyanın türünü belirtmektedir. Tipik tür değerleri şunlardır:

     0 ---> Geçersiz
     1 ---> Amaç Dosya (Relocatable Object File)
     2 ---> Çalıştırılabilir Dosya (Executable File)
     3 ---> Dinamik Kütüphane Dosyası (Shared Object)
     4 ---> Çekirdek Dosyası (Core File)

    ELF Başlığının 18'inci offset'indeki 2 byte'lık işaretsiz tmsayı dosyanın çalıştırılacağı hedef işlemcinin  türünü belirtmektedir. 
    Buradaki 2 byte'lık çeşitli işaretsiz tamsayı değerler çeşitli işlemci türlerini belirtmektedir. Örneğin 0x28 "32 Bit ARM 
    İşlemcilerini", 0x3E "AMD'nin 64 bit Intel Tabanlı İşlemcilerini" belirtmektedir. Bunların tam listesini Internet'ten elde 
    edebilirsiniz. (Örneğin Wikipedia'da "Executable and Linkable Format" sayfasında ayrıntılı bir liste verilmiştir.)

    ELF Başlığının 20'inci offset'teki 4 byte'lık işaretssiz tamsayı yine ELF dosyasının dosyanın versiyon numarasını belirtmektedir. 
    Burada tipik olarak 1 değeri bulunacaktır. 

    ELF Başlığının 24'üncü offset'inde "çalıştırılabilir dosyalar için" programın çalışmaya başlayacağı sanal adresi belirtilmektedir. 
    Çalıştırılabilir bir dosyanın çalıştırılmaya başlanacağı adrese aşağı seviyeli terminoloji de "entry point" denilmektedir. 
    Tabii adres bilgileri 32 bit ELF dosyalarında 4 byte, 64 bit ELF dosyalarında 8 byte uzunluktadır. 

    ELF Başlığının sonraki elemanlarının offset'leri artık 32 bit ve 64 bit ELF dosyalarına göre değişmektedir. 32 bit ELF 
    dosyalarında adres bilgileri ve dosya offset bilgileri 4 byte uzunluğunda, 64 bit ELF dosyalarında ise 8 byte uzunluğundadır.

    ELF başlığında bulunan diğer bilgiler şunlardır:

    - Program Başlık Tablosunun (Program Header Table)" dosyada hangi offset'ten başladığı bilgisi. Program başlık tablosu
    tipik olarak ELF başlığından hemen sonra gelmektedir. 

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

