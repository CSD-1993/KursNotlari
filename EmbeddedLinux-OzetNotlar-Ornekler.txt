/*-----------------------------------------------------------------------------------------------------------------------------

                                        C ve Sistem Programcıları Derneği

                                   Gömülü Linux Sistemleri - Geliştirme ve Uygulama Kursu

                                        Sınıfta Yapılan Örnekler ve Özet Notlar

                                                  Eğitmen: Kaan ASLAN

          Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.

                    (Notları okurken editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz.)

                                                Son Güncelleme: 30/04/2024

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												1. Ders 05/03/2024 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kurs için gerekli olabilecek malzemeler şunlardır:

    - Raspberry Pi SBC (Single Board Computer): Version 3, 4 ya da 5 olabilir. Yeni satın alacakların Raspberry Pi 5 almalarını 
    tavsiye ediyoruz.

    - Raspberry Pi 5 alınacaksa soğutucu ya da soğutuculu kılıf da alınmalı. Raspberry Pi 3 ve 4 için soğutucu alınmayabilir.

    - Raspberry Pi için Micso SD Kart: 64GB Yüksek Hızlı (SanDisk Extreme serisi olabilir). Micro SD kart 32 GB de olabilir.
    Ancak 32GB'den düşüğü tavsiye etmiyoruz.

    - Raspberry Pi 4 ve Raspberry Pi 5 için "Mikro HDMI -> HDMI kablosu", Raspberry Pi 3 için "HDMI -> HDMI" Kablosu.

    - USB Kombo Klavye + Mouse

    - Raspberry Pi için GPIO Breadboard Aktarma Kablosu

    - Raspberry Pi için Güç Kaynağı Adaptörü: Raspberry Pi 3 ve 4 için 5V/3A, Raspberry Pi 5 için 5V/5A (27W). Raspberry Pi 4 
    ve 5 USB Type C kullanıyor. Raspberry Pi 3 Micro USB kablosu kullanıyor.

    - BeagleBone Black SBC (Single Board Computer): BeagleBone Black 4G ya da BeagleBone Black Industrial ya da BeagleBone 
    Black Wireless yeni satın alacak olanlar "BeagleBone Black 4G" ya da BeagleBone Black Wireless" alabilirler. Stokları 
    kontrol etmek gerekiyor.

    - BeagleBone Black için Güç Kaynağı: Mini USB ile 5V/500mA güç adaptörü ya da yuvarlak girişli (DC Jack) 5V/1A güç adaptörü.

    - BeagleBone Black için Micro SD Kart (16GB olabilir).

    - BeagleBone Black için "Micro HDMI -> HDMI" Dönüştürücü.

    - Standart Boy Breadboard ve İsteğe Bağlı Küçük Boy Breadboard'lar da olabilir.

    - Jumper Kablo seti

    - "USB -> UART" Dönüştürücü (CP2102 olabilir)

    - USB Uzatma Kablosu Gerekebilir.

    - Ethernet RJ45 Kablosu: Eğer SBC'nin wireless özelliği varsa buna gerek duymayabilirsiniz.

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												2. Ders 07/03/2024 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kursumuzun giriş bölümünde çeşitli kavramları ve terimleri açıklayacağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Asıl amacı bilgisayar olmayan fakat bilgisayar sistemi içeren sistemlere genel olarak gömülü sistemler (embedded systems) 
    denilmektedir. Yani gömülü sistemler başka amaçları gerçekleştirmek için tasarlanmış olan aygıtların içerisindeki bilgisayar
    sistemleridir. Örneğin elektronik tartılar, biyomedikal aygıtlar, GPS cihazları, turnike geçiş sistemleri (validatörler), 
    müzik kutuları, kapı güvenlik aygıtları, otomobiller içerisindeki kontrol panelleri birer gömülü sistemdir. Gömülü 
    sistemlerde en çok kullanılan programlama dili C'dir. Ancak genel amaçlı işletim sistemlerinin yüklenebildiği SBC'lerde 
    (Single Board Computer) diğer programlama dilleri de kullanılabilmektedir.

    Gömülü sistemler gömüldüğü aygıtta belli işlevleri sağlamak için kullanılmaktadır. Örneğin buzdolaplarının, çamaşır 
    makinelerinin içerisine yerleştirilen bilgisayar devreleri ve yazılımlar onların önemli etkinlerini yönetmekte, kullanıcı 
    ile arayüz oluşturabilmektedir. Günümüzde bilgisayar sistemi içeren aygıtlar artık her yeri sarmıştır. Bu nedenle üzerinde 
    geliştirme faaliyetleri de önemli bir iş alanı haline gelmiştir.

    Gömülü sistemlerin tipik özellikleri şunlardır:

    - Gömülü sistemler "genel değil belirli (specific) amaca yönelik" işlemleri gerçekleştirmektedir. Yani genel amaçlı değil, 
    özel amaçlı donanım ve yazılım hizmeti sunmaktadır. Bu sistemlerdeki yazılımlar da genel amaçlı değil, belli bir amacı 
    gerçekleştirmeyi hedeflemektedir.

    - Gömülü sistemler genellikle daha düşük bir bilgi işlem kapasitesine sahip bilgisayar devreleridir. Örneğin bu sistemlerde 
    kullanılan işlemciler genel amaçlı masaüstü işlemcilerden genellikle daha yavaş olma eğilimindedir. Bu sistemlerdeki bellek
    miktarları (birincil ve ikinci bellekler) genel amaçlı bilgisayar sistemlerine göre daha düşük olma eğilimindedir. Dolayısıyla 
    gömülü sistemlerin maliyetleri de genel amaçlı bilgisayar sistemlerine göre çok düşüktür.

    - Gömülü sistemler genellikle (fakat her zaman değil) daha düşük güç harcamaktadır. Bu durum onların bataryalarla beslenebilmesini 
    dolayısıyla fiziksel taşınabilirliğini de artırmaktadır. Tabii genel olarak gömülü sistemler düşük güç harcama eğiliminde olan 
    sistemler olsalar da bu durum her zaman böyle olmak zorunda değildir. Bazı gömülü sistemlerin gömüldüğü sistemlerde bir güç 
    kullanma sorunu yoktur. (Örneğin araba kantarı zaten bu işlevi gerçekleştirmek için önemli bir güç harcamaktadır. Dolayısıyla 
    bu sistemdeki gömülü sistemin harcadığı gücün önemi olmayabilir.)

    - Gömülü sistemlerin önemli bir bölümü "gerçek zamanlı (real time)" olaylarla ilişkilidir. Bu sistemlerin belli bir bölümü 
    dış dünyadaki değişimlere karşı bir yanıt oluşturmaya çalışmaktadır. Örneğin bir gömülü sistem otamdaki ısı belli bir kritik 
    düzeye geldiğinde bir işlemi başlatabilir. Ya da bir gömülü sistem kalp ritmi bozulduğunda kalbe uyarılar göndererek ritim 
    bozukluğunu düzeltmeye çalışabilir. Hava araçlarındak gömülü sistemler o anki hava şartlarına göre bir otomatik kumanda sistemi 
    işlevini görüyor olabilir. Tabii gömülü istemlerin bu gerçek zamanlı işlem doğası bazı uygulamalarda "çok katı (hard realtime)" 
    olurken bazı uygulamalarda "daha gevşek (soft realtime)" olabilmektedir.

    - Gömülü sistemlerin bazılarında hiç girdi/çıktı birimi olmayabilir. Bazılarında ise girdi/çıktı birimi olarak "düğmeler", 
    basit tuş takımları, küçük LCD'ler olabilir. Oysa genel amaçlı bilgisayar sistemlerinde genellikle girdi/çıktı birimi olarak 
    klavye, fare ve gelişmiş monitörler kullanılmaktadır. Başka bir deyişle gömülü sistemler kullanıcı arayüzü bakımından minimal 
    olma eğilimindedir.

    - Gömülü sistemlerdeki donanım birimleri nispeten ucuz olma eğilimindedir. Genel amaçlı bilgisayarlara göre bunlar çok daha ucuz
    olarak temin edilebilmektedir.

    - Gömülü sistemler çeşitli kaynaklarda çeşitli ölçütlere göre de sınıflandırılabilmektedir.

    1) İşlevsel Gereksinime Göre Sınıflandırma:

        a) Gerçek Zamanlı Olan ya da Gerçek Zamanlı Olmayan Gömülü Sistemler: Bunlar "hard" ya da "soft" real-time olabilmektedir.
        b) Bağımsız (Stand-Alone) Olan ya da Bağımsız Olmayan Sistemler: Bunlar belli bir amaca yönelik hazırlanmış gömülü sistemlerdir.
        Örneğin hesap makineleri, kapı güvenlik sistemleri, MP3 çalarlar gibi.
        c) Ağ (Network) Üzerinde İşlem Yapan Gömülü Sistemler: Bunlar ağ işlemleri yapmak için oluşturulmuş gömülü sistemlerdir.
        ATM makineleri, ADSL Rouer cihazları gibi cihazları bunlara örnek verebiliriz.
        d) Mobil Aygıtlarda Kullanılan Gömülü Sistemler: Bunlar küçük, taşınabilir aygıtlarda kullanılan gömülü sistemlerdir.
        Telefonlar, GPS cihazları, dijital kameralar bunlara örnek verilebilir.

    2) Performans Gereksinimine Göre Sınıflandırma:

        a) Küçük Ölçekli (Small Scale) Gömülü Sistemler
        b) Orta Ölçekli (Medium Scale) Gömülü Sistemler
        c) Büyük Ölçekli (Large Scale) Gömülü Sistemler

    Biz burada "https://www.ultralibrarian.com/2022/06/28/types-of-embedded-systems-characteristics-classifications-ulc"
    bağlantısındaki sınıflandırmayı kullandık. Ancak başka kaynaklarda başka türlü sınıflandırmalar da yapılabilmektedir.

    Gömülü sistemlerde bilgisayar birimi olarak genellikle mikrodenetleyiciler (microcontrollers) kullanılmaktadır. Ancak entegre
    devre teknolojisinin gelişmesiyle artık içlerine standart işletim sistemi yüklenebilen çok daha gelişmiş donanımlar da 
    gömülü sistemlerde kullanılabilmektedir.

    Gömülü sistem yazılımlarının önemli bir bölümü bir işletim sistemi olmadan çalışacak biçimde (bare-metal) olarak geliştirilmektedir. 
    Bunun önemli nedenlerinden biri bunların kapasitelerinin nispeten düşük olması diğeri de belirli bir amacı gerçekleştirecek
    biçimde tasarlanmış olmalarıdır. Gömülü sistemlerin bir bölümünde "gerçek zamanlı işletim sistemleri" bir bölümünde ise "genel 
    amaçlı işletim sistemleri" kullanılmaktadır.

    Gömülü sistemlerde genel olarak üç işlem birimi kullanılmaktadır:

    1) Mikrodenetleyiciler
    2) Mikroişlemcileri
    3) DSP'ler

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bir bilgisayar sisteminde aritmetik, mantıksal, bitsel işlemler ve karşılaştırma gibi bilgi işlem faaliyetleri işlemleri 
    "mikroişlemci (microprocessor)" denilen birim tarafından yapılmaktadır. Mikroişlemciler entegre devre biçiminde üretilmişlerdir. 
    Mikroişlemcilere kavramsal olarak CPU (Centeral Processing Unit) de denilmektedir. Yani CPU mikroişlemcilerin kavramsal ismidir. 
    Aslında genel amaçlı bir bilgisayar sisteminde komut çalıştıran pek çok işlemci bulunabilmektedir. CPU bu işlemcileri de 
    programlayan "merkezi (central)" işlemcidir. Bilgisayar sisteminde yerel bazı işlemlerden sorumlu yardımcı işlemciler de vardır. 
    Örneğin "kesme denetleyicisi (interrupt controller)", "disk denetleyicisi (disk controller)", "DMA denetleyicisi (DMA controller)" 
    gibi.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Mikrodenetleyiciler tek bir chip içerisine yerleştirilmiş bir bilgisayar sistemi gibi düşünülebilirler. Tipik olarak bir 
    mikrodenetleyicide bir "işlemci (processor)", kendi içerisinde "RAM ve Flash EPROM", dış dünya ile haberleşmek için kullanılan 
    "IO birimi" ve bazı "çevre birimleri (peripherals)" bulunmaktadır. Mikrodenetleyicilere İngilizce "Microcontroller" ya da 
    "Microcontroller Unit (MCU)" da denilmektedir.

    Mikrodenetleyicilerin işlem kapasiteleri ve içerdikleri bellek miktarları düşük olma eğilimindedir. Ancak bunlar çok kolay 
    programlanıp uygulamaya sokulabilmektedir. Mikrodenetleyicilere "tek çiplik bilgisayar (single chip computer)" da denilmektedir. 
    Mikrodenetleyiciler özellikle gömülü sistemlerde tercih edilmektedir. Bunların düşük güç harcaması ve ucuz olmaları en büyük 
    avantajlarındandır. Gömülü uygulamalarda kullanılan pek çok mikrodenetleyici ailesi vardır. Örneğin:

    - Microchip PIC Mikrodenetleyici Ailesi (Microchip)
    - Renesas Mikrodenetleyici Ailesi (Renesas)
    - ARM Mikrodenetleyici Ailesi (Tasarımcısı ARM Holding, ancak çok çeşitli firmalar tarafından üretiliyor)
    - AVR Mikrodenetleyici Ailesi (Atmel, ancak Atmel firması 2016'da Microchip tarafından satın alındı)
    - MSP Mikrodenetleyici Ailesi (Texas Instruments)

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bazı firmalar ayrı birimler olarak tasarlanmış mikroişlemcileri, RAM'leri, ROM’ları ve diğer bazı çevre birimlerini tek bir 
    entegre devrenin içerisine sıkıştırmaktadır. Bunlara genel olarak "SoC (System on Chip)" denilmektedir. SoC mikrodenetleyicilere 
    benzese de aslında onlardan farklıdır. SoC’lar içerisindeki işlemcilerin ve belleklerin kapasiteleri yüksektir. Bunlar özel 
    amaçlı üretilirler ve bunların devrelerde kullanılmaları mikrodenetleyiciler kadar kolay değildir. Bunların en önemli avantajları 
    "az yer kaplamasıdır". Örneğin Raspberry Pi kitlerinde Broadcom isimli firmanın 2835, 2836, 2837, 2711, 2712 numaralı SoC 
    çipleri kullanılmıştır. SoC'ların RAM ve ROM bellek içermesi zorunlu değildir. Bazı SoC'lar RAM içerirken bazıları içermeyebilmektedir. 
    Örneğin Raspberry Pi 1, 2, 3 modellerinde kullanılan SoC'lar RAM içerirken Raspberry Pi 4 ve 5 modellerinde kullanılan SoC'lar 
    RAM içermemektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    SoC kavramına benzer diğer bir kavram da "SoM (Ssystem on Module)" kavramıdır. SoM bir işlemci ve onunla ilişkili bazı birimlerin
    monte edildiği kartları belirtmek için kullanılmaktadır. SoM'lar SoC'ları içerebilir. Ancak başka birimleri de içerebilir. 
    Örneğin bir SoM bir işlemci, buna ilişkin RAM, IO denetleyicisi (IO controllers) içeren bir kart olabilir. Örneğin "Raspberry Pi
    Pico" ve "Raspberry Pi Compute Module" birer SBC'den ziyade birer SoM olarak ele alınabilir. SoM kavramını zihninizde SoC ile 
    SBC arasında bir yerde konumlandırabilirsiniz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Küçük bir kit (baskılı devre) üzerine monte edilmiş bilgisayarlara SBC (Single Board Computer) denilmektedir. Genellikle 
    bu kitlerde SoC'lar, RAM'ler, başka çevre birimleri ve IO işlemleri için soketler bulunmaktadır. Örneğin Raspberry Pi, 
    Beagleboard SBC'lere örnek verilebilir. SBC'ler klavye, fare ve monitör takılarak bir masaüstü bilgisayar gibi kullanılabilmektedir.
    SBC'ler masaüstü bilgisayarlar gibi de kullanılabildiğinden bunlara Linux başta olmak üzere, Android ve Windows gibi işletim 
    sistemleri yüklenebilmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Mikroişlemcileri tasarım mimarilerine göre iki CISC (Complex Instruction Set Computers) ve RISC (Reduced Instruction Set 
    Computers) olmak üzere iki kısma ayırabiliriz. CISC ailesi işlemcilere Intel firmasının x86 ailesi işlemcilerini örnek 
    verebiliriz. ARM, MIPS, PowerPC, Itanium gibi işlemciler ise tipik RISC işlemcileridir. Her ne kadar CISC ve RISC isimleri 
    komut kümesi ile ilgili biçimde uydurulmuşsa da CISC ve RISC tasarımları başka bakımlardan da farklılık göstermektedir.

    İşlemciler (makro ve mikro) ortaya çıktığında çok fazla makine komutunun bulunmasının bir avantaj olduğu düşünülüyordu. 
    Ancak daha sonraları bunun avantajdan ziyade dezavantaj oluşturduğu görüldü. Belli bir süreden sonra artık RISC mimarisinin
    CISC mimarisinden toplamda daha iyi bir tasarım olduğu kabul görmüştür. Bu nedenle son dönem mikroişlemci tasarımlarında hep 
    RISC mimarisi kullanılmıştır.

    CISC ve RISC mimarisi arasındaki temel farklılıklar şunlardır:

    1) CISC işlemcilerinde fazla sayıda makine komutu bulunmaktadır. Bu işlemcilerde bazı komutlar temel işlemleri yaparken 
    bazıları karmaşık işlemler yapmaktadır. Halbuki RISC işlemcilerinde az sayıda temel makine komutları bulunmaktadır. Bu 
    makine komutları da daha fazla transistör kullanılarak daha hızlı çalışacak biçime getirilmiştir. Dolayısıyla CISC işlemcilerindeki 
    bazı komutlar RISC işlemcilerinde birkaç komutla karşılanabilmektedir. Ancak bu durum sanıldığının tersine daha hızlı bir 
    çalışma sağlama potansiyelindedir.

    2) CISC işlemcilerinde az sayıda yazmaç (register), RISC işlemcilerinde ise fazla sayıda yazmaç bulunma eğilimindedir. Yazmaç 
    sayıları az olunca yazmaçların tekrar tekrar aynı değerlerle yüklenmesi gerekebilmektedir. Bu da derleyicinin nesneleri 
    daha kısa sürede yazmaçlarda tutmasına yol açmaktadır. Yine CISC işlemcilerindeki bazı komutlar ancak bazı özel yazmaçlarla 
    kullanılmaktadır. (Örneğin Intel x86 işlemcilerinde MUL ve DIV gibi komutların bir operandı EAX ya da RAX yazmacında bulunmak 
    zorundadır.) Oysa RISC işlemcilerinde her işlem her yazmaçla yapılabilmektedir.

    3) CISC işlemcilerinde komutlar farklı uzunluklarda olabilmektedir. Örneğin Intel'in x86 ailesinde 1 byte olan makine komutları 
    da vardır, 5 byte olan makine komutları da vardır, 11 byte olan hatta 15 byte olan makine komutları da vardır. Halbuki RISC 
    işlemcilerinde genel olarak tüm makine komutları eşit uzunluktadır. Örneğin ARM işlemcilerinde her makine komutu 4 byte 
    uzunluktadır. Böylece işlemci komutları bellekten daha etkin bir biçimde çekip (fetch işlemi) onları daha çabuk anlamlandırmaktadır. 
    "n" sonraki ya da önceki makine komutlarının yerini belirleyebilmektedir.

    4) RISC işlemcilerinde pipeline mekanizması CISC işlemcilerine göre daha iyi gerçekleştirilmektedir. Pipeline işlemcinin
    bir makine komutunu çalıştırırken sonraki komutlar üzerinde hazırlık işlemlerini yapması anlamına gelmektedir. RISC tasarımı
    olarak pipeline mekanizmasının daha iyi yürütülmesine olanak sağlamaktadır.

    5) RISC işlemcileri load/store tarzı makine komutları kullanmaktadır. Bu işlemcilerde belleğe erişim yapan makine komutlarıyla
    aritmetik, mantıksal ve bitsel işlem yapan makine komutları birbirinden ayrılmıştır. Örneğin RISC işlemcilerinde ADD, SUB gibi
    makine komutlarının her iki operandı da yazmaç olmak zorundadır. Halbuki CISC işlemcilerinde bu tür makine komutlarının bir 
    operandı yazmaç bir operandı bellek olabilmektedir. Örneğin:

    a = b + c;

    gibi bir işlem CISC işlemcisi ile şu makine komutlarıyla yapılabilmektedir:

    - b'yi yazmaca çeken makine komutu
    - Yazmaçtaki b ile bellekteki c'yi toplayan makine komutu
    - Yazmaçtaki toplamı a'ya yerleştiren makine komutu

    Oysa aynı işlem RISC işlemcilerinde şöyle gerçekleştirilmektedir:

    - b'yi yazmaca çeken makine komutu
    - c'yi yazmaca çeken makine komutu
    - Yazmaçlardaki b ile c'yi toplayan makine komutu
    - Yazmaçtaki sonucu a'ya yerleştiren makine komutu

    Belleğe erişim komutlarıyla diğer komutların birbirinden ayrıldığı işlemcilere "load/store" işlemciler ya da "register-register"
    işlemciler de denilmektedir.

    6) RISC işlemcileri genel olarak (ancak hepsi değil) üç operandlı makine komutlarını kullanmaktadır. Oysa CISC işlemcileri 
    genellikle iki operand'lı makine komutlarını kullanır. İki operand'lı makine komutlarında işlemin sonucu operand olan yazmaçlardan
    birine yerleştirildiği için o yazmaç bozulmaktadır. Böylece derleyici o yazmaçtaki değeri yeniden kullanmak istediğinde 
    onu yeniden yüklemek zorunda kalmaktadır. Örneğin a = b + c işlemi 32 bit Intel işlemcilerinde tipik olarak şöyle 
    gerçekleştirilmektedir:

    MOV EAX, <a'nın adresi>
    ADD EAX, <b'nin adrei>
    MOV <c'bin adresi>, EAX

    Burada EAX işlemcinin bir yazmacıdır. ADD makine komutu bu yazmaçtaki değer ile bellekteki b'yi toplamakta ve sonucu yine
    EAX yazmacına yerleştirmektedir. Dolayısıyla EAX yazmacındaki a değeri artık kaybolacaktır. Bu değer yeniden kullanılmak 
    istendiğinde ise yeniden yüklemenin yapılması gerekecektir. Şimdi aynı işlemi ARM işlemcilerinde yapacak olalım:

    LDR R0, <a'nın bellek adresi>
    LDR R1, <b'nin bellek adresi>
    ADD R2, R1, R0
    STR R2, <c'nin bellek adresi>

    Burada R0, R1 ve R2 işlemcinin yazmaçlarıdır. Görüldüğü gibi ARM işlemcilerinde load/store komutları dışındaki komutlar 
    üç operand'lıdır. Bu da yazmaçlardaki değerlerin gerektiğinde bozulmamasına yol açmaktadır.

    7) RISC işlemcileri yukarıda belirttiğimiz tasarım prensiplerinden dolayı toplamda daha az güç harcama eğilimindedir. Bu da
    onların mobil aygıtlarda kullanılmasının önemli bir gerekçesini oluşturmaktadır.

    8) RISC işlemcilerinde makine komutlarının çalışma süreleri birbirine yakındır. Ancak CISC işlemcilerinde makine komutlarının 
    çalışma süreleri arasında önemli farklılıklar olabilmektedir. Örneğin ARM işlemcilerinde toplama, çıkartma, çarpma gibi 
    makine komutları 1 cycle'da yapılmaktadır. Ancak load/store komutlarının, jump komutlarının ve özel bazı komutların çalışma 
    süreleri 1 cycle'dan fazla olabilmektedir. Oysa örneğin Intel x86 işlemcilerinde komut süreleri değişik faktörlere bağlı olarak
    birbirinden çok farklılaşmaktadır.

    RISC ve CISC mimarilerini bir spektrum olarak düşünmek gerekir. Örneğin MIPS işlemcileri ARM işlemcilerine göre bu spektrumun 
    daha fazla RISC tarafındadır. Intel'in x86 işlemcilerini kategori olarak CISC grubu işlemciler olarak ele alsak da Pentium 
    işlemcileri ile birlikte bu işlemcilerde de RISC prensipleri gittikçe daha fazla kullanılır hale gelmiştir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												3. Ders 12/03/2024 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ARM işlemcilerinin tarihi "Acorn Computer" isimli İngiliz firmasına dayanmaktadır. Bu firma 80’li yılların başlarında 
    "BBC Micro" isimli 64K’lık ev bilgisayarlarını yapmıştı. Bu bilgisayarlarda Rockwell’in 8 bitlik 6502 işlemcileri kullanılıyordu. 
    Firma daha sonra "Berkeley RISC" projesinden etkilenerek kendi RISC işlemcilerini yapmaya odaklandı. Böylece ilk ARM modelleri 
    tasarlanmış oldu. Şirket 1990’da "Apple" ve "VLSI Technology" şirketleriyle ortaklıklar da kurarak ARM ismini aldı. (Eskiden 
    ARM "Acorn RISC Machine" isminden kısaltlıyordu. Fakat daha sonra bu firma kurulunca bu kısaltma "Advanced RISC Machine" haline 
    getirildi.) Apple firması bu yeni firmaya maddi destek sağlamıştır. "VLSI Technology" firması ise ekipman tedarik etmiştir.
    Acorn ise az sayıda tasarım mühendisini bu yeni firmaya aktarmıştır. 2016 yılında "SoftBank Group" ARM hisselerinin önemli bir 
    bölümünü aldı. 2018'de ARM'ın Çin şubesinin yarısından fazlasını "Chine Investment" şirketine sattı. 2020'de "NVidia", ARM'ı 
    SoftBank Group'tan satın almak istediyse de satış gerçekleşmedi. Bugün "SoftBank Group" ARM'ın %90 civarındaki hisselerine 
    sahiptir. Geri kalan hisseleri kurucu ortaklarda ve halka arzdadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ARM bir tasarım firmasıdır. Yani fabrikalara sahip değildir. ARM yaptığı tasarımları lisanslandırarak üretici firmalara 
    satmaktadır. ARM'ın uyguladığı dört tür lisans vardır:

    Entegre Devre Lisansı (Full Custom License): Bu lisans müşterinin mikrodenetleyici tasarımını kendi özel ihtiyaçlarına 
    göre özelleştirmesine ve optimize etmesine olanak tanır. Örneğin Apple gibi, Qualcomm gibi, Samsung gibi firmalar bu 
    lisansa sahiptir.

    Mimari Lisans (Architecture License): Bu lisans ARM'nin genel mikroişlemci mimarisine erişim sağlayan bu lisanstır. Ancak, 
    bu lisans müşterinin mikrodenetleyiciyi özelleştirmesine izin vermez. Yani bu lisansa sahip olanlar işlemci tasarımını
    kullanarak üretim yapabilirler ancak onu özelleştiremezler.

    Çekirdek Lisansı (Processor IP License): Bu lisans ile ancak müşteri belli bir ARM işlemcisini (core) üretebilmektedir.

    Geliştirici Lisansı (Development License): Bu lisans ARM'nin tasarım araçlarına erişim sağlayan bir lisanstır. Müşteri 
    bu araçları kullanarak kendi işlemcilerini tasarlayabilir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ARM dünyasında çalışmak için bazı terimler hakkında bilgi sahibi olmak gerekir. ARM firması kendine özgü terimler uydurmuştur.
    Bu dünyada en çok karşılaşılan terimler "core", "cortex" ve "version" terimleridir.

    ARM dünyasında "core" terimi belli bir mikroişlemci tasarımını belirtmektedir. Bu tasarım üretici firmalar tarafından 
    fiziksel hale getirilmektedir. Bir grup "core" bir araya getirildiğinde ve işlemciyle ilişkili birtakım birimler de bunlara 
    eklendiğinde "cortex'ler" oluşmaktadır. ARM firması ARM'ın klasik versiyonlarında "cortex" terimini kullanmamıştır. Cortex
    terimi ARM11'den sonra kullanılmaya başlanmıştır. Bir cortex belli sayıda "core" içerebilir. Bu "core"lar noktalı sayılara
    (floating point) ilişkin işlem yapan birimlere sahip olabilirler. Cortex içerisindeki core'ların belli hızları vardır. Core 
    ve cortex terimleri daha çok çip düzeyindeki mimariyi belirtmektedir. Ancak cortex'lerde kullanılan işlemcilerin (core'ların) 
    sistem programcısını ilgilendiren "komut kümeleri (instruction sets)" de vardır. Böylece bir grup cortex belli bir komut
    kümesi ile kullanılabilecek biçimde tasarlanmıştır. Komut kümesi mimarisine "ARM Versiyonları" ya da İngilizcesiyle "ARM ISA
    (Instruction Set Architecture) Mimarisi" denilmektedir. Biz sistem programcısı olarak elimizdeki cortex'in hangi komut kümesini 
    kullanan ARM versiyonuna ilişkin olduğunu bilmek durumundayız. Burada dikkat edilmesi gereken nokta "Cortex teriminin donanımsal 
    mimariyi, versiyonun ise yazılımsal mimariyi belirtiyor" olmasıdır. O halde gömülü sistem geliştiricisi olarak bizim ilgilendiğimiz 
    ARM içeren kart ile ilgili şu iki özelliği biliyor olamamız gerekir:

    1) Kartımızda ARM'ın hangi cortex'i kullanılmıştır?
    2) Bu cortex'in ilişkin olduğu versiyon numarası nedir?

    Yukarıda da belirttiğimiz gibi farklı cortex'ler aynı versiyon numarasını kullanabilmektedir.

    ARM dünyasında üç mimari profili (profile) bulunmaktadır:

    1) A (Application) Profili
    2) R (Realtime) Profili
    3) M (Microcontroller) Profili

    Bu profiller ilgili cortex'lerin hangi tür uygulamalarda ideal olarak kullanılabileceğini belirtmektedir. Profil isimleri 
    cortex'lerde ve versiyon numaralarında '-' karakterinden sonra A, R, M harfleriyle belirtilmektedir. Örneğin "Cortex-A8" ve 
    "ARMv7-A" gibi. A profilleri masasüstü işletim sistemlerinin çalıştırılabileceği, tamamen kişisel bilgisayar olarak kullanılabilecek 
    cortex'leri belirtmektedir. Biz kursumuzda "gömülü Linux programcısı" olarak bu "A" profilleriyle çalışacağız. R profilleri
    "gerçek zamanlı (realtime)" uygulamalar için daha uygun olabilecek cortex'leri belirtmektedir. R profilleri ile A profilleri 
    birbirlerine benzemektedir. R profilleri A profillerine göre çok daha seyrek kullanılmaktadır. M profilleri ARM'ın mikrodenetleyici
    olarak kullanılan cortex'lerini belirtmektedir. Bu cortex'ler genel olarak Linux işletim sisteminin yüklenmesine izin vermemektedir. 
    Bu cortex'ler genellikle "bare-metal" programlarla ya da gerçek zamanlı işletim sistemleriyle kullanılmaktadır.

    ARM'ın iki önemli versiyonu ARMv7-A ve ARMv8-A dır. ARMv7 32 bitlik bir arayüz sunmaktadır. Dolayısıyla bu komut mimarisini 
    kullanan cortex'ler 32 bitlik işlemciler içermektedir. ARMv8-A versiyonları ise 64 bitlik arayüz sunmaktadır. Dolayısıyla bu 
    versiyonları kullanan cortex'ler 64 bitlik işlemcilere ilişkindir. Ancak ARM cortex'lerinin bir grubu hem 32 bit hem de 64 bit 
    olarak kullanılabilmektedir. Bu cortex'lerdeki işlemcileri kullanan işletim sistemleri 32 bitlik ve 64 bitlik programları 
    zaman paylaşımlı olarak bir arada çalıştırabilmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Mikroişlemciler ilk çıktığında 8 bit işlemleri yapabiliyordu (örneğin 8080, 6800 gibi işlemciler). Bunlara 8 bitlik mikroişlemci 
    deniyordu. Sonra 16 bitlik mikroişlemciler çıktı (örneğin Intel'in 8086, 8088 işlemcileri gibi). Bunu 32 bit işlemciler izledi. 
    Günümüzde artık ağırlıklı olarak 64 bit işlemciler kullanılmaktadır. Pekiyi bir işlemcinin N bitlik olmasının anlamı nedir? 
    Bu soruya yanıt verelim:

    - N bitlik bir işlemcide tek hamlede (yani tek bir makine komutuyla) N bit üzerinde işlem yapılabilmektedir. Örneğin 32 bitlik 
    bir mikroişlemcide tek bir makine komutu ile 32 bitlik iki sayıyı toplayıp çarpabiliriz.

    - N bitlik bir mikroişlemciler genellikle (ama her zaman değil) 2^N uzunlukta bir fiziksel RAM'i adresleyebilmektedir. Örneğin
    32 bitlik bir mikroişlemciye biz tipik olarak 2^32 = 4GB'lik bir RAM bağlayabiliriz. Elimizdeki RAM 64GB olsa bile 32 bit
    bir mikroişlemci bu RAM'in ancak ilk 4GB'sini kullanabilmektedir. Tabii bu durum her zaman böyle değildir. Örneğin 8086 
    işlemcisi 16 bit olduğu halde 2^16 değil 2^20 uzunluğunda (1MB) fiziksel belleği adresleyebiliyordu. Benzer biçimde bugünkü
    64 bitlik Intel ve AMD işlemcileri gereksiz olduğu gerekçesiyle 2^64 değil 2^48 uzunluğundaki RAM'leri adresleyebilmektedir.

    - N bitlik bir mikroişlemcide genellikle işlemci ile RAM arasında transfer N bit olarak yapılmaktadır. Örneğin 32 bitlik
    bir mikroişlemcide tek bir makine komutuyla RAM'den CPU'ya 32 bitlik bir veri transfer edilebilir.

    8 bitten 16 bite geçişte ve 16 bitten 32 bite geçişte çok farkedilir bir hızlanma yaşanmıştır. Ancak 32 bitten 64 bite 
    geçişte hızlanma öncekiler kadar olmamıştır. Bunun nedeni 64 bitlik işlemlerin aslında yoğun olarak yapılmadığındandır. Ancak 
    32 bitten 64 bite geçişin en önemli etkisi işlemciye bağlanabilecek RAM miktarı üzerinde olmuştur. Örneğin elimizde 8 GB 
    RAM'li Raspberry Pi 5 olsun. Buradaki ARM cortex'i hem 32 bit hem de 64 bit işlemci gibi çalışabilmektedir. Dolayısıyla biz 
    bu kartımıza 32 bitlik de 64 bitlik de Linux yükleyebilriz. Ancak 32 bitlik Linux işletim sistemi işlemciyi 32 bit modda 
    çalıştıracağı için işletim sistemi 8GB RAM'in ancak 4GB'sini kullanabilecektir. Bu 8GB RAM'in tamamından istifade edebilmemiz 
    için işlemcinin 64 bit modunda çalıştırılması dolayısıyla da işletim sisteminin 64 bit olması gerekecektir.

    Pekiyi 128 bitlik işlemciler tasarlansa, bunlar daha hızlı bir çalışma sunmaz mı? Neden 128 bitlik işlemciler tasarlanmıyor? 
    İşte 128 bitlik tamsayı işlemlerine çok nadir gereksinim duyulmaktadır. 2^128 uzunluğunda RAM zaten şu an için erişilmesi 
    imkansız bir RAM miktarıdır. O halde işlemcilerin 64 bitten 128 bite çıkartılmasının şu an için önemli bir faydası olmayacaktır.
    Ancak tabii gelecekte böyle bir ihtiyaç ortaya çıkabilecektir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Popüler ürünlerde kullanılan ARM cortex'leri şunlardır:

    iPhone 14: Apple'ın A15 isimli SoC'unu kullanmaktadır. Bu SoC'un içerisinde Apple'ın ARMv8.6‑A versiyonunu kullanan Avalanche 
    Cortex'i vardır. Buradaki core'lar yalnızca 64 biti desteklemektedir.

    iPhone 15: Apple'ın A16 isimli SoC'unu kullanmaktadır. Bu SoC'un içerisinde Apple'ın ARMv8.6‑A versiyonunu kullanan Everest
    Cortex'i vardır. Buradaki core'lar yalnızca 64 biti desteklemektedir.

    Apple M1 SoC: Apple'ın ARMv8.4‑A versiyonunu kullanan FireStorm isimli Cortex'i vardır. Buradaki core'lar yalnızca 64 biti 
    desteklemektedir.

    Apple M2 SoC: Apple'ın ARMv8.6‑A versiyonunu kullanan Avalanche ve Blizzard isimli Cortex'leri vardır. Buradaki Core'lar
    yalnızca 64 biti desteklemektedir.

    Apple M3 SoC: Apple'ın ARMv8.6‑A versiyonunu kullanan Avalanche ve Blizzard isimli Cortex'leri vardır. Buradaki core'lar
    yalnızca 64 biti desteklemektedir.

    Samsung Galaxy S24: Qualcomm firmasının Snapdragon-8 SoC'unu kullanmaktadır. Bu SoC içerisinde ARMv9-A versiyonunu kullanan 
    Cortex A715 bulunmaktadır.

    Redmi Note 11: Xiaomi firmasının ürünüdür. Qualcomm Snapdragon-685 SoC'unu kullanmaktadır. Bu SoC'un içerisinde ARMv8.2-A 
    versiyonuna ilişkin Cortex A78 bulunmaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bu kursta kullanacağımız SBC'lerin üzerinde bulunan ARM cortex'leri ve bunların versiyon numaraları da şöyledir:

    Raspberry Pi 3: BCM2837 SoC'u kullanılmıştır. Bu SoC'un içerisinde ARMv8-A versiyonuna ilişkin Cortex-A53 bulunmaktadır. Bu 
    cortex'teki işlemciler hem 32 bit hem de 64 bit modda çalışabilmektedir. Dolayısıyla bunlara 32 bit ve 64 bit Linux sistemleri 
    yüklenebilmektedir.

    Raspberry Pi 4: BCM2711 SoC kullanılmıştır. Bu SoC'un içerisinde ARMv8-A versiyonuna ilişkin Cortex-A72 bulunmaktadır. Bu 
    cortex'teki işlemciler hem 32 bit hem de 64 bit modda çalışabilmektedir. Dolayısıyla bunlara 32 bit ve 64 bit Linux sistemleri 
    yüklenebilmektedir.

    Raspberry Pi 5: BCM2712 Bu SoC'un içerisinde ARMv8.2-A versiyonuna ilişkin Cortex-A76 bulunmaktadır. Bu cortex'teki 
    işlemciler hem 32 bit hem de 64 bit modda çalışabilmektedir. Dolayısıyla bunlara 32 bit ve 64 bit Linux sistemleri 
    yüklenebilmektedir.

    BeagleBone Black 4G ve BeagleBone Black Wireless: Texas Instruments firmasının Sitara-AM3358 SoC'unu kullanmaktadır. Bu SoC'un 
    içerisinde Cortex-A8 kullanılmıştır. Bu cortex 32 bit işlemcilerden oluşmaktadır. Bunların kullandığı komut mimarisi de 
    ARMv7-A'dır. BeagleBone Black'ler 32 bit ARM işlemcilerini kullandığı için bunlara yalnızca 32 bit Linux sistemleri
    yüklenebilmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												4. Ders 14/03/2024 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi de Raspberry Pi 5 donanımını inceleyelim. Kartın üzerinde BCM2712 SoC'u hemen dikkati çekmektedir. Bu SoC'un hemen 
    yanında RAM chip'i bulunmaktadır. Raspberyy Pi 5'in 1GB, 2GB, 4GB ve 8GB RAM'li modelleri bulunmaktadır. Raspberry Pi 5 
    modelinde toplam 4 USB soketi bulunmaktadır. Bunlardan iki tanesi USB 2.0, diğer 2 tanesi de USB 3.0'dır. Klavye ve fare gibi 
    yavaş aygıtları USB 2.0 girişlerine bağlayabilirsiniz. Bunların hemen yanında Ethernet girişi bulunmaktadır. Kenarlarda toplam 
    40 tane (20'lik iki sıra) GPIO uçları bulunmaktadır. Bu GPIO uçları aygıtın dış dünya ile elektriksel olarak haberleşmesi
    için kullanılmaktadır. Raspberry Pi 5'te iki Micro HDMI girişi bulunmaktadır. Bu uçlardan birine monitörümüzü bağlamalıyız.
    Raspberry Pi 5 modelinde arka tarafta SD kart girişine yakın bir bölgede çok küçük ON/OFF düğmesi bulunmaktadır. Bu düğme 
    bilgisayarlarımızdaki "Power Off" düğmesi gibidir. Ayrıca kamera ve LCD bağlamak için iki adet MIP DSI/CSI bulunmaktadır. 
    Kartın arka tarafında bir Micro SD kart girişi bulunmaktadır. Buraya disk görevini görecek olan micro SD kartımızı takacağız.
    Giriş kısmında da belirttiğimiz gibi şu an için 64GB'lik SD kartlar fiyat bakımından uygun bir büyüklüktür. Ancak denemeler 
    için birden fazla (bunlar daha küçük de olabilir) SD kart kullanabilirsiniz. Kart üzerindeki diğer bileşenlerin bazılarını 
    ilerleyen bölümlerde ayrıca ele alacağız.

    Kart üzerindeki bileşenleri inceleyebilmek için aşağıdaki bağlantıyı kullanabilirsiniz:

    https://grobotronics.com/raspberry-pi-5-4gb.html

    Raspberry Pi'ın resmi iki sitesi raspberrypi.com ve raspberrypi.org siteleridir. Raspberry Pi ile ilgili tüm dokümanlar 
    https://www.raspberrypi.com/documentation/ bağlantısından elde edilebilir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Raspberry Pi bir proje olarak özellikle az gelişmiş ülkelerde düşük fiyatlı bilgisayar oluşturmayı hedeflemiştir. Dolayısıyla
    biz Raspberry Pi'ı tamamen Linux tabanlı bir kişisel bilgisayar olarak kullanabiliriz. Kursumuzda önce Raspberry Pi'ın 
    kişisel bilgisayar olarak nasıl kullanıldığı üzerinde duracağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Raspberry Pi için birkaç işletim sistemi oluşturulmuştur. Ancak bunlardan en yaygın kullanılan ikisi Linux'un "Raspberry Pi 
    OS (eski ismiyle Raspbian)" ve "Ubuntu" dağıtımlarıdır. Raspberry Pi ile tam uyum içinde olan ana dağıtım "Raspberry Pi OS"
    dağıtımıdır. Biz en azından "Raspberry Pi OS" ve "Ubuntu" dağıtımlarını ayrı micro SD kartlara yüklemenizi tavsiye ediyoruz.

    Bir bilgisayar sistemini reset ettiğimizde işletim sisteminin (ya da bu görevdeki yazılımın) yüklenmesini sağlayan mekanizmalara
    "boot loader" denilmektedir. Gömülü sistemlerde kullanılan "boot loader" mekanizmaları kursumuzun ayrı bir konusunu oluşturmaktadır. 
    Ancak kabaca boot işlemi şöyle gerçekleşmektedir: Biz mikroişlemciyi reset ettiğimizde çalışma belli bir adresten başlatılmaktadır. 
    Yani işlemci reset edildiğinde çalıştırılacak kodun önceden hazır bir biçimde kalıcı bir bellekte (bugün bunlar için flash 
    EPROM'lar kullanılmaktadır) bulunuyor olması gerekir. Buradaki kod çeşitli donanım birimlerini programlar ve onları kullanıma 
    hazır hale getirir. Sonra boot loader'ın işletim sisteminin yüklenmesinden sorumlu olan kısmı RAM'e yüklenir. Boot loader'ın 
    bu kısmı işletim sistemini yükler. Zaten bu konular ileride ayrıntılarıyla ele alınacaktır. Bizim bu aşamada bilmemiz gereken 
    şey işletim sistemimizin micro SD karta nasıl yükleneceğidir. Çünkü bu işlem yapıldıktan sonra artık her şey otomatik 
    gerçekleşmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Micro SD kartımıza işletim sisteminin yüklenmesi gelişi güzel yapılacak bir işlem değildir. Çünkü belli programların disk 
    üzerinde belli sektörlerde bulunuyor olması gerekmektedir. Bunu sağlamanın basit bir yolu önceden hazırlanmış bir imaj dosyasını 
    micro SD kartımıza aktarmaktır. Raspberry Pi için bu imaj dosyaları hazır bir biçimde zaten bulunmaktadır. O halde bizim 
    tek yapacağımız şey bu imaj dosyalarını indirip micro SD kartımızın içerisine aktarmaktır. Ancak son birkaç yıldır bu işlemin
    kolaylaştırılması için Raspberry Pi ekibi "Raspberry Pi Imager" denilen bir program geliştirmiştir. Bu program menüler
    eşliğinde kullanıcının istediği işletim sisteminin imaj dosyasını indirip micro SD karta bunları yazmaktadır. Dolayısıyla 
    bu program işimizi hepten kolaylaştırmaktadır. Raspberry Pi Imager programını aşağıdaki bağlantıdan indirebilirsiniz:

    https://www.raspberrypi.com/software/

    RaspberryImager programı indirilip kurulup çalıştırılınca program bize üç şey sormaktadır?

    1) Hangi Rasperry Pi modelini kullandığımızı
    2) Hangi işletim sistemini yükleyeceğimizi
    3) Hangi micro SD karta yüklemeyi yapacağımızı

    Bu sorulara yanıt verdikten sonra yüklenecek Linux üzerinde bazı basit konfigürasyon işlemleri de "Edit Setting" seçeneği 
    yapılabilmektedir. Tabii bunları yüklemeden sonra da yapabiliriz.

    Raspberry Pi Imager her şeyi kendisi yapmaktadır. Program önce ilgili imajı yerel makineye indirir, sonra da micro SD karta 
    yazma yapar.

    Tabii biz Raspberry Pi Imager programını kullanmak zorunda değiliz. Zaten bu program eskiden yoktu. Eğer bu programı kullanmayacaksak
    işletim sistminin SD kart imajını indirip SD karta yazma yapan bir programla onu karta aktarmamız gerekir. SD karta aktarma 
    yapan pek çok bedava program vardır. Bunlardan en popüler iki tanesi "Rufus" ve "Etcher" programlarıdır. Manuel kurulum 
    için işletim sistemi imajlarını aşağıdaki bağlantıdan indirebilirsiniz:

    https://www.raspberrypi.com/software/operating-systems/

    Artık her şey hazırdır. Bundan sonra şu bağlantıları yapmalısınız:

    1) SD kartınızı Raspberry Pi'ınıza yerleştiriniz.
    2) Monitörünüzü Raspberry Pi'ınızın micro HDMI soketine takınız.
    3) Klavye ve farenizi Raspberry Pi'ınızın USB soketlerine takınız.
    4) USB Type-C soketi ile Raspberry Pi'ınıza güç veriniz.

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												5. Ders 19/03/2024 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Gömülü sistemimize Linux'u kurduktan sonra ona başka bir makineden erişmek isteyebiliriz. Bunun çeşitli yolları varsa da 
    en tipik üç yöntem kullanılmaktadır:

    1) SSH protokolü ile erişim
    2) VNC protokolü ile erişim
    3) Microsoft Remote Desktop Protokolü (RDP) ile erişim

    VNC ve RDP ile gömülü aygıtımızdaki Linux'a erişebilmemiz için orada bir pencere yönetici programın (yani masaüstü sisteminin)
    kurulu olması gerekir. RSapberry Pi güçlü bir donanıma sahip olduğu için ve kişisel bir bilgisayar gibi kullanılabildiği için
    buraya yüklediğimiz Linux sistemlerinde pencere yöneticisi zaten bulunuyor olacaktır. Ancak server sistemlerinde ve pek çok 
    gömülü Linux sisteminde bir pencere yöneticisi bulunmamaktadır. Bu durumda SSH protokolü ile erişim sağlanmaktadır. Eskiden 
    SSH protokolünden önce telnet isimli benzer bir protokol vardı. Ancak telnet protokolünün güvenilirliği zayıf olduğu için 
    SSH protokolü geliştirildi. Bugün konsol tabanlı bir ortamda bir Linux sistemine uzaktan bağlanmak için genellikle SSH protokolü 
    kullanılmaktadır.

    Her türlü TCP/IP uygulamalarında haberleşmenin yapılabilmesi için bir "server" program ile bir de "client" programın bulunuyor 
    olması gerekir. Bize erişimi sağlayan uzak makinedeki program "server" programdır. Bizim erişmek için kullandığımız program 
    ise "client" programdır. SSH server ve client programlar zaten işletim sistemlerinin pek çoğunun içinde default bir biçimde 
    bulunmaktadır. Biz Raspberry Pi'ımıza Raspberry OS işletim sistemini kurduğumuzda zaten SSH client ve server programlar yüklü 
    durumdadır. Ancak eğer gömülü sisteminizde SSH server program bulunmuyorsa onu şöyle kurabilirsiniz:

    $ sudo apt-get install openssh-server

    Bu işlem SSH server programının kurulup çalışır hale getirilmesini sağlamaktadır. client program da benzer biçime kurulabilir:

    $ sudo apt-get install openssh-client

    ssh client programıyla bağlantı aşağıdaki gibi sağlanabilir:

    $ ssh user_name@host_name

    Bizim bağlantı sağlayabilmek için uzak makinede bir kullanıcının ismini ve parolasını biliyor olmamız gerekir. SSH client programı 
    benzer komut satırı argümanlarıyla Windows sistemlerinde ve macOS sistemlerinde de hazır bir biçimde bulunmaktadır. Dolayısıyla
    Windows ve macOS sistemlerinden de gömülü aygıtınıza benzer biçimde bağlanabilirsiniz. SSH programı ile bağlantı yapılırken 
    kullanıcı ismini "-l" seçeneği ile de belirtebilirsiniz. Örneğin:

    $ ssh -l user_name host_name

    VNC ile bağlantı da yine bir VNC server programıyla bir de VNC client programının karşılıklı makinelerde yüklü olması gerekmektedir. 
    Bizim bağlanmak istediğimiz makinede server programının çalışıyor olması, bağlantıyı sağlamak istediğimiz tarafta da client programın 
    yüklü olması gerekir. Raspberry Pi'daki eski Raspbian işletim sisteminde VNC server hazır bir biçimde bulunmuyordu. Ancak belli 
    süre sonra artık Raspberry Pi OS içerisinde zaten VNC server programı hazır bir biçimde bulunmaktadır. Ancak VNC server hazır bir 
    biçimde bulunuyor olsa da onun çalışır hale getirilmesi gerekmektedir. Bu işlem pratik olarak ana menüden "Preferences/Raspberry Pi 
    Configurations/Interfaces" sekmesinden yapılabilir. Yukarıda da belirttiğimiz gibi VNC server için Linux sistemimizde bir pencere 
    yöneticisinin çalışıyor olması gerekir. Yani içerisine grafik arayüz yüklenmemiş olan bir Linux sistemine VNC ile bağlanmanın da 
    bir anlamı yoktur.

    VNC server ve client program olarak çeşitli programlar kullanılabilmektedir. Linux'ta en yaygın kullanılan VNC server program
    "tightvncserver" isimli programdır. Bunun kurulumu şöyle yapılabilir:

    $ sudo apt-get install tightvncserver

    Ancak server program kurulduktan sonra bazı ayarlamaların yapılması gerekmektedir. Bu konu ileride başka bir bölümde ele 
    alınacaktır.

    Biz pencere yönetici sisteminin bulunduğu bir Linux sistemine Microsoft'un "Remote Desktop Protocol(RDP)"ünü kullanarak da 
    bağlanabiliriz. Tabii bunun için de bağlanacağımız makinede RDP server programının çalışıyor durumda olması gerekmektedir. 
    Bu protokol Microsoft'a ait olduğu için Linux sistemleri tarafından aktif bir biçimde kullanılmamaktadır. RDP server programı
    aşağıdaki gibi kurulabilir:

    $ sudo apt-get install xrdp

    RDP protokülü için client program olarak genellikle Windows'taki "Uzak Masaüstü Bağlantısı" kullanılmaktadır. Ancak bu 
    protokol için başka client programlar da bulunmaktadır.

    VNC ve RDP protokolleri hem Linux sistemlerinde hem de Windows ve macOS sistemlerinde kullanılabilmektedir. Windows dünyasında
    RDP programları VNC programlarına göre daha hızlı bir biçimde çalışmaktadır. Ancak Linux'ta VNC programları RDP programlarına 
    göre daha hızlıdır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    BeagleBoard'lar en yaygın kullanılan SBC'ler arasındadır. Biz de kursumuz Beaglebone Black (BBB) kullanacağımızı söylemiştik.
    BBB'nin dokümantasyonuna aşağıdaki bağlantıdan erişilebilir:

    https://docs.beagleboard.org/latest/https://docs.beagleboard.org/latest/

    BBB kendi içerisinde ismine "eMMC (Embedded Multi-Media Card)" denilen on-board flash belleğe sahiptir. Zaten ürün satın 
    alındığında bu flash belleğin içerisinde bir Debian Linux dağıtımı yüklü durumdadır. Bu nedenle biz board'umuzu güç kaynağına 
    taktığımızda zaten default olarak bu on-board flash içerisindeki Linux boot edilmektedir. BBB'yi kullanıma hazır hale getirmek 
    için şunlar yapılmalıdır:

    1) BBB'ye güç kaynağını bağlamak için iki soket kullanılabilmektedir. Birincisi eski tip yuvarlak sokettir (DC barrel jack). 
    İkincisi ise mini USB soketidir. Kullanıcılar genellikle güç kaynağını mini USB soketine bağlamaktadır. (Tabii bu mini USB 
    girişi doğrudan masaüstü bilgisayarımızın USB girişine bağlanabilir. Bu durumda gücü buradan alacaktır.)

    2) BBB üzerinde bir tane standart USB soket vardır. Genellikle bu sokete combo klavye fare bağlanmaktadır. Ancak birden fazla
    bağlantı için USB hub kullanılabilir.

    3) BBB'nin klasik modellerinde internet için "wireless" bağlantı yoktur. Dolayısıyla internet bağlantısı sağlamak için ethernet
    soketi kullanılmaktadır. Ancak on-board flash üzerine yüklenmiş olan Debian içerisinde "Internet over USB" için gerekli aygıt
    sürücüler (device drivers) bulunmaktadır. Bu sayede biz örneğin mini USB kablosu ile BBB'yi Windows ya da Linux makinemize 
    bağlayıp BBB'nin oradaki interneti kullanmasını sağlayabiliriz.

    4) BBB'de de Raspberry Pi'da olduğu gibi micro HDMI soketi vardır. Bu sokete doğrudan monitörümüzü bağlayabiliriz.

    Tipik olarak BBB'yi ilk kez kullanırken mini USB soketini masaüstü bilgisayarımızın standart USB soketine takarız. Böylece
    masaüstü bilgisayarımız otomatik olarak BBB'nin on-board flash belleğindeki bir disk bölümünü bir sürücü biçiminde görür. 
    Bu sürücü içerisinde host sistem için gerekli olan aygıt sürücüler bulunmaktadır. Eğer host makine olarak Windows'ta çalışıyorsak 
    aygıt sürücüleri yüklerken "UEFI BIOS'tan imzasız aygıt sürücüleri için" izin vermemiz gerekir. Bunun için aşağıdaki bağlantıdaki 
    yönergeleri izleyebilirsiniz:

    https://www.terasic.com.tw/wiki/Disable_Driver_Signature_Enforcement_in_Windows10_x64

    Biz bu biçimde USB bağlantısı yaptığımızda artık IP protokol ailesini USB üzerinden kullanabilir duruma geliriz. Dolayısıyla
    SSH ile BBB'ye bağlanabiliriz. BBB'de yüklü olan Debian dağıtımının default kullanıcı ismi "debian", default parolası ise "temppwd"
    biçimindedir. Tabii hazır yüklü olan Linux dağıtımının klavye ayarları İngilizce'dir. Türkçe klavye ile yazarken buna dikkat 
    ediniz. SSH bağlantısı için BBB'deki IPv4 adresi "192.168.7.2" biçimindedir. Yani bağlantı aşağıdaki gibi yapılabilir:

    $ ssh debian@192.168.7.2

    parola olarak da "temppwd" girilmelidir. On-board flash üzerine yüklenmiş olan Debian dağıtımında bir pencere yönetici program
    bulunmamaktadır. Zaten BBB'nin on-board flash belleği 4GB'dir.

    Biz BBB'nin mini USB kablosunu host makinemize bağladığımızda artık host makinemizden BBB'ye SSH yoluyla erişebiliriz. Ancak
    BBB'deki Linux sisteminin masaüstü host makinemizdeki interneti kullanabilmesi için Windows ve Linux sistemlerinde bazı 
    ayarların da yapılması gerekmektedir. Tabii BBB'nin interneti kullanabilmesini sağlamanın en normal ve hızlı yolu doğrudan 
    ADSL Router'ımızdan gelen Ethernet RJ45 jakını BBB'ye takmaktır. Biz "Internet over USB" yerine bu yöntemi kullanmanızı 
    öneriririz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												6. Ders 21/03/2024 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    BBB'ni on-board flash belleğine işletim sisteminin yeni bir sürümümü yerleştirebiliriz. Aslında Beagleboard için hazır imajlar
    zaten bulundurulmaktadır. Aşağıdaki bağlantıdan size uygun olan hazır imajları indirebilirsiniz:

    https://www.beagleboard.org/distros

    On-board flash belleğe işletim sistemini yüklemek için sırasıyla şu adımlardan geçilmelidir:

    1) Yukarıda belirttiğimiz sayfadan BBB için uygun sürüm indirilir. Bu sayfadaki hazır imajların bir bölümünde "Flasher" 
    ibaresi vardır. Bu "flasher" ibareli imajlardan biri indirilmelidir. Örneğin sınıftaki denemede aşağıdaki imaj indirilmiştir:

    AM335x 11.7 2023-09-02 4GB eMMC IoT Flasher

    Buradaki "IoT" sözcüğü indirilecek Debian dağıtımının IoT amaçla oluşturulmuş minimalist bir dağıtım olduğunu belirtmektedir. 
    Örneğin alternatif bir imaj da şu olabilir:

    AM335x 11.7 2023-09-02 4GB eMMC Xfce Flasher

    Burada "IoT" ibaresi yerine "Xfce" ibaresi bulunmaktadır. Xfce küçük bir pencere yöneticisidir. Ancak maalesef bu pencere 
    yöneticisi bile BBB'nin pek çok versiyonunda sistem kısıtları nedeniyle çok yavaş çalışma eğilimindedir.

    2) İndirilen imaj zip'li olduğu için açılmalıdır. Açılan imajın uzantısının ".img" olması gerekir.

    3) İmaj SD karta Rufus ya da Etcher benzeri bir programla yazılmalıdır.

    4) SD karta yazma işlemi bittikten sonra SD kart BBB'nin SD kart yuvasına takılır. Sonra "Boot switch" denilen küçük düğmeciğe
    basılarak board'a güç verilir. Güç verildikten sonra 7, 8 saniye boot switch'e basılmaya devam edilmelidir. Sonra el boot 
    switch'ten çekilir. BBB'nin dört LED'i önce tamamen yanar. Sonra sırasıyla yanıp sönmeye başlar. Bu durum yazmanın başladığı
    anlamına gelmektedir. Yazma takriben 5 dakika civarında sürmektedir. Yazma bittikten sonra LED'ler tamamen söner. Boot switch
    Micro SD kartın yanındaki switch'tir.

    5) SD kart çıkartılarak sistem yeniden boot edilir. Artık on-board flash üzerine çektiğimiz işletim sistemi ile boot işlemini
    yapmış olduk. Ancak bizim indirdiğimiz imaj İngilizce (US) olarak ayarlanmıştır. Dolayısıyla default klavye ayarları da 
    İngilizce klavye biçimindedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Debian türevi sistemlerde klavye ayarlarını değiştirmenin birkaç yolu vardır. Öncelikle locale ayarlarının Türkiye ve Türkçe 
    biçiminde yapılmasını tavsiye ederiz. Çünkü BBB için hazır bulundurulan Debian dağıtımında default locale ayarları Amerika 
    ve İngilizce biçimindedir. Bunu sağlamanın bir yolu aşağıdaki komutu kullanmaktadır:

    $ sudo dpkg-reconfigure locales

    Karşımıza bir menü gelecektir. Bu menüden locale'i "tr_TR.UTF-8" biçiminde ayarlayabilirsiniz. Bu ayarlamadan sonra artık 
    /etc/default/locale dosyası aşağıdaki gibi olacaktır:

    # File generated by update-locale
    LANG=tr_TR.UTF-8

    Ancak locale'in ayarlanması klavye düzenini değiştirmemektedir. Locale'in ayarlanması birtakım mesajların Türkçe çıkmasını, 
    terminal aygıt sürücüsünün girdi ve çıktılarının encoding'ini belirlemektedir. Klavye düzeni manuel olarak "/etc/default/keyboard"
    dosyası üzerinde güncelleme yapılarak ayarlanabilir. Bu dosyanın BBB'deki default içeriği şöyledir:

    # KEYBOARD CONFIGURATION FILE
    # Consult the keyboard(5) manual page.

    XKBMODEL="pc105"
    XKBLAYOUT="us"
    XKBVARIANT=""
    XKBOPTIONS=""
    BACKSPACE="guess"

    Bizim Türkçe klavye için buradaki XKBLAYOUT satırını aşağıdaki gibi değiştirmemiz gerekir:

    XKBLAYOUT="tr"

    Ancak bu dosyada değişiklik yapılması klavye düzeninin değişeceği anlamına gelmemektedir. Bu ve birkaç dosyaya bakarak klavye 
    düzenini ayarlayan bazı programlar vardır. Bunların çalıştırılması gerekir. Bunun için "setupcon" programı kullanılabilir:

    $ sudo setupcon

    Artık klavyemiz Türkçe olarak ayarlanmıştır. Ancak iki problem daha vardır. Birincisi BBB'deki Debian dağıtımındaki default 
    console fontu Türkçe'yi desteklememektedir. Yani klavyedeki tuşların yerleri doğru olarak ele alınmaktadır ama Türkçe 
    karakterler doğru görüntülenememektedir. İkinci sorun ise BBB'yi reboot ettiğimizde yaptığımız ayarların otomatik devreye 
    girmemesidir.

    Console ekranının fontunu değiştirmek için "/etc/default/console-setup" dosyasının edit edilmesi gerekmektedir. Bu dosyasının 
    BBB'deki default durumu şöyledir:

    # CONFIGURATION FILE FOR SETUPCON
    # Consult the console-setup(5) manual page.

    ACTIVE_CONSOLES="/dev/tty[1-6]"
    CHARMAP="ISO_8859-15"
    CODESET="guess"
    FONTFACE="Fixed"
    FONTSIZE="8x16"
    VIDEOMODE=
    # The following is an example how to use a braille font
    # FONT='lat9w-08.psf.gz brl-8x8.psf'

    Bizim burada CHARMAP satırını aşağıdaki gibi UTF-8 olarak güncellememiz gerekir:

    CHARMAP="UTF-8"

    Şimdi artık sistemi reboot ettiğimizde login ekranındaki klavye düzeni İngilizce olsa da login olup "setupcon" programını 
    çalıştırdığımızda her şey Türkçe'ye göre ayarlanmış olacaktır.

    Biz klavyeyi ve console fontlarını ayarlarken bazı dosyaları güncelledik. Aslında bu dosyaları manuel olarak edit etmek yerine 
    bunları güncelleyen küçük programlardan da faydalanılabilir. Örneğin aslında "sudo dpkg-reconfigure locales" komutu 
    "/etc/default/locale" dosyası üzerinde güncelleme yapmaktadır. Benzer biçimde "sudo dpkg-reconfigure console-data" komutu 
    da aslında "/etc/default/console-setup" dosyasını güncellemektedir. Bazen klavye ayarlarını çalışırken o anda başka bir dille 
    de değiştirmek isteyebiliriz. Bunun için "loadkeys" isimli program kullanılmaktadır. Bu program klavye düzenek dosyasını 
    argüman olarak alıp klavyeyi ona göre ayarlamaktadır.

    Yukarıda da belirttiğimiz gibi biz Türkçe ayarlarını yapmış olsak da bu ayarları etkili hale getirmek için "setupcon" 
    programını çalıştırmamız gerekir. Bu nedenle BBB'mizi reboot ettiğimizde login ekranında yine klavye İngilizce'de kalacaktır. 
    Bunu kalıcı ayarlamanın bir yolu "sudo update-initramfs -u" işlemidir. Diğer yolu ise sistem boot edildiğinde otomatik olarak 
    bu "setupcon" programının çalıştırılmasını sağlamaktır. Bu konular ileride ele alınacaktır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki ayarlama işlemlerinden de görüldüğü gibi aslında birtakım ayarlar "/etc" dizinin altındaki çeşitli dosyalarda 
    saklanmaktadır. Çeşitli programlar da ayarları bu dosyalara bakarak set etmektedir. Microsoft eskiden Linux'takilere benzer
    ismine "ini dosyaları" denilen ayar dosyalarını kullanıyordu. Daha sonra "registry" denilen tüm ayarların saklandığı mini 
    bir hiyerarşik veritabanı sistemine geçti. Ancak UNIX/Linux sistemlerinde böyle bir merkezi ayar sistemi kullanılmamaktadır. 
    Her ayar "/etc" dizininin altında belli formattaki dosyaların içerisinde saklanmaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Sizin de gördüğünüz gibi Raspberry Pi donanımı BBB'ye göre oldukça güçlüdür. Raspberry Pi'ın SD kartına yüklediğimiz 
    işletim sistemleri oldukça dolu bir biçimdedir. Çünkü bu sistemler tam bir bilgisayar gibi kullanılsın istenmiştir. Halbuki
    BBB'nin kaynakları zayıf olduğu için hazır imajlar genellikle dolu bir biçimde değildir. Örneğin UNIX/Linux sistemlerinde 
    yardım almak için kullanılan "man" programı BBB'nin default imajında bulunmamaktadır. "man" programını ve onun kullandığı 
    önemli veri dosyalarını aşağıdaki gibi yükleyebiliriz:

    $ sudo apt install man-db manpages-posix
    $ sudo apt install manpages-dev manpages-posix-dev

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    BBB'yi on-board flash (eMMC) üzerine yüklü olan Linux sistemiyle açmak zorunda değiliz. SD kartımıza Linux kurup SD kart ile 
    de boot edebiliriz. SD karttan boot işlemi için yine "boot switch"e basılı olarak board'a güç verilir. Led'ler yandığında 
    basılı olan boot switch'ten el bırakılır. Böylece boot işlemi SD karttan harekeetle başlatılacaktır. BBB kartlarının ileri 
    sürümlerinde SD karttan boot işlemi için boot switch'e basmaya gerek kalmamıştır. Bu ileri modellerde SD kart takılıysa 
    zaten boot işlemi SD karttan başlatılmaktadır. SD karta yazacağınız Linux sistemine dikkat ediniz. Buraya "flasher" olmayan 
    bir imajı yerleştirmelisiniz. SD kartınıza yükleyeceğiniz hazır Debian imajını aşağıdaki bağlantıdan indirebilirsiniz:

    https://www.beagleboard.org/distros

    Örneğin buradan SD kartınız için aşağıdaki imajı indirebilirsiniz:

    AM335x 11.7 2023-09-02 4GB microSD IoT

    Beagleboard Black kartınızın boot süreci kursumuzun ayrı bir bölümünde ayrıntılı bir biçimde ele alınacaktır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												7. Ders 26/03/2024 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kursumuzun bu bölümünde gömülü Linux sistemlerinde C/C++ ile yazılım geliştirmek için kullanılan toolchain'ler üzerinde
    duracağız. Kursumuzda "toolchain" sözcüğünü bazen bu biçimde İngilizce olarak bazen de "araç zinciri" biçiminde Türkçe 
    olarak kullanacağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Aşağı seviyeli (C/C++, sembolik makine dilleri) biçimde yazılım geliştirmek için kullanılan araçlardan oluşan topluluğa 
    "araç zinciri (toolchain)" denilmektedir. Bir araç zincirinin tipik bileşenleri şunlardır:

    - C ve C++ Derleyicileri (C and C++ Compilers)
    - Sembolik Makine Dili Derleyicileri (Assemblers)
    - Bağlayıcılar (Linkers)
    - Binary Araçlar (Binary Utilities). Bu araçlar aşağı seviyeli işlemler için gerekebilen programlardan oluşmaktadır.
    - Debugger'lar. Bunlar hataların tespit edilmesi ve çözümlenmesi amacıyla kullanılmaktadır.
    - C ve C++'tan kullanılabilecek temel kütüphaneler. (Örneğin standart C kütüphanesi, POSIX kütüphanesi gibi.)
    - Emülatörler ve Simülatörler (Emulators amd Simulators). Her türlü araç zincirinde bu bileşenler bulunmayabilir.
    - Build Otomasyon Araçları (Build Automation Tools). Örneğin make ve cmake gibi araçlar.
    - Geliştirme İçin Gerekli Olan Diğer Dosyaların Bulunduğu "sysroot" Dizini. Programların derlenip bağlanabilmesi için
    bazı öğelerin bazı dizinler içerisinde bulunması gerekmektedir.

    Her araç zincirinin bu öğelerin hepsini içermesi gerekmez. Bazı araç zincirleri de daha fazla öğe de içerebilir. Burada bir 
    noktaya dikkatinizi çekmek istiyoruz. Gömülü Linux sistemlerinde "araç zinciri (toolchain)" demekle "aşağı seviyeli araçlar"
    kastedilmektedir. Yani örneğin araç zincirleri içerisine Java, .NET, Python gibi platformlarda yazılım geliştirmek için 
    gerekli olan araçlar dahil değildir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kursumuzda kimi zaman çapraz derleme (cross compile) işlemleri yapacağız. Bu durumda host makine ile hedef makine arasında 
    dosya transfleri yapmamız gerekecek. İki makine arasında dosya transferi yapmak için genellikle IP protokol ailesinin sunduğu 
    olanaklar kullanılmaktadır. Bunun için en çok kullanılan utility program "scp" isimli programdır. Bu program "Secure Copy 
    Protocol" denilen bir protokol yoluyla arka planda SSH kullanarak dosya transferini yapmaktadır. scp programının tipik 
    kullanımı şöyledir:

    $ scp dosya_yol_ifadesi kullanıcı_ismi@uzak_makine

    Burada uzak_makine ip adresi ya da host ismi biçiminde belirtilebilir. Örneğin:

    $ scp app debian@192.168.7.2:

    Burada app dosyası uzak makinenin debian kullanıcısının home dizinine kopyalanmaktadır. (host isminden sonra ':' 
    karakterinin bulundurulması zorunludur.) Örneğin:

    $ scp app debian@192.168.7.2:/Test

    Burada app dosyası uzak makinedeki debian kullanıcısının home dizini içerisindeki "Test" dizinine kopyalanacaktır. Tabii scp 
    ile hedef makineden host makineye ters yönde de kopyalama yapabiliriz. Örneğin:

    $ scp debian@192.168.7.2:app app

    Burada hedef makinedeki app dosyası app ismiyle host makineye kopyalanmaktadır. scp ile bir dizin bütünsel olarak da transfer 
    edilebilir. Bunun için "-r" seçeneğinin kullanılması gerekmektedir. Örneğin:

    $ scp -r Src debian@192.168.7.2:

    Burada yerel makinedeki Src dizininin tamamı uzak makineye kopyalanmaktadır.

    scp programının ayrıntıları için ilgili man sayfalarına başvurabilirsiniz.

    Uzak makineye dosya transfer etmek için diğer pratik bir yöntem de "sshfs" denilen dosya sistemini kullanmaktır. Bu dosya 
    sistemi uzak makinedeki bir dizini yerel makinede bir dizin gibi göstermektedir. Böylece biz o dizine dosya kopyaladığımızda 
    sshfs dosya sistemi onu otomatik olarak hedef makineye transfer etmektedir. Tabii sshfs Linux sistemlerini kurduğumuzda sistemin 
    bir parçası biçiminde yüklü durumda değildir. Onun aşağıdaki gibi indirip kurabiliriz:

    $ sudo apt-get install sshfs

    Kurulumu yaptıktan sonra yerel makinede mount edilecek dizini yaratmamız gerekir. Örneğin:

    $ mkdir BBB

    Artık mount işlemini şöyle yapabiliriz:

    $ sshfs BBB debian@192.168.7.2:

    Artık BBB dizinimiz uzak makinedeki kullanıcının home dizini gibi olmuştur. Yani biz bu BBB dizinine dosya kopyaladığımızda 
    aslında onu uzak makineye kopyalamış oluruz. Benzer biçimde uzak makinede home dizinine bir dosya kopyalandığında biz bu 
    dosyayı BBB dizininde otomatik olarak görürüz.

    Mount ettiğimiz dizinin uzak bağlantı yaptığımız makineden kopartılması için "umount" işleminin uygulanması gerekir.
    umount komutunda dizin ismi argüman olarak verilmektedir. Örneğin:

    $ umount BBB

    Yerel makine ile uzak makine arasında dosya transfer etmenin diğer bir yolu da FTP (File Tranfer Protocol) protokülünü 
    kullanmaktır. Ancak bunun için uzak makinede bir FTP sunucusunun yüklü olması gerekir. Düşük kapasiteli gömülü aygıtlarda 
    geliştirici bu server'ı uzak makineye yüklemek istemeyebiir. FTP server ve client programların Linux sistemlerine nasıl 
    kurulacağını ilgili dokümanlardan öğrenebilirsiniz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Araç zincirlerini iki bölüme ayırabiliriz:

    1) Doğal Araç Zincirleri (Native Toolchains)
    2) Çapraz Araç Zincirleri (Cross Toolchains)

    Doğal araç zincirleri genellikle dağıtımların içerisinde zaten hazır bir biçimde bulunmaktadır. Örneğin Raspberry Pi için 
    Raspberry Pi OS'yi yüklediğimizde, Beaglebone Black için Debian dağıtımını yüklediğimizde zaten onun içerisinde doğal araç 
    zincirleri bulunmaktadır. Doğal araç zincirleri doğrudan ilgili sistem üzerinde yazılım geliştirilirken kullanılmaktadır. 
    Örneğin biz Raspberry Pi için yazılımımızı doğrudan Raspberry Pi üzerinde geliştirebiliriz. Bu durumda orada yüklü olan doğal 
    araç zincirini kullanabiliriz. Raspberry Pi donanımları (özellikle 4 ve 5) çok güçlü olduğu için doğal araç zincirleri ile 
    geliştirme yapmak artık iyi bir seçenek durumundadır. Ancak Beaglebone Black gibi aygıtların sistem kaynakları daha kısıtlı 
    olduğu için doğrudan bunların üzerinde geliştirme yapmak zor hatta bazen olanaksız hale gelebilmektedir.

    Çapraz araç zincirleri (cross toolchains) geliştirmenin güçlü bir makine üzerinde yapılmasını sağlayan, hedef aygıt için kod 
    üreten araç zincirleridir. Buradaki çapraz (cross) sözcüğü üretilen kodun geliştirmenin yapıldığı makineye değil, başka bir 
    hedef (target) makineye ilişkin olduğunu belirtmektedir. Eğer hedef makine etkin bir geliştirme yapmaya olanak sağlamıyorsa 
    bu durumda çapraz araç zincirleri kullanılabilir. Örneğin Beaglebone Black için tipik olarak çapraz araç zincirleri kullanılmaktadır.

    Pekiyi doğal araç zincirleri mi yoksa çapraz araç zincirleri mi tercih edilmelidir? İşte eğer Raspberry Pi'da olduğu gibi 
    hedef donanım güçlüyse doğal araç zincirlerinin kullanılmasını tavsiye ederiz. Çünkü doğal ortamda geliştirme yapılırken denemeler
    o anda geliştirme yapılan makinede çok daha hızlı yapılabilmektedir. Ancak hedef makine yeteri kadar güçlü değilse güçlü bir
    host makinede çapraz araç zincirleriyle geliştirmenin yapılmasını öneririz. Araç zinciri denildiğinde zaten default olarak
    çapraz araç zincirleri kastedilmektedir.

    Araç zincirlerini başka bakımlardan da sınıflandırabiliriz. Örneğin araç zincirini "tedarik eden (vendor)" kuruma göre, 
    kullanılan derleyici sistemlerine göre de sınıflandırılabiliriz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Araç zincirlerinin isimlendirilmesi genellikle "hedef (target) sisteme" göre yapılmaktadır. İsimlendirmede '-' karakterleriyle
    ayrılmış üç alan ya da dört alan kullanılabilmektedir. Üçlü (triple) isimlendirmede ismin alanları şunlardır:

    CPU-Tedarikçi-İşletimSistemi

    Dörtlü isimlendirmede ayrıca bir de ABI alanı bulundurulmaktadır. Dörtlü isimlendirmenin de genel biçimi şöyledir:

    CPU-Tedarikçi-İşletimSistemi-ABI

    Buradaki bileşenlerin hepsi hedef makineye ilişkin bileşenlerdir. Ancak araç zincirlerindeki isimlendirme biçimi herkes 
    tarafından uyulan, resmi bir standardı olan kural niteliğindeki biçimler değildir. Gevşek kurallardır. Üçlü ya da dörtlü 
    isimlendirmeye uymayan ya da kısmen uyan araç zincirleri de bulunmaktadır.

    Şimdi bazı örnekler vermek istiyoruz.

    i686-apple-darwin10-gcc-4.2.1

    Bu araç zinciri Intel'in 32 bit işlemcilerine ilişkin (x86) kod üretilmektedir. Tedarikçi (vendor) Apple şirketidir. Yani araç 
    zinciri Apple firması tarafından hazırlanmıştır. Hedef işletim sistemi darwin10'dur. Yani oluşturulacak kod bu işletim sistemi 
    tarafından çalıştırılacaktır. (macOS işletim sisteminin kernel'ına "Darwin" denilmektedir. Dolayısıyla buradaki Darwin aslında 
    macOS anlamındadır.) Kullanılan ABI versiyonu gcc-4.2.1 tarafından kullanılan default ABI'yi belirtmektedir.

    arm-none-linux-gnueabi

    Burada ARM kodu üretilmektedir. Tedarikçinin olmaması bunun manuel üretildiği anlamına gelebilmektedir. Burada yine kodun 
    Linux işletim sistemi için üretileceği belirtilmektedir. ABI için kullanılan "gnueabi" tipik olarak GNU araç zincirini ve 
    gömülü sistemler için kullanılan ABI'yi belirtmektedir. (Buradaki eabi "extended abi" anlamına gelmektedir.).

    arm-linux-gcc

    Burada ARM üzerinde çalışan Linux sistemleri için kod üretilecektir. gcc derleyicisinin o sistemdeki default ABI'si 
    kullanılacaktır.

    i686-unknown-linux-gnu

    Burada tipik olarak 32 bit Intel işlemcileri üzerinde çalışan Linux sistemleri için kod üretilecektir. ABI bu sistemlerde 
    kullanılan default ABI'dir. Buradaki "gnu" GNU araç zincirini belirtmektedir.

    x86_64-w64-mingw32

    Buradaki araç zinciri 64 bit Intel işlemcilerini kullanan 64 bit Windows sistemleri için kod üretmektedir. Araç zinciri 
    MinGW dağıtımını referans almaktadır. Dolayısıyla oradaki ABI'yi kullanmaktadır.

    arm-none-eabi

    Burada ARM kodu üretilmektedir. Ancak herhangi bir işletim sistemi hedef alınmamıştır. İşletim sisteminin belirtilmediği 
    durum genellikle "bare metal" araç zinciri anlamına gelmektedir.

    Örneğin Windows'ta sanal makineye kurduğumuz Intel işlemcisini kullanan Mint dağıtımındaki gcc derleyicisinin izini sürelim:

    $ whereis gcc
    gcc: /usr/bin/gcc /usr/lib/gcc /usr/share/gcc /usr/share/man/man1/gcc.1.gz
    $ ls -l /usr/bin/gcc
    lrwxrwxrwx 1 root root 6 Mar 19 21:29 /usr/bin/gcc -> gcc-11
    $ ls -l /usr/bin/gcc-11
    lrwxrwxrwx 1 root root 23 Mar 19 21:29 /usr/bin/gcc-11 -> x86_64-linux-gnu-gcc-11

    Buradaki araç zinciri isimlendirmesinden şu anlaşılmaktadır: Buradaki gcc derleyici 64 bit Intel işlemcilerine ilişkin kod 
    üretmektedir. Söz konusu kod Linux sisteminde çalıştırılmak için üretilmektedir. GNU'nun araçları ve ABI'si kullanılmıştır. 
    Şimdi de BBB'deki Debian dağıtımı için aynı izi sürelim:

    $ whereis gcc
    gcc: /usr/bin/gcc /usr/lib/gcc /usr/share/gcc
    $ ls -l /usr/bin/gcc
    lrwxrwxrwx 1 root root 6 Oca 11 2021 /usr/bin/gcc -> gcc-10
    $ ls -l /usr/bin/gcc-10
    lrwxrwxrwx 1 root root 26 Oca 10 2021 /usr/bin/gcc-10 -> arm-linux-gnueabihf-gcc-10

    Buradaki araç zincirinden de şunu anlıyoruz: Bu araç zinciri 32 bit ARM kodu üretmektedir. Yine üretilen kodun Liux sistemlerinde 
    çalıştırılması gerektiği belirtilmektedir. GNU'nu araçları ve GNU'nun "eabihf" ABI'si kullanılmıştır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Pekiyi araç zincirleri sistemimizde hazır bir biçimde bulunmuyorsa bunları nasıl elde edebiliriz? İşte bunun tipik olarak 
    üç yolu vardır:

    1) Çeşitli kurumlar ve topluluklar tarafından oluşturulmuş ve hazır hale getirilmiş araç zincirlerini kullanmak: Bunlara 
    "pre-built toolchain" de denilmektedir.

    2) Araç zinciri oluşturan yazılımları ve projeleri kullanmak: Örneğin "crosstool-NG" gibi "buildroot" gibi "yocto" gibi 
    projelerle araç zincirleri daha etkin ve optimize edilmiş bir biçimde oluşturulabilmektedir.

    3) Araç zincirlerini manuel biçimde oluşturmak: Manuel oluşturma çok zorlu bir süreçtir. Çünkü bu yöntemde araç zincirindeki 
    öğelerin kaynak kodlardan hareketle derlenmesi gerekmektedir. Bu işlemleri manuel yapmak için iyi bir deneyime sahip olmak 
    gerekir.

    Biz kursumuzda önce ARM platformu için hazır araç zincirlerini tanıtacağız. Sonra "crosstool-NG" yazılımı ile araç 
    zinciri oluşturmayı göreceğiz. Buildroot ve Yocto projeleri araç zinciri oluşturmaktan daha fazla işlevselliğe sahiptir.
    Biz kursumuzda bunları ileride ayrı bir bölümde ele alacağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ARM platformu için önceden hazırlanmış ve kullanıma hazır hale getirilmiş hazır doğal ve çapraz araç zincirleri bulunmaktadır. 
    Bu amaçla kullanılan tipik araç zincirleri şunlardır:

    1) ARM Firması Tarafından Oluşturulmuş Olan Araç Zincirleri: ARM firmasının kendisi ARM hedefi için doğrudan kullanılabilecek 
    doğal ve çapraz araç zincirlerini hazırlamıştır. Bu araç zincirleri GNU projesini kullanmaktadır. Bu nedenle bu tür araç 
    zincirlerine "GNU araç zincirleri (GNU toolchains)" de denilmektedir. ARM'ın GNU araç zincirlerine aşağıdaki bağlantıdan 
    erişilebilir:

    https://developer.arm.com/downloads/-/gnu-a

    Örneğin elinizdeki host makinede 64 bit Intel işlemcilerinde çalışan Linux sistemi varsa Beaglebone Black için aşağıdaki çapraz 
    araç zincirini indirip kurabilirsiniz:

    gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf.tar.xz

    Raspberry Pi'nızda 64 bit Raspberry Pi OS varsa 64 bit Intel işlemcilerinde çalışan Linux sistemi için aşağıdaki çapraz araç 
    zincirini kullanabilirsiniz:

    gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz

    Burada yapılacak şey bu dosyaları indirip aşağıdaki örnekte olduğu gibi açmaktır:

    $ tar -xf gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf.tar.xz

    Tabii açımı dosya yöneticileri ile de yapabilirsiniz.

    ARM firmasının yukarıda belirttiğimiz sitedeki hazır araç zincirleri ARM tarafından "discontinued" yapılmıştır. Yani ARM 
    yeni araç zinciri sistemine geçmiştir. ARM'ın en yeni araç zincirleri aşağıdaki bağlantıdan indirilebilir:

    https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads

    Ancak buradaki araç zincirleri maalesef bizim kullandığımız BeagleBone Black ile uyumsuzdur. (Buradaki araç zincirlerinde
    glibc kütüphanesinin daha ileri bir versiyonu kullanılmıştır. Dolayısıyla bu kütüphane dinamik kütüphane olarak kullanılacaksa 
    sorun oluşacaktır. Ancak statik kütüphane biçiminde kullanılacaksa sorun oluşmayacaktır.) Biz burada test amacıyla BeagleBone 
    Black aygıtımızla uyumlu olan ilk verdiğimiz bağlantıdaki araç zincirlerini kullanacağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												8. Ders 28/03/2024 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki araç zincirini yerel host makineye indirdiğimizde aşağıdaki bir dizin yapısıyla karşılaşırız:

    bin
    lib
    libexec
    arm-none-linux-gnueabihf
    include
    lib64
    share

    Genel olarak araç zincirlerinin çoğundaki dizin yapısı bu biçimdedir. Burada bizim için en önemli dizin "bin" dizinidir. 
    Çünkü bütün çapraz araçlar bu dizin içerisinde bulunmaktadır. Bu dizini görüntülediğimizde içeriği şöyle listelenmektedir:

    arm-none-linux-gnueabihf-addr2line
    2021 arm-none-linux-gnueabihf-ar
    2021 arm-none-linux-gnueabihf-as
    2021 arm-none-linux-gnueabihf-c++
    2021 arm-none-linux-gnueabihf-c++filt
    2021 arm-none-linux-gnueabihf-cpp
    2021 arm-none-linux-gnueabihf-dwp
    2021 arm-none-linux-gnueabihf-elfedit
    2021 arm-none-linux-gnueabihf-g++
    2021 arm-none-linux-gnueabihf-gcc
    2021 arm-none-linux-gnueabihf-gcc-10.3.1
    2021 arm-none-linux-gnueabihf-gcc-ar
    2021 arm-none-linux-gnueabihf-gcc-nm
    2021 arm-none-linux-gnueabihf-gcc-ranlib
    2021 arm-none-linux-gnueabihf-gcov
    2021 arm-none-linux-gnueabihf-gcov-dump
    2021 arm-none-linux-gnueabihf-gcov-tool
    2021 arm-none-linux-gnueabihf-gdb
    2021 arm-none-linux-gnueabihf-gdb-add-index
    2021 arm-none-linux-gnueabihf-gfortran
    2021 arm-none-linux-gnueabihf-gprof
    2021 arm-none-linux-gnueabihf-ld
    2021 arm-none-linux-gnueabihf-ld.bfd
    2021 arm-none-linux-gnueabihf-ld.gold
    2021 arm-none-linux-gnueabihf-lto-dump
    2021 arm-none-linux-gnueabihf-nm
    2021 arm-none-linux-gnueabihf-objcopy
    2021 arm-none-linux-gnueabihf-objdump
    2021 arm-none-linux-gnueabihf-ranlib
    2021 arm-none-linux-gnueabihf-readelf
    2021 arm-none-linux-gnueabihf-size
    2021 arm-none-linux-gnueabihf-strings
    2021 arm-none-linux-gnueabihf-strip

    Burada gcc derleyicimiz "arm-none-linux-gnueabihf-gcc" ismiyle bulunmaktadır. Ancak derleyicimizi kullanmak için oldukça 
    fazla tuşa basmamız gerekir. Bunu engellemek için PATH çevre değişkenine bu "bin" dizini eklenebilir. Ya da aşağıdaki gibi 
    bir sembolik bağlantı dosyası oluşturulabilir:

    $ ln -s gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin/arm-none-linux-gnueabihf-gcc gcc-arm

    Burada artık biz ./gcc-arm biçiminde programı çalıştırdığımızda çapraz derleyicimizi çalıştırmış oluruz. Aynı işlemi C++
    derleyicisi için de yapabilirsiniz. C++ derleyicisi de "arm-none-linux-gnueabihf-g++" ismiyle bulunmaktadır. O halde 
    örneğin "sample.c" programını sembolik link oluşturduktan sonra aşağıdaki gibi derleyebiliriz:

    $ ./gcc-arm -o sample sample.c

    2) Linaro Kurumu Tarafından Oluşturulmuş Araç Zincirleri: Yaygın kullanılan hazır araç zincirlerinden biri de "Linaro" 
    tarafından oluşturulmuş araç zincirleridir. Linaro kar amacı gütmeyen bir organizasyondur. Linaro araç zincirlerini 
    aşağıdaki bağlantıdan indirebilirsiniz:

    https://releases.linaro.org/components/toolchain/binaries

    Ya da aşağıdaki bağlantıyı kullanabilirsiniz:

    https://snapshots.linaro.org/

    BBB için Linaro araç zincirinin "bin" dizini içerisindeki çapraz araçların listesi şöyledir:

    arm-linux-gnueabihf-addr2line
    arm-linux-gnueabihf-ar
    arm-linux-gnueabihf-as
    arm-linux-gnueabihf-c++
    arm-linux-gnueabihf-c++filt
    arm-linux-gnueabihf-cpp
    arm-linux-gnueabihf-dwp
    arm-linux-gnueabihf-elfedit
    arm-linux-gnueabihf-g++
    arm-linux-gnueabihf-gcc
    arm-linux-gnueabihf-gcc-14.0.0
    arm-linux-gnueabihf-gcc-ar
    arm-linux-gnueabihf-gcc-nm
    arm-linux-gnueabihf-gcc-ranlib
    arm-linux-gnueabihf-gcov
    arm-linux-gnueabihf-gcov-dump
    arm-linux-gnueabihf-gcov-tool
    arm-linux-gnueabihf-gdb
    arm-linux-gnueabihf-gdb-add-index
    arm-linux-gnueabihf-gfortran
    arm-linux-gnueabihf-gprof
    arm-linux-gnueabihf-ld
    arm-linux-gnueabihf-ld.bfd
    arm-linux-gnueabihf-ld.gold
    arm-linux-gnueabihf-lto-dump
    arm-linux-gnueabihf-nm
    arm-linux-gnueabihf-objcopy
    arm-linux-gnueabihf-objdump
    arm-linux-gnueabihf-ranlib
    arm-linux-gnueabihf-readelf
    arm-linux-gnueabihf-size
    arm-linux-gnueabihf-strings
    arm-linux-gnueabihf-strip

    Bu araç zincirindeki gcc derleyicisi için de aşağıdaki gibi sembolik bağlantı dosyası oluşturabiliriz:

    $ ln -s gcc-linaro-14.0.0-2023.06-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc gcc-linaro

    Derlemeyi de şöyle yapabiliriz:

    $ ./gcc-linaro -o sample sample.c

    3) Bootlin Kurumu Tarafından Oluşturulmuş Araç Zincirini İndirip Kurmak: Bootlin gömülü Linux sistemleri alanında faaliyet 
    gösteren bir kurumdur. Bootlin tarafından oluşturulmuş olan çapraz araç zincirleri sık kullanılmaktadır. İlgili araç zinciri
    aşağıdaki sayfadan indirilebilir:

    https://toolchains.bootlin.com/

    Bootlin araç zincirlerinin hepsi Intel işlemcilerinin kullanıldığı Linux sistemleri için hazırlanmıştır.

    4) Windows İçin "gnutoolchains.com" Sitesindeki Araç Zincirini İndirip Kurmak: Bu site yalnızca Windows için çok çeşitli 
    GNU araç zincirlerini barındırmaktadır. Dolayısıyla eğer host sistem olarak Windows'u kullanıyorsak bu site işimizi 
    kolaylaştırabilir. Siteye aşağıdaki bağlantıdan erişebilirsiniz:

    https://gnutoolchains.com/

    Örneğin BBB için bu siteden "Beaglebone" seçilerek "beaglebone-gcc8.3.0.exe" dosyası indirilip kurulabilir. Bu site Windows'ta 
    doğrudan install edilebilen çalıştırılabilir programlar barındırmaktadır. Kurulum yapılırken bize araçların bulunduğu "bin"
    dizininin PATH çevre değişkenine eklenip eklenmeyeceği de sorulmaktadır. Eğer bu eklemeyi yaparsanız komut satırından 
    daha rahat çalışabilirsiniz.

    5) Bazı dağıtımların sunduğu araç zincirleri de bulunmaktadır. Örneğin Debian dağıtımı için ARM çapraz araç zinciri şöyle 
    kurulabilir:

    $ sudo apt-get install crossbuild-essential-armhf

    Bu araç zincirinin de glibc kütüphanesi bakımından BBB ile uyumsuz olduğuna dikkatinizi çekmek istiyoruz. Eğer ARM işlemcisinin
    bulunduğu Debian türevi bir Linux sisteminde çalışıyorsanız Intel kodu üretmek için de aşağıdaki gibi araç zincirini 
    kurabilirsiniz:

    $ sudo apt-get install crossbuild-essential-amd64

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												9. Ders 02/04/2024 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Gömülü Linux sistemleri için host makine olarak Windows kullanılmasının çok uygun olmadığını belirtmiştik. Windows'ta geleneksel
    çalışma modeli GUI çalışma modelidir. Windows'ta komut satırından komutlar yoluyla çalışma yaygın bir kullanım biçimi değildir. 
    Halbuki daha önceden de söylediğimiz gibi UNIX/Linux sistemlerinin geleneksel çalışma biçimi "console" çalışmasıdır. Pekiyi 
    macOS sistemlerini host makine olarak kullanmak uygun olur mu?

    Aslında Apple firması GUI çalışma modelini ilk kullanan firmalardandır. Microsoft'un DOS işletim sistemi zamanlarında 
    Apple firmasının Machintosh sistemleri grafik arayüz kullanıyordu. Sonra 90'lı yılların sonlarına doğru Mac OS X (10) 
    ile birlikte Apple işletim sistemlerinin çekirdeğini değiştirerek UNIX türevi bir çekirdek kullanmaya başladı. Bugünkü 
    macOS sistemleri UNIX türevi bir sistem gibi değerlendirilebilir. Ancak durum böyle olsa da macOS sistemlerinde ağırlıklı 
    çalışma yine grafik arayüz yoluyla yapılmaktadır. Maalesef macOS sistemleri için hazır Linux araç zincirleri bulunmamaktadır. 
    Örneğin ARM, Linaro ve Bootlin kurumlarının macOS host olarak hazır araç zincirleri bulunmamaktadır. Bunların araç zinciri 
    üreten programlar tarafından derlenerek oluşturulması gerekmektedir. Dolayısıyla macOS sistemlerini host sistem olarak 
    kullanmak Windows sistemlerini host sistem olarak kullanmaktan biraz daha zordur. Biz macOS sistemlerini kullanan 
    katılımcılarımıza sanal makinelerine Linux kurmalarını öneriyoruz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Eclipse ilk kez bir Java IDE'si olarak tasarlanmıştır. Daha sonra plugin'ler yoluyla genel bir IDE haline getirilmiştir. 
    Eclips IDE'sinin C/C++ plugin'ine CDT denilmektedir. Elimizde Java için zaten kurmuş olduğumuz bir Eclipse varsa biz bu CDT
    plugin'ini IDE'ye ekleyerek C/C++ çalışması da yapabiliriz. Ancak kolaylık olsun diye Eclipse'in çeşitli diller için plugin'leri
    yüklenmiş halleri kendi sitesinde bulundurulmaktadır. Biz burada Eclipse IDE'si ile çapraz araç zincirlerinin nasıl kullanılacağını 
    göreceğiz.

    Eclipse IDE'si ile çapraz araç zincirini kullanmak için sırasıyla şunlar yapılmalıdır:

    1) Eclipse IDE for C++ Developers (Eclipse - CDT) indirilerek kurulur. İndirmeyi aşağıdaki bağlantıdan yapabilirsiniz:

    https://www.eclipse.org/downloads/packages/

    2) "File/New/C/C++" seçeneğinden "C++ Project" ya da "C Project" seçilir. ("C/C++ Project" seçeneğini seçmeyiniz.)

    3) Karşımıza çıkan diyalog penceresinde projeye bir isim verilir. Sağ taraftaki "Toolchains" panelinden de "Cross GCC" 
    seçilir.

    4) Daha sonra "Project/Properties" menüsünden "Tool Setting" seçilir. Çıkan diyalog penceresinden "Cross Settings" seçilir. 
    Yan taraftaki "Prefix" edit alanına alet zincirinin ön ekleri girilir. Öneklerin sonunda "-" karakterinin de bulundurulması 
    gerekmektedir. Örneğin "arm-linux-gnueabihf-" gibi. "Path edit" alanına ise çapraz alet zincirindeki programların bulunduğu
    "bin" dizininin yol ifadesi girilmelidir. (Örneğin "C:\SysGCC\beaglebone\bin" gibi.)

    5) Daha sonra Proje üzerine gelinerek bağlam menüsünden "Build Project" seçilip build işlemi yapılır.

    Eclipse üzerinden uzak bağlantı kurmak için de şunları yapılabilir:

    1) "Help/Install New Software" seçilir. Buradan aşağıdaki iki plugin kurulur:

    - Remote System Explorer User Actions
    - Remote System Explorer End-User Runtime
    - Remote Command Shell Console

    2) "Window/Show View/Remote Systems" seçilir. "Linux" seçilerek yeni bir bağlantı olşturulur. Bağlantıya bir isim verilerek "Next" 
    düğmesine basılır. "Configuration" penceresinden "SSH files" seçilir. "Next" düğmesine basılır. Bu kez "Configuration" sekmesinden 
    "processes.shell.linux" seçilir ve "Next" seçilir. Oradan da "ssh.shells" seçilir ve "Finish" düğmesine basılır.

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												10. Ders 04/04/2024 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Microsoft'un ünlü IDE'sine "Visual Studio" denilmektedir. Visual Studi IDE'si Windows için tasarlanmış ve gerçekleştirilmiştir. 
    Linux sistemlerinde bulunmamaktadır. Microsoft bu IDE'nin macOS versiyonunu çıkartmışsa da artık o projeyi devam ettirmemektedir. 
    Diğer sistemler için IDE ile editör arasında olan "Visual Studio Code" denilen aracı önermektedir. Visual Studio IDE'si 
    paralı bir üründür. Ancak Microsoft bu IDE'nin temel bir versiyonunu "Visual Studio Community" ismi altında bedava bir biçimde
    de vermektedir. IDE aşağıda bağlantıdan indirilebilir:

    https://visualstudio.microsoft.com/tr/downloads/

    Visual Studio uzun süredir ARM tabanlı mobil aygıtlar için kod üreten çapraz derleyicileri bünyesinde barındırmaktadır.

    Windows'ta Visual Studio IDE'sinde ARM tabanlı Linux sistemleri için proje (ve çözüm) şöyle yaratılmaktadır:

    1) Yeni bir proje oluşturulurken Platform olarak "Linux" ve "Empty Console Application" ya da "Empty Project" seçilir.

    2) Üretilecek kod türü ARM seçilir. Bu seçim IDE'nin ana ekranında yukarıdaki combobox'tan yapılabilmektedir.

    3) Daha sonra uzak makineye bağlantı yapılır. Bağlantı sırasında bizden uzak makinenin IP adresi (ya da ismi), oradaki 
    kullanıcının ismi ve parolası istenecektir. Bağlantı "Tools/Options/Multi Platform/Connection Manager" menüsünden yapılabilmektedir.

    4) Projeye kaynak kod eklenip "build" işlemi yapıldığında hedef makine için kod üretilir. Derleme menüsünden "Çözümü Dağıt"
    seçeneği seçildiğinde otomatik olarak tüm proje uzak makineye aktarılmaktadır. Debug işlemleri için de aslında programcının 
    özel bir hazırlık yapmasına gerek kalmamaktadır. Debug işlemi yerel makinede olduğu gibi yapılmaktadır.

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Microsoft değişik sistemlerde platform bağımsız geliştirme yapabilmek için "Visual Studio Code" isimli IDE ile Editör arası
    bir araç da gelişmiştir. Son yıllarda bu araç çok kullanılır olmuştur. Visual Studio Code yüksek seviyeli bir çalışma biçimine 
    sahip değildir. Çalışma düşük seviyede çeşitli ayar dosyaların edit edilmesiyle yapılmaktadır. Ancak editör tasarım olarak 
    genişletilebilir bir biçimde oluşturulmuştur. Yüksek seviyeli çalışma çeşitli plugin'lerle sağlanabilmektedir. Microsoft 
    bu plugin'lere "uzantı (extension)" demektedir. C/C++ programcısı olarak en azından Microsoft'un "C/C++ Extension Pack" 
    isimli eklentisini yüklemenizi öneririz. Ayrıca tek tuşa basarak programı derleyip çalıştırmak için "Code Runner" isimli 
    eklentiden de faydalanabilirsiniz. Örneğin bu eklenti sayesinde "Ctrl+Alt+N" tuşlarına basılarak editördeki program doğrudan 
    derlenip çalıştırılabilmektedir.

    Biz kursumuzdaki kodlama örneklerinde ağırlıklı olarak Visual Studio Code editörünü kullanacağız. Ancak bu aracı bir IDE 
    gibi değil, bir text editör gibi kullanacağız. İşlemleri genellikle manuel bir biçimde komut satırından yapacağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Visual Studio Code ile çapraz derleme işlemi maalesef kolay değildir. Bunun için henüz hazır eklentiler bulunmamaktadır. 
    Programcı tek tuşa basarak Visual Studio'da olduğu gibi işlemlerini otomatize edebilir. Ancak bunu yapmak için Visual Studio 
    Code'un çalışma biçimi hakkında ayrıntılı bilgi sahibi olması gerekir.

    Visual Studio Code aracında tek tuşa basarak çapraz derleme yapmak için sırasıyla şu adımlar izlenebilir:

    1) Önce bir dizin yaratılır. Dizin projeyi temsil edecektir. Sonra dizin içerisinde ".vscode" isimli bir dizin oluşturulur. 
    Bu dizinin içerisinde de "tasks.json" dosyası yaratılır.

    2) tasks.json dosyası için bir şablon şöyle olabilir:

    {
        "version": "2.0.0",
        "tasks": [
            {
                "label": "Build for ARM",
                "type": "process",
                "command": "/home/Study/gcc-arm-10.3-2021.07-aarch64-arm-none-linux-gnueabihf/bin/arm-none-linux-gnueabihf-gcc",
                "args": [
                    "-g",
                    "${workspaceFolder}/sample.c",
                    "-o",
                    "${workspaceFolder}/sample.o",
                    "--static"
                ],
                "group": {
                    "kind": "build",
                    "isDefault": true
                },
                "problemMatcher": [
                    "$gcc"
                ],
                "detail": "Compiler task."
            }
        ]
    }

    Burada "type" programın nasıl çalıştırılacağını belirtmektedir. Eğer buraya "shell" girilirse çalıştırma kabuğa yaptırılır.
    Eğer burada "process" girilirse doğrudan çalıştırma uygulanmaktadır. "command" çalıştırılacak programı belirtmektedir. 
    Tabii bu program ya doğrudan derleyici olur ya da "make" gibi, bir shell script gibi bir program olabilir. "args" ise "command" 
    ile belirtilen programın komut satırı argümanlarını belirtmektedir.

    Bu dosya oluşturulduktan sonra derlenecek dosya editörde aktif hale getirilir. Shift+Ctrl+P tuşlarına basılarak "Run Build Task" 
    seçilir.

    Tabii aslında yukarıdaki "tasks.json" dosyasında birden fazla "label" olabilir. Burada doğrudan derleyici çalıştırmak yerine 
    "make" gibi "cmake" gibi build otomasyon araçlarını da çalıştırabiliriz. Örneğin "tasks.json" dosyasını şöyle de oluşturabiliriz:

    {
    "version": "2.0.0",
    "tasks": [
        {
            "label": "Build for ARM",
            "type": "shell",
            "command": "make",
            "args": [
                "-f",
                "${workspaceFolder}/Makefile"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "problemMatcher": [
                "$gcc"
            ],
            "detail": "Compiler task."
        }
    ]
    }

    Burada biz "Shift+Ctlr+P" yapıp "Run Build Task" seçeneğini seçtiğimizde "make" programı çalıştırılacak ve make işlemi 
    yapılacaktır. Make dosyalarının nasıl oluşturulacağını ayrı bir bölümde ele alacağız. Ancak en basit bir make dosyası 
    şöyle oluşturulabilir:

    SDK_PATH=/home/kaan/Study/EmbeddedLinux/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin

    project: sample.o
        $(SDK_PATH)/arm-none-linux-gnueabihf-gcc -o project sample.o
    sample.o: sample.c
        $(SDK_PATH)/arm-none-linux-gnueabihf-gcc -c sample.c

    Bu make kodunu yaratmış olduğunuz proje dizinine "Makefile" ismiyle kaydedebilirsiniz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Visual Studio Code editöründe uzak bağlantı ile çalışmak için de sırasıyla şunlar yapılmalıdır:

    1) Aşağıdaki bağlantıdan CLI paketini uzak makineye indirip sıkıştırılmış dosyayı açınız:

    https://code.visualstudio.com/Download

    Bu dosyada "code" isimli bir program bulunmaktadır. Bu programı Linux sistemlerinde "/usr/bin" dizinine kopyalayabilirsiniz. 
    Bu işlem Linux sistemlerinde aşağıdaki gibi yapılabilir:

    $ tar xf <indirilen CLI dosyası>
    $ sudo cp code /user/bin

    2) Hedef makinede code programı aşağıdaki gibi çalıştırılır:

    $ code tunnel

    Bu program server'ın çalıştırılmasını sağlayacaktır. Bu çalıştırmayı ilk kez yaptığınızda github için bir onaylama istenmektedir.
    Bundan sonra size bir URL verilir. Bu URL yerel makinenizin tarayıcısında yazılırsa VSCode editörü grafik arayüzle açılacaktır.
    Tabii siz aslında uzak makinede VSCode editörü ile çalışıyor durumda olacaksanız.

    3) Bu işlemden sonra uzak makinedeki server program bir URL verir. Bu URL yerel makinede girilirse karşımıza tarayıcıda 
    Visual Studio Code editörü çıkacaktır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda çeşitli kurumlar tarafından hazır hale getirilmiş (prebuilt) araç zincirlerini kullandık. Ancak hazır araç 
    zincirlerini kullanmanın kimi zaman bazı dezavantajları söz konusu olabilmektedir. Örneğin:

    - Hazır araç zincirleri gömülü sistemimizdeki Linux ile uyumlu olmayabilir. Çünkü bir programın çapraz derlenerek hedef 
    makinede çalışabilmesi için çapraz derleme ortamıyla derlenmiş kodun çalışacağı ortamın tam bir uyum içerisinde olması 
    gerekmektedir. Örneğin ARM'ın hazır yeni araç zincirleri bizim kullandığımız BBB ile kütüphane bakımından uyumsuzdur.

    - Hazır araç zincirleri pek çok sistemde çalışabilsin diye hazırlanmaktadır. Bu da belli bir sistem için performansı 
    düşürebilmektedir. Oysa araç zincirleri tam olarak hedef sistem için en uygun kodların üretilebileceği biçimde o sisteme
    özgü oluşturulabilmektedir.

    - Hazır araç zincirleri standart C ve POSIX fonksiyonları için belli bir kütüphaneyi kullanmaktadır. Genellikle de bu 
    kütüphane GNU glibc kütüphanesidir. C++ için de benzer biçimde stdc++ kütüphanesi kullanılmaktadır. Araç zincirlerini 
    manuel biçimde oluştururken bu kütüphaneleri de hedef sistem için daha uygun olacak biçimde belirleyebiliriz.

    - Hazır araç zincirleri bazı klasik ABI'leri kullanmaktadır. Bazı aygıtlar için bazı nedenlerden dolayı farklı ABI'lerin 
    kullanılması gerekebilmektedir.

    Biz daha önce araç zincirlerinin manuel bir biçimde oluşturulmasının zorluklarından bahsetmiştik. İşte araç zincirlerinin
    içinde çok çeşitli programlar vardır. Bunların tek tek konfigüre edilip derlenmesi hem zahmetlidir hem de özel bilgiler 
    gerektirmektedir. İşte bu nedenden dolayı araç zincirlerini otomatik olarak üreten yazılımlar oluşturulmuştur. Biz kursumuzda 
    "buildroot" ve "yocto" projelerini ayrı bölümlerde ele alacağız. Bu projelerle araç zincirleri de oluşturulabilmektedir.
    Araç zincirlerinin oluşturulmasında son zamanlarda "crosstool-NG" isimli yazılım yaygın biçimde kullanılmaya başlanmıştır. Biz de 
    bu bölümde bu crosstool-NG yazılımının kullanılması üzerinde duracağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    crosstool-NG araç zinciri oluşturan bir yazılımdır. Zaman içerisinde çeşitli böcekler giderilmiş olsa da hala birtakım böcekler 
    bulunmaktadır. Ancak yazılım iş görür bir durumdadır.

    crosstool-NG aracını kullanmak için önce onun kaynak kodlarını indirip host makinede derlemek gerekir. Maalesef projenin 
    derlenmiş "binary" biçimi kendi sitesinde bulunmamaktadır. crosstool-NG hangi sistemde derlenirse host sistem o olmaktadır. 
    Biz bu araçta hedef (target) sistemin özelliklerini belirleyip host sistemde çalışacak çapraz derleme araçlarını oluştururuz.

    crosstool-NG aracının tipik host sistemi Linux olmalıdır. Windows'ta derleme yapmak oldukça zordur. macOS sistemlerinde 
    bu aracın kullanılması Windows sistemlerinden daha kolaydır. Ancak macOS için bazı programların "brew (home brew)" ile 
    indirilmesi gerekmektedir. Biz kursumuzda host sistem olarak Linux kullanacağız.

    crosstool-NG'nin tipik kullanımı şöyledir:

    1) Öncelikle crosstool-NG'nin derlenmesi ve araç zincirinin oluşturulması sırasında gerekli olan başka paketler kurulmalıdır.
    Gerekli bütün paketler aşağıda listelenmiştir. Bunu copy-paste yaparak bunların kurulumlarını sağlayabilirsiniz:

    $ sudo apt-get install autoconf automake bison bzip2 cmake flex g++ gawk gcc gettext git gperf help2man libncurses5-dev \
    libstdc++6 libtool libtool-bin make patch python3-dev rsync texinfo unzip wget xz-utils

    2) Projenin kaynak kodları kendi sitesinden indirilip proje derlenmelidir. Projenin resmi sitesi şöyledir:

    https://crosstool-ng.github.io/

    İndirme işlemi doğrudan git'ten yapılabilir. Örneğin:

    $ git clone https://github.com/crosstool-ng/crosstool-ng

    Eğer siteden indirme yapılmışsa indirilen dosya sıkıştırılmış bir dosyadır. Bu dosyanın açılması gerekir. Dosya açılınca bir 
    dizin oluşacaktır.

    3) Kabuktan dizine geçilir ve ilk iş olarak "bootstrap" isimli program aşağıdaki gibi çalıştırılır:

    $ ./bootstarp

    4) Daha sonra "autoconf" projelerinin çoğunda olduğu gibi bir "configure" işlemi yapılmalıdır. Bunun için "configure" denilen 
    program çalıştırılır. Bu program çalıştırılırken kurulumun hangi dizine yapılacağı da "--prefix" komut satırı argümanı
    ile belirtilebilir. Bu argümana "mutlak yol ifadesinin" verilmesi gerekmektedir. Örneğin

    $ ./configure --prefix=/home/kaan/crosstool-NG

    5) Artık projenin derlenmesi "make" komutuyla gerçekleştirilebilir:

    $ make

    6) Artık derleme yapılmıştır. Son aşama olarak derlenmiş programın install edilmesi kalmıştır. Bu işlem de "make install" 
    komutuyla yapılmaktadır:

    $ make install

    Bu komutla crosstool-NG configure işleminde --prefix ile belirtilen dizine kurulacaktır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												11. Ders 16/04/2024 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    crosstool-NG'de çapraz araç zincirleri için üç makine söz konusudur:

    1) Build Makinesi (Build Machine): Çapraz derleme araçlarının oluşturulduğu makinedir. Örneğin biz Intel tabanlı masaüstü 
    bilgisayarımızda alet zinciri oluşturmak amacıyla build işlemi yapıyorsak build makinesi bu makinedir.

    2) Host Makinesi (Host Machine): Oluşturulmuş olan araç zincirinin kullanıldığı makinedir. Örneğin biz Intel tabanlı masaüstü
    bilgisayarımızda ARM için çapraz derleme yapıyorsak bu durumda host makinesi bu çapraz derlemeyi yaptığımız makinedir.

    3) Hedef Makine (Target Machine): Derlenmiş olan kodun çalıştırılacağı makineyi belirtmektedir. Örneğin biz Intel işlemcilerinin
    kullanıldığı host makinede ARM için çapraz derleme yapmışsak burada hedef makine ARM işlemcisinin bulunduğu makinedir.

    Genellikle "build makinesi" ile "host makinesi" aynı makine olmaktadır. Yani biz genellikle araç zincirini build ettiğimiz 
    makinede aynı zamanda çapraz derleme işlemlerini de yaparız.

    crosstool-NG'nin dokümantasyonunda build makinesi, host makinesi ve hedef makine kombinasyonları için dört terim kullanılmaktadır:

    1) Eğer "build makinesi == host makinesi == hedef makine" ise bu tür araç zincirlerine "doğal araç zincirleri (native toolchains) 
    denilmektedir.

    2) Eğer "build makinesi == host makinesi != hedef makine" ise bu tür araç zincirlerine "çapraz araç zincirleri (cross toolchains)" 
    denilmektedir. crosstool-NG için en çok kullanılan araç zincirleri bunlardır.

    3) Eğer "build makinesi != host makinesi == hedef makine" ise bu tür araç zincirlerine "çapraz-doğal araç zincirleri 
    (cross-native toolchains)" denilmektedir.

    4) Eğer "build makinesi != host makinesi != hedef makine" ise böyle araç zincirlerine "kanadalı araç zincirleri (canadian 
    toolchains)" denilmektedir.

    Kanadalı araç zincirine dikkat ediniz. Örneğin biz ARM tabanlı bir Linux makinede araç zinciri oluşturmak isteyelim. 
    Ancak araç zincirimiz Intel tabanlı bir bilgisayarda çalışacak olsun. Ancak bu Intel tabanlı bilgisayarda bu araç zincirini 
    çalıştırdığımızda üretilecek kod MIPS tabanlı bir bilgisayara yönelik olsun. Burada crosstool-NG terminolojisine göre bir 
    Kanadalı araç zinciri söz konusudur.

    Ancak crosstool-NG her zaman build işleminin yapıldığı makinede çalışacak araç zinciri kodu üretmektedir. Yani üretilen 
    araç zincirinde "build makinesi == host makine" olmaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    crosstool-NG'de işlemler "bin" klasörünün altında "ct-ng" isimli programla yapılmaktadır. Biz burada sizin crosstool-NG'nin 
    ana klasöründe olduğunuzu varsayacağız.

    Maalesef crosstool-NG aracında halen bazı böcekler bulunmaktadır. Örneğin eğer Linux sisteminizdeki "sistem dili" Türkçe ise
    crosstool-NG derlenirken bu sistem dilini referans aldığı için ürettiği script'lerde Türkçe karakterleri kullanmaktadır.
    Bu da bu script'lerin çalıştırılmasında sorunlara yol açmaktadır. Bu böceğin "arkasından dolaşmak (workaround)" için sistem 
    dili Türkçe yerine İngilizce yapılabilir. (Mint dağıtımında bu işlem ana menüden "Tercihler/Diller" seçeneği kullanılarak 
    yapılabilir. Burada yalnızca arayüz dilini değiştirebilirsiniz.) Tabii bu değişiklik yapıldıktan sonra crosstool-NG'yi yeniden 
    derlenmelidir. (Aslında muhtemelen derleme sırasında kodlar "LANG" ve "LANGUAGE" gibi bazı çevre değişkenlerine bakmaktadır. 
    Sistem ayarlarını değiştirmeden yalnızca birkaç çevre değişkeni geçici olarak da değiştirilebilir. Ancak sistem dilinin 
    değiştirilmesi daha sorunsuz bir çözüm oluşturacaktır.) crosstool-NG derlendikten sonra sistem dilini eski haline getirebilirsiniz. 
    Sistem dilini değiştirdikten sonra makinenizi reboot etmelisiniz.

    crosstool-NG'de araç zinciri derleme işlemi sırasıyla şu adımlardan geçilerek sağlanmaktadır:

    1) Önce araç zinciri "ct-ng" programı ile konfigüre edilir. Araç zincirinin konfigürasyonu için "menuconfig" argümanı 
    kullanılmaktadır:

    $ bin/ct-ng menuconfig

    Karşımıza bir konfigürasyon menüsü gelecektir. Bu menüde ilgili öğeler seçilip konfigürasyon save edilir. Save işlemi sonrasında
    default durumda ".config" isimli bir dosya oluşacaktır. (UNIX/Linux sistemlerinde başında "." olan dosya ve klasörlerin ls 
    komutunda default olarak görüntülenmediğine dikkat ediniz.)

    Konfigürasyon işleminde pek çok menü seçeneği bulunmaktadır. Bu seçeneklerin hepsi için belirlemeler yapmak yerine isteğinize en 
    yakın olan hazır bir konfigürasyonu yükleyip değişiklikleri onun üzerinde yapabilirsiniz. Hazır konfigürasyonların listesi 
    aşağıdaki gibi görüntülenebilir:

    $ bin/ct-ng list-samples
    Status  Sample name
    [G...]   aarch64-ol7u9-linux-gnu
    [G...]   aarch64-ol8u6-linux-gnu
    [G...]   aarch64-ol8u7-linux-gnu
    [G...]   aarch64-rpi3-linux-gnu
    [G...]   aarch64-rpi4-linux-gnu
    [G...]   aarch64-unknown-linux-gnu
    [G..X]   aarch64-unknown-linux-musl
    [G...]   aarch64-unknown-linux-uclibc
    [G...]   alphaev56-unknown-linux-gnu
    [G...]   alphaev67-unknown-linux-gnu
    [G...]   arc-arc700-linux-uclibc
    ...

    Hazır bir konfigürasyonu yüklemek için buradaki isimlerden uygun olanı seçilir ve aşağıdaki gibi yükleme yapılır:

    $ bin/ct-ng <hazır şablonun ismi>

    Örneğin:

    $ bin/ct-ng arm-cortex_a8-linux-gnueabi

    Bir konfigürasyonun belirlemeleri konfigürasyon isminin başına "show-" getirilerek görüntülenebilmektedir. Örneğin:

    $ bin/ct-ng show-arm-cortex_a8-linux-gnueabi
    [G...]   arm-cortex_a8-linux-gnueabi
        Languages       : C,C++
        OS              : linux-6.6.1
        Binutils        : binutils-2.42
        Compiler        : gcc-13.2.0
        C library       : glibc-2.39
        Debug tools     : duma-2_5_21 gdb-14.2 ltrace-0.7.3 strace-6.6
        Companion libs  : expat-2.5.0 gettext-0.21 gmp-6.2.1 isl-0.26 libelf-0.8.13 libiconv-1.16 mpc-1.3.1 mpfr-4.2.1
                          ncurses-6.4 zlib-1.3 zstd-1.5.5
        Companion tools :

    BBB için araç zinciri oluşturmak isteniyorsa buna en yakın konfigürasyon "arm-cortex_a8-linux-gnueabi" isimli konfigürasyondur.
    Bu konfigürasyonu aşağıdaki gibi yükleyebilirsiniz:

    $ bin/ct-ng arm-cortex_a8-linux-gnueabi

    Sonra menuconfig yaparak konfigürasyon menüsüne girebilirsiniz:

    $ bin/ct-ng menuconfig

    Burada şu seçenekleri değiştirmeniz gerekir:

    - "Paths and misc options" menüsünden "Render the toolchain read-only" unchecked yapılır.
    - "Target/Floating Point" menüsünden "hardware (FPU)" seçilir.
    - "Target/Use specific FPU" menüsünde "neon" girilir.
    - "C-Library" menüsünden "Versions of glibc" alt menüsüne gelinip glibc kütüphanesinin versiyon numarası 2.31 yapılır.
    (BBB'deki debian sürümü glibc 2.34'i kullanmaktadır.)

    2) Araç zinciri menuconfig ile konfigüre edildikten sonra artık "build" işlemi aşağıdaki gibi yapılabilir:

    $ bin/ct-ng build

    3) crosstool-NG ürettiği araç zincirini default olarak "home" dizininin altında "x-tools" isimli bir dizine yerleştirmektedir. 
    Örneğin yukarıda ürettiğimiz araç zinciri bu dizinde şöyle gözükmektedir:

    $ ls -l x-tools
    total 4
    drwxrwxr-x 8 kaan kaan 4096 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf

    Buradaki dizin hazır araç zincirlerinde olduğu bir yapıya sahiptir. Derleyiciler ve diğer binary araçlar "bin" dizininin içerisinde
    bulunmaktadır. Örneğin:

    -rwxr-xr-x 1 kaan kaan  1123904 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-addr2line
    -rwxr-xr-x 2 kaan kaan  1156456 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-ar
    -rwxr-xr-x 2 kaan kaan  2193584 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-as
    -rwxr-xr-x 2 kaan kaan  1850512 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-c++
    lrwxrwxrwx 1 kaan kaan       33 Nis 16 22:41 arm-cortex_a8-linux-gnueabihf-cc -> arm-cortex_a8-linux-gnueabihf-gcc
    -rwxr-xr-x 1 kaan kaan  1123392 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-c++filt
    -rwxr-xr-x 1 kaan kaan  1850512 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-cpp
    -rwxr-xr-x 1 kaan kaan     5812 Nis 16 21:19 arm-cortex_a8-linux-gnueabihf-ct-ng.config
    -rwxr-xr-x 1 kaan kaan  2742848 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-dwp
    -rwxr-xr-x 1 kaan kaan    43704 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-elfedit
    -rwxr-xr-x 2 kaan kaan  1850512 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-g++
    -rwxr-xr-x 2 kaan kaan  1846416 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-gcc
    -rwxr-xr-x 2 kaan kaan  1846416 Nis 16 23:14 arm-cortex_a8-linux-gnueabihf-gcc-13.2.0
    ...

    crosstool-NG'de daha önce yapılan ve ".config" dosyasına save edilen konfigürasyon dosyası "oldconfig" argümanıyla 
    geri yüklenebilir. Örneğin:

    $ bin/ct-ng oldconfig

    Artık bundan sonra "menuconfig" yaparsak eski konfigürasyon dosyasını yüklemiş oluruz.

    Daha önce yapılan build işleminden kalan birtakım dosyaların kaldırılması için ise "distclean" argümanıyla yapılabilmektedir. 
    Örneğin:

    # bin/ct-ng distclean

    distclean işlemi oluşturulan araç zincirlerini silmemektedir. Araç zincirlerinin oluşturulması için yaratılmış olan dosyaları 
    silmektedir.

    ct-ng programının diğer komut satırı argümanları için aşağıdaki bağlantıdan faydalanabilirsiniz:

    https://man.archlinux.org/man/extra/crosstool-ng/ct-ng.1.en

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Araç zincirlerinin nasıl oluşturulduğunu ve kullanıldığını gördükten sonra şimdi dikkatimizi araç zincirleri içerisindeki 
    araçlara yönelteceğiz. Araç zincirleri içerisindeki en önemli araçlar şüphesiz "C Derleyicileri", "C++ Derleyicileri" ve 
    "Bağlayıcı (linker)" programlardır.

    Bilindiği gibi derleyiciler aslında "amaç dosya (object file)" denilen bir dosya üretmektedir. Bu amaç dosyalara "bağlayıcı
    (linker)" denilen programlara sokularak çalıştırılabilir (executable) dosya oluşturulmaktadır. Sistem programcısının bu 
    kavramlar hakkında temel bilgilere sahip olması gerekmektedir. Amaç dosyaların UNIX/Linux sistemlerindeki uzantıları ".o" 
    biçimindedir. Çalıştırılabilen dosyalar için UNIX/Linux sistemlerinde özel bir uzantı kullanılmamaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Derleyicilerin ürettiği amaç dosyaların (object files) ve bağlayıcıların ürettiği çalıştırılabilir dosyaların (executable files)
    önceden belirlenmiş belli bir formatı vardır. Microsoft DOS zamanlarında amaç dosya formatı olarak "OMF (Object Module Format)" 
    denilen bir formatı, çalıştırılabilir dosya formatı olarak da "MZ (Mark Zibikovski) " denilen bir formatı kullanıyordu. Sonra 
    16 bit Windows sistemleriyle amaç dosya formatı olarak OMF formatını kullanmaya devam etti, ancak çalıştırılabilir dosya formatı 
    olarak "NE (New Executable)" isimli bir formatı kullanmaya başladı. Sonra nihayet 32 bit ve 64 bit Windows sistemlerinde amaç 
    dosya formatı olarak COFF (Common Object File Format)", çalıştırılabilir dosya formatı olarak "PE (Portable Executable)" denilen 
    formatı kullanmaya başladı. Bugün Microsoft COFF ve PE formatlarını kullanmaktadır. COFF formatı ile PE formatı hemen hemen aynı 
    formatlardır. COFF formatı, PE formatının amaç dosya için özelleştirilmiş biçimi gibidir.

    Apple firması macOS sistemlerinde amaç dosya ve çalıştırılabilir dosya formatı olarak "Mach-O" formatı denilen bir dosya formatını
    kullanmaktadır.

    UNIX/Linux sistemlerinde uzunca bir süredir en yaygın kullanılan amaç dosya formatı ve çalıştırılabilir dosya formatı "ELF
    (Executable and Linkable Format)" isimli formattır. ELF formatı hem bir amaç dosya formatı hem de çalıştırılabilir dosya
    formatıdır. ELF formatının 32 bit ve 64 bit biçimleri vardır. Linux geçmişe doğru uyum için eski geleneksel "a.out" denilen 
    çalıştırılabilir dosya formatını da desteklemektedir. Fakat Linux sistemlerindeki default amaç dosya ve çalıştırılabilir 
    dosya formatı ELF formatıdır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde ELF dosyasını belleğe yükleyip çalışmaya hazır hale getirme işlemi "exec fonksiyonları" tarafından
    yapılmaktadır. (Linux sistemlerinde yalnızca execve fonksiyonu sistem fonksiyonu olarak bulundurulmuştur. Diğer exec 
    fonksiyonları execve fonksiyonunu çağırmaktadır.) Kavramsal olarak işletim sistemlerinde çalıştırılabilir dosyayı belleğe 
    yükleyerek çalıştırma durumuna getiren alt sistemlere "yükleyici (loader)" denilmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Sistem programcısı olarak bir dosyanın içeriğini byte-byte hex sistemde görmek isteyebiliriz. Windows sistemlerinde bunu 
    yapan pek çok GUI uygulaması vardır. "HxD" denilen program oldukça yeteneklidir ve ücretsiz olarak kullanılabilmektedir. 
    Linux ve macOS sistemlerinde "hex editör" olarak çok güzel GUI programlarla karşılaşmak zordur. "GHex" isimli GUI hex editör 
    oldukça basittir ve GNOME sistemlerinde kullanılmaktadır. "ghex" programı aşağıdaki gibi install edilebilir:

    $ sudo apt-get install ghex

    Yine GUI hex editörlerinden biri de "bless" isimli editördür. Şöyle kurulabilir:

    $ sudo apt-get install bless

    Linux ve macOS sistemlerinde yetenekli IDE'ler aynı zamanda bir hex editör işlevini de görebilmektedir. Örneğin Visual Studio
    Code editörünün "Hex Editor" isimli bir eklentisi (Microsoft tarafından yazılmıştır) dosya içeriklerini hex olarak gösterebilmektedir. 

    Ancak tabii Linux sistemleri ağırlıklı biçimde komut satırından işletildiği için sistem programcısının bir dosyanın içeriğini 
    komut satırından hex sistemde görüntülemesi gerekebilmektedir. Linux için konsol ekranında çalışan bazı hex gösterim yapan
    programlar şunlardır:

    - "od" programı. Tipik kullanımı şöyledir:

    od -t x1 <yol ifadesi>

    od default olarak dağıtımlarda bulunmaktadır.

    - "hexer" isimli program eski DOS sistemine benzer bir biçimde görüntüleme yapmaktadır. Şöyle kurulabilir:

    $ sudo ept-get install hexer

    - "hexcurse" isimli program. Hexcurse şöyle kurulabilir:

    $ sudo apt-get install hexcurse

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												12. Ders 18/04/2024 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ELF dosyasının genel yapısı şöyledir:

    |ELF Başlığı (ELF Header)|
    |Program Başlık Tablosu (Program Header Table) (İsteğe Bağlı)|
    |Bölümler (Sections)|
    |Bölüm Başlık Tablosu (Section Header Table)|

    ELF dosyasının hemen başında bir başlık kısmı (ELF Header) bulunmaktadır. Bu başlık kısmında dosya hakkında en önemli bilgiler
    tutulmaktadır.

    32 bit ELF dokümanlarında ELF formatının yapısal içeriğinde kullanılan tür isimleri ve anlamları şöyledir:

    Name            Size        Alignment       Purpose
    Elf32_Addr      4           4               Unsigned program address
    Elf32_Half      2           2               Unsigned medium integer
    Elf32_Off       4           4               Unsigned file offset
    Elf32_Sword     4           4               Signed large integer
    Elf32_Word      4           4               Unsigned large integer
    unsigned char   1           1               Unsigned small integer

    64 bit ELF dokümanlarında ELF formatının yapısal içeriğinde kullanılan tür isimleri ve anlamları da şöyledir:

    Name                Size        Alignment       Purpose
    Elf64_Addr      8           8               Unsigned program address
    Elf64_Off       8           8               Unsigned file offset
    Elf64_Half      2           2               Unsigned medium integer
    Elf64_Word      4           4               Unsigned integer
    Elf64_Sword     4           4               Signed integer
    Elf64_Xword     8           8               Unsigned long integer
    Elf64_Sxword    8           8               Signed long integer
    unsigned char   1           1               Unsigned small integer

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ELF Başlığında dosyadaki meta-data alanları hakkında önemli bilgiler yer almaktadır. ELF başlığığının ilk 16 byte'tı "kimlik 
    bilgileri (identification)" denilen dosyanın en kritik bilgilerini tutan kısmıdır. ELF dosyasının ilk dört byte'ında bir 
    "sihirli sayı (magic number)" bulundurulmuştur. Bu ilk 4 byte'ın ilk byte'ı 0x7F sonraki üç byte'ı da 'E', 'L', 'F' karakterlerinin 
    ASCII kodlarından oluşmaktadır. Yani ELF dosyasının ilk 4 byte'ı hex olarak şöyledir:

    7F 45 4C 46

    Kimlik bilgilerinin 4'üncü offset'teki byte'ı ELF dosyasının 32 bit mi 64 bit mi olduğunu belirtmektedir. Eğer ELF dosyası 
    32 bit ise (yani 32 bitlik bir işletim sistemi için oluşturulmuşsa) burada 1 değeri 64 bit ise (yani 64 bit bir işletim 
    sistemi için oluşturulmuşsa) burada 2 değeri olmalıdır.

    Kimlik bilgilerininin 5'inci offset'teki byte'ı ELF dosyasının "little endian" olarak mı yoksa "big endian" olarak mı 
    oluşturulduğunu belirtmektedir. Buradaki değer 1 ise dosya "little endian", 2 ise dosya "big endian" biçiminde oluşturulmuştur. 
    Intel işlemcilerinin yalnızca "little endian" kullandığını, ARM işlemcilerinin hem "little endian" hem de "big endian" 
    olarak kullanılabildiğini ancak default kullanımın "little endian" olduğunu anımsayınız. O halde burada tipik olarak 1 
    değeri bulunacaktır.

    Kimlik bilgilerinin 6'ıncı offset'indeki byte'ı ELF dosyasının majör versiyon numarasını belirtmektedir. Şu anda ELF dosyasının 
    majör olarak 1'li versiyonları kullanıdlığı için burada 1 değeri bulunacaktır.

    Kimlik bilgilerinin 7'inci offset'teki byte'ı kullanılan ABI türünü belirtmektedir. Buradaki 0 değeri klasik "System 5 ABI"
    anlamına gelmektedir. Burada genellikle 0 değeri bulunmaktadır.

    Kimlik bilgilerinin 8'inci offset'teki byte'ı ABI versiyon numarasını belirtmektedir. Genel olarak burada 0 değeri bulunur.

    Kimlik bilgilerinin 9'uncu offset'inden itibaren artık 16 byte'tan geri kalan byte'lar 0'larla doldurulmuştur. Bu 0 byte'larına
    "padding" denilmektedir.

    Aşağıda 64 bit Intel makinesinde oluşturulmuş bir ELF formatının ilk 16 byte'ı görülmektedir:

    7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  .ELF............

    Aşağıda da 32 bit ARM işlemcileri için oluşturulmuş bir ELF formatının ilk 16 byte'ı görülmektedir:

    7f 45 4c 46 01 01 01 00  00 00 00 00 00 00 00 00  .ELF............

    ELF Başlığında kimlik bilgilerinden (ilk 16 byte) sonra yine dosya hakkında önemli bilgiler yer almaktadır. ELF başlığının 
    16'ıncı offset'indeki 2 byte'lık işaretsiz tamsayı dosyanın türünü belirtmektedir. Tipik tür değerleri şunlardır:

     0 ---> Geçersiz
     1 ---> Amaç Dosya (Relocatable Object File)
     2 ---> Çalıştırılabilir Dosya (Executable File)
     3 ---> Dinamik Kütüphane Dosyası (Shared Object)
     4 ---> Çekirdek Dosyası (Core File)

    ELF Başlığının 18'inci offset'indeki 2 byte'lık işaretsiz tmsayı dosyanın çalıştırılacağı hedef işlemcinin türünü belirtmektedir. 
    Buradaki 2 byte'lık çeşitli işaretsiz tamsayı değerler çeşitli işlemci türlerini belirtmektedir. Örneğin 0x28 "32 Bit ARM 
    İşlemcilerini", 0x3E "AMD'nin 64 bit Intel Tabanlı İşlemcilerini" belirtmektedir. Bunların tam listesini Internet'teki 
    dokümanlardan elde edebilirsiniz. (Örneğin Wikipedia'da "Executable and Linkable Format" sayfasında ayrıntılı bir liste 
    verilmiştir.)

    ELF Başlığının 20'inci offset'teki 4 byte'lık işaretssiz tamsayı yine ELF dosyasının versiyon numarasını belirtmektedir. Burada 
    tipik olarak 1 değeri bulunacaktır.

    ELF Başlığının 24'üncü offset'inde "çalıştırılabilir dosyalar için" programın çalışmaya başlayacağı sanal adresi (virtual address) 
    belirtilmektedir. Çalıştırılabilir bir dosyanın çalıştırılmaya başlanacağı adrese aşağı seviyeli terminoloji de "entry point" 
    denilmektedir. Tabii adres bilgileri 32 bit ELF dosyalarında 4 byte, 64 bit ELF dosyalarında 8 byte uzunluktadır.

    ELF Başlığının sonraki elemanlarının offset'leri artık 32 bit ve 64 bit ELF dosyalarına göre değişmektedir. 32 bit ELF 
    dosyalarında adres bilgileri ve dosya offset bilgileri 4 byte uzunluğunda, 64 bit ELF dosyalarında ise 8 byte uzunluğundadır.

    ELF başlığında bulunan diğer bilgiler şunlardır:

    - ELF Başlığının (ELF Header) byte uzunluğu.

    - Program Başlık Tablosunun (Program Header Table)" dosyada hangi offset'ten başladığı bilgisi. Program başlık tablosu
    tipik olarak ELF başlığından hemen sonra gelmektedir.

    - Program Başlık Tablosundaki Program Başlıklarının sayısı

    - Bölüm Başlık Tablosunun (Section Header Table) dosyada hangi offset'ten başladığı bilgisi. Bölüm Başlık Tablosu genellikle 
    ELF formatının sonunda bulunmaktadır.

    - Bölüm Başlık Tablosundaki bölüm başlıklarının sayısı ve bir Bölüm Başlığının byte uzunluğu.

    - Bölüm Başlık isimlerinin bulunduğu String Tablosunun Bölüm Başlık Tablosundaki indeksi.

    32 bit ELF formatında ELF Başlığının yapısal içeriği şöyledir:

    #define EI_NIDENT		16

    typedef struct {
        unsigned char e_ident[EI_NIDENT];   /* ELF identification */
        Elf32_Half e_type;                  /* Object file type */
        Elf32_Half e_machine;               /* Machine type */
        Elf32_Word e_version;               /* Object file version */
        Elf32_Addr e_entry;                 /* Entry point address */
        Elf32_Off e_phoff;                  /* Program header offset */
        Elf32_Off e_shoff;                  /* Section header offset */
        Elf32_Word e_flags;                 /* Processor-specific flags */
        Elf32_Half e_ehsize;                /* ELF header size */
        Elf32_Half e_phentsize;             /* Size of program header entry */
        Elf32_Half e_phnum;                 /* Number of program header entries */
        Elf32_Half e_shentsize;             /* Size of section header entry */
        Elf32_Half e_shnum;                 /* Number of section header entries */
        Elf32_Half e_shstrndx;              /* Section name string table index */
    } Elf32_Ehdr;

    64 bit ELF formatında ise ELF Başlığının yapısal içeriği şöyledir:

    typedef struct {
        unsigned char e_ident[16];          /* ELF identification */
        Elf64_Half e_type;                  /* Object file type */
        Elf64_Half e_machine;               /* Machine type */
        Elf64_Word e_version;               /* Object file version */
        Elf64_Addr e_entry;                 /* Entry point address */
        Elf64_Off e_phoff;                  /* Program header offset */
        Elf64_Off e_shoff;                  /* Section header offset */
        Elf64_Word e_flags;                 /* Processor-specific flags */
        Elf64_Half e_ehsize;                /* ELF header size */
        Elf64_Half e_phentsize;             /* Size of program header entry */
        Elf64_Half e_phnum;                 /* Number of program header entries */
        Elf64_Half e_shentsize;             /* Size of section header entry */
        Elf64_Half e_shnum;                 /* Number of section header entries */
        Elf64_Half e_shstrndx;              /* Section name string table index */
    } Elf64_Ehdr;

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												13. Ders 25/04/2024 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ELF formatını parse edip insanların anlayabileceği biçimde görüntüleyen çeşitli utility programlar bulunmaktadır. Bunların 
    en yaygın kullanılan ikisi "readelf" ve "objdump" programlarıdır. Bu programların ayrıntılı dokümantasyonu "man" sayfalarında 
    bulunmaktadır. "objdump" programı daha genel, readelf programı daha özel programlardır. Ancak "objdump" programı işlevsel 
    olarak "readelf" programını tam olmasa da kapsar niteliktedir. "readelf" programının kullanımı daha kolaydır.

    readelf programında "-h" ya da "--file-header" seçeneği ELF başlığını görüntülemek için kullanılmaktadır. Örneğin:

    $ readelf -h sample
    ELF Başlığı:
    Sihir:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
    Sınıf:                              ELF64
    Veri:                               2's complement, little endian
    Version:                            1 (current)
    OS/ABI:                             UNIX - System V
    ABI Sürümü:                         0
    Tip:                                DİN (Paylaşımlı nesne dosyası)
    Makine:                             Advanced Micro Devices X86-64
    Sürüm:                              0x1
    Girdi noktası adresi:               0x1060
    Yazılım başlıkları başlangıcı:      64 (bayt dosya içinde)
    Bölüm başlıkları başlangıcı:        14712 (bayt dosya içinde)
    Seçenekler:                         0x0
    Size of this header:                64 (bytes)
    Size of program headers:            56 (bytes)
    Number of program headers:          13
    Size of section headers:            64 (bytes)
    Number of section headers:          31
    Section header string table index:  30

    objdump programı ile ELF formatının başlıkları "-x" ya da "--all-headers" seçeneği ile görüntülenebilir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ELF Formatı içerisinde pek çok "isim" belirten öğe bulunmaktadır. İsimler değişken uzunlukta olabileceği için hem isim 
    tekrarlarında kolaylık sağlamak hem de isimlerin sabit uzunlukta ifade edilmesini sağlamak amacıyla "string tabloları" 
    bulundurulmuştur. String tabloları sonu '\0' ile biten yazılardan oluşmaktadır. ELF formatı içerisinde ne zaman bir isim
    belirtilecek olsa isim yerine o ismin bulunduğu string tablosundaki offset belirtilmektedir. ELF formatında string tabloları 
    da aslında "bölümler (sections)" biçimindedir. ELF dosyasında tek bir string tablosu bulunmak zorunda değildir. Genellikle 
    derleyiciler normal sembolleri ".strtab" isimli bölümde "bölüm başlıklarının isimlerini" ".shstrtab" isimli bölümde, dinamik
    kütüphanelerdeki sembollerin isimlerini de ".dynstr" isimli bölümde string tabloları biçiminde tutmaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirtitğimiz gibi ELF formatı "bölümlerden (sections)" oluşmaktadır. Her bölümde belli bir konuya ilişkin
    bilgiler bulunmaktadır. ELF formatının derleyiciler tarafından kullanılan standart bazı bölümleri vardır. Ancak çeşitli 
    derleyiciler ve hatta sistem programcıları standrat olmayan bölümler de oluşturabilmektedir. Bölümlerin birer ismi vardır.
    Bölüm isimleri genellikle "." karakteri ile başlatılır. ELF dosyası içerisindeki bütün bölümlerin dosyanın neresinden 
    başladığıi, hangi uzunlukta olduğu ve o bölümde hangi tarzda bilgiler bulunduğu "Bölüm Başlık Tablosu (Section Header Table)
    denilen bir tabloda belirtilmiştir. Bölüm Başlık Tablosunun dosya içerisindeki yeri ve Bölüm Başlıklarının Sayısı ELF 
    Başlığında bulunmaktadır. Bu durumda ELF dosyasının bölüm bilgilerini elde etmek için önce ELF Başlığı okunmalı oradan Bölüm 
    Başlık Tablosunun yeri elde edilmelidir. Bölüm Başlık Tablosu "Bölüm Başlığı (Section Header)" denilen alanlardan oluşmaktadır. 
    Başka bir deyişle Bölüm Başlık Tablosu "Bölüm Başlığı Dizilerinden" oluşmaktadır. Bir Bölüm Başlığında aşağıdaki bilgiler 
    bulunmaktadır:

    - Bölümün isminin bölüm isimlerinin bulunduğu string tablosundaki offset numarası

    - Bölümün türü. Her bölüm belli bir konuya ilişkin bilgi tutmaktadır. İşte bölümün hangi konuya ilişkin bilgiyi tuttuğuna
    bölümün türü ddenilmektedir. Bölüm türleri aslında birer sayıyla belirtiliyorsa da okunabilirliği artırmak için sembolik
    isimlerle de belirtilmektedir. Örneğin SHT_STRTAB türü ilgili bölümün içerisinde "string tablosu olduğunu", SHT_RELA ilgili
    bölümün içerisinde "relocation" bilgilerinin bulunduğunu belirtmektedir.

    - Bölümün bayrakları. Bölüm hakkında diğer bazı önemli bilgiler bölüm bayrakları biçiminde belirtilmektedir. Örneğin bir 
    bölümün yükleyici tarafından dosyasının içerisinde belleğe yüklenip yüklenmeyeceği, bölümün read-only olup olmadığı gibi 
    bayraklar ilgili bölüm hakkında önemli bilgiler vermektedir.

    - Bölüm eğer yükleyici tarafından belleğe yüklenecekse sanal belleğin neresine yükleneceğine ilişkin adres bilgisi. Tabii 
    bölüm belleğe yüklenmeyecekse bu adres bilgisi kullanılmaz. Burada 0 değeri bulunur.

    - Bölümün dosyanın hangi offsetin'den başladığı bilgisi.

    - Bölümün kaç byte uzunlukta olduğu bilgisi.

    - Bölümün hangi string tablosunu ya da sembol tablosunu kullandığı bilgisi.

    - Diğer bazı bilgiler.

    32 bit ELF formatında Bölüm Başlığının yapısal içeriği şöyledir:

    typedef struct {
        Elf32_Word sh_name;         /* Section name */
        Elf32_Word sh_type;         /* Section type */
        Elf32_Word sh_flags;        /* Section attributes */
        Elf32_Addr sh_addr;         /* Virtual address in memory */
        Elf32_Off sh_offset;        /* Offset in file */
        Elf32_Word sh_size;         /* Size of section */
        Elf32_Word sh_link;         /* Link to other section */
        Elf32_Word sh_info;         /* Miscellaneous information */
        Elf32_Word sh_addralign;    /* Address alignment boundary */
        Elf32_Word sh_entsize;      /* Size of entries, if section has table */
    } Elf32_Shdr;

    64 bit ELF formatında ise Bölüm Başlığının yapısal içeriği şöyledir:

    typedef struct
    {
        Elf64_Word sh_name;         /* Section name */
        Elf64_Word sh_type;         /* Section type */
        Elf64_Xword sh_flags;       /* Section attributes */
        Elf64_Addr sh_addr;         /* Virtual address in memory */
        Elf64_Off sh_offset;        /* Offset in file */
        Elf64_Xword sh_size;        /* Size of section */
        Elf64_Word sh_link;         /* Link to other section */
        Elf64_Word sh_info;         /* Miscellaneous information */
        Elf64_Xword sh_addralign;   /* Address alignment boundary */
        Elf64_Xword sh_entsize;     /* Size of entries, if section has table */
    } Elf64_Shdr;

    Bölüm Başlık Tablosundaki Bölüm Başlıkları "readelf" programında "-S" veya "--section-headers" veya "--sections" seçenekleri 
    kullanılmaktadır. Örneğin:

    $ readelf -S sample
    There are 31 section headers, starting at offset 0x3978:

    Bölüm Başlıkları:
    [Nr] İsim              Tip              Adres             Basamak
        Boy               EntBoy           Seç    Bağ   Bilgi Hiza
    [ 0]                   NULL             0000000000000000  00000000
        0000000000000000  0000000000000000           0     0     0
    [ 1] .interp           PROGBITS         0000000000000318  00000318
        000000000000001c  0000000000000000   A       0     0     1
    [ 2] .note.gnu.propert NOTE             0000000000000338  00000338
        0000000000000020  0000000000000000   A       0     0     8
    [ 3] .note.gnu.build-i NOTE             0000000000000358  00000358
        0000000000000024  0000000000000000   A       0     0     4
    .................................................................
    [29] .strtab           STRTAB           0000000000000000  00003658
        0000000000000204  0000000000000000           0     0     1
    [30] .shstrtab         STRTAB           0000000000000000  0000385c
        000000000000011a  0000000000000000           0     0     1
    Key to Flags:
    W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
    L (link order), O (extra OS processing required), G (group), T (TLS),
    C (compressed), x (unknown), o (OS specific), E (exclude),
    l (large), p (processor specific)

    Bölüm Başlık Tablosundaki Bölüm Başlıkları "objdump" programı ile "-h" veya "--section-headers" veya "--headers" seçenekleriyle 
    görüntülenebilmektedir. Örneğin:

    kaan@kaan-virtual-machine:~/Study/EmbeddedLinux$ objdump -h sample

    sample:     elf64-x86-64 dosya biçemi

    Bölümler:
    Idx Name          Size      VMA               LMA               File off  Algn
    0 .interp       0000001c  0000000000000318  0000000000000318  00000318  2**0
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    1 .note.gnu.property 00000020  0000000000000338  0000000000000338  00000338  2**3
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    2 .note.gnu.build-id 00000024  0000000000000358  0000000000000358  00000358  2**2
                    CONTENTS, ALLOC, LOAD, READONLY, DATA
    .................................................................................
                    CONTENTS, ALLOC, LOAD, DATA
    25 .bss          00000008  0000000000004010  0000000000004010  00003010  2**0
                    ALLOC
    26 .comment      0000002b  0000000000000000  0000000000000000  00003010  2**0
                    CONTENTS, READONLY

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ELF Formatının en önemli kısımlarından biri "sembol tablosu (symbol table)" denilen kısmıdır. Sembol (symbol) derleyici ve 
    bağlayıcı dünyasında "değişken (identifier)" anlamına gelen bir terimdir. Yani programlamada "değişken (variable/identifier)" 
    kavramı derleyici ve bağlayıcı dünyasında "sembol (symbol)" biçiminde ifade edilmektedir. Semboller fonksiyon isimleri biçiminde, 
    global değişken isimleri biçiminde olabileceği gibi başka varlıklar (entity) biçiminde de karşımıza çıkabilmektedir. Semboler 
    yalnızca isimlerden oluşmazlar bir sembole ilişkin başka özellikler de vardır. İşte sembol tablolarında sembollerin isimleri 
    ve onlara ilişkin özellikler tutulmaktadır.

    Sembol tabloları bölümlerin içerisinde bulunur. ELF dosyasında tek bir sembol tablosu bulunmak zorunda değildir. Tipik olarak 
    derleyici ve bağlayıcılar iki ayrı sembol tablosu bulundurmaktadır. Program içerisindeki semboller SHT_SYMTAB bölüm türüyle, 
    dinamik kütüphanelerden kullanılan semboller SHT_DYNSYM bölüm türüyle belirtilmektedir. Sembol tablolarının bulunduğu tipik 
    bölümler şunlardır:

    .symtab         ---> Program içerisindeki sembollerin bulunduğu sembol tablosu
    .dynsym         ---> Dinamik kütüphanelerden kullanılan sembolleri bulunduğu sembol tablosu

/*-----------------------------------------------------------------------------------------------------------------------------
												14. Ders 30/04/2024 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Sembol tabloları sembollerden oluşmaktadır. Yani sembollerden oluşan bir dizi biçimindedir. Sembollerin bilgileri eşit 
    uzunluklu kayıtlar biçimindedir. 32 bit ELF formatındaki sembol tablosunun sembollerinin yapısal içeriği şöyledir:

    typedef struct {
        Elf32_Word st_name;         /* Symbol name */
        Elf32_Addr st_value;        /* Symbol value */
        Elf32_Word st_size;         /* Size of object (e.g., common) */
        unsigned char st_info;      /* Type and Binding attributes */
        unsigned char st_other;     /* Reserved */
        Elf32_Half st_shndx;        /* Section table index */
    } Elf32_Sym;

    64 bit ELF formatındaki sembol tablosunun sembollerinin yapısal içeriği ise şöyledir:

    typedef struct {
        Elf64_Word st_name;         /* Symbol name */
        unsigned char st_info;      /* Type and Binding attributes */
        unsigned char st_other;     /* Reserved */
        Elf64_Half st_shndx;        /* Section table index */
        Elf64_Addr st_value;        /* Symbol value */
        Elf64_Xword st_size;        /* Size of object (e.g., common) */
    } Elf64_Sym;

    Sembol tabloları özellikle "amaç dosyalarda (object files)" kritik önemdedir. Aşağıdaki gibi bir C programı bulunuyor olsun:

    /* sample.c */

    #include <stdio.h>

    char g_a[1000000];
    int g_b = 20;
    int g_c = 30;
    static int g_d = 40;

    void bar(void);

    void foo(void)
    {
        printf("foo\n");
    }

    void bar(void);

    int main(void)
    {
        foo();
        bar();

        return 0;
    }

    Bu programı "-c" seçneği ile link etmeden yanızca derleyelim:

    $ gcc -c sample.c

    readelf programı bize sembol tablosunu her satırda bir sembol bilgisi olacak biçimde de görüntüleyebilmektedir. readelf programı
    ile yalnızca sembol tablosu görünülenmek isteniyorsa "-s" ya da "--syms" ya da "--symbols" seçenekleri kullanılabilir. Örneğin:

    $ readelf -s sample.o

    Aynı işlem "objdump" programı ile "--syms" seçeneği kullanılaarak da yapılabilir:

    $ objdump --syms sample.o

    Biz yukarıdaki amaç dosyanın bütün bilgilerini "readelf -a" seçeneği ile bir dosyaya yönlendirelim:

    $ readelf -a sample.o > sample.o.txt

    readelf programı sembol tablosundaki her sembol bilgisini bir satır olacak biçimde görüntülemektedir. Yukarıdaki C programının 
    derlenmesi sonucunda elde edilen amaç dosyanın ".symtab" isimli sembol tablosu readelf tarafından aşağıdaki gibi görüntülenmiştir:

    Symbol table '.symtab' contains 12 entries:
      Num:    Value          Size Type    Bind   Vis      Ndx Name
        0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
        1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS sample.c
        2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text
        3: 0000000000000008     4 OBJECT  LOCAL  DEFAULT    3 g_d
        4: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 .rodata
        5: 0000000000000000 0xf4240 OBJECT  GLOBAL DEFAULT    4 g_a
        6: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 g_b
        7: 0000000000000004     4 OBJECT  GLOBAL DEFAULT    3 g_c
        8: 0000000000000000    26 FUNC    GLOBAL DEFAULT    1 foo
        9: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND puts
        10: 000000000000001a    25 FUNC    GLOBAL DEFAULT    1 main
        11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND bar

    Amaç dosyanın Bölüm Başlık Tablosu da şöyledir:

    Section Headers:
        [Nr] Name              Type             Address           Offset
            Size              EntSize          Flags  Link  Info  Align
        [ 0]                   NULL             0000000000000000  00000000
            0000000000000000  0000000000000000           0     0     0
        [ 1] .text             PROGBITS         0000000000000000  00000040
            0000000000000033  0000000000000000  AX       0     0     1
        [ 2] .rela.text        RELA             0000000000000000  00000278
            0000000000000060  0000000000000018   I      11     1     8
        [ 3] .data             PROGBITS         0000000000000000  00000074
            000000000000000c  0000000000000000  WA       0     0     4
        [ 4] .bss              NOBITS           0000000000000000  00000080
            00000000000f4240  0000000000000000  WA       0     0     32
        [ 5] .rodata           PROGBITS         0000000000000000  00000080
            0000000000000004  0000000000000000   A       0     0     1
        [ 6] .comment          PROGBITS         0000000000000000  00000084
            000000000000002c  0000000000000001  MS       0     0     1
        [ 7] .note.GNU-stack   PROGBITS         0000000000000000  000000b0
            0000000000000000  0000000000000000           0     0     1
        [ 8] .note.gnu.pr[...] NOTE             0000000000000000  000000b0
            0000000000000020  0000000000000000   A       0     0     8
        [ 9] .eh_frame         PROGBITS         0000000000000000  000000d0
            0000000000000058  0000000000000000   A       0     0     8
        [10] .rela.eh_frame    RELA             0000000000000000  000002d8
            0000000000000030  0000000000000018   I      11     9     8
        [11] .symtab           SYMTAB           0000000000000000  00000128
            0000000000000120  0000000000000018          12     5     8
        [12] .strtab           STRTAB           0000000000000000  00000248
            000000000000002c  0000000000000000           0     0     1
        [13] .shstrtab         STRTAB           0000000000000000  00000308
            0000000000000074  0000000000000000           0     0     1
        Key to Flags:
        W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
        L (link order), O (extra OS processing required), G (group), T (TLS),
        C (compressed), x (unknown), o (OS specific), E (exclude),
        D (mbind), l (large), p (processor specific)

    Sembol tablosundaki bir sembolde şu bilgiler bulunmaktadır:

    - Sembolün ismi: Bu isim ".strtab" isimli string tablosunda bir index belirtmektedir.

    - Sembolün Türü ve Bağlama Bilgisi: Sembolün türü onun bir "data" sembolü mü yoksa bir "fonksiyon" sembolü mü olduğunu 
    belirten bilgidir. Diğer sembol türleri ELF dokümanlarında belirtilmiştir. Sembolün bağlama bilgisi o sembolün diğer 
    modüller tarafından görünebilirliğine ilişkindir. Örneğin bir sembolün "global" olması demek başka bir modülden kullanılabilir
    olması demektir. Sembolün "local" olması demek sadece o modülde tanınabilmesi demektir. C'deki global değişkenler global 
    bağlama biçimine, static global değişkenler ise "local" bağlama biçimine sahiptir. Diğer bağlama biçimleri ELF dokümanlarında
    belirtilmiştir.

    - Sembolün Hangi Bölüm İçerisinde Olduğu Bilgisi: Eğer sembol ilgili modülde bir yer kaplıyorsa o bir bölümün içerisindedir. 
    İşte sembol tablosunda sembolün hangi bölüm içerisinde tanımlandığı (yer kapladığı) ilgili bölümün indeksiyle belirtilmektedir. 
    Fonksiyonlar ".txt" isimli bölümde, "ilkdeğer verilmiş global nesneler ".data" isimli bölümde, ilkdeğer verilmemiş global 
    değişkenler ise ".bss" isimli bölümde bulunurlar. Eğer bir sembol o modülde tanımlanmamışsa ona ilişkin bölüm bilgisi de 
    yoktur. Bu tür semboller sembol tablosunda "Undefined" olarak belirtilirler. Örneğin biz C'de başka bir modülde tanımlanmış 
    olan bir prototipini belirterek çağırmış olalım. Bu fonksiyon bizim dosyasımızda yer kaplamamaktadır. Sembol tablosunda bu 
    fonksiyonun ismi bulunur ancak bölüm olarak "Undefined" biçimde belirtilir. (readelf bunu "UND" olarak göstermektedir.)

    Sembolün Değeri: C'de global bir değişkene ilkdeğer verdiğimizi düşünelim. Bu ilkdeğerin de derleyici tarafından amaç 
    dosyaya bağlayıcı tarafından da çalıştırılabilen dosyaya yazılması gerekir. Böylece ilgili bölüm belleğe yüklenirken bu 
    global değişken ilkdeğeri ile birlikte belleğe yüklenecektir. İşte eğer bir modül içerisinde bir nense tanımlanmışsa o nesne 
    bir bölümün belli bir yerindedir. Sembolün değeri ilgili nesnenin kendi bölümünün kaçıncı offset'inden başladığını belirtmektedir. 
    Global nesnelere verilen ilkdeğerler ilgili bölümün burada belirtilen offset'inde saklanmaktadır.

    Sembolün Uzunluğu: Burada ilgili nesnenin bölüm içerisinde kaç byte yer kapladığı bilgisi bulundurulmaktadır. Eğer ilgili 
    sembol o modülde tanımlanmış olan bir fonksiyon ise sembolün uzunluğu fonksiyonun kapladığı yerin byte uzunluğu olarak 
    sembol tablosuna yazılmaktadır.

    Tabii sembolün değeri ve uzunluğu ancak sembol o modülde tanımlanmış ise anlamlıdır. Örneğin prototipi belirtilmiş olan bir 
    fonksiyonu çağıralım (örneğimizdeki bar fonksiyonu). Ancak bu fonksiyon kendi modülümüzde tanımlanmış olmasın. Bu durumda
    bar sembolü için değer ve uzunluk anlamlı değildir. Burada 0 değerleri bulunur.

    Yukarıda örnek olarak verdiğimiz C programındaki g_c sembolünün sembol tablosundaki görünümüne dikkat ediniz.

    7: 0000000000000004     4 OBJECT  GLOBAL DEFAULT    3 g_c

    Buradan şu anlam çıkmaktadır: Sembol bir "data" sembolüdür. Amaç dosyanın 3 numaralı indeksteki bölümünde (".data" bölümü) yer
    kaplamaktadır. Sembol bu bölümün 4'üncü offset'inden itibaren 4 byte uzunluktadır. Sembol global bir değişkendir başka bir 
    modülden extern yapılırsa kullanılabilir. g_c sembolünün C programında aşağıdaki gibi bir tanımlamayla yaratılmış olduğuna 
    dikkat ediniz:

    int g_c = 30;

    İşte ".data" bölümünün 4 numaralı offset'inden başlayan 4 byte'lık "little endian" sayı 30 olacaktır. Şimdi de g_d static 
    global değişkeninin sembol tablosundaki görünümüne bakalım:

    3: 0000000000000008     4 OBJECT  LOCAL  DEFAULT    3 g_d

    Buradan şu sonuç çıkmaktadır: Burada bir "data" sembolü söz konusudur. Yine sembol amaç dosyanın ".data" bölümünde ve ".data" 
    bölümünün 8'inci offset'inden itibaren 4 byte yer kaplamaktadır. Ancak bu sembol "local" bir semboldür. Yani yalnızca
    bu modülden kullanılabilir. Başka bir modülden extern bildirimi yapılsa bile linker bu sembolün kullanılmasını engelleyecektir. 
    Bu sembolün aşağıdaki bir tanımlamayşa oluşturulduğuna dikkat ediniz:

    static int g_d = 40;

    Şimdi de g_a sembolü için sembol tablosundaki bilgilere bakalım:

    5: 0000000000000000 0xf4240 OBJECT  GLOBAL DEFAULT    4 g_a

    Buradan g_a'nın bir "data" sembolü olduğunu, onun 4 numaralı bölümde bulunduğunu (".bss bölümü"), dışarıdan kullanılabileceğini
    ve 1000000 byte (0xf4240) yer kapladığını anlamaktayız. Bu sembol derleyici tarafından aşağıdaki tanımlama sonucunda 
    oluşturulmuştur:

    char g_a[100000];

    C'de ilkdeğer verilmemiş global değişkenlerin içerisinde 0 olduğunu biliyoruz. Pekiyi bu sembol için amaç dosyanın ".bss" 
    bölümünde yer fiziksel olarak ayrılmış mıdır? Buradaki 1000000 byte'ın hepsi 0 olduğuna göre bunun amaç dosyada ve çalıştırılabilen 
    dosyada yer ayrılması gereksizdir. ".bss" bölümünün Bölüm Başlık Tablosundaki bilgilerine dikkat ediniz:

    [ 4] .bss              NOBITS           0000000000000000  00000080
        00000000000f4240  0000000000000000  WA       0     0     32

    Burada bu bölümün 1000000 byte yer kapladığı belirtilmiştir. Ancak bölüm türü olarak SHT_NOBITS kullanılmıştır. Bu bölüm 
    türü bu bölümün amaç dosyada (ya da çalıştırılabilir dosyada) yer kaplamayacağı anlamına gelmektedir. O halde biz g_a 
    sembolünden şunu anlamlıyız: Bu sembol 1000000 byte'lık bir alan bleirtiyorsa da içi 0 olduğu için gereksiz bir biçimde 
    amaç dosyada bunun için yer ayrılmamıştır. O halde C'de ilkdeğer verilmemiş global nesnelerin sıfırlanması amaç dosya ya da 
    çalıştırılabilir dosya içerisinde derleyici ya da bağlayıcı tarafından değil onu belleğe yükleyen yükleyici tarafından 
    yapılmaktadır.

    Pekiyi aşağıdaki gibi bir tanımlama yapılsaydı derleyici bu sembolü amaç dosyanın ".bss" bölümüne mi ".data" bölümüne mi
    yerleştirirdi?

    char g_a[100000] = {1};

    Burada C kurallarına göre bu dizinin ilk elemanı 1 diğer tüm elemanları 0 olmalıdır. Eğer derleyici bu sembolü ".bss" 
    bölümüne yerleştirse bu bölüm yükleyici tarafından sıfırlanacağı için 1 değeri kaybolacaktır. Eğer derleyici bu sembolü 
    ".data" bölümüne yerleştirse amaç dosyada 999999 tane 0 olan byte bulunacaktır. Aslında burada ne olacağını dosyaysı derleyip 
    amaç dosyanın uzunluğuna bakarak hemen anlayabilirsiniz. UNIX/Linux sistemlerinde derleyiciler tipik olarak böylesi bir 
    durumda ellerinden bir şey gelmediği için sembolü ".data" bölümüne yerleştirip amaç dosyayı mecburen büyütmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												15. Ders 02/05/2024 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Derleyicilerin "amaç dosya (object file)" oluşturduğunu bu amaç dosyaların linker tarafından birleştirilerek çalıştırılabilir
    bir dosya haline getirildiğini anımsayınız. Pekiyi derleyici üreteceği makine kodlarındaki nesne ve fonksiyon adreslerini nasıl 
    belirlemektedir? Çünkü derleme aşamasında henüz amaç dosyalar birleştirilmemiş ve program belleğe yüklenmemiştir. Örneğin 
    aşağıdaki gibi "a.c" ve "b.c" programları bulunuyor olsun:

    // a.c

    #include <stdio.h>

    void foo(void);
    int g_a;

    int main(void)
    {
        g_a = 10;
        foo();

        return 0;
    }

    // b.c

    extern int g_a;

    void foo(void)
    {
        printf("%d\n", g_a);
    }

    Derleyicimizin 32 bit Intel kodu üreteceğini varsayalım. Şimdi "a.c" dosyasındaki foo çağrımına dikkat ediniz:

    foo();

    Derleyici bu çağrı için Intel işlemcilerinde CALL makine komutu üretecektir. CALL makine komutunun operand'ı call edilecek
    fonksiyonun bellekteki başlangıç adresini almaktadır. Yani CALL makine komutu aşağıdaki gibi bir komuttur:

    CALL <adres>

    Ancak derleyici derleme sırasında foo fonksiyonunun adresini bilmemektedir. Çünkü foo fonksiyonu "b.c" dosyasında tanımlanmıştır. 
    Bu durumda derleyici CALL makine komutunun operand'ına hangi adresi yazacaktır? İşte henüz bilinmeyen bellek adreslerinin sonraki 
    aşamada başka bir program tarafından düzeltilmesine "relocation işlemi", henüz bilinmeyen adreslere de (foo için üretilen CALL 
    makine komutunda olduğu gibi) "relocatable adresler" denilmektedir. Derleyiciler bu tür durumlarda henüz bilmedikleri adresleri 
    boş bırakırlar (tipik olarak o adresler yerine 0 yerleştirirler).

    Pekiyi derleyiciler tarafından oluşturulan bu relocatable adresleri kim ve nasıl düzeltmektedir? İşte bugünkü modern ve gelişmiş 
    işlemcilerin kullanıldığı sistemlerde ileride de açıklanacağı gibi program belli bir adresten itibaren sanal belleğe yüklenecekmiş 
    gibi kod üretilmektedir. Yani link aşamasından geçmiş olan bir program eğer öngörülen adresten itibaren yüklenirse (bu konuda 
    ayrıntılar vardır) sorunsuz çalışabilmektedir. (Tabii şimdi programın belli bir adresten itibaren yükleneceğinin garantisinin nasıl 
    verilebildiğini merak edebilirsiniz. Bu budurm bazı konular ele alındıktan sonra anlaşılacaktır.) Ancak şimdilik biz çalıştırılabilen 
    programların belli bir adresten itibaren yüklenecek biçimde oluşturulduğunu varsayalım. Derleyici programın hangi adresten itibaren 
    belleğe yükleneceğini bilse bile yukarıdaki CALL komutunun adres operandın'ı derleme aşamasında oluşturamaz. Çünkü linker başka 
    modüllerdeki kod ve verileri de çalıştırılabilen dosyaya yazmaktadır. Bu yüzden derleyici yukarıdaki foo çağrısında CALL makine 
    komutundaki adresi boş bırakmaktadır.

    Pekiyi bu CALL makine komutundaki adresi kim doğru biçimde tespit edebilir? İşte linker farklı amaç dosyaların bölümlerini 
    çalıştırılabilir dosyada bir araya getirmektedir. Linker eğer programın nereye yükleneceğini biliyorsa buradaki adresi düzeltebilir. 
    Çünkü linker link işlemi sırasında zaten bu foo fonksiyonunu diğer amaç dosyalarda arayacak, foo fonksiyonunun o amaç dosyanın 
    hangi bölümünde ve o bölümün kaçıncı offset'inde olduğunu tespit edebilecektir. Çalıştırılabilir dosyanın nereye yükleneceği de belli 
    olduğuna göre linker artık foo fonksiyonunun program çalışırkenki gerçek bellek adresini hesaplayabilecektir. Yani eğer linker 
    programın sanal belleğe hangi adresten itibaren yükleneceğini biliyorsa CALL komutundaki adresi doğru bir biçimde düzeltebilecektir.
    Burada ELF formatında "Program Başlık Tablosu (Program Header Table)" denilen tablo ile ilgili bazı ayrıntılar vardır. Ancak biz 
    burada kabaca linker'ın foo çağrısı için oluşturulan CALL makine komutundaki adresi nasıl düzelettiğini aşama aşama anlatalım:

    1) ELF formatında amaç dosyada nerelerin düzeltileceğini belirten "relocation tablosu" denilen bir tablo bulunmaktadır. Linker 
    "a.o" dosyasının "relocation tablosunu" incelediğinde orada "foo" isimli bir fonksiyonun yerinin tespit edilmesi gerektiğini 
    ve bu tespit yapıldıktan sonra da "a.o" içerisinde nerenin değiştirilmesi gerektiğini anlamaktadır. (Başka bir deyişle linker "
    a.o" dosyasındaki relocation tablosundan "hangi sembolün nihai adresinin nereye yazılması gerektiğini" anlamaktadır.) Yani adeta 
    "a.o" dosyasının relocation tablosu foo çağrımı için linker'a şunları söylemektedir: "Git diğer modüllerde "foo" isimli fonksiyonu 
    bul, birleştirme sonucunda onun nihai adresini tespit et ve kodun şu kısmını düzelt".

    2) Linker "a.o" dosyasının relocation tablosunda belirtilen "foo" fonksiyonunu diğer modüllerin sembol tablolarında arar. Bizim 
    örneğimizde bu sembol "b.o" dosyasının sembol tablosunda bulunacaktır. (Sembol tablosunda ilgili sembolün hangi bölümün (section) 
    kaçıncı offset'inde olduğu belirtiliyordu.) Linker "a.o" ve "b.o" dosyalarının bölümlerini çalıştırılabilir dosyada birleştirdiğinde 
    artık foo fonksiyonunun hangi adreste olduğunu da tespit edebilmektedir. Linker'lar eğer aranan sembol birden fazla amaç dosyada 
    bulunursa bu durumda error oluşturmaktadır. Tabii aranan sembol hiçbir amaç dosyada bulunamazsa yine error oluşturmaktadır.

    Yukarıdaki örnekte "a.c" dosyası içerisinde main fonksiyonunda g_a global değişkeni aşağıdaki gibi kullanılmıştır:

    g_a = 10;

    Bu ifadenin kodunun derleyici tarafından üretilebilmesi için yine g_a global değişkeninin adresinin biliniyor olması gerekmektedir. 
    Örneğin Intel işlemcilerinde bu işlem aşağıdaki gibi bir makine koduyla yapılabilmektedir:

    mov [<g_a'nın adresi>], 10

    Pekiyi derleyici g_a global değişkeninin adresini derleme sırasında bilmekte midir? Burada her ne kadar g_a aynı modülde tanımlanmış 
    olsa da derleyici yine bu nesnenin bellek adresini derleme zamanında tespit edemeyecektir. Çünkü linker'ın diğer modüllerle birleştirme 
    yapması sonucunda bu global nesnenin adresi değişmiş olacaktır. O halde buradaki g_a nesnesinin adresi de "relocatable" bir adrestir. 
    Bu adres de derleyici tarafından boş bırakılır ve relocation tablosunda belirtilir. Linker bu adresin de nihai değerini tespit edip 
    kodda ilgili yeri düzeltir.

    Pekiyi yerel nesnelerin adresleri de relocatable adresler midir? Hayır yerel nesnelerin yerleri o fonksiyonda stack göstericisine 
    (stack pointer) göreli uzaklıkla tespit edilebilmektedir. Yani yerel nesnelerin adresleri derleme sırasında derleyici tarafından 
    gçreli bir biçimde tespit edilebilmektedir.

    Pekiyi çalıştırılabilir bir dosya bellekte eğer yüklenmesi gereken yere yüklenemezse, başka yere yüklenirse ne olur? Linker
    nihai adresleri çalıştırılabilir dosyanın belli bir adresten itibaren yükleneceği fikriyle oluşturmaktadır. Eğer dosya bellekte 
    başka bir yere yüklenirse program düzgün çalışmayacaktır.

    Relocation işlemi aslında yalnızca linker tarafından değil yükleyici tarafından da yapılabilmektedir. İşte bazı sistemlerde 
    çalıştırılabilir programlar için de relocation tabloları oluşturulabilmektedir. Böylece yükleyici programı başka bir adresten 
    itibaren yüklerse bu relocation tablosundan hareketle dosya içerisindeki adresleri de düzeltebilmektedir. Yani amaç dosya 
    içerisindeki relocation tablosu "linker" için, çalıştırılabilir dosyadaki relocation tablosu "yükleyici" için düzeltme bilgilerini
    bulundurmaktadır. Yukarıda da belirttiğimiz gibi genellikle çalıştırılabilir dosyaların sanal belleğin neresine yükleneceği 
    bilinmektedir. Ancak dinamik kütüphanelerin belleğin neresine yükleneceği önceden belirlenememektedir. Linker için relocation 
    tablosunun derleyici tarafından, yükleyici için relocation tablosunun ise linker tarafından oluşturulduğuna dikkat ediniz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtildiği gibi yerel nesnelerin (yani fonksiyonlar içerisinde tanımlanmış nesnelerin) relocation işlemi ile 
    bir ilgisi yoktur. Yerel nesnelerin yerleri ismine "Stack Pointer (SP)" denilen bir yazmaca göreli bir biçimde tespit 
    edilmektedir. Stack oldukça zekice düşünülmüş çok pratik bir kullanıma sahip bir kavramdır. Aşağıdaki gibi bir C fonksiyonu 
    olsun:

    void foo(void)
    {
        int a = 10;
        int b = 20;
        int c;

        c = a + b;
        ...
    }

    Derleyici fonksiyonun başında makine komutuyla SP yazmacını fonksiyonun yerel değişkenlerinin toplam uzunluğu kadar yukarı çeker 
    (yani azaltır):

    Yeni SP'nin gösterdiği yer  ----->
    ....
    Eski SP'in gösterdiği yer   ----->

    Sonra yerel nesneleri SP'nin bulunduğu yere göreli bir biçimde konumlandırır:

    Yeni SP'nin gösterdiği yer  ----->
                                            a
                                            b
                                            c
    Eski SP'in gösterdiği yer   ----->

    Artık makine kodlarını SP'nin bulunduğu yere göreli bir biçimde oluşturmaktadır. Örneğin 32 bit Intel işlemcileri için aşağıda
    sembolik bir kod örneği verilmiştir:

    SUB     ESP, 12
    MOV     [ESP + 0], 10           ; a = 10
    MOV     [ESP + 4], 20           ; b = 20
    MOV     EAX, [ESP + 0]          ; a değeri EAX yazmacına yükledi
    ADD     EAX, [ESP + 4]          ; a ile b'yi topladı, sonuç EAX yazmacında
    MOV     [ESP + 8], EAX          ; toplam c'ye atanıyor
    ...
    ADD     ESP, 12                 ; ESP'yi eski değerine çekiyor

    Burada dikkat edilecek bir nokta yerel nesnelerin adreslerinin yalnızca o fonksiyon tarafından bilinebileceğidir. Bu nedenle
    yerel nesneler yalnızca o fonksiyon içerisinde kullanılabilmektedir. Global değişkenlerin adresleri bir yazmaca göreli değil, 
    mutlak olarak belirlendiği için onlar her fonksiyondan kullanılabilmektedir.

    Ayrıca buradan yerel nesnelerin içerisinde neden çöp değer olduğu da anlaşılmaktadır. SP yazmacı sürekli yukarı aşağı gittiği için 
    Stack'teki değerler de çöp değerler haline gelmektedir. Yerel nesneler SP yazmacının yukarı çekilmesiyle bir hamlede yaratılmaktadır. 
    Oradaki değerler de daha önceki rastgele stack değerlerinden oluşmaktadır. Derleyicinin yerel nesneleri sıfırlaması da uygun 
    değildir. Çünkü bu sıfırlama işlemi ancak makine komutlarıyla yapılabilir. Bu da programı yavaşlatacaktır. Oysa global nesnelerin 
    sıfırlanması program çalışırken değil yüklenirken yalnızca bir kez yapılmaktadır.

    Yerel nesnelerin çok hızlı yaratrılıp (tek bir makine komutuyla), çok hızlı yok edildiğine (tek bir makine komutuyla) de dikkat
    ediniz. C'de yerel değişkenlere "otomatik değişkenler" de denilmektedir.

    Pekiyi iç içe çok fazla fonksiyon çağrılırsa ne olur? İşte bu durumda her fonksiyon SP yazmacını bir miktar yukarı çekeceğine 
    göre ve stack için belli bir alan ayrıldığına göre stack yukarıdan taşabilmektedir. Bu yukarıdan taşmaya İngilizce "stack 
    overflow" da denilmektedir. Bu tür durumlarda muhtemelen program çökecektir. Windows sistemlerinde thread'lerin default stack 
    büyüklüğü 1 MB, Linux sistemlerinde ise 8 MB kadardır. Bu stack miktarları küçük değildir. Ancak programcı büyük dizileri 
    yerel dizi olarak yaratırken dikkat etmelidir. Büyük dizilerin yerel olarak yaratılması stack'i taşırabilir. Bunların static 
    yerel ya da global tanımlanması uygundur. Stack alanı ".data" ve ".bss" alanlarına göre çok küçük bir alandır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ELF formatının relocation tablosu SHT_REL ya da SHT_RELA bölüm türüyle belirtilen bölümler içerisinde bulunmaktadır. Tipik 
    olarak derleyiciler relocation işlemi hangi bölüm ile ilgiliyse relocation bilgilerini ".rel<isim>" ya da ".rela<isim>" 
    ismindeki bölümlere yerleştirmektedir. Örneğin yukarıdaki "a.c" dosyası derlendiğinde relocation tablosu da ".rela.text" 
    isimli bölümde bulunacaktır. 32 bit ELF formatında relocation bölümlerinin içerisindeki her relocation bilgisi aşağıdaki 
    yapılar ile temsil edilmektedir:

    typedef struct {
        Elf32_Addr r_offset;            /* Address of reference */
        Elf32_Word r_info;              /* Symbol index and type of relocation */
    } Elf32_Rel;

    typedef struct {
        Elf32_Addr r_offset;            /* Address of reference */
        Elf32_Word r_info;              /* Symbol index and type of relocation */
        Elf32_Sword r_addend;           /* Constant part of expression */
    } Elf32_Rela;

    64 bit ELF formatında da bu yapılar şöyledir:

    typedef struct {
        Elf64_Addr r_offset;            /* Address of reference */
        Elf64_Xword r_info;             /* Symbol index and type of relocation */
    } Elf64_Rel;

    typedef struct {
        Elf64_Addr r_offset;            /* Address of reference */
        Elf64_Xword r_info;             /* Symbol index and type of relocation */
        Elf64_Sxword r_addend;          /* Constant part of expression */
    } Elf64_Rela;

    SHT_REL bölüm türüyle belirtilen bölümün yapısı ile SHT_RELA bölüm türüyle belirtilen bölümün yapısının birbirinden farklı
    olduğuna dikkat ediniz. Bu yapılardaki r_offset elemanı linker'ın ya da yükleyicinin düzelteceği yeri belirtmektedir. 
    Burada relocation uygulanacak yer hangi bölümdeyse o bölümün başından itibaren bir offset bilgisi ya da sanal bellek adresi
    tutulmaktadır. Böylece linker ya da yükleyici dosyanın neresini düzelteceğini anlamaktadır. Yapıların r_info elemanları 
    kendi içerisinde iki parçaya ayrılmaktadır. Bu elemanın yüksek anlamlı 4 byte'ı düzeltilecek yere ilişkin sembolün sembol 
    tablosundaki indeksini (byte offset'ini değil sembolün indeksini), düşük anlamlı 4 byte ise düzeltme türünü (relocation type) 
    belirtmektedir. Düzeltme türü platforma göre farklılıklar gösterebilmektedir. Yapılardaki r_addend elemanı ayrıntı içermektedir. 
    Burada ele almayacağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												16. Ders 07/05/2024 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ELF formatının diğer önemli bir bölümü de "Program Başlık Tablosu (Program Header Table)" denilen bölümüdür. Program Başlık 
    Tablosu eşit uzunlukta Program Başlıklarından (Program Header Table Entry) oluşmaktadır. Program Başlık Tablosunun ELF 
    dosyasında nereden başladığı ve hangi uzunlukta olduğu ELF Başlığında belirtilmektedir. Program Başlık Tablosu amaç dosyalarda 
    değil "çalıştırılabilen dosyalarda ve dinamik kütüphane dosyalarında" bulunmaktadır. İşletim sistemi çalıştırılabilen dosyayı
    ya da dinamki kütüphane dosyasını bölüm bölüm değil segment segment yüklemektedir. Bir segment aynı özelliğe sahip peşi sıra
    giden bölümlerden oluşmaktadır. Program Başlık Tabosundaki ger Program Başlığı bir segment hakkında bilgi vermektedir. 
    Şimdi aklınıza bölümler varken nedne segment'lere gereksinim duyulmuştur sorusu gelebilir? Bölümler daha çok linker için 
    segment'ler ise yükleyici için düşünülmüştür. Dosyada benzer özelliklere sahip bölümler segment ismiyle bir araya getirilmektedir. 
    Böylece işletim sistemi (exec fonksiyonları) bu segment'leri yüklemektedir.

    Program Başlık Tablosundaki Program Başlıklarının 32 bit ELF formatındaki yapısal biçimi şöyledir:

    typedef struct {
        Elf32_Word p_type;          /* Type of segment */
        Elf32_Off p_offset;         /* Offset in file */
        Elf32_Addr p_vaddr;          /* Virtual address in memory */
        Elf32_Addr p_paddr;         /* Reserved */
        Elf32_Word p_filesz;        /* Size of segment in file */
        Elf32_Word p_memsz;         /* Size of segment in memory */
        Elf32_Word p_flags;         /* Segment attributes */
        Elf32_Word p_align;         /* Alignment of segment */
    } Elf32_Phdr;

    typedef struct {
        Elf64_Word p_type;          /* Type of segment */
        Elf64_Word p_flags;         /* Segment attributes */
        Elf64_Off p_offset;         /* Offset in file */
        Elf64_Addr p_vaddr;         /* Virtual address in memory */
        Elf64_Addr p_paddr;         /* Reserved */
        Elf64_Xword p_filesz;       /* Size of segment in file */
        Elf64_Xword p_memsz;        /* Size of segment in memory */
        Elf64_Xword p_align;        /* Alignment of segment */
    } Elf64_Phdr;

    Program Başlığında şu bilgiler yer almaktadır:

    - Başlığn Türü: Burada PT_LOAD ilgili segment'in belleğe yüklenmesi gerektiği anlamına gelmektedir. Her ne kadar yukarıda 
    Program Başlık Tablosunun belle yüklenecek segment'leri belirttiğini söylemiş olsak da belleğe yüklenmeyen ancak ilgili 
    dosyanın yüklenmesinde kullanılacak bazı bilgiler de Program Başlık Tablosunda birer segment olarak bulunmaktadır. 
    Yüklenecek olan segment'lerin türü PT_LOAD biçiminde belirtilmektedir.

    - Segment'in Koruma Bayrakları: İleride ele alınacağı gibi Sayfalama (paging) mekanizmasına sahip olan işlemcilerde RAM 
    sayfalardan (pages) oluşmaktadır. Sayfalara koruma bayrakları iliştirilebilmektedir. Örneğin bir ayfanın koruma bayrağı 
    "Read Only" ise işlemci bu sayfaya yazma yapamaz. Eğer işlemci böyle bir sayfaya yazma yapmaya çalışırse içsel bir kesme 
    oluşur (page fault) ve program çöker. Bir sayfada bir kodun çalıştırılabilmesi için sayfa koruma bayraklarının "Executable"
    olması gerekir. Aksi takdirde o sayfadaki bir fonksiyonu CALL makine komutlarıyla çağıramayız. Pek çok işlemcide sayfanın 
    "Write" özelliğine sahip olması aynı zamanda "Read" özelliğine de sahip olması anlamına gelmektedir. Ancak linker programları
    bunları ayrı ayrı belirtmektedir.

    - Segment'in ELF Dosyasındaki Başlangıç Offset'i ve Uzunluğu: Yükleyicinin segment'i belleğe yükleyebilmesi için dosyanın 
    nereseinden başladığını ve hangi uzunlukta olduğunu bilmesi gerekir.

    - Segment'in Bellekteki Uzunluğu: İlkdeğer verilmemiş global değişkenler ELF dosyalarının içerisinde yer kaplamamaktadır. 
    Ancak bunlar için de bellekte yer ayrılmalıdır. O halde bir segment belleğe yüklenirken bellekte ne kadar yer tahsis edileceği
    de bilinmelidir. Tabii linker ilkdeğer verilmemiş global değişkenlerin bulunduğu bölümleri (tipik olarak .bss) segment'in 
    sonuna almaktadır. Böylece yükleyici dosyada belirtilen uzunluktaki kısmı bellekte tahsis ettiği alanın başından itibaren y
    ükleyebilir.

    Segment'in Sanal Belleğe Yükleme Adresi: Linker programın belli bir adresten itibaren yükleneceği varsayımyla kodu düzeltmektedir.
    İşte her segment'in sanal belleğin neresindne itibaren yükleneceği Program Başlığında belirtilmektedir. Ancak segment yükleyici 
    tarafından bu adrese yüklenmeyebilir. Bu durumda yükleyici "relocation" işlemi uygulayacaktır. Yani linker modüllerdeki kodu
    belli bir adresten itibaren yüklenecekmiş gibi oluşturmaktadır. Ancak yükleyici eğer onu başka bir yere ykleyecekse "relocation"
    işlemi uygulamak zorundadır.

    Çalışmakta olan programın sanal bellek alanına map edilen segment'ler proc dosya sisteminden /proc/<proses_is>/maps 
    dosyasının içerisinden görülebilir.

    readelf programında ELF dosyasının Program Başlık Tablosu "-l" seçeneği ile objdump programı ile de "-p" ya da "--program-headers" 
    seçeneği ile 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz basit bir yükleyici program yazmak istesek bunu nasıl yazabiliriz? Aslında yükleyiciler burada henüz ele almadığımız
    bazı ayrıntılı işlemleri de yapmaktadır. Ancak kabaca bunu gerçekleştirebilmek için ELF dosya formatını parse edip Program 
    Başlık Tablosundaki PT_LOAD ile belirtilen segment'leri belirtilen sanal bellek adresine mmap fonksiyonu yüklenmesi gerekir.
    Tabii yükleme işlemi bittikten sonra programın ELF dosyasının başlık kısmında belirtilen "entry point"den başlatılması gerekir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ELF formatının diğer önemli bir bölümü de ".dynamic" isimli bölümüdür Bu bölüm ".dynsym" bölümüyle birlikte kullanılmaktadır. 
    Bu bölümün işlevini anlayabilmek için dinamik kütüphanelerin nasıl yüklendiğinin bilinmesi gerekir. Biz önce statik ve 
    dinamik kütüphaneleri ele alıp ondan sonra ELF formatının bu bölümlerini açıklayacağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kütüphane "hazır kodların bulunduğu topluluklar" için kullanılan bir terimdir. Ancak aşağı seviyeli dünyada kütüphane 
    kavramı daha farklı bir biçimde kullanılmaktadır. Aşağı seviyeli dünyada "içerisinde derlenmiş bir biçimde fonksiyonların 
    bulunduğu dosyalara kütüphane (library)" denilmektedir. Aslında kütüphaneler yalnızca fonksiyon değil, global nesneler 
    de içerebilmektedir.

    Kütüphaneler "statik" ve "dinamik" olmak üzere ikiye ayrılmaktadır. Statik kütüphane dosyalarının uzantıları UNIX/Linux 
    sistemlerinde ".a (archive)" biçiminde, Windows sistemlerinde ".lib (library)" biçimindedir. Dinamik kütüphane dosyalarının 
    uzantıları ise UNIX/Linux sistemlerinde ".so (shared object), Windows sistemlerinde ".dll (dynamic link library)" biçimindedir. 
    UNIX/Linux dünyasında kütüphane dosyaları geleneksel olarak başında "lib" öneki olacak biçimde isimlendirilmektedir. (Örneğin 
    "x" isimli bir statik kütüphane dosyası UNIX/Linux sistemlerinde genellikle "libx.a" biçiminde, "x" isimli bir dinamik kütüphane 
    dosyası ise UNIX/Linux sistemlerinde genellikle "libx.so" biçiminde isimlendirilmektedir.)
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Statik kütüphaneler aslında "object modülleri (yani .o dosyalarını)" tutan birer kap gibidir. Yani statik kütüphaneler object
    modüllerden oluşmaktadır. Statik kütüphanelere link aşamasında linker tarafından bakılır. Bir program statik kütüphane dosyasından 
    bir çağırma yaptıysa (ya da o kütüphaneden bir global değişkeni kullandıysa) linker o statik kütüphane içerisinde ilgili 
    fonksiyonun bulunduğu object modülü link aşamasında statik kütüphane dosyasından çekerek çalıştırılabilir dosyaya yazar. 
    (Yani statik kütüphaneden bir tek fonksiyon çağırsak bile aslında o fonksiyonun bulunduğu object modülün tamamı çalıştırılabilen 
    dosyaya yazılmaktadır.) Statik kütüphaneleri kullanan programlar artık o statik kütüphaneler olmadan çalıştırılabilirler.

    Statik kütüphane kullanımının şu dezavantajları vardır:

    1) Kütüphaneyi kullanan farklı programlar aynı fonksiyonun (onun bulunduğu object modülün) bir kopyasını çalıştırılabilir dosya 
    içerisinde bulundururlar. Yani örneğin printf fonksiyonu statik kütüphanede ise her printf kullanan C programı aslında printf 
    fonksiyonunun bir kopyasını da barındırıyor durumda olur. Bu da programların diskte fazla yer kaplamasına yol açacaktır.

    2) Aynı statik kütüphaneyi kullanan programlar belleğe yüklenirken işletim sistemi aynı kütüphane kodlarınını yeniden fiziksel 
    belleğe yükleyecektir. İşletim sistemi bu kodların ortak olarak kullanıldığını anlayamamaktadır.

    3) Statik kütüphanede bir değişiklik yapıldığında onu kullanan programların yeniden link edilmesi gerekir.

    Statik kütüphane kullanımının şu avantajları vardır:

    1) Kolay konuşlandırılabilirler. Statik kütüphane kullanan bir programın yüklenmesi için başka dosyalara gereksinim 
    duyulmamaktadır.

    2) Statik kütüphanelerin kullanımları kolaydır, statik kütüphane kullanan programlar için daha kolay build ya da make işlemi 
    yapılabilmektedir.

    3) Statik kütüphane kullanan programların yüklenmesi dinamik kütüphane kullanan programların yüklenmesinden çoğu kez daha hızlı
    yapılmaktadır. Ancak bu durum çeşitli koşullara göre tam ters bir hale de gelebilmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde statik kütüphane dosyaları üzerinde işlemler "ar" isimli utility program yoluyla yapılmaktadır. 
    ar programına önce bir seçenek, sonra statik kütüphane dosyasının ismi, sonra da bir ya da birden fazla object modül ismi komut
    satırı argümanı olarak verilir. Örneğin:

    $ ar r libmyutil.a x.o y.o

    Burada r seçeneği belirtmektedir. ar eski bir komut olduğu için burada seçenekler '-' ile başlatılarak verilmemektedir. Komuttaki
    "libmyutil.a" işlemden etkilenecek statik kütüphane dosyasını "x.o" ve "y.o" argümanları ise object modülleri belirtmektedir. 
    Tipik ar seçenekleri ve yaptıkları işler şunlardır:

    r (replace) seçeneği (yanında "-" olmadığına dikkat ediniz) ilgili object modüllerin kütüphaneye yerleştirilmesini sağlar. 
    Eğer kütüphane dosyası yoksa komut aynı zamanda onu yaratmaktadır. Örneğin:

    ar r libmyutil.a x.o y.o

    Burada "libmyutil.a" statik kütüphane dosyasına "x.o" ve "y.o" object modülleri yerleştirilmiştir. Eğer "libmyutil.a" dosyası
    yoksa aynı zamanda bu dosya yaratılacaktır.

    t seçeneği kütüphane içerisindeki object modüllerin listesini almakta kullanılır. Örneğin:

    $ ar t libsample.a

    d (delete) seçeneği kütüphaneden bir object modülü silmekte kullanılır. Örneğin:

    ar d libmyutil.a x.o

    x (extract) seçeneği kütüphane içerisindeki object modülü bir dosya biçiminde diske save etmekte kullanılır. Ancak bu object 
    modül kütüphane dosyasından silinmeyecektir. Örneğin:

    $ ar x libmyutil.a x.o

    m (modify) seçeneği de bir object modülün yeni versiyonunu eski versiyonla değiştirmekte kullanılır.

    O halde "x.c" ve "y.c" dosyalarının içerisindeki fonksiyonları statik kütüphane dosyasına eklemek için sırasıyla şunlar
    yapılmalıdır:

    $ gcc -c x.c
    $ gcc -c y.c
    $ ar r libmyutil.a x.o y.o
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Statik kütüphane kullanan programları derlerken statik kütüphane dosyaları komut satırında belirtilebilir. Bu durumda gcc 
    ve clang derleyicileri o dosyayı bağlama (link) işleminde kullanmaktadır. Örneğin:

    $ gcc -o app app.c libmyutil.a

    Burada "libmyutil.a" dosyasına C derleyicisi bakmamaktadır. gcc aslında bu dosyayı bağlayıcıya (linker) iletmektedir. Biz bu 
    işlemi iki adımda da yapabilirdik:

    gcc -c app.c
    gcc -o app app.o libmyutil.a

    Her ne kadar GNU'nun bağlayıcı programı aslında "ld" isimli programsa da genellikle programcılar bu ld bağlayıcısını doğrudan 
    değil yukarıdaki gibi gcc yoluyla kullanırlar. Çünkü ld bağlayıcısını kullanılırken "libc" kütüphanesinin start-up amaç dosyaların
    (start-up object modules) programcı tarafından ld bağlayıcısına verilmesi gerekmektedir. Bu da oldukça sıkıcı bir işlemdir. 
    Halbuki biz ld bağlayıcısını gcc yoluyla çalıştırdığımızda libc kütüphanesi ve bu start-up amaç dosyalar ld bağlayıcısına gcc 
    tarafından verilmektedir.

    gcc eskiden C derleyicisi anlamına geliyordu (GNU C Compiler). Ancak zamanla derleyicileri çalıştıran bir önyüz (frontend) 
    program haline getirildi ve ismi de "GNU Compiler Collection" biçiminde değiştirildi. Yani aslında uzunca bir süredir gcc 
    programı ile yalnızca C programlarını değil diğer programlama dillerinde yazılmıl olan programları da derleyebilmekteyiz. 

    Komut satırında kütüphane dosyalarının komut satırı argümanlarının sonunda belirtilmesi uygundur. Çünkü gcc programı kütüphane 
    dosyalarını yalnızca onlarınsolunda belirtilen dosyaların bağlanmasında kullanmaktdır. Örneğin:

    gcc -o app app1.o libmyutil.a app2.o

    Böylesi bir kullanımda "libmyutil.a" kütüphanesinin solunda yalnızca "app1.o" dosyası vardır. Dolayısıyla bağlayıcı yalnızca 
    bu modül için bu kütüphaneye bakacaktır, "app2.o" için bu kütüphaneye bakılmayacaktır.

    Şüphesiz statik kütüphane kullanmak yerine aslında amaç dosyaları da doğrudan bağlama işlemine sokabiliriz. Örneğin:

    gcc -o sample sample.c x.o y.o

    Ancak çok sayıda object modül söz konusu olduğunda bu işlemin zorlaşacağına dikkat ediniz. Yani amaç dosyalar (object modules) 
    dosyalara benzetilirse statik kütüphane dosyaları dizinler gibi düşünülebilir.

    Derleme işlemi sırasında kütüphane dosyası -l<isim> biçiminde de belirtilebilir. Bu durumda arama sırasında "lib" öneki 
    ve ".a" uzantısı aramaya dahil edilmektedir. Yani örneğin:

    gcc -o sample sample.c -lmyutil

    İşleminde aslında "libmyutil.a" (ya da "libmyutil.so") dosyaları aranmaktadır. Arama işlemi sırasıyla bazı dizinlerde yapılmaktadır. 
    Örneğin "/lib" dizini, "/usr/lib dizini", "/usr/local/lib" dizini gibi dizinlere bakılmaktadır. Ancak "bulunulan dizine (current 
    working directory)" bakılmamaktadır. -l seçeneği ile belli bir dizine de bakılması isteniyorsa "-L" seçeneği ile ilgili dizin 
    belirtilebilir. Örneğin:

    gcc -o sample sample.c -lmyutil -L.

    Buradaki '.' çalışma dizinini temsil etmektedir. Artık "libmyutil.a" kütüphanesi için bulunulan dizine de (current working 
    directory) bakılacaktır. Birden fazla dizin için -L seçeneğinin yinelenmesi gerekmektedir. Örneğin:

    gcc -o sample sample.c -lmyutil -L. -L/home/csd

    Geleneksel olarak "-l" ve "-L" seçeneklerinden sonra boşluk bırakılmamaktadır. Ancak boşluk bırakılmasında bir sakınca yoktur.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bir statik kütüphane başka bir statik kütüphaneye bağımlı olabilir. Örneğin biz "liby.a" kütüphanesindeki kodda "libx.a" 
    kütüphanesindeki fonksiyonları kullanmış olabiliriz. Bu durumda "liby.a" kütüphanesini kullanan program "libx.a" kütüphanesini
    de komut satırında belirtmek zorundadır. Örneğin:

    gcc -o sample sample.c libx.a liby.a
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												17. Ders 09/05/2024 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphane dosyalarının UNIX/Linux sistemlerinde uzantıları ".so" (shared object'ten kısaltma), Windows sistemlerinde 
    ise ".dll" (Dynamic Link Library) biçimindedir.

    Bir dinamik kütüphaneden bir fonksiyon çağrıldığında linker statik kütüphanede olduğu gibi gidip fonksiyonun kodunu (fonksiyonun 
    bulunduğu amaç dosyayı) çalıştırılabilen dosyaya yazmaz. Bunun yerine çalıştırılabilen dosyaya çağrılan fonksiyonun hangi 
    dinamik kütüphanede olduğu bilgisini yazar. Çalıştırılabilen dosyayı yükleyen işletim sistemi o dosyanın çalışması için 
    gerekli olan dinamik kütüphaneleri çalıştırılabilen dosyayla birlikte bütünsel olarak prosesin sanal bellek alanına yüklemektedir. 
    Böylece birtakım ayarlamalar yapıldıktan sonra artık çağrılan fonksiyon için gerçekten o anda sanal belleğe yüklü olan dinamik 
    kütüphane kodlarına gidilmektedir. Örneğin biz "app" programımızda "libmyutil.so" dinamik kütüphanesinden foo isimli fonksiyonu 
    çağırmış olalım. Bu foo fonksiyonunun kodları dinamik kütüphaneden alınıp "app" dosyasına yazılmayacaktır. Bu "app" dosyası 
    çalıştırıldığında işletim sistemi bu "app" dosyası ile birlikte "libmyutil.so" dosyasını da sanal belleğe yükleyecektir. Programın 
    akışı foo çağrısına geldiğinde akış "libmyutil.so" dosyası içerisindeki foo fonksiyonunun kodlarına aktarılacaktır. Dinamik kütüphane 
    dosyalarının bir kısmının değil hepsinin prosesin adres alanına yüklendiğine dikkat ediniz. (Tabii işletim sisteminin sanal bellek 
    mekanizması aslında yalnızca bazı sayfaları fiziksel belleğe yükleyebilecektir.)

    Dinamik kütüphane kullanımının avantajları şunlardır:

    1) Çalıştırılabilen dosyalar fonksiyon kodlarını içermezler. Dolayısıyla önemli bir disk alanı kazanılmış olur. Oysa statik 
    kütüphanelerde statik kütüphanelerden çağrılan fonksiyonlar çalıştırılabilen dosyalara yazılmaktadır.

    2) Dinamik kütüphaneler birden fazla proses tarafından fiziksel belleğe tekrar tekrar yüklenmeden kullanılabilmektedir.
    Yani işletim sistemi arka planda aslında aynı dinamik kütüphaneyi kullanan programlarda bu kütüphaneyi tekrar tekrar fiziksel 
    belleğe yüklememektedir. Bu da statik kütüphanelere göre önemli bir bellek kullanım avantaj oluşturmaktadır. Bu durumda eğer 
    dinamik kütüphanenin ilgili kısmı daha önce fiziksel belleğe yüklenmişse bu durum dinamik kütüphane kullanan programın daha hızlı 
    yüklemesine de yol açabilmektedir. Prog1 ve Prog2 biçiminde iki programın çalıştığını düşünelim. Bunlar aynı dinamik 
    kütüphaneyi kullanıyor olsun. İşletim sistemi bu dinamik kütüphaneyi bu proseslerin sanal bellek alanlarının farklı yerlerine 
    yükleyebilir. Ancak aslında işletim sistemi sayfa tablolarını kullanarak mümkün olduğunca bu iki dinamik kütüphaneyi aynı 
    fiziksel sayfaya eşlemeye çalışacaktır. Tabii bu durumda proseslerden biri dinamik kütüphane içerisindeki bir statik 
    nesneyi değiştirdiğinde artık "copy on write" mekanizması devreye girecek ve dinamik kütüphanenin o sayfasının yeni bir kopyası 
    oluşturulacaktır. Aslında bu durum fork fonksiyonu ile yeni bir prosesin yaratılması durumuna çok benzemektedir. Burada anlatılan 
    unsurların ayrıntıları "sayfalama ve sanal bellek" kullanımın açıklandığı paragraflarda ele alınacaktır.

    3) Dinamik kütüphaneleri kullanan programlar bu dinamik kütüphanelerdeki değişikliklerden etkilenmezler. Yani biz dinamik 
    kütüphanenin yeni bir versiyonunu oluşturduğumuzda bunu kullanan programları yeniden derlemek ya da bağlamak zorunda kalmayız. 
    Örneğin bir dinamik kütüphaneden foo fonksiyonunu çağırmış olalım. Bu foo fonksiyonunun kodları bizim çalıştırılabilir dosyamızın
    içerisinde değil de dinamik kütüphanede olduğuna göre dinamik kütüphanedeki foo fonksiyonu değiştirildiğinde bizim programımız 
    artık değişmiş olan foo fonksiyonunu çağıracaktır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphanelerin gerçekleştiriminde ve kullanımında önemli bir sorun vardır. Dinamik kütüphanelerin tam olarak sanal 
    belleğin neresine yükleneceği baştan belli değildir. Halbuki çalıştırılabilen dosyanın sanal belleğin neresine yükleneceği 
    baştan bilinebilmektedir. Yani çalıştırılabilen dosyanın tüm kodları aslında derleyici ve bağlayıcı tarafından zaten "onun 
    sanal bellekte yükleneceği yere göre" oluşturulmaktadır. Fakat dinamik kütüphanelerin birden fazlası prosesin sanal adres 
    alanına yüklenebildiğinden bunlar için yükleme adresinin önceden tespit edilmesi mümkün değildir. İşte bu sorunu giderebilmek 
    için işletim sistemlerinde değişik teknikler kullanılmaktadır. Windows sistemlerinde "import-export tablosu ve "load time 
    relocation" yöntemleri tercih edilmiştir. Bu sistemlerde dinamik kütüphane belli bir adrese yüklendiğinde işletim sistemi 
    o dinamik kütüphanenin "relocation" tablosuna bakarak gerekli makine komutlarını düzeltmektedir. Dinamik kütüphane fonksiyonlarının
    çağrımı için de "import tablosu" ve "export tablosu" denilen tablolar kullanılmaktadır. UNIX/Linux dünyasında dinamik kütüphanelerin 
    herhangi bir yere yüklenebilmesi ve minimal düzeyde relocation uygulanabilmesi için "Konumdan Bağımsız Kod (Position Independent 
    Code)" denilen teknik kullanılmaktadır. Konumdan bağımsız kod "nereye yüklenirse yüklenilsin çalışabilen kod" anlamına gelmektedir. 
    Konumdan bağımsız kod oluşturabilmek derleyicinin yapabileceği bir işlemdir. Konumdan bağımsız kod oluşturabilmek için gcc 
    ve clang derleyicilerinde derleme sırasında "-fPIC" seçeneğinin bulundurulması gerekmektedir. Biz kursumuzda konumdan bağımsız 
    kodun ayrıntıları üzerinde durmayacağız.

    Pekiyi Windows sistemlerinin kullandığı "relocation" tekniği ile UNIX/Linux sistemlerinde kullanılan "konumdan bağımsız
    kod tekniği" arasında performans bakımından ne farklılıklar vardır? İşte bu tekniklerin kendi aralarında bazı avantaj 
    ve dezavantajları bulunmaktadır. Windows'taki teknikte "relocation" işlemi bir zaman kaybı oluşturabilmektedir. Ancak 
    bir "relocation" işlemi yapıldığında kodlar daha hızlı çalışma eğilimindedir. Konumdan bağımsız kod tekniğinde ise
    "relocation" işlemine minimal düzeyde gereksinim duyulmaktadır. Ancak dinamik kütüphanelerdeki fonksiyonlar çağrılırken göreli 
    biçimde daha fazla zaman kaybedilmektedir. Aynı zamanda bu teknikte kodlar biraz daha fazla yer kaplamaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Pekiyi neden dinamik kütüphane dosyaları linker tarafından tıpkı çalıştırılabilir dosyalarda olduğu gibi sanal bellekte belli 
    bir yere yüklenenince sorunsuz çalışacak biçimde oluşturulmuyor? Çalıştırılabilir dosyalar sanal bellek boşken yüklendiğinden 
    onların belli bir yere yüklenmesinde bir sorun oluşmamaktadır. Ancak bir program çok fazla dinamik kütüphane kullanabileceğine 
    göre bu dinamik kütüphanelerin baştan yerinin belirlenmesi olanaksızdır.

    Pekiyi dinamik kütüphaneler içerisindeki global değişkenlerin ve fonksiyonların yükleme yerinden bağımsız bir biçimde dinamik 
    kütüphane içerisinden kullanılması nasıl sağlanabilir? Dinamik kütüphane içerisinde aşağıdaki gibi bir kod parçası bulunuyor 
    olsun:

    int g_a;
    ...

    g_a = 10;

    Burada derleyicinin yukarıdaki ifadeye ilişkin makine kodlarını üretebilmesi için g_a değişkenin tüm bellekteki adresini 
    (yani tepeden itibaren adresini) bilmesi gerekir. Bir nesnenin belleğin tepesinden itibarenki adresine "mutlak adres (absolute
    address) de denilmektedir. Örneğin Intel işlemcilerinde yukarıdaki ifade aşağıdaki gibi makine komutlarına dönüştürülmektedir:

    MOV  EAX, 10
    MOV  [g_a'nın mutlak adresi], EAX

    İşte sorun buradaki g_a değişkeninin mutlak adresinin program yüklenene kadar bilinmemesidir. Bu sorunu çözmenin de iki yolu 
    vardır:

    1) Derleyici ve linker g_a'nın mutlak adresinin bulunduğu yeri boş bırakır. Yükleyicinin bu yeri yükleme adresine göre 
    doldurmasını ister. İşte bu işlem yükleyicinin yaptığı "relocation" işlemidir. Bu tür relocation işlemlerine "load time 
    relocation" da denilmektedir. Windows sistemleri bu yöntemi kullanmaktadır.

    2) Derleyici makine komutunu o anda komutun yütürüldüğü yerin adresini barındıran ve ismine "Instruction Pointer" denilen 
    yazmaca dayalı olarak oluşturabilir. Çünkü linker komutun bulunduu yerden g_a'ya kadar kaç byte'lık bir açıklık olduğunu 
    bilmektedir. İşte buna "konumdan bağımsız kod (position independent code)" denilmektedir.

    Yukarıda da belirttiğimiz gibi birinci teknik (Windows sistemlerinin kullandığı teknik) relocation yapıldıktan sonra kodun
    hızlı çalışmasını sağlamaktadır. Ancak bu teknikte relocation zamanı yüklemeyi uzatabilmektedir. İkinci teknikte ise relocation
    minimal düzeyde tutulmaktadır. Ancak bu global değişkenlere erişim birkaç makine komutu ile daha yavaş yapılmaktadır. 
    UNIX/Linux sistemleri genel olarak bu tekniği kullanmaktadır. Ayrıca birinci teknikte kod üzerinde relocation uygulandığı 
    için mecburen "copy on write" mekanizaması devreye sokulmaktadır. Bu da fiziksel belleğin kullanım verimini düşürebilmektedir.

    Bu noktada ek olarak işlemcilerde bazı makine komutlarının (MOV, LOAD, STORE gibi) mutlak adres kullandığını ancak CALL ve 
    JMP gibi bazı makine komutlarının hem mutlak hem de göreli adres kullanabildiğini belirtelim. Aslında işlemcileri tasarlayanlar 
    relocation işlemi gerekmesin diye CALL ve JMP komutlarının göreli (relative) versiyonlarını da oluşturmuşlardır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde bir dinamik kütüphaneler şöyle oluşturulmaktadır:

    1) Önce dinamik kütüphaneye yerleştirilecek amaç dosyaların (object files) -fPIC seçeneği ile "Konumdan Bağımsız Kod (Position 
    Independent Code)" tekniği kullanılarak derlenmesi gerekir. (-fPIC seçeneğinde -f'ten sonra boşluk bırakılmamalıdır.)

    2) Bağlama işleminde "çalıştırılabilir (executable)" değil de "dinamik kütüphane" dosyasının oluşturulması için -shared seçeneğinin 
    kullanılması gerekir. "-shared" seçeneği kullanılmazsa bağlayıcı dinamik kütüphane değil, normal çalıştırılabilir dosya oluşturmaya
    çalışmaktadır. (Zaten bu durumda main fonksiyonu olmadığı için linker hata mesajı verecektir.) Örneğin:

    $ gcc -fPIC a.c b.c c.c
    $ gcc -shared -o libmyutil.so a.o b.o c.o

    Dinamik kütüphanelere daha sonra dosya eklenip çıkartılamaz. Onların her defasında yeniden bütünsel biçimde oluşturulmaları 
    gerekmektedir. Yukarıdaki işlem aslında tek hamlede de aşağıdaki gibi yapılabilmektedir:

    $ gcc -shared -o libmyutil.so -fPIC a.c b.c c.c
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz -fPIC seçeneğini kullanmadan yani "konumdan bağımsız kod" üretmeden dinamik kütüphane oluşturmaya çalışırsak
    ne olur? Mevcut GNU linker programları "-shared" seçeneği kullanıldığında global değişkenler için relocation işlemi söz konusu
    ise bir mesaj vererek link işlemini yapmamaktadır. Yani bu durumda mevcut GNU linker programları kodun "-fPIC" seçeneği ile
    derlenmesini zorunlu tutmaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda dinamik kütüphanelerin nasıl oluşturulduğunu gördük. Pekiyi dinamik kütüphaneler nasıl kullanılmaktadır?

    Dinamik kütüphane kullanan bir program bağlanırken kullanılan dinamik kütüphanenin komut satırında belirtilmesi gerekir. 
    Örneğin:

    gcc -o app app.c libmyutil.so

    Tabii bu işlem yine -l seçeneği ile de yapılabilirdi:

    gcc -o app app.c -lmyutil -L.

    Bu biçimde çalıştırılabilir dosya oluşturulduğunda linker bu çalıştırılabilir dosyanın çalıştırılabilmesi için hangi 
    dinamik kütüphanelerin yüklenmesi gerektiğini ELF formatının ".dynamic" isimli bölümüne yazmaktadır. Böylece yükleyici 
    bu programı yüklerken onun kullandığı dinamik kütüphaneleri de yükleyecektir. Ancak linker bu ".dynamic" bölümüne çalıştırılabilir
    dosyanın kullandığı dinamik kütüphanelerin yol ifadesini (yani tam olarak nerede olduğunu) yazmaz. Yalnızca isimlerini 
    yazmaktadır. İşte yükleyici (dinamik linler) bu nedenle dinamik kütüphaneleri önceden belirlenen bazı yerlerde aramaktadır. 
    Bu yere çalıştırılabilir dosyanın yüklendiği dizin (current working directory) dahil değildir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    İster statik kütüphane isterse dinamik kütüphane yazacak olalım yazdığımız kütüphaneler için bir başlık dosyası oluşturmak 
    iyi bir tekniktir. Örneğin içerisinde çeşitli fonksiyonların bulunduğu "libmyutil.so" dinamik kütüphanersini "libmyutil.c" 
    dosyasından hareketle oluşturmak isteyelim. İşte "libmyutil.c" dosyasındaki fonksiyonların prototipleri, gerekli olan sembolik 
    sabitler, makrolar, inline fonksiyonlar, yapı bildirimleri gibi "nesne yaratmayan bildirimler"  bir başlık dosyasına yerleştirilmelidir. 
    Böylece bu kütüphaneyi kullanacak kişiler bu dosyayı include ederek gerekli bildirimlerin kodlarını oluşturmuş olurlar. Başlık 
    dosyaları oluşturulurken iki önemli noktaya dikkat edilmelidir:

    1) Başlık dosyalarına yalnızca "nesne yaratmayan bildirimler (declarations)" yerleştirilmelidir. 
    2) Başlık dosyalarının başına "include koruması (include guard)" yerleştirilmelidir. Include koruması aşağıdaki gibi yapılabilir:

    #ifndef SOME_NAME
    #define SOME_NAME

    <dosyanın içeriği>

    #endif

    Buradaki SOME_NAME dosya isminden hareketle uydurulmuş olan herhangi bir isim olabilir. Örneğin:

    #ifndef MYUTIL_H_
    #define MYUTIL_H_

    <dosyanın içeriği>

    #endif

    Örneğin "myutil.so" dinamik kütüphanesinde foo ve bar isimli iki fonksiyon bulunuyor olsun. Bunun için "myutil.h" isimli
    başlık dosyası aşağıdaki gibi oluşturulabilir:

    #ifndef MYUTIL_H_
    #define MYUTIL_H_

    void foo(void);
    void bar(void);

    #endif
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Standart C fonksiyonlarının ve POSIX fonksiyonlarının bulunduğu "libc" kütüphanesi gcc ve clang programlarıyla derleme yapıldığında 
    otomatik olarak bağlama aşamasında devreye sokulmaktadır. Yani biz standart fonksiyonları ve POSIX fonksiyonları için bağlama 
    aşamasında kütüphane belirtmek zorunda değiliz. Default durumda gcc ve clang programları standart C fonksiyonlarını ve POSIX 
    fonksiyonlarını dinamik kütüphaneden alarak kullanır. Ancak programcı isterse "-static" seçeneği ile statik bağlama işlemi 
    de yapabilir. Bu durumda bu fonksiyonlar statik kütüphanelerden alınarak çalıştırılabilen dosyalara yazılacaktır. Örneğin:

    gcc -o app -static app.c

    "-static" seçeneği ile bağlama işlemi yapıldığında artık üretilen çalıştırılabilir dosyanın dinamik kütüphanelerle hiçbir ilgisi 
    kalmamaktadır. Zaten "-static" seçeneği belirtildiğinde artık dinamik kütüphaneler bağlama aşamasına programcı tarafından da 
    dahil edilememektedir. Tabii bu biçimde statik bağlama işlemi yapıldığında çalıştırılabilen dosyanın boyutu çok büyüyecektir. 
    
    Eğer "libc" kütüphanesinin default olarak bağlama aşamasında devreye sokulması istenmiyorsa "-nodefaultlibs" seçeneğinin kullanılması 
    gerekir. Örneğin:

    gcc -nodefaultlibs -o app app.c

    Burada glibc kütüphanesi devreye sokulmadığı için bağlama aşamasında hata oluşacaktır. Tabii bu durumda da kütüphane açıkça 
    belirtilebilir:
    
    gcc -nodefaultlibs -o app app.c -lc

    Bir kütüphanenin statik ve dinamik biçimi aynı anda bulunuyorsa ve biz bu kütüphaneyi "-l" seçeneği ile belirtiyorsak bu 
    durumda default olarak kütüphanenin dinamik versiyonu devreye sokulmaktadır. Eğer bu durumda kütüphanelerin statik versiyonlarının 
    devreye sokulması isteniyorsa "-static" seçeneğinin kullanılması ya da komut satırında açıkça statik kütüphaneye referans 
    edilmesi gerekir. Örneğin:

    gcc -o app app.c -lmyutil -L.

    Burada eğer hem "libmyutil.so" hem de "libmyutil.a" dosyaları varsa "libmyutil.so" dosyası kullanılacaktır. Yani dinamik bağlama 
    yapılacaktır. Tabii biz açıkça statik kütüphanenin ya da dinamik kütüphanenin kullanılmasını sağlayabiliriz:

    gcc -o app app.c libmyutil.a

    Aynı etkiyi şöyle de sağlayabilirdik:

    gcc -static -o app app.c -lmyutil -L.

    Burada "libc" kütüphanesinin dinamik biçimi devreye sokulacaktır. Ancak "libmyutil" kütüphanesi statik biçimde bağlanmıştır.
    Eğer "-static" seçeneği kullanılırsa bu durumda tüm kütüphanelerin statik versiyonları devreye sokulmaktadır. Tabii bu durumda 
    biz açıkça dinamik kütüphanelerin bağlama işlemine sokulmasını isteyemeyiz. Örneğin:

    gcc -static -o app app.c libmyutil.so

    Bu işlem başarısız olacaktır. Çünkü "-static" seçeneği zaten "tüm kütüphanelerin statik olarak bağlanacağı edileceği" anlamına 
    gelmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
   Dinamik kütüphane kullanan programlarda bağlayıcı tarafından ELF formatında iki önemli bölüm oluşturulmaktadır. Bu bölümler 
   ".dynamic" ve ".dynsym" isimli bölümlerdir. ".dynmaic" bölümü çalıştırılabilir dosyanın kullandığı dinamik kütüphaneler hakkında 
   bilgileri içermektedir. ".dynsym" bölümü ise dinamki kütüphanelerden kullanılan sembollerin tutulduğu sembol tablosudur. Programın 
   normal sembollerinin ".symtab" isimli bölümdeki sembol tablosunda tutulduğunu anımsayınız. 

   32 bit ELF formatının ".dynamic" bölümünün yapısal içeriği şöyledir:

    typedef struct {
        Elf32_Sword d_tag;
        union {
            Elf32_Word d_val;
            Elf32_Addr d_ptr;
        } d_un;
    } Elf32_Dyn;

    64 bit ELF formatının ".dynamic" bölümünün yapısal içeriği ise şöyledir:

    typedef struct {
        Elf64_Sxword d_tag;
        union {
            Elf64_Xword d_val;
            Elf64_Addr d_ptr;
        } d_un;
    } Elf64_Dyn;

    ELF formatının ".dynamic" bölümü yukarıdaki yapılardan oluşan bir dizi gibidir. Bu bölümün içeriğini aşağıdaki gibi temsil
    edebiliriz:

    d_tag d_un
    d_tag d_un
    d_tag d_un
    d_tag d_un
    d_tag d_un
    ....

    Burada d_un ya d_val olabilir ya da d_ptr olabilir, ancak ikisi birden olamaz. d_val bir değer, d_ptr ise bir sanal adres 
    belirtmektedir.
    
    Yapıların d_tag elemanı ilgili girişin türünü belirtmektedir. Yapının d_un elemanının d_val ya da d_ptr elemanını mı içereceği
    bu d_tag elemanına bağlıdır. Önemli bazı d_tag değerleri şunlardır:

    DT_NEEDED: Bu tag'ı d_val elemanı izlemektedir. Bu tag'daki d_val elemanı modülün yüklenmesi için gerekli olan dinamik kütüphanenin
    isminin (yol ifadesinin değil) string tablosundaki (".strtab") indeks numarası belirtilmektedir. 

    DT_SONAME: Bu tag'ı d_val elemanı izlemektedir. Bu tag dinamik kütüphanelerde bulunmaktadır. Burada dinamik kütüphanenin "so 
    ismininin" bulunduğu string tablosundaki (".strtab" bölümündeki) indeks belirtilmektedir.

    Buradaki pek çok tag önemli bilgiler içermektedir. Bu tag'lar hakkında bilgileri ELF formatına başvurarak edinebilirsiniz.
    İzleyen paragraflarda bazı bilgiler için bu tag'lara referans edeceğiz.

    Aşağıda readelf programı ile ".dynamic" bölümünün görüntülenme biçimi gösterilmektedir:

    Dynamic section at offset 0xd78 contains 28 entries:
    Tag        Type                         Name/Value
    0x0000000000000001 (NEEDED)             Shared library: [libmyutil.so]
    0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
    0x000000000000000c (INIT)               0x610
    0x000000000000000d (FINI)               0x85c
    0x0000000000000019 (INIT_ARRAY)         0x10d68
    0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)
    0x000000000000001a (FINI_ARRAY)         0x10d70
    0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)
    0x000000006ffffef5 (GNU_HASH)           0x298
    0x0000000000000005 (STRTAB)             0x3c0
    0x0000000000000006 (SYMTAB)             0x2b8
    0x000000000000000a (STRSZ)              151 (bytes)
    0x000000000000000b (SYMENT)             24 (bytes)
    0x0000000000000015 (DEBUG)              0x0
    0x0000000000000003 (PLTGOT)             0x10f78
    ......

    O halde çalıştırılabilir dosyanın ya da dinamik kütüphane dosyasının hangi dinamik kütüphaneleri kullandığını komut satırından
    aşağıdaki gibi elde edebiliriz:

    $ readelf -d app | grep "NEEDED"
    0x0000000000000001 (NEEDED)             Shared library: [libmyutil.so]
    0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]

    Tabii biz bu biçimde yalnızca çalıştırılabilen dosyanın doğrudan kullandığı dinamik kütüphaneleri görüntülemiş oluruz. 
    Oysa dinamik kütüphaneler de başka dinamik kütüphaneleri kullanıyor olabilir. Bu tür durumlarda özyinelemeli (recursive) 
    biçimde yükleme yapılmaktadır. Bir çalıştırılabilir dosyanın yüklenebilmesi için özyinelemeli biçimde bütün gereken
    dinamik kütüphaneler "ldd" komutuyla elde edilebilmektedir. Örneğin.

    $ ldd app
	linux-vdso.so.1 (0x0000ffffaf206000)
	libmyutil.so => not found
	libc.so.6 => /lib/aarch64-linux-gnu/libc.so.6 (0x0000ffffaf03f000)
	/lib/ld-linux-aarch64.so.1 (0x0000ffffaf1d6000)
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphanelerden kullanılan semboller genellikle ELF formatının ".dynsym" isimli sembol tablosunda bulunmaktadır. 
    Aslında dinamik kütüphanedeki sembollerin hangi sembol tablosunda bulunacağı da ".dynamic" bölümündeki DT_SYMTAB tag'ında
    belirtilmektedir. ".dynsym" bölümü daha önce incelediğimiz sembol tablosu formatına sahiptir. Aşağıda örnek bir ".dynsym"
    sembol tablosunun readelf programı ile elde edilen görüntüsü verilmiştir:

    Symbol table '.dynsym' contains 11 entries:
    Num:    Value          Size Type    Bind   Vis      Ndx Name
        0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
        1: 0000000000000610     0 SECTION LOCAL  DEFAULT   11 
        2: 0000000000011000     0 SECTION LOCAL  DEFAULT   22 
        3: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab
        4: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2.17 (2)
        5: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND bar
        6: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.17 (2)
        7: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
        8: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND abort@GLIBC_2.17 (2)
        9: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND foo
        10: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde dinamik kütüphane kullanan programların yüklenmesi süreci biraz ilginçtir. Anımsanacağı gibi aslında
    her türlü program exec fonksiyonları tarafındnan yüklenip çalıştırılmaktadır. Bu exec fonksiyonlarının taban olanı "execve"
    isimli fonksiyondur. (Yani diğer exec fonksiyonları bunu çağırmaktadır.) execve fonksiyonu da bir sistem fonksiyonu olarak 
    yazılmıştır. 

    Dinamik kütüphane kullanan programların kullandığı dinamik kütüphaneler ismine "dinamik linker (dynamic linker)" denilen
    özel bir program tarafındna yüklenmektedir. exec fonksiyonları aslında sıra dinamik kütüphanelerin yüklenmesine geldiğinde 
    dinamik linker denilen bu programı çalıştırmaktadır. Dinamik linker "ld.so" ismiyle temsil edilmektedir. Programın kullandığı 
    dinamik kütüphanelerin başka bir program tarafından yüklenmesi esneklik sağlamaktadır. Bu sayede sistem programcısı isterse 
    (genellikle istemez) bu dinamik linker programını değiştirerek yükleme sürecinde özel işlemler yapabilir. Dinamik linker 
    tamamen user modda çalışmaktadır. 

    Programın dinamik kütüphanelerinin yüklenmesinde kullanılacak olan dinamik linker'ın yol ifadesi ELF formatında Program Başlık 
    Tablosunda INTERP türüyle belirtilmektedir. INTERP türüne ilişkin Program Başlığında dinamik bağlayıcının yol ifadsininin 
    bulunduğu dosya offset'i belirtilmektedir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    <BURADA KALDIK>
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
     Bir programın kullandığı dinamik kütüphaneler ldd isimli utility program ile basit bir biçimde görüntülenebilir. Örneğin:

    $ ldd sample
	linux-vdso.so.1 (0x00007fff38162000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7ec0b5c000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f7ec114f000

    ldd programı dinamik kütüphanelerin kullandığı dinamik kütüphaneleri de görüntülemektedir. Programın doğrudan kullandığı dinamik
    kütüphanelerin listesi readelf komutuyla aşağıdaki gibi de elde edilebilir:

    $ readelf -d sample | grep "NEEDED"
    0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Pekiyi bizim programımız örneğin "libmyutil.so" isimli bir dinamik kütüphaneden çağrı yapıyor olsun. Bu "libmyutil.so" 
    dosyasının program çalıştırılırken nerede bulundurulması gerekir? İşte program çalıştırılırken ilgili dinamik kütüphane 
    dosyasının özel bazı dizinlerde bulunuyor olması gerekmektedir. Yükleme sırasında hangi dizinlere bakıldığı "man ld.so" 
    sayfasından elde edilebilir. Bu dokümanda dinamik kütüphanenin bulunabilmesi için sırasıyla tek tek hangi dizinlere bakıldığı 
    belirtilmiştir. Dinamik linker'ın dinamik kütüphaneleri nerede ve nasıl aradığının bazı ayrıntıları vardır. Ancak konuyu 
    basitleştirirsek dinamik linker LD_LIBRARY_PATH isimli çevre değişkeni ile belirtilen dizinlerde dinamik kütüphane dosyalarını
    aramaktadır. LD_LIBRARY_PATH çevre değişkeni normal olarak çevre değişken listesinde bulunmaz. Programcının bunu eklemesi 
    gerekebilmektedir. Bu çevre değişkeninin değeri ':' karakterleriyle ayrılmış olan dizinlerden oluşmalıdır. İşte dinamik linker 
    tek tek bu dizinlere bakmaktadır. Örneğin:

    export LD_LIBRARY_PATH=/home/kaan:/home/kaan/Study/Unix-Linux-SysProg

    Burada artık dinamik kütüphaneler "/home/kaan" dizininde ve "/home/kaan/Unix-Linux-SysProg" dizininde aranacaktır. Eğer biz
    LD_LIBRARY_PATH çevre değişkenine "." biçiminde dizin eklersek buradaki "." o anda bulunulan dizin anlamına gelmektedir. Örneğin:

    export LD_LIBRARY_PATH=/home/kaan:/home/kaan/Study/Unix-Linux-SysProg:.

    Dinamik linker eğer dinamik kütüphaneyi LD_LIBRARY_PATH ile belirtilen dizinde bulamazsa bu durumda /lib, /usr/lib, /lib64 ve
    /usr/lib64 dizinlerine de bakmaktadır. (Bu 64'lü dizinlere 32 bit sistemlerde ve bazı 64 bit sistemlerde bakılmamaktadır.) O halde
    dinamik kütüphanemizin dinamik linker tarafından bulunmasını istiyorsak onu doğrudan /lib ya da /usr/lib dizinlerinin içerisine de
    yerleştirebiliriz. /lib dizini sistemin yüklenmesi için de gereken aşağı seviyeli kütüphanelerin bulunduğu dizindir. Programcının 
    bu tür durumlarda /usr/lib dizinini tercih etmesi uygundur.

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphanelerin aranacağı yer aslında doğrudan çalıştırılabilen dosyanın içerisine (.dynamic isimli bölüme (section)) 
    de yazılabilir. Bunun için "-rpath <yol ifadesi>" linker seçeneği kullanılmalıdır. Buradaki yol ifadesinin mutlak olması gerekir. 
    Ancak eskiden bunun ELF formatında için DT_RPATH isimli tag kullanılırken daha sonra bu tag "deprecated" yapılmış ve DT_RUNPATH 
    tag'ı kullanılmaya başlanmıştır. "-rpath" seçeneğini linker'a geçirebilmek için gcc'de "-Wl" seçeneğini kullanmak gerekir. "-Wl" 
    seçeneği bitişik yazılan virgüllü alanlardan oluşmaktadır. gcc bunu ld linker'ına virgüller yerine boşluklar koyarak geçirmektedir. 
    Örneğin:

    gcc -o app app.c -Wl,-rpath,/home/csd/Study/Unix-Linux-SysProg libmyutil.so

    Burada ELF formatının DT_RUNPATH tag'ına yerleştirme yapılmaktadır. Çalıştırılabilir dosyaya iliştirilen rpath bilgisi readelf 
    programı ile aşağıdaki gibi görüntülenebilir:

    $ readelf -d app | grep "RUNPATH"
    0x000000000000001d (RUNPATH)            Library runpath: [/home/csd/Study/Unix-Linux-SysPro

    Biz bu tag'a birden fazla dizin de yerleştirebiliriz. Bu durumda yine dizinleri ':' ile ayırmamız gerekir. Örneğin:

    gcc -o app app.c -Wl,-rpath,/home/csd/Study/Unix-Linux-SysProg:/home/kaan libmyutil.so

    Birden fazla kez -rpath seçeneği kullanıldığında bu seçenekler tek bir DT_RUNPATH tag'ına aralarına ':' karakteri getirilerek 
    yerleştirilmektedir. Yani aşağıdaki işlem yukarıdaki ile eşdeğerdir:

    gcc -o app app.c -Wl,-rpath,/home/csd/Study/Unix-Linux-SysProg,-rpath,/home/kaan libmyutil.so

    Eğer DT_RPATH tag'ına yerleştirme yapılmak isteniyorsa linker seçeneklerine ayrıca --disable-new-dtags seçeneğinin de girilmesi 
    gerekmektedir. Örneğin:

    gcc -o app app.c -Wl,-rpath,/home/csd/Study/Unix-Linux-SysProg,--disable-new-dtags libmyutil.so

    DT_RPATH tag'ını da aşağıdaki gibi görüntüleyebiliriz:

    $ readelf -d app | grep "RPATH"
    0x000000000000000f (RPATH)              Library rpath: [/home/csd/Study/Unix-Linux-SysProg]

    Yukarıda da belirttiğimiz gibi DT_RPATH tag'ı bir süredir "deprecated" yapılmıştır.

    Çalıştırılabilir dosyaya DT_RUNPATH tag'ının mutlak yol ifadesi biçiminde girilmesi kullanım sorunlarına yol açabilmektedir. 
    Çünkü bu durumda dinamik kütüphaneler uygulamanın kurulduğu dizine göreli biçimde konuşlandırılacağı zaman kurulum yeri 
    değiştirildiğinde sorunlar oluşabilmektedir. Örneğin biz çalıştırılabilir dosyanın DT_RUNPATH tag'ına home/kaan/test isimli 
    yol ifadesini yazmış olalım. Programımızı ve dinamik kütüphanemizi bu dizine yerleştirirsek bir sorun oluşmayacaktır. Ancak 
    başka bir dizine yerleştirirsek dinamik kütüphanemiz bulunamayacaktır. İşte bunu engellemek için -rpath seçeneğinde '$ORIGIN' 
    argümanı kullanılmaktadır. Buradaki '$ORIGIN' argümanı o anda uygulamanın bulunduğu dizini temsil etmektedir. Örneğin: 

    gcc -o app app.c -Wl,-rpath,'$ORIGIN'/. libmyutil.so

    Burada artık çalıştırılabilen dosya nereye yerleştirilirse yerleştirilsin dinamik kütüphaneler onun yerleştirildiği dizinde 
    aranacaktır.

    Aslında arama sırası bakımından DT_RPATH tag'ının en yukarıda olması (daha doğrusu LD_LIBRARY_PATH'in yukarısında olması) yanlış 
    bir tasarımdır. Geriye doğru uyumu koruyarak bu yanlış tasarım DT_RUNPATH tag'ı ile telafi edilmiştir. DT_RUNPATH tag'ına 
    LD_LIBRARY_PATH çevre değişkeninden sonra başvurulmaktadır. (Bunun için "man ld.so" sayfasındaki sıralamayı gözden geçiriniz.)
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphanelerin aranması sırasında "/lib" ve "/usr/lib" dizinlerine bakılmadan önce özel bir dosyaya da bakılmaktadır. 
    Bu dosya "/etc/ld.so.cache" isimli dosyadır. "/etc/ld.so.cache" dosyası aslında binary bir dosyadır. Bu dosya hızlı aramanın 
    yapılabilmesi için "sözlük (dictionary)" tarzı yani algoritmik aramaya izin verecek biçimde bir içeriğe sahiptir. Bu dosya
    ilgili dinamik kütüphane dosyalarının hangi dizinler içerisinde olduğunu gösteren bir yapıdadır. (Yani bu dosya .so dosyalarının 
    hangi dizinlerde olduğunu belirten binary bir dosyadır.) Başka bir deyişle bu dosyanın içerisinde "falanca .so dosyası filanca 
    dizinde" biçiminde bilgiler vardır. İlgili .so dosyasının yerinin bu dosyada aranması dizinlerde aranmasından çok daha hızlı 
    yapılabilmektedir.

    Pekiyi bu "/etc/ld.so.cache" dosyasının içerisinde hangi ".so" dosyaları vardır? Aslında bu dosyanın içerisinde "/lib" ve 
    "/usr/lib" dizinindeki ".so" dosyalarının hepsi bulunmaktadır. Ama programcı isterse kendi dosyalarını da bu cache dosyasının 
    içerisine yerleştirebilir. Pekiyi neden böyle bir cache dosyasına gereksinim duyulmuştur? İşte dinamik kütüphaneler yüklenirken 
    "/lib" ve "/usr/lib" dizinlerinin taranması göreli olarak uzun zaman almaktadır. Bu da programın yüklenme süresini uzatabilmektedir. 
    Halbuki bu dizinlere bakılmadan önce bu cache dosyasına bakılırsa ilgili dosyanın olup olmadığı varsa nerede olduğu çok daha 
    hızlı bir biçimde elde edilebilmektedir. Burada dikkat edilmesi gereken nokta bu cache dosyasına "/lib" ve "/usr/lib" dizinlerinden 
    daha önce bakıldığı ve bu dizinlerin içeriğinin de zaten bu cache dosyasının içerisinde olduğudur. O halde aslında "/lib" ve "/usr/lib"
    dizinlerinde arama çok nadir olarak yapılmaktadır. Bu cache dosyasına LD_LIBRARY_PATH dizininden daha sonra bakılmaktadır. O halde 
    programcının kendi ".so" dosyalarını da eğer uzun süreliğine konuşlandıracaksa bu cache dosyasının içerisine yazması tavsiye 
    edilmektedir.

    Pekiyi "/etc/ld.so.cache" dosyasına biz nasıl bir dosya ekleriz? Aslında programcı bunu dolaylı olarak yapmaktadır. Şöyle ki: 
    "/sbin/ldconfig" isimli bir program vardır. Bu program "/etc/ld.so.conf" isimli bir text dosyasına bakar. Bu dosya dizinlerden 
    oluşmaktadır. Bu ldconfig programı bu dizinlerin içerisindeki "so" dosyalarını "/etc/ld.so.cache" dosyasına eklemektedir. 
    Şimdilerde "/etc/ld.so.conf" dosyasının içeriği şöyledir:

    include /etc/ld.so.conf.d/*.conf

    Bu satır "/etc/ld.so.conf.d" dizinindeki tüm ".conf" uzantılı dosyaların bu işleme dahil edileceğini belirtmektedir.

    Biz ldconfig programını çalıştırdığımızda bu program "/lib", "/usr/lib" ve "/etc/ld.so.conf" (dolayısıyla "/etc/ld.so.conf.d" 
    dizinindeki ".conf" dosyalarına) bakarak "/etc/ld.so.cache" dosyasını yeniden oluşturmaktadır. O halde bizim bu cache'e ekleme yapmak 
    için tek yapacağımız şey "/etc/ld.so.conf.d" dizinindeki bir ".conf" dosyasına yeni bir satır olarak bir dizinin yol ifadesini girmektir. 
    (".conf" dosyaları her satırda bir dizinin yol ifadesinden oluşmaktadır.) Tabii programcı isterse bu dizine yeni bir ".conf" dosyası 
    da ekleyebilir. İşte programcı bu işlemi yaptıktan sonra "/sbin/ldconfig" programını çalıştırınca artık onun eklediği dizinin 
    içerisindeki ".so" dosyaları da "/etc/ld.so.cache" dosyasının içerisine eklenmiş olacaktır. Daha açık bir anlatımla programcı 
    bu cache dosyasına ekleme işini adım adım şöyle yapar:

    1) Önce ".so" dosyasını bir dizine yerleştirir.
    2) Bu dizinin ismini "/etc/ld.so.conf.d" dizinindeki bir dosyanın sonuna ekler. Ya da bu dizinde yeni conf dosyası oluşturarak
    dizini bu dosyanın içerisine yazar.
    3) "/sbin/ldconfig" programını çalıştırır.

    ldconfig programının "sudo" ile çalıştırılması gerektiğine dikkat ediniz. Zaten "/sbin" dizinindeki tüm programlar "super user"
    için bulundurulmuştur.

    Programcı "/etc/ld.so.conf.d" dizinindeki herhangi bir dosyaya değil de -f seçeneği ile kendi belirlediği bir dosyaya da ilgili 
    dizini yazabilmektedir. Başka bir deyişle "-f" seçeneği "şu config dosyasına da bak" anlamına gelmektedir. ldconfig her 
    çalıştırıldığında sıfırdan yeniden cache dosyasını oluşturmaktadır.

    Programcı "/lib" ya da "/usr/lib" dizinine bir "so" dosyası eklediğinde ldconfig programını çalıştırması zorunlu olmasa da 
    iyi bir tekniktir. Çünkü o dosya da cache dosyasına yazılacak ve daha hızlı bulunacaktır.

    ldconfig programında "-p" seçeneği ile cache dosyası içerisindeki tüm dosyalar görüntülenebilmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kütüphane dosyalarının "so" isimleri denilen bir isimleri de bulunabilmektedir. Kütüphane dosyalarının "so" isimleri linker 
    tarafından kullanılan isimleridir. Kütüphane dosyası oluşturulurken "so" isimleri verilmeyebilir. Yani bir kütüphane dosyasının 
    "so" ismi olmak zorunda değildir. Kütüphane dosyalarına "so" isimlerini vermek için "-soname <isim>" linker seçeneği 
    kullanılmaktadır. Kütüphanelere verilen "so" isimleri ELF formatının dinamik bölümündeki (dynamic section) SONAME isimli 
    bir tag'ına yerleştirilmektedir. "-soname" komut satırı argümanı linker'a ilişkin olduğu için "-Wl" seçeneği ile kullanılmalıdır. 
    Örneğin biz libx.so isimli bir dinamik kütüphaneyi "so" ismi vererek oluşturmak isteyelim. Bu işlemi şöyle yapabiliriz:

    gcc -o libx.so -fPIC -shared -Wl,-soname,liby.so libx.c

    Burada "libx.so" kütüphane dosyasına "liby.so" "so" ismi verilmiştir. Kütüphane dosyalarına iliştirilen "so" isimleri 
    readelf ile aşağıdaki gibi görüntülenebilir:

    $ readelf -d libx.so | grep "SONAME"
    0x000000000000000e (SONAME)             Kitaplık so_adı: [liby.so]

    Aynı işlem objdump programıyla da şöyle yapılabilir:

    objdump -x libx.so | grep "SONAME"
    SONAME               liby.so

    Tabii yukarıda da belirttiğimiz gibi biz dinamik kütüphanelere "so" ismi vermek zorunda değiliz.

    "so" ismi içeren bir kütüphaneyi kullanan bir program link edilirken linker çalıştırılabilen dosyaya "so" ismini içeren 
    kütüphanenin ismini değil "so" ismini yazmaktadır. Yukarıdaki örneğimizde "libx.so" kütüphanesi "so" ismi olarak "liby.so"
    ismini içermektedir. Şimdi libx.so dosyasını kullanan "app.c" dosyasını derleyip link edelim:

    gcc -o app app.c libx.so

    Burada link işleminde "libx.so" dosya ismi kullanılmıştır. Ancak oluşturulan "app" dosyasının içerisine linker bu ismi 
    değil, "so" ismi olan "liby.so" ismini yazacaktır. Örneğin:

    $ readelf -d app | grep "NEEDED"
    0x0000000000000001 (NEEDED)             Paylaşımlı kitaplık: [liby.so]
    0x0000000000000001 (NEEDED)             Paylaşımlı kitaplık: [libc.so.6]

    O halde biz buradaki "app" dosyasını çalıştırmak istediğimizde yükleyici (yani dinamik linker) artık "libx.so" dosyasını 
    değil, "liby.so" dosyasını yüklemeye çalışacaktır. Örneğin.

    $ export LD_LIBRARY_PATH=.
    $ ./app
    ./app: error while loading shared libraries: liby.so: cannot open shared object file: No such file or directory

    Tabii yukarıda belirttiğimiz gibi eğer kütüphaneyi oluştururken ona "so" ismi vermeseydik bu durumda linker "app" dosyasına
    "libx.so" dosyasını yazacaktı ve yükleyici de (dynamic linker) bu dosyası yükleyecekti.

    Pekiyi yukarıdaki örnekte "app" programı artık "liby.so" dosyasını kullanıyor gibi olduğuna göre ve böyle de bir dosya 
    olmadığına göre bu işlemlerin ne anlamı vardır? İşte biz bu örnekte "so" ismine ilişkin dosyayı bir sembolik link dosyası 
    haline getirirsek ve bu sembolik link dosyası da "libx.so" dosyasını gösterir hale gelirse sorunu ortadan kaldırabiliriz. 
    Örneğin:

    $ ln -s libx.so liby.so
    $ ls -l liby.so
    lrwxrwxrwx 1 kaan study 7 Şub 25 16:44 liby.so -> libx.so

    Şimdi artık "app" dosyasını çalıştırmak istediğimizde yükleyici "liby.so" dosyasını yüklemek isteyecektir. Ancak "liby.so" 
    dosyası da zaten "libx.so" dosyasını belirttiği için yine "libx.so" dosyası yüklenecektir. Yani artık "app" dosyasını 
    çalıştırabiliriz. Tabii burada tüm bunları neden yapmış olduğumuza bir anlam verememiş olabilirsiniz. İşte bunun anlamını 
    izleyen paragraflarda dinamik kütüphanelerin versiyonlanması konusunda açıklayacağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde dinamik kütüphane dosyalarına isteğe bağlı olarak birer versiyon numarası verilebilmektedir. Bu 
    versiyon numarası dosya isminin bir parçası durumundadır. Linux sistemlerinde izlenen tipik numaralandırma (convention) 
    şöyledir:

    <dosya_ismi>.so.<majör_numara>.<minör_yüksek_numara>.<minör_alçak_numara>

    Örneğin:

    libmyutil.so.2.4.6

    Majör numaralar büyük değişiklikleri, minör numaralar ise küçük değişiklikleri anlatmaktadır. Majör numara değişirse yeni 
    dinamik kütüphane eskisiyle uyumlu olmaz. Burada "uyumlu değildir" lafı eski dinamik kütüphaneyi kullanan programların 
    yenisini kullanamayacağı anlamına gelmektedir. Çünkü muhtemelen bu yeni versiyonda fonksiyonların isimlerinde, parametrik 
    yapılarında değişiklikler söz konusu olmuş olabilir ya da bazı fonksiyonlar silinmiş olabilir. Fakat majör numarası aynı 
    ancak minör numaraları farklı olan kütüphaneler birbirleriyle uyumludur. Yani alçak minör numarayı kullanan program yüksek 
    minör numarayı kullanırsa sorun olmayacaktır. Bu durumda tabii yüksek minör numaralı kütüphanede hiçbir fonksiyonun ismi, 
    parametrik yapısı değişmemiş ve hiçbir fonksiyon silinmemiş olmalıdır. Örneğin yüksek minör numaralarda fonksiyonlarda 
    daha hızlı çalışacak biçimde optimizasyonlar yapılmış olabilir. Ya da örneğin yüksek minör numaralarda yeni birtakım 
    fonksiyonlar da eklenmiş olabilir. Çünkü yeni birtakım fonksiyonlar eklendiğinde eski fonksiyonlar varlığını devam ettirmektedir. 
    Tabii yine de bu durum dinamik kütüphanenin eski versiyonunu kullanan programların düzgün çalışacağı anlamına gelmemektedir. 
    Çünkü programcılar kodlarına yeni birtakım şeyler eklerken istemeden eski kodların çalışmasını da bozabilmektedir. (Bu tür 
    problemler Windows sistemlerinde eskiden ciddi sıkıntılara yol açmaktaydı. Bu probleme Windows sistemlerinde "DLL cehennemi 
    (DLL Hell)" deniyordu.)
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde versiyonlama bakımından bir dinamik kütüphanenin üç ismi bulunmaktadır:

    1) Gerçek ismi (real name)
    2) so ismi (so name)
    3) Linker ismi (linker name)

    Kütüphanenin majör ve çift minör versiyonlu ismine gerçek ismi denilmektedir. Örneğin:

    libmyutil.so.2.4.6

    "so" ismi ise yalnızca majör numara içeren ismidir. Örneğin yukarıdaki gerçek ismin "so" ismi şöyledir:

    libmyutil.so.2

    Linker ismi ise hiç versiyon numarası içermeyen ismidir. Örneğin yukarıdaki kütüphanelerin linker ismi ise şöyledir:

    libmyutil.so

    İşte tipik olarak "so" ismi gerçek isme sembolik link, linker ismi de en yüksek numaralı "so" ismine sembolik link yapılır.

    linker ismi ---> so ismi ---> gerçek ismi

    Örneğin:

    gcc -o libmyutil.so.1.0.0 -shared -fPIC libmyutil.c     (gerçek isimli kütüphane dosyası oluşturuldu)
    ln -s libmyutil.so.1.0.0 libmyutil.so.1                 (so ismi oluşturuldu)
    ln -s libmyutil.so.1 libmyutil.so                       (linker ismi oluşturuldu)

    Burada oluşturulan üç dosyayı "ls -l" komutu ile görüntüleyelim:

    lrwxrwxrwx 1 kaan study    14 Şub 25 15:45 libmyutil.so -> libmyutil.so.1
    lrwxrwxrwx 1 kaan study    18 Şub 25 15:45 libmyutil.so.1 -> libmyutil.so.1.0.0
    -rwxr-xr-x 1 kaan study 15736 Şub 25 15:45 libmyutil.so.1.0.0
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde versiyonlama bakımından bir dinamik kütüphanenin üç ismi bulunmaktadır:

    1) Gerçek ismi (real name)
    2) so ismi (so name)
    3) Linker ismi (linker name)

    Kütüphanenin majör ve çift minör versiyonlu ismine gerçek ismi denilmektedir. Örneğin:

    libmyutil.so.2.4.6

    "so" ismi ise yalnızca majör numara içeren ismidir. Örneğin yukarıdaki gerçek ismin "so" ismi şöyledir:

    libmyutil.so.2

    Linker ismi ise hiç versiyon numarası içermeyen ismidir. Örneğin yukarıdaki kütüphanelerin linker ismi ise şöyledir:

    libmyutil.so

    İşte tipik olarak "so" ismi gerçek isme sembolik link, linker ismi de en yüksek numaralı "so" ismine sembolik link yapılır.

    linker ismi ---> so ismi ---> gerçek ismi

    Örneğin:

    gcc -o libmyutil.so.1.0.0 -shared -fPIC libmyutil.c     (gerçek isimli kütüphane dosyası oluşturuldu)
    ln -s libmyutil.so.1.0.0 libmyutil.so.1                 (so ismi oluşturuldu)
    ln -s libmyutil.so.1 libmyutil.so                       (linker ismi oluşturuldu)

    Burada oluşturulan üç dosyayı "ls -l" komutu ile görüntüleyelim:

    lrwxrwxrwx 1 kaan study    14 Şub 25 15:45 libmyutil.so -> libmyutil.so.1
    lrwxrwxrwx 1 kaan study    18 Şub 25 15:45 libmyutil.so.1 -> libmyutil.so.1.0.0
    -rwxr-xr-x 1 kaan study 15736 Şub 25 15:45 libmyutil.so.1.0.0

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
												123. Ders 25/02/2024 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphanelerin linker isimleri o kütüphaneyi kullanan programlar link edilirlen link aşamasında (link ederken) 
    kullanılan isimlerdir. Bu sayede link işlemini yapan programcıların daha az tuşa basarak genel bir isim kullanması sağlanmıştır. 
    Bu durumda örneğin biz libmyutil isimli kütüphaneyi kullanan programı link etmek istersek şöyle yapabiliriz:

    gcc -o app app.c libmyutil.so

    Ya da şöyle yapabiliriz:

    gcc -o app app.c -lmyutil -L.

    Burada aslında "libmyutil.so" dosyası "so ismine" "so" ismi de "gerçek isme link yapılmış" durumdadır. Yani bu komutun 
    aslında eşdeğeri şöyledir:

    gcc -o app app.c libmyutil.so.1.0.0
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Yukarıda anlattıklarımızı özetlersek geldiğimiz noktayı daha iyi kavrayabiliriz:

    1) Bir dinamik kütüphane oluştururken ona bir versiyon numarası da atanabilmektedir. Örneğin biz oluşturduğumuz "myutil" 
    dinamik kütüphanesine "1.0.0" versiyon numarası atamış olalım. Bu durumda kütüphanemizin gerçek ismi "libmyutil.so.1.0.0" 
    olacaktır. Kütüphanemizi aşağıdaki gibi derlemiş olalım:

    $ gcc -fPIC -shared -o libmyutil.so.1.0.0 -Wl,-soname,libmyutil.so.1 libmyutil.c

    2) Dinamik kütüphanelerin "so ismi" kütüphanelerin içerisine yazılan ismidir. Yukarıdaki gibi bir derlemede biz "libmyutil.so.1.0.0"
    kütüphanesinin içerisine "so ismi" olarak "libmyutil.so" ismini yerleştirdik. "so isimleri" genel olarak yalnızca majör 
    numara içeren isimlerdir. Bizim bu aşamada tipik olarak bir sembolik link oluşturarak "so" ismine ilişkin dosyanın gerçek 
    kütüphane dosyasını göstermesini sağlamamız gerekir. Bunu şöyle yapabiliriz:

    $ ln -s libmyutil.so.1.0.0 libmyutil.so.1

    Şimdi her iki dosyayı da görüntüleyelim:

    lrwxrwxrwx 1 kaan study    18 Mar  1 20:02 libmyutil.so.1 -> libmyutil.so.1.0.0
    -rwxr-xr-x 1 kaan study 15736 Mar  1 19:57 libmyutil.so.1.0.0

    3) Dinamik kütüphanenin link aşamasında kullanılmasını kolaylaştırmak için sonunda versiyon uzuntısı olmayan bir "linker ismi"
    oluşturabiliriz. Tabii bu linker ismi aslında gerçek kütüphaneye referans edecektir. Ancak bu referansın doğrudan değil de "so ismi"
    üzerinden yapılması daha esnek bir kullanıma yol açacaktır. Örneğin:

    $ ln -s libmyutil.so.1 libmyutil.so

    Artık kütüphanenin "linker ismi" "so ismine", "so ismi" de gerçek ismine sembolik link yapılmış durumdadır. Bu üç dosyayı 
    aşağıda yeniden görüntüleyelim:

    lrwxrwxrwx 1 kaan study    14 Mar  1 20:07 libmyutil.so -> libmyutil.so.1
    lrwxrwxrwx 1 kaan study    18 Mar  1 20:02 libmyutil.so.1 -> libmyutil.so.1.0.0
    -rwxr-xr-x 1 kaan study 15736 Mar  1 19:57 libmyutil.so.1.0.0

    Aşağıdaki gibi bir durum elde ettiğimize dikkat ediniz:

    Linker ismi ---> so ismi ---> gerçek isim

    4) Şimdi kütüphaneyi kullanan bir "app" programını derleyip link edelim:

    $ gcc -o app app.c libmyutil.so

    Şimdi LD_LIBRARY_PATH çevre değişkenini belirleyip programı çalıştıralım:

    $ LD_LIBRARY_PATH=. ./app
    30.000000
    -10.000000
    200.000000
    0.500000

    Burada app programının kullandığı kütüphane ismi app dosyasının içerisinde kütüphanenin "so ismi" olarak set edilecektir. 
    Yani burada "app" dosyası sanki "libmyutil.so.1" dosyasını kullanıyor gibi olacaktır. Örneğin:

    $ readelf -d app | grep "NEEDED"
    0x0000000000000001 (NEEDED)             Paylaşımlı kitaplık: [libmyutil.so.1]
    0x0000000000000001 (NEEDED)             Paylaşımlı kitaplık: [libc.so.6]

    İşte "app" programını yükleyecek olan dinamik linker aslında "libmyutil.so.1" dosyasını yüklemeye çalışacaktır. Bu dosyann 
    kütüphanenin gerçek ismine sembolik link yapıldığını anımsayınız. Bu durumda gerçekte yüklenecek olan dosya "libmyutil.so.1" 
    dosyası değil, "libmyutil.so.1.0.0" dosyası olacaktır. Yani çalışmada bir sorun ortaya çıkmayacaktır. Pekiyi tüm bunların 
    amacı nedir? Bunu şöyle açıklayabiliriz:

    1) Örneğin kütüphanemizin libmyutil.so.1.1.0 biçiminde majör numarası aynı, minör numarası farklı öncekiyle uyumlu yeni bir 
    versiyonunun daha oluşturulduğunu düşünelim. Şimdi biz uygulamamızı çektiğimiz dizin içerisindeki "libmyutil.so" dosyasını 
    bu yeni versiyonu referans edecek biçimde değiştirebiliriz. Bu durumda dinamik linker "app" programını yüklemeye çalışırken 
    aslında artık "libmyutil.so.1.1.0" kütüphanesini yükleyecektir. Burada biz hiç "app" dosyasının içini değiştirmeden artık "app"
    dosyasının kütüphanenin yeni minör versiyonunu kullamasını sağlamış olduk.

    2) Şimdi de kütüphanemizin "libmyutil.so.2.0.0" biçiminde yeni bir majör versiyonunun oluşturulduğunu varsayalım. 1 numaralı 
    majör versiyonla 2 numaralı majör versiyon birbirleriyle uyumlu değildir. Biz bu "libmyutil.so.2.0.0" yeni versiyonu derlerken ona
    "so ismi" olarak artık "libmyutil.so.2" ismini vermeliyiz. Tabii bu durumda biz yine "libmyutil.so.2" sembolik bağlantı dosyasının 
    "libmyutil.so.2.0.0" dosyasını göstermesini sağlamalıyız. Artık kütüphanenin 2'inci versiyonunu kullanan programlarda yüklenecek 
    kütüphane "libmyutil.so.2" kütüphanesi olacaktır. Bu kütüphanede 2'inci versiyonunun gerçek kütüphane ismine sembolik link yapılmış 
    durumdadır.

    "so ismine" ilişkin sembol ik link çıkartma ve "/etc/ld.so.cache" dosyasının güncellenmesi işlemi ldconfig tarafından otomatik 
    yapılabilmektedir. Yani aslında örneğin biz kütüphanenin gerçek isimli dosyasını "/lib" ya da "/usr/lib" içerisine yerleştirip 
    "ldconfig" programını çalıştırdığımızda bu program zaten "so ismine" ilişkin sembolik linki de oluşturmaktadır. Örneğin biz 
    "libmyutil.so.1.0.0" dosyasını "/usr/lib" dizinine kopyalayalım ve "ldconfig" programını çalıştıralım. "ldconfig" programı 
    "libmyutil.so.1" sembolik link dosyasını oluşturup bu sembolik link dosyasının "libmyutil.so.1.0.0" dosyasına referans etmesini 
    sağlayacaktır. Tabii cache'e de "libmyutil.so.1" dosyasını yerleştirecektir. Örneğin:

    $ ldconfig -p | grep "libmyutil"
    libmyutil.so.1 (libc6,x86-64) => /lib/libmyutil.so.1
    $ ls -l /usr/lib | grep "libmyutil"
    lrwxrwxrwx  1 root root       18 Mar  1 21:02 libmyutil.so.1 -> libmyutil.so.1.0.0
    -rwxr-xr-x  1 root root    15736 Mar  1 21:01 libmyutil.so.1.0.

    Özetle Dinamik kütüphane kullanırken şu konvansiyona uymak iyi bir tekniktir:

    - Kütüphane ismini "lib" ile başlatarak vermek
    - Kütüphane ismine majör ve minör numara vermek
    - Gerçek isimli kütüphane dosyasını oluştururken "so ismi" olarak "-Wl,-soname" seçeneği ile kütüphanenin "so ismini" yazmak
    - Kütüphane için "linker ismi" ve "so ismini" sembolik link biçiminde oluşturmak
    - Kütüphane paylaşılacaksa onu "/lib" ya da tercihen "/usr/lib" dizinine yerleştirmek ve ldconfig programı çalıştırarak 
    /etc/ld.so.cache dosyasının güncellenmesini sağlamak

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------*/

